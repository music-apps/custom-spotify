(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
"use strict";const i18n=require("../../../libs/spotify-i18n")({ar:require("./json/ar.json"),cs:require("./json/cs.json"),de:require("./json/de.json"),el:require("./json/el.json"),en:require("./json/en.json"),es:require("./json/es.json"),"es-419":require("./json/es-419.json"),fi:require("./json/fi.json"),fr:require("./json/fr.json"),"fr-CA":require("./json/fr-CA.json"),hu:require("./json/hu.json"),id:require("./json/id.json"),it:require("./json/it.json"),ja:require("./json/ja.json"),nl:require("./json/nl.json"),pl:require("./json/pl.json"),"pt-BR":require("./json/pt-BR.json"),sv:require("./json/sv.json"),th:require("./json/th.json"),tr:require("./json/tr.json"),vi:require("./json/vi.json"),"zh-Hant":require("./json/zh-Hant.json"),ms:require("./json/ms.json")});module.exports=i18n;

},{"../../../libs/spotify-i18n":301,"./json/ar.json":2,"./json/cs.json":3,"./json/de.json":4,"./json/el.json":5,"./json/en.json":6,"./json/es-419.json":7,"./json/es.json":8,"./json/fi.json":9,"./json/fr-CA.json":10,"./json/fr.json":11,"./json/hu.json":12,"./json/id.json":13,"./json/it.json":14,"./json/ja.json":15,"./json/ms.json":16,"./json/nl.json":17,"./json/pl.json":18,"./json/pt-BR.json":19,"./json/sv.json":20,"./json/th.json":21,"./json/tr.json":22,"./json/vi.json":23,"./json/zh-Hant.json":24}],2:[function(require,module,exports){
module.exports={
  "app.name": "الكلمات",
  "app.description": "APP-SKELETON-ID",
  "app.offlineTitle": "كلمات الأغاني غير متوفرة خارج شبكة الإنترنت",
  "app.offlineMessage": "يرجى الاتصال بشبكة الإنترنت للتحميل.",
  "app.errorTitle": "خطأ",
  "app.errorMessage": "عذراً! الكلمات غير متوفرة. يرجى المحاولة لاحقاً.",
  "app.noLyrics0": "حسناً. ولا نعرف الكلمات أيضاً.",
  "app.noLyrics1": "عذراً. يبدو أنه ليس لدينا كلمات لهذه الأغنية.",
  "app.noLyrics2": "عذراً، ما زلنا نعمل على حل هذا الأمر.",
  "app.noLyrics3": "نرجو تقبل اعتذارنا! عليك أن تخمّن كلمات هذه الأغنية بنفسك.",
  "app.contextMenuToolTip": "المزيد",
  "app.optionsButtonLabel": "خيارات",
  "app.optionsMenuToggleLabel": "شاشة خلفية محركة",
  "app.attributionText": "يتم توفير الكلمات من قبل ",
  "app.attribution_link": "مزامنة هذه الكلمات",
  "app.no_service_title": "الموسيقى ممتعة.",
  "app.no_service_body": "لمحبي كلمات الأغاني، نجري الآن بعض التحسينات الكبيرة، لذا فإنّ خاصية عرض كلمات الأغاني غير متوفرة حالياًً. ترقبوا التحديثات."
}
},{}],3:[function(require,module,exports){
module.exports={
  "app.name": "Text skladby",
  "app.description": "APP-SKELETON-ID",
  "app.offlineTitle": "Texty nejsou k dispozici offline",
  "app.offlineMessage": "Pro načtení přejdi prosím online.",
  "app.errorTitle": "Chyba",
  "app.errorMessage": "Je nám líto! Texty nejsou k dispozici. Zkus to prosím znovu.",
  "app.noLyrics0": "Hmmm. My text také neznáme.",
  "app.noLyrics1": "Jejda. Vypadá to, že text k téhle skladbě nemáme.",
  "app.noLyrics2": "Teď jsi nás načapal/a, pořád ještě na tom pracujeme.",
  "app.noLyrics3": "Moc se omlouváme! Text téhle skladby si budeš muset odposlechnout sám/sama.",
  "app.contextMenuToolTip": "dalších",
  "app.optionsButtonLabel": "Možnosti",
  "app.optionsMenuToggleLabel": "Animované pozadí",
  "app.attributionText": "Text ti přináší ",
  "app.attribution_link": "Synchronizovat tyto texty",
  "app.no_service_title": "Broukání je zábava.",
  "app.no_service_body": "Zdravíme tě, fanoušku textů, právě provádíme výrazná vylepšení, naše funkce zobrazování textů proto momentálně není k dispozici. Sleduj, jak se bude situace vyvíjet."
}
},{}],4:[function(require,module,exports){
module.exports={
  "app.name": "Songtexte",
  "app.description": "APP-SKELETON-ID",
  "app.offlineTitle": "Songtexte offline nicht verfügbar",
  "app.offlineMessage": "Geh zum Laden online.",
  "app.errorTitle": "Fehler",
  "app.errorMessage": "Sorry, die Songtexte sind momentan nicht verfügbar. Versuche es später bitte noch einmal.",
  "app.noLyrics0": "Leider kennen wir den Songtext auch nicht.",
  "app.noLyrics1": "Leider haben wir den Text zu diesem Song nicht.",
  "app.noLyrics2": "Da hast Du uns eiskalt erwischt. Wir arbeiten noch daran.",
  "app.noLyrics3": "Leider ist der Text zu diesem Song nicht verfügbar.",
  "app.contextMenuToolTip": "Mehr",
  "app.optionsButtonLabel": "Optionen",
  "app.optionsMenuToggleLabel": "Animierter Hintergrund",
  "app.attributionText": "Songtexte bereitgestellt von ",
  "app.attribution_link": "Songtexte synchronisieren",
  "app.no_service_title": "Einfach mitsummen!",
  "app.no_service_body": "Du singst gern mit, wenn Du Musik hörst? Leider ist unser Feature für Songtexte derzeit nicht verfügbar, weil wir einige tolle Verbesserungen daran vornehmen. Bald gibt es weitere Informationen dazu."
}
},{}],5:[function(require,module,exports){
module.exports={
  "app.name": "Στίχοι",
  "app.description": "APP-SKELETON-ID",
  "app.offlineTitle": "Οι στίχοι δεν είναι διαθέσιμοι εκτός σύνδεσης",
  "app.offlineMessage": "Συνδέσου στο διαδίκτυο για να πραγματοποιηθεί φόρτωση.",
  "app.errorTitle": "Σφάλμα",
  "app.errorMessage": "Δυστυχώς, οι στίχοι δεν είναι διαθέσιμοι. Δοκίμασε ξανά.",
  "app.noLyrics0": "Χμ. Ούτε κι εμείς ξέρουμε τους στίχους.",
  "app.noLyrics1": "Ωχ! Όπως φαίνεται, δεν έχουμε τους στίχους για αυτό το τραγούδι.",
  "app.noLyrics2": "Μας τσάκωσες, δεν το έχουμε ακόμα έτοιμο.",
  "app.noLyrics3": "Άσχημα νέα! Θα πρέπει να μαντέψεις τους στίχους αυτού του τραγουδιού.",
  "app.contextMenuToolTip": "Περισσότερα",
  "app.optionsButtonLabel": "Επιλογές",
  "app.optionsMenuToggleLabel": "Κινούμενο φόντο",
  "app.attributionText": "Οι στίχοι παρέχονται από:  ",
  "app.attribution_link": "Συγχρονισμός αυτών των στίχων",
  "app.no_service_title": "Είναι ωραίο να σιγομουρμουρίζεις τα κομμάτια.",
  "app.no_service_body": "Για όλους τους φαν των στίχων, ετοιμάζουμε μεγάλες βελτιώσεις, γι' αυτό και προς το παρόν η λειτουργία στίχων δεν είναι διαθέσιμη. Μείνετε συντονισμένοι για ενημερώσεις."
}
},{}],6:[function(require,module,exports){
module.exports={
  "app.name": "Lyrics",
  "app.description": "APP-SKELETON-ID",
  "app.offlineTitle": "Lyrics not Available Offline",
  "app.offlineMessage": "Please go online to load.",
  "app.errorTitle": "Error",
  "app.errorMessage": "Sorry! Lyrics not available. Please try again.",
  "app.noLyrics0": "Hmmm. We don’t know the lyrics either.",
  "app.noLyrics1": "Uh oh. It looks like we don’t have the lyrics to this song.",
  "app.noLyrics2": "You caught us, we’re still working on this one.",
  "app.noLyrics3": "So sorry! You’ll have to guess the lyrics for this one.",
  "app.contextMenuToolTip": "More",
  "app.optionsButtonLabel": "Options",
  "app.optionsMenuToggleLabel": "Animated Background",
  "app.attributionText": "Lyrics provided by ",
  "app.attribution_link": "Sync these lyrics",
  "app.no_service_title": "Humming is fun.",
  "app.no_service_body": "Hey lyrics fans, we're making some big improvements, so our lyrics feature is unavailable right now. Stay tuned for updates."
}
},{}],7:[function(require,module,exports){
module.exports={
  "app.name": "Letras",
  "app.description": "APP-SKELETON-ID",
  "app.offlineTitle": "Letras no disponibles sin conexión",
  "app.offlineMessage": "Conéctate a la red para cargar.",
  "app.errorTitle": "Error",
  "app.errorMessage": "Lo sentimos, las letras no están disponibles. Inténtalo de nuevo.",
  "app.noLyrics0": "Mmmm. Nosotros tampoco sabemos la letra.",
  "app.noLyrics1": "Oh, oh. Parece que no tenemos la letra de esta canción.",
  "app.noLyrics2": "¡Nos atrapaste! Todavía estamos trabajando en esto.",
  "app.noLyrics3": "¡Lo sentimos! Tendrás que adivinar la letra para esta canción.",
  "app.contextMenuToolTip": "Más",
  "app.optionsButtonLabel": "Opciones",
  "app.optionsMenuToggleLabel": "Fondo animado",
  "app.attributionText": "Letras proporcionadas por ",
  "app.attribution_link": "Sincronizar esta letra",
  "app.no_service_title": "Tararear es divertido.",
  "app.no_service_body": "¡Atención fans de las letras! La funcionalidad Letras no está disponible en este momento porque estamos trabajando para incorporar grandes mejoras. ¡No se pierdan las próximas actualizaciones!"
}
},{}],8:[function(require,module,exports){
module.exports={
  "app.name": "Letra",
  "app.description": "APP-SKELETON-ID",
  "app.offlineTitle": "Las letras no están disponibles sin conexión",
  "app.offlineMessage": "Por favor, conéctate para cargar.",
  "app.errorTitle": "Error",
  "app.errorMessage": "Lo sentimos, pero no hemos podido acceder a las letras. Por favor, inténtalo de nuevo.",
  "app.noLyrics0": "Lo cierto es que nosotros tampoco sabemos la letra.",
  "app.noLyrics1": "¡Vaya! Parece que no tenemos la letra de esta canción.",
  "app.noLyrics2": "¡Nos has pillado! En esta todavía estamos trabajando.",
  "app.noLyrics3": "Lo sentimos mucho, pero la letra de esta vas a tener que adivinarla.",
  "app.contextMenuToolTip": "Más",
  "app.optionsButtonLabel": "Opciones",
  "app.optionsMenuToggleLabel": "Fondo animado",
  "app.attributionText": "Letra proporcionada por ",
  "app.attribution_link": "Sincronizar esta letra",
  "app.no_service_title": "Tararear también es divertido.",
  "app.no_service_body": "Hola, amantes de las letras. Estamos de grandes reformas, por lo que nuestra función Letras no está disponible en estos momentos. ¡Pronto habrá novedades!"
}
},{}],9:[function(require,module,exports){
module.exports={
  "app.name": "Sanat",
  "app.description": "APP-SKELETON-ID",
  "app.offlineTitle": "Sanat eivät ole käytettävissä offline-tilassa",
  "app.offlineMessage": "Siirry online-tilaan, jotta voit ladata.",
  "app.errorTitle": "Virhe",
  "app.errorMessage": "Valitettavasti sanoja ei ole saatavilla. Yritä uudelleen.",
  "app.noLyrics0": "Hmm. Mekään emme tiedä sanoja.",
  "app.noLyrics1": "Hupsista. Näyttää siltä, ettei meillä ole sanoja tähän kappaleeseen.",
  "app.noLyrics2": "Kiinni jäimme, tämä on edelleen työn alla.",
  "app.noLyrics3": "Pahoittelumme! Sinun on vain koetettava arvata tämän kappaleen sanat.",
  "app.contextMenuToolTip": "Lisää",
  "app.optionsButtonLabel": "Vaihtoehdot",
  "app.optionsMenuToggleLabel": "Animoitu tausta",
  "app.attributionText": "Sanat tarjoaa ",
  "app.attribution_link": "Synkronoi sanat",
  "app.no_service_title": "Hyräilykin on kivaa.",
  "app.no_service_body": "Hei sanoitusten ystävä, teemme juuri isoja päivityksiä, joten sanat-ominaisuus ei tällä hetkellä ole käytössä. Pysy kuulolla."
}
},{}],10:[function(require,module,exports){
module.exports={
  "app.name": "Paroles",
  "app.description": "APP-SKELETON-ID",
  "app.offlineTitle": "Paroles non disponibles hors ligne",
  "app.offlineMessage": "Veuillez accéder à Internet pour charger le contenu.",
  "app.errorTitle": "Erreur",
  "app.errorMessage": "Nous sommes désolés! Les paroles ne sont pas disponibles. Veuillez réessayer.",
  "app.noLyrics0": "Hum! Nous ignorons également les paroles.",
  "app.noLyrics1": "Oh oh. Il semble que nous n'avons pas les paroles de cette chanson.",
  "app.noLyrics2": "Vous nous avez devancés, nous travaillons encore sur celles-ci.",
  "app.noLyrics3": "Nous sommes vraiment désolés! Vous devrez deviner ces paroles-ci.",
  "app.contextMenuToolTip": "Plus",
  "app.optionsButtonLabel": "Options",
  "app.optionsMenuToggleLabel": "Arrière-plan animé",
  "app.attributionText": "Paroles fournies par ",
  "app.attribution_link": "Synchronise ces paroles",
  "app.no_service_title": "On s'amuse à fredonner.",
  "app.no_service_body": "Hey les amateurs de paroles, nous apportons de nettes améliorations, notre fonctionnalité de paroles n'est pas disponible pour le moment. Reste à l'écoute pour connaître les mises à jour."
}
},{}],11:[function(require,module,exports){
module.exports={
  "app.name": "Paroles",
  "app.description": "APP-SKELETON-ID",
  "app.offlineTitle": "Les paroles ne sont pas disponibles hors connexion.",
  "app.offlineMessage": "Connectez-vous pour procéder au chargement.",
  "app.errorTitle": "Erreur",
  "app.errorMessage": "Désolé, les paroles ne sont pas disponibles. Merci de réessayer plus tard.",
  "app.noLyrics0": "Hmmm. Nous ne connaissons pas non plus les paroles.",
  "app.noLyrics1": "Oups. Il semble que nous ne disposions pas des paroles de cette chanson.",
  "app.noLyrics2": "Vous nous avez pris de court. Nous cherchons toujours une solution à ce problème.",
  "app.noLyrics3": "Nous sommes vraiment désolés ! Vous allez devoir deviner les paroles de ce titre.",
  "app.contextMenuToolTip": "Plus",
  "app.optionsButtonLabel": "Options",
  "app.optionsMenuToggleLabel": "Arrière-plan animé",
  "app.attributionText": "Paroles fournies par ",
  "app.attribution_link": "Synchroniser ces paroles",
  "app.no_service_title": "Le plaisir de fredonner.",
  "app.no_service_body": "Chers utilisateurs, nous apportons d'importantes améliorations à la fonctionnalité Paroles, c'est pourquoi elle est momentanément indisponible. Restez à l'affût des mises à jour !"
}
},{}],12:[function(require,module,exports){
module.exports={
  "app.name": "Dalszöveg",
  "app.description": "APP-SKELETON-ID",
  "app.offlineTitle": "A dalszöveg offline módban nem érhető el",
  "app.offlineMessage": "Csatlakozz az internethez, majd indítsd el.",
  "app.errorTitle": "Hiba",
  "app.errorMessage": "Sajnáljuk, a dalszöveg nem érhető el. Próbálkozz újra.",
  "app.noLyrics0": "Hmmm. Ennek a dalnak a szövegét mi sem tudjuk.",
  "app.noLyrics1": "Ajjaj... Úgy tűnik, ehhez a számhoz nincs meg a dalszöveg.",
  "app.noLyrics2": "Most lebuktunk. Ezen a dalszövegen még dolgozunk.",
  "app.noLyrics3": "Ezer bocs! Ehhez a számhoz neked kell kihallanod a dalszöveget.",
  "app.contextMenuToolTip": "Több",
  "app.optionsButtonLabel": "Opciók",
  "app.optionsMenuToggleLabel": "Mozgó háttér",
  "app.attributionText": "Dalszöveg: ",
  "app.attribution_link": "Dalszöveg szinkronizálása",
  "app.no_service_title": "Dúdolni jó.",
  "app.no_service_body": "Dalszövegek szerelmesei! Nagy változtatásokat végzünk, ezért nem érhető el most a dalszöveg funkció. Hamarosan többet is elárulunk."
}
},{}],13:[function(require,module,exports){
module.exports={
  "app.name": "Lirik",
  "app.description": "APP-SKELETON-ID",
  "app.offlineTitle": "Lirik tidak Tersedia Offline",
  "app.offlineMessage": "Alihkan ke online untuk memuat.",
  "app.errorTitle": "Kesalahan",
  "app.errorMessage": "Maaf! Lirik tidak tersedia. Silakan coba lagi.",
  "app.noLyrics0": "Hmmm. Kami juga tidak tahu liriknya.",
  "app.noLyrics1": "Aduh. Kelihatannya kami tidak memiliki lirik lagu ini.",
  "app.noLyrics2": "Kamu menangkap basah kami, kami masih mengerjakannya.",
  "app.noLyrics3": "Maaf! Kamu harus menebak lirik lagu ini.",
  "app.contextMenuToolTip": "Lainnya",
  "app.optionsButtonLabel": "Opsi ",
  "app.optionsMenuToggleLabel": "Latar Belakang Bergerak",
  "app.attributionText": "Lirik disediakan oleh ",
  "app.attribution_link": "Sinkronkan lirik ini",
  "app.no_service_title": "Bersenandung itu menyenangkan.",
  "app.no_service_body": "Hai para penggemar lirik, kami membuat sejumlah peningkatan besar, jadi saat ini fitur lirik kami tidak tersedia. Nantikan informasi selanjutnya."
}
},{}],14:[function(require,module,exports){
module.exports={
  "app.name": "Testo",
  "app.description": "APP-SKELETON-ID",
  "app.offlineTitle": "Testo non disponibile offline",
  "app.offlineMessage": "Passa online per caricare.",
  "app.errorTitle": "Errore",
  "app.errorMessage": "Ci dispiace, il testo non è disponibile. Riprova.",
  "app.noLyrics0": "Ci dispiace, anche noi non sappiamo il testo.",
  "app.noLyrics1": "Ci dispiace, il testo per questa canzone non è disponibile.",
  "app.noLyrics2": "Stiamo lavorando per aggiungerlo.",
  "app.noLyrics3": "Ci dispiace, per questo brano dovrai indovinare le parole.",
  "app.contextMenuToolTip": "Più",
  "app.optionsButtonLabel": "Opzioni",
  "app.optionsMenuToggleLabel": "Sfondo animato",
  "app.attributionText": "Testi forniti da ",
  "app.attribution_link": "Sincronizza testo",
  "app.no_service_title": "Canticchiare è divertente.",
  "app.no_service_body": "Ciao appassionati di testi. Al momento la funzione non è disponibile perché stiamo lavorando per migliorarla. Avrete presto novità."
}
},{}],15:[function(require,module,exports){
module.exports={
  "app.name": "歌詞",
  "app.description": "APP-SKELETON-ID",
  "app.offlineTitle": "歌詞はオフラインでは表示できません。",
  "app.offlineMessage": "ロードするには、インターネットに接続してください。",
  "app.errorTitle": "エラー",
  "app.errorMessage": "歌詞を表示できません。後でまた試してください。",
  "app.noLyrics0": "この曲の歌詞に関しては現在確認中です。",
  "app.noLyrics1": "この曲の歌詞に関しては現在確認中です。",
  "app.noLyrics2": "この曲の歌詞に関しては現在確認中です。",
  "app.noLyrics3": "この曲の歌詞に関しては現在確認中です。",
  "app.contextMenuToolTip": "詳細",
  "app.optionsButtonLabel": "オプション",
  "app.optionsMenuToggleLabel": "動画バックグラウンド",
  "app.attributionText": "歌詞提供： ",
  "app.attribution_link": "この歌詞を同期する",
  "app.no_service_title": "鼻歌って楽しい。",
  "app.no_service_body": "歌詞を楽しみにしている方へ。大きな改善を行っている最中なので、歌詞機能は現在使用できません。アップデートをお楽しみに。"
}
},{}],16:[function(require,module,exports){
module.exports={
  "app.name": "Lirik",
  "app.description": "APP-SKELETON-ID",
  "app.offlineTitle": "Lirik tidak Tersedia di Luar Talian",
  "app.offlineMessage": "Sila ke online untuk memuatkan.",
  "app.errorTitle": "Ralat",
  "app.errorMessage": "Maaf! Lirik tidak tersedia. Sila cuba lagi.",
  "app.noLyrics0": "Hmm. Kami pun tidak tahu liriknya.",
  "app.noLyrics1": "Alamak. Nampaknya kami tiada lirik untuk lagu ini.",
  "app.noLyrics2": "Kami mengaku, kami masih berusaha untuk yang ini.",
  "app.noLyrics3": "Maaf! Anda perlu meneka lirik untuk lagu ini.",
  "app.contextMenuToolTip": "Lebih banyak",
  "app.optionsButtonLabel": "Pilihan",
  "app.optionsMenuToggleLabel": "Latar Belakang Animasi",
  "app.attributionText": "Lirik disediakan oleh ",
  "app.attribution_link": "Segerakkan lirik ini",
  "app.no_service_title": "Bersenandung adalah menyeronokkan.",
  "app.no_service_body": "Hei peminat lirik, kami sedang membuat beberapa penambahbaikan yang besar, jadi ciri lirik kami tidak tersedia pada masa ini. Nantikan maklumat terkini."
}
},{}],17:[function(require,module,exports){
module.exports={
  "app.name": "Songteksten",
  "app.description": "APP-SKELETON-ID",
  "app.offlineTitle": "Songteksten niet offline beschikbaar",
  "app.offlineMessage": "Ga online om te laden.",
  "app.errorTitle": "Fout",
  "app.errorMessage": "Helaas, er zijn geen songteksten beschikbaar. Probeer het later opnieuw.",
  "app.noLyrics0": "Hmmm. Deze teksten kennen we ook niet.",
  "app.noLyrics1": "Uh-oh! We hebben geen songteksten voor dit nummer.",
  "app.noLyrics2": "Ja, goed gezien. We werken hier nog aan.",
  "app.noLyrics3": "Sorry, helaas hebben we deze lyrics niet.",
  "app.contextMenuToolTip": "Meer",
  "app.optionsButtonLabel": "Opties",
  "app.optionsMenuToggleLabel": "Geanimeerde achtergrond",
  "app.attributionText": "Songteksten aangeleverd door ",
  "app.attribution_link": "Deze songteksten synchroniseren",
  "app.no_service_title": "Neuriën is leuk.",
  "app.no_service_body": "Voor de fans van songteksten zijn we een aantal grote verbeteringen aan het doorvoeren. Onze songtekstenfunctie is daarom nu niet beschikbaar. Blijf ons volgen voor updates."
}
},{}],18:[function(require,module,exports){
module.exports={
  "app.name": "Teksty",
  "app.description": "APP-SKELETON-ID",
  "app.offlineTitle": "Teksty są niedostępne offline",
  "app.offlineMessage": "Przejdź do trybu online, aby załadować.",
  "app.errorTitle": "Błąd",
  "app.errorMessage": "Niestety, tekst jest niedostępny. Spróbuj ponownie.",
  "app.noLyrics0": "Hmmm. My też nie znamy tekstu.",
  "app.noLyrics1": "Och nie. Wygląda na to, że nie mamy tekstu tego utworu.",
  "app.noLyrics2": "Niestety, ciągle nad tym pracujemy.",
  "app.noLyrics3": "Tak nam przykro! Wygląda na to, że musisz odgadnąć tekst tego utworu.",
  "app.contextMenuToolTip": "Więcej",
  "app.optionsButtonLabel": "Opcje",
  "app.optionsMenuToggleLabel": "Animowane tło",
  "app.attributionText": "Teksty udostępniane przez ",
  "app.attribution_link": "Zsynchronizuj te teksty",
  "app.no_service_title": "Wszyscy lubimy nucić.",
  "app.no_service_body": "Hej miłośnicy tekstów piosenek, właśnie pracujemy nad ulepszeniami, więc chwilowo ta funkcja nie jest dostępna."
}
},{}],19:[function(require,module,exports){
module.exports={
  "app.name": "Letra",
  "app.description": "APP-SKELETON-ID",
  "app.offlineTitle": "Letra não disponível offline",
  "app.offlineMessage": "Fique online para carregar.",
  "app.errorTitle": "Erro",
  "app.errorMessage": "Desculpe! A letra não está disponível. Tente de novo.",
  "app.noLyrics0": "Hummm. A gente também não sabe essa letra.",
  "app.noLyrics1": "Eita. Parece que a gente não tem a letra dessa música.",
  "app.noLyrics2": "Vixe! Ainda estamos trabalhando nessa.",
  "app.noLyrics3": "Foi mal! Parece que você vai ter que improvisar dessa vez.",
  "app.contextMenuToolTip": "Mais",
  "app.optionsButtonLabel": "Opções",
  "app.optionsMenuToggleLabel": "Fundo animado",
  "app.attributionText": "Letra disponibilizada por ",
  "app.attribution_link": "Sincronizar esta letra",
  "app.no_service_title": "Cantarolar sem a letra também é divertido.",
  "app.no_service_body": "Fãs de letras, estamos fazendo melhorias muito legais, por isso esse recurso não está disponível. Fiquem de olho nas atualizações."
}
},{}],20:[function(require,module,exports){
module.exports={
  "app.name": "Låttexter",
  "app.description": "APP-SKELETON-ID",
  "app.offlineTitle": "Låttexter är inte tillgängliga offline",
  "app.offlineMessage": "Anslut till internet om du vill läsa in appen.",
  "app.errorTitle": "Fel",
  "app.errorMessage": "Den här låttexten är tyvärr inte tillgänglig. Försök igen.",
  "app.noLyrics0": "Hm … Vi kan inte heller låttexten.",
  "app.noLyrics1": "Oj då. Vi verkar inte ha texten till den här låten.",
  "app.noLyrics2": "Du kom på oss. Vi är inte klara här än.",
  "app.noLyrics3": "Beklagar! Du får gissa texten till den här låten.",
  "app.contextMenuToolTip": "Mer",
  "app.optionsButtonLabel": "Alternativ",
  "app.optionsMenuToggleLabel": "Animerad bakgrund",
  "app.attributionText": "Låttexter från ",
  "app.attribution_link": "Synka låttexterna",
  "app.no_service_title": "Det är kul att nynna.",
  "app.no_service_body": "Hej alla låttextfans! Vi gör förbättringar så låttextfunktionen är inte tillgänglig just nu. Men kom ihåg att kolla efter uppdateringar."
}
},{}],21:[function(require,module,exports){
module.exports={
  "app.name": "เนื้อเพลง",
  "app.description": "APP-SKELETON-ID",
  "app.offlineTitle": "เนื้อเพลงไม่สามารถใช้งานขณะออฟไลน์ได้",
  "app.offlineMessage": "โปรดใช้งานแบบออนไลน์เพื่อโหลด",
  "app.errorTitle": "ผิดพลาด",
  "app.errorMessage": "ขออภัย เนื้อเพลงไม่พร้อมใช้งาน โปรดลองอีกครั้ง",
  "app.noLyrics0": "อืมม เราก็ไม่รู้เนื้อเพลงนี้เหมือนกัน",
  "app.noLyrics1": "โอ๊ะโอ ดูเหมือนว่าเราจะไม่มีเนื้อเพลงของเพลงนี้",
  "app.noLyrics2": "โดนจับได้ซะแล้วว่าเรายังจัดการตรงนี้ไม่เสร็จ",
  "app.noLyrics3": "ขออภัยอย่างยิ่ง! คุณคงต้องเดาเนื้อเพลงนี้ไปก่อน",
  "app.contextMenuToolTip": "เพิ่มเติม",
  "app.optionsButtonLabel": "ตัวเลือก",
  "app.optionsMenuToggleLabel": "ภาพพื้นหลังเคลื่อนไหวได้",
  "app.attributionText": "เนื้อเพลงป้อนโดย ",
  "app.attribution_link": "ซิงค์เนื้อเพลงเหล่านี้",
  "app.no_service_title": "ฮัมเพลงก็สนุกดี",
  "app.no_service_body": "สวัสดีเพื่อนๆ ที่ชอบดูเนื้อเพลง เรากำลังทำการปรับปรุงครั้งใหญ่ เนื้อเพลงจึงไม่พร้อมให้บริการในขณะนี้ โปรดคอยติดตามการอัพเดต"
}
},{}],22:[function(require,module,exports){
module.exports={
  "app.name": "Şarkı sözleri",
  "app.description": "APP-SKELETON-ID",
  "app.offlineTitle": "Şarkı Sözlerine Çevrimdışı Ulaşılamaz",
  "app.offlineMessage": "Yüklemek için lütfen çevrimiçi ol.",
  "app.errorTitle": "Hata",
  "app.errorMessage": "Üzgünüz! Şarkı sözleri mevcut değil. Lütfen tekrar dene.",
  "app.noLyrics0": "Hmmm. Biz de şarkı sözlerini bilmiyoruz.",
  "app.noLyrics1": "Eyvah. Görünüşe göre bu şarkı için şarkı sözlerine sahip değiliz.",
  "app.noLyrics2": "Bizi yakaladın, hala bunun üzerinde çalışıyoruz.",
  "app.noLyrics3": "Çok üzgünüz! Bu şarkı için şarkı sözlerini tahmin etmen gerekecek.",
  "app.contextMenuToolTip": "Daha fazla",
  "app.optionsButtonLabel": "Seçenekler",
  "app.optionsMenuToggleLabel": "Animasyonlu Arka Plan",
  "app.attributionText": "Şarkı sözlerini sağlayan ",
  "app.attribution_link": "Bu şarkı sözlerini eşitle",
  "app.no_service_title": "Mırıldanmak eğlencelidir.",
  "app.no_service_body": "Şarkı sözü tutkunları için büyük yenilikler yapıyoruz, bu yüzden şarkı sözü özelliğimiz şu anda kullanılamıyor. Güncellemeleri bekleyin."
}
},{}],23:[function(require,module,exports){
module.exports={
  "app.name": "Lời bài hát",
  "app.description": "APP-SKELETON-ID",
  "app.offlineTitle": "Lời bài hát không có ở chế độ Offline",
  "app.offlineMessage": "Vui lòng truy cập trực tuyến để tải.",
  "app.errorTitle": "Lỗi",
  "app.errorMessage": "Rất tiếc! Không có lời bài hát. Vui lòng thử lại.",
  "app.noLyrics0": "Hmmm. Chúng tôi cũng chưa có lời bài hát.",
  "app.noLyrics1": "Ồ. Có vẻ như chúng tôi chưa có lời của bài hát này.",
  "app.noLyrics2": "Bạn thấy đấy, chúng tôi vẫn đang khắc phục vấn đề này.",
  "app.noLyrics3": "Rất tiếc! Bạn sẽ phải đoán lời bài hát này thôi.",
  "app.contextMenuToolTip": "Chi tiết",
  "app.optionsButtonLabel": "Các tùy chọn",
  "app.optionsMenuToggleLabel": "Nền Động",
  "app.attributionText": "Lời bài hát được cung cấp bởi ",
  "app.attribution_link": "Đồng bộ hóa những lời bài hát này",
  "app.no_service_title": "Ngâm nga thật vui.",
  "app.no_service_body": "Này các fan của lời bài hát, chúng tôi đang thực hiện những cải tiến lớn, do vậy tính năng lời bài hát của chúng tôi hiện chưa có. Hãy kiên nhẫn chờ cập nhật."
}
},{}],24:[function(require,module,exports){
module.exports={
  "app.name": "歌詞",
  "app.description": "APP-SKELETON-ID",
  "app.offlineTitle": "離線時不顯示歌詞",
  "app.offlineMessage": "請上網以載入。",
  "app.errorTitle": "錯誤",
  "app.errorMessage": "很抱歉！沒顯示歌詞。請再試一次。",
  "app.noLyrics0": "嗯，我們也不曉得歌詞。",
  "app.noLyrics1": "哎呀。看來我們沒有這首歌的歌詞。",
  "app.noLyrics2": "被你抓到了，我們確實還在努力完成這部分。",
  "app.noLyrics3": "真抱歉！你可能得猜這首歌的歌詞了。",
  "app.contextMenuToolTip": "更多",
  "app.optionsButtonLabel": "選項",
  "app.optionsMenuToggleLabel": "動畫背景",
  "app.attributionText": "歌詞提供者： ",
  "app.attribution_link": "同步這些歌詞",
  "app.no_service_title": "跟著哼唱很好玩。",
  "app.no_service_body": "各位歌詞的愛好者們，由於我們目前正進行一些重大改進，歌詞功能暫時無法使用。敬請隨時注意最新消息。"
}
},{}],25:[function(require,module,exports){
"use strict";var _sentry=require("../../libs/sentry"),sentry=_interopRequireWildcard(_sentry);function _interopRequireWildcard(e){if(e&&e.__esModule)return e;var i={};if(null!=e)for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&(i[r]=e[r]);return i.default=e,i}sentry.install();const FEATURE_ID="lyrics",live=require("../../libs/live"),events=require("../../libs/spotify-events"),liveModels=require("../../libs/live-models");liveModels.register(),events.attach(),events.update();const eventDispatcher=require("../../libs/event-dispatcher"),handlebars=require("../../libs/spotify-handlebars"),helpers=require("../../libs/spotify-handlebars/helpers"),i18n=require("./i18n"),appStrings=i18n.appStrings();helpers.loc.register(appStrings),helpers.numeral.setLocale(i18n.locale()),handlebars.register(helpers);const PlayerListener=require("./src/player_listener"),TrackController=require("./src/track_controller"),LyricsSheetController=require("./src/lyrics_sheet_controller"),LoggingService=require("./src/logging_service"),VisualizationController=require("../../libs/visualization/src/visualization_controller");let _isInitialized=!1;function init(e){_isInitialized=!0;const i=new PlayerListener,r=new LoggingService,t=new VisualizationController(document.getElementById("visualization-container")),n=new TrackController(document.body,document.getElementById("header"),document.getElementById("message-container"),document.getElementById("error"),document.getElementById("options-button-container"),document.getElementById("options-menu-container"),r,t),s=new LyricsSheetController(document.querySelector("div.lyrics-lines-container"),document.getElementById("attribution-container"),r),o={forceNoLyrics:!1,forceNoSyncLyrics:!1,forceOffline:!1},l={printLogs:!1},a={runVisualization:!0,highVisualizationFrameRate:!1,enableOptionsButton:!0};e.arguments&&(o.forceNoLyrics=-1!==e.arguments.indexOf("nolyrics"),o.forceNoSyncLyrics=-1!==e.arguments.indexOf("nosynclyrics"),o.forceOffline=-1!==e.arguments.indexOf("offline"),l.printLogs=-1!==e.arguments.indexOf("log"),a.highVisualizationFrameRate=-1!==e.arguments.indexOf("60fps"),a.noService=-1!==e.arguments.indexOf("noService")),r.init(FEATURE_ID,l),n.init(a),s.init(o),t.init(),i.start(),window.parent.postMessage({type:"notify_ready",pageId:"lyrics"},"*")}live("spotify:application").on("update",function(e){void 0!==e.active&&live("spotify:application").query("arguments",function(i,r){if(i)throw i;_isInitialized||init(r),eventDispatcher.dispatchEvent({type:"appActivated",params:{active:e.active}})})});

},{"../../libs/event-dispatcher":60,"../../libs/live":148,"../../libs/live-models":111,"../../libs/sentry":190,"../../libs/spotify-events":246,"../../libs/spotify-handlebars":298,"../../libs/spotify-handlebars/helpers":287,"../../libs/visualization/src/visualization_controller":351,"./i18n":1,"./src/logging_service":28,"./src/lyrics_sheet_controller":30,"./src/player_listener":35,"./src/track_controller":37}],26:[function(require,module,exports){
"use strict";const attributionTemplate=require("../templates/attribution_view.hbs");function AttributionView(t){this.container=t}AttributionView.prototype.update=function(t){this.container.innerHTML=attributionTemplate(t)},module.exports=AttributionView;

},{"../templates/attribution_view.hbs":40}],27:[function(require,module,exports){
"use strict";const errorTemplate=require("../../../libs/glue/templates/error-and-offline.hbs");function ErrorView(r){this.container=r}ErrorView.prototype.update=function(r){r&&r.errorTitle&&r.errorMessage||(this.container.innerHTML=""),this.container.innerHTML=errorTemplate(r)},ErrorView.prototype.show=function(){this.container.classList.remove("hidden")},ErrorView.prototype.hide=function(){this.container.classList.add("hidden")},module.exports=ErrorView;

},{"../../../libs/glue/templates/error-and-offline.hbs":90}],28:[function(require,module,exports){
"use strict";const UIImpression5=require("../../../libs/logger/messages/UIImpression5"),UIInteraction5=require("../../../libs/logger/messages/UIInteraction5"),eventDispatcher=require("../../../libs/event-dispatcher");function LoggingService(){this.featureId=null,this.active=null,this.printLogs=null,this._loggedItems=null}LoggingService.ImpressionTypes={PAGE:"page",ITEM:"item",SECTION:"section",BLOCK:"block"},LoggingService.InteractionTypes={HIT:"hit",SCROLL:"scroll"},LoggingService.UserIntents={SHOW_LYRICS_FROM_NPB:"show-lyrics-from-npb",SHOW_LYRICS:"show-lyrics",HIDE_LYRICS:"hide-lyrics",SCROLL_LYRICS:"scroll-lyrics",HIDE_OPTIONS_MENU:"hide-options-menu",SHOW_OPTIONS_MENU:"show-options-menu",DISABLE_VISUALIZATIONS:"disable-visualizations",ENABLE_VISUALIZATIONS:"enable-visualizations",SELECT_VISUALIZATION:"select-visualization",LINK_TO_SYNC_LYRICS:"link-to-sync-lyrics"},LoggingService.RenderTypes={PAGE:"page",CARD:"card",BUTTON:"button",LIST:"list",MENU:"menu"},LoggingService.SectionIds={FULLSCREEN:"fullscreen",CARD:"card",NPV:"npv",NO_LYRICS:"no-lyrics",ERROR:"error"},LoggingService.TargetUris={FULLSCREEN:"spotify:app:lyrics:fullscreen",CARD:"spotify:app:lyrics:card"},LoggingService.prototype.init=function(e,i){if(!e)return;const t="object"==typeof i?i:{};this.featureId=e,this.active=!0,this.printLogs=t.printLogs,eventDispatcher.addEventListener("appActivated",this._setAppActivation.bind(this)),eventDispatcher.addEventListener("fetchLyrics",this._resetLoggedItems.bind(this)),this._resetLoggedItems()},LoggingService.prototype.logPageImpression=function(e){if(!e)return;const i={request_id:e,impression_type:LoggingService.ImpressionTypes.PAGE};this._sendUIImpressionMessage(i)},LoggingService.prototype.logSectionImpression=function(e,i){if(!e||!i)return;const t={request_id:e,section_id:i,impression_type:LoggingService.ImpressionTypes.SECTION};this._sendUIImpressionMessage(t)},LoggingService.prototype.logBlockImpression=function(e,i,t){if(!e||!i||!t)return;const s={request_id:e,section_id:i,impression_type:LoggingService.ImpressionTypes.BLOCK,render_type:t};this._sendUIImpressionMessage(s)},LoggingService.prototype.logItemImpression=function(e,i,t,s,n){if(!e||!i||!n||void 0===t)return;const r={request_id:e,section_id:i,item_index:t,impression_type:LoggingService.ImpressionTypes.ITEM,target_uri:s,render_type:n};this._sendUIImpressionMessage(r)},LoggingService.prototype.logItemInteraction=function(e,i,t,s,n,r){if(!e||!n||!r)return;const o={request_id:e,section_id:i,item_index:t,target_uri:s,interaction_type:n,user_intent:r};this._sendUIInteractionMessage(o)},LoggingService.prototype._sendUIImpressionMessage=function(e){if(!e||!this.active)return;const i=this._prepareMessage(e),t=this._createImpressionKey(i);this._loggedItems[t]||(UIImpression5.log(i),this._loggedItems[t]=!0,this.printLogs&&this._printMessage(i))},LoggingService.prototype._sendUIInteractionMessage=function(e){if(!e||!this.active)return;const i=this._prepareMessage(e);UIInteraction5.log(i),this.printLogs&&this._printMessage(i)},LoggingService.prototype._prepareMessage=function(e){return e?(e.feature_id=this.featureId,e.pageuri="spotify:app:lyrics",e.timestamp=Date.now(),e):{}},LoggingService.prototype._setAppActivation=function(e){e.params.active?this.active=!0:this.active=!1},LoggingService.prototype._createImpressionKey=function(e){if(!e)return"";return`${void 0!==e.request_id?e.request_id:""}-${void 0!==e.section_id?e.section_id:""}-${void 0!==e.item_index?e.item_index:""}-${void 0!==e.impression_type?e.impression_type:""}-${void 0!==e.render_type?e.render_type:""}`},LoggingService.prototype._resetLoggedItems=function(){this._loggedItems={}},LoggingService.prototype._printMessage=function(e){console.log(e)},module.exports=LoggingService;

},{"../../../libs/event-dispatcher":60,"../../../libs/logger/messages/UIImpression5":158,"../../../libs/logger/messages/UIInteraction5":159}],29:[function(require,module,exports){
"use strict";const CACHE_EXPIRATION_SECONDS=86400;function LyricsSheet(){this.lines=null,this.kind=null,this.trackId=null,this._cache=[]}LyricsSheet.prototype.update=function(t){const e=t||{};if(this.lines=e.lines,this.kind=e.kind,this.trackId=e.trackId,!this.checkCache(this.trackId)){this.cleanCache();const t=new LyricsSheet;for(const e in this)t.hasOwnProperty(e)&&"_cache"!==e&&(t[e]=this[e]);t.dateAdded=Date.now(),this._cache.push(t)}},LyricsSheet.prototype.checkCache=function(t){if(!t)return!1;const e=this._cache.filter(function(e){return e.trackId===t})[0];return e||!1},LyricsSheet.prototype.cleanCache=function(){for(let t=this._cache.length-1;t>=0;t--)this._cache[t].dateAdded<Date.now()-864e5&&this._cache.splice(t,1)},module.exports=LyricsSheet;

},{}],30:[function(require,module,exports){
"use strict";const eventDispatcher=require("../../../libs/event-dispatcher"),cosmos=require("../../../libs/cosmos-api").default,i18n=require("../i18n/index"),live=require("../../../libs/live"),Utils=require("./utils"),LyricsSheet=require("./lyrics_sheet"),LyricsSheetView=require("./lyrics_sheet_view"),AttributionView=require("./attribution_view"),LoggingService=require("./logging_service"),TOTAL_LINES_DISPLAY=4,NO_LYRICS_MESSAGES=[i18n.get("app.noLyrics0"),i18n.get("app.noLyrics1"),i18n.get("app.noLyrics2"),i18n.get("app.noLyrics3")],ERROR_MESSAGE=i18n.get("app.errorMessage"),SYNC_LYRICS_LINK="http://sp-w.in/KtPYn",offlineOverlay=require("../../../libs/offline-overlay");function LyricsSheetController(e,i,t){this.container=e,this.attributionContainer=i,this.attributionView=null,this.loggingService=t,this.lyricsSheet=null,this._prevLastTrackTimestamp=null,this._lastScrollPosition=0,this._lastScrollDirection=0,this._scrollEventTicking=!1,this._lyricsIndex=-1,this._lastNoLyricsMessage=null,this._hasSyncedLyrics=!1,this._fullScreenContainerHeight=0}LyricsSheetController.prototype.init=function(e){this.options="object"==typeof e?e:{},eventDispatcher.addEventListener("fetchLyrics",this._testOnline.bind(this)),eventDispatcher.addEventListener("checkLyricsIndex",this._checkLyricsIndex.bind(this)),eventDispatcher.addEventListener("updateLyricsDisplay",this._updateLyricsDisplay.bind(this)),eventDispatcher.addEventListener("adPlayback",this._resetLyricsSheet.bind(this)),this.lyricsSheet||(this.lyricsSheet=new LyricsSheet,this.lyricsSheetView=new LyricsSheetView(this.container))},LyricsSheetController.prototype._resetLyricsSheet=function(){this._hasSyncedLyrics=!1,this.lyricsSheet.update(),this.lyricsSheetView.resetView()},LyricsSheetController.prototype._testOnline=function(e){live("spotify:client").query("session(language, online)",(i,t)=>{if(i)throw i;if(t.session.online){if(!e||!e.params.uri)return;this._resetLyricsSheet(),this._fetchLyrics(e.params.uri)}else this._resetLyricsSheet(),offlineOverlay.enable({title:i18n.get("app.offlineTitle"),message:i18n.get("app.offlineMessage"),onWentOnline:function(){window.location.reload()}})})},LyricsSheetController.prototype._fetchLyrics=function(e){const i=Utils.getTrackIdFromUri(e),t=`hm://lyrics/v1/track/${i}`,s=this.lyricsSheet.checkCache(i);s?this._handleFetchLyrics(s,e):cosmos.resolver.get(t,function(i,t){if(500===t._status)return this._hasSyncedLyrics=!1,void this.lyricsSheetView.renderNoLyrics(ERROR_MESSAGE);!i&&200===t._status&&t._body&&""!==t._body?this._handleFetchLyrics(JSON.parse(t._body),e):this._handleFetchLyrics({},e)}.bind(this))},LyricsSheetController.prototype._handleFetchLyrics=function(e,i){if(e){if(this.lyricsSheet.update(e),e.lines&&e.lines.length&&!this.options.forceNoLyrics)!this._checkForSyncData(e)||this.options.forceNoSyncLyrics?(this._hasSyncedLyrics=!1,e.syncLyricsLink=SYNC_LYRICS_LINK,this.lyricsSheetView.renderNoSyncLyrics(e),this.lyricsSheetView.container.addEventListener("click",this._handleSyncLyricsClickEvent.bind(this,i)),this.container.addEventListener("scroll",this._handleScrollEvent.bind(this,i)),setTimeout(this._setFullScreenContainerHeight.bind(this),10),setTimeout(this._logScrollItems.bind(this,i),20),this._logBlockImpression(i,LoggingService.SectionIds.FULLSCREEN),this.attributionView&&this.attributionContainer.classList.remove("nolyrics")):(this._hasSyncedLyrics=!0,this.lyricsSheetView.resetView(),cosmos.resolver.get("sp://player/v2/main/state",function(e,i){if(e)return;const t=JSON.parse(i.toJSON().body),s=t.timestamp;t.position_as_of_timestamp=t.position_as_of_timestamp+Date.now()-s,eventDispatcher.dispatchEvent({type:"updateTrack",params:t})}),this._logBlockImpression(i,LoggingService.SectionIds.CARD),this.attributionView&&this.attributionContainer.classList.remove("nolyrics"));else{this._hasSyncedLyrics=!1;const e=this._getNoLyricsMessage(NO_LYRICS_MESSAGES);this.lyricsSheetView.renderNoLyrics(e),this._logBlockImpression(i,LoggingService.SectionIds.NO_LYRICS),this.attributionView&&this.attributionContainer.classList.add("nolyrics")}!this.attributionView&&e.provider&&(this.attributionView=new AttributionView(this.attributionContainer),this.attributionView.update({text:i18n.get("app.attributionText")+e.provider}))}},LyricsSheetController.prototype._checkForSyncData=function(e){if(!e.lines||!e.lines.length)return!1;let i=!1;return e.lines.map(function(e){void 0!==e.time&&"number"==typeof e.time&&(i=!0)}),i},LyricsSheetController.prototype._updateLyricsDisplay=function(e){if(!e||!e.params||!this._hasSyncedLyrics)return;const i=e.params.lastTrackTimestamp;if(i!==this._prevLastTrackTimestamp){this._prevLastTrackTimestamp=i,this._lyricsIndex=this._getCurrentLyricsIndex(i);const e=this._getNextLines(this._lyricsIndex);this.lyricsSheetView.forceUpdate({lines:e})}},LyricsSheetController.prototype._checkLyricsIndex=function(e){if(!(e&&e.params&&void 0!==e.params.currentProgress&&e.params.trackUri&&this._hasSyncedLyrics))return;const i=e.params.currentProgress,t=-1===this._lyricsIndex?0:this._lyricsIndex;if(t<=this.lyricsSheet.lines.length-1&&(i>this.lyricsSheet.lines[t].time||-1===this._lyricsIndex)){const i=this._getNextLines(this._lyricsIndex);this.lyricsSheetView.update({lines:i}),this._logItemImpression(e.params.trackUri,LoggingService.SectionIds.CARD,this._lyricsIndex,i.length>0?i[0]:""),this._lyricsIndex++}},LyricsSheetController.prototype._getCurrentLyricsIndex=function(e){if(!this.lyricsSheet||!this.lyricsSheet.lines||void 0===e)return 0;const i=this.lyricsSheet.lines;for(let t=0,s=i.length;t<s;t++)if(i[t].time>e)return t-1;return i.length-1},LyricsSheetController.prototype._resetLyricsIndex=function(){this._lyricsIndex=-1},LyricsSheetController.prototype._getNextLines=function(e){const i=-1===e?0:e||0,t=-1===e?[""]:[];for(let e=i;e<i+4;e++)e<=this.lyricsSheet.lines.length-1?t.push(this.lyricsSheet.lines[e].words[0].string):t.push("");return t},LyricsSheetController.prototype._getNoLyricsMessage=function(e){if(!e)return this._lastNoLyricsMessage="","";const i=e[Math.floor(Math.random()*e.length)];return this._lastNoLyricsMessage=i,i},LyricsSheetController.prototype._logBlockImpression=function(e,i){this.loggingService&&this.loggingService.logBlockImpression(e,i,LoggingService.RenderTypes.LIST)},LyricsSheetController.prototype._logItemImpression=function(e,i,t,s){this.loggingService&&-1!==t&&this.loggingService.logItemImpression(e,i,t,s,LoggingService.RenderTypes.LIST)},LyricsSheetController.prototype._handleScrollEvent=function(e){if(!this._scrollEventTicking){let i=1;this.container.scrollTop<this._lastScrollPosition&&(i=-1),window.requestAnimationFrame(this._scrollTick.bind(this,i,e))}this._lastScrollPosition=this.container.scrollTop,this._scrollEventTicking=!0},LyricsSheetController.prototype._scrollTick=function(e,i){e!==this._lastScrollDirection&&(this._lastScrollDirection=e,this.loggingService.logItemInteraction(i,LoggingService.SectionIds.FULLSCREEN,null,null,LoggingService.InteractionTypes.SCROLL,LoggingService.UserIntents.SCROLL_LYRICS)),this._logScrollItems(i),this._scrollEventTicking=!1},LyricsSheetController.prototype._setFullScreenContainerHeight=function(){const e=this.container.firstChild;e&&(this._fullScreenContainerHeight=e.getBoundingClientRect().height)},LyricsSheetController.prototype._logScrollItems=function(e){if(this._fullScreenContainerHeight&&this.lyricsSheet.lines&&this.lyricsSheet.lines.length&&e){const i=this.container.getBoundingClientRect(),t=this.container.firstChild;if(t.children){const s=t.getBoundingClientRect(),r=t.children[0].scrollHeight,n=Math.floor((i.height-s.top)/r),o=Math.ceil(-s.top/r);let c=o<0?0:o;for(;c<n;c++){const i=void 0!==this.lyricsSheet.lines[c].words.length?this.lyricsSheet.lines[c].words[0].string:"";this.loggingService.logItemImpression(e,LoggingService.SectionIds.FULLSCREEN,c,i,LoggingService.RenderTypes.LIST)}}}},LyricsSheetController.prototype._handleSyncLyricsClickEvent=function(e,i){this.loggingService&&"nosync_link"===i.target.id&&this.loggingService.logItemInteraction(e,LoggingService.SectionIds.FULLSCREEN,null,SYNC_LYRICS_LINK,LoggingService.InteractionTypes.HIT,LoggingService.UserIntents.LINK_TO_SYNC_LYRICS)},module.exports=LyricsSheetController;

},{"../../../libs/cosmos-api":54,"../../../libs/event-dispatcher":60,"../../../libs/live":148,"../../../libs/offline-overlay":172,"../i18n/index":1,"./attribution_view":26,"./logging_service":28,"./lyrics_sheet":29,"./lyrics_sheet_view":31,"./utils":39}],31:[function(require,module,exports){
"use strict";const lyricsTemplate=require("../templates/lyrics_view.hbs"),noLyricsTemplate=require("../templates/nolyrics_view.hbs"),noSyncLyricsTemplate=require("../templates/nosynclyrics_view.hbs"),i18n=require("../i18n/index");function LyricsSheetView(e){this.container=e,this.forcedLines=null}LyricsSheetView.prototype.forceUpdate=function(e){this.forcedLines=e.lines,this.resetView();const t=this.container.children;for(let e=t.length-1;e>=1;e--)t[e].textContent=this._decodeHtml(this.forcedLines[e-1])},LyricsSheetView.prototype.update=function(e){const t=e.lines;if(this.forcedLines&&this.forcedLines[0]===t[0])return;let i=this.container.children;const n=i[0];this.container.appendChild(n),i=this.container.children;for(let e=0;e<i.length;e++)i[e].className=`index${e}`;i[i.length-1].textContent=this._decodeHtml(t[t.length-1])},LyricsSheetView.prototype.resetView=function(){this.container.style.overflow="visible",this.container.classList.remove("fullscreen"),this.container.innerHTML=lyricsTemplate()},LyricsSheetView.prototype.renderNoLyrics=function(e){e&&(this.container.style.overflow="auto",this.container.classList.add("fullscreen"),this.container.innerHTML=noLyricsTemplate({message:e}))},LyricsSheetView.prototype.renderNoSyncLyrics=function(e){if(!e)return;const t=e.lines.reduce(function(e,t){return e.concat(t.words[0].string)},[]);this.container.style.overflow="auto",this.container.classList.add("fullscreen"),this.container.innerHTML=noSyncLyricsTemplate({lines:t,attribution_href:e.syncLyricsLink,attribution_link:i18n.get("app.attribution_link")})},LyricsSheetView.prototype._decodeHtml=function(e){if(!e)return"";const t=document.createElement("textarea");return t.innerHTML=e,t.value},module.exports=LyricsSheetView;

},{"../i18n/index":1,"../templates/lyrics_view.hbs":41,"../templates/nolyrics_view.hbs":43,"../templates/nosynclyrics_view.hbs":44}],32:[function(require,module,exports){
"use strict";const noServiceViewTemplate=require("../templates/no_service_view.hbs"),i18n=require("../i18n/index");function NoServiceView(e){this.container=e}NoServiceView.prototype.render=function(){this.container.innerHTML=noServiceViewTemplate({message_title:i18n.get("app.no_service_title"),message_body:i18n.get("app.no_service_body")})},module.exports=NoServiceView;

},{"../i18n/index":1,"../templates/no_service_view.hbs":42}],33:[function(require,module,exports){
"use strict";const optionsButtonTemplate=require("../templates/options_button_view.hbs");function OptionsButtonView(t){this.container=t}OptionsButtonView.prototype.update=function(t){this.container.innerHTML=optionsButtonTemplate(t)},module.exports=OptionsButtonView;

},{"../templates/options_button_view.hbs":45}],34:[function(require,module,exports){
"use strict";const optionsMenuTemplate=require("../templates/options_menu_view.hbs");function OptionsMenuView(e){this.container=e}OptionsMenuView.prototype.update=function(e){const i=e.visualizationNames.concat();i.unshift(i.pop()),e.visualizationNames=i,this.container.innerHTML=optionsMenuTemplate(e),this.animatedBackgroundToggle=this.container.querySelector("#animated-background-toggle > .slider"),this.visualizationSelectContainer=this.container.querySelector("#visualization-select-container"),this.visualizationSelectContainerInnerWrapper=this.visualizationSelectContainer.querySelector(".innerWrapper")},OptionsMenuView.prototype.updateVisualizationSelector=function(e){if(this.visualizationSelectContainerInnerWrapper){const i=parseInt(e,10),t=this.visualizationSelectContainerInnerWrapper,n=t.children;let a;1===i?(a=n[0],t.appendChild(a)):-1===i&&(a=n[n.length-1],t.insertBefore(a,n[0]))}},OptionsMenuView.prototype.disableVisualizationSelect=function(){this.visualizationSelectContainer&&this.visualizationSelectContainer.classList.add("disabled"),this.animatedBackgroundToggle&&this.animatedBackgroundToggle.classList.remove("enabled")},OptionsMenuView.prototype.enableVisualizationSelect=function(){this.visualizationSelectContainer&&this.visualizationSelectContainer.classList.remove("disabled"),this.animatedBackgroundToggle&&this.animatedBackgroundToggle.classList.add("enabled")},module.exports=OptionsMenuView;

},{"../templates/options_menu_view.hbs":46}],35:[function(require,module,exports){
"use strict";const cosmos=require("../../../libs/cosmos-api").default,eventDispatcher=require("../../../libs/event-dispatcher");function PlayerListener(){this._onCosmosEvent=this._onCosmosEvent.bind(this)}PlayerListener.prototype.start=function(){cosmos.resolver.subscribe("sp://player/v2/main",this._onCosmosEvent)},PlayerListener.prototype.stop=function(){cosmos.resolver.unsubscribe("sp://player/v2/main",this._onCosmosEvent)},PlayerListener.prototype._onCosmosEvent=function(e,t){if(e)return;const s=t.getJSONBody();s.track&&"ad"===s.track.provider?eventDispatcher.dispatchEvent({type:"adPlayback",params:s}):s.track&&s.track.metadata&&eventDispatcher.dispatchEvent({type:"updateTrack",params:s})},module.exports=PlayerListener;

},{"../../../libs/cosmos-api":54,"../../../libs/event-dispatcher":60}],36:[function(require,module,exports){
"use strict";function Track(){this.uri=null,this.title=null,this.artist_name=null,this.artist_uri=null,this.duration=0}Track.prototype.update=function(t,i,r){const s=t||{},u=i||{},a=void 0!==r?r:0;this.uri=s.uri,this.title=u.title,this.artist_name=u.artist_name,this.artist_uri=u.artist_uri,this.duration=a},module.exports=Track;

},{}],37:[function(require,module,exports){
"use strict";const eventDispatcher=require("../../../libs/event-dispatcher"),cosmos=require("../../../libs/cosmos-api").default,Track=require("./track"),TrackView=require("./track_view"),ErrorView=require("./error_view"),OptionsButtonView=require("./options_button_view"),OptionsMenuView=require("./options_menu_view"),ColorPalette=require("../../../libs/visualization/src/palette/color_palette"),LoggingService=require("./logging_service"),VisualizationManifest=require("../../../libs/visualization/src/visualization/visualizations/manifest"),i18n=require("../i18n/index"),abba=require("../../../libs/abba"),NoServiceView=require("./no_service_view"),PROGRESS_INTERVAL=20,LYRICS_INTERVAL=100;function TrackController(t,i,e,r,s,o,n,a){this.background=t,this.container=i,this.messageContainer=e,this.errorContainer=r,this.optionsButtonContainer=s,this.optionsMenuContainer=o,this.optionsMenuView=null,this.loggingService=n,this.visualizationController=a,this.active=null,this.playing=null,this.track=null,this.trackView=null,this.errorView=null,this.colorPalette=null,this._currentProgress=null,this._playback_id=null,this._progressInterval=null,this._lyricsInterval=null,this._lastPlayTime=Date.now(),this._lastTrackTimestamp=0,this._optionsMenuActive=-1,this._visualizationActive=1,this._visualizationIndex=0}TrackController.prototype.init=function(t){this.options="object"==typeof t?t:{},this.colorPalette=new ColorPalette,this.options.runVisualization&&(this._updateVisualization(),this.visualizationController.play(this.options.highVisualizationFrameRate)),this.track=new Track,this.trackView=new TrackView(this.container),abba.fetch(["ab-lyrics-market-km","ab-lyrics-thailand-holdout","ab-lyrics-thailand-rollout","ab-lyrics-thailand","ab-lyrics-vietnam-rollout","ab-lyrics-vietnam","ab-lyrics-vietnam-holdout"]).then(t=>this._checkABFlags(null,t),t=>this._checkABFlags(t)),eventDispatcher.addEventListener("appActivated",this._handleAppActivation.bind(this)),eventDispatcher.addEventListener("adPlayback",this._clearTrack.bind(this))},TrackController.prototype._checkABFlags=function(t,i){const e=Object.values(i||{}).some(t=>"Enabled"===t);if(!e||this.options.noService)this._createNoServiceMessage(),eventDispatcher.addEventListener("updateTrack",this._updateTrackNoService.bind(this));else if(e){if(this.options.enableOptionsButton){new OptionsButtonView(this.optionsButtonContainer).update({label:i18n.get("app.optionsButtonLabel")}),this.optionsButtonContainer.addEventListener("mouseup",this._handleOptionsButton.bind(this)),this.optionsMenuContainer.addEventListener("mouseup",this._handleOptionsMenu.bind(this))}eventDispatcher.addEventListener("updateTrack",this._updateTrack.bind(this))}},TrackController.prototype._createNoServiceMessage=function(){this._updateColorPalette(),this.noServiceView=new NoServiceView(this.messageContainer),this.noServiceView.render()},TrackController.prototype._updateTrackNoService=function(t){const i=t.params;this.track.update(i.track,i.track.metadata,i.duration),this.trackView.update({track_uri:this.track.uri,track_title:this.track.title,artist_name:this.track.artist_name,artist_uri:this.track.artist_uri})},TrackController.prototype._updateTrack=function(t){if(!(t&&t.params&&t.params.track&&this.active))return;const i=t.params;if(this.errorContainer&&this._hideError(),this.playing=this._isPlaying(i),this.playing){this._startLyricsInterval();const t=VisualizationManifest[this._visualizationIndex];t&&t.reactive&&this._startProgressInterval()}else this._stopLyricsInterval(),this._stopProgressInterval();this._lastPlayTime=Date.now(),this._lastTrackTimestamp=i.position_as_of_timestamp,this._playback_id===i.playback_id&&this._playback_id?eventDispatcher.dispatchEvent({type:"updateLyricsDisplay",params:{lastTrackTimestamp:this._lastTrackTimestamp}}):(this._playback_id=i.playback_id,this.track.update(i.track,i.track.metadata,i.duration),this.trackView.update({track_uri:this.track.uri,track_title:this.track.title,artist_name:this.track.artist_name,artist_uri:this.track.artist_uri}),this._updateColorPalette(),eventDispatcher.dispatchEvent({type:"fetchLyrics",params:{uri:this.track.uri}}),eventDispatcher.dispatchEvent({type:"fetchAudioData",params:{uri:this.track.uri}})),this.loggingService&&this.loggingService.logPageImpression(this.track.uri)},TrackController.prototype._clearTrack=function(){this.track.update(),this.trackView.clear()},TrackController.prototype._startLyricsInterval=function(){clearInterval(this._lyricsInterval),this._lyricsInterval=setInterval(this._handleLyricsInterval.bind(this),100)},TrackController.prototype._startProgressInterval=function(){clearInterval(this._progressInterval),this._progressInterval=setInterval(this._handleProgressInterval.bind(this),20)},TrackController.prototype._stopLyricsInterval=function(){return clearInterval(this._lyricsInterval)},TrackController.prototype._stopProgressInterval=function(){return clearInterval(this._progressInterval)},TrackController.prototype._isPlaying=function(t){return!t.is_paused&&t.is_playing},TrackController.prototype._updateCurrentProgress=function(t){const i=t||Date.now();this.playing&&this._setCurrentProgress(this._lastTrackTimestamp+(i-this._lastPlayTime))},TrackController.prototype._handleProgressInterval=function(){this.options.runVisualization&&(this._updateCurrentProgress(),this.visualizationController.updateTrackProgress(this._currentProgress))},TrackController.prototype._handleLyricsInterval=function(){this._updateCurrentProgress(),eventDispatcher.dispatchEvent({type:"checkLyricsIndex",params:{currentProgress:this._currentProgress,trackUri:this.track.uri}})},TrackController.prototype._setCurrentProgress=function(t){let i=t;i>this.track.duration&&(i=this.track.duration),i<0&&(i=0),this._currentProgress=i},TrackController.prototype._updateColorPalette=function(){const t=this.colorPalette.randomColor(),i=this.colorPalette.colorLookup[t]||this.colorPalette.colorLookup[0];this.background.style.backgroundColor=`rgb(${i.r}, ${i.g}, ${i.b})`;const e=this._getVisualizerPalette(t,i);this.visualizationController.updateColorPalette(e)},TrackController.prototype._updateVisualization=function(){const t=VisualizationManifest[this._visualizationIndex];this.visualizationController.changeVisualization(t.id,function(){}),t&&t.reactive?this._startProgressInterval():this._stopProgressInterval()},TrackController.prototype._getVisualizerPalette=function(t,i){const e={primary:{name:t,r:i.r,g:i.g,b:i.b},pairs:[]},r=this.colorPalette.randomPair(t),s=this.colorPalette.colorLookup[r]||this.colorPalette.colorLookup.Black;return e.pairs.push({name:r,r:s.r,g:s.g,b:s.b}),e},TrackController.prototype._handleAppActivation=function(t){if(!(t&&t.params&&t.params.active))return this.active=!1,this._stopLyricsInterval(),this._stopProgressInterval(),this.visualizationController.pause(),void(this.loggingService&&this.loggingService.logItemInteraction(this.track.uri,null,null,null,LoggingService.InteractionTypes.HIT,LoggingService.UserIntents.HIDE_LYRICS));t.params.active&&(this.active=!0,cosmos.resolver.get("sp://player/v2/main/state",this._handleActiveState.bind(this)))},TrackController.prototype._handleActiveState=function(t,i){if(t)return;if(!this.track)return void this._showError();this._hideError(),this.options.runVisualization&&this.visualizationController.play(this.options.highVisualizationFrameRate);const e=JSON.parse(i.toJSON().body),r=e.timestamp;e.position_as_of_timestamp=e.position_as_of_timestamp+Date.now()-r,eventDispatcher.dispatchEvent({type:"updateTrack",params:e}),this.loggingService&&this.loggingService.logItemInteraction(this.track.uri,null,null,null,LoggingService.InteractionTypes.HIT,LoggingService.UserIntents.SHOW_LYRICS)},TrackController.prototype._showError=function(){this.errorView||(this.errorView=new ErrorView(this.errorContainer)),this.errorView.update({errorTitle:i18n.get("app.errorTitle"),errorMessage:i18n.get("app.errorMessage")}),this.errorView.show()},TrackController.prototype._hideError=function(){this.errorView||(this.errorView=new ErrorView(this.errorContainer)),this.errorView.hide()},TrackController.prototype._handleOptionsButton=function(){this._optionsMenuActive*=-1;let t=LoggingService.UserIntents.SHOW_OPTIONS_MENU;if(1===this._optionsMenuActive){if(!this.optionsMenuView){this.optionsMenuView=new OptionsMenuView(this.optionsMenuContainer),this.optionsMenuView.update({label:i18n.get("app.optionsMenuToggleLabel"),enabled:1===this._visualizationActive,visualizationNames:VisualizationManifest}),this.optionsMenuContainer.querySelector(".slider").addEventListener("mouseup",this._handleToggleVisualization.bind(this))}this._showOptionsMenu()}else t=LoggingService.UserIntents.HIDE_OPTIONS_MENU,this._hideOptionsMenu();this.loggingService&&this.loggingService.logItemInteraction(this.track.uri,LoggingService.SectionIds.CARD,null,"spotify:app:lyrics:menu",LoggingService.InteractionTypes.HIT,t)},TrackController.prototype._hideOptionsMenu=function(){this.optionsMenuContainer.classList.add("menu-hidden")},TrackController.prototype._showOptionsMenu=function(){this.optionsMenuContainer.classList.remove("menu-hidden")},TrackController.prototype._handleToggleVisualization=function(){this._visualizationActive*=-1;let t=LoggingService.UserIntents.DISABLE_VISUALIZATIONS;-1===this._visualizationActive?(this._disableVisualizations(),this.optionsMenuView.disableVisualizationSelect()):(t=LoggingService.UserIntents.ENABLE_VISUALIZATIONS,this._enableVisualizations(),this.optionsMenuView.enableVisualizationSelect()),this.loggingService&&this.loggingService.logItemInteraction(this.track.uri,LoggingService.SectionIds.CARD,null,"spotify:app:lyrics:visualization",LoggingService.InteractionTypes.HIT,t)},TrackController.prototype._disableVisualizations=function(){this.visualizationController.pause(),this.visualizationController.hide()},TrackController.prototype._enableVisualizations=function(){this.visualizationController.play(),this.visualizationController.show()},TrackController.prototype._handleOptionsMenu=function(t){if(1===this._visualizationActive&&t.target&&t.target.id&&("cell-left"===t.target.id||"cell-right"===t.target.id)){const i=t.target.getAttribute("direction");this._setVisualizationIndex(i,VisualizationManifest.length-1);const e=VisualizationManifest[this._visualizationIndex].id;this._updateVisualization(),this._updateColorPalette(),this.optionsMenuView.updateVisualizationSelector(i),this.loggingService&&this.loggingService.logItemInteraction(this.track.uri,LoggingService.SectionIds.CARD,null,e,LoggingService.InteractionTypes.HIT,LoggingService.UserIntents.SELECT_VISUALIZATION)}},TrackController.prototype._setVisualizationIndex=function(t,i){const e=parseInt(t,10);this._visualizationIndex=this._visualizationIndex+e,this._visualizationIndex<0?this._visualizationIndex=i:this._visualizationIndex>i&&(this._visualizationIndex=0)},module.exports=TrackController;

},{"../../../libs/abba":48,"../../../libs/cosmos-api":54,"../../../libs/event-dispatcher":60,"../../../libs/visualization/src/palette/color_palette":306,"../../../libs/visualization/src/visualization/visualizations/manifest":340,"../i18n/index":1,"./error_view":27,"./logging_service":28,"./no_service_view":32,"./options_button_view":33,"./options_menu_view":34,"./track":36,"./track_view":38}],38:[function(require,module,exports){
"use strict";const headerTemplate=require("../templates/track_view.hbs");function TrackView(e){this.container=e}TrackView.prototype.update=function(e){this.container.innerHTML=headerTemplate(e)},TrackView.prototype.clear=function(){this.container.innerHTML=""},module.exports=TrackView;

},{"../templates/track_view.hbs":47}],39:[function(require,module,exports){
"use strict";const Utils={getTrackIdFromUri:function(t){const c=/^spotify:track:(.*)/;let r=null;return!!(t.match(c)&&t.match(c).length>1)&&(r=t.match(c)[1])}};module.exports=Utils;

},{}],40:[function(require,module,exports){
var HandlebarsCompiler=require("hbsfy/runtime");module.exports=HandlebarsCompiler.template({compiler:[7,">= 4.0.0"],main:function(e,t,l,n,a){var r;return'<p class="attribution-text">'+e.escapeExpression("function"==typeof(r=null!=(r=l.text||(null!=t?t.text:t))?r:l.helperMissing)?r.call(null!=t?t:e.nullContext||{},{name:"text",hash:{},data:a}):r)+"</p>\n"},useData:!0});

},{"hbsfy/runtime":381}],41:[function(require,module,exports){
var HandlebarsCompiler=require("hbsfy/runtime");module.exports=HandlebarsCompiler.template({compiler:[7,">= 4.0.0"],main:function(e,n,p,s,a){return'<p class="index0"></p>\n<p class="index1"></p>\n<p class="index2"></p>\n<p class="index3"></p>\n<p class="index4"></p>\n'},useData:!0});

},{"hbsfy/runtime":381}],42:[function(require,module,exports){
var HandlebarsCompiler=require("hbsfy/runtime");module.exports=HandlebarsCompiler.template({compiler:[7,">= 4.0.0"],main:function(e,s,a,n,l){var i,t=null!=s?s:e.nullContext||{},o=a.helperMissing,r=e.escapeExpression;return'<div class="no-service-text-container">\n    <div class="no-service-title">'+r("function"==typeof(i=null!=(i=a.message_title||(null!=s?s.message_title:s))?i:o)?i.call(t,{name:"message_title",hash:{},data:l}):i)+'</div>\n    <div class="no-service-message">'+r("function"==typeof(i=null!=(i=a.message_body||(null!=s?s.message_body:s))?i:o)?i.call(t,{name:"message_body",hash:{},data:l}):i)+"</div>\n</div>\n\n"},useData:!0});

},{"hbsfy/runtime":381}],43:[function(require,module,exports){
var HandlebarsCompiler=require("hbsfy/runtime");module.exports=HandlebarsCompiler.template({compiler:[7,">= 4.0.0"],main:function(e,s,a,l,n){var r;return'<p class="no-lyrics-message">'+e.escapeExpression("function"==typeof(r=null!=(r=a.message||(null!=s?s.message:s))?r:a.helperMissing)?r.call(null!=s?s:e.nullContext||{},{name:"message",hash:{},data:n}):r)+"</p>\n"},useData:!0});

},{"hbsfy/runtime":381}],44:[function(require,module,exports){
var HandlebarsCompiler=require("hbsfy/runtime");module.exports=HandlebarsCompiler.template({1:function(n,l,a,t,i){var e;return"    <p>"+(null!=(e=n.lambda(l,l))?e:"")+"</p>\n"},compiler:[7,">= 4.0.0"],main:function(n,l,a,t,i){var e,r,u=null!=l?l:n.nullContext||{},o=a.helperMissing,s=n.escapeExpression;return'<div class="lyrics-list-full">\n'+(null!=(e=a.each.call(u,null!=l?l.lines:l,{name:"each",hash:{},fn:n.program(1,i,0),inverse:n.noop,data:i}))?e:"")+'  <p>&nbsp;</p>\n  <p class="attribution"><a id="nosync_link" href="'+s("function"==typeof(r=null!=(r=a.attribution_href||(null!=l?l.attribution_href:l))?r:o)?r.call(u,{name:"attribution_href",hash:{},data:i}):r)+'">'+s("function"==typeof(r=null!=(r=a.attribution_link||(null!=l?l.attribution_link:l))?r:o)?r.call(u,{name:"attribution_link",hash:{},data:i}):r)+"</a></p>\n  <p>&nbsp;</p>\n</div>\n"},useData:!0});

},{"hbsfy/runtime":381}],45:[function(require,module,exports){
var HandlebarsCompiler=require("hbsfy/runtime");module.exports=HandlebarsCompiler.template({compiler:[7,">= 4.0.0"],main:function(e,l,a,n,r){var t;return'<div class="options-button">'+e.escapeExpression("function"==typeof(t=null!=(t=a.label||(null!=l?l.label:l))?t:a.helperMissing)?t.call(null!=l?l:e.nullContext||{},{name:"label",hash:{},data:r}):t)+"</div>"},useData:!0});

},{"hbsfy/runtime":381}],46:[function(require,module,exports){
var HandlebarsCompiler=require("hbsfy/runtime"),partial$0=require("../../../libs/glue/templates/slider.hbs");HandlebarsCompiler.registerPartial("../../../libs/glue/templates/slider.hbs",partial$0),module.exports=HandlebarsCompiler.template({1:function(e,l,a,n,i){return'            <p class="item">'+e.escapeExpression(e.lambda(null!=l?l.name:l,l))+"</p>\n"},compiler:[7,">= 4.0.0"],main:function(e,l,a,n,i){var t,s,r=null!=l?l:e.nullContext||{};return'<div class="options-menu">\n  <div id="visualization-select-container" class="menu-row-select">\n    <table>\n      <tr>\n        <td class="spoticon-chevron-left-16" id="cell-left" direction="-1"></td>\n        <td id="cell-middle">\n          <div class="innerWrapper">\n'+(null!=(t=a.each.call(r,null!=l?l.visualizationNames:l,{name:"each",hash:{},fn:e.program(1,i,0),inverse:e.noop,data:i}))?t:"")+'          </div>\n        </td>\n        <td class="spoticon-chevron-right-16" id="cell-right" direction="1"></td>\n      </tr>\n    </table>\n  </div>\n  <div class="menu-row-toggle">\n    <p>'+e.escapeExpression("function"==typeof(s=null!=(s=a.label||(null!=l?l.label:l))?s:a.helperMissing)?s.call(r,{name:"label",hash:{},data:i}):s)+'</p>\n    <div id="animated-background-toggle" class="toggle-container">\n'+(null!=(t=e.invokePartial(n["../../../libs/glue/templates/slider.hbs"],l,{name:"../../../libs/glue/templates/slider.hbs",data:i,indent:"      ",helpers:a,partials:n,decorators:e.decorators}))?t:"")+"    </div>\n  </div>\n</div>\n"},usePartial:!0,useData:!0});

},{"../../../libs/glue/templates/slider.hbs":91,"hbsfy/runtime":381}],47:[function(require,module,exports){
var HandlebarsCompiler=require("hbsfy/runtime");module.exports=HandlebarsCompiler.template({compiler:[7,">= 4.0.0"],main:function(t,a,n,l,e){var i,r=null!=a?a:t.nullContext||{},o=n.helperMissing,c=t.escapeExpression;return'<div class="lyrics-header" data-uri="'+c("function"==typeof(i=null!=(i=n.track_uri||(null!=a?a.track_uri:a))?i:o)?i.call(r,{name:"track_uri",hash:{},data:e}):i)+'" data-context>\n  <div class="lyrics-context-menu-container">\n    <button class="button button-icon-with-stroke spoticon-more-16" data-button="contextmenu" data-tooltip="'+c((n.loc||a&&a.loc||o).call(r,"app.contextMenuToolTip",{name:"loc",hash:{},data:e}))+'" data-log-click="contextmenu-button"></button>\n  </div>\n  <div class="lyrics-header-container">\n    <div class="text">\n      <strong class="track">'+c("function"==typeof(i=null!=(i=n.track_title||(null!=a?a.track_title:a))?i:o)?i.call(r,{name:"track_title",hash:{},data:e}):i)+'</strong>\n    </div>\n    <div>\n      <a class="artist" href="'+c("function"==typeof(i=null!=(i=n.artist_uri||(null!=a?a.artist_uri:a))?i:o)?i.call(r,{name:"artist_uri",hash:{},data:e}):i)+'">'+c("function"==typeof(i=null!=(i=n.artist_name||(null!=a?a.artist_name:a))?i:o)?i.call(r,{name:"artist_name",hash:{},data:e}):i)+"</a>\n    </div>\n  </div>\n</div>\n"},useData:!0});

},{"hbsfy/runtime":381}],48:[function(require,module,exports){
"use strict";var _cosmosApi=require("../cosmos-api"),_cosmosApi2=_interopRequireDefault(_cosmosApi),_jsonStableStringify=require("json-stable-stringify"),_jsonStableStringify2=_interopRequireDefault(_jsonStableStringify);function _interopRequireDefault(e){return e&&e.__esModule?e:{default:e}}let subscriptions=[];function _getFlagsFromCosmos(e,s){_cosmosApi2.default.resolver.post({url:"sp://abba/v1/flags",body:{flags:e}},(e,t)=>{if(e)s(e);else{const{flags:e=[]}=t.getJSONBody();s(null,e)}})}function fetch(e){if("string"==typeof e)return fetch([e]).then(s=>s[e]);const s={},t=readOverrides(),r=e.reduce((e,r)=>(t.hasOwnProperty(r)?(console.warn(`Abba: Override for ${r} : ${t[r]}`),s[r]=t[r]):e.push(r),e),[]);return r.length?new Promise((t,o)=>{_getFlagsFromCosmos(r,(r,n)=>{r?o(r):(n.forEach(e=>{s[e.featureName]=e.cell}),Object.keys(s).length!==e.length&&e.forEach(e=>{s.hasOwnProperty(e)||(s[e]=null)}),t(s))})}):Promise.resolve(s)}function get(e,s){const t=readOverrides();if(t.hasOwnProperty(e))return console.warn(`Abba: Override for ${e} : ${t[e]}`),void setTimeout(()=>s(null,t[e]),0);_getFlagsFromCosmos([e],(t,r)=>{if(t)return void s(t);const o=r[0]&&r[0].featureName===e&&r[0].cell;s(null,o||null)})}function getAll(e){console.warn("Abba:getAll should only be used by TA tests for logging purposes."),_cosmosApi2.default.resolver.get({url:"sp://abba/v1/all_flags",body:{}},(s,t)=>{if(s)e(s);else{const{flags:s=[]}=t.getJSONBody(),r=s.reduce((e,s)=>(e[s.featureName]=s.cell,e),{});e(null,(0,_jsonStableStringify2.default)(r,{space:2}))}})}function getRequestedFlagNames(e){_cosmosApi2.default.resolver.get({url:"sp://abba/v1/requested_flag_names",body:{}},(s,t)=>{s?e(s):e(null,JSON.stringify(t.getJSONBody().sort(),null,2))})}function subscribe(e,s){let t;const r=e=>{e!==t&&(t=e,s(null,e))};let o=_cosmosApi2.default.resolver.subscribe({url:"sp://abba/v1/flags",body:{flags:[e]}},t=>{t?s(t):get(e,(e,t)=>{e?s(e):r(t)})}),n={cancel:()=>{o&&o.cancel();const s=subscriptions[e].indexOf(n);-1!==s&&subscriptions[e].splice(s,1),n=o=null},_update:r};return e in subscriptions||(subscriptions[e]=[]),subscriptions[e].push(n),n}function clearSubscriptions(){subscriptions=[]}function readOverrides(){const e="undefined"!=typeof __spotify&&__spotify.product_state?__spotify.product_state.abbaOverrides||__spotify.product_state.abbaoverrides:"";if(e)try{return JSON.parse(e)}catch(s){console.error("error parsing value=%o, error=%o",e,s)}return{}}module.exports={get:get,subscribe:subscribe,clearSubscriptions:clearSubscriptions,fetch:fetch},"undefined"!=typeof window&&(window.abba={get:get,getAll:getAll,getRequestedFlagNames:getRequestedFlagNames});

},{"../cosmos-api":54,"json-stable-stringify":383}],49:[function(require,module,exports){
"use strict";const TEN_PER_SECOND_FOR_A_YEAR=31536e4,COSMOS_VERBS=["GET","HEAD","POST","PUT","SUB","PATCH","DELETE"],ERROR_PREFIX="bridge.cosmosRequest: ";function cosmosRequest(e,t,o,r){if(o.url)throw new Error(`${ERROR_PREFIX}"url" is not a valid option, did you mean "uri"?`);if("string"!=typeof o.uri)throw new Error(`${ERROR_PREFIX}Expected uri to be string.`);if(-1===COSMOS_VERBS.indexOf(o.method))throw new Error(`${ERROR_PREFIX}Method must match valid verb in uppercase (GET, POST etc)`);if(o.body&&"string"!=typeof o.body)throw new Error(`${ERROR_PREFIX}If body is provided it should be a string.`);if(o.headers&&"[object Object]"!==Object.prototype.toString.call(o.headers))throw new Error(`${ERROR_PREFIX}Expected headers be a plain object.`);const s={action:o.method,uri:o.uri};o.body&&(s.body=o.body),o.headers&&(s.headers=o.headers),e.requestIDCounter=e.requestIDCounter||TEN_PER_SECOND_FOR_A_YEAR,e.requestIDCounter++;const n=[e.requestIDCounter,s];let u=!1;const i=e.requestIDCounter;return function e(s,i){t(s?"cosmos_request_create":"cosmos_request_pull",n,function(s,n){if(!u)try{r&&(s?r(s):r(null,n))}finally{"SUB"!==o.method?t("cosmos_request_cancel",[i]):u||e(!1,i)}})}(!0,i),function(){u=!0,t("cosmos_request_cancel",[i])}}module.exports=cosmosRequest;

},{}],50:[function(require,module,exports){
(function (global){
"use strict";const debug=require("../debug")("bridge"),defer=require("spotify-deferred"),cosmosBaseFunction=require("./cosmos");let scheduledCoreFlush=!1,cosmosState=null;function cosmos(){cosmosState||(cosmosState={});const e=[cosmosState,request];return cosmosBaseFunction.apply(null,e.concat(Array.prototype.slice.call(arguments)))}function _createCallbackWrapper(e){return function(t,s){let r=t;if(r)e(r,s);else{if(s&&!s.body&&s.status>=400)return r=new Error(`${s.uri} responded with status ${s.status}`),void e(r,s);let t;try{t=JSON.parse(s.body)}catch(t){return t.message=`Failed to parse cosmos response: ${t.message}`,void e(t)}e(null,t)}}}function cosmosJSON(e,t){return e.body&&(e.body=JSON.stringify(e.body)),cosmos(e,t?_createCallbackWrapper(t):null)}function request(e,t,s){const r=t||[],o=getCallback(e,r,s);return debug(`req:${e}`,r),exports._request(e,r,o),e.endsWith("_metadata")&&!scheduledCoreFlush&&(scheduledCoreFlush=!0,defer(flushCore)),exports}function _request(e,t,s){global&&"function"==typeof global._getSpotifyModule&&global._getSpotifyModule("bridge").executeRequest(JSON.stringify({name:e,args:t}),{onSuccess:getSuccessHandler(s),onFailure:getFailureHandler(s,e,t)})}function getCallback(e,t,s){const r=s||function(){};return function(s,o){if(s&&"timeout"===s.name){const o=300+Math.floor(100*Math.random());return debug("timeout",s.message),void setTimeout(function(){request(e,t,r)},o)}debug(`res:${e}`,t,o),r(s,o)}}function getSuccessHandler(e){return function(t){let s;debug("success",t);try{s=JSON.parse(t)}catch(t){e(t)}s&&e(null,s)}}function getFailureHandler(e,t,s){return function(r){let o;debug("failure",r);try{o=JSON.parse(r)}catch(t){r instanceof Error?e(r):(t.message+=`\nResponse Data: ${r}`,e(t))}o&&e(createError(t,s,o))}}function createError(e,t,s){const r=` (bridge message: '${e}', args: ${JSON.stringify(t)})`,o=s.message+r,u=new Error(o);return u.name=s.error,u}function flushCore(){scheduledCoreFlush=!1,request("core_flush")}exports.cosmos=cosmos,exports.cosmosJSON=cosmosJSON,exports.request=request,exports._request=_request;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../debug":59,"./cosmos":49,"spotify-deferred":445}],51:[function(require,module,exports){
"use strict";Object.defineProperty(exports,"__esModule",{value:!0});const operationCanceledError={name:"OperationCanceledError",message:"An async operation was cancelled"};class CancellationToken{constructor(e){this.source=e,this.requestId=e.requestId}isCanceled(){return this.requestId!==this.source.requestId}throwIfCanceled(){if(this.isCanceled())throw operationCanceledError}errorIfCanceled(){if(this.isCanceled())return operationCanceledError}operationCanceledError(){return operationCanceledError}}class CancellationTokenSource{constructor(){this.requestId=0}token(){return new CancellationToken(this)}cancel(){this.requestId++}}exports.default=CancellationTokenSource;

},{}],52:[function(require,module,exports){
(function (global){
"use strict";Object.defineProperty(exports,"__esModule",{value:!0});const hasFlag=exports.hasFlag=(t=>!!(global.__spotify&&global.__spotify.product_state&&global.__spotify.product_state.hasOwnProperty(t))),hasValue=exports.hasValue=((t,s)=>hasFlag(t)&&global.__spotify.product_state[t]===s);

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],53:[function(require,module,exports){
"use strict";const parser=require("../live/util/parser"),sortMap={track:{_replace:"",artists:{_replace:"artist"},disc:{_replace:"discNumber"},number:{_replace:"trackNumber"},duration:{_replace:"length"}},timeSinceAdded:{_reverse:!0,_replace:"addTime"},addedBy:{_replace:"",name:{_replace:"addedByDisplayName"}}};function reverse(e){return"ASC"===e?"DESC":"ASC"}function walk(e,r,a,s){const t=[],c=s&&s.slice()||[];return e.mask.forEach(e=>{const s=c.slice();if(e.key){let t=r&&r[e.key]&&null!==r[e.key]._replace&&void 0!==r[e.key]._replace?r[e.key]._replace:e.key;if(""!==t){if(!e.mask){const s=!!(r&&r[e.key]&&r[e.key]._reverse);if(a){const e=a.toUpperCase();t+=` ${s?reverse(e):e}`}}s.push(t)}}if(e.mask){const c=walk(e,r[e.key],a,s);c.length&&t.push(c)}else s.length&&t.push(s.join("."))}),t}function getParams(e,r,a){const s=parser(e);return e?walk(s,a||sortMap,r).join(","):null}module.exports=getParams;

},{"../live/util/parser":151}],54:[function(require,module,exports){
(function (global){
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.resolver=exports.Resolver=exports.Response=exports.Request=exports.Action=void 0;var _request=require("./request"),_response=require("./response"),_resolver=require("./resolver");const window=global.window||{},bridge=window._getSpotifyModule&&"function"==typeof window._getSpotifyModule&&window._getSpotifyModule("bridge"),resolver=bridge?new _resolver.Resolver(bridge):new _resolver.NullResolver;exports.default={Action:_request.Action,Request:_request.Request,Response:_response.Response,Resolver:_resolver.Resolver,resolver:resolver},exports.Action=_request.Action,exports.Request=_request.Request,exports.Response=_response.Response,exports.Resolver=_resolver.Resolver,exports.resolver=resolver;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./request":56,"./resolver":57,"./response":58}],55:[function(require,module,exports){
"use strict";function stringify(e){return"string"!=typeof e?JSON.stringify(e):e}Object.defineProperty(exports,"__esModule",{value:!0});class Message{constructor(e,r,t){if("string"!=typeof e)throw new TypeError("Invalid `uri` argument for Message.");this._uri=e,this._headers=this._headersToLowerCase(r),this._body=stringify(t||"")}static fromObject(e){return e&&e.uri?new Message(e.uri,e.headers,e.body):null}getURI(){return this._uri}getMimeType(){return this._headers.accept}getHeader(e){return this._headers[e.toLowerCase()]||null}getHeaders(){return this._copyHeaders(null)}getBody(){return this._body}getJSONBody(){try{return JSON.parse(this._body)}catch(e){return null}}copy(e,r){return new Message(this._uri,this._copyHeaders(e),void 0!==r?r:this._body)}serialize(){return this.toJSON()}toJSON(){return{uri:this._uri,headers:this._headers,body:this._body}}_headersToLowerCase(e){return null===e||"object"!=typeof e?{}:Object.keys(e).reduce((r,t)=>(r[t.toLowerCase()]=e[t],r),{})}_copyHeaders(e){return Object.assign({},this._headers,this._headersToLowerCase(e))}}exports.Message=Message;

},{}],56:[function(require,module,exports){
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.Request=exports.Action=void 0;var _message=require("./message");const Action=exports.Action={DELETE:"DELETE",GET:"GET",HEAD:"HEAD",POST:"POST",PUT:"PUT",SUB:"SUB",PATCH:"PATCH"};class Request extends _message.Message{constructor(e,t,s,r){if("string"!=typeof e)throw new TypeError("Invalid `action` argument for Request.");super(t,s,r),this._action=e}static fromObject(e){return e&&e.action&&e.uri?new Request(e.action,e.uri,e.headers,e.body):null}getAction(){return this._action}copy(e,t){return new Request(this._action,this._uri,this._copyHeaders(e),void 0!==t?t:this._body)}toJSON(){return{action:this._action,uri:this._uri,headers:this._headers,body:this._body}}}exports.Request=Request;

},{"./message":55}],57:[function(require,module,exports){
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.NullResolver=exports.Resolver=void 0;var _request=require("./request"),_response=require("./response");function isSuccessStatus(e){return e>=200&&e<=299}class Resolver{constructor(e){if(!e||"function"!=typeof e.executeRequest)throw new TypeError("Missing or invalid `bridge` parameter");this._bridge=e,this._requestId=1e6}resolve(e,s){return this._resolve(e,s)}get(e,s){return this._resolveFromParams(_request.Action.GET,e,s)}post(e,s){return this._resolveFromParams(_request.Action.POST,e,s)}subscribe(e,s){return this._resolveFromParams(_request.Action.SUB,e,s)}put(e,s){return this._resolveFromParams(_request.Action.PUT,e,s)}patch(e,s){return this._resolveFromParams(_request.Action.PATCH,e,s)}delete(e,s){return this._resolveFromParams(_request.Action.DELETE,e,s)}_sendRequest(e,s,t){return new Promise((r,n)=>{const o=JSON.stringify({name:e,args:[s,t]});this._bridge.executeRequest(o,{onSuccess:e=>{r(JSON.parse(e))},onFailure:e=>{n(JSON.parse(e))}})})}_parseResponse(e,s){const t=_response.Response.fromObject(s);if(null===t)throw new Error(`Failed to parse response: ${s}`);const r=t.getStatusCode();if(!isSuccessStatus(r)){const s=new Error(`Request to ${e.getURI()} failed with status code ${r}`);throw s.response=t,s}return t}async _createRequestAsync(e,s){const t=s.toJSON(),r=await this._sendRequest("cosmos_request_create",e,t);return this._parseResponse(s,r)}async _pullRequestAsync(e,s){const t=await this._sendRequest("cosmos_request_pull",e,{uri:s.getURI()});return this._parseResponse(s,t)}async _cancelRequestAsync(e){await this._sendRequest("cosmos_request_cancel",e)}_doResolve(e,s){const t=++this._requestId,r={isCancelled:!1};return this._createRequestAsync(t,e).then(e=>{r.isCancelled||s(null,e),this._cancelRequestAsync(t)}).catch(e=>{r.isCancelled||s(e,e.response||null)}),{cancel:()=>{r.isCancelled=!0,this._cancelRequestAsync(t)}}}_doSubscribe(e,s){const t=++this._requestId,r={isCancelled:!1},n=()=>r.isCancelled?Promise.resolve():this._pullRequestAsync(t,e).then(e=>{r.isCancelled||s(null,e)}).then(n);return this._createRequestAsync(t,e).then(e=>(r.isCancelled||s(null,e),n())).catch(e=>{r.isCancelled||s(e,e.response||null)}),{cancel:()=>{r.isCancelled=!0,this._cancelRequestAsync(t)}}}_resolve(e,s){const t="function"==typeof s?s:()=>{};return e.getAction()===_request.Action.SUB?this._doSubscribe(e,t):this._doResolve(e,t)}_resolveFromParams(e,s,t){const r=s||{},n="string"==typeof r?r:r.url,o=r.headers,c=r.body,u=new _request.Request(e,n,o,c);return this._resolve(u,t)}}exports.Resolver=Resolver;class NullResolver{resolve(){return{cancel:()=>{}}}get(){return{cancel:()=>{}}}post(){return{cancel:()=>{}}}subscribe(){return{cancel:()=>{}}}put(){return{cancel:()=>{}}}patch(){return{cancel:()=>{}}}delete(){return{cancel:()=>{}}}}exports.NullResolver=NullResolver;

},{"./request":56,"./response":58}],58:[function(require,module,exports){
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.Response=exports.StatusCode=void 0;var _message=require("./message");const StatusCode=exports.StatusCode={OK:200,CREATED:201,ACCEPTED:202,BAD_REQUEST:400,UNAUTHORIZED:401,FORBIDDEN:403,NOT_FOUND:404,METHOD_NOT_ALLOWED:405,TIMED_OUT:408,CONFLICT:409,GONE:410,INTERNAL_SERVER_ERROR:500,NOT_IMPLEMENTED:501,BAD_GATEWAY:502,SERVICE_UNAVAILABLE:503,ERROR_UNKNOWN:-100,ERROR_ALLOCATION_FAILED:-101,ERROR_INVALID_ENCODING:-102,ERROR_INFINITE_LOOP:-103,ERROR_RESOLVER_NOT_FOUND:-104};class Response extends _message.Message{constructor(e,s,t,r){if("number"!=typeof s)throw new TypeError("Invalid `status` argument for Response.");super(e,t,r),this._status=s}static fromObject(e){return e&&e.uri&&e.status?new Response(e.uri,e.status,e.headers,e.body):null}getMimeType(){return this._headers["content-type"]}getStatusCode(){return this._status}copy(e,s){return new Response(this._uri,this._status,this._copyHeaders(e),void 0!==s?s:this._body)}toJSON(){return{uri:this._uri,status:this._status,headers:this._headers,body:this._body}}}exports.Response=Response;

},{"./message":55}],59:[function(require,module,exports){
"use strict";let debug,initialized=!1;const spDebug=function e(t){if(!initialized){if(debug=require("debug"),e.enable=debug.enable.bind(debug),e.disable=debug.disable.bind(debug),"undefined"!=typeof window&&window.frameElement){const e=window.frameElement.getAttribute("data-debug");e&&debug.enable(e)}const t="undefined"!=typeof __spotify&&__spotify.product_state?__spotify.product_state:{},i=t.debugEnable||t.debugenable;i&&debug.enable(i),"undefined"!=typeof __spotify&&__spotify.product_state&&"1"===__spotify.product_state["ta-environment"]&&(debug.useColors=(()=>!1),debug.formatters.o=(e=>{try{return JSON.stringify(e)}catch(e){return console.error("Unable to stringify object",e),""}})),initialized=!0}return debug(t)};module.exports=spDebug;

},{"debug":359}],60:[function(require,module,exports){
"use strict";function EventDispatcher(){this._listeners=Object.create(null)}EventDispatcher.prototype.addEventListener=function(e,t,n=0){if(!e||!t)throw new Error("Both event type and callback need to be defined");this._listeners[e]||(this._listeners[e]=[]);const i=this._listeners[e];if(i.every(function(e){return e.callback!==t})){const e={callback:t,priority:n};let s=0;for(;s<i.length&&i[s].priority>e.priority;)s++;i.splice(s,0,e)}},EventDispatcher.prototype.removeEventListener=function(e,t){const n=this._listeners[e]||[];for(let e=0;e<n.length;e++)if(n[e].callback===t)return void n.splice(e,1)},EventDispatcher.prototype.addEventListenerOnce=function(e,t,n=(()=>!0),i=0){const s=i=>{n(i)&&(this.removeEventListener(e,s),t(i))};this.addEventListener(e,s,i)},EventDispatcher.prototype.dispatchEvent=function(e){const t=this._listeners[e.type]?this._listeners[e.type].slice():[];for(let n=0,i=t.length;n<i;n++){t[n].callback(e)}},EventDispatcher.prototype.reset=function(){this._listeners=Object.create(null)},module.exports=new EventDispatcher;

},{}],61:[function(require,module,exports){
(function (global){
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.addDebouncedScrollListener=addDebouncedScrollListener,exports.removeDebouncedScrollListener=removeDebouncedScrollListener,exports.requestFrame=requestFrame,exports.cancelFrame=cancelFrame,exports._reset=_reset;let scrollNodeToListenerInfoList=new global.Map,idToScrollNode={},frameListenerInfoList=[],hasQueuedScroll=!1,lastScrollEvent=null,lastFrameRequestId=0,globalIdCounter=0;function onScroll(e){if(lastScrollEvent=e,!hasQueuedScroll){hasQueuedScroll=!0;const o=scrollNodeToListenerInfoList.get(e.target);if(o){let e;requestFrame(()=>{hasQueuedScroll=!1,callReadHandlers(e=o.slice(),lastScrollEvent)},()=>{callWriteHandlers(e,lastScrollEvent)})}}}function onFrame(e){lastFrameRequestId=0;const o=frameListenerInfoList;frameListenerInfoList=[],callReadHandlers(o,e),callWriteHandlers(o,e)}function callReadHandlers(e,o){e.forEach(e=>{e.readFunction&&e.readFunction(o)})}function callWriteHandlers(e,o){e.forEach(e=>{"function"==typeof e.writeFunction&&e.writeFunction(o)})}function addDebouncedScrollListener(e,o,r){if(null!==o&&"function"!=typeof o)throw new TypeError("The callback provided to addDebouncedScrollListener as parameter 2 is not a function.");if(void 0!==r&&"function"!=typeof r)throw new TypeError("The callback provided to addDebouncedScrollListener as parameter 3 is not a function.");scrollNodeToListenerInfoList.has(e)||(e.addEventListener("scroll",onScroll),scrollNodeToListenerInfoList.set(e,[]));const t=++globalIdCounter,n={id:t,readFunction:o,writeFunction:r};return idToScrollNode[t]=e,scrollNodeToListenerInfoList.get(e).push(n),t}function removeDebouncedScrollListener(e){const o=idToScrollNode[e];if(o){delete idToScrollNode[e];const r=scrollNodeToListenerInfoList.get(o);if(r)for(let o=0;o<r.length;o++)if(r[o].id===e){r.splice(o,1);break}0===r.length&&(o.removeEventListener("scroll",onScroll),scrollNodeToListenerInfoList.delete(o))}}function requestFrame(e,o){if(null!==e&&"function"!=typeof e)throw new TypeError("The callback provided to requestFrame as parameter 1 is not a function.");if(void 0!==o&&"function"!=typeof o)throw new TypeError("The callback provided to requestFrame as parameter 2 is not a function.");0===lastFrameRequestId&&(lastFrameRequestId=window.requestAnimationFrame(onFrame));const r=++globalIdCounter,t={id:r,readFunction:e,writeFunction:o};return frameListenerInfoList.push(t),r}function cancelFrame(e){for(let o=0;o<frameListenerInfoList.length;o++)if(frameListenerInfoList[o].id===e){frameListenerInfoList.splice(o,1);break}0!==lastFrameRequestId&&0===frameListenerInfoList.length&&(window.cancelAnimationFrame(lastFrameRequestId),lastFrameRequestId=0)}function _reset(){scrollNodeToListenerInfoList=new global.Map,idToScrollNode={},frameListenerInfoList=[],hasQueuedScroll=!1,lastScrollEvent=null,lastFrameRequestId=0,globalIdCounter=0}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],62:[function(require,module,exports){
module.exports={
  "Album": "ألبوم",
  "AndMore": "و {0} أكثر",
  "Artist": "الفنان",
  "By": "من",
  "ByLabel": "من",
  "Create Similar Playlist": "قم بإنشاء قائمة أغاني مماثلة",
  "DateAdded": "تاريخ الإضافة",
  "Duration": "المدة الزمنية",
  "Recommended Songs": "الأغاني المقترحة",
  "Filter": "فلتر",
  "Follow": "تابع",
  "Follower": "متابع",
  "FollowersLabel": {
    "one": "متابع",
    "other": "متابعون"
  },
  "FollowersCount": {
    "one": "{0} متابع",
    "other": "{0} متابعين"
  },
  "Following": "متابع",
  "FollowingLabel": "متابع",
  "ListenersLabel": "مستمعون شهرياً",
  "FollowsYou": "يتابعك",
  "HoldToPreview": "انقر وامسك للعرض المسبق",
  "ListenCount": {
    "one": "1 مرة استماع",
    "other": "{0} استماع"
  },
  "ListenReactionMulti": "{0} مستمع في شبكتك",
  "ListenReactionSingle": "{0} يستمع إلى هذه الأغنية",
  "LocalFile": "الأغاني المُحملة",
  "More": "المزيد",
  "MoreSongsLoad": "يتم تحميل المزيد من الأغاني أثناء الاستماع",
  "Pause": "إيقاف مؤقّت",
  "Play": "استمع",
  "Playlist": "قائمة الأغاني",
  "PressEnterToPlay": "Press Shift + Enter to play",
  "Popularity": "الشعبية",
  "Progress": "تقدم",
  "Remove": "احذف",
  "RemoveYourMusic": "احذف من مكتبتك الموسيقية",
  "RemoveFromYourFavoriteSongs": "احذف من الأغاني المفضلة",
  "Save": "احفظ",
  "SaveYourMusic": "احفظها في مكتبتك الموسيقية",
  "SaveToYourFavoriteSongs": "احفظ في الأغاني المفضلة",
  "Saved": "تمّ الحفظ",
  "StartRadio": "إبدأ الراديو",
  "Time": "الوقت",
  "Title": "عنوان",
  "Toplist": "الأغاني الأكثر استماعاً",
  "Track": "الأغنية",
  "Unfollow": "ألغي المتابعة",
  "User": "المستخدم",
  "ViewAll": "عرض جميع النتائج",
  "HoursShort": "{0} ساعة",
  "MinutesShort": "{0} دقيقة",
  "SecondsShort": "{0} ثانية",
  "ErrorTitle": "وقعت مشكلة أثناء عرض هذه الصفحة!",
  "ErrorMessage": "هذه الصفحة إما غير موجودة أو حدث خطأ ما.",
  "OfflineTitle": "هذه الصفحة غير متوفرة عندما تكون غير متصل بشبكة الإنترنت!",
  "OfflineMessage": "يرجى الاتصال بشبكة الإنترنت للتحميل.",
  "MadeFor": "تمّ إعدادها لـ {0}",
  "heart_label": "أعجبني",
  "undo_heart_label": "أعجبني",
  "ban_label": "احذف",
  "format_list.ban_label": "لا يعجبني",
  "nft.ban_song_label": "Hide this song",
  "nft.undo_ban_song_label": "Stop hiding this song",
  "format_list.undo_ban_label": "لا يعجبني ذلك",
  "VariousArtistsCapitalized": "فنانون متنوعون"
}
},{}],63:[function(require,module,exports){
module.exports={
  "Album": "Album",
  "AndMore": "a {0} další(ch)",
  "Artist": "Umělec",
  "By": "od",
  "ByLabel": "Od",
  "Create Similar Playlist": "Vytvořit podobný playlist",
  "DateAdded": "Datum přidání",
  "Duration": "Délka",
  "Recommended Songs": "Doporučené skladby",
  "Filter": "Filtr",
  "Follow": "Sledovat",
  "Follower": "Sledující",
  "FollowersLabel": {
    "one": "Sledující",
    "other": "sledujících"
  },
  "FollowersCount": {
    "one": "{0} sledující",
    "other": "{0} sledujících"
  },
  "Following": "Sleduješ",
  "FollowingLabel": "Sleduješ",
  "ListenersLabel": "Posluchačů měsíčně",
  "FollowsYou": "Sleduje tě",
  "HoldToPreview": "Pro náhled klikni a podrž",
  "ListenCount": {
    "one": "1 přehrání",
    "other": "{0} přehrání"
  },
  "ListenReactionMulti": "{0} posluchačů ve tvé síti",
  "ListenReactionSingle": "{0} uživatelů tohle poslouchá",
  "LocalFile": "Místní soubory",
  "More": "dalších",
  "MoreSongsLoad": "Během přehrávání se načtou další skladby.",
  "Pause": "Pozastavit",
  "Play": "Přehrát",
  "Playlist": "Playlist",
  "PressEnterToPlay": "Press Shift + Enter to play",
  "Popularity": "Popularita",
  "Progress": "Postup",
  "Remove": "Odstranit",
  "RemoveYourMusic": "Odstranit ze sbírky Tvoje knihovna",
  "RemoveFromYourFavoriteSongs": "Odstranit ze sbírky Oblíbené skladby",
  "Save": "Uložit",
  "SaveYourMusic": "Uložit do sbírky Tvoje knihovna",
  "SaveToYourFavoriteSongs": "Uložit do sbírky Oblíbené skladby",
  "Saved": "Uloženo",
  "StartRadio": "Spustit rádio",
  "Time": "Čas",
  "Title": "Název",
  "Toplist": "Top skladby",
  "Track": "Skladba",
  "Unfollow": "Přestat sledovat",
  "User": "Uživatel",
  "ViewAll": "Zobrazit vše",
  "HoursShort": "{0} h",
  "MinutesShort": "{0} min",
  "SecondsShort": "{0} s",
  "ErrorTitle": "Při zobrazování této stránky došlo k problému!",
  "ErrorMessage": "Tato stránka buď neexistuje, nebo došlo k chybě.",
  "OfflineTitle": "Tato stránka není dostupná offline!",
  "OfflineMessage": "Pro načtení přejdi prosím online.",
  "MadeFor": "Speciálně pro uživatele {0}",
  "heart_label": "Líbí se mi",
  "undo_heart_label": "Líbilo se mi",
  "ban_label": "Odstranit",
  "format_list.ban_label": "Nelíbí se mi",
  "nft.ban_song_label": "Hide this song",
  "nft.undo_ban_song_label": "Stop hiding this song",
  "format_list.undo_ban_label": "Tohle se ti nelíbí",
  "VariousArtistsCapitalized": "Různí umělci"
}
},{}],64:[function(require,module,exports){
module.exports={
  "Album": "Album",
  "AndMore": "und {0} weitere",
  "Artist": "Künstler",
  "By": "von",
  "ByLabel": "Von",
  "Create Similar Playlist": "Ähnliche Playlist erstellen",
  "DateAdded": "Datum hinzugefügt",
  "Duration": "Dauer",
  "Recommended Songs": "Empfohlene Songs",
  "Filter": "Filter",
  "Follow": "Folgen",
  "Follower": "Follower",
  "FollowersLabel": {
    "one": "Follower",
    "other": "Follower"
  },
  "FollowersCount": {
    "one": "{0} Follower",
    "other": "{0} Follower"
  },
  "Following": "Folge ich",
  "FollowingLabel": "Folge ich",
  "ListenersLabel": "Monatliche Hörer",
  "FollowsYou": "Folgt dir",
  "HoldToPreview": "Zum Reinhören gedrückt halten",
  "ListenCount": {
    "one": "1 Wiedergabe",
    "other": "{0} Mal abgespielt"
  },
  "ListenReactionMulti": "{0} Hörer in Deinem Netzwerk",
  "ListenReactionSingle": "{0} hört sich das an",
  "LocalFile": "Lokale Datei",
  "More": "Mehr",
  "MoreSongsLoad": "Während du Musik hörst, werden weitere Songs geladen.",
  "Pause": "Pause",
  "Play": "Play",
  "Playlist": "Playlist",
  "PressEnterToPlay": "Press Shift + Enter to play",
  "Popularity": "Beliebtheit",
  "Progress": "Fortschritt",
  "Remove": "Entfernen",
  "RemoveYourMusic": "Aus Bibliothek entfernen",
  "RemoveFromYourFavoriteSongs": "Aus deinen Lieblingssongs entfernen",
  "Save": "Speichern",
  "SaveYourMusic": "In Bibliothek speichern",
  "SaveToYourFavoriteSongs": "In deinen Lieblingssongs speichern",
  "Saved": "Gespeichert",
  "StartRadio": "Radio starten",
  "Time": "Dauer",
  "Title": "Titel",
  "Toplist": "Top-Songs",
  "Track": "Song",
  "Unfollow": "Nicht mehr folgen",
  "User": "Benutzer",
  "ViewAll": "Mehr Darstellung",
  "HoursShort": "{0} Std.",
  "MinutesShort": "{0} Min.",
  "SecondsShort": "{0} Sek.",
  "ErrorTitle": "Bei der Anzeige dieser Seite ist ein Fehler aufgetreten.",
  "ErrorMessage": "Diese Seite ist entweder nicht vorhanden oder es ist ein Fehler aufgetreten.",
  "OfflineTitle": "Diese Seite ist offline nicht verfügbar.",
  "OfflineMessage": "Geh zum Laden online.",
  "MadeFor": "Für {0}",
  "heart_label": "Gefällt mir",
  "undo_heart_label": "Gefällt mir",
  "ban_label": "Entfernen",
  "format_list.ban_label": "Gefällt mir nicht",
  "nft.ban_song_label": "Hide this song",
  "nft.undo_ban_song_label": "Stop hiding this song",
  "format_list.undo_ban_label": "Das gefällt dir nicht",
  "VariousArtistsCapitalized": "Diverse Künstler"
}
},{}],65:[function(require,module,exports){
module.exports={
  "Album": "Άλμπουμ",
  "AndMore": "και άλλοι {0}",
  "Artist": "Καλλιτέχνης",
  "By": "από",
  "ByLabel": "Από",
  "Create Similar Playlist": "Δημιουργία παρόμοιας playlist",
  "DateAdded": "Προστέθηκε ημερομηνία",
  "Duration": "Διάρκεια",
  "Recommended Songs": "Προτεινόμενα τραγούδια",
  "Filter": "Φίλτρο",
  "Follow": "Ακολούθησε",
  "Follower": "Οπαδός",
  "FollowersLabel": {
    "one": "Οπαδός",
    "other": "Ακόλουθοι"
  },
  "FollowersCount": {
    "one": "{0} οπαδός",
    "other": "{0} οπαδοί"
  },
  "Following": "Aκολουθείται",
  "FollowingLabel": "Aκολουθείται",
  "ListenersLabel": "Μηνιαίοι ακροατές",
  "FollowsYou": "Σε ακολουθεί",
  "HoldToPreview": "Πάτησε και κράτησε πατημένο για προεπισκόπηση",
  "ListenCount": {
    "one": "1 αναπαραγωγή",
    "other": "{0} αναπαραγωγές"
  },
  "ListenReactionMulti": "{0} ακροατές στο δίκτυό σου",
  "ListenReactionSingle": "Ο χρήστης {0} ακούει αυτό",
  "LocalFile": "Τοπικό αρχείο",
  "More": "Περισσότερα",
  "MoreSongsLoad": "Περισσότερα τραγούδια φορτώνουν ενώ ακούς",
  "Pause": "Παύση",
  "Play": "Αναπαραγωγή",
  "Playlist": "Λίστα",
  "PressEnterToPlay": "Press Shift + Enter to play",
  "Popularity": "Δημοφιλία",
  "Progress": "Πρόοδος",
  "Remove": "Αφαίρεση",
  "RemoveYourMusic": "Αφαίρεση από τη Βιβλιοθήκη",
  "RemoveFromYourFavoriteSongs": "Αφαίρεση από τα Αγαπημένα σου τραγούδια",
  "Save": "Αποθήκευση",
  "SaveYourMusic": "Αποθήκευση στη Βιβλιοθήκη",
  "SaveToYourFavoriteSongs": "Αποθήκευση στα Αγαπημένα σου τραγούδια",
  "Saved": "Αποθηκεύτηκε",
  "StartRadio": "Έναρξη ράδιο",
  "Time": "Διάρκεια",
  "Title": "Τίτλος",
  "Toplist": "Κορυφαία τραγούδια",
  "Track": "Τραγούδι",
  "Unfollow": "Άρση ακολούθησης",
  "User": "Χρήστης",
  "ViewAll": "Δες τα όλα",
  "HoursShort": "{0} ώρα",
  "MinutesShort": "{0} λεπ.",
  "SecondsShort": "{0} δευτ.",
  "ErrorTitle": "Παρουσιάστηκε πρόβλημα κατά την προβολή αυτής της σελίδας!",
  "ErrorMessage": "Αυτή η σελίδα δεν υπάρχει ή προέκυψε κάποιο σφάλμα.",
  "OfflineTitle": "Αυτή η σελίδα δεν είναι διαθέσιμη εκτός σύνδεσης!",
  "OfflineMessage": "Συνδέσου στο διαδίκτυο για να πραγματοποιηθεί φόρτωση.",
  "MadeFor": "Ειδικά για: {0}",
  "heart_label": "Μου αρέσει",
  "undo_heart_label": "Αρέσει σε",
  "ban_label": "Αφαίρεση",
  "format_list.ban_label": "Δεν μου αρέσει",
  "nft.ban_song_label": "Hide this song",
  "nft.undo_ban_song_label": "Stop hiding this song",
  "format_list.undo_ban_label": "Δεν σου αρέσει αυτό",
  "VariousArtistsCapitalized": "Διάφοροι καλλιτέχνες"
}
},{}],66:[function(require,module,exports){
module.exports={
  "Album": "Album",
  "AndMore": "and {0} more",
  "Artist": "Artist",
  "By": "by",
  "ByLabel": "By",
  "Create Similar Playlist": "Create Similar Playlist",
  "DateAdded": "Date Added",
  "Duration": "Duration",
  "Recommended Songs": "Recommended Songs",
  "Filter": "Filter",
  "Follow": "Follow",
  "Follower": "Follower",
  "FollowersLabel": {
    "one": "Follower",
    "other": "Followers"
  },
  "FollowersCount": {
    "one": "{0} follower",
    "other": "{0} followers"
  },
  "Following": "Following",
  "FollowingLabel": "Following",
  "ListenersLabel": "Monthly Listeners",
  "FollowsYou": "Follows You",
  "HoldToPreview": "Click and Hold to Preview",
  "ListenCount": {
    "one": "1 play",
    "other": "{0} plays"
  },
  "ListenReactionMulti": "{0} listeners in your network",
  "ListenReactionSingle": "{0} listens to this",
  "LocalFile": "Local File",
  "More": "More",
  "MoreSongsLoad": "More songs load as you listen",
  "Pause": "Pause",
  "Play": "Play",
  "Playlist": "Playlist",
  "PressEnterToPlay": "Press Shift + Enter to play",
  "Popularity": "Popularity",
  "Progress": "Progress",
  "Remove": "Remove",
  "RemoveYourMusic": "Remove from Your Library",
  "RemoveFromYourFavoriteSongs": "Remove from your Favorite Songs",
  "Save": "Save",
  "SaveYourMusic": "Save to Your Library",
  "SaveToYourFavoriteSongs": "Save to your Favorite Songs",
  "Saved": "Saved",
  "StartRadio": "Start Radio",
  "Time": "Time",
  "Title": "Title",
  "Toplist": "Top songs",
  "Track": "Song",
  "Unfollow": "Unfollow",
  "User": "User",
  "ViewAll": "View All",
  "HoursShort": "{0} hr",
  "MinutesShort": "{0} min",
  "SecondsShort": "{0} sec",
  "ErrorTitle": "There was a problem displaying this page!",
  "ErrorMessage": "This page either does not exist or an error occurred.",
  "OfflineTitle": "This page is not available offline!",
  "OfflineMessage": "Please go online to load.",
  "MadeFor": "Made for {0}",
  "heart_label": "Like",
  "undo_heart_label": "Liked",
  "ban_label": "Remove",
  "format_list.ban_label": "Don't like",
  "nft.ban_song_label": "Hide this song",
  "nft.undo_ban_song_label": "Stop hiding this song",
  "format_list.undo_ban_label": "You don't like this",
  "VariousArtistsCapitalized": "Various artists"
}
},{}],67:[function(require,module,exports){
module.exports={
  "Album": "Álbum",
  "AndMore": "y {0} más",
  "Artist": "Artista",
  "By": "por",
  "ByLabel": "De",
  "Create Similar Playlist": "Crear playlist similar",
  "DateAdded": "Fecha agregada",
  "Duration": "Duración",
  "Recommended Songs": "Canciones recomendadas",
  "Filter": "Filtrar",
  "Follow": "Seguir",
  "Follower": "Seguidor",
  "FollowersLabel": {
    "one": "Seguidor",
    "other": "Seguidores"
  },
  "FollowersCount": {
    "one": "{0} seguidor",
    "other": "{0} seguidores"
  },
  "Following": "Siguiendo",
  "FollowingLabel": "Siguiendo",
  "ListenersLabel": "Oyentes mensuales",
  "FollowsYou": "Te sigue",
  "HoldToPreview": "Haz clic y mantén pulsado para oír la muestra preliminar",
  "ListenCount": {
    "one": "1 reproducción",
    "other": "{0} reproducciones"
  },
  "ListenReactionMulti": "{0} oyentes en tu red",
  "ListenReactionSingle": "{0} escucha esto",
  "LocalFile": "Archivo local",
  "More": "Más",
  "MoreSongsLoad": "Se cargarán más canciones a medida que escuchas",
  "Pause": "Pausa",
  "Play": "Reproducir",
  "Playlist": "Lista",
  "PressEnterToPlay": "Press Shift + Enter to play",
  "Popularity": "Popularidad",
  "Progress": "Progreso",
  "Remove": "Eliminar",
  "RemoveYourMusic": "Eliminar de Tu Biblioteca",
  "RemoveFromYourFavoriteSongs": "Eliminar de tus Canciones favoritas",
  "Save": "Guardar",
  "SaveYourMusic": "Guardar en Tu Biblioteca",
  "SaveToYourFavoriteSongs": "Guardar en tus Canciones favoritas",
  "Saved": "Guardado",
  "StartRadio": "Comenzar Radio",
  "Time": "Tiempo",
  "Title": "Título",
  "Toplist": "Canciones más reproducidas",
  "Track": "Canción",
  "Unfollow": "Dejar de seguir",
  "User": "Usuario",
  "ViewAll": "Ver todos",
  "HoursShort": "{0} hr",
  "MinutesShort": "{0} min",
  "SecondsShort": "{0} seg",
  "ErrorTitle": "Hubo un problema al mostrar esta página.",
  "ErrorMessage": "Puede ser que esta página no exista o que haya ocurrido un error.",
  "OfflineTitle": "Esta página no se encuentra disponible sin conexión.",
  "OfflineMessage": "Conéctate a la red para cargar.",
  "MadeFor": "Hecho para {0}",
  "heart_label": "Me gusta",
  "undo_heart_label": "Te gusta esto",
  "ban_label": "Eliminar",
  "format_list.ban_label": "No me gusta",
  "nft.ban_song_label": "Hide this song",
  "nft.undo_ban_song_label": "Stop hiding this song",
  "format_list.undo_ban_label": "No te gusta esto",
  "VariousArtistsCapitalized": "Varios artistas"
}
},{}],68:[function(require,module,exports){
module.exports={
  "Album": "Álbum",
  "AndMore": "y {0} más",
  "Artist": "Artista",
  "By": "por",
  "ByLabel": "De",
  "Create Similar Playlist": "Crear playlist similar",
  "DateAdded": "Fecha en la que se añadió",
  "Duration": "Duración",
  "Recommended Songs": "Canciones recomendadas",
  "Filter": "Filtrar",
  "Follow": "Seguir",
  "Follower": "Seguidor",
  "FollowersLabel": {
    "one": "Seguidor",
    "other": "Seguidores"
  },
  "FollowersCount": {
    "one": "{0} seguidor",
    "other": "{0} seguidores"
  },
  "Following": "Siguiendo",
  "FollowingLabel": "Siguiendo",
  "ListenersLabel": "Oyentes mensuales",
  "FollowsYou": "Te sigue",
  "HoldToPreview": "Pulsa y mantén pulsado para oír la muestra preliminar",
  "ListenCount": {
    "one": "1 reproducción",
    "other": "{0} reproducciones"
  },
  "ListenReactionMulti": "{0} oyentes en tu red",
  "ListenReactionSingle": "{0} escucha esto",
  "LocalFile": "Archivo local",
  "More": "Más",
  "MoreSongsLoad": "Se cargarán más canciones mientras escuchas",
  "Pause": "Pausar",
  "Play": "Reproducir",
  "Playlist": "Lista",
  "PressEnterToPlay": "Press Shift + Enter to play",
  "Popularity": "Popularidad",
  "Progress": "Completado",
  "Remove": "Retirar",
  "RemoveYourMusic": "Eliminar de Tu biblioteca",
  "RemoveFromYourFavoriteSongs": "Retirar de tus Canciones favoritas",
  "Save": "Guardar",
  "SaveYourMusic": "Guardar en Tu biblioteca",
  "SaveToYourFavoriteSongs": "Guardar en tus Canciones favoritas",
  "Saved": "Guardada",
  "StartRadio": "Comenzar radio",
  "Time": "Tiempo",
  "Title": "Título",
  "Toplist": "Canciones más escuchadas",
  "Track": "Canción",
  "Unfollow": "Dejar de seguir",
  "User": "Usuario",
  "ViewAll": "Ver todos",
  "HoursShort": "{0} hr",
  "MinutesShort": "{0} min",
  "SecondsShort": "{0} seg",
  "ErrorTitle": "Se ha producido un problema al mostrar esta página.",
  "ErrorMessage": "Esta página no existe o se ha producido un error.",
  "OfflineTitle": "Esta página no está disponible sin conexión.",
  "OfflineMessage": "Por favor, conéctate para cargar.",
  "MadeFor": "Hecha para {0}",
  "heart_label": "Me gusta",
  "undo_heart_label": "Te gusta",
  "ban_label": "Retirar",
  "format_list.ban_label": "No me gusta",
  "nft.ban_song_label": "Hide this song",
  "nft.undo_ban_song_label": "Stop hiding this song",
  "format_list.undo_ban_label": "No te gusta esto",
  "VariousArtistsCapitalized": "Varios artistas"
}
},{}],69:[function(require,module,exports){
module.exports={
  "Album": "Albumi",
  "AndMore": "ja {0} muuta",
  "Artist": "Artisti",
  "By": "tekijältä",
  "ByLabel": "tekijältä",
  "Create Similar Playlist": "Luo samankaltainen soittolista",
  "DateAdded": "Lisäyspäivä",
  "Duration": "Kesto",
  "Recommended Songs": "Suositellut kappaleet",
  "Filter": "Suodatin",
  "Follow": "Seuraa",
  "Follower": "Seuraaja",
  "FollowersLabel": {
    "one": "Seuraaja",
    "other": "Seuraajat"
  },
  "FollowersCount": {
    "one": "{0} seuraaja",
    "other": "{0} seuraajaa"
  },
  "Following": "Seurataan",
  "FollowingLabel": "Seurataan",
  "ListenersLabel": "Kuuntelijat kuukauden aikana",
  "FollowsYou": "Seuraa sinua",
  "HoldToPreview": "Kuuntele pätkä pitämällä tätä painettuna",
  "ListenCount": {
    "one": "1 toisto",
    "other": "{0} toistoa"
  },
  "ListenReactionMulti": "{0} kuuntelijaa verkostossasi",
  "ListenReactionSingle": "{0} kuuntelee tätä",
  "LocalFile": "Paikallinen tiedosto",
  "More": "Lisää",
  "MoreSongsLoad": "Lisää kappaleita ladataan kuuntelun aikana",
  "Pause": "Tauko",
  "Play": "Toista",
  "Playlist": "Soittolista",
  "PressEnterToPlay": "Press Shift + Enter to play",
  "Popularity": "Suosio",
  "Progress": "Edistyminen",
  "Remove": "Poista",
  "RemoveYourMusic": "Poista omasta kirjastosta",
  "RemoveFromYourFavoriteSongs": "Poista suosikkikappaleista",
  "Save": "Tallenna",
  "SaveYourMusic": "Tallenna omaan kirjastoon",
  "SaveToYourFavoriteSongs": "Tallenna suosikkikappaleisiin",
  "Saved": "Tallennettu",
  "StartRadio": "Käynnistä radio",
  "Time": "Kesto",
  "Title": "Nimi",
  "Toplist": "Suosituimmat kappaleet",
  "Track": "Kappale",
  "Unfollow": "Lopeta seuraaminen",
  "User": "Käyttäjä",
  "ViewAll": "Näytä kaikki",
  "HoursShort": "{0} h",
  "MinutesShort": "{0} min",
  "SecondsShort": "{0} s",
  "ErrorTitle": "Sivun näyttämisessä ilmeni ongelma!",
  "ErrorMessage": "Sivua ei ole, tai tapahtui virhe.",
  "OfflineTitle": "Sivu ei ole saatavilla offline-tilassa!",
  "OfflineMessage": "Siirry online-tilaan, jotta voit ladata.",
  "MadeFor": "Luotu käyttäjälle {0}",
  "heart_label": "Tykkää",
  "undo_heart_label": "Tykätty",
  "ban_label": "Poista",
  "format_list.ban_label": "En tykkää",
  "nft.ban_song_label": "Hide this song",
  "nft.undo_ban_song_label": "Stop hiding this song",
  "format_list.undo_ban_label": "Et tykkää tästä",
  "VariousArtistsCapitalized": "Eri esittäjiä"
}
},{}],70:[function(require,module,exports){
module.exports={
  "Album": "Album",
  "AndMore": "et {0} autres",
  "Artist": "Artiste",
  "By": "par",
  "ByLabel": "Par",
  "Create Similar Playlist": "Créer une liste de lecture semblable",
  "DateAdded": "Ajouté le",
  "Duration": "Durée",
  "Recommended Songs": "Chansons recommandées",
  "Filter": "Filtrer",
  "Follow": "Suivre",
  "Follower": "Abonné",
  "FollowersLabel": {
    "one": "Abonné",
    "other": "Abonné"
  },
  "FollowersCount": {
    "one": "{0} abonné",
    "other": "{0} abonnés"
  },
  "Following": "Suivis",
  "FollowingLabel": "Suivis",
  "ListenersLabel": "Auditeurs mensuels",
  "FollowsYou": "Vous suit",
  "HoldToPreview": "Cliquez longuement pour avoir un aperçu",
  "ListenCount": {
    "one": "1 lecture",
    "other": "{0} écoutes"
  },
  "ListenReactionMulti": "{0} auditeurs dans votre réseau",
  "ListenReactionSingle": "{0} écoute ceci",
  "LocalFile": "Fichier local",
  "More": "Plus",
  "MoreSongsLoad": "D'autres chansons se chargent pendant que vous écoutez",
  "Pause": "Pause",
  "Play": "Lecture",
  "Playlist": "Playlist",
  "PressEnterToPlay": "Press Shift + Enter to play",
  "Popularity": "Popularité",
  "Progress": "Progression",
  "Remove": "Supprimer",
  "RemoveYourMusic": "Supprimer de la Bibliothèque",
  "RemoveFromYourFavoriteSongs": "Supprimer de vos chansons favorites",
  "Save": "Sauvegarder",
  "SaveYourMusic": "Enregistrer dans la Bibliothèque",
  "SaveToYourFavoriteSongs": "Enregistrer dans vos chansons favorites",
  "Saved": "Sauvegardé",
  "StartRadio": "Lancer la radio",
  "Time": "Durée",
  "Title": "Titre",
  "Toplist": "Meilleures chansons",
  "Track": "Titre",
  "Unfollow": "Ne plus suivre",
  "User": "Utilisateur",
  "ViewAll": "Voir tout",
  "HoursShort": "{0} h",
  "MinutesShort": "{0} min",
  "SecondsShort": "{0} s",
  "ErrorTitle": "Un problème est survenu lors de l'affichage de cette page!",
  "ErrorMessage": "Cette page n'existe pas ou une erreur s'est produite.",
  "OfflineTitle": "Cette page n'est pas accessible hors ligne!",
  "OfflineMessage": "Veuillez accéder à Internet pour charger le contenu.",
  "MadeFor": "Créée pour {0}",
  "heart_label": "J'aime",
  "undo_heart_label": "A aimé",
  "ban_label": "Supprimer",
  "format_list.ban_label": "Je n'aime pas",
  "nft.ban_song_label": "Hide this song",
  "nft.undo_ban_song_label": "Stop hiding this song",
  "format_list.undo_ban_label": "Vous n’aimez pas cela",
  "VariousArtistsCapitalized": "Différents artistes"
}
},{}],71:[function(require,module,exports){
module.exports={
  "Album": "Album",
  "AndMore": "et {0} autres",
  "Artist": "Artiste",
  "By": "par",
  "ByLabel": "Par",
  "Create Similar Playlist": "Créer une playlist similaire",
  "DateAdded": "Ajouté le",
  "Duration": "Durée",
  "Recommended Songs": "Titres recommandés",
  "Filter": "Filtre",
  "Follow": "S'abonner",
  "Follower": "Abonné",
  "FollowersLabel": {
    "one": "Abonné",
    "other": "Abonnés"
  },
  "FollowersCount": {
    "one": "{0} abonné",
    "other": "{0} abonnés"
  },
  "Following": "Abonné",
  "FollowingLabel": "Abonné",
  "ListenersLabel": "Nombres de personnes qui écoutent par mois",
  "FollowsYou": "Est abonné à vous",
  "HoldToPreview": "Cliquez longuement pour avoir un aperçu",
  "ListenCount": {
    "one": "1 lecture",
    "other": "{0} écoutes"
  },
  "ListenReactionMulti": "{0} auditeurs dans votre réseau",
  "ListenReactionSingle": "{0} écoute ceci.",
  "LocalFile": "Fichier local",
  "More": "Plus",
  "MoreSongsLoad": "D'autres titres se chargent pendant que vous écoutez.",
  "Pause": "Pause",
  "Play": "Lire",
  "Playlist": "Playlist",
  "PressEnterToPlay": "Press Shift + Enter to play",
  "Popularity": "Popularité",
  "Progress": "Progression",
  "Remove": "Supprimer",
  "RemoveYourMusic": "Supprimer de Bibliothèque",
  "RemoveFromYourFavoriteSongs": "Supprimer de vos titres favoris",
  "Save": "Sauvegarder",
  "SaveYourMusic": "Sauvegarder dans Bibliothèque",
  "SaveToYourFavoriteSongs": "Ajouter à vos titres favoris",
  "Saved": "Sauvegardé",
  "StartRadio": "Ecouter la radio",
  "Time": "Durée",
  "Title": "Titre",
  "Toplist": "Top titres",
  "Track": "Titre",
  "Unfollow": "Se désabonner",
  "User": "Utilisateur",
  "ViewAll": "Présentation tout",
  "HoursShort": "{0} h",
  "MinutesShort": "{0} min",
  "SecondsShort": "{0} s",
  "ErrorTitle": "Problème d'affichage !",
  "ErrorMessage": "Cette page n'existe pas, ou une erreur s'est produite.",
  "OfflineTitle": "Cette page n'est pas disponible hors connexion !",
  "OfflineMessage": "Connectez-vous pour procéder au chargement.",
  "MadeFor": "Concocté pour {0}",
  "heart_label": "J'aime",
  "undo_heart_label": "A aimé",
  "ban_label": "Supprimer",
  "format_list.ban_label": "Je n'aime pas",
  "nft.ban_song_label": "Hide this song",
  "nft.undo_ban_song_label": "Stop hiding this song",
  "format_list.undo_ban_label": "Vous n'aimez pas ce contenu",
  "VariousArtistsCapitalized": "Différents artistes"
}
},{}],72:[function(require,module,exports){
module.exports={
  "Album": "Album",
  "AndMore": "és még {0} felhasználó",
  "Artist": "Előadó",
  "By": "tőle:",
  "ByLabel": "Tőle:",
  "Create Similar Playlist": "Hasonló műsorlista létrehozása",
  "DateAdded": "Dátum hozzáadva",
  "Duration": "Időtartam",
  "Recommended Songs": "Ajánlott dalok",
  "Filter": "Szűrő",
  "Follow": "Követés",
  "Follower": "Követő",
  "FollowersLabel": {
    "one": "Követő",
    "other": "Követők"
  },
  "FollowersCount": {
    "one": "{0} követő",
    "other": "{0} követő"
  },
  "Following": "Követések",
  "FollowingLabel": "Követések",
  "ListenersLabel": "Hallgatók havonta",
  "FollowsYou": "Téged követ",
  "HoldToPreview": "Tartsd nyomva a belehallgatáshoz",
  "ListenCount": {
    "one": "1 lejátszás",
    "other": "{0} lejátszás"
  },
  "ListenReactionMulti": "{0} ismerősöd hallgatta meg",
  "ListenReactionSingle": "{0} már meghallgatta",
  "LocalFile": "Helyi fájl",
  "More": "Több",
  "MoreSongsLoad": "Lesz még szám, csak hallgasd tovább",
  "Pause": "Szünet",
  "Play": "Lejátszás",
  "Playlist": "Lejátszási lista",
  "PressEnterToPlay": "Press Shift + Enter to play",
  "Popularity": "Népszerűség",
  "Progress": "Állapot",
  "Remove": "Eltávolítás",
  "RemoveYourMusic": "Törlés a Gyűjteményemből",
  "RemoveFromYourFavoriteSongs": "Törlés a Kedvenc dalok közül",
  "Save": "Mentés",
  "SaveYourMusic": "Mentés a Gyűjteményedbe",
  "SaveToYourFavoriteSongs": "Mentés a Kedvenc dalokhoz",
  "Saved": "Mentett",
  "StartRadio": "Rádió bekapcsolása",
  "Time": "Idő",
  "Title": "Cím",
  "Toplist": "Toplista",
  "Track": "Dal",
  "Unfollow": "Nem követem",
  "User": "Felhasználó",
  "ViewAll": "Mindent mutat",
  "HoursShort": "{0} óra",
  "MinutesShort": "{0} perc",
  "SecondsShort": "{0} mp",
  "ErrorTitle": "Hiba történt az oldal megjelenítésekor.",
  "ErrorMessage": "Az oldal nem létezik, vagy hiba történt.",
  "OfflineTitle": "Ez az oldal offline módban nem érhető el.",
  "OfflineMessage": "Csatlakozz az internethez, majd indítsd el.",
  "MadeFor": "{0} felhasználónak készült",
  "heart_label": "Tetszik",
  "undo_heart_label": "Kedvelted",
  "ban_label": "Eltávolítás",
  "format_list.ban_label": "Nem tetszik",
  "nft.ban_song_label": "Hide this song",
  "nft.undo_ban_song_label": "Stop hiding this song",
  "format_list.undo_ban_label": "Ez nem tetszett neked",
  "VariousArtistsCapitalized": "Különböző előadók"
}
},{}],73:[function(require,module,exports){
module.exports={
  "Album": "Album",
  "AndMore": "dan {0} lagi",
  "Artist": "Artis",
  "By": "menurut",
  "ByLabel": "Dari",
  "Create Similar Playlist": "Buat Playlist Serupa",
  "DateAdded": "Tanggal Dimuat",
  "Duration": "Durasi",
  "Recommended Songs": "Lagu yang Direkomendasikan",
  "Filter": "Filter",
  "Follow": "Ikuti",
  "Follower": "Pengikut",
  "FollowersLabel": {
    "one": "Pengikut",
    "other": "Pengikut"
  },
  "FollowersCount": {
    "one": "{0} pengikut",
    "other": "{0} pengikut"
  },
  "Following": "Mengikuti",
  "FollowingLabel": "Mengikuti",
  "ListenersLabel": "Pendengar Bulanan",
  "FollowsYou": "Mengikutimu",
  "HoldToPreview": "Klik dan Tahan untuk Pratinjau",
  "ListenCount": {
    "one": "1 pemutaran",
    "other": "{0} permainan"
  },
  "ListenReactionMulti": "{0} pendengar di jaringanmu",
  "ListenReactionSingle": "{0} mendengarkan ini",
  "LocalFile": "File Lokal",
  "More": "Lainnya",
  "MoreSongsLoad": "Lebih banyak lagu dimuat saat kamu mendengarkan",
  "Pause": "Jeda",
  "Play": "Play",
  "Playlist": "Playlist",
  "PressEnterToPlay": "Press Shift + Enter to play",
  "Popularity": "Popularitas",
  "Progress": "Kemajuan",
  "Remove": "Hapus",
  "RemoveYourMusic": "Hapus dari Koleksi Kamu",
  "RemoveFromYourFavoriteSongs": "Hapus dari Lagu Favoritmu",
  "Save": "Simpan",
  "SaveYourMusic": "Simpan ke Koleksi Kamu",
  "SaveToYourFavoriteSongs": "Simpan ke Lagu Favoritmu",
  "Saved": "Tersimpan",
  "StartRadio": "Mulai Radio",
  "Time": "Waktu",
  "Title": "Judul",
  "Toplist": "Lagu teratas",
  "Track": "Lagu",
  "Unfollow": "Berhenti mengikuti",
  "User": "Pengguna",
  "ViewAll": "Lihat Semua",
  "HoursShort": "{0} jam",
  "MinutesShort": "{0} mnt",
  "SecondsShort": "{0} dtk",
  "ErrorTitle": "Ada masalah saat menampilkan halaman ini!",
  "ErrorMessage": "Halaman ini tidak ada atau terjadi kesalahan.",
  "OfflineTitle": "Halaman ini tidak tersedia secara offline!",
  "OfflineMessage": "Alihkan ke online untuk memuat.",
  "MadeFor": "Dibuat untuk {0}",
  "heart_label": "Suka",
  "undo_heart_label": "Disukai",
  "ban_label": "Hapus",
  "format_list.ban_label": "Tidak suka",
  "nft.ban_song_label": "Hide this song",
  "nft.undo_ban_song_label": "Stop hiding this song",
  "format_list.undo_ban_label": "Kamu tidak suka ini",
  "VariousArtistsCapitalized": "Berbagai artis"
}
},{}],74:[function(require,module,exports){
module.exports={
  "Album": "Album",
  "AndMore": "e altri {0}",
  "Artist": "Artista",
  "By": "per",
  "ByLabel": "di",
  "Create Similar Playlist": "Crea playlist simile",
  "DateAdded": "Aggiunto il",
  "Duration": "Durata",
  "Recommended Songs": "Brani consigliati",
  "Filter": "Filtra",
  "Follow": "Segui",
  "Follower": "Follower",
  "FollowersLabel": {
    "one": "Follower",
    "other": "Follower"
  },
  "FollowersCount": {
    "one": "{0} follower",
    "other": "{0} follower"
  },
  "Following": "Following",
  "FollowingLabel": "Following",
  "ListenersLabel": "Ascoltatori questo mese",
  "FollowsYou": "Ti segue",
  "HoldToPreview": "Tieni premuto per un'anteprima",
  "ListenCount": {
    "one": "1 riproduzione",
    "other": "{0} riproduzioni"
  },
  "ListenReactionMulti": "{0} ascoltatori nella tua rete",
  "ListenReactionSingle": "{0} ascolta questo",
  "LocalFile": "File locale",
  "More": "Più",
  "MoreSongsLoad": "Durante l'ascolto vengono caricati altri brani",
  "Pause": "Pausa",
  "Play": "Play",
  "Playlist": "Playlist",
  "PressEnterToPlay": "Press Shift + Enter to play",
  "Popularity": "Popolarità",
  "Progress": "Progress",
  "Remove": "Rimuovi",
  "RemoveYourMusic": "Elimina da La tua libreria",
  "RemoveFromYourFavoriteSongs": "Rimuovi dai tuoi brani preferiti",
  "Save": "Salva",
  "SaveYourMusic": "Salva in La tua libreria",
  "SaveToYourFavoriteSongs": "Aggiungi ai tuoi brani preferiti",
  "Saved": "Salvato",
  "StartRadio": "Crea una radio",
  "Time": "Durata",
  "Title": "Titolo",
  "Toplist": "Brani top",
  "Track": "Brano",
  "Unfollow": "Non seguire più",
  "User": "Utente",
  "ViewAll": "Visualizza tutto",
  "HoursShort": "{0} ore",
  "MinutesShort": "{0} min.",
  "SecondsShort": "{0} sec",
  "ErrorTitle": "Si è verificato un errore nella visualizzazione di questa pagina.",
  "ErrorMessage": "Questa pagina non esiste o si è verificato un errore.",
  "OfflineTitle": "Questa pagina non è disponibile offline.",
  "OfflineMessage": "Passa online per caricare.",
  "MadeFor": "Realizzata per {0}",
  "heart_label": "Preferiti",
  "undo_heart_label": "Preferiti",
  "ban_label": "Rimuovi",
  "format_list.ban_label": "Non mi piace",
  "nft.ban_song_label": "Hide this song",
  "nft.undo_ban_song_label": "Stop hiding this song",
  "format_list.undo_ban_label": "Questo elemento non ti piace",
  "VariousArtistsCapitalized": "Artisti vari"
}
},{}],75:[function(require,module,exports){
module.exports={
  "Album": "アルバム",
  "AndMore": "その他{0}人",
  "Artist": "アーティスト",
  "By": "/",
  "ByLabel": "/",
  "Create Similar Playlist": "同様のプレイリストを作成",
  "DateAdded": "追加日",
  "Duration": "期間",
  "Recommended Songs": "おすすめの曲",
  "Filter": "フィルター",
  "Follow": "フォロー",
  "Follower": "フォロワー",
  "FollowersLabel": {
    "one": "フォロワー",
    "other": "フォロワー"
  },
  "FollowersCount": {
    "one": "{0}人のフォロワー",
    "other": "{0}人のフォロワー"
  },
  "Following": "フォロー中",
  "FollowingLabel": "フォロー中",
  "ListenersLabel": "今月のリスナー",
  "FollowsYou": "あなたをフォローしています",
  "HoldToPreview": "プレビューするには、クリックを押しします",
  "ListenCount": {
    "one": "1回再生",
    "other": "{0}回再生"
  },
  "ListenReactionMulti": "ネットワーク内で{0}人が聴いています",
  "ListenReactionSingle": "{0}さんはこれを聴いています",
  "LocalFile": "ローカルファイル",
  "More": "詳細",
  "MoreSongsLoad": "再生すると、さらに曲がロードされます",
  "Pause": "一時停止",
  "Play": "曲の再生",
  "Playlist": "プレイリスト",
  "PressEnterToPlay": "Press Shift + Enter to play",
  "Popularity": "人気",
  "Progress": "進捗",
  "Remove": "削除",
  "RemoveYourMusic": "My Musicから削除",
  "RemoveFromYourFavoriteSongs": "My Library から削除する",
  "Save": "保存",
  "SaveYourMusic": "My Musicに保存",
  "SaveToYourFavoriteSongs": "お気に入りソングに保存しました。",
  "Saved": "保存済み",
  "StartRadio": "Radioを開始",
  "Time": "時間",
  "Title": "タイトル",
  "Toplist": "トップ曲",
  "Track": "ソング",
  "Unfollow": "フォローをやめる",
  "User": "ユーザー",
  "ViewAll": "すべて表示",
  "HoursShort": "{0} 時間",
  "MinutesShort": "{0} 分",
  "SecondsShort": "{0} 秒",
  "ErrorTitle": "このページの表示中に問題が発生しました。",
  "ErrorMessage": "このページは存在しないか、表示中にエラーが発生しました。",
  "OfflineTitle": "このページはオフラインでは利用できません。",
  "OfflineMessage": "ロードするには、インターネットに接続してください。",
  "MadeFor": " {0}さんのために作られたプレイリスト",
  "heart_label": "いいね！",
  "undo_heart_label": "お気に入り",
  "ban_label": "削除",
  "format_list.ban_label": "この曲を削除する",
  "nft.ban_song_label": "Hide this song",
  "nft.undo_ban_song_label": "Stop hiding this song",
  "format_list.undo_ban_label": "この曲を削除する",
  "VariousArtistsCapitalized": "様々なアーティスト"
}
},{}],76:[function(require,module,exports){
module.exports={
  "Album": "Album",
  "AndMore": "dan {0} lagi",
  "Artist": "Artis",
  "By": "oleh",
  "ByLabel": "Lebih banyak lagi oleh",
  "Create Similar Playlist": "Cipta Senarai Main Serupa",
  "DateAdded": "Tarikh Ditambah",
  "Duration": "Tempoh",
  "Recommended Songs": "Lagu yang Dicadangkan",
  "Filter": "Penapis",
  "Follow": "Ikut",
  "Follower": "Pengikut",
  "FollowersLabel": {
    "one": "Pengikut",
    "other": "Pengikut"
  },
  "FollowersCount": {
    "one": "{0} pengikut",
    "other": "{0} pengikut"
  },
  "Following": "Mengikuti",
  "FollowingLabel": "Mengikuti",
  "ListenersLabel": "Pendengar Bulanan",
  "FollowsYou": "Megikuti Anda",
  "HoldToPreview": "Klik dan Tahan untuk Pratonton",
  "ListenCount": {
    "one": "1 main",
    "other": "{0} main"
  },
  "ListenReactionMulti": "{0} pendengar dalam rangkaian anda",
  "ListenReactionSingle": "{0} mendengar ini",
  "LocalFile": "Fail Setempat",
  "More": "Lebih banyak",
  "MoreSongsLoad": "Lebih banyak lagu dimuatkan semasa anda mendengar",
  "Pause": "Jeda",
  "Play": "Main",
  "Playlist": "Senarai main",
  "PressEnterToPlay": "Press Shift + Enter to play",
  "Popularity": "Populariti",
  "Progress": "Perkembangan",
  "Remove": "Keluarkan",
  "RemoveYourMusic": "Keluarkan daripada Pustaka Anda",
  "RemoveFromYourFavoriteSongs": "Keluarkan daripada Lagu Kegemaran anda",
  "Save": "Simpan",
  "SaveYourMusic": "Simpan ke Pustaka Anda",
  "SaveToYourFavoriteSongs": "Simpankan ke dalam Lagu Kegemaran anda",
  "Saved": "Disimpan",
  "StartRadio": "Mulakan Radio",
  "Time": "Masa",
  "Title": "Tajuk",
  "Toplist": "Lagu popular",
  "Track": "Lagu",
  "Unfollow": "Nyahikut",
  "User": "Pengguna",
  "ViewAll": "Lihat Semua",
  "HoursShort": "{0} jam",
  "MinutesShort": "{0} min",
  "SecondsShort": "{0} saat",
  "ErrorTitle": "Terdapat masalah untuk memaparkan laman ini!",
  "ErrorMessage": "Laman ini sama ada tidak wujud atau ralat telah berlaku.",
  "OfflineTitle": "Laman ini tidak tersedia di luar talian!",
  "OfflineMessage": "Sila ke online untuk memuatkan.",
  "MadeFor": "Dibuat untuk {0}",
  "heart_label": "Suka",
  "undo_heart_label": "Disukai",
  "ban_label": "Keluarkan",
  "format_list.ban_label": "Tidak suka",
  "nft.ban_song_label": "Hide this song",
  "nft.undo_ban_song_label": "Stop hiding this song",
  "format_list.undo_ban_label": "Anda tidak sukakannya",
  "VariousArtistsCapitalized": "Pelbagai artis"
}
},{}],77:[function(require,module,exports){
module.exports={
  "Album": "Album",
  "AndMore": "en {0} meer",
  "Artist": "Artiest",
  "By": "van",
  "ByLabel": "Van",
  "Create Similar Playlist": "Vergelijkbare afspeellijst maken",
  "DateAdded": "Datum toegevoegd",
  "Duration": "Duur",
  "Recommended Songs": "Aanbevolen nummers",
  "Filter": "Filter",
  "Follow": "Volgen",
  "Follower": "Volger",
  "FollowersLabel": {
    "one": "Volger",
    "other": "Volger"
  },
  "FollowersCount": {
    "one": "{0} volger",
    "other": "{0} volgers"
  },
  "Following": "Volgend",
  "FollowingLabel": "Volgend",
  "ListenersLabel": "Luisteraars per maand",
  "FollowsYou": "Volgt jou",
  "HoldToPreview": "Klikken en vasthouden om een stukje te horen",
  "ListenCount": {
    "one": "1 keer afgespeeld",
    "other": "{0} keer afgespeeld"
  },
  "ListenReactionMulti": "{0} luisteraars in jouw netwerk",
  "ListenReactionSingle": "{0} luistert hiernaar",
  "LocalFile": "Lokaal bestand",
  "More": "Meer",
  "MoreSongsLoad": "Meer nummers worden geladen terwijl je luistert",
  "Pause": "Pauze",
  "Play": "Afspelen",
  "Playlist": "Afspeellijst",
  "PressEnterToPlay": "Press Shift + Enter to play",
  "Popularity": "Populariteit",
  "Progress": "Voortgang",
  "Remove": "Verwijderen",
  "RemoveYourMusic": "Verwijderen uit Bibliotheek",
  "RemoveFromYourFavoriteSongs": "Verwijderen uit je Favoriete nummers",
  "Save": "Opslaan",
  "SaveYourMusic": "Opslaan in Bibliotheek",
  "SaveToYourFavoriteSongs": "Opslaan in je Favoriete nummers",
  "Saved": "Opgeslagen",
  "StartRadio": "Radio starten",
  "Time": "Tijd",
  "Title": "Titel",
  "Toplist": "Topnummers",
  "Track": "Nummer",
  "Unfollow": "Niet meer volgen",
  "User": "Gebruiker",
  "ViewAll": "Alles bekijken",
  "HoursShort": "{0} uur",
  "MinutesShort": "{0} min",
  "SecondsShort": "{0} sec",
  "ErrorTitle": "Er is een fout opgetreden bij het weergeven van deze pagina.",
  "ErrorMessage": "Deze weergave bestaat niet of er is een fout opgetreden.",
  "OfflineTitle": "Deze pagina is niet offline beschikbaar.",
  "OfflineMessage": "Ga online om te laden.",
  "MadeFor": "Gemaakt voor {0}",
  "heart_label": "Vind ik leuk",
  "undo_heart_label": "Geliked",
  "ban_label": "Verwijderen",
  "format_list.ban_label": "Niet leuk",
  "nft.ban_song_label": "Hide this song",
  "nft.undo_ban_song_label": "Stop hiding this song",
  "format_list.undo_ban_label": "Je vindt dit niet leuk",
  "VariousArtistsCapitalized": "Diverse artiesten"
}
},{}],78:[function(require,module,exports){
module.exports={
  "Album": "Album",
  "AndMore": "i {0} więcej",
  "Artist": "Wykonawca",
  "By": "według",
  "ByLabel": "-",
  "Create Similar Playlist": "Utwórz podobną playlistę",
  "DateAdded": "Data dodania",
  "Duration": "Czas trwania",
  "Recommended Songs": "Polecane utwory",
  "Filter": "Filtruj",
  "Follow": "Obserwuj",
  "Follower": "Obserwujący",
  "FollowersLabel": {
    "one": "Obserwujący",
    "other": "Obserwatorzy"
  },
  "FollowersCount": {
    "one": "{0} obserwujący",
    "other": "{0} obserwujących"
  },
  "Following": "Obserwujesz",
  "FollowingLabel": "Obserwujesz",
  "ListenersLabel": "Słuchacze w tym miesiącu",
  "FollowsYou": "Obserwuje Cię",
  "HoldToPreview": "Aby odsłuchać, kliknij i przytrzymaj.",
  "ListenCount": {
    "one": "1 odtworzenie",
    "other": "Liczba odtworzeń: {0}"
  },
  "ListenReactionMulti": "Liczba słuchaczy w Twojej sieci: {0}",
  "ListenReactionSingle": "Użytkownik {0} słucha tego",
  "LocalFile": "Plik lokalny",
  "More": "Więcej",
  "MoreSongsLoad": "Więcej utworów będzie się pojawiać w miarę słuchania",
  "Pause": "Pauza",
  "Play": "Odtwórz",
  "Playlist": "Playlista",
  "PressEnterToPlay": "Press Shift + Enter to play",
  "Popularity": "Popularność",
  "Progress": "Postęp",
  "Remove": "Usuń",
  "RemoveYourMusic": "Usuń z Biblioteki",
  "RemoveFromYourFavoriteSongs": "Usuń z Ulubionych utworów",
  "Save": "Zapisz",
  "SaveYourMusic": "Zapisz w Bibliotece",
  "SaveToYourFavoriteSongs": "Zapisz w Ulubionych utworach",
  "Saved": "Zapisany",
  "StartRadio": "Włącz radio",
  "Time": "Czas",
  "Title": "Tytuł",
  "Toplist": "Najpopularniejsze utwory",
  "Track": "Utwór",
  "Unfollow": "Przestań obserwować",
  "User": "Użytkownik",
  "ViewAll": "Wyświetl wszystko",
  "HoursShort": "{0} godz.",
  "MinutesShort": "{0} min",
  "SecondsShort": "{0} s",
  "ErrorTitle": "Wystąpił błąd podczas wyświetlania tej strony!",
  "ErrorMessage": "Ta strona nie istnieje lub wystąpił błąd.",
  "OfflineTitle": "Ta strona nie jest dostępna w trybie offline!",
  "OfflineMessage": "Przejdź do trybu online, aby załadować.",
  "MadeFor": "Przygotowana dla {0}",
  "heart_label": "Lubię to",
  "undo_heart_label": "Polubiono",
  "ban_label": "Usuń",
  "format_list.ban_label": "Nie lubię",
  "nft.ban_song_label": "Hide this song",
  "nft.undo_ban_song_label": "Stop hiding this song",
  "format_list.undo_ban_label": "Nie podoba Ci się",
  "VariousArtistsCapitalized": "Różni wykonawcy"
}
},{}],79:[function(require,module,exports){
module.exports={
  "Album": "Álbum",
  "AndMore": "e mais {0}",
  "Artist": "Artista",
  "By": "de",
  "ByLabel": "De",
  "Create Similar Playlist": "Criar playlist similar",
  "DateAdded": "Adicionado em",
  "Duration": "Duração",
  "Recommended Songs": "Músicas recomendadas",
  "Filter": "Filtrar",
  "Follow": "Seguir",
  "Follower": "Seguidor",
  "FollowersLabel": {
    "one": "Seguidor",
    "other": "Seguidores"
  },
  "FollowersCount": {
    "one": "{0} seguidor",
    "other": "{0} seguidores"
  },
  "Following": "Seguindo",
  "FollowingLabel": "Seguindo",
  "ListenersLabel": "Ouvintes mensais",
  "FollowsYou": "Segue você",
  "HoldToPreview": "Clique e segure para a prévia",
  "ListenCount": {
    "one": "1 reprodução",
    "other": "{0} reproduções"
  },
  "ListenReactionMulti": "{0} ouvintes na sua rede",
  "ListenReactionSingle": "{0} ouvem isso",
  "LocalFile": "Arquivo local",
  "More": "Mais",
  "MoreSongsLoad": "Mais músicas serão carregadas à medida que você for escutando",
  "Pause": "Pause",
  "Play": "Play",
  "Playlist": "Playlist",
  "PressEnterToPlay": "Press Shift + Enter to play",
  "Popularity": "Popularidade",
  "Progress": "Progresso",
  "Remove": "Remover",
  "RemoveYourMusic": "Remover da Sua Biblioteca",
  "RemoveFromYourFavoriteSongs": "Remover de Músicas Favoritas",
  "Save": "Salvar",
  "SaveYourMusic": "Salvar na Sua Biblioteca",
  "SaveToYourFavoriteSongs": "Salva em Músicas Favoritas",
  "Saved": "Salvo",
  "StartRadio": "Abrir rádio",
  "Time": "Tempo",
  "Title": "Título",
  "Toplist": "Músicas mais tocadas",
  "Track": "Música",
  "Unfollow": "Deixar de seguir",
  "User": "Usuário",
  "ViewAll": "Ver tudo",
  "HoursShort": "{0} h",
  "MinutesShort": "{0} m",
  "SecondsShort": "{0} s",
  "ErrorTitle": "Tivemos um problema ao mostrar esta página!",
  "ErrorMessage": "Essa página não existe ou ocorreu um erro.",
  "OfflineTitle": "Essa página não está disponível offline!",
  "OfflineMessage": "Fique online para carregar.",
  "MadeFor": "Feito para {0}",
  "heart_label": "Curtir",
  "undo_heart_label": "Curtiu",
  "ban_label": "Remover",
  "format_list.ban_label": "Não curto",
  "nft.ban_song_label": "Hide this song",
  "nft.undo_ban_song_label": "Stop hiding this song",
  "format_list.undo_ban_label": "Você não curte isso",
  "VariousArtistsCapitalized": "Vários artistas"
}
},{}],80:[function(require,module,exports){
module.exports={
  "Album": "Album",
  "AndMore": "och {0} till",
  "Artist": "Artist",
  "By": "av",
  "ByLabel": "Av",
  "Create Similar Playlist": "Skapa en liknande spellista",
  "DateAdded": "Tillagd",
  "Duration": "Längd",
  "Recommended Songs": "Rekommenderade låtar",
  "Filter": "Filtrera",
  "Follow": "Följ",
  "Follower": "Följare",
  "FollowersLabel": {
    "one": "Följare",
    "other": "Följare"
  },
  "FollowersCount": {
    "one": "{0} följare",
    "other": "{0} följare"
  },
  "Following": "Följer",
  "FollowingLabel": "Följer",
  "ListenersLabel": "Lyssnare per månad",
  "FollowsYou": "Följer dig",
  "HoldToPreview": "Klicka och håll kvar för att förhandslyssna",
  "ListenCount": {
    "one": "1 uppspelning",
    "other": "{0} uppspelningar"
  },
  "ListenReactionMulti": "{0} lyssnare i ditt nätverk",
  "ListenReactionSingle": "{0} lyssnar på detta",
  "LocalFile": "Lokal fil",
  "More": "Mer",
  "MoreSongsLoad": "Fler låtar läses in medan du lyssnar",
  "Pause": "Pausa",
  "Play": "Spela upp",
  "Playlist": "Spellista",
  "PressEnterToPlay": "Press Shift + Enter to play",
  "Popularity": "Popularitet",
  "Progress": "Lyssnat",
  "Remove": "Ta bort",
  "RemoveYourMusic": "Ta bort från Ditt bibliotek",
  "RemoveFromYourFavoriteSongs": "Ta bort från dina favoritlåtar",
  "Save": "Spara",
  "SaveYourMusic": "Spara i Ditt bibliotek",
  "SaveToYourFavoriteSongs": "Spara i dina favoritlåtar",
  "Saved": "Sparade",
  "StartRadio": "Starta radio",
  "Time": "Tid",
  "Title": "Titel",
  "Toplist": "Topplåtar",
  "Track": "Låt",
  "Unfollow": "Sluta följa",
  "User": "Användare",
  "ViewAll": "Visa alla",
  "HoursShort": "{0} tim",
  "MinutesShort": "{0} min",
  "SecondsShort": "{0} sek",
  "ErrorTitle": "Det uppstod ett fel när den här sidan skulle visas!",
  "ErrorMessage": "Den här sidan finns inte eller så uppstod ett fel.",
  "OfflineTitle": "Den här sidan är inte tillgänglig offline!",
  "OfflineMessage": "Anslut till internet om du vill läsa in appen.",
  "MadeFor": "Skapad för {0}",
  "heart_label": "Gilla",
  "undo_heart_label": "Gillar",
  "ban_label": "Ta bort",
  "format_list.ban_label": "Gillar inte",
  "nft.ban_song_label": "Hide this song",
  "nft.undo_ban_song_label": "Stop hiding this song",
  "format_list.undo_ban_label": "Du gillar inte det här",
  "VariousArtistsCapitalized": "Olika artister"
}
},{}],81:[function(require,module,exports){
module.exports={
  "Album": "อัลบั้ม",
  "AndMore": "และอีก {0} คน",
  "Artist": "ศิลปิน",
  "By": "โดย",
  "ByLabel": "จาก",
  "Create Similar Playlist": "สร้างเพลย์ลิสต์ที่คล้ายกัน",
  "DateAdded": "เพิ่มวันที่แล้ว",
  "Duration": "ระยะเวลา",
  "Recommended Songs": "เพลงที่แนะนำ",
  "Filter": "ตัวกรอง",
  "Follow": "ติดตาม",
  "Follower": "ผู้ติดตาม",
  "FollowersLabel": {
    "one": "ผู้ติดตาม",
    "other": "ผู้ติดตาม"
  },
  "FollowersCount": {
    "one": "ผู้ติดตาม {0} คน",
    "other": "ผู้ติดตาม {0} คน"
  },
  "Following": "กำลังติดตาม",
  "FollowingLabel": "กำลังติดตาม",
  "ListenersLabel": "ผู้ฟังรายเดือน",
  "FollowsYou": "ติดตามคุณ",
  "HoldToPreview": "คลิกค้างไว้เพื่อฟังตัวอย่าง",
  "ListenCount": {
    "one": "เล่น 1 ครั้ง",
    "other": "เล่น {0} ครั้ง"
  },
  "ListenReactionMulti": "ผู้ฟัง {0} คนในเครือข่ายของคุณ",
  "ListenReactionSingle": "{0} ฟังรายการนี้",
  "LocalFile": "ไฟล์ในเครื่อง",
  "More": "เพิ่มเติม",
  "MoreSongsLoad": "เราจะโหลดเพลงเพิ่มระหว่างที่คุณฟัง",
  "Pause": "หยุดชั่วคราว",
  "Play": "เล่น",
  "Playlist": "เพลย์ลิสต์",
  "PressEnterToPlay": "Press Shift + Enter to play",
  "Popularity": "ความนิยม",
  "Progress": "ความคืบหน้า",
  "Remove": "ลบ",
  "RemoveYourMusic": "ลบจากคอลเลกชันของคุณ",
  "RemoveFromYourFavoriteSongs": "ลบจากเพลงโปรดของคุณ",
  "Save": "บันทึก",
  "SaveYourMusic": "บันทึกในคอลเลกชันของคุณ",
  "SaveToYourFavoriteSongs": "บันทึกในเพลงโปรดของคุณ",
  "Saved": "บันทึกแล้ว",
  "StartRadio": "เริ่มต้นวิทยุ",
  "Time": "เวลา",
  "Title": "ชื่อ",
  "Toplist": "เพลงยอดนิยม",
  "Track": "เพลง",
  "Unfollow": "เลิกติดตาม",
  "User": "ผู้ใช้",
  "ViewAll": "ดูทั้งหมด",
  "HoursShort": "{0} ชั่วโมง",
  "MinutesShort": "{0} นาที",
  "SecondsShort": "{0} วินาที",
  "ErrorTitle": "เกิดปัญหาในการแสดงผลหน้านี้!",
  "ErrorMessage": "ไม่มีหน้านี้หรือเกิดข้อผิดพลาดขึ้น",
  "OfflineTitle": "ไม่สามารถใช้งานหน้านี้ขณะออฟไลน์ได้!",
  "OfflineMessage": "โปรดใช้งานแบบออนไลน์เพื่อโหลด",
  "MadeFor": "จัดทำเพื่อ {0}",
  "heart_label": "ถูกใจ",
  "undo_heart_label": "ถูกใจแล้ว",
  "ban_label": "ลบ",
  "format_list.ban_label": "ไม่ชอบ",
  "nft.ban_song_label": "Hide this song",
  "nft.undo_ban_song_label": "Stop hiding this song",
  "format_list.undo_ban_label": "คุณไม่ชอบเนื้อหานี้",
  "VariousArtistsCapitalized": "รวมศิลปิน"
}
},{}],82:[function(require,module,exports){
module.exports={
  "Album": "Albüm",
  "AndMore": "ve {0} daha",
  "Artist": "Sanatçı",
  "By": "-",
  "ByLabel": "-",
  "Create Similar Playlist": "Benzer Çalma Listesi Oluştur",
  "DateAdded": "Tarih Eklendi",
  "Duration": "Süre",
  "Recommended Songs": "Önerilen Şarkılar",
  "Filter": "Filtrele",
  "Follow": "Takip Et",
  "Follower": "Takipçi",
  "FollowersLabel": {
    "one": "Takipçi",
    "other": "Takipçi"
  },
  "FollowersCount": {
    "one": "{0} takipçi",
    "other": "{0} takipçi"
  },
  "Following": "Takip Ediliyor",
  "FollowingLabel": "Takip Ediliyor",
  "ListenersLabel": "Aylık Dinleyici",
  "FollowsYou": "Seni Takip Ediyor",
  "HoldToPreview": "Basılı Tut ve Önizle",
  "ListenCount": {
    "one": "1 çalma",
    "other": "{0} dinleme"
  },
  "ListenReactionMulti": "Ağında {0} dinleyici",
  "ListenReactionSingle": "{0} bunu dinliyor",
  "LocalFile": "Yerel Dosya",
  "More": "Daha fazla",
  "MoreSongsLoad": "Sen dinledikçe daha fazla şarkı yüklenir",
  "Pause": "Duraklat",
  "Play": "Çal",
  "Playlist": "Çalma listesi",
  "PressEnterToPlay": "Press Shift + Enter to play",
  "Popularity": "Popülerlik",
  "Progress": "Progress",
  "Remove": "Çıkar",
  "RemoveYourMusic": "Kitaplığın'dan kaldır",
  "RemoveFromYourFavoriteSongs": "Favori Şarkılarından Kaldır",
  "Save": "Kaydet",
  "SaveYourMusic": "Kitaplığın'a kaydet",
  "SaveToYourFavoriteSongs": "Favori Şarkılarına Kaydet",
  "Saved": "Kaydedildi",
  "StartRadio": "Radyoyu Başlat",
  "Time": "Saat",
  "Title": "Başlık",
  "Toplist": "En çok dinlenen şarkılar",
  "Track": "Şarkı",
  "Unfollow": "Takip Etmeyi Bırak",
  "User": "Kullanıcı",
  "ViewAll": "Tümünü Görüntüle",
  "HoursShort": "{0} sa",
  "MinutesShort": "{0} dk",
  "SecondsShort": "{0} sn",
  "ErrorTitle": "Bu sayfa görüntülenirken bir sorun oluştu!",
  "ErrorMessage": "Bu sayfa yok veya bir hata oluştu.",
  "OfflineTitle": "Bu sayfa çevrimdışı kullanılamaz!",
  "OfflineMessage": "Yüklemek için lütfen çevrimiçi ol.",
  "MadeFor": "{0} İçin Yapıldı",
  "heart_label": "Beğen",
  "undo_heart_label": "Beğenildi",
  "ban_label": "Çıkar",
  "format_list.ban_label": "Beğenme",
  "nft.ban_song_label": "Hide this song",
  "nft.undo_ban_song_label": "Stop hiding this song",
  "format_list.undo_ban_label": "Bunu beğenmedin",
  "VariousArtistsCapitalized": "Çeşitli sanatçılar"
}
},{}],83:[function(require,module,exports){
module.exports={
  "Album": "Album",
  "AndMore": "và thêm {0}",
  "Artist": "Nghệ sĩ",
  "By": "của",
  "ByLabel": "Của",
  "Create Similar Playlist": "Tạo Playlist Tương tự",
  "DateAdded": "Đã Thêm Ngày",
  "Duration": "Thời lượng",
  "Recommended Songs": "Bài hát Gợi ý",
  "Filter": "Bộ lọc",
  "Follow": "Theo dõi",
  "Follower": "Người theo dõi",
  "FollowersLabel": {
    "one": "Người theo dõi",
    "other": "Người theo dõi"
  },
  "FollowersCount": {
    "one": "{0} người theo dõi",
    "other": "{0} người theo dõi"
  },
  "Following": "Đang theo dõi",
  "FollowingLabel": "Đang theo dõi",
  "ListenersLabel": "Người nghe Hàng tháng",
  "FollowsYou": "Theo dõi Bạn",
  "HoldToPreview": "Nhấp và Giữ để Xem trước",
  "ListenCount": {
    "one": "1 lượt phát",
    "other": "{0} phát"
  },
  "ListenReactionMulti": "{0} người nghe trong mạng lưới của bạn",
  "ListenReactionSingle": "{0} nghe bản này",
  "LocalFile": "File trên máy",
  "More": "Tuỳ chọn...",
  "MoreSongsLoad": "Tải được nhiều bài hát hơn khi bạn nghe",
  "Pause": "Tạm dừng",
  "Play": "Phát",
  "Playlist": "Playlist",
  "PressEnterToPlay": "Press Shift + Enter to play",
  "Popularity": "Mức độ phổ biến",
  "Progress": "Tiến độ",
  "Remove": "Xóa",
  "RemoveYourMusic": "Xóa khỏi Thư viện",
  "RemoveFromYourFavoriteSongs": "Xóa khỏi Bài hát Yêu thích của bạn",
  "Save": "Lưu",
  "SaveYourMusic": "Lưu vào Thư viện",
  "SaveToYourFavoriteSongs": "Lưu vào Bài hát Yêu thích của bạn",
  "Saved": "Đã lưu",
  "StartRadio": "Bắt đầu Radio",
  "Time": "Thời gian",
  "Title": "Tiêu đề",
  "Toplist": "Các bài hát hàng đầu",
  "Track": "Bài hát",
  "Unfollow": "Hủy theo dõi",
  "User": "Người dùng",
  "ViewAll": "Xem Tất cả",
  "HoursShort": "{0} giờ",
  "MinutesShort": "{0} phút",
  "SecondsShort": "{0} giây",
  "ErrorTitle": "Đã có sự cố xảy ra khi hiển thị trang này!",
  "ErrorMessage": "Nội dung này hoặc không tồn tại hoặc đã có lỗi xảy ra.",
  "OfflineTitle": "Trang này không có ở chế độ offline!",
  "OfflineMessage": "Vui lòng truy cập trực tuyến để tải.",
  "MadeFor": "Dành cho {0}",
  "heart_label": "Thích",
  "undo_heart_label": "Đã thích",
  "ban_label": "Xóa",
  "format_list.ban_label": "Không thích",
  "nft.ban_song_label": "Hide this song",
  "nft.undo_ban_song_label": "Stop hiding this song",
  "format_list.undo_ban_label": "Bạn không thích điều này",
  "VariousArtistsCapitalized": "Nhiều nghệ sĩ"
}
},{}],84:[function(require,module,exports){
module.exports={
  "Album": "專輯",
  "AndMore": "還有 {0} 首",
  "Artist": "藝人",
  "By": "－",
  "ByLabel": "來自",
  "Create Similar Playlist": "建立相似的播放清單",
  "DateAdded": "已加入日期",
  "Duration": "長度",
  "Recommended Songs": "推薦歌曲",
  "Filter": "篩選",
  "Follow": "關注",
  "Follower": "粉絲",
  "FollowersLabel": {
    "one": "粉絲",
    "other": "粉絲"
  },
  "FollowersCount": {
    "one": "{0} 粉絲",
    "other": "{0} 位粉絲"
  },
  "Following": "正在關注",
  "FollowingLabel": "正在關注",
  "ListenersLabel": "每月聽眾",
  "FollowsYou": "關注你",
  "HoldToPreview": "按住即可預覽",
  "ListenCount": {
    "one": "1 個播放項目",
    "other": "播放了 {0} 次"
  },
  "ListenReactionMulti": "在你的社群網路中有 {0} 名聽眾",
  "ListenReactionSingle": "{0} 收聽了這首歌曲",
  "LocalFile": "本機檔案",
  "More": "更多",
  "MoreSongsLoad": "聆聽時載入更多歌曲",
  "Pause": "暫停",
  "Play": "播放",
  "Playlist": "播放列表",
  "PressEnterToPlay": "Press Shift + Enter to play",
  "Popularity": "流行",
  "Progress": "進度",
  "Remove": "移除",
  "RemoveYourMusic": "從你的音樂庫中移除",
  "RemoveFromYourFavoriteSongs": "從最愛的歌曲中移除",
  "Save": "儲存",
  "SaveYourMusic": "儲存至你的音樂庫",
  "SaveToYourFavoriteSongs": "儲存至最愛的歌曲",
  "Saved": "已儲存",
  "StartRadio": "啟用電臺",
  "Time": "時間",
  "Title": "標題",
  "Toplist": "當紅歌曲",
  "Track": "歌曲",
  "Unfollow": "取消關注",
  "User": "使用者",
  "ViewAll": "檢視全部",
  "HoursShort": "{0} 小時",
  "MinutesShort": "{0} 分鐘",
  "SecondsShort": "{0} 秒鐘",
  "ErrorTitle": "顯示這個頁面時出現問題！",
  "ErrorMessage": "這個頁面可能不存在或發生錯誤。",
  "OfflineTitle": "離線時無法進入這個頁面！",
  "OfflineMessage": "請上網以載入。",
  "MadeFor": "專為 {0} 精心打造",
  "heart_label": "讚",
  "undo_heart_label": "已按讚",
  "ban_label": "移除",
  "format_list.ban_label": "不喜歡",
  "nft.ban_song_label": "Hide this song",
  "nft.undo_ban_song_label": "Stop hiding this song",
  "format_list.undo_ban_label": "你不喜歡這個",
  "VariousArtistsCapitalized": "多位藝人"
}
},{}],85:[function(require,module,exports){
"use strict";var _gridOverlay=require("./src/gridOverlay"),gridOverlay=_interopRequireWildcard(_gridOverlay),_responsiveTitleType=require("./src/responsiveTitleType"),responsiveTitleType=_interopRequireWildcard(_responsiveTitleType),_attentionHighlight=require("./src/attentionHighlight"),attentionHighlight=_interopRequireWildcard(_attentionHighlight);function _interopRequireWildcard(e){if(e&&e.__esModule)return e;var i={};if(null!=e)for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&(i[r]=e[r]);return i.default=e,i}exports.gridOverlay=gridOverlay,exports.responsiveTitleType=responsiveTitleType,exports.attentionHighlight=attentionHighlight;

},{"./src/attentionHighlight":86,"./src/gridOverlay":87,"./src/responsiveTitleType":88}],86:[function(require,module,exports){
"use strict";Object.defineProperty(exports,"__esModule",{value:!0});const HIDE_DELAY=exports.HIDE_DELAY=2e3;

},{}],87:[function(require,module,exports){
(function (global){
"use strict";const cosmos=require("../../cosmos-api").default,DEFAULT_GRID_COLOR="rgba(251, 74, 131, 0.22)",DEFAULT_GRID_COLOR_HIGHLIGHT="rgba(251, 74, 131, 0.8)",GRID_BASELINE=8;let overlayElement=null,baselineHighlightElement=null,gridColor="",highlightGridColor="";const gridModes=["off","column","baseline"];let currentModeIndex=0;function listen(){global.__spotify.developer_mode&&cosmos.resolver.subscribe({url:"sp://messages/v1/container/control"},function(e,l){if(e)return;const o=l.getJSONBody();o&&"toggle_grid"===o.type&&toggle()})}function toggle(){let e=currentModeIndex+1;e>gridModes.length-1&&(e=0);const l=gridModes[e];"off"===l?disable():enable(l)}function enable(e){e&&gridModes[currentModeIndex]!==e&&(currentModeIndex=gridModes.indexOf(e),overlayElement&&overlayElement.parentNode&&overlayElement.parentNode.removeChild(overlayElement),"baseline"===e&&document.addEventListener("mousemove",onMouseMove,!1),overlayElement=createOverlayElement(),document.body.appendChild(overlayElement))}function disable(){"off"!==gridModes[currentModeIndex]&&(overlayElement&&overlayElement.parentNode&&overlayElement.parentNode.removeChild(overlayElement),currentModeIndex=gridModes.indexOf("off"),overlayElement=null,baselineHighlightElement=null,document.removeEventListener("mousemove",onMouseMove,!1))}function setColor(e,l){gridColor=e,highlightGridColor=l}function reset(){overlayElement=null,baselineHighlightElement=null,gridColor="",highlightGridColor="",currentModeIndex=0}function onMouseMove(e){baselineHighlightElement||((baselineHighlightElement=document.createElement("div")).className="grid-overlay-baseline-highlight",baselineHighlightElement.style.backgroundColor=highlightGridColor||DEFAULT_GRID_COLOR_HIGHLIGHT,overlayElement.appendChild(baselineHighlightElement));const l=e.clientY+window.scrollY,o=Math.floor(l/GRID_BASELINE)*GRID_BASELINE+(l%GRID_BASELINE>4?GRID_BASELINE:0);baselineHighlightElement.style.top=`${o-1}px`}function createOverlayElement(){const e=gridColor||DEFAULT_GRID_COLOR,l=document.createElement("div");if(l.className="grid-overlay container","column"===gridModes[currentModeIndex]){const o=document.createElement("div");o.className="grid-overlay-row row",l.appendChild(o);const n=createSizeLabel();l.appendChild(n);const t="col-xs-1 col-sm-1 col-md-1 col-lg-1";for(let l=0;l<12;l++){const n=document.createElement("div");n.className=`grid-overlay-col-${l+1} ${t}`,n.style.backgroundColor=e,o.appendChild(n)}}else if("baseline"===gridModes[currentModeIndex]){l.classList.add("grid-overlay-baseline");const o=`${(GRID_BASELINE-1)/GRID_BASELINE*100}%`,n=["linear-gradient(","to bottom, ","transparent, ",`transparent ${o}, `,`${e} ${o}`,")"].join("");l.style.backgroundImage=n,l.style._backgroundImage=n}return l}function createSizeLabel(){const e=document.createElement("div");return e.className="grid-overlay-label",[{name:"Extra Small",id:"xs"},{name:"Small",id:"sm"},{name:"Medium",id:"md"},{name:"Large",id:"lg"}].forEach(function(l){const o=document.createElement("span");o.className=`visible-${l.id}`,o.textContent=`${l.name} (${l.id})`,e.appendChild(o)}),e}exports.listen=listen,exports.toggle=toggle,exports.enable=enable,exports.disable=disable,exports.setColor=setColor,exports.reset=reset;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../cosmos-api":54}],88:[function(require,module,exports){
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.loadFont=loadFont,exports.setSizeForTitle=setSizeForTitle;const PADDING_BOTTOM_PERCENTAGE=.07;function getSizeSpecs(){return"th"===window.__spotify.locale?{default:{fontSizes:[[48,36],[36,28]],lineHeights:[[75,58],[58,44]]},large:{fontSizes:[[96,72,48],[48,36,28]],lineHeights:[[148,111,75],[75,58,44]]}}:{default:{fontSizes:[[48,36],[36,28]],lineHeights:[[56,44],[44,36]]},large:{fontSizes:[[96,72,48],[48,36,28]],lineHeights:[[110,82,56],[56,44,36]]}}}function loadFont(){return document.fonts.load("500 48px spotify-circular")}function setSizeForTitle(e,t={}){const i=t.useLargeTitle?"large":"default",{fontSizes:l,lineHeights:o}=getSizeSpecs()[i];let n=1,s=0,r=l[0][0],a=o[0][0],p=n+1,g=Math.ceil(PADDING_BOTTOM_PERCENTAGE*a);for(e.style.webkitLineClamp=p,e.style.fontSize=`${r}px`,e.style.lineHeight=`${a}px`,e.style.paddingBottom=`${g}px`,e.style.marginBottom=`-${g}px`,e.removeAttribute("title");n<=l.length&&e.offsetHeight-g>a*n;)s++,l[n-1][s]||(s=0,n++),n<=l.length&&(r=l[n-1][s],a=o[n-1][s],p=n+1,g=Math.ceil(PADDING_BOTTOM_PERCENTAGE*a),e.style.webkitLineClamp=p,e.style.fontSize=`${r}px`,e.style.lineHeight=`${a}px`,e.style.paddingBottom=`${g}px`,e.style.marginBottom=`-${g}px`);n>l.length&&e.setAttribute("title",e.textContent.trim()),e.style.webkitLineClamp=p-1}

},{}],89:[function(require,module,exports){
"use strict";module.exports={ar:require("../i18n/json/ar.json"),cs:require("../i18n/json/cs.json"),de:require("../i18n/json/de.json"),el:require("../i18n/json/el.json"),en:require("../i18n/json/en.json"),es:require("../i18n/json/es.json"),"es-419":require("../i18n/json/es-419.json"),fi:require("../i18n/json/fi.json"),fr:require("../i18n/json/fr.json"),"fr-CA":require("../i18n/json/fr-CA.json"),hu:require("../i18n/json/hu.json"),id:require("../i18n/json/id.json"),it:require("../i18n/json/it.json"),ja:require("../i18n/json/ja.json"),nl:require("../i18n/json/nl.json"),pl:require("../i18n/json/pl.json"),"pt-BR":require("../i18n/json/pt-BR.json"),sv:require("../i18n/json/sv.json"),th:require("../i18n/json/th.json"),tr:require("../i18n/json/tr.json"),vi:require("../i18n/json/vi.json"),"zh-Hant":require("../i18n/json/zh-Hant.json"),ms:require("../i18n/json/ms.json")};

},{"../i18n/json/ar.json":62,"../i18n/json/cs.json":63,"../i18n/json/de.json":64,"../i18n/json/el.json":65,"../i18n/json/en.json":66,"../i18n/json/es-419.json":67,"../i18n/json/es.json":68,"../i18n/json/fi.json":69,"../i18n/json/fr-CA.json":70,"../i18n/json/fr.json":71,"../i18n/json/hu.json":72,"../i18n/json/id.json":73,"../i18n/json/it.json":74,"../i18n/json/ja.json":75,"../i18n/json/ms.json":76,"../i18n/json/nl.json":77,"../i18n/json/pl.json":78,"../i18n/json/pt-BR.json":79,"../i18n/json/sv.json":80,"../i18n/json/th.json":81,"../i18n/json/tr.json":82,"../i18n/json/vi.json":83,"../i18n/json/zh-Hant.json":84}],90:[function(require,module,exports){
var HandlebarsCompiler=require("hbsfy/runtime");module.exports=HandlebarsCompiler.template({1:function(e,l,n,a,r){var s,o=null!=l?l:e.nullContext||{},i=n.helperMissing;return'        <h1 class="hdr-l">'+e.escapeExpression((n.loc||l&&l.loc||i).call(o,"ErrorTitle",{name:"loc",hash:{},data:r}))+'</h1>\n        <div class="message">'+(null!=(s=(n.loc||l&&l.loc||i).call(o,"ErrorMessage",{name:"loc",hash:{},data:r}))?s:"")+"</div>\n"},3:function(e,l,n,a,r){var s,o,i=null!=l?l:e.nullContext||{},t=n.helperMissing;return'        <h1 class="hdr-l">'+e.escapeExpression("function"==typeof(o=null!=(o=n.errorTitle||(null!=l?l.errorTitle:l))?o:t)?o.call(i,{name:"errorTitle",hash:{},data:r}):o)+'</h1>\n        <div class="message">'+(null!=(s="function"==typeof(o=null!=(o=n.errorMessage||(null!=l?l.errorMessage:l))?o:t)?o.call(i,{name:"errorMessage",hash:{},data:r}):o)?s:"")+"</div>\n"},5:function(e,l,n,a,r){var s,o=null!=l?l:e.nullContext||{},i=n.helperMissing,t=e.escapeExpression;return'        <a class="button button-white" href="'+t("function"==typeof(s=null!=(s=n.errorEscapeUrl||(null!=l?l.errorEscapeUrl:l))?s:i)?s.call(o,{name:"errorEscapeUrl",hash:{},data:r}):s)+'" data-log-click="error-escape">'+t("function"==typeof(s=null!=(s=n.errorEscapeMessage||(null!=l?l.errorEscapeMessage:l))?s:i)?s.call(o,{name:"errorEscapeMessage",hash:{},data:r}):s)+"</a>\n"},7:function(e,l,n,a,r){var s,o=null!=l?l:e.nullContext||{},i=n.helperMissing;return'        <h1 class="hdr-l">'+e.escapeExpression((n.loc||l&&l.loc||i).call(o,"OfflineTitle",{name:"loc",hash:{},data:r}))+'</h1>\n        <div class="message">'+(null!=(s=(n.loc||l&&l.loc||i).call(o,"OfflineMessage",{name:"loc",hash:{},data:r}))?s:"")+"</div>\n"},9:function(e,l,n,a,r){var s,o,i=null!=l?l:e.nullContext||{},t=n.helperMissing;return'        <h1 class="hdr-l">'+e.escapeExpression("function"==typeof(o=null!=(o=n.offlineTitle||(null!=l?l.offlineTitle:l))?o:t)?o.call(i,{name:"offlineTitle",hash:{},data:r}):o)+'</h1>\n        <div class="message">'+(null!=(s="function"==typeof(o=null!=(o=n.offlineMessage||(null!=l?l.offlineMessage:l))?o:t)?o.call(i,{name:"offlineMessage",hash:{},data:r}):o)?s:"")+"</div>\n"},11:function(e,l,n,a,r){var s,o=null!=l?l:e.nullContext||{},i=n.helperMissing,t=e.escapeExpression;return'        <a class="button button-white" href="'+t("function"==typeof(s=null!=(s=n.offlineEscapeUrl||(null!=l?l.offlineEscapeUrl:l))?s:i)?s.call(o,{name:"offlineEscapeUrl",hash:{},data:r}):s)+'" data-log-click="offline-escape">'+t("function"==typeof(s=null!=(s=n.offlineEscapeMessage||(null!=l?l.offlineEscapeMessage:l))?s:i)?s.call(o,{name:"offlineEscapeMessage",hash:{},data:r}):s)+"</a>\n"},13:function(e,l,n,a,r){var s;return'  <div class="error-version text-muted">'+e.escapeExpression("function"==typeof(s=null!=(s=n.errorVersion||(null!=l?l.errorVersion:l))?s:n.helperMissing)?s.call(null!=l?l:e.nullContext||{},{name:"errorVersion",hash:{},data:r}):s)+"</div>\n"},compiler:[7,">= 4.0.0"],main:function(e,l,n,a,r){var s,o=null!=l?l:e.nullContext||{};return'<div class="error-and-offline" data-log-context="error-and-offline">\n  <div class="container">\n    <div class="error-content">\n'+(null!=(s=n.if.call(o,null!=l?l.useDefaultError:l,{name:"if",hash:{},fn:e.program(1,r,0),inverse:e.program(3,r,0),data:r}))?s:"")+(null!=(s=n.if.call(o,null!=l?l.errorEscapeMessage:l,{name:"if",hash:{},fn:e.program(5,r,0),inverse:e.noop,data:r}))?s:"")+'    </div>\n    <div class="offline-content">\n'+(null!=(s=n.if.call(o,null!=l?l.useDefaultOffline:l,{name:"if",hash:{},fn:e.program(7,r,0),inverse:e.program(9,r,0),data:r}))?s:"")+(null!=(s=n.if.call(o,null!=l?l.offlineEscapeMessage:l,{name:"if",hash:{},fn:e.program(11,r,0),inverse:e.noop,data:r}))?s:"")+"    </div>\n  </div>\n"+(null!=(s=n.if.call(o,null!=l?l.errorVersion:l,{name:"if",hash:{},fn:e.program(13,r,0),inverse:e.noop,data:r}))?s:"")+"</div>\n"},useData:!0});

},{"hbsfy/runtime":381}],91:[function(require,module,exports){
var HandlebarsCompiler=require("hbsfy/runtime");module.exports=HandlebarsCompiler.template({1:function(n,l,a,e,r){return"true"},3:function(n,l,a,e,r){return"false"},5:function(n,l,a,e,r){return" enabled"},7:function(n,l,a,e,r){return" disabled"},9:function(n,l,a,e,r){return"enabled"},11:function(n,l,a,e,r){return"disabled"},13:function(n,l,a,e,r){return'aria-disabled="true"'},15:function(n,l,a,e,r){var i;return'data-slider="'+n.escapeExpression("function"==typeof(i=null!=(i=a.id||(null!=l?l.id:l))?i:a.helperMissing)?i.call(null!=l?l:n.nullContext||{},{name:"id",hash:{},data:r}):i)+'"'},17:function(n,l,a,e,r){return"data-slider"},19:function(n,l,a,e,r){var i;return'data-ta-id="'+n.escapeExpression("function"==typeof(i=null!=(i=a.id||(null!=l?l.id:l))?i:a.helperMissing)?i.call(null!=l?l:n.nullContext||{},{name:"id",hash:{},data:r}):i)+'"'},21:function(n,l,a,e,r){var i;return'aria-labelledby="'+n.escapeExpression("function"==typeof(i=null!=(i=a.labelId||(null!=l?l.labelId:l))?i:a.helperMissing)?i.call(null!=l?l:n.nullContext||{},{name:"labelId",hash:{},data:r}):i)+'"'},23:function(n,l,a,e,r){var i;return'data-uri="'+n.escapeExpression("function"==typeof(i=null!=(i=a.uri||(null!=l?l.uri:l))?i:a.helperMissing)?i.call(null!=l?l:n.nullContext||{},{name:"uri",hash:{},data:r}):i)+'"'},25:function(n,l,a,e,r){var i;return'data-slider-property="'+n.escapeExpression("function"==typeof(i=null!=(i=a.property||(null!=l?l.property:l))?i:a.helperMissing)?i.call(null!=l?l:n.nullContext||{},{name:"property",hash:{},data:r}):i)+'"'},27:function(n,l,a,e,r){var i;return'data-slider-allowed-property="'+n.escapeExpression("function"==typeof(i=null!=(i=a.allowedProperty||(null!=l?l.allowedProperty:l))?i:a.helperMissing)?i.call(null!=l?l:n.nullContext||{},{name:"allowedProperty",hash:{},data:r}):i)+'"'},compiler:[7,">= 4.0.0"],main:function(n,l,a,e,r){var i,t=null!=l?l:n.nullContext||{},o=a.helperMissing;return'<div\n  tabindex="0"\n  role="checkbox"\n  aria-checked="'+(null!=(i=a.if.call(t,null!=l?l.enabled:l,{name:"if",hash:{},fn:n.program(1,r,0),inverse:n.program(3,r,0),data:r}))?i:"")+'"\n  class="slider'+(null!=(i=a.if.call(t,null!=l?l.enabled:l,{name:"if",hash:{},fn:n.program(5,r,0),inverse:n.noop,data:r}))?i:"")+(null!=(i=(a.compare||l&&l.compare||o).call(t,null!=l?l.allowed:l,!1,{name:"compare",hash:{},fn:n.program(7,r,0),inverse:n.noop,data:r}))?i:"")+'"\n  data-ta-slider-state="'+(null!=(i=a.if.call(t,null!=l?l.enabled:l,{name:"if",hash:{},fn:n.program(9,r,0),inverse:n.program(11,r,0),data:r}))?i:"")+'"\n  '+(null!=(i=(a.compare||l&&l.compare||o).call(t,null!=l?l.allowed:l,!1,{name:"compare",hash:{},fn:n.program(13,r,0),inverse:n.noop,data:r}))?i:"")+"\n  "+(null!=(i=a.if.call(t,null!=l?l.id:l,{name:"if",hash:{},fn:n.program(15,r,0),inverse:n.program(17,r,0),data:r}))?i:"")+"\n  "+(null!=(i=a.if.call(t,null!=l?l.id:l,{name:"if",hash:{},fn:n.program(19,r,0),inverse:n.noop,data:r}))?i:"")+"\n  "+(null!=(i=a.if.call(t,null!=l?l.labelId:l,{name:"if",hash:{},fn:n.program(21,r,0),inverse:n.noop,data:r}))?i:"")+"\n  "+(null!=(i=a.if.call(t,null!=l?l.uri:l,{name:"if",hash:{},fn:n.program(23,r,0),inverse:n.noop,data:r}))?i:"")+"\n  "+(null!=(i=a.if.call(t,null!=l?l.property:l,{name:"if",hash:{},fn:n.program(25,r,0),inverse:n.noop,data:r}))?i:"")+"\n  "+(null!=(i=a.if.call(t,null!=l?l.allowedProperty:l,{name:"if",hash:{},fn:n.program(27,r,0),inverse:n.noop,data:r}))?i:"")+">\n  <div></div>\n</div>\n"},useData:!0});

},{"hbsfy/runtime":381}],92:[function(require,module,exports){
"use strict";const base="spotify:internal:filterlist",regExp=/^spotify:internal:filterlist:([^:]*):(.*)$/;exports.create=function(t,e){const r=t.replace(/^spotify:/,""),n=encodeURIComponent(e);return[base,n,r].join(":")},exports.getQuery=function(t){const e=t.match(regExp);return e?decodeURIComponent(e[1]):""},exports.getOriginUri=function(t){const e=t.match(regExp);return e?`spotify:${e[2]}`:""},exports.parse=function(t){const e=t.match(regExp);return e?{query:decodeURIComponent(e[1]),originUri:`spotify:${e[2]}`}:null},exports.isValid=function(t){return regExp.test(t)},exports.regExp=regExp;

},{}],93:[function(require,module,exports){
"use strict";const Range=require("../range2");function getInsertOperations(e,t){return[{type:"insert",index:t,values:e}]}function getRemoveOperations(e){const t=Range.fromIndices(e);let n=0;const r=[];for(let e,s=0;t[s];s++)e=t[s],r.push({type:"remove",index:e.start-n,length:e.length}),n+=e.length;return r}function getMoveOperations(e,t){let n=0,r=t;const s=Range.fromIndices(e);let o,a,i;for(o=0;s[o];o++)if((a=s[o]).start<=t&&a.end>=t){i=a;break}const g=[];for(o=0;s[o];o++){const e=(a=s[o]).length;let p,c=a.start-n;if(i)if(a.end<i.start)c=a.start-n,p=i.start-e,n+=e;else{if(a===i){r=Math.max(r,a.end);continue}c=a.start,p=r,r=Math.max(r,p+e)}else a.end<t?(c=a.start-n,p=r-e,n+=e):(c=a.start,p=r,r=Math.max(r,p+e));g.push({type:"move",from:c,length:e,to:p})}return g}exports.getInsertOperations=getInsertOperations,exports.getRemoveOperations=getRemoveOperations,exports.getMoveOperations=getMoveOperations;

},{"../range2":189}],94:[function(require,module,exports){
(function (global){
"use strict";const live=require("../../live"),cosmos=require("../util/cosmos"),Collection=require("./collection"),liburi=require("spotify-liburi"),endpoints={isInCollection:"sp://core-collection/v1/contains",updateIsInCollection:"sp://core-collection/v1/items",broadcast:"sp://messages/v1/collectionstate",pubsub:"hm://collection/collection/@/json"},onCollectionPublish=function(o,e){o?global.console&&console.error(o):live(e.body.items.filter(({type:o=""})=>"ALBUM"===o.toUpperCase()).map(({identifier:o,removed:e})=>({uri:liburi.albumURI(o).toURI(),added:!e})))};let albumCollection,broadcastSubscription,collectionSubscription;const regExp=exports.matches=/^spotify:album:[^:]+$/;let registered=!1;exports.register=function(){registered||(registered=!0,albumCollection=new Collection(endpoints),live.subscribe(regExp,"publish",albumCollection.onPublish),live.subscribe(regExp,"wait",albumCollection.onWait),broadcastSubscription=cosmos.subscribe({url:endpoints.broadcast},Collection.onBroadcast),collectionSubscription=cosmos.subscribe({url:endpoints.pubsub},onCollectionPublish))},exports.unregister=function(){registered&&(registered=!1,live.unsubscribe(regExp,"publish",albumCollection.onPublish),live.unsubscribe(regExp,"wait",albumCollection.onWait),albumCollection=null,broadcastSubscription&&(broadcastSubscription.cancel(),broadcastSubscription=null),collectionSubscription&&(collectionSubscription.cancel(),collectionSubscription=null))},exports._endpoints=endpoints;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../live":148,"../util/cosmos":143,"./collection":96,"spotify-liburi":450}],95:[function(require,module,exports){
"use strict";const profile=require("./profile"),regExp=exports.matches=/^spotify:artist:/;let registered;exports.register=function(){registered||(registered=!0,profile.register(regExp))},exports.unregister=function(){registered&&(registered=!1,profile.unregister(regExp))};

},{"./profile":100}],96:[function(require,module,exports){
(function (global){
"use strict";const prime=require("../../../libs/prime"),defer=require("../../../libs/prime/defer"),live=require("../../live"),contains=require("mout/array/contains"),cosmos=require("../util/cosmos"),INSUFFICIENT_STORAGE=507,Collection=prime({constructor:function(o){this.endpoints=o,this.onPublish=this.onPublish.bind(this),this.waitQueue=[],this.onWait=this.onWait.bind(this),this.fetch=this.fetch.bind(this)},onPublish:function(o,t){if("added"in t){const e=this.endpoints,i=!!t.added;o.update({added:i});const s=i?"post":"delete";this._publish(s,[o],function(t,s){t?(o.update({added:!i}),t.response&&507===t.response.getStatusCode()&&cosmos.post({url:"sp://messages/v1/container/user-message",body:{id:"collection-limit-exceeded"}})):(cosmos.post({url:e.broadcast,body:{uri:o.uri,isInCollection:i,added:i}}),s&&s.items&&s.items.forEach(function(o){o.added=o.isInCollection,cosmos.post({url:e.broadcast,body:o})}))})}},onWait:function(o,t){contains(t,"added")&&this.fetch(o)},fetch:function(o){const t=this.waitQueue;t.push(o),1===t.length&&defer.immediate(this._fetchBatch,this)},_fetchBatch:function(){const o=this.waitQueue;0!==o.length&&(this.waitQueue=[],this._contains(o,function(t,e){t&&(!t.response||t.response&&404!==t.response.getStatusCode())?global.console&&console.error(t):o.forEach(function(o,i){let s=!1;t||(s=e[i]),o.update({added:s})})}))},_contains:function(o,t){const e=this.endpoints.isInCollection,i=this._getRequestBody(o);cosmos.post({url:e,body:i},function(o,e){t(o,e&&e.body&&e.body.found)})},_publish:function(o,t,e){const i=this.endpoints.updateIsInCollection,s=this._getRequestBody(t);cosmos[o]({url:i,body:s},function(o,t){e(o,t&&t.body)})},_getRequestBody:function(o){return{items:o.map(function(o){return o.uri}),source:global.__spotify&&global.__spotify.app_uri||null}}});Collection.onBroadcast=function(o,t){if(o)return void(global.console&&console.error(o));let e;"added"in t.body?e=t.body.added:"isInCollection"in t.body&&(e=t.body.isInCollection),live(t.body.uri).update({added:e})},module.exports=Collection;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../../libs/prime":187,"../../../libs/prime/defer":185,"../../live":148,"../util/cosmos":143,"mout/array/contains":386}],97:[function(require,module,exports){
"use strict";const album=require("./album"),artist=require("./artist"),playlist=require("./playlist"),track=require("./track"),user=require("./user"),local=require("./local"),show=require("./show");exports.register=function(){album.register(),artist.register(),playlist.register(),track.register(),user.register(),local.register(),show.register()},exports.unregister=function(){album.unregister(),artist.unregister(),playlist.unregister(),track.unregister(),user.unregister(),local.unregister(),show.unregister()};

},{"./album":94,"./artist":95,"./local":98,"./playlist":99,"./show":101,"./track":102,"./user":103}],98:[function(require,module,exports){
"use strict";const live=require("../../live"),contains=require("mout/array/contains"),onWait=function(e,t){contains(t,"added")&&e.update({added:!1})},regExp=exports.matches=/^spotify:local:[^:]*:[^:]*:[^:]*:\d*$|^spotify:local:[^:]*:[^:]*$|^spotify:local:[^:]*$/;let registered=!1;exports.register=function(){registered||(registered=!0,live.subscribe(regExp,"wait",onWait))},exports.unregister=function(){registered&&(registered=!1,live.unsubscribe(regExp,"wait",onWait))};

},{"../../live":148,"mout/array/contains":386}],99:[function(require,module,exports){
(function (global){
"use strict";var _playlistUtils=require("../../../libs/playlist-utils"),_playlistUtils2=_interopRequireDefault(_playlistUtils);function _interopRequireDefault(e){return e&&e.__esModule?e:{default:e}}const contains=require("mout/array/contains"),live=require("../../live"),cosmos=require("../util/cosmos"),endpoints={broadcast:"sp://messages/v1/followstate"};function onPublish(e,o){if("added"in o){e.update({added:o.added}),null!==e.get("followersCount")&&e.update({followersCount:e.get("followersCount")+(o.added?1:-1)}),(o.added?_playlistUtils2.default.followPlaylist:_playlistUtils2.default.removePlaylist)(e.uri,t=>{t&&(e.update({added:!o.added}),null!==e.get("followersCount")&&e.update({followersCount:e.get("followersCount")+(o.added?-1:1)}))})}}function onBroadcast(e,o){if(e)return void(global.console&&console.error(e));let t;"added"in o.body?t=o.body.added:"isFollowing"in o.body&&(t=o.body.isFollowing),void 0!==t&&live(o.body.uri).update({added:t})}function fetchAdded(e){cosmos.get({url:`sp://core-playlist/v1/playlist/${encodeURIComponent(e.uri)}/metadata`,body:{policy:{followed:!0}}},function(o,t){o?global.console&&console.error(o):e.update({added:t.body.metadata.followed})})}function fetchFollowersCount(e){cosmos.get({url:`sp://core-playlist/v1/playlist/${encodeURIComponent(e.uri)}/metadata`,body:{policy:{followers:!0}}},function(o,t){o?global.console&&console.error(o):e.update({followersCount:t.body.metadata.followers})})}const onWait=function(e,o){const t=contains(o,"added"),l=contains(o,"followersCount");if(t){const o=e.get("subscribed");void 0!==o?e.update({added:o}):fetchAdded(e)}l&&fetchFollowersCount(e)},regExp=exports.matches=/^spotify:(user:[^:]+:)?playlist:[^:]+$/;let broadcastSubscription,registered;exports.register=function(){registered||(registered=!0,live.subscribe(regExp,"publish",onPublish),live.subscribe(regExp,"wait",onWait),broadcastSubscription=cosmos.subscribe({url:endpoints.broadcast},onBroadcast))},exports.unregister=function(){registered&&(registered=!1,live.unsubscribe(regExp,"publish",onPublish),live.unsubscribe(regExp,"wait",onWait),broadcastSubscription.cancel(),broadcastSubscription=null)};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../../libs/playlist-utils":180,"../../live":148,"../util/cosmos":143,"mout/array/contains":386}],100:[function(require,module,exports){
(function (global){
"use strict";const intersection=require("mout/array/intersection"),live=require("../../live"),cosmos=require("../util/cosmos");let requestsInProgress={};const endpoints={isFollowing:"hm://socialgraph/v2/is_following?format=json",followCounts:"hm://socialgraph/v2/counts?format=json",updateIsFollowing:"hm://socialgraph/v2/following?format=json",broadcast:"sp://messages/v1/followstate"};function onUpdate(o,e){if("added"in e&&!("followersCount"in e)){const n=o.get("followersCount");if(void 0!==n){const t=n+(e.added?1:-1);o.update({followersCount:t})}}}function onPublish(o,e){if("added"in e){if(requestsInProgress[o.uri])return;requestsInProgress[o.uri]=!0,o.update({added:e.added}),updateBackend(o,!!e.added,function(n){delete requestsInProgress[o.uri],n?o.update({added:!e.added}):(o.update({added:e.added}),broadcast(o))})}}function onBroadcast(o,e){if(o)return void(global.console&&console.error(o));const n=e.body,t={};"added"in n?t.added=n.added:"isFollowing"in n&&(t.added=n.isFollowing),"followersCount"in n&&(t.followersCount=n.followersCount),"followingCount"in n&&(t.followingCount=n.followingCount),live(n.uri).update(t)}const followProperties=["added","followersCount","followingCount"];function onWait(o,e){intersection(e,followProperties).length&&getRequestData(o,function(e,n){e?global.console&&console.error(e):(updateIsFollowing(o,n),updateCounts(o,n))})}function updateIsFollowing(o,e,n){const t={url:endpoints.isFollowing,body:e};cosmos.get(t,function(e,t){if(e)global.console&&console.error(e),n&&n(e);else{const e=t.body[0].is_following;o.update({added:e}),n&&n()}})}function updateCounts(o,e,n){const t={url:endpoints.followCounts,body:e};cosmos.get(t,function(e,t){if(e)global.console&&console.error(e),n&&n(e);else{const e=t.body[0];o.update({followersCount:e.followers_count,followingCount:e.following_count}),n&&n()}})}function getRequestData(o,e){live("spotify:client").query("currentUser(uri)",function(n,t){n?e(n):e(null,{source_uri:decodeURIComponent(t.currentUser.uri),target_uris:[decodeURIComponent(o.uri)]})})}function updateBackend(o,e,n){getRequestData(o,function(o,t){if(o)n(o);else{cosmos[e?"post":"delete"]({url:endpoints.updateIsFollowing,body:t},function(o){n(o||null)})}})}function broadcast(o){const e=o.get("added");cosmos.post({url:endpoints.broadcast,body:{uri:o.uri,isFollowing:e,added:e,followersCount:o.get("followersCount"),followingCount:o.get("followingCount")}})}let broadcastSubscription;exports.register=function(o){live.subscribe(o,"wait",onWait),live.subscribe(o,"update",onUpdate),live.subscribe(o,"publish",onPublish),requestsInProgress={},broadcastSubscription||(broadcastSubscription=cosmos.subscribe({url:endpoints.broadcast},onBroadcast))},exports.unregister=function(o){live.unsubscribe(o,"wait",onWait),live.unsubscribe(o,"update",onUpdate),live.unsubscribe(o,"publish",onPublish),broadcastSubscription&&(broadcastSubscription.cancel(),broadcastSubscription=null)};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../live":148,"../util/cosmos":143,"mout/array/intersection":393}],101:[function(require,module,exports){
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.register=register,exports.unregister=unregister;var _live=require("../../live"),_live2=_interopRequireDefault(_live),_collection=require("./collection"),_collection2=_interopRequireDefault(_collection);function _interopRequireDefault(e){return e&&e.__esModule?e:{default:e}}const regExp=/^spotify:show:[^:]+$/;let showCollection,registered=!1;function register(){registered||(registered=!0,showCollection=new _collection2.default({isInCollection:"sp://core-collection/v1/contains",updateIsInCollection:"sp://core-collection/v1/items",broadcast:"sp://messages/v1/collectionstate",pubsub:"hm://collection/collection/@/json"}),_live2.default.subscribe(regExp,"publish",showCollection.onPublish),_live2.default.subscribe(regExp,"wait",showCollection.onWait))}function unregister(){registered&&(registered=!1,_live2.default.unsubscribe(regExp,"publish",showCollection.onPublish),_live2.default.unsubscribe(regExp,"wait",showCollection.onWait))}

},{"../../live":148,"./collection":96}],102:[function(require,module,exports){
(function (global){
"use strict";const live=require("../../live"),cosmos=require("../util/cosmos"),Collection=require("./collection"),liburi=require("spotify-liburi"),endpoints={isInCollection:"sp://core-collection/v1/contains",updateIsInCollection:"sp://core-collection/v1/items",broadcast:"sp://messages/v1/collectionstate",pubsub:"hm://collection/collection/@/json"},onCollectionPublish=function(o,e){o?global.console&&console.error(o):live(e.body.items.filter(({type:o=""})=>"TRACK"===o.toUpperCase()).map(({identifier:o,removed:e})=>({uri:liburi.trackURI(o).toURI(),added:!e})))};let trackCollection,broadcastSubscription,collectionSubscription;const regExp=exports.matches=/^spotify:track:[^:]+$/;let registered=!1;exports.register=function(){registered||(registered=!0,trackCollection=new Collection(endpoints),live.subscribe(regExp,"publish",trackCollection.onPublish),live.subscribe(regExp,"wait",trackCollection.onWait),broadcastSubscription=cosmos.subscribe({url:endpoints.broadcast},Collection.onBroadcast),collectionSubscription=cosmos.subscribe({url:endpoints.pubsub},onCollectionPublish))},exports.unregister=function(){registered&&(registered=!1,live.unsubscribe(regExp,"publish",trackCollection.onPublish),live.unsubscribe(regExp,"wait",trackCollection.onWait),trackCollection=null,broadcastSubscription&&(broadcastSubscription.cancel(),broadcastSubscription=null),collectionSubscription&&(collectionSubscription.cancel(),collectionSubscription=null))},exports._endpoints=endpoints;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../live":148,"../util/cosmos":143,"./collection":96,"spotify-liburi":450}],103:[function(require,module,exports){
"use strict";const profile=require("./profile"),regExp=exports.matches=/^spotify:user:[^:]+$/;let registered;exports.register=function(){registered||(registered=!0,profile.register(regExp))},exports.unregister=function(){registered&&(registered=!1,profile.unregister(regExp))};

},{"./profile":100}],104:[function(require,module,exports){
(function (global){
"use strict";const live=require("../live"),liburi=require("spotify-liburi"),intersection=require("mout/array/intersection"),contains=require("mout/array/contains"),mixIn=require("mout/object/mixIn"),bridge=require("./util/bridge").request;function isLocalAlbum(t){return liburi.from(t).type===liburi.Type.LOCAL_ALBUM}function isLocalArtist(t){return liburi.from(t).type===liburi.Type.LOCAL_ARTIST}function updateMetadata(t){if(isLocalAlbum(t.uri)){const i=liburi.from(t.uri);if(i){const r={local:!0,name:i.album,artists:[{uri:"spotify:local:",name:"",local:!0}]};i.artist&&(r.artists[0].uri=liburi.localArtistURI(i.artist).toURI(),r.artists[0].name=i.artist,r.artists[0].local=!0),t.update(r)}}else bridge("album_metadata",[t.uri],function(i,r){i?global.console&&console.error(i):t.update(r)})}function updateLocal(t){t.update({local:isLocalAlbum(t.uri)})}let idCounter=1e3;function getRowUri(t){return t.replace("spotify:",`spotify:row:${(++idCounter).toString(36)}:`)}function updateRows(t){const i={type:"list",uri:t.uri};bridge("album_tracks_snapshot",[i,0,0,!1],function(r,e){r?global.console&&console.error(r):bridge("album_tracks_snapshot",[i,0,e.length,!1],function(i,r){if(i)global.console&&console.error(i);else{const i=[],e=liburi.from(t.uri).id,a=r.metadata&&r.metadata.map(function(t,a){const o=mixIn({uri:r.array[a]},t),s=o.disc?o.disc-1:0;o.unavailable=!o.playable,setLocalProperty(o),i[s]||(i[s]={rows:[],uri:e?liburi.albumURI(e,s+1).toURI():""});const l={track:o,uri:getRowUri(o.uri)};return i[s].rows.push(l),l});t.update({rows:a,discs:i})}})})}function setLocalProperty(t){if(t.album&&t.album.uri&&(t.album.local=isLocalAlbum(t.album.uri)),t.artists)for(let i=0,r=t.artists.length;i<r;i++){const r=t.artists[i];r.uri&&(r.local=isLocalArtist(r.uri))}}function onWait(t,i){const r=contains(i,"local"),e=contains(i,"rows"),a=contains(i,"discs");!!intersection(i,["artists","image","images","name","playable","type","availability","date","label","copyrights"]).length&&updateMetadata(t),(e||a)&&updateRows(t),r&&updateLocal(t)}const regExp=exports.matches=/^spotify:album:[0-9a-zA-Z]+$|^spotify:local:[^:]*:[^:]*$/;let registered;exports.register=function(){registered||(registered=!0,live.subscribe(regExp,"wait",onWait))},exports.unregister=function(){registered&&(registered=!1,live.unsubscribe(regExp,"wait",onWait))};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../live":148,"./util/bridge":141,"mout/array/contains":386,"mout/array/intersection":393,"mout/object/mixIn":423,"spotify-liburi":450}],105:[function(require,module,exports){
(function (global){
"use strict";var _getLocationHref=require("./util/get-location-href"),_getLocationHref2=_interopRequireDefault(_getLocationHref);function _interopRequireDefault(e){return e&&e.__esModule?e:{default:e}}const live=require("../live"),AppState=require("../navigation/app-state");function onMessage(e){e.data&&e.data.name&&("set_active"===e.data.name?live("spotify:application").update({active:e.data.active}):"set_arguments"===e.data.name?live("spotify:application").update({arguments:e.data.arguments.join(":")}):"set_state"===e.data.name&&live("spotify:application").update({state:AppState.unserialize(e.data.state)}))}function onRegister(e){e.update({version:global.__spotify&&global.__spotify.app_version||"0.0.0"});const t=new URL((0,_getLocationHref2.default)());if(t.hostname.length>0){const a=/^([a-zA-Z-]+)\.app\.spotify\.com$/,i=t.hostname.match(a);2===i.length&&e.update({appURI:`spotify:app:${i[1]}`,arguments:t.searchParams.get("param")||"",active:!0})}}let registered;exports.matches=/^spotify:application$/,exports.register=function(){registered||(registered=!0,global.addEventListener("message",onMessage),onRegister(live("spotify:application")))},exports.unregister=function(){registered&&(registered=!1,global.removeEventListener("message",onMessage))};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../live":148,"../navigation/app-state":167,"./util/get-location-href":144}],106:[function(require,module,exports){
(function (global){
"use strict";const liburi=require("spotify-liburi"),contains=require("mout/array/contains"),live=require("../live"),bridge=require("./util/bridge").request;function isLocalArtist(e){return liburi.from(e).type===liburi.Type.LOCAL_ARTIST}function updateMetadata(e){if(isLocalArtist(e.uri)){const i=liburi.from(e.uri);i&&e.update({local:!0,name:i.artist})}else bridge("artist_metadata",[e.uri],function(i,t){i?global.console&&console.error(i):(t.image||e.get("image")||(t.image=""),t.images||e.get("images")||(t.images=[]),e.update(t))})}function updateLocal(e){e.update({local:isLocalArtist(e.uri)})}function onWait(e,i){const t=contains(i,"local");let r=!1;const a=["image","images","name"];for(let e=0,t=i.length;e<t;e++)if(contains(a,i[e])){r=!0;break}r&&updateMetadata(e),t&&updateLocal(e)}const regExp=exports.matches=/^spotify:artist:|^spotify:local:[^:]*$/;let registered;exports.register=function(){registered||(registered=!0,live.subscribe(regExp,"wait",onWait))},exports.unregister=function(){registered&&(registered=!1,live.unsubscribe(regExp,"wait",onWait))};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../live":148,"./util/bridge":141,"mout/array/contains":386,"spotify-liburi":450}],107:[function(require,module,exports){
(function (global){
"use strict";const forOwn=require("mout/object/forOwn"),combine=require("mout/array/combine"),remove=require("mout/array/remove"),contains=require("mout/array/contains"),URI="spotify:client-storage",live=require("../live"),cosmos=require("./util/cosmos"),endpoints={broadcast:"sp://messages/v1/client-storage"};let broadcastSubscription,waiting=[];function onInit(e){e.update({implemented:!0})}function onWait(e,t){waiting=combine(waiting,t),global.top.postMessage({type:"client_storage",name:"broadcast_client_storage",data:t},"*")}function onPublish(e,t){global.top.postMessage({type:"client_storage",name:"set_client_storage",data:t},"*"),e.update(t)}function onBroadcast(e,t){if(e)return void console.error("Broadcast Error",e);const i={},o=live(URI);forOwn(t.body,function(e,t){const r=contains(waiting,t),s=void 0!==o.get(t);(r||s)&&(i[t]=e),r&&remove(waiting,t)}),o.update(i)}const regExp=exports.matches=new RegExp(`^${URI}$`);let registered;exports.register=function(){registered||(registered=!0,live.subscribe(regExp,"init",onInit),live.subscribe(regExp,"wait",onWait),live.subscribe(regExp,"publish",onPublish),broadcastSubscription=cosmos.subscribe({url:endpoints.broadcast},onBroadcast))},exports.unregister=function(){registered&&(registered=!1,live.unsubscribe(regExp,"init",onInit),live.unsubscribe(regExp,"wait",onWait),live.unsubscribe(regExp,"publish",onPublish),broadcastSubscription&&(broadcastSubscription.cancel(),broadcastSubscription=null),waiting.length=0)},exports._endpoints=endpoints;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../live":148,"./util/cosmos":143,"mout/array/combine":385,"mout/array/contains":386,"mout/array/remove":395,"mout/object/forOwn":420}],108:[function(require,module,exports){
(function (global){
"use strict";const live=require("../live"),bridge=require("./util/bridge").request,liburi=require("spotify-liburi"),BACKOFF=100;function updateCurrentUser(e){const t=global.__spotify&&global.__spotify.username,i=liburi.profileURI(t).toURI();bridge("user_metadata",[i],function(o,s){if(o)return t&&e.update({currentUser:{uri:i,username:t}}),void(global.console&&console.error(o));e.update({currentUser:{uri:i,name:s.name,username:s.username}})})}function updateSessionData(e){bridge("session_query",[],function(t,i){t?global.console&&console.error(t):(void 0===i.employee&&(global.__spotify&&global.__spotify.product_state&&global.__spotify.product_state.employee?i.employee="1"===global.__spotify.product_state.employee:i.employee=!1),e.update({session:i}),bridgeWaitSession(e))})}let registered;function bridgeWaitSession(e){bridge("session_event_wait",[],function(t,i){if(registered){if(t)return setTimeout(function(){bridgeWaitSession(e)},BACKOFF),void(global.console&&console.error(t));"change"===i.type&&e.get("session").update(i.data),bridgeWaitSession(e)}})}function showContextMenu(e,t){global===window&&window.top&&window.top.postMessage&&window.top.postMessage({type:"client_show_context_ui",data:t},"*")}function onWait(e,t){t.indexOf("currentUser")>-1&&updateCurrentUser(e),t.indexOf("session")>-1&&updateSessionData(e)}function onInit(e){const t=global.__spotify||{},i=live(t.container_features||{});if(i.on("wait",function(e){const t={};for(let i=0;i<e.length;i++){t[e[i]]=!1}i.update(t)}),e.update({containerFeatures:i}),global.__spotify&&global.__spotify.username){const t=global.__spotify.username;e.update({currentUser:{uri:liburi.profileURI(t).toURI(),username:t}})}updateCurrentUser(e)}const regExp=exports.matches=/^spotify:client$/;exports.register=function(){registered||(registered=!0,live.subscribe(regExp,"wait",onWait),live.subscribe(regExp,"init",onInit),live.subscribe(regExp,"show-context-menu",showContextMenu))},exports.unregister=function(){registered&&(registered=!1,live.unsubscribe(regExp,"wait",onWait),live.unsubscribe(regExp,"init",onInit),live.unsubscribe(regExp,"show-context-menu",showContextMenu))};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../live":148,"./util/bridge":141,"spotify-liburi":450}],109:[function(require,module,exports){
"use strict";const live=require("../live"),cosmos=require("./util/cosmos");function onWait(e){cosmos.get({url:"sp://core-show/unstable/decorate",body:{items:[e.uri]}},function(i,s){if(i)throw i;const t=s.body.items[e.uri];t.show.uri=t.show.link,e.update(t)})}const regExp=exports.matches=/^spotify:episode:[^:]+$/;let registered;exports.register=function(){registered||(registered=!0,live.subscribe(regExp,"wait",onWait))},exports.unregister=function(){registered&&(registered=!1,live.unsubscribe(regExp,"wait",onWait))};

},{"../live":148,"./util/cosmos":143}],110:[function(require,module,exports){
"use strict";var _live=require("../live"),_live2=_interopRequireDefault(_live),_bridge=require("../bridge"),_playlistUtils=require("../playlist-utils"),_playlistUtils2=_interopRequireDefault(_playlistUtils);function _interopRequireDefault(e){return e&&e.__esModule?e:{default:e}}const CORE_FEEDBACK_ENDPOINT="sp://feedback/v1/feedback";let feedbackSubscriptionCancel;function onFeedbackSuccess(e,i){if(e||!i)return;const t=_playlistUtils2.default.formatListUtils.makeFeedbackUri(i.context_uri,i.uri);let l=null;switch(i.type){case"like":l="up";break;case"dislike":l="down"}(0,_live2.default)(t).update({thumb:l})}exports.register=function(){feedbackSubscriptionCancel=(0,_bridge.cosmosJSON)({method:"SUB",uri:CORE_FEEDBACK_ENDPOINT},onFeedbackSuccess)},exports.unregister=function(){feedbackSubscriptionCancel(),feedbackSubscriptionCancel=null};

},{"../bridge":50,"../live":148,"../playlist-utils":180}],111:[function(require,module,exports){
"use strict";const album=require("./album"),application=require("./application"),artist=require("./artist"),client=require("./client"),clientStorage=require("./client-storage"),sessionStorage=require("./session-storage"),player=require("./player"),playlist=require("./playlist"),sortlist=require("./sortlist"),track=require("./track"),user=require("./user"),add=require("./add"),localFiles=require("./local-files"),listVariant=require("./list-variant"),episode=require("./episode"),show=require("./show"),feedback=require("./feedback");exports.register=function(){album.register(),application.register(),artist.register(),client.register(),clientStorage.register(),sessionStorage.register(),player.register(),playlist.register(),sortlist.register(),track.register(),user.register(),add.register(),localFiles.register(),listVariant.register(),episode.register(),show.register(),feedback.register()},exports.unregister=function(){album.unregister(),application.unregister(),artist.unregister(),client.unregister(),clientStorage.unregister(),sessionStorage.unregister(),player.unregister(),playlist.unregister(),sortlist.unregister(),track.unregister(),user.unregister(),add.unregister(),localFiles.unregister(),listVariant.unregister(),episode.unregister(),show.unregister(),feedback.unregister()};

},{"./add":97,"./album":104,"./application":105,"./artist":106,"./client":108,"./client-storage":107,"./episode":109,"./feedback":110,"./list-variant":112,"./local-files":113,"./player":118,"./playlist":122,"./session-storage":123,"./show":124,"./sortlist":132,"./track":139,"./user":140}],112:[function(require,module,exports){
"use strict";var _contains=require("mout/array/contains"),_contains2=_interopRequireDefault(_contains),_unplayableTracksPlaylistSetting=require("./util/unplayable-tracks-playlist-setting.js"),_unplayableTracksPlaylistSetting2=_interopRequireDefault(_unplayableTracksPlaylistSetting),_legacySortUris=require("./sorting/legacy-sort-uris"),_legacySortUris2=_interopRequireDefault(_legacySortUris),_live=require("../live"),_live2=_interopRequireDefault(_live),_liveSortUri=require("../live-sort-uri"),_liveSortUri2=_interopRequireDefault(_liveSortUri),_liveFilterUri=require("../live-filter-uri"),_liveFilterUri2=_interopRequireDefault(_liveFilterUri),_playlistUtils=require("../playlist-utils"),_playlistUtils2=_interopRequireDefault(_playlistUtils),_spotifyLiburi=require("spotify-liburi"),_spotifyLiburi2=_interopRequireDefault(_spotifyLiburi);function _interopRequireDefault(t){return t&&t.__esModule?t:{default:t}}const SESSION_STORAGE="spotify:session-storage",CLIENT_STORAGE="spotify:client-storage",SORT_VARIANT_KEY="list-variant-",STRING_FILTER_KEY="list-filter-string-";function onWait(t,e){if(!(0,_contains2.default)(e,"listVariant"))return;const i=getOriginUri(t.uri);let r=(0,_live2.default)(i).get("listVariant");r||(r=(0,_live2.default)({origin:{uri:i}})).on("wait",onVariantWait.bind(null,r)),t.update({listVariant:r}),i!==t.uri&&(0,_live2.default)(i).update({listVariant:r})}function onVariantWait(t,e){(0,_contains2.default)(e,"currentUri")?addAndWatchCurrentUri(t):((0,_contains2.default)(e,"filterString")&&addAndWatchFilterString(t),((0,_contains2.default)(e,"sortQuery")||(0,_contains2.default)(e,"sortDirection")||(0,_contains2.default)(e,"sortUri"))&&addAndWatchSortQuery(t),(0,_contains2.default)(e,"showUnplayable")&&addAndWatchUnplayable(t))}function addAndWatchCurrentUri(t){function e(){const e="filterString, sortQuery, sortDirection, sortUri, showUnplayable, origin(uri)";t.query(e,function(i,r){if(i)return void console.error("Error when getting",e,":",Error);let a=r.origin.uri;const n=[];r.filterString&&n.push(`text contains ${encodeURIComponent(r.filterString)}`),r.showUnplayable||n.push("playable eq true"),n.length&&(a=_liveFilterUri2.default.create(a,n.join(",")));const l=r.sortUri&&_liveSortUri2.default.parse(r.sortUri);l&&(a=_liveSortUri2.default.create(a,l.direction,l.query)),t.update({currentUri:a})})}t.on("update",e),e()}function addAndWatchUnplayable(t){const e=t.get("origin").uri;_spotifyLiburi2.default.isPlaylistV1OrV2(e)?(0,_live2.default)(e).get("formatListType",function(e,i){e||"chart"!==i?subscribeToUnplayablePref(t):t.update({showUnplayable:!0})}):t.update({showUnplayable:!0})}let showUnplayablePref,registered,updateUnavailablePrefOn=[];function subscribeToUnplayablePref(t){updateUnavailablePrefOn.push(t),showUnplayablePref?t.update({showUnplayable:showUnplayablePref}):_unplayableTracksPlaylistSetting2.default.subscribe(function(t,e){let i=e;t&&(console.error(t),i=!1),showUnplayablePref=i;for(let t=0;t<updateUnavailablePrefOn.length;t++)updateUnavailablePrefOn[t].update({showUnplayable:i})})}function fetchSortVariantByUri(t){return new Promise((e,i)=>(0,_live2.default)(CLIENT_STORAGE).get(exports.getSortVariantKey(t),(t,r)=>{t?i(t):e(r)}))}async function addAndWatchSortQuery(t){const e=t.get("origin").uri,i=(0,_live2.default)(CLIENT_STORAGE),r=exports.getSortVariantKey(e);if(i.get("implemented")){if(_spotifyLiburi2.default.isPlaylistV2(e)){if(!await fetchSortVariantByUri(e)){const t=await fetchSortVariantByUri(await _playlistUtils2.default.fetchPlaylistV1UriFromPlaylist(e));t&&i.publish({[r]:t})}}updateSortParams(t,e,r),i.on("update",function(i){i.hasOwnProperty(r)&&updateSortParams(t,e,r)})}else{const i=getDefaultQueryParams(e);t.update(i)}}function updateSortParams(t,e,i){const r=(0,_live2.default)(CLIENT_STORAGE);r.get(i,function(a,n){const l=n&&_liveSortUri2.default.parse(n);if(!a&&l){const a=_legacySortUris2.default.legacyQueries[l.query];if(a&&a!==l.query){const t=_liveSortUri2.default.create(e,l.direction,a),n={};return n[i]=t,void r.publish(n)}t.update({sortQuery:l.query,sortDirection:l.direction,sortUri:n})}else if(n===e)t.update({sortQuery:null,sortDirection:null,sortUri:null});else{const i=getDefaultQueryParams(e);t.update(i)}})}function getDefaultQueryParams(t){let e=null,i=null,r=null;return"spotify:internal:local-files"===t&&(e="track(name)",i="asc",r=_liveSortUri2.default.create(t,i,e)),{sortQuery:e,sortDirection:i,sortUri:r}}function addAndWatchFilterString(t){const e=t.get("origin").uri,i=(0,_live2.default)(SESSION_STORAGE),r=STRING_FILTER_KEY+e;i.get("implemented")?(updateFilterString(t,e,r),i.on("update",function(i){i.hasOwnProperty(r)&&updateFilterString(t,e,r)})):t.update({filterString:""})}function updateFilterString(t,e,i){(0,_live2.default)(SESSION_STORAGE).get(i,function(e,i){t.update({filterString:i||""})},_live2.default.ASAP)}function getOriginUri(t){let e=t;const i=_liveSortUri2.default.parse(e);i&&(e=i.originUri);const r=_liveFilterUri2.default.parse(e);return r&&(e=r.originUri),e}function updateRegisteredStatus(t){registered=t,(0,_live2.default)("spotify:list-variant").update({implemented:t})}exports.getSortVariantKey=function(t){return"list-variant-"+t};const regExp=exports.matches=/^spotify:/;exports.register=function(){registered||(_live2.default.subscribe(regExp,"wait",onWait),updateRegisteredStatus(!0))},exports.unregister=function(){registered&&(updateUnavailablePrefOn=[],showUnplayablePref=null,_live2.default.unsubscribe(regExp,"wait",onWait),updateRegisteredStatus(!1))};

},{"../live":148,"../live-filter-uri":92,"../live-sort-uri":146,"../playlist-utils":180,"./sorting/legacy-sort-uris":126,"./util/unplayable-tracks-playlist-setting.js":145,"mout/array/contains":386,"spotify-liburi":450}],113:[function(require,module,exports){
(function (global){
"use strict";const contains=require("mout/array/contains"),live=require("../live"),listOperations=require("../live-list-operations"),liburi=require("spotify-liburi"),Range=require("../range2"),cosmos=require("./util/cosmos"),regExp=/^spotify:internal:local-files$/;function onWait(e,t){contains(t,"allows")&&getAllows(e),contains(t,"rows")&&getRows(e)}function getAllows(e){e.update({allows:{insertTracks:!1,removeTracks:!1}})}function createRows(e){const t=new Array(e.length);for(let o=0,r=e.length;o<r;o++){const r=e[o];setLocalProperty(r);const s=1e3*r.dateAdded,i={uri:getRowUri(r.uri),track:r,dateAdded:s};t[o]=i,delete r.dateAdded,delete r.addedBy}return t}function setLocalProperty(e){if(e.album&&e.album.uri){const t=liburi.from(e.album.uri).type;e.album.local=t===liburi.Type.LOCAL_ALBUM}if(e.artists)for(let t=0,o=e.artists.length;t<o;t++){const o=e.artists[t];if(o.uri){const e=liburi.from(o.uri).type;o.local=e===liburi.Type.LOCAL_ARTIST}}}function getRows(e){cosmos.get({url:"sp://local-files/v1/tracks"},function(t,o){t?global.console&&console.error(t):(e.update({rows:createRows(o.body)}),cosmos.subscribe({url:"sp://local-files/v1/changes"},function(t,o){t?global.console&&console.error(t):onChange(e,o.body)}))})}function onChange(e,t){switch(t.type){case"removed":onTracksRemoved(e,t.data);break;case"added":onTracksAdded(e,t.data);break;case"moved":onTracksMoved(e,t.data);break;case"changed":onMetadataChanged(e,t.data);break;default:console.error("Unexpected event type",t.type)}}function onMetadataChanged(e,t){const o=Range.fromIndices(t.positions);let r=0;for(let s=0;s<o.length;s++){const i=o[s],n=i.toIndices(),a=i.length,c=new Array(n.length);for(let e=0;e<a;e++)c[e]=t.tracks[r+e];const l=listOperations.getRemoveOperations(n);e.get("rows").update(l),addTracksToList(e,c,n[0]),r+=a}}function onTracksMoved(e,t){const o=listOperations.getMoveOperations(t.positions,t.position);e.get("rows").update(o)}function onTracksRemoved(e,t){const o=listOperations.getRemoveOperations(t.positions);e.get("rows").update(o)}function onTracksAdded(e,t){addTracksToList(e,t.tracks,t.position)}function addTracksToList(e,t,o){const r=createRows(t),s=listOperations.getInsertOperations(r,o);e.get("rows").update(s)}let idCounter=1e3;function getRowUri(e){return e.replace("spotify:",`spotify:row:${(++idCounter).toString(36)}:`)}let registered=!1;exports.register=function(){registered||(registered=!0,live.subscribe(regExp,"wait",onWait))},exports.unregister=function(){registered&&(registered=!1,live.unsubscribe(regExp,"wait",onWait))},exports.matches=regExp;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../live":148,"../live-list-operations":93,"../range2":189,"./util/cosmos":143,"mout/array/contains":386,"spotify-liburi":450}],114:[function(require,module,exports){
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.play=play;const cosmos=require("../util/cosmos"),liburi=require("spotify-liburi");function play(e,r,i){const s=liburi.from(e),t={url:`sp://core-collection/unstable/@/list/tracks/${{[liburi.Type.COLLECTION_ALBUM]:"album",[liburi.Type.COLLECTION_ARTIST]:"artist"}[s.type]}/${s.getBase62Id()}/play?sort=${{[liburi.Type.COLLECTION_ALBUM]:"discNumber,trackNumber",[liburi.Type.COLLECTION_ARTIST]:"addTime DESC,discNumber,trackNumber"}[s.type]}`};r&&(t.body=r),cosmos.post(t,i)}

},{"../util/cosmos":143,"spotify-liburi":450}],115:[function(require,module,exports){
(function (global){
"use strict";var _liveWrappedUri=require("../../live-wrapped-uri"),_liveWrappedUri2=_interopRequireDefault(_liveWrappedUri),_cosmosPlayer=require("./cosmos-player"),_cosmosPlayer2=_interopRequireDefault(_cosmosPlayer),_playerApi=require("./player-api"),_playerApi2=_interopRequireDefault(_playerApi),_playlistResolver=require("./playlist-resolver"),playlistResolver=_interopRequireWildcard(_playlistResolver),_collectionResolver=require("./collection-resolver"),collectionResolver=_interopRequireWildcard(_collectionResolver),_data=require("./data"),_data2=_interopRequireDefault(_data);function _interopRequireWildcard(e){if(e&&e.__esModule)return e;var r={};if(null!=e)for(var t in e)Object.prototype.hasOwnProperty.call(e,t)&&(r[t]=e[t]);return r.default=e,r}function _interopRequireDefault(e){return e&&e.__esModule?e:{default:e}}function playTrackUris(e,r,t){_playerApi2.default.play(e,r,t)}function playFromResolver(e,r,t){_playerApi2.default.playFromResolver(e,r,t)}function playContext(e,r,t){_playerApi2.default.playContext(e,r,t)}function updateContext(e,r){_playerApi2.default.updateContext(e,r)}function playFromPlaylistResolver(e,r,t){const i={};r.uids?i.track_uid=r.uids[0]:r.uid&&(i.track_uid=r.uid),r.uris?i.track_uri=r.uris[0]:r.trackUri&&(i.track_uri=r.trackUri);const o={};Object.keys(i).length&&(o.skip_to_index=i);const l={prepare_play_options:o,play_origin:{view_uri:_liveWrappedUri2.default.getOriginUri(r.context)||r.context,feature_identifier:r.source,referrer_identifier:r.referrerId,feature_version:r.referrerVersion}};playlistResolver.play(e,l,t)}function playFromCollectionResolver(e,r,t){const i={view_uri:_liveWrappedUri2.default.getOriginUri(r.context)||r.context,feature_identifier:r.source,referrer_identifier:r.referrerId,feature_version:r.referrerVersion},o={};null!==r.index&&(o.skip_to={track_index:r.index});const l={prepare_play_options:o,play_origin:i};collectionResolver.play(e,l,t)}function playTrack(e,r,t){r.context=e,r.track=e,r.index=0,playTrackUris([{uri:e}],r,t)}function playRows(e,r,t){const{index:i,range:o}=r;if(null===i&&o)_data2.default.getFirstPlayableRow(e,o,(i,o)=>{if(i)global.console&&console.error(i),t&&t(i);else{const i=_data2.default.getTracksFromRows(e);r.index=o,playTrackUris(i,r,t)}});else{playTrackUris(_data2.default.getTracksFromRows(e),r,t)}}function playFromArtist(e,r,t){playFromResolver(e,r,t)}function updateWithRows(e,r,t){const i=_data2.default.getTracksFromRows(e);delete r.index,_playerApi2.default.update(i,r,t)}function pause(e){_playerApi2.default.pause(e)}function resume(e){_playerApi2.default.resume(e)}function skipPrev(e){_cosmosPlayer2.default.skipPrev(e)}function skipNext(e){_cosmosPlayer2.default.skipNext(e)}exports.playTrack=playTrack,exports.playRows=playRows,exports.playFromResolver=playFromResolver,exports.playContext=playContext,exports.playFromArtist=playFromArtist,exports.updateContext=updateContext,exports.updateWithRows=updateWithRows,exports.pause=pause,exports.resume=resume,exports.skipPrev=skipPrev,exports.skipNext=skipNext,exports.playFromPlaylistResolver=playFromPlaylistResolver,exports.playFromCollectionResolver=playFromCollectionResolver;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../live-wrapped-uri":147,"./collection-resolver":114,"./cosmos-player":116,"./data":117,"./player-api":119,"./playlist-resolver":120}],116:[function(require,module,exports){
"use strict";const cosmos=require("../util/cosmos"),PLAYER_URI="sp://player/v2/main",ACTIONS={PLAY:"play",PAUSE:"pause",RESUME:"resume",UPDATE:"update",SKIP_PREV:"skip_prev",SKIP_NEXT:"skip_next"};function pause(s){cosmos.post({url:PLAYER_URI,body:{action:ACTIONS.PAUSE}},s)}function resume(s){cosmos.post({url:PLAYER_URI,body:{action:ACTIONS.RESUME}},s)}function skipPrev(s){cosmos.post({url:PLAYER_URI,body:{action:ACTIONS.SKIP_PREV}},s)}function skipNext(s){cosmos.post({url:PLAYER_URI,body:{action:ACTIONS.SKIP_NEXT}},s)}function getState(s){cosmos.get({url:PLAYER_URI},function(e,o){e?s(e):s(null,o.body)})}function subscribe(s){let e=cosmos.subscribe({url:PLAYER_URI},function(e,o){e?s(e):s(null,o.body)});return{unsubscribe:function(){e&&(e.cancel(),e=null)}}}exports.pause=pause,exports.resume=resume,exports.skipPrev=skipPrev,exports.skipNext=skipNext,exports.getState=getState,exports.subscribe=subscribe;

},{"../util/cosmos":143}],117:[function(require,module,exports){
(function (global){
"use strict";const live=require("../../live"),Range=require("../../range2"),playerApi=require("./player-api"),PLAY_OPTIONS_DEFAULTS={page:null,uid:null,trackUri:null,index:null,source:"unknown",reason:"unknown"};function getFirstPlayableRow(e,r,t){let i=r.start;isRowPlayable(e.get(i),function a(n,l){l?t(null,i):i===r.end-1?t(null,r.start):isRowPlayable(e.get(++i),a)})}function isRowPlayable(e,r){e?e.query("track(playable)",function(e,t){e?r(e):r(null,t.track.playable)},live.ASAP):r(null,!1)}function getPlayOptions(e,r){getReferrer(e,function(t,i,a,n){t?r(t):(Object.keys(PLAY_OPTIONS_DEFAULTS).forEach(function(r){void 0===e[r]&&(e[r]=PLAY_OPTIONS_DEFAULTS[r])}),e.range&&(e.range=new Range(e.range[0],e.range[1])),e.viewUri=i,e.referrerId=a,e.referrerVersion=getReferrerVersion(),e.featureId=n,r(null,e))})}function getTracksFromRows(e){return e.map((r,t)=>{const i=r&&r.get("track");if(i){const r=i.serialize(1),a={};return r.manifestId&&(a["media.manifest_id"]=r.manifestId),r.mediaTypeEnum&&(a["media.type"]=2===r.mediaTypeEnum?"video":"audio"),{uri:r.uri,uid:e.keys[t],metadata:a}}return null})}function getPlayerState(e){playerApi.getState(e)}function subscribeForPlayerState(e){return playerApi.subscribe(e)}function getReferrer(e,r){const t=live("spotify:player").get("referrer"),i=live("spotify:player").get("referrerBaseUri");t?(i||console.warn(`referrer field is set on the player model (${t}), but referrerBaseUri isn't`),r(null,t,i||"","")):e.viewUri&&e.referrerId?r(null,e.viewUri,e.referrerId,e.featureId):live("spotify:application").get("appURI","arguments",function(t,i,a){if(t)r(t);else{const t=e.viewUri||(a?`${i}:${a}`:i);r(null,t,i,"")}})}function getReferrerVersion(){return global.__spotify.app_version}exports.getReferrer=getReferrer,exports.getReferrerVersion=getReferrerVersion,exports.getFirstPlayableRow=getFirstPlayableRow,exports.isRowPlayable=isRowPlayable,exports.getPlayOptions=getPlayOptions,exports.getTracksFromRows=getTracksFromRows,exports.getPlayerState=getPlayerState,exports.subscribeForPlayerState=subscribeForPlayerState;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../live":148,"../../range2":189,"./player-api":119}],118:[function(require,module,exports){
(function (global){
"use strict";var _messageProxy=require("../../../libs/message-proxy");const live=require("../../live"),URI=require("spotify-liburi"),CancellationTokenSource=require("../../../libs/cancellation-token-source").default,playerApi=require("./player-api"),playbackControl=require("./control"),dataUtils=require("./data"),updatesUtils=require("./updates"),sortUriUtils=require("../../live-sort-uri"),filterUriUtils=require("../../live-filter-uri"),createStationPlayContext=require("../station/create-play-context"),createStationPlayOptions=require("../station/create-play-options"),isStationUri=require("../station").isStationUri,TYPE_TRACK="track",TYPE_ROWS="rows",TYPE_CP_RESOLVER_PLAYLIST="context-player-resolver-playlist",TYPE_CP_RESOLVER_COLLECTION="context-player-resolver-collection",TYPE_CP_CONTEXT="context-player-context",TYPE_CONTEXT_OBJECT="context-object",TYPE_STATION_CONTEXT="context-station-context",TYPE_CP_ARTIST_CONTEXT="context-player-artist",TYPE_CP_ALBUM_CONTEXT="context-player-album",TYPE_CONTEXT_EPISODE="context-episode",TYPE_CONTEXT_SHOW="context-show",cancellationTokenSource=new CancellationTokenSource,contextDataStore={};function onWait(e){updateState(e)}function onSync(e){updateState(e)}function onPlayerStateUpdate(e,t){if(e)return void(global.console&&console.error(e));const i=live("spotify:player");i.get("pending")||i.update(t)}function onUpdate(e){const t=e.get("index")&&e.get("index").get("track");null!==t&&updatesUtils.setPlayingIndex(t),updatesUtils.clean(e)}function onPlay(e,t){const i=t.context;if(!i)return;"number"!=typeof t.index&&delete t.index,cancellationTokenSource.cancel();const o=cancellationTokenSource.token();e.update(playerApi.addContext({isPlaying:!0,isPaused:!1,index:void 0===t.index?null:{page:0,track:t.index},track:void 0===t.trackUri?null:{uri:t.trackUri},contextUpdatedCrossFrame:!1},i)),dataUtils.getPlayOptions(t,function(t,i){t||!i.context?updateState(e):/^spotify:internal:/.test(i.context)?playWithOptions(e,o,i):live("spotify:list-variant").get("implemented")?live(i.context).query("listVariant(currentUri, sortUri)",function(t,a){t?updateState(e):o.isCanceled()||(i.context=a.listVariant.currentUri,playWithOptions(e,o,i))}):playWithOptions(e,o,i)})}function onPause(e){!1!==e.get("isPlaying")&&!0!==e.get("isPaused")&&(e.update({isPaused:!0}),playbackControl.pause(function(t){t&&e.update({isPaused:!1})}))}function onResume(e){!0===e.get("isPlaying")&&!1===e.get("isPaused")||(e.update({isPaused:!1}),playbackControl.resume(function(t){t&&e.update({isPaused:!0})}))}function onSkipPrev(){playbackControl.skipPrev()}function onSkipNext(){playbackControl.skipNext()}function onUpdateShowContext(e,t){const i=t.context;if(!i)return;cancellationTokenSource.cancel();const o=cancellationTokenSource.token();e.update(playerApi.addContext({},i));live(i).query("show(name, uri), rows(track(uri, name, mediaTypeEnum))",(t,a)=>{if(!o.isCanceled())if(t)updateState(e);else{const t={uri:a.show.uri,pages:[{tracks:a.rows.map(({track:e})=>({uri:e.uri,uid:e.uri,metadata:{title:e.name,album_title:a.show.name,"media.type":1===e.mediaTypeEnum?"audio":"video","media.manifest_id":live(e.uri).get("manifestId")||""}}))}],metadata:{"zelda.context_uri":i}};playbackControl.updateContext(t,t=>{t&&updateState(e)})}},3e3)}function playWithOptions(e,t,i){const o=i.context,a=getPlaybackResolverType(o);if(a===TYPE_TRACK)playbackControl.playTrack(o,i,function(t){t&&updateState(e)});else if(a===TYPE_CP_ALBUM_CONTEXT)playbackControl.playFromResolver(o,i,function(t){t&&updateState(e)});else if(a===TYPE_ROWS){sortUriUtils.isValid(o)?getSortedRows(o,function(o,a){o?updateState(e):t.isCanceled()||playRows(e,a,i)}):live(o).query("rows(track(uri))",function(a){a||t.isCanceled()||playRows(e,live(o).get("rows"),i)})}else if(a===TYPE_CP_RESOLVER_PLAYLIST)playbackControl.playFromPlaylistResolver(o,i,function(t){t&&updateState(e)});else if(a===TYPE_CP_RESOLVER_COLLECTION)playbackControl.playFromCollectionResolver(o,i,function(t){t&&updateState(e)});else if(a===TYPE_CONTEXT_OBJECT){const t=contextDataStore[o];playbackControl.playContext(t,i,function(t){t&&updateState(e)})}else if(a===TYPE_CP_CONTEXT){const t={url:`context://${o}`,entity_uri:o};playbackControl.playContext(t,i,function(t){t&&updateState(e)})}else if(a===TYPE_STATION_CONTEXT){const t=live(o);t.query("rows",function(a){a||(playbackControl.playContext(createStationPlayContext(t),createStationPlayOptions(t,i),function(t){t&&updateState(e)}),(0,_messageProxy.messageProxy)({method:"POST",uri:"station-create",target:"top",body:{stationUri:o}}))})}else if(a===TYPE_CP_ARTIST_CONTEXT)playbackControl.playFromArtist(o,i,function(t){t&&updateState(e)});else if(a===TYPE_CONTEXT_EPISODE){const t=3e3;live(o).query("name, mediaTypeEnum, show(name)",function(t,a){if(t)updateState(e);else{const t={uri:o,pages:[{tracks:[{uri:o,metadata:{title:a.name,album_title:a.show.name,"media.type":1===a.mediaTypeEnum?"audio":"video","media.manifest_id":live(o).get("manifestId")||""}}]}],restrictions:{disallow_toggling_repeat_context_reasons:["disallow-video"],disallow_toggling_repeat_track_reasons:["disallow-video"],disallow_toggling_shuffle_reasons:["disallow-video"]}};i.player_options_override||(i.player_options_override={}),i.player_options_override.repeating_context=!1,i.player_options_override.repeating_track=!1,playbackControl.playContext(t,i,function(t){t&&updateState(e)})}},t)}else if(a===TYPE_CONTEXT_SHOW){const t=3e3;live(o).query("show(name, uri), rows(track(uri, name, mediaTypeEnum))",(t,a)=>{if(t)updateState(e);else{const t={uri:a.show.uri,pages:[{tracks:a.rows.map(({track:e})=>({uri:e.uri,uid:e.uri,metadata:{title:e.name,album_title:a.show.name,"media.type":1===e.mediaTypeEnum?"audio":"video","media.manifest_id":live(e.uri).get("manifestId")||""}}))}],restrictions:{disallow_toggling_repeat_context_reasons:["disallow-show"],disallow_toggling_repeat_track_reasons:["disallow-show"],disallow_toggling_shuffle_reasons:["disallow-show"]},metadata:{"zelda.context_uri":o}};i.player_options_override||(i.player_options_override={}),i.player_options_override.repeating_context=!1,i.player_options_override.repeating_track=!1,i.player_options_override.shuffling_context=!1,playbackControl.playContext(t,i,t=>{t&&updateState(e)})}},t)}}function playRows(e,t,i){playbackControl.playRows(t,i,function(o){o&&updateState(e),updatesUtils.listen(t,i,function(i){playbackControl.updateWithRows(t,i,function(t){t&&updateState(e)})})})}function getPlaybackResolverType(e){const t=URI.from(e).type,i=t===URI.Type.TRACK,o=t===URI.Type.LOCAL,a=t===URI.Type.PLAYLIST||t===URI.Type.PLAYLIST_V2,r=t===URI.Type.COLLECTION_ALBUM,n=t===URI.Type.COLLECTION_ARTIST,s=t===URI.Type.FOLDER,l=t===URI.Type.ARTIST,p=t===URI.Type.ALBUM,u=sortUriUtils.isValid(e),c=filterUriUtils.isValid(e),d=isStationUri(e),_=t===URI.Type.EPISODE,y=t===URI.Type.SHOW;if(i||o)return TYPE_TRACK;if(a)return TYPE_CP_RESOLVER_PLAYLIST;if(r||n)return TYPE_CP_RESOLVER_COLLECTION;if(s)return TYPE_CP_CONTEXT;if(d)return TYPE_STATION_CONTEXT;let T;if(u)return T=sortUriUtils.parse(e).originUri,filterUriUtils.isValid(T)&&(T=filterUriUtils.parse(T).originUri),URI.isPlaylistV1OrV2(T)?TYPE_CP_RESOLVER_PLAYLIST:URI.isShow(T)?TYPE_CONTEXT_SHOW:TYPE_ROWS;if(c)return T=filterUriUtils.parse(e).originUri,URI.isPlaylistV1OrV2(T)?TYPE_CP_RESOLVER_PLAYLIST:TYPE_ROWS;if(_)return TYPE_CONTEXT_EPISODE;if(y)return TYPE_CONTEXT_SHOW;if(contextDataStore[e])return TYPE_CONTEXT_OBJECT;const E=live(e).get("rows");return E&&E.length?TYPE_ROWS:l?TYPE_CP_ARTIST_CONTEXT:p?TYPE_CP_ALBUM_CONTEXT:null}function getSortedRows(e,t){const i=sortUriUtils.getOriginUri(e);live(i).get("rows",function(i,o){i?t(i):o.get(0,o.length,function(o){o?t(i):live(e).get("rows",function(e,i){e?t(e):t(null,i)})})})}function updateState(e){dataUtils.getPlayerState(function(t,i){t?global.console&&console.error(t):e.update(i)})}const regExp=exports.matches=/^spotify:player$/;let registered,playerSubscription,cancelPlayerErrorSubscription;exports.register=function(){registered||(registered=!0,live.subscribe(regExp,"play",onPlay),live.subscribe(regExp,"pause",onPause),live.subscribe(regExp,"resume",onResume),live.subscribe(regExp,"skip-previous",onSkipPrev),live.subscribe(regExp,"skip-next",onSkipNext),live.subscribe(regExp,"update-show-context",onUpdateShowContext),live.subscribe(regExp,"update",onUpdate),live.subscribe(regExp,"wait",onWait),live.subscribe(regExp,"sync-position",onSync),playerSubscription=dataUtils.subscribeForPlayerState(onPlayerStateUpdate),cancelPlayerErrorSubscription=playerApi.onError(function(e,t){if(e)return void console.error(e);switch(t.getJSONBody().error){case"one_track_unplayable":case"one_track_unplayable_auto_stopped":case"all_tracks_unplayable_auto_stopped":exports._syncPlayerModelState()}}))},exports._syncPlayerModelState=function(){updateState(live("spotify:player"))},exports.unregister=function(){registered&&(registered=!1,live.unsubscribe(regExp,"play",onPlay),live.unsubscribe(regExp,"pause",onPause),live.unsubscribe(regExp,"resume",onResume),live.unsubscribe(regExp,"skip-previous",onSkipPrev),live.unsubscribe(regExp,"skip-next",onSkipNext),live.unsubscribe(regExp,"update-show-context",onUpdateShowContext),live.unsubscribe(regExp,"update",onUpdate),live.unsubscribe(regExp,"wait",onWait),live.unsubscribe(regExp,"sync-position",onSync),playerSubscription.unsubscribe(),cancelPlayerErrorSubscription&&cancelPlayerErrorSubscription(),playerSubscription=null)},exports.setContextData=function(e,t){contextDataStore[e]=t};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../../libs/cancellation-token-source":51,"../../../libs/message-proxy":165,"../../live":148,"../../live-filter-uri":92,"../../live-sort-uri":146,"../station":133,"../station/create-play-context":134,"../station/create-play-options":135,"./control":115,"./data":117,"./player-api":119,"./updates":121,"spotify-liburi":450}],119:[function(require,module,exports){
(function (global){
"use strict";var _data=require("./data"),_data2=_interopRequireDefault(_data),_cosmos=require("../util/cosmos"),_cosmos2=_interopRequireDefault(_cosmos),_liveSortUri=require("../../live-sort-uri"),_liveSortUri2=_interopRequireDefault(_liveSortUri),_liveFilterUri=require("../../live-filter-uri"),_liveFilterUri2=_interopRequireDefault(_liveFilterUri),_player=require("../../player"),_player2=_interopRequireDefault(_player),_cosmosApi=require("../../cosmos-api"),_cosmosApi2=_interopRequireDefault(_cosmosApi);function _interopRequireDefault(e){return e&&e.__esModule?e:{default:e}}function getPlayer(e,t){const r=e||{};_data2.default.getReferrer(r,(e,r,i,n)=>{if(e)return void t(e);let o=n;const a=_data2.default.getReferrerVersion();if(!o){const e=global.__spotify&&global.__spotify.app_manifest;e&&(o=e.BundleIdentifier||null)}const u={station:"radio",stations:"radio","radio-hub":"radio","daily-mix-hub":"radio"};o&&u[o]&&(o=u[o]);const l=i?{referrerIdentifier:i}:null,s=new _player2.default.Player(_cosmosApi2.default.resolver,r,o,a,l);t(s)})}function play(e,t,r){getPlayer(t,function(i){const n={pages:[{tracks:e}],metadata:{"zelda.context_uri":t.context},entity_uri:getOriginUri(t.context)},o={};"number"==typeof t.index?o.skip_to_index={page:0,track:t.index}:(t.uid||t.uri)&&(o.skip_to={},t.uid?o.skip_to.track_uid=t.uid:t.uri&&(o.skip_to.track_uri=t.uri)),i.play(n,o,r)})}function playContext(e,t,r){t.uid||t.uri||t.page?(t.skip_to={},t.uid?t.skip_to.track_uid=t.uid:t.uri&&(t.skip_to.track_uri=t.uri),t.page&&(t.skip_to.page_index=t.page)):t.range?t.skip_to_index={page:0,track:t.range.start}:"number"==typeof t.index&&(t.skip_to_index={page:0,track:t.index}),getPlayer(t,function(i){i.play(e,t||{},r)})}function updateContext(e,t){getPlayer(null,function(r){r.update(e,t)})}function update(e,t,r){getPlayer(t,function(i){const n={pages:[{tracks:e}],metadata:{"zelda.context_uri":t.context},entity_uri:getOriginUri(t.context)};i.update(n,r)})}function playFromResolver(e,t,r){getPlayer(t,i=>{_cosmos2.default.sanitizeURL(e,(e,n)=>{if(e)return void(r&&r(e));const o={uri:n,url:`context://${encodeURI(n)}`};let a=null;"number"==typeof t.index?a={skip_to_index:{page:0,track:t.index}}:t.trackUri&&(a={skip_to_index:{track_uri:t.trackUri}}),"number"==typeof t.seekTo&&(a.seek_to=t.seekTo),i.play(o,a,r)})})}let cancelSubscribe,onErrorSubscription;function subscribe(e,t={}){let r;return cancelSubscribe=!1,getPlayer(null,i=>{cancelSubscribe||(r=i.subscribe((t,r)=>{t?e(t):e(null,addContext(r.getJSONBody()))},t))}),{unsubscribe:()=>{cancelSubscribe=!0,r&&(r.cancel(),r=null)}}}function onError(e){return getPlayer(null,t=>{onErrorSubscription=t.onError(e)}),()=>{onErrorSubscription&&(onErrorSubscription.cancel(),onErrorSubscription=null)}}function getState(e){getPlayer(null,t=>{t.getState((t,r)=>{t?e(t,null):e(null,addContext(r.getJSONBody()))})})}function pause(e){getPlayer(null,t=>{t.pause(e)})}function resume(e){getPlayer(null,t=>{t.resume(e)})}function addContext(e,t){const r=t||e.context_metadata["zelda.context_uri"]||e.context_uri||e.track&&e.track.uri||null,i=getOriginUri(r);return delete e.context_uri,r?(e.variant={uri:r},e.context={uri:i}):(e.variant=null,e.context=null),e.track=e.track||null,e.index=e.index||null,e.track?(e.uid=e.track.uid,delete e.track.uid):e.uid=null,removeUnderscores(e)}function getOriginUri(e){if(!e)return e;const t=_liveSortUri2.default.parse(e);let r=e;t&&(r=t.originUri);const i=_liveFilterUri2.default.parse(r);return i&&(r=i.originUri),r}function removeUnderscores(e){let t;for(const r in e)e.hasOwnProperty(r)&&(t=r.replace(/_(.)/g,(e,t)=>t.toUpperCase()),e[r]instanceof Object?e[t]=removeUnderscores(e[r]):e[t]=e[r],t!==r&&delete e[r]);return e}exports.play=play,exports.playFromResolver=playFromResolver,exports.playContext=playContext,exports.pause=pause,exports.resume=resume,exports.update=update,exports.subscribe=subscribe,exports.onError=onError,exports.getState=getState,exports.addContext=addContext,exports.updateContext=updateContext;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../cosmos-api":54,"../../live-filter-uri":92,"../../live-sort-uri":146,"../../player":175,"../util/cosmos":143,"./data":117}],120:[function(require,module,exports){
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.play=play;const playlistUtils=require("../../../libs/playlist-utils").default,isPlaylist2Shows=require("../../../libs/playlist-utils").default.isPlaylist2Shows,live=require("../../../libs/live"),wrappedUri=require("../../../libs/live-wrapped-uri");function play(e,i,l){checkIfPlaylistsToShowsContext(e).then(s=>{playlistUtils.playlistRequest(e,{method:"POST",includeEpisodes:s,type:"play",body:i},l)})}function checkIfPlaylistsToShowsContext(e){return new Promise(i=>{const l=wrappedUri.parse(e),s=l?l.originUri:e;live(s).get("formatListType",(e,l)=>{i(isPlaylist2Shows(l))},live.ASAP)})}

},{"../../../libs/live":148,"../../../libs/live-wrapped-uri":147,"../../../libs/playlist-utils":180}],121:[function(require,module,exports){
"use strict";let lastRowsList,lastRowsListUri,lastRowsListHandler,lastRowsListReferrer,playerRowKey,playerKeys;function listen(e,s,t){lastRowsList&&removeRowsListener(),lastRowsList=e,lastRowsListUri=s.context,lastRowsListReferrer=s.referrerId,lastRowsListHandler=function(){s.index=getPlayingAndUpdateIndicesInList(e).update,t(s)},e.on("update",lastRowsListHandler)}function clean(e){if(!lastRowsListHandler)return;const s=e.get("variant");if((s&&s.uri)!==lastRowsListUri)removeRowsListener();else{const s=e.get("playOrigin");(s&&s.get("referrerIdentifier"))===lastRowsListReferrer||e.get("contextUpdatedCrossFrame")||removeRowsListener()}}function setPlayingIndex(e,s){if(!lastRowsList&&!s)return;if(e<0)return;const t=s||lastRowsList;playerRowKey=t.keys[e]||null,playerKeys=t.keys.slice()}function removeRowsListener(){lastRowsList&&lastRowsList.off("update",lastRowsListHandler),lastRowsList=null,lastRowsListUri="",lastRowsListHandler=null,lastRowsListReferrer=""}function getPlayingAndUpdateIndicesInList(e){if(!playerRowKey)return{update:-1,playing:-1};const s=e.keys.indexOf(playerRowKey);let t=s;if(-1===s){for(let s=playerKeys.indexOf(playerRowKey),i=playerKeys.length;s<i;s++)if((t=e.keys.indexOf(playerKeys[s]))>-1){t--;break}}return{update:t,playing:s}}function isPlayingFromRowsContext(e){return e?lastRowsListUri===e:!!lastRowsList}exports.setPlayingIndex=setPlayingIndex,exports.listen=listen,exports.clean=clean,exports.getPlayingAndUpdateIndicesInList=getPlayingAndUpdateIndicesInList,exports.isPlayingFromRowsContext=isPlayingFromRowsContext;

},{}],122:[function(require,module,exports){
(function (global){
"use strict";var _live=require("../live"),_live2=_interopRequireDefault(_live),_offlineStatus=require("../playlist-utils/offline-status"),_bridge=require("../bridge"),_playlistUtils=require("../playlist-utils"),_playlistUtils2=_interopRequireDefault(_playlistUtils),_messageProxy=require("../message-proxy");function _interopRequireDefault(e){return e&&e.__esModule?e:{default:e}}function onBroadcast(e,t){e?global.console&&console.error(e):(0,_live2.default)(t.uri).update(t)}function onWait(e,t){const i={};t.includes("name")&&(i.name=!0),t.includes("description")&&(i.description=!0),(t.includes("image")||t.includes("annotatedImage"))&&(i.picture=!0),t.includes("added")&&(i.followed=!0),t.includes("formatListType")&&(i.formatListType=!0),t.includes("formatListAttributes")&&(i.formatListAttributes=!0),t.includes("annotatedImage")&&(i.pictureFromAnnotate=!0),t.includes("owner")&&(i.owner={link:!0,username:!0,name:!0},i.ownedBySelf=!0),t.includes("madeFor")&&(i.madeFor={link:!0,username:!0,name:!0}),t.includes("published")&&(i.published=!0),t.includes("collaborative")&&(i.collaborative=!0),t.includes("allows")&&(i.allows={insert:!0,remove:!0}),0!==Object.keys(i).length&&_playlistUtils2.default.subscribeToMetadata(e.uri,i,(i,l={})=>{i?console.error(i):(l&&"picture"in l&&(l.image=l.picture,delete l.picture),l&&"pictureFromAnnotate"in l&&(l.annotatedImage=l.pictureFromAnnotate&&l.image||null,delete l.pictureFromAnnotate),l&&"offline"in l&&(l.offlineStatus=l.offline,l.shouldBeOffline=(0,_offlineStatus.shouldBeOffline)(l.offline),delete l.offline),t.includes("formatListType")&&(l.formatListType=l.formatListType||"playlist"),"owner"in l&&"link"in l.owner&&(l.owner.uri=l.owner.link),"madeFor"in l&&"link"in l.madeFor&&(l.madeFor.uri=l.madeFor.link),"ownedBySelf"in l&&"owner"in l&&(l.owner.currentUser=l.ownedBySelf),l&&"allows"in l&&(l.allows={insertTracks:l.allows.insert,removeTracks:l.allows.remove}),e.update(l))})}function onHeart(e,t){const i=_playlistUtils2.default.formatListUtils.originalPlaylistUri(e.get("uri"));(0,_live2.default)(i).get("formatListAttributes",function(e,l){if(e)return void console.error(e);"1"===l.get("like-feedback-available")&&(0,_messageProxy.messageProxy)({method:"POST",uri:"format-list-heart",body:{entityUri:i,trackUri:t}});const a=_playlistUtils2.default.formatListUtils.makeFeedbackUri(i,t);(0,_live2.default)(a).update({thumb:"up"})})}function onUndoFeedback(e,t){const i=_playlistUtils2.default.formatListUtils.originalPlaylistUri(e.get("uri"));(0,_live2.default)(i).get("formatListAttributes",function(e,l){if(e)console.error(e);else if("1"===l.get("like-feedback-available")){(0,_messageProxy.messageProxy)({method:"POST",uri:"format-list-undo-feedback",body:{entityUri:i,trackUri:t}});const e=_playlistUtils2.default.formatListUtils.makeFeedbackUri(i,t);(0,_live2.default)(e).update({thumb:null})}})}const matches=exports.matches=/^spotify:(user:[^:]+:)?playlist:[^:]+$/;let broadcastSubscriptionCancel,registered;exports.register=function(){registered||(registered=!0,_live2.default.subscribe(matches,"wait",onWait),_live2.default.subscribe(matches,"heart",onHeart),_live2.default.subscribe(matches,"undo-heart",onUndoFeedback),_live2.default.subscribe(matches,"undo-ban",onUndoFeedback),broadcastSubscriptionCancel=(0,_bridge.cosmosJSON)({method:"SUB",uri:"sp://messages/v1/playliststate"},onBroadcast))},exports.unregister=function(){registered&&(registered=!1,_live2.default.unsubscribe(matches,"wait",onWait),broadcastSubscriptionCancel(),broadcastSubscriptionCancel=null)};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../bridge":50,"../live":148,"../message-proxy":165,"../playlist-utils":180,"../playlist-utils/offline-status":181}],123:[function(require,module,exports){
(function (global){
"use strict";const forOwn=require("mout/object/forOwn"),combine=require("mout/array/combine"),remove=require("mout/array/remove"),contains=require("mout/array/contains"),URI="spotify:session-storage",live=require("../live"),cosmos=require("./util/cosmos"),endpoints={broadcast:"sp://messages/v1/session-storage"};let broadcastSubscription,waiting=[];function onInit(e){e.update({implemented:!0})}function onWait(e,s){waiting=combine(waiting,s),global.top.postMessage({type:"session_storage",name:"broadcast_session_storage",data:s},"*")}function onPublish(e,s){global.top.postMessage({type:"session_storage",name:"set_session_storage",data:s},"*"),e.update(s)}function onBroadcast(e,s){if(e)return void console.error(e);const i={},t=live(URI);forOwn(s.body,function(e,s){const o=contains(waiting,s),n=void 0!==t.get(s);(o||n)&&(i[s]=e),o&&remove(waiting,s)}),t.update(i)}const regExp=exports.matches=new RegExp(`^${URI}$`);let registered;exports.register=function(){registered||(registered=!0,live.subscribe(regExp,"init",onInit),live.subscribe(regExp,"wait",onWait),live.subscribe(regExp,"publish",onPublish),broadcastSubscription=cosmos.subscribe({url:endpoints.broadcast},onBroadcast))},exports.unregister=function(){registered&&(registered=!1,live.unsubscribe(regExp,"init",onInit),live.unsubscribe(regExp,"wait",onWait),live.unsubscribe(regExp,"publish",onPublish),broadcastSubscription&&(broadcastSubscription.cancel(),broadcastSubscription=null),waiting.length=0)},exports._endpoints=endpoints;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../live":148,"./util/cosmos":143,"mout/array/combine":385,"mout/array/contains":386,"mout/array/remove":395,"mout/object/forOwn":420}],124:[function(require,module,exports){
"use strict";var _live=require("../live"),_live2=_interopRequireDefault(_live),_cosmos=require("./util/cosmos"),_cosmos2=_interopRequireDefault(_cosmos),_spotifyLiburi=require("spotify-liburi"),_spotifyLiburi2=_interopRequireDefault(_spotifyLiburi),_liveWrappedUri=require("../live-wrapped-uri"),_liveWrappedUri2=_interopRequireDefault(_liveWrappedUri);function _interopRequireDefault(e){return e&&e.__esModule?e:{default:e}}const regExp=exports.matches=/^spotify:((internal:sortlist:(asc|desc):([^:]*):(internal:filterlist:[^:]*):)|(internal:sortlist:(asc|desc):([^:]*):)|(internal:filterlist:[^:]*):)?show:[^:]+$/;let registered;const subscribingForUris=[];function onWait(e,r){if(!r.includes("show")&&!r.includes("rows"))return;if(subscribingForUris.includes(e.uri))return;subscribingForUris.push(e.uri);let i=e.uri,t="",s="number,publishDate,name";const u=_liveWrappedUri2.default.parse(e.uri);u&&(i=u.originUri,u.sort&&u.sort.query&&(s=sortToString(u.sort)),u.filter&&u.filter.query&&(t=filterQueryToString(u.filter.query)));const o=_spotifyLiburi2.default.from(i).getBase62Id();_cosmos2.default.subscribe({url:`sp://core-show/unstable/show/${o}?filter=available eq true${t}&sort=${s}`},(r,i)=>{if(r)throw r;const{show:t,items:s}=i.body;t.uri=t.link,s.forEach(e=>{e.uri=e.link,e.show.uri=e.show.link}),e.update({show:t,rows:s.map(e=>({track:e})),lastUpdateTimestamp:Date.now()})})}function sortToString(e){const r=e.direction.toUpperCase();let i="number,publishDate,name";switch(e.query){case"track(name)":i=`name ${r}`;break;case"track(duration)":i=`length ${r}`;break;case"track(timeLeft)":i=`progress ${r}`;break;case"timeSinceAdded,track(album(name),disc,number)":i=`number ${r},publishDate ${r},name ${r}`;break;default:console.error("Invalid query",e.query)}return i}function filterQueryToString(e){return e.length>0?`,${e}`:""}exports.register=(()=>{registered||(registered=!0,subscribingForUris.length=0,_live2.default.subscribe(regExp,"wait",onWait))}),exports.unregister=(()=>{registered&&(registered=!1,subscribingForUris.length=0,_live2.default.unsubscribe(regExp,"wait",onWait))});

},{"../live":148,"../live-wrapped-uri":147,"./util/cosmos":143,"spotify-liburi":450}],125:[function(require,module,exports){
"use strict";module.exports=function(t,n=50){return function(t,n=2){const e=[];if(null===t)return e;const l=Math.floor(t.length/n),o=t.length%n;let r=0;const u=t.length;let c,s=0;for(;r<u;)c=l,s<o&&c++,e.push(t.slice(r,r+c)),s++,r+=c;return e}(t,Math.ceil(t.length/n))};

},{}],126:[function(require,module,exports){
"use strict";exports.legacyQueries={"track(album(name))":"track(album(name),disc,number)","track(artists(name))":"track(artists[0:1](name),album(name),disc,number)","track(addedBy)":"addedBy(name)","track(addedBy(name))":"addedBy(name)",timeSinceAdded:"timeSinceAdded,track(album(name),disc,number)"};

},{}],127:[function(require,module,exports){
"use strict";module.exports=function s(t,e,o,i){const l={items:e[o],id:i};o===e.length-1&&(l.last=!0),t.postMessage(l),l.last||s(t,e,o+1,i)};

},{}],128:[function(require,module,exports){
(function (global){
"use strict";const chunker=require("./chunker"),poster=require("./poster"),sorter=require("./sorter"),sortWorker=require("./sortworker"),defer=require("../../../libs/prime/defer");let workerFile;const workers={},callbacks={},waitingForReset={};let idCounter=0;const lastIds={};function localSorter(e,r,t){const o=sorter(r);callbacks[e]=t,defer.immediate(function(){t===callbacks[e]&&(delete callbacks[e],t(null,o))})}function workerSorter(e,r,t){let o=workers[e];if(o){callbacks[e]=t,waitingForReset[e]=(waitingForReset[e]||0)+1;const s=(++idCounter).toString(36);return lastIds[e]=s,o.postMessage({reset:!0,newId:s}),void sendItemsToWorker(r,o,s)}o=new Worker(workerFile),workers[e]=o,callbacks[e]=t;const s=(++idCounter).toString(36);lastIds[e]=s,sendItemsToWorker(r,o,s);const n={items:[]};o.addEventListener("message",function(r){onWorkerMessage(r,n,e)},!1)}function onWorkerMessage(e,r,t){if(e.data.reset)return waitingForReset[t]--,void(r.items.length=0);if(e.data.id===lastIds[t]&&!waitingForReset[t]&&(r.items=r.items.concat(e.data.items),e.data.last)){workers[t].terminate();const e=callbacks[t];delete callbacks[t],delete workers[t],e(null,r.items)}}function createWorkerFile(){const e=`(${sortWorker.toString()})(${[sorter.toString(),chunker.toString(),poster.toString()].join(", ")})`,r=new Blob([e],{type:"text/javascript"});return URL.createObjectURL(r)}function sendItemsToWorker(e,r,t){const o=chunker(e);poster(r,o,0,t)}function getSorter(){return global.Worker&&global.Blob&&global.URL?(workerFile||(workerFile=createWorkerFile()),workerSorter):localSorter}module.exports=function(e,r,t){getSorter()(e,r,t)};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../../libs/prime/defer":185,"./chunker":125,"./poster":127,"./sorter":129,"./sortworker":130}],129:[function(require,module,exports){
"use strict";module.exports=function(r){return r.sort(function(r,t){const e=r.data.length;for(let n=0;n<e;n++){const e=r.data[n],a=t.data[n],i=parseInt(e,10),o=parseInt(a,10),s=!isNaN(i),u=!isNaN(o);if(s&&u){if(i<o)return-1;if(i>o)return 1}else{if(s)return-1;if(u)return 1}if(e.localeCompare){const r=e.localeCompare(a);if(0!==r)return r}else{if(e<a)return-1;if(e>a)return 1}}return-1}),r};

},{}],130:[function(require,module,exports){
"use strict";module.exports=function(t,e,a,s){const n=s||self;let d=[],i=null;n.addEventListener("message",function(s){if(s.data.reset)return d.length=0,i=s.data.newId,void n.postMessage({reset:!0,newId:i});if(null===i&&(i=s.data.id),i===s.data.id&&(d=d.concat(s.data.items),s.data.last)){const s=t(d),l=e(s);a(n,l,0,i)}},!1)};

},{}],131:[function(require,module,exports){
"use strict";function getValues(e,t){let n=[];return e.forEach(function(e){const s=e.key,r=t[s];if(Array.isArray(r))if(e.mask){let t=[];for(let n=0,s=r.length;n<s;n++)t=t.concat(getValues(e.mask,r[n]));n.push(t.join(", "))}else n.push(r.join(", "));else e.mask?n.push.apply(n,getValues(e.mask,r)):n.push(r)}),n=sanitizeStrings(n)}function sanitizeStrings(e){const t=/\b[0-9]+\b/g,n="000000";return e.map(function(e){if("string"!=typeof e)return e;let s=e.toLowerCase();const r=["the ","(the) "];for(let e=0;e<r.length;e++){const t=r[e];if(0===s.indexOf(t)){s=s.replace(t,"");break}}return(s=s.replace(t,function(e){return e.length>=n.length?e:n.substr(0,n.length-e.length)+e})).trim()})}module.exports=getValues;

},{}],132:[function(require,module,exports){
(function (global){
"use strict";const live=require("../live"),mixIn=require("mout/object/mixIn"),parse=require("../live/util/parser"),sortUriUtils=require("../live-sort-uri"),listOperations=require("../live-list-operations"),sort=require("./sorting/sort"),getValues=require("./sorting/values");let idCounter=0;const lastIds={};function onInit(e){const t=getTrackingModel(e.uri);lastIds[e.uri]=(++idCounter).toString(36),t.on("update",function(t){const r=mixIn({},t);delete r.rows,e.update(r)}),e.on("publish",function(e){const r=mixIn({},e);delete r.rows,t.publish(r)})}function onWait(e,t){const r=getTrackingModel(e.uri);t.forEach(function(t){"rows"===t?setRowsProperty(e,r):r.get(t,function(r,o){if(r)return void(global.console&&console.error(r));const s={};s[t]=o,e.update(s)})})}function setRowsProperty(e,t){const r=sortUriUtils.parse(e.uri),o=r.direction,s=r.query;performRowSorting(t,e,s,o),e.get("rows",function(e,r){e?global.console&&console.error(e):r.on("publish",function(e){const r=t.get("rows");r&&syncRows(r,e,"publish")})}),t.get("rows",function(r,n){r?global.console&&console.error(r):n.on("update",function(r){const n=e.get("rows");n&&syncRows(n,r,"update")&&performRowSorting(t,e,s,o)})})}function getTrackingModel(e){const t=sortUriUtils.parse(e),r=t.direction,o=t.originUri,s=t.query;return live("desc"===r?sortUriUtils.create(o,"asc",s):o)}function getSortData(e,t,r){return e.map(function(e,o){const s=getValues(t,e);return s.push(o),{data:s,key:r.keys[o]}})}function performRowSorting(e,t,r,o){lastIds[t.uri]=(++idCounter).toString(36);const s=lastIds[t.uri];e.get("rows",function(e,n){if(e)return void(global.console&&console.error(e));const i=[],u=[];for(let e=0,t=n.length;e<t;e++)n.get(e)&&(i.push(n.get(e)),u.push(n.keys[e]));if(0===i.length){const e=t.get("rows");return void(e?e.update([{type:"remove",index:0,length:e.length}]):t.update({rows:[]}))}const l=live([]);l.update([{type:"insert",index:0,values:i,keys:u}]),l.query(r,function(e,n){if(e)global.console&&console.error(e);else if("desc"===o)updateListWithReversedData(t,l);else{const e=getSortData(n,parse(r).mask,l);sort(t.uri,e,function(e,r){e?global.console&&console.error(e):lastIds[t.uri]===s&&updateListWithSortedData(t,l,r)})}})})}function updateListWithSortedData(e,t,r){let o=e.get("rows");o||(o=new live.List,e.update({rows:o}));const s=r.length,n=new Array(s),i=new Array(s);for(let e=0,o=r.length;e<o;e++)n[e]=r[e].key,i[e]=t.valueOf(n[e]);o.update([{type:"remove",index:0,length:o.length},{type:"insert",index:0,keys:n,values:i}])}function updateListWithReversedData(e,t){let r=e.get("rows");r||(r=new live.List,e.update({rows:r})),r.update([{type:"remove",index:0,length:r.length},{type:"insert",index:0,length:t.length,values:t.values.slice().reverse(),keys:t.keys.slice().reverse()}])}function syncRows(e,t,r){let o=!1;return t.forEach(function(t){let s=[];switch(t.type){case"remove":s=convertRemoveOperationForList(e,t);break;case"insert":s=[{type:"insert",index:0,values:t.values,keys:t.keys}],o=!0;break;case"move":o=!0;break;default:console.error("Invalid operation type",t.type)}"publish"===r?e.publish(s):"update"===r&&e.update(s)}),o}function convertRemoveOperationForList(e,t){const r=[],o=t.keys;return e.keys.forEach(function(e,t){o.indexOf(e)>-1&&r.push(t)}),listOperations.getRemoveOperations(r)}const regExp=exports.matches=/^spotify:internal:sortlist:(asc|desc):([^:]*):(.*)$/;let registered=!1;exports.register=function(){registered||(registered=!0,live.subscribe(regExp,"init",onInit),live.subscribe(regExp,"wait",onWait))},exports.unregister=function(){registered&&(registered=!1,live.unsubscribe(regExp,"init",onInit),live.unsubscribe(regExp,"wait",onWait))};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../live":148,"../live-list-operations":93,"../live-sort-uri":146,"../live/util/parser":151,"./sorting/sort":128,"./sorting/values":131,"mout/object/mixIn":423}],133:[function(require,module,exports){
"use strict";var _messageProxy=require("../../libs/message-proxy");const live=require("../live"),trackToRow=require("./station/track-to-row"),contains=require("mout/array/contains"),spotifyURI=require("spotify-liburi"),thumbActions=require("./station/thumb-actions"),URI=exports.URI="spotify:station:",idRegexStr="[a-zA-Z0-9]{22}",dailyMixPrefix=exports.dailyMixPrefix="spotify:dailymix",dailyMixRegexStr=`${dailyMixPrefix}:[^:]*`,regExp=exports.matches=new RegExp(`^(?:${URI}(.*)|(?:${dailyMixRegexStr}))`),isStationUri=exports.isStationUri=regExp.test.bind(regExp),clusterRegExp=new RegExp(`^${URI}((user:[^:]+:cluster:${idRegexStr}))`),isClusterStationUri=exports.isClusterStationUri=regExp.test.bind(clusterRegExp),dailyMixRegExp=new RegExp(`^${dailyMixRegexStr}`),isDailyMixUri=exports.isDailyMixUri=(t=>dailyMixRegExp.test(t));exports.isOrdinaryRadioUri=(t=>isStationUri(t)&&!(isClusterStationUri(t)||isDailyMixUri(t)));const DEFAULT_FETCH_COUNT=15,PLAYLIST="playlist",TRACK="track",ALBUM="album",ARTIST="artist",GENRE="genre",CLUSTER="cluster",DAILY_MIX="dailymix",UNKNOWN="unknown";let metadataUpdateUnsubscribe,registered=!1,trackingRows=[],trackingMetadata=[];function getBaseSeedFromUri(t){const e=t.uri.replace(/^spotify:station:/,"spotify:");return decodeURIComponent(e)}function getType(t){const e=spotifyURI.from(t);if(!e)return UNKNOWN;const i=e.type;return spotifyURI.isPlaylistV1OrV2(e)?PLAYLIST:i===spotifyURI.Type.ARTIST?ARTIST:i===spotifyURI.Type.ALBUM?ALBUM:i===spotifyURI.Type.TRACK?TRACK:0===t.indexOf("spotify:genre:")?GENRE:t.indexOf(":cluster:")>0?CLUSTER:t.startsWith(dailyMixPrefix)?DAILY_MIX:UNKNOWN}function onThumbUp(t,e){(0,_messageProxy.messageProxy)({method:"POST",uri:"station-thumb",body:{stationUri:t.get("uri"),trackUri:e,thumb:thumbActions.UP}})}function onThumbDown(t,e){(0,_messageProxy.messageProxy)({method:"POST",uri:"station-thumb",body:{stationUri:t.get("uri"),trackUri:e,thumb:thumbActions.DOWN}})}function onHeart(t,e){isStationUri(t.get("uri"))&&(0,_messageProxy.messageProxy)({method:"POST",uri:"station-heart",body:{stationUri:t.get("uri"),trackUri:e}})}function onUndoHeart(t,e){isStationUri(t.get("uri"))&&(0,_messageProxy.messageProxy)({method:"POST",uri:"station-undo-feedback",body:{stationUri:t.get("uri"),trackUri:e,thumbAction:thumbActions.UNDO_HEART}})}function requestStationData(t,e,i,r){const s=!!i&&(r||t.get("fetchCount"));(0,_messageProxy.messageProxy)({method:"GET",uri:"station",target:"top",body:{stationUri:t.get("uri"),metadata:e,trackCount:s}},function(e,i){if(e)return void(0,_messageProxy.messageProxy)({method:"POST",uri:"station-error",body:{stationUri:t.get("uri"),message:e}});const r=i.stationUri,s=i.station;if(s.hasOwnProperty("tracks")){if(-1!==trackingRows.indexOf(r)){const t=(new Date).getTime();s.rows=s.tracks.map(trackToRow.bind(null,t))}delete s.tracks}live(r).update(s)})}function onRowsWait(t,e){if(e&&e.length>0){let i=0,r=0;e.forEach(function(t){t.end>r&&(r=t.end)}),requestStationData(t,[],!0,i=r-t.get("rows").length)}}function onUpdateMetadata(t){const e=t.stationUri,i=t.metadata;if(-1!==trackingMetadata.indexOf(e)){if(i.hasOwnProperty("tracks")){if(-1!==trackingRows.indexOf(e)){const t=(new Date).getTime();i.rows=i.tracks.map(trackToRow.bind(null,t))}delete i.tracks}live(e).update(i)}}function onInit(t){const e=getBaseSeedFromUri(t);e&&(t.update({baseSeed:e,type:getType(e),fetchCount:DEFAULT_FETCH_COUNT}),t.on("update",function e(i){i.hasOwnProperty("rows")&&(t.get("rows").on("wait",onRowsWait.bind(null,t)),t.off("update",e))}),trackingMetadata.push(t.get("uri")))}function onPublish(t,e){if(e.hasOwnProperty("added")){const i=e.added;"boolean"==typeof i?(t.update({added:i}),(0,_messageProxy.messageProxy)({method:"POST",uri:"station-add",body:{stationUri:t.get("uri"),add:i}})):console.error("Added can only be a boolean")}}function onWait(t,e){let i,r=-1;const s=["added","name","subtitles","relatedArtists","image","nextPageUrl"];e.forEach(function(t,e){"rows"===t&&(r=e),!i&&contains(s,t)&&(i=!0)}),-1!==r?(trackingRows.push(t.get("uri")),e.splice(r,1),requestStationData(t,e,!0)):i&&requestStationData(t,e)}exports.register=function(){registered||(registered=!0,live.subscribe(regExp,"wait",onWait),live.subscribe(regExp,"init",onInit),live.subscribe(regExp,"thumb-up",onThumbUp),live.subscribe(regExp,"thumb-down",onThumbDown),live.subscribe(regExp,"heart",onHeart),live.subscribe(regExp,"undo-heart",onUndoHeart),live.subscribe(regExp,"publish",onPublish),metadataUpdateUnsubscribe=(0,_messageProxy.messageProxy)({method:"SUB",uri:"station-metadata"},onUpdateMetadata))},exports.unregister=function(){registered&&(registered=!1,live.unsubscribe(regExp,"wait",onWait),live.unsubscribe(regExp,"init",onInit),live.unsubscribe(regExp,"thumb-up",onThumbUp),live.unsubscribe(regExp,"thumb-down",onThumbDown),live.unsubscribe(regExp,"heart",onHeart),live.unsubscribe(regExp,"publish",onPublish),metadataUpdateUnsubscribe(),trackingRows=[],trackingMetadata=[])};

},{"../../libs/message-proxy":165,"../live":148,"./station/thumb-actions":137,"./station/track-to-row":138,"mout/array/contains":386,"spotify-liburi":450}],134:[function(require,module,exports){
"use strict";const rowToPlayerTrack=require("./row-to-player-track"),PLAYER_RESTRICTIONS={disallow_toggling_repeat_context_reasons:["disallow-radio"],disallow_toggling_repeat_track_reasons:["disallow-radio"],disallow_toggling_shuffle_reasons:["disallow-radio"]};function createPlayerTracks(e){const r=e.get("rows");return r?r.values.map(rowToPlayerTrack):[]}module.exports=function(e){return{entity_uri:e.get("uri"),pages:[{tracks:createPlayerTracks(e),next_page_url:e.get("nextPageUrl")}],metadata:{context_description:e.get("name")},restrictions:PLAYER_RESTRICTIONS}};

},{"./row-to-player-track":136}],135:[function(require,module,exports){
"use strict";const PLAYER_OPTIONS={shuffling_context:!1,repeating_context:!1,repeating_track:!1};function getLastIndex(e){const t=e.get("rows"),n=e.get("currentTrackUid");if(!t||!n)return 0;let r;return t.values.some(function(e,t){return e.get("uid")===n&&(r=t,!0)})?r:0}module.exports=function(e,t){let n;const r={skip_to_index:{page:0,track:n=t&&(t.index||0===t.index)?t.index:getLastIndex(e)},player_options_override:PLAYER_OPTIONS};return t&&t.uid&&(r.uid=t.uid),r};

},{}],136:[function(require,module,exports){
"use strict";module.exports=function(t){return{uid:t.get("uid"),uri:t.get("track").get("uri"),album_uri:t.get("track").get("albumUri"),artist_uri:t.get("track").get("artistUri"),metadata:{image_url:t.get("track").get("image"),"radio.thumb":t.get("track").get("thumb")}}};

},{}],137:[function(require,module,exports){
"use strict";module.exports={UP:"ups",DOWN:"downs",UNDO_HEART:"undo-heart",UNDO_BAN_ARTIST:"undo-ban-artist",UNDO_BAN_TRACK:"undo-ban-track"};

},{}],138:[function(require,module,exports){
"use strict";function transformArtists(t){const r=[];for(let i=0;;i++){const a=i>0?`:${i}`:"",u=t[`artist_uri${a}`],e=t[`artist_name${a}`];if(!u||!e)break;r.push({uri:u,name:e})}return r}module.exports=function(t,r,i){const a=r.metadata||{},u=r.album_uri||a.album_uri;let e=r.uid;if(!r.uid){e=t+r.uri.replace("spotify:track:","")+i}return{uid:e,uri:e,track:{uri:r.uri,name:a.title,image:a.image_url,albumUri:u,artists:transformArtists(r.metadata),album:{name:a.album_title,uri:u},thumb:a["radio.thumb"]||""}}};

},{}],139:[function(require,module,exports){
(function (global){
"use strict";const live=require("../live"),liburi=require("spotify-liburi"),intersection=require("mout/array/intersection"),contains=require("mout/array/contains"),bridge=require("./util/bridge").request,cosmos=require("./util/cosmos"),util=require("./util/common"),BACKOFF=100;let localFilesRequest=null;const metaFields=["album","artists","availability","disc","duration","explicit","image","local","name","number","placeholder","playable","linkedTrack"];function onWait(e,i){contains(i,"unavailable")&&e.get("playable",function(i,a){i?global.console&&console.error(i):e.update({unavailable:!a})}),!!intersection(i,metaFields).length&&updateMetadata(e);const a=contains(i,"shouldBeOffline"),t=contains(i,"offlineProgress");(a||t)&&updateOffline(e)}function updateMetadata(e){bridge("track_metadata",[e.uri],function(i,a){i?global.console&&console.error(i):(util.setLocalProperties(a),a.image=largestImage(a),a.linkedTrack?a.linkedTrack={uri:a.linkedTrack}:a.linkedTrack=null,e.update(a))})}function largestImage(e){let i,a=e.image;if(e.images)for(let t=0;t<e.images.length;t++){const o=e.images[t];(!i||o[0]>i)&&(i=o[0],a=o[1])}return a}function updateOffline(e){liburi.fromString(e.uri).type!==liburi.Type.LOCAL?cosmos.subscribe({url:`sp://offline/v1/resources?uri=${e.uri}`},function(i,a){if(i){const a=i.response&&i.response.getStatusCode();if(-104!==a&&404!==a)return void(global.console&&console.error(i));updateModelWithOfflineData(e,{offline_availability:"no"})}else{const i=a.body.resources;updateModelWithOfflineData(e,i)}}):e.get("playable",function(i,a){i?global.console&&console.error(i):e.update({shouldBeOffline:a,offlineProgress:a?1:0})})}function updateModelWithOfflineData(e,i){let a=!1,t=0;switch(i.offline_availability){case"waiting":a=!0,t=0;break;case"downloading":a=!0,t=.5;break;case"yes":a=!0,t=1;break;case"no":a=!1,t=0;break;default:console.error("Unexpected resource.offline_availability",i.offline_availability)}e.update({shouldBeOffline:a,offlineProgress:t})}let registered;function waitForLocalFilesChange(){localFilesRequest=cosmos.subscribe({url:"sp://local-files/v1/changes"},function(e,i){if(!registered)return;if(e){const i=e.response&&e.response.getStatusCode();if(-104===i||404===i)return;return void(global.console&&console.error(e))}const a=i.body,t=a.data,o=a.type,l="added"===o;(l||"removed"===o)&&t.tracks.forEach(function(e){live(e.uri).update({shouldBeOffline:l,offlineProgress:l?1:0,playable:l})})})}function waitForTrackChange(){bridge("track_event_wait_any",[],function(e,i){if(registered){if(e)return setTimeout(function(){waitForTrackChange()},BACKOFF),void(global.console&&console.error(e));waitForTrackChange(),"change"===i.type&&(void 0!==i.data.playable&&(i.data.unavailable=!i.data.playable),live(i.data.uri).update(i.data))}})}const regExp=exports.matches=/^spotify:track:|^spotify:local:[^:]*:[^:]*:[^:]*:\d*$/;exports.register=function(){registered||(registered=!0,live.subscribe(regExp,"wait",onWait),waitForLocalFilesChange(),global._getSpotifyModule&&waitForTrackChange())},exports.unregister=function(){registered&&(registered=!1,live.unsubscribe(regExp,"wait",onWait),localFilesRequest&&(localFilesRequest.cancel(),localFilesRequest=null))};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../live":148,"./util/bridge":141,"./util/common":142,"./util/cosmos":143,"mout/array/contains":386,"mout/array/intersection":393,"spotify-liburi":450}],140:[function(require,module,exports){
(function (global){
"use strict";const live=require("../live"),liburi=require("spotify-liburi"),contains=require("mout/array/contains"),intersection=require("mout/array/intersection"),bridge=require("./util/bridge").request;function updateMetadata(e){bridge("user_metadata",[e.uri],function(r,i={}){r&&global.console&&console.error(r),i.username=i.username||liburi.from(e.uri).username,i.name=i.name||i.username,i.image=i.image||"",i.images=i.images||[],i.subscribed||(i.subscribed=!1),i.currentUser||live("spotify:client").query("currentUser(uri)",function(r,i){r?global.console&&console.error(r):e.update({currentUser:e.uri===i.currentUser.uri})}),e.update(i)})}function updateArtist(e){bridge("user_associated_artist",[e.uri],function(r,i){if(r)return void(global.console&&console.error(r));const t=i.artist?{uri:i.artist}:null;e.update({artist:t})})}function onWait(e,r){const i=contains(r,"artist");!!intersection(r,["currentUser","name","username","image","images","subscribed"]).length&&updateMetadata(e),i&&updateArtist(e)}const regExp=exports.matches=/^spotify:user:[^:]+$/;let registered;exports.register=function(){registered||(registered=!0,live.subscribe(regExp,"wait",onWait))},exports.unregister=function(){registered&&(registered=!1,live.unsubscribe(regExp,"wait",onWait))};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../live":148,"./util/bridge":141,"mout/array/contains":386,"mout/array/intersection":393,"spotify-liburi":450}],141:[function(require,module,exports){
"use strict";const bridge=require("../../bridge");module.exports={request:bridge.request};

},{"../../bridge":50}],142:[function(require,module,exports){
"use strict";const liburi=require("spotify-liburi");function setLocalProperties(i){if(i.album&&i.album.uri){const r=liburi.from(i.album.uri).type;i.album.local=r===liburi.Type.LOCAL_ALBUM}if(i.artists)for(let r=0,t=i.artists.length;r<t;r++){const t=i.artists[r];if(t.uri){const i=liburi.from(t.uri).type;t.local=i===liburi.Type.LOCAL_ARTIST}}}module.exports={setLocalProperties:setLocalProperties};

},{"spotify-liburi":450}],143:[function(require,module,exports){
(function (global){
"use strict";const cosmos=require("../../cosmos-api").default;function DELETE(e,t){return e.method=exports.cosmos.Action.DELETE,request(e,t)}function GET(e,t){return e.method=exports.cosmos.Action.GET,request(e,t)}function SUB(e,t){return e.method=exports.cosmos.Action.SUB,request(e,t)}function POST(e,t){return e.method=exports.cosmos.Action.POST,request(e,t)}function PUT(e,t){return e.method=exports.cosmos.Action.PUT,request(e,t)}function HEAD(e,t){return e.method=exports.cosmos.Action.HEAD,request(e,t)}function request(e,t){const o=e.method;let s,n;return delete e.method,sanitizeURL(e.url,function(r,c){if(r)t&&t(r);else if(!n){const n=new exports.cosmos.Request(o||exports.cosmos.Action.GET,c,e.headers,e.body);s=exports.cosmos.resolver.resolve(n,function(e,o){if(t)if(t&&e)t(e);else try{t(null,{body:JSON.parse(o.getBody()||"{}"),headers:o.getHeaders(),status:o.getStatusCode()})}catch(e){e.response=o,t(e)}})}}),{cancel:function(){return s&&s.cancel?(s.cancel(),s=null):n||(n=!0),null}}}function sanitizeURL(e,t){e.indexOf("@")>-1?t(null,e.replace("@",encodeURIComponent(global.__spotify.username))):t(null,e)}exports.request=request,exports.get=GET,exports.post=POST,exports.subscribe=SUB,exports.delete=DELETE,exports.put=PUT,exports.head=HEAD,exports.cosmos=cosmos,exports.sanitizeURL=sanitizeURL;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../cosmos-api":54}],144:[function(require,module,exports){
(function (global){
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=(()=>global.location.href);

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],145:[function(require,module,exports){
"use strict";const Preferences=require("../../preferences");function subscribe(e){return new Preferences("ui").subscribe("show_unplayable_tracks",function(r,s){r?e(r):e(null,!!s)})}exports.subscribe=subscribe;

},{"../../preferences":184}],146:[function(require,module,exports){
"use strict";const base="spotify:internal:sortlist",regExp=/^spotify:internal:sortlist:(asc|desc):([^:]*):(.*)$/;exports.create=function(t,e,r){const n=t.replace(/^spotify:/,""),o=encodeURIComponent(r).replace(/%20/g,"");return[base,e,o,n].join(":")},exports.getDirection=function(t){const e=t.match(regExp);return e?e[1]:""},exports.getQuery=function(t){const e=t.match(regExp);return e?decodeURIComponent(e[2]):""},exports.getOriginUri=function(t){const e=t.match(regExp);return e?`spotify:${e[3]}`:""},exports.parse=function(t){const e=t.match(regExp);return e?{direction:e[1],query:decodeURIComponent(e[2]),originUri:`spotify:${e[3]}`}:null},exports.isValid=function(t){return regExp.test(t)},exports.regExp=regExp;

},{}],147:[function(require,module,exports){
"use strict";const sortUriUtils=require("../live-sort-uri"),filterUriUtils=require("../live-filter-uri");exports.create=function(r){let i=r.originUri;return r.filter&&(i=filterUriUtils.create(i,r.filter.query)),r.sort&&(i=sortUriUtils.create(i,r.sort.direction,r.sort.query)),i},exports.getOriginUri=function(r){const i=exports.parse(r);return i&&i.originUri||""},exports.parse=function(r){const i=sortUriUtils.parse(r),t=filterUriUtils.parse(i&&i.originUri||r);return i||t?{originUri:t&&t.originUri||i&&i.originUri,sort:i,filter:t}:null},exports.isValid=function(r){return!!exports.parse(r)};

},{"../live-filter-uri":92,"../live-sort-uri":146}],148:[function(require,module,exports){
(function (global){
"use strict";const prime=require("../../libs/prime"),defer=require("../../libs/prime/defer"),Emitter=require("../../libs/prime/emitter"),isPlainObject=require("mout/lang/isPlainObject"),isRegExp=require("mout/lang/isRegExp"),isNumber=function(e){return"number"==typeof e},isString=function(e){return"string"==typeof e},escapeRegExp=require("mout/string/escapeRegExp"),_difference=require("mout/array/difference"),filter=require("mout/array/filter"),combine=require("mout/array/combine"),map=require("mout/array/map"),deepMixIn=require("mout/object/deepMixIn"),pick=require("mout/object/pick");function parallel(e,t){const i=[];let n=e.length;n?e.forEach((e,r)=>{e((e,s)=>{i[r]=s,(0==--n||e)&&t(e,i)})}):t(null,i)}const OrderedSet=require("./util/ordered-set"),Range=require("../range2"),parse=require("./util/parser"),throttle=require("./util/throttle"),debug=require("../debug")("live"),isLiveList=function(e){return e instanceof LiveList},isLiveObject=function(e){return e instanceof LiveObject},simpleClone=function(e){return Object.assign({},e)},difference=function(e,t){return 0===e.length?[]:_difference.call(this,e,t)},values=function(e,t){const i=[];let n;for(let r=0,s=t.length;r<s;r++)(n=t[r])in e?i.push(e[n]):i.length++;return i},rdifference=function(e,t){if(!e.length)return[];let i=[];for(let n=0,r=e.length;n<r;n++){const r=e[n];i=i.concat(r.subtract(t))}return i=new Range(0,0).merge(i),i=filter(i,function(e){return!!e.length})},rcombine=function(e,t){let i=t;for(let t=0,n=e.length;t<n;t++){i=e[t].merge(i)}return i};let IDX=0;const slice_=Array.prototype.slice,transform=function(e,t){return isPlainObject(e)?"operations"in e?(new LiveList).update(e.operations):live(e.uri)._update(e,t):Array.isArray(e)?(new LiveList)._update([{type:"insert",index:0,length:e.length,values:e}],t):e};function createTimedCallback(e,t){let i;const n=setTimeout(function(){i=!0,e(new Error(`Timeout Expired: ${t} milliseconds`))},t);return function(){i||(clearTimeout(n),e.apply(this,arguments))}}const LiveList=prime({mixin:Emitter,constructor:function(e){this._data=new OrderedSet(e),this._mergeThrottled=throttle(this._merge,this),this._waiting=[];let t="";live.debug&&setInterval(()=>{const e=this._waiting.toString();t!==e&&(t=e,this._waiting.length?debug(this,"waiting for",this._waiting):debug(this,"all done"))},2e3)},get index(){return this._data.index},get length(){return this._data.length},get keys(){return this._data.keys},get values(){return this._data.values},indexOf:function(e){return this._data.indexOf(e)},indexOfMany:function(e){return this._data.indexOfMany(e)},valueOf:function(e){return this._data.valueOf(e)},hasKey:function(e){return this._data.hasKey(e)},forEach:function(e,t){return this._data.forEach(e,t),this},map:function(e,t){return this._data.map(e,t)},_merge:function(){const e=this._data,t=this._publish,i=this._before;if(t){if(delete this._publish,this._listeners&&this._listeners.publish){const i=e.diff(t);i.length&&this.emit("publish",i,EMIT_SYNC)}}else if(i&&(delete this._before,this._listeners&&this._listeners.update)){const t=i.diff(e);t.length&&this.emit("update",t,EMIT_SYNC)}return this},_update:function(e,t){let i,n;if(t===PUBLISH){if(this._before)return this;i=this._publish||(this._publish=this._data.clone())}else t===UPDATE&&(this._publish&&delete this._publish,this._before||(this._before=this._data.clone()),i=this._data);for(let r=0,s=e.length;r<s;r++){const s=[],l=(n=e[r]).keys||[];switch(n.type){case"length":i.length=n.length;break;case"sort":i.sort(n.compareFunction);break;case"move":i.move(n.from,n.to,n.length);break;case"remove":i.remove(n.index,n.length);break;case"insert":for(let e=0,i=n.values.length;e<i;e++)n.keys&&n.keys[e]||(l[e]=(IDX++).toString(36)),s[e]=transform(n.values[e],t);i.insert(n.index,l,s);break;default:console.error("Invalid operation type",n.type)}}return t===UPDATE&&(this._waiting=rdifference(this._waiting,this.index)),this._mergeThrottled(),this},publish:function(e){return this._update(e,PUBLISH)},update:function(e){return this._update(e,UPDATE)},serialize:function(e){if(0===e)return[];const t=[],i=void 0===e?void 0:e-1;for(let e=0;e<this.length;e++){const n=this.values[e];let r=n;n&&n.serialize&&(r=n.serialize(i)),t.push(r)}return t},_getDataFromMask:function(e){const t=[];if(e.length>0)for(let i=0,n=this.length;i<n;i++){const n=this.get(i);let r;n&&n._getDataFromMask&&(r=n._getDataFromMask(e)),t.push(r)}return t},_query:function(e,t,i){const n=()=>{queryList(this,e,(n,r,s)=>{n?t(n):s?t(null,r):this._query(e,t,i)})};i===ASYNC?defer.immediate(n):n()},query:function(e,t,i,n,r){let s=t,l=i,u=n,a=r;return"function"==typeof s&&(a=u,u=l,l=s,s=[]),l?(u?isNumber(u)&&(a=u,u=ASYNC):u=ASYNC,a&&(l=createTimedCallback(l,a)),this._query(parse(e,s),l,u),this):this._getDataFromMask(parse(e,s).mask)},_wait:function(e){this._required||(this._required=[],defer.immediate(function(){const e=this.missing(this._required),t=rdifference(e,this._waiting);this._waiting=rcombine(this._waiting,t),delete this._required,t.length&&this.emit("wait",t,EMIT_SYNC)},this)),this._required=rcombine(this._required,e)},missing:function(e){return rdifference(e,this.index)},_get:function(e,t){if(this.missing(e).length){this._wait(e);const i=function(){this.missing(e).length||(this.off("update",i),t.call(this))};this.on("update",i)}else t.call(this,null,!0)},has:function(e,t){let i;return(i=new Range(e,void 0!==t?t:e+1)).contained(this.index)},get:function(e,t){if(1===arguments.length){if(isNumber(e))return this.values[e];if(isString(e))return this.valueOf(e)}const i=slice_.call(arguments);let n,r,s;for(let e=0,t=i.length;e<t;e++){if("function"==typeof i[e]){const s=i.splice(e,3);if(t=i.length,n=s[0],s[1]){if(s[1]!==SYNC&&s[1]!==ASYNC&&s[1]!==ASAP){r=ASYNC,n=createTimedCallback(n,s[1]);break}r=s[1],s[2]&&r!==SYNC&&(n=createTimedCallback(n,s[2]))}else r=ASYNC;break}}let l=!1,u=!1;if(e instanceof Range)s=i,l=!n&&s.length>1;else if(Array.isArray(e))l=!0,s=e;else{const i=!isNaN(t);s=i?[new Range(e,t)]:[new Range(e,e+1)],u=!i}const a=()=>map(s,e=>this.values.slice(e.start,e.end)),o=()=>{l?n.call(this,null,a()):u?n.call(this,null,this.values[e]):n.apply(this,[null].concat(a()))};return n?(r===SYNC?o():r!==ASYNC||this.missing(s).length?this._get(s,o):defer.immediate(function(){this._get(s,o)},this),this):l?a():a()[0]}}),LiveObject=prime({mixin:Emitter,constructor:function(e){this.uri=e,this._data={uri:e},this._mergeThrottled=throttle(this._merge,this),this.index=[],this._waiting=[],this.emit("init",EMIT_SYNC);let t="";live.debug&&setInterval(()=>{const e=this._waiting.toString();t!==e&&(t=e,this._waiting.length?debug(this,this._waiting):debug(this,"all done"))},2e3)},emit:function(){const e=this.uri;if(e){const t=emitters.keys,i=emitters.values;let n,r;for(let s=0,l=t.length;s<l;s++)if(n=t[s],e.match(n)){if(!r){r=new Array(arguments.length);for(let e=0;e<arguments.length;++e)r[e]=arguments[e];r.splice(1,0,this)}const e=i[s];e.emit.apply(e,r)}}Emitter.prototype.emit.apply(this,arguments)},_merge:function(){const e=this._data,t=this._before,i=this._publish;let n,r;if(i&&(delete this._publish,this.uri||this._listeners&&this._listeners.publish)){const t={};for(r in i)i.hasOwnProperty(r)&&(n=i[r],e[r]!==n&&(t[r]=n));Object.keys(t).length&&this.emit("publish",t,EMIT_SYNC)}if(t){delete this._before;const i={};if(this.uri||this._listeners&&this._listeners.update){for(r in e)e.hasOwnProperty(r)&&(n=e[r],r in t&&t[r]===n||(i[r]=n));for(r in t)t.hasOwnProperty(r)&&(n=t[r],r in e||(i[r]=void 0));Object.keys(i).length&&this.emit("update",i,EMIT_SYNC)}}return this},_update:function(e,t){let i,n;t===PUBLISH?i=this._publish||(this._publish=simpleClone(this._data)):t===UPDATE&&(this._before||(this._before=simpleClone(this._data)),i=this._data);for(const r in e){if(!e.hasOwnProperty(r))continue;n=e[r];const s=r in i?i[r]:void 0;if(isLiveList(s)){if(Array.isArray(n)){s._update([{type:"remove",index:0,length:s.length},{type:"insert",index:0,values:n}],t);continue}if(isPlainObject(n)&&"operations"in n){s._update(n.operations,t);continue}}t===UPDATE&&void 0===n?delete i[r]:i[r]=transform(n,t)}return t===UPDATE&&(this.index=Object.keys(i),this._waiting=difference(this._waiting,this.index)),this._mergeThrottled(),this},delete:function(e){const t={};return t[e]=void 0,this.update(t)},update:function(e){return this._update(e,UPDATE)},publish:function(e){return this._update(e,PUBLISH)},serialize:function(e){if(0===e)return{};const t={},i=this._data,n=void 0===e?void 0:e-1;for(const e in i){if(!i.hasOwnProperty(e))continue;const r=i[e];if(void 0===r)continue;let s=r;r&&r.serialize&&(s=r.serialize(n)),t[e]=s}return t},_getDataFromMask:function(e){const t={};for(let i=0,n=e.length;i<n;i++){const n=e[i],r=n.mask,s=n.key,l=this.get(s);let u=l;if(isLiveObject(l)&&(u={}),isLiveList(l)&&(u=[]),r)if(isLiveObject(l)){const e=l._getDataFromMask(r);deepMixIn(u,e)}else isLiveList(l)&&(u=l._getDataFromMask(r));t[s]=u}return t},_query:function(e,t,i){const n=()=>{queryObject(this,e,(n,r,s)=>{n?t.call(this,n):s?t.call(this,null,r):this._query(e,t,i)})};i===ASYNC?defer.immediate(n):n()},query:function(e,t,i,n,r){let s=t,l=i,u=n,a=r;return"function"==typeof s&&(a=u,u=l,l=s,s=[]),l?(u?isNumber(u)&&(a=u,u=ASYNC):u=ASYNC,a&&(l=createTimedCallback(l,a)),this._query(parse(e,s),l,u),this):this._getDataFromMask(parse(e,s).mask)},_wait:function(e){this._required||(this._required=[],defer.immediate(function(){const e=this.missing(this._required),t=difference(e,this._waiting);this._waiting=combine(this._waiting,t),delete this._required,t.length&&this.emit("wait",t,EMIT_SYNC)},this)),this._required=combine(this._required,e)},missing:function(e){return difference(e,this.index)},has:function(e){return this.index.indexOf(e)>-1},_get:function(e,t){if(this.missing(e).length){this._wait(e);const i=function(){this.missing(e).length||(this.off("update",i),t.call(this))};this.on("update",i)}else t.call(this,null,!0)},get:function(e){const t=this._data;if(1===arguments.length&&isString(e))return t[e];const i=slice_.call(arguments);let n,r,s;for(let e=0,t=i.length;e<t;e++){if("function"==typeof i[e]){const s=i.splice(e,3);if(t=i.length,n=s[0],s[1]){if(s[1]!==SYNC&&s[1]!==ASYNC&&s[1]!==ASAP){r=ASYNC,n=createTimedCallback(n,s[1]);break}r=s[1],s[2]&&r!==SYNC&&(n=createTimedCallback(n,s[2]))}else r=ASYNC;break}}let l=!1;Array.isArray(e)?(s=e,l=!0):s=i;const u=()=>{const e=values(t,s);l?n.call(this,null,e):(e.unshift(null),n.apply(this,e))};return n?(r===SYNC?u():r!==ASYNC||this.missing(s).length?this._get(s,u):defer.immediate(()=>{this._get(s,u)}),this):values(t,s)}}),queryAny=function(e,t,i){return isPlainObject(e)||isLiveObject(e)?queryObject(e,t,i):Array.isArray(e)||isLiveList(e)?queryList(e,t,i):i(null,e,!0)},queryObject=function(e,t,i){const n={};let r=!0;t||i(null,n,r);const s=map(t.mask,"key"),l=function(e){parallel(e.map(function(e,i){return function(l){queryAny(e,t.mask[i],function(e,t,u){e?l(e):(u||(r=!1),n[s[i]]?deepMixIn(n[s[i]],t):n[s[i]]=t,l())})}}),function(e){i(e,n,r)})};if(isLiveObject(e))e._get(s,function(t,n){if(t)i(t);else{n||(r=!1);const t=map(s,function(t){return e._data[t]});l(t)}});else{const t=pick(e,s);l(t)}},satisfies=function(e,t,i){if(!t)return!!e;if(isRegExp(i))return i.test(e);if("="===t)return e===i;if("!="===t)return e!==i;if(isNumber(i)){if(">"===t)return e>i;if(">="===t)return e>=i;if("<"===t)return e<i;if("<="===t)return e<=i}if(isString(i)){const n=escapeRegExp(i);if("^="===t)return new RegExp(`^${n}`).test(e);if("$="===t)return new RegExp(`${n}$`).test(e);if("~="===t)return new RegExp(`(^|\\s)${n}(\\s|$)`).test(e);if("|="===t)return new RegExp(`^${n}(-|$)`).test(e);if(" *="===t)return-1!==e.toString().indexOf(i)}return!1},filterArray=function(e,t,i,n,r){let s=!0;const l=[];let u=e.length,a=!1;function o(e){if(e)return void(a||(a=!0,r(e)));if(a||--u>0)return;const t=[];for(let e=0;e<l.length;e++)e in l&&t.push(l[e]);r(null,t,s)}for(let r=0;r<e.length;r++){const u=e[r];isLiveObject(u)?u._get([t],function(e,a){if(e)return void o(e);a||(s=!1);let c=u._data[t];satisfies(c,i,n)&&(l[r]=u),o()}):(isPlainObject(u)&&satisfies(u[t],i,n)&&(l[r]=u),o())}},defaultFilters=[[{left:0,op:":"}]];function runSeriallyOnArray(e,t,i,n){t>=e.length?n():i(e[t],function(r){r?n(r):runSeriallyOnArray(e,t+1,i,n)})}const queryList=function(e,t,i){let n=!0;t.filters||(t.filters=defaultFilters),runSeriallyOnArray(t.filters,0,function(t,i){let r=[];parallel(t.map(function(t){return function(i){!function(t,i){let s=t.left,l=t.right,u=t.op;if("left"in t&&!("right"in t)&&isNumber(s)&&(u?":"===u&&(l=e.length):l=s+1,u=":"),"right"in t&&!("left"in t)&&isNumber(l)&&":"===u&&(s=0),isNumber(s)&&isNumber(l)&&":"===u)if(Array.isArray(e)){const t=slice_.call(e,s,l);r=r.concat(t),i()}else e._get([new Range(s,l)],function(t,u){if(t)i(t);else{for(let t=s;t<l;t++)r.push(e.values[t]);u||(n=!1),i()}});else{const t=function(e){filterArray(e,s,u,l,function(e,t,s){e?i(e):(s||(n=!1),r=r.concat(t),i())})};Array.isArray(e)?t(e):e._get([new Range(0,e.length)],function(r,s){if(r)i(r);else{const i=[];for(let t=0;t<e.length;t++)i.push(e.values[t]);s||(n=!1),t(i)}})}}(t,i)}}),function(t){t?i(t):(e=r,i())})},function(r){if(r)i(r);else{const r=[];parallel(e.map(function(e,i){return function(s){queryAny(e,t,function(e,t,l){l||(n=!1),r[i]?deepMixIn(r[i],t):r[i]=t,s(e)})}}),function(e){i(e,r,n)})}})};let cache={};const live=function(e){return Array.isArray(e)?(new LiveList).update([{type:"insert",index:0,length:e.length,values:e}]):isNumber(e)?new LiveList(e):isString(e)?cache[e]||(cache[e]=new LiveObject(e)):isPlainObject(e)?live(e.uri).update(e):isLiveList(e)||isLiveObject(e)?e:new LiveObject};global.localStorage&&global.localStorage.debug&&(global.localStorage.debug.indexOf("live")>-1||global.localStorage.debug.indexOf("*")>-1)&&(live.debug=!0);const emitters={keys:[],values:[]};live.subscribe=function(e,t,i){let n=e;e.matches&&(n=n.matches);const r=n.toString(),s=emitters.keys,l=emitters.values;let u;for(let e=0,t=s.length;e<t;e++){if(s[e].toString()===r&&(u=l[e]))break}return u||(s.push(e),l.push(u=new Emitter)),u.on(t,i),this},live.unsubscribe=function(e,t,i){let n=e;n.matches&&(n=n.matches);const r=e.toString(),s=emitters.keys,l=emitters.values;let u;for(let e=0,t=s.length;e<t;e++){if(s[e].toString()===r&&(u=l[e]))break}return u&&u.off(t,i),this},live.delete=function(e){return delete cache[e],this},live.purge=function(){return cache={},this},live.has=function(e){return!!cache[e]};const EMIT_SYNC=live.EMIT_SYNC=Emitter.EMIT_SYNC,ASYNC=live.ASYNC="ASYNC",SYNC=live.SYNC="SYNC",ASAP=live.ASAP="ASAP",PUBLISH=3,UPDATE=4;live.Object=LiveObject,live.List=LiveList,module.exports=live;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../libs/prime":187,"../../libs/prime/defer":185,"../../libs/prime/emitter":186,"../debug":59,"../range2":189,"./util/ordered-set":150,"./util/parser":151,"./util/throttle":152,"mout/array/combine":385,"mout/array/difference":387,"mout/array/filter":390,"mout/array/map":394,"mout/lang/isPlainObject":411,"mout/lang/isRegExp":412,"mout/object/deepMixIn":416,"mout/object/pick":424,"mout/string/escapeRegExp":426}],149:[function(require,module,exports){
"use strict";const splice_=Array.prototype.splice,slice_=Array.prototype.slice,annotate=function(t,e){const o=t.length,n=e.length,r=[],f={},l={};for(let s=0;s<o;s++){const c=t[s];for(let i=0;i<n;i++){if(l[i])continue;if(c!==e[i])continue;const h=s,a=i;let u=0;do{f[s++]=l[i++]=!0,u++}while(s<o&&i<n&&t[s]===e[i]&&!l[i]);const m={type:"move",from:h,to:a,length:u};r.push(m),s--;break}}const s=[];for(let e=0;e<o;){if(f[e]){e++;continue}const n=e;let r=0;for(;e<o&&!f[e++];)r++;const l={type:"remove",index:n,length:r,values:slice_.call(t,n,n+r)};s.push(l)}const c=[];for(let t=0;t<n;){if(l[t]){t++;continue}const o=t;let r=0;for(;t<n&&!l[t++];)r++;const f=slice_.call(e,o,o+r);c.push({type:"insert",index:o,length:r,values:f})}return[s,r,c]},reduceMoves=function(t){for(let e=0;e<t.length;e++)if(t[e].length>Math.abs(t[e].to-t[e].from)){const o=t[e].to,n=t[e].length;t[e].length=Math.abs(t[e].to-t[e].from),t[e].from=o,t[e].to=o+n}},offset=function(t,e,o){const n=o.length,r=t.length,f=e.length;let l=0;for(let o=0;o<r;o++){const n=t[o];n.index-=l,l+=n.length;for(let t=0;t<f;t++){const o=e[t];o.from>=n.index&&(o.from-=n.length)}}for(let t=n;t--;){const n=o[t],r=n.length;for(let t=f;t--;){const o=e[t];o.to>=n.index&&(o.to-=r)}}for(let t=f;t-- >1;){const o=e[t];if(o.to!==o.from)for(let n=t;n--;){const t=e[n];t.to>=o.to&&(t.to-=o.length),t.to>=o.from&&(t.to+=o.length)}}const s=[];for(let t=0;t<f;t++){const o=e[t];if(o.to!==o.from){s.push(o);for(let n=t+1;n<f;n++){const t=e[n];t.from>=o.from&&(t.from-=o.length),t.from>=o.to&&(t.from+=o.length)}}}return reduceMoves(s),t.concat(s,o)},insert=function(t,e,o){for(let n=0;n<o.length;n++)if(n in o){const r=e+n;t.length<r&&(t.length=r),t.splice(r,0,o[n])}return o},remove=function(t,e,o){return splice_.call(t,e,o)},move=function(t,e,o,n){const r=remove(t,e,n);return insert(t,o,r),r},patch=function(t,e){for(let o=0;o<e.length;o++){const n=e[o];switch(n.type){case"move":move(t,n.from,n.to,n.length);break;case"remove":remove(t,n.index,n.length);break;case"insert":insert(t,n.index,n.values);break;default:console.error("Unexpected operation type",n.type)}}return t},diff=function(t,e){const o=annotate(t,e);return offset.apply(this,o)};diff.annotate=annotate,diff.offset=offset,diff.remove=remove,diff.insert=insert,diff.move=move,diff.patch=patch,module.exports=diff;

},{}],150:[function(require,module,exports){
"use strict";const prime=require("../../../libs/prime"),forEach=require("mout/array/forEach"),Range=require("../../range2"),diff=require("./diff"),OrderedSet=prime({constructor:function(e=0){this.index=[],this.keys=new Array(e),this.values=new Array(e),this.objectStorage={}},get length(){return this.keys.length},set length(e){this.keys.length=e,this.values.length=e},forEach:function(e,t){const i=this.index;for(let s=0;s<i.length;s++){const n=i[s];for(let i=n.start;i<n.end&&!1!==e.call(t,this.values[i],i,this.keys[i],this);i++);}return this},map:function(e,t){const i=new Array(this.length);return this.forEach(function(s,n,r){i[n]=e.call(t,s,n,r,this)},this),i},copy:function(e){this.index=e.index.slice(),this.keys=e.keys.slice(),this.values=e.values.slice();const t=this.keys.length;this.objectStorage={};for(let e=0;e<t;e++)this.objectStorage[this.keys[e]]=this.values[e];return this},clone:function(){return(new OrderedSet).copy(this)},indexOf:function(e){let t=-1;return this.forEach(function(i,s,n){e===n&&(t=s)}),t},indexOfMany:function(e){const t={},i=[];for(let i=0;i<e.length;i++)t[e[i]]=-1;this.forEach(function(e,i,s){s in t&&(t[s]=i)});for(let s=0;s<e.length;s++)i[s]=t[e[s]];return i},valueOf:function(e){return this.objectStorage[e]||null},hasKey:function(e){return this.objectStorage.hasOwnProperty(e)},sort:function(e){const t=this.keys,i=this.values,s=diff(i.slice(),i.sort(e));return forEach(s,function(e){diff.move(t,e.from,e.to,e.length)}),this},move:function(e,t,i){let s=i,n=t;return e>this.length?[]:(e+s>this.length&&(s=e-this.length),n>this.length&&(n=this.length),e===n?[]:(diff.move(this.keys,e,n,s),diff.move(this.values,e,n,s),this))},insert:function(e,t,i){if(t.length!==i.length)throw new Error("length mismatch");const s=new Range(e,e+t.length);this.index=s.insert(this.index),diff.insert(this.keys,e,t),diff.insert(this.values,e,i);for(let e=0,s=t.length;e<s;e++)this.objectStorage[t[e]]=i[e];return this},remove:function(e,t){let i=t;if(e>=this.length)return[];e+i>this.length&&(i=this.length);const s=new Range(e,e+i);this.index=s.extract(this.index);for(let t=0;t<i;t++)delete this.objectStorage[this.keys[t+e]];return diff.remove(this.keys,e,i),diff.remove(this.values,e,i),this},diff:function(e){const t=diff.annotate(this.keys,e.keys);return forEach(t[0],function(e){e.keys=e.values,e.values=this.values.slice(e.index,e.index+e.length)},this),forEach(t[1],function(e){e.keys=e.values,e.values=this.values.slice(e.from,e.from+e.length)},this),forEach(t[2],function(t){t.keys=t.values,t.values=e.values.slice(t.index,t.index+t.length)}),diff.offset.apply(diff,t)},patch:function(e){return forEach(e,function(e){switch(e.type){case"move":this.move(e.from,e.to,e.length);break;case"remove":this.remove(e.index,e.length);break;case"insert":this.insert(e.index,e.keys,e.values);break;default:console.error("Invalid patch operation type",e.type)}},this),this}});module.exports=OrderedSet;

},{"../../../libs/prime":187,"../../range2":189,"./diff":149,"mout/array/forEach":391}],151:[function(require,module,exports){
"use strict";const normalize=function(e){return""===e||isNaN(e)?"true"===e||"false"!==e&&("null"===e?null:"undefined"!==e?e:void 0):+e};function escapeForRegExp(e){return e.replace(/[-[\]{}()*+?.,\\^$|#\s]/g,"\\$&")}const COMMA=",",BMASK="(",EMASK=")",BFILTER="[",EFILTER="]",EQUALS="=",WHITESPACE="\\s",operators=["=","!=",">=","<=",">","<","^=","$=","~=","|=","*="],keyBlacklist=",()"+escapeForRegExp("[")+escapeForRegExp("]")+"=\\s",keyBlacklistCharacterClass=`[^${keyBlacklist}]`,KEY_CHARACTER_REG_EXP=new RegExp(keyBlacklistCharacterClass),EXACT_KEY_REG_EXP=new RegExp(`^${keyBlacklistCharacterClass}+$`),OPERATORS_REG_EXP=new RegExp(operators.map(escapeForRegExp).join("|")),REPLACE_REG_EXP=/\$([\d]+)/,RANGE_FILTER_REG_EXP=/^(\d*):(\d*)$/,parse=function(e,t=[]){let r={mask:[]};const E=[r];let s,n="",a="",i="",l="",o="";for(let c=0;c<e.length+1;c++){const R=e.charAt(c);if(s){if(a=a.trim(),","===R||"]"===R){const e=a.match(RANGE_FILTER_REG_EXP),E=a.match(OPERATORS_REG_EXP),n=a.match(EXACT_KEY_REG_EXP);if(e)i=e[1],o=":",l=e[2];else if(E)i=a.substring(0,E.index),o=E[0],l=a.substring(E.index+o.length);else{if(!n)throw new SyntaxError(`syntax error: \`${a}\` contains characters not valid in a filter`);i=n[0]}a="";const c={};if(i){const e=i.match(REPLACE_REG_EXP);i=e?t[+e[1]]:normalize(i),c.left=i}if(o&&(c.op=o),l){const e=l.match(REPLACE_REG_EXP);l=e?t[+e[1]]:normalize(l),c.right=l}if(("left"in c||"right"in c)&&s.push(c),l="",i="",o="","]"===R){if(s.length){(r.filters||(r.filters=[])).push(s)}s=null}continue}a+=R}else{if(R&&KEY_CHARACTER_REG_EXP.test(R))n+=R;else if(!n||R&&","!==R&&"("!==R&&"["!==R&&")"!==R){if(R&&n)throw new SyntaxError(`syntax error: \`${R}\` is not a valid character in a key`)}else{const e=n.match(REPLACE_REG_EXP);E[0].mask.push(r={key:e?t[+e[1]]:normalize(n)}),n=""}"("===R?(r.mask=[],E.unshift(r)):")"===R&&E.shift(),"["===R&&(s=[])}}if(1!==E.length)throw new SyntaxError("syntax error");return E[0]};module.exports=parse;

},{}],152:[function(require,module,exports){
"use strict";const defer=require("../../../libs/prime/defer"),isInteger=function(t){return"number"==typeof t&&t%1==0},slice=Array.prototype.slice,_throttle=function(t,e,r){let n,o,i;return function(){return o=arguments,n||(n=!0,i=e(function(e){n=!1,t.apply(r,slice.call(o).concat(e))})),i}},throttle=function(t,e,r){return"number"==typeof(n=e)&&n%1==0?throttle.timeout(t,e,r):throttle.immediate(t,e);var n};throttle.timeout=function(t,e,r){return _throttle(t,function(t){return defer.timeout(t,e,r)},r)},throttle.immediate=function(t,e){return _throttle(t,function(t){return defer.immediate(t,e)},e)},module.exports=throttle;

},{"../../../libs/prime/defer":185}],153:[function(require,module,exports){
"use strict";const languages=require("./languages.json");function lookup(e,u){const n=languages[e];return n&&n[u]?n[u]:e}module.exports=lookup,module.exports.all=function(){return Object.keys(languages)};

},{"./languages.json":154}],154:[function(require,module,exports){
module.exports={
  "ar": {
    "smartling": "ar"
  },
  "cs": {
    "smartling": "cs-CZ"
  },
  "de": {
    "smartling": "de-DE"
  },
  "el": {
    "smartling": "el-GR"
  },
  "en": {
    "smartling": "en-GB"
  },
  "es": {
    "smartling": "es-ES"
  },
  "es-419": {
    "moment": "es",
    "smartling": "es-LA"
  },
  "fi": {
    "smartling": "fi-FI"
  },
  "fr": {
    "smartling": "fr-FR"
  },
  "fr-CA": {
    "smartling": "fr-CA",
    "moment": "fr-ca"
  },
  "hu": {
    "smartling": "hu-HU"
  },
  "id": {
    "smartling": "id-ID"
  },
  "it": {
    "smartling": "it-IT"
  },
  "ja": {
    "smartling": "ja-JP"
  },
  "nl": {
    "smartling": "nl-NL"
  },
  "pl": {
    "smartling": "pl-PL"
  },
  "pt-BR": {
    "moment": "pt-br",
    "smartling": "pt-BR",
    "intl": "pt-PT"
  },
  "sv": {
    "smartling": "sv-SE"
  },
  "th": {
    "smartling": "th-TH"
  },
  "tr": {
    "smartling": "tr-TR"
  },
  "vi": {
    "smartling": "vi-VN"
  },
  "zh-Hant": {
    "moment": "zh-tw",
    "smartling": "zh-TW"
  },
  "ms": {
    "moment": "ms-my",
    "smartling": "ms-MY",
    "intl": "ms-MY"
  }
}

},{}],155:[function(require,module,exports){
"use strict";const schemer=require("./schemer"),cosmos=require("../../cosmos-api").default,debug=require("../../debug");let id=0;module.exports=function(e,s){const o=schemer(e,Object.assign({},{message_name:e.name,message_version:e.schema_version},s));o.fields=o.fields.map(function(e){return"string"==typeof e?e:null===e?"":JSON.stringify(e)});const r=e.name+e.schema_version,n=debug(`logger:${r}`),i=++id;n("REQ %s#%s %s",r,i,JSON.stringify(o)),cosmos.resolver.post({url:"sp://logging/v3/log",body:o},function(e,s){e?console.error(e,o):n("RES %s#%s %d",r,i,s.getStatusCode())})};

},{"../../cosmos-api":54,"../../debug":59,"./schemer":156}],156:[function(require,module,exports){
(function (Buffer){
"use strict";var _avroJs=require("avro-js"),_avroJs2=_interopRequireDefault(_avroJs);function _interopRequireDefault(e){return e&&e.__esModule?e:{default:e}}const debug=require("../../debug")("logger:");function convertType(e,r){if(Array.isArray(e.type)){const n=r[e.name];if(null===n)return;r[e.name]={};const s=e.type.filter(e=>"null"!==e)[0];"object"==typeof s?(r[e.name]={[s.type]:n},convertType(s,r[e.name])):r[e.name][s]="bytes"===s?new Buffer(n):n}else"bytes"===e.type&&(r[e.name]=new Buffer(r[e.name]))}module.exports=function(e,r){debug(e.name);const n=r.message_name,s=r.message_version,o=Object.assign({},r);if(s!==e.schema_version)throw new Error(`Invalid message version: received Message with message_version ${s} but the Schema requires version ${e.schema_version}`);const t=e.fields.map(e=>{const r=o[e.name];return void 0===r?e.default:(convertType(e,o),r)}).slice(2);return _avroJs2.default.parse(e).isValid(o,{errorHook(e,r){throw new Error(`Logger: Invalid data: ${e.join(",")}: ${r}`)}}),{message:n,version:s,fields:t}};

}).call(this,require("buffer").Buffer)
},{"../../debug":59,"avro-js":352,"buffer":358}],157:[function(require,module,exports){
"use strict";const schema=require("../schemas/AddToPlaylist3.json"),log=require("../lib/log");module.exports={schema:schema,log:log.bind(null,schema)};

},{"../lib/log":155,"../schemas/AddToPlaylist3.json":161}],158:[function(require,module,exports){
"use strict";const schema=require("../schemas/UIImpression5.json"),log=require("../lib/log");module.exports={schema:schema,log:log.bind(null,schema)};

},{"../lib/log":155,"../schemas/UIImpression5.json":162}],159:[function(require,module,exports){
"use strict";const schema=require("../schemas/UIInteraction5.json"),log=require("../lib/log");module.exports={schema:schema,log:log.bind(null,schema)};

},{"../lib/log":155,"../schemas/UIInteraction5.json":163}],160:[function(require,module,exports){
"use strict";const schema=require("../schemas/UserDragAndDropInteraction1.json"),log=require("../lib/log");module.exports={schema:schema,log:log.bind(null,schema)};

},{"../lib/log":155,"../schemas/UserDragAndDropInteraction1.json":164}],161:[function(require,module,exports){
module.exports={
  "namespace": "com.spotify.Message",
  "type": "record",
  "name": "AddToPlaylist",
  "fields": [
    {
      "type": "string",
      "name": "message_name"
    },
    {
      "type": "int",
      "name": "message_version"
    },
    {
      "default": null,
      "doc": "Create playlist, save to collection, save to existing playlist etc.",
      "type": [
        "null",
        "string"
      ],
      "name": "intent"
    },
    {
      "default": null,
      "doc": "URI of item that was added and only the first if multiple.",
      "type": [
        "null",
        "string"
      ],
      "name": "item_uri"
    },
    {
      "default": null,
      "doc": "Number of items added.",
      "type": [
        "null",
        "string"
      ],
      "name": "number_items"
    },
    {
      "default": null,
      "doc": "What section the item where added from.",
      "type": [
        "null",
        "string"
      ],
      "name": "section"
    },
    {
      "default": null,
      "doc": "The view uri which led to add to playlist.",
      "type": [
        "null",
        "string"
      ],
      "name": "source"
    },
    {
      "default": null,
      "doc": "The action which led to add to playlist.",
      "type": [
        "null",
        "string"
      ],
      "name": "source_action"
    },
    {
      "default": null,
      "doc": "The position of playlist added to or null.",
      "type": [
        "null",
        "int"
      ],
      "name": "playlist_index"
    },
    {
      "default": null,
      "doc": "The uri of playlist added to or null.",
      "type": [
        "null",
        "string"
      ],
      "name": "playlist_uri"
    },
    {
      "default": null,
      "doc": "The total number of items displayed.",
      "type": [
        "null",
        "int"
      ],
      "name": "total_number_playlists"
    },
    {
      "default": null,
      "doc": "Unix timestamp",
      "type": [
        "null",
        "long"
      ],
      "name": "time"
    }
  ],
  "doc": "User interacted with add to playlist.",
  "schema_version": 3
}
},{}],162:[function(require,module,exports){
module.exports={
  "type": "record",
  "name": "UIImpression",
  "namespace": "com.spotify.Message",
  "doc": "A UI impression log",
  "fields": [
    {
      "name": "message_name",
      "type": "string"
    },
    {
      "name": "message_version",
      "type": "int"
    },
    {
      "name": "request_id",
      "type": [
        "null",
        "string"
      ],
      "doc": "Request ID from Spaces Log",
      "default": null
    },
    {
      "name": "feature_id",
      "type": [
        "null",
        "string"
      ],
      "doc": "A name for a feature (e.g., browse-new-releases, collection, etc.)",
      "default": null
    },
    {
      "name": "pageuri",
      "type": [
        "null",
        "string"
      ],
      "doc": "Uri of the page within the feature (e.g., spotify:hub:music, etc.)",
      "default": null
    },
    {
      "name": "section_id",
      "type": [
        "null",
        "string"
      ],
      "doc": "Section of the page (e.g., Early Morning)",
      "default": null
    },
    {
      "name": "item_index",
      "type": [
        "null",
        "int"
      ],
      "doc": "Index of item in block",
      "default": null
    },
    {
      "name": "target_uri",
      "type": [
        "null",
        "string"
      ],
      "doc": "URI of item impressed (nullable for page and block impressions)",
      "default": null
    },
    {
      "name": "impression_type",
      "type": [
        "null",
        "string"
      ],
      "doc": "Page, block, or item",
      "default": null
    },
    {
      "name": "render_type",
      "type": [
        "null",
        "string"
      ],
      "doc": "Block container ceramic type (e.g. carousel, list, tile)",
      "default": null
    },
    {
      "name": "timestamp",
      "type": [
        "null",
        "double"
      ],
      "doc": "Unix timestamp of event",
      "default": null
    }
  ],
  "schema_version": 5
}
},{}],163:[function(require,module,exports){
module.exports={
  "type": "record",
  "name": "UIInteraction",
  "namespace": "com.spotify.Message",
  "doc": "A UI interaction log",
  "fields": [
    {
      "name": "message_name",
      "type": "string"
    },
    {
      "name": "message_version",
      "type": "int"
    },
    {
      "name": "request_id",
      "type": [
        "null",
        "string"
      ],
      "doc": "Request ID from Spaces Log",
      "default": null
    },
    {
      "name": "feature_id",
      "type": [
        "null",
        "string"
      ],
      "doc": "A name for a feature (e.g., browse-new-releases, collection, etc.)",
      "default": null
    },
    {
      "name": "pageuri",
      "type": [
        "null",
        "string"
      ],
      "doc": "Uri of the page within the feature (e.g., spotify:hub:music, etc.)",
      "default": null
    },
    {
      "name": "section_id",
      "type": [
        "null",
        "string"
      ],
      "doc": "Section or block of the page (e.g., Early Morning)",
      "default": null
    },
    {
      "name": "item_index",
      "type": [
        "null",
        "int"
      ],
      "doc": "Index of item in block",
      "default": null
    },
    {
      "name": "target_uri",
      "type": [
        "null",
        "string"
      ],
      "doc": "Destination of interaction",
      "default": null
    },
    {
      "name": "interaction_type",
      "type": [
        "null",
        "string"
      ],
      "doc": "Type of interaction (e.g., hit, swipe, hold, hover, etc.)",
      "default": null
    },
    {
      "name": "user_intent",
      "type": [
        "null",
        "string"
      ],
      "doc": "Grouping of interactions based on user intent (e.g., play, navigate-forward, navigate-back)",
      "default": null
    },
    {
      "name": "timestamp",
      "type": [
        "null",
        "double"
      ],
      "doc": "Unix timestamp of event",
      "default": null
    }
  ],
  "schema_version": 5
}
},{}],164:[function(require,module,exports){
module.exports={
  "type": "record",
  "name": "UserDragAndDropInteraction",
  "namespace": "com.spotify.Message",
  "doc": "Logged whenever a user drags and drops (currently desktop only) an item in the client. Only completed drag and drops are logged and not canceled/failed ones.",
  "fields": [
    {
      "name": "message_name",
      "type": "string"
    },
    {
      "name": "message_version",
      "type": "int"
    },
    {
      "name": "item_type",
      "type": [
        "null",
        "string"
      ],
      "doc": "Type of item, eg \"track\".",
      "default": null
    },
    {
      "name": "item_uri",
      "type": [
        "null",
        "string"
      ],
      "doc": "Uri of item that was dropped and only the first if multiple.",
      "default": null
    },
    {
      "name": "number_items",
      "type": [
        "null",
        "long"
      ],
      "doc": "Number of items dropped.",
      "default": null
    },
    {
      "name": "source_view_uri",
      "type": [
        "null",
        "string"
      ],
      "doc": "View uri from where the drag started, eg \"spotify:app:playlist\".",
      "default": null
    },
    {
      "name": "source_uri",
      "type": [
        "null",
        "string"
      ],
      "doc": "Uri of the context from where the drag started, eg: \"spotify:user:spotify:playlist:1m6DKwKNM1YLcm3OX6RzJg\".",
      "default": null
    },
    {
      "name": "source_index",
      "type": [
        "null",
        "long"
      ],
      "doc": "Index of the item from where the drag started.",
      "default": null
    },
    {
      "name": "source_component",
      "type": [
        "null",
        "string"
      ],
      "doc": "Id of the component from where the drag started, eg: \"header/title\" if the user dragged a playlist via the playlist title in the header.",
      "default": null
    },
    {
      "name": "target_view_uri",
      "type": [
        "null",
        "string"
      ],
      "doc": "View uri where the drop ended, eg \"spotify:app:zlink\".",
      "default": null
    },
    {
      "name": "target_uri",
      "type": [
        "null",
        "string"
      ],
      "doc": "Uri of the context where the drop ended, \"spotify:user:spotify:rootlist\".",
      "default": null
    },
    {
      "name": "target_index",
      "type": [
        "null",
        "long"
      ],
      "doc": "Index where dropped.",
      "default": null
    },
    {
      "name": "target_component",
      "type": [
        "null",
        "string"
      ],
      "doc": "Id of the component where the drop ended, eg: \"player/queue\" if dropped on the Queue button in the player component.",
      "default": null
    },
    {
      "name": "ms_duration",
      "type": [
        "null",
        "long"
      ],
      "doc": "The duration in milliseconds from the start of the drag until the end of the drop.",
      "default": null
    }
  ],
  "schema_version": 1
}
},{}],165:[function(require,module,exports){
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.messageProxy=messageProxy;var _debug=require("../debug"),_debug2=_interopRequireDefault(_debug),_uris=require("./uris.json"),_uris2=_interopRequireDefault(_uris);function _interopRequireDefault(e){return e&&e.__esModule?e:{default:e}}const METHODS=["POST","SUB","GET","REPLY"],BASE_URI="message-proxy",debug=(0,_debug2.default)("message-proxy");function messageProxy(e,r){if("undefined"==typeof window||!window.top||!window.top.postMessage)return!1;const t=e.uri;if(!e)throw new Error("Need a request object.");if(-1===METHODS.indexOf(e.method))throw new Error("Need a valid method:",METHODS);if(!r&&"POST"===!e.method)throw new Error("Callback needed");if(!_uris2.default.hasOwnProperty(t))throw new Error("Uri need to be one of these: ",Object.keys(_uris2.default));const o={},s=_uris2.default[t][e.method]||[];if("GET"===e.method){s.forEach(r=>{if(!e.body.hasOwnProperty(r))throw new Error(`Uri 'GET' request body missing\n                        a required key: ${r}`);o[r]=e.body[r]});const n=e=>{isEventValid(e,`${BASE_URI}-${t}-reply`)&&(debug("getListener",t,e.data),e.data.error?r(e.data.error):(delete e.data.uri,r(null,e.data)),window.removeEventListener("message",n))};return window.addEventListener("message",n),o.uri=`${BASE_URI}-${t}-get`,debug("get",t,o),postMessageToFrame(e.target,o)||(window.removeEventListener("message",n),r("No frame found to post to.")),!0}if("REPLY"===e.method){const e=e=>{isEventValid(e,`${BASE_URI}-${t}-get`)&&(debug("reply listener",t,e.data),delete e.data.uri,r(e.data,function(r,o){const n={};r?n.error=r:s.forEach(e=>{if(!o.hasOwnProperty(e))throw new Error(`Reply data missing\n                              a required key: ${e}`);n[e]=o[e]}),n.uri=`${BASE_URI}-${t}-reply`,debug("reply post",t,n),e.source.postMessage(n,e.origin)}))};return window.addEventListener("message",e,!1),()=>{window.removeEventListener("message",e)}}if("POST"===e.method){s.forEach(r=>{if(!e.body.hasOwnProperty(r))throw new Error(`Uri 'POST' request body missing\n                        a required key: ${r}`);o[r]=e.body[r]}),o.uri=`${BASE_URI}-${t}`,debug("post",t,o);const n=postMessageToFrame(e.target,o);return r&&r(n?null:"No frame found to post to."),!0}const n=e=>{isEventValid(e,`${BASE_URI}-${t}`)&&(debug("subscription event",t,e.data),r(e.data))};return debug("subscription",t),window.addEventListener("message",n,!1),()=>{window.removeEventListener("message",n)}}const originRegex=new RegExp("^https?://[a-zA-Z-]*.app.spotify.com");function isEventValid(e,r){return!!originRegex.test(e.origin)&&e.data.uri===r}function postMessageToFrame(e,r){if(("top"===e||!e)&&(debug("postMessageToFrame target=top data=%o",r),window.top.postMessage(r,"*"),"top"===e))return!0;let t,o;if(window===window.top)t=window.top.frames;else{const e=Array.prototype.slice.call(window.top.frames,0,window.top.frames.length),r=Array.prototype.slice.call(window.frames,0,window.frames.length);t=e.concat(r)}const s=t.length;for(let n=0;n<s;n++)e&&e!==t[n].frameElement.src||(debug("postMessageToFrame target=%o data=%o",t[n].frameElement.target,r),t[n].postMessage(r,"*"),o=!0);return debug("postMessageToFrame framesLength=%o frameFound=%o",s,o),o}

},{"../debug":59,"./uris.json":166}],166:[function(require,module,exports){
module.exports={
  "unit-test": {
    "GET": ["key1"],
    "POST": ["key2"],
    "REPLY": ["key3"]
  },
  "client-state": {
    "SUB": [],
    "POST": ["state"],
    "GET": [],
    "REPLY": ["state"]
  },
  "history": {
    "GET": ["count"],
    "REPLY": ["history"]
  },
  "hpto": {
    "REPLY": ["ad"],
    "GET": []
  },
  "hpto-refresh": {
    "SUB": [],
    "POST": []
  },
  "station": {
    "GET": ["stationUri", "metadata", "trackCount"],
    "REPLY": ["stationUri", "station"]
  },
  "station-add": {
    "POST": ["stationUri", "add"]
  },
  "station-autoplay": {
    "POST": ["contextUri", "playerPlaybackId", "prevTracks"],
    "SUB": []
  },
  "station-create": {
    "POST": ["stationUri"],
    "SUB": []
  },
  "station-error": {
    "POST": ["stationUri", "message"],
    "SUB": []
  },
  "station-metadata": {
    "POST": ["stationUri", "metadata"]
  },
  "station-last-played": {
    "POST": ["stationUri"]
  },
  "station-thumb": {
    "POST": ["stationUri", "trackUri", "thumb"]
  },
  "station-heart": {
    "POST": ["stationUri", "trackUri"]
  },
  "station-undo-feedback": {
    "POST": ["stationUri", "trackUri", "thumbAction"]
  },
  "stations-all": {
    "GET": [],
    "REPLY": ["user_stations", "genre_stations", "recommended_stations"]
  },
  "stations-saved": {
    "GET": [],
    "REPLY": ["saved_stations"]
  },
  "format-list-heart": {
    "POST": ["entityUri", "trackUri"]
  },
  "format-list-undo-feedback": {
    "POST": ["entityUri", "trackUri"]
  }
}

},{}],167:[function(require,module,exports){
"use strict";var _pageIdentifiers=require("./page-identifiers.js"),_pageIdentifiers2=require("./page-identifiers.json"),_pageIdentifiers3=_interopRequireDefault(_pageIdentifiers2);function _interopRequireDefault(t){return t&&t.__esModule?t:{default:t}}const UUID=require("uuid-js");function AppState(t){this._uri=void 0,void 0!==t&&this.setURI(t),this._uuid=UUID.create().toString(),this._isInitialState=!1}AppState.unserialize=function(t){const e=JSON.parse(t),i=new AppState;return i.setURI(e.uri),i},AppState.prototype.equals=function(t){return"string"==typeof this._uri&&t instanceof AppState&&this._uri===t._uri},AppState.prototype.equalsApp=function(t){const e=this.getAppId();return t&&e&&t.getAppId()===e||!1},AppState.prototype.getAppId=function(){const t=this.getURI().split(":");if(!(t.length<3)&&"app"===t[1]&&""!==t[2])return t[2]},AppState.prototype.getAppURI=function(){return this.getURI().split(":").slice(0,3).join(":")},AppState.prototype.getArgs=function(){return this.getURI().split(":").slice(3).map(function(t){return decodeURIComponent(t)})},AppState.prototype.getURI=function(){if(void 0===this._uri)throw new Error("URI not set");return this._uri},AppState.prototype.serialize=function(){return JSON.stringify({uri:this.getURI()})},AppState.prototype.setArgs=function(t){if(!Array.isArray(t))throw new TypeError("Args must be array");this._uri=this.getAppURI().split(":").concat(t.map(function(t){return encodeURIComponent(t)})).join(":")},AppState.prototype.setURI=function(t){if("string"!=typeof t)throw new TypeError("URI must be string");this._uri=t},AppState.prototype.setIsInitialState=function(t){this._isInitialState=t},AppState.prototype.getIsInitialState=function(){return this._isInitialState},AppState.prototype.getUUID=function(){return this._uuid},AppState.prototype.getPageID=function(){return(0,_pageIdentifiers.getPageIdFromUri)(this.getAppId(),this.getURI())},AppState.prototype.isPageCovered=function(){return this.getPageID()!==_pageIdentifiers3.default.unknownUncovered},module.exports=AppState;

},{"./page-identifiers.js":171,"./page-identifiers.json":170,"uuid-js":455}],168:[function(require,module,exports){
"use strict";module.exports={AppState:require("./app-state"),Navigator:require("./navigator")};

},{"./app-state":167,"./navigator":169}],169:[function(require,module,exports){
(function (global){
"use strict";const inherit=require("spotify-inheritance/inherit"),EventEmitter=require("spotify-eventemitter"),AppState=require("./app-state");function Navigator(){this._global=global.top||global,EventEmitter.call(this),this._messageHandler=this._messageHandler.bind(this)}inherit(Navigator,EventEmitter),Navigator.prototype.EVENTS=Navigator.EVENTS={REQUEST_STATE:"navigation_request_state"},Navigator.prototype.METHOD=Navigator.METHOD={OPEN:"open",TOGGLE:"toggle"},Navigator.prototype._messageHandler=function(t){if(!t.data.type)return;const e=t.data.type;if(e===Navigator.EVENTS.REQUEST_STATE){const a={state:AppState.unserialize(t.data.state),method:t.data.method};t.data.extra&&(a.extra=JSON.parse(t.data.extra)),this.emitSync(e,a)}},Navigator.prototype.attachListener=function(){this._global.addEventListener("message",this._messageHandler)},Navigator.prototype.detachListener=function(){this._global.removeEventListener("message",this._messageHandler)},Navigator.prototype.openURI=function(t,e={}){this.requestOpenState(new AppState(t),e)},Navigator.prototype.toggleURI=function(t){this.requestToggleState(new AppState(t))},Navigator.prototype.requestOpenState=function(t,e={}){this.requestState(t,this.METHOD.OPEN,e)},Navigator.prototype.requestToggleState=function(t){this.requestState(t,this.METHOD.TOGGLE)},Navigator.prototype.requestState=function(t,e,a=null){if(!t)throw new TypeError("AppState not set");if(!e)throw new TypeError("Method not set");const i={type:this.EVENTS.REQUEST_STATE,method:e,state:t.serialize()};a&&(i.extra=JSON.stringify(a)),this._global.postMessage(i,"*")},module.exports=Navigator;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./app-state":167,"spotify-eventemitter":447,"spotify-inheritance/inherit":448}],170:[function(require,module,exports){
module.exports={
  "album": "album",
  "artist": "artist",
  "artistAbout": "artist/about",
  "artistAlbums": "artist/albums",
  "artistBio": "artist/bio",
  "artistConcerts": "artist/concerts",
  "artistGallery": "artist/gallery",
  "artistPlaylists": "artist/playlists",
  "artistRelated": "artist/related",
  "artistWorks": "artist/works",
  "browse": "browse",
  "browseCharts": "browse/charts",
  "browseDiscover": "browse/discover",
  "browseGenres": "browse/genres",
  "browseNewReleases": "browse/newreleases",
  "browsePodcasts": "browse/podcasts",
  "browseVideos": "browse/videos",
  "charts": "charts",
  "chartsChart": "charts/chart",
  "chartsRegional": "charts/regional",
  "chartsSocial": "charts/social",
  "chartsViral": "charts/viral",
  "collection": "collection",
  "collectionAlbums": "collection/albums",
  "collectionAlbumsAlbum": "collection/albums/album",
  "collectionArtists": "collection/artists",
  "collectionArtistsArtist": "collection/artists/artist",
  "collectionPlaylists": "collection/playlists",
  "collectionRadio": "collection/radio",
  "collectionRecentlyPlayed": "collection/recently-played",
  "collectionShows": "collection/shows",
  "collectionSongs": "collection/songs",
  "concert": "concert",
  "concerts": "concerts",
  "concertsCitysearch": "concerts/citysearch",
  "concertsConcert": "concerts/concert",
  "debug": "debug",
  "experimentalFeatures": "experiments",
  "lyrics": "lyrics",
  "home": "home",
  "moments": "moments",
  "momentsCategory": "moments/category",
  "music": "music",
  "musicCategory": "music/category",
  "now": "now",
  "nowplaying": "nowplaying",
  "nowplayingDevicepicker": "connect/devicepicker",
  "nowplayingHistory": "nowplaying/history",
  "nowplayingQueue": "nowplaying/queue",
  "party": "party",
  "partyAddFriends": "party/add-friends",
  "partyEnableBluetooth": "party/enable-bluetooth",
  "partyEnableNearby": "party/enable-nearby",
  "partyPreset": "party/preset",
  "partyQueue": "party/queue",
  "playlist": "playlist",
  "playlistFolder": "playlist/folder",
  "profile": "profile",
  "profileActivity": "profile/activity",
  "profileArtists": "profile/artists",
  "profileFollowers": "profile/followers",
  "profileFollowing": "profile/following",
  "profilePlaylists": "profile/playlists",
  "radio": "radio",
  "radioDailyMixes": "radio/daily-mixes",
  "radioStation": "radio/station",
  "running": "running",
  "runningCategory": "running/category",
  "runningSetup": "running/setup",
  "search": "search",
  "searchAlbums": "search/albums",
  "searchArtists": "search/artists",
  "searchGenres": "search/genres",
  "searchPlaylists": "search/playlists",
  "searchProfiles": "search/profiles",
  "searchRadio": "search/radio",
  "searchShows": "search/shows",
  "searchSongs": "search/songs",
  "searchVideos": "search/videos",
  "settings": "settings",
  "show": "show",
  "shows": "shows",
  "showsAudio": "shows/audio",
  "showsCategory": "shows/category",
  "showsNetwork": "shows/network",
  "showsVideo": "shows/video",
  "song": "song",
  "unknown": "unknown",
  "unknownUncovered": "unknown/uncovered",
  "work": "work"
}

},{}],171:[function(require,module,exports){
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.getPageIdFromUri=getPageIdFromUri,exports.getPageIdFromAppArguments=getPageIdFromAppArguments;var _pageIdentifiers=require("./page-identifiers.json"),_pageIdentifiers2=_interopRequireDefault(_pageIdentifiers),_spotifyLiburi=require("spotify-liburi"),_spotifyLiburi2=_interopRequireDefault(_spotifyLiburi);function _interopRequireDefault(e){return e&&e.__esModule?e:{default:e}}const extractArg=e=>r=>r.length>e&&r[e]||null,extractHubArg=e=>"charts"===extractArg(0)(e)?`charts-${extractArg(1)(e)}`:"genre",PAGE_LOGGER_MAP={album:"album","app-manager":"debug",artist:"artist","artist-concerts":"concerts","artist-creator-about":"artistAbout","artist-overview":"artist","artist-related":"artistRelated","artist-works":"artistWorks",boilerplate:"debug",browse:"browse","browse-charts":"charts","browse-discover":"browseDiscover","browse-genres":"browseGenres","browse-home":"browse","browse-podcasts":"browsePodcasts","browse-releases":"browseNewReleases","browse-videos":"browseVideos",chart:"chartsChart",charts:"charts",collection:"collection","collection-album":"collectionAlbumsAlbum","collection-albums":"collectionAlbums","collection-artist":"collectionArtistsArtist","collection-artists":"collectionArtists","collection-podcasts":"collectionShows","collection-songs":"collectionSongs","collection-videos":"collectionShows",concert:"concert",concerts:"concerts","daily-mix-hub":"radioDailyMixes",diag:"debug",discover:"browseDiscover",experiments:"experimentalFeatures","friends-mix":"friendsMix",genre:"browseGenres","glue-grid-demo":"debug","glue-header-demo":"debug","glue-reference":"debug",home:"home","hub-charts-regional":"chartsRegional","hub-charts-viral":"chartsViral","hub-genre":"browseGenres",lyrics:"lyrics",playlist:"playlist","playlist-folder":"playlistFolder","profile-followers":"profileFollowers","profile-following":"profileFollowing","profile-overview":"profile","profile-public-playlists":"profilePlaylists","profile-recently-played-artists":"profileArtists",profile:"profile",queue:"nowplayingQueue","queue-history":"nowplayingHistory","queue-queue":"nowplayingQueue",radio:"radio","radio-hub":"radio","recently-played":"collectionRecentlyPlayed","search-albums":"searchAlbums","search-artists":"searchArtists","search-genres":"searchGenres","search-playlists":"searchPlaylists","search-profiles":"searchProfiles","search-tracks":"searchSongs","search-shows":"searchShows",search:"search",settings:"settings",show:"show",song:"song",station:"radioStation",stations:"collectionRadio","video-debug":"debug",work:"work"},EXTRACT_SECTION={browse:extractArg(0),artist:extractArg(1),profile:extractArg(1),queue:extractArg(0),search:extractArg(1),hub:extractHubArg,collection:extractArg(0)};function getPageIdFromUri(e,r){if(e in EXTRACT_SECTION){const t=_spotifyLiburi2.default.from(r);return getPageIdFromAppIdAndSection(e,EXTRACT_SECTION[e](t.args))}return getPageIdFromAppIdAndSection(e)}function getPageIdFromAppArguments(e,r){if(e in EXTRACT_SECTION){return getPageIdFromAppIdAndSection(e,EXTRACT_SECTION[e](r))}return getPageIdFromAppIdAndSection(e)}function getPageIdFromAppIdAndSection(e,r){let t=e;r&&(t=`${t}-${r}`);const o=PAGE_LOGGER_MAP[t];return _pageIdentifiers2.default[o]||_pageIdentifiers2.default.unknownUncovered}

},{"./page-identifiers.json":170,"spotify-liburi":450}],172:[function(require,module,exports){
"use strict";const live=require("../live"),template=require("./offline-container.hbs");exports.enable=function(e){require("../live-models/client").register();const n=live("spotify:client");let i=document.createElement("div");i.innerHTML=template({offlineTitle:e.title,offlineMessage:e.message});const o=i.childNodes[0];i.removeChild(o),i=null,n.query("session(online)",function(i,t){i?console.error("Failed to load client state:",i):(t.session.online||document.body.appendChild(o),n.get("session").on("update",function(n){"online"in n&&(n.online?(document.body.removeChild(o),e.onWentOnline&&e.onWentOnline()):document.body.appendChild(o))}))})};

},{"../live":148,"../live-models/client":108,"./offline-container.hbs":173}],173:[function(require,module,exports){
var HandlebarsCompiler=require("hbsfy/runtime"),partial$0=require("../glue/templates/error-and-offline.hbs");HandlebarsCompiler.registerPartial("../glue/templates/error-and-offline.hbs",partial$0),module.exports=HandlebarsCompiler.template({compiler:[7,">= 4.0.0"],main:function(e,r,a,l,t){var i;return'<div class="show-offline-screen" style="position: fixed; bottom: 0; left: 0; right: 0; top: 0; z-index: 90000;">\n'+(null!=(i=e.invokePartial(l["../glue/templates/error-and-offline.hbs"],r,{name:"../glue/templates/error-and-offline.hbs",data:t,indent:"  ",helpers:a,partials:l,decorators:e.decorators}))?i:"")+"</div>\n"},usePartial:!0,useData:!0});

},{"../glue/templates/error-and-offline.hbs":90,"hbsfy/runtime":381}],174:[function(require,module,exports){
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.PLATFORM_WINDOWS=exports.PLATFORM_MAC=exports.PLATFORM_UNKNOWN=void 0,exports._setGetTopLevelWindowFunction=_setGetTopLevelWindowFunction,exports._resetGetTopLevelWindowFunction=_resetGetTopLevelWindowFunction,exports.isMac=isMac,exports.isWindows=isWindows,exports.getPlatform=getPlatform,exports.subscribeToPlatform=subscribeToPlatform,exports.removeAllSubscriptions=removeAllSubscriptions;var _cosmosApi=require("../cosmos-api"),_cosmosApi2=_interopRequireDefault(_cosmosApi);function _interopRequireDefault(o){return o&&o.__esModule?o:{default:o}}const PLATFORM_UNKNOWN=exports.PLATFORM_UNKNOWN=Symbol("PLATFORM_UNKNOWN"),PLATFORM_MAC=exports.PLATFORM_MAC=Symbol("PLATFORM_MAC"),PLATFORM_WINDOWS=exports.PLATFORM_WINDOWS=Symbol("PLATFORM_WINDOWS");let getTopLevelWindow=()=>window.top;const originalGetTopLevelWindow=getTopLevelWindow;function _setGetTopLevelWindowFunction(o){getTopLevelWindow=o}function _resetGetTopLevelWindowFunction(){getTopLevelWindow=originalGetTopLevelWindow}const subscriptions=[];let cosmosSubscription=null;function createCosmosSubscription(){if(cosmosSubscription)return;let o=getPlatform();cosmosSubscription=_cosmosApi2.default.resolver.subscribe("sp://messages/v1/container/control",(e,t)=>{if(e)return void console.error(e);const s=t.getJSONBody();if(s){let e;switch(s.type){case"set_platform_emulation_auto":e=getPlatform();break;case"set_platform_emulation_macos":e=PLATFORM_MAC;break;case"set_platform_emulation_windows":e=PLATFORM_WINDOWS;break;case"set_platform_emulation_linux":e=PLATFORM_UNKNOWN;break;default:return}subscriptions.forEach(t=>{t(e,o)}),o=e,getTopLevelWindow()===window&&setGlobalBasedOnPlatform(o)}})}function setGlobalBasedOnPlatform(o){switch(o){case PLATFORM_MAC:window.osLibCurrentPlatformId="mac";break;case PLATFORM_WINDOWS:window.osLibCurrentPlatformId="win";break;default:window.osLibCurrentPlatformId="unknown"}}function getPlatformFromGlobal(){switch(getTopLevelWindow().osLibCurrentPlatformId){case"mac":return PLATFORM_MAC;case"win":return PLATFORM_WINDOWS;default:return PLATFORM_UNKNOWN}}function isMac(){return window.navigator.platform.startsWith("Mac")}function isWindows(){return window.navigator.platform.startsWith("Win")}function getPlatform(){return getTopLevelWindow()!==window?getPlatformFromGlobal():isMac()?PLATFORM_MAC:isWindows()?PLATFORM_WINDOWS:PLATFORM_UNKNOWN}function subscribeToPlatform(o){subscriptions.push(o);const e=getPlatform();o(e,e),getTopLevelWindow()===window&&setGlobalBasedOnPlatform(e),createCosmosSubscription()}function removeAllSubscriptions(){subscriptions.length=0,cosmosSubscription&&(cosmosSubscription.cancel(),cosmosSubscription=null)}

},{"../cosmos-api":54}],175:[function(require,module,exports){
"use strict";const player=require("./player"),play=require("./play"),playHistory=require("./play_history");exports.Play=play.Play,exports.Player=player.Player,exports.PlayHistory=playHistory.PlayHistory;

},{"./play":176,"./play_history":177,"./player":178}],176:[function(require,module,exports){
"use strict";const cosmos=require("../cosmos-api"),nodefn=require("when/node");function Play(e,t,n,o,s,i){if(!(this instanceof Play))return new Play(e,t,n,o,s,i);if(!(e&&t&&n&&o&&s))throw new TypeError("Missing parameters for Play");this._resolver=e,this._createSessionPromise=t,this._player=n,this._getTime=o,this._context=s,this._optOptions=i}Play.prototype._sessionUrl=function(){return this._createSessionPromise.then(function(e){return e.getJSONBody().session})},Play.prototype._createPlayRequest=function(e){const t={logging_params:{command_initiated_time:this._getTime()}};return new cosmos.Request(cosmos.Action.POST,`${e}/play`,null,t)},Play.prototype._createUpdateRequest=function(e,t){return t.logging_params={command_initiated_time:this._getTime()},new cosmos.Request(cosmos.Action.POST,`${e}/update`,null,t)},Play.prototype.play=function(e=(()=>{})){const t=this;this._createSessionPromise?this._sessionUrl().then(function(e){return nodefn.call(t._resolver.resolve.bind(t._resolver),t._createPlayRequest(e))}).done(function(){e(null)},function(n){if(n.response&&404===n.response.getStatusCode())t._createSessionPromise=null,t.play(e);else{const t=new Error(`Failed to prepare player session: ${n.message}`);t.cause=function(){return n},e(t)}}):this._player.play(this._context,this._optOptions,e)},Play.prototype._update=function(e,t=(()=>{})){const n=this;this._createSessionPromise?this._sessionUrl().then(function(t){return nodefn.call(n._resolver.resolve.bind(n._resolver),n._createUpdateRequest(t,e))}).done(function(){t(null)},function(e){const n=new Error(`Failed to update player session: ${e.message}`);n.cause=function(){return e},t(n)}):t(new Error("Cannot update invalidated Play"))},Play.prototype.updateContext=function(e,t){this._update({context:e},t)},Play.prototype.updatePage=function(e,t){this._update({page:e},t)},Play.prototype.updateTrack=function(e,t){this._update({track:e},t)},Play.prototype.updateViewUri=function(e,t){this._update({view_uri:e},t)},Play.prototype.invalidate=function(e=(()=>{})){if(!this._createSessionPromise)return;const t=this;this._sessionUrl().done(function(n){const o=new cosmos.Request(cosmos.Action.DELETE,n,null,null);t._resolver.resolve(o,function(){e(null)})},function(){e(null)}),this._createSessionPromise=null},exports.Play=Play;

},{"../cosmos-api":54,"when/node":474}],177:[function(require,module,exports){
"use strict";const cosmos=require("../cosmos-api"),PLAY_HISTORY_URI="sp://play-history/v1";function PlayHistory(s){if(!(this instanceof PlayHistory))return new PlayHistory(s);if(!s)throw new TypeError("Missing resolver for PlayHistory");this._resolver=s}PlayHistory.prototype.get=function(s){const o=new cosmos.Request(cosmos.Action.GET,PLAY_HISTORY_URI);return this._resolver.resolve(o,s)},PlayHistory.prototype.subscribe=function(s){const o=new cosmos.Request(cosmos.Action.SUB,PLAY_HISTORY_URI);return this._resolver.resolve(o,s)},exports.PlayHistory=PlayHistory;

},{"../cosmos-api":54}],178:[function(require,module,exports){
"use strict";const cosmos=require("../cosmos-api"),nodefn=require("when/node"),play=require("./play"),PLAYER_URI="sp://player/v2/",DEFAULT_PLAYER_ID="main";function Player(e,t,r,o,n){if(!(this instanceof Player))return new Player(e,t,r,o);if(!(e&&t&&r&&o))throw new TypeError("Missing parameters for Player");this._getTime=n&&n.getTime||function(){return(new Date).getTime()},this._id=n&&n.playerId||DEFAULT_PLAYER_ID,this._referrerIdentifier=n&&n.referrerIdentifier,this._resolver=e,this._viewUri=t,this._featureId=r,this._featureVersion=o}Player.Actions={PROBE_PLAY:"probe_play",PLAY:"play",SESSION:"session",STOP:"stop",UPDATE:"update",PAUSE:"pause",RESUME:"resume",SKIP_NEXT:"skip_next",SKIP_PREV:"skip_prev",SHUFFLE:"set_shuffling_context",REPEAT_CONTEXT:"set_repeating_context",REPEAT_TRACK:"set_repeating_track",SEEK_TO:"seek_to"},Player.prototype._playOrPrepareOrProbe=function(e,t,r,o){if(!t)throw new TypeError("Invalid `context` object");r instanceof Function&&!o&&(o=r,r=null);const n={};return n.context=t,n.play_origin=this._makePlayOrigin(),n.options=r,this._sendRequestWithParams(e,n,o)},Player.prototype.addToQueue=function(e,t){if(!e)throw new TypeError("Invalid `track` object");return this._sendRequestWithParams("add_to_queue",{track:e},t)},Player.prototype.probePlay=function(e,t,r){return this._playOrPrepareOrProbe(Player.Actions.PROBE_PLAY,e,t,r)},Player.prototype.play=function(e,t,r){return this._playOrPrepareOrProbe(Player.Actions.PLAY,e,t,r)},Player.prototype.preparePlay=function(e,t){const r=nodefn.call(this._playOrPrepareOrProbe.bind(this),Player.Actions.SESSION,e,t);return new play.Play(this._resolver,r,this,this._getTime,e,t)},Player.prototype.stop=function(e){return this._sendRequestWithAction(Player.Actions.STOP,e)},Player.prototype.update=function(e,t){if(!e)throw new TypeError("Invalid `context` object");const r={context:e};return this._sendRequestWithParams(Player.Actions.UPDATE,r,t)},Player.prototype.resume=function(e){return this._sendRequestWithAction(Player.Actions.RESUME,e)},Player.prototype.pause=function(e){return this._sendRequestWithAction(Player.Actions.PAUSE,e)},Player.prototype.skipToPrevTrack=function(e,t){1===arguments.length&&"function"==typeof e&&(t=e,e=null);const r={};return e&&(r.options=e),this._sendRequestWithParams(Player.Actions.SKIP_PREV,r,t)},Player.prototype.skipToNextTrack=function(e,t){1===arguments.length&&"function"==typeof e&&(t=e,e=null);const r={};return e&&(r.options=e),this._sendRequestWithParams(Player.Actions.SKIP_NEXT,r,t)},Player.prototype.skipToSpecificPrevTrack=function(e,t){return this._sendRequestWithParams(Player.Actions.SKIP_PREV,{track:e},t)},Player.prototype.skipToSpecificNextTrack=function(e,t){return this._sendRequestWithParams(Player.Actions.SKIP_NEXT,{track:e},t)},Player.prototype.skipToPrev=Player.prototype.skipToPrevTrack,Player.prototype.skipToNext=Player.prototype.skipToNextTrack,Player.prototype.setShufflingContext=function(e,t){return this._sendRequestWithParam(Player.Actions.SHUFFLE,e,t)},Player.prototype.setRepeatingContext=function(e,t){return this._sendRequestWithParam(Player.Actions.REPEAT_CONTEXT,e,t)},Player.prototype.setRepeatingTrack=function(e,t){return this._sendRequestWithParam(Player.Actions.REPEAT_TRACK,e,t)},Player.prototype.seekTo=function(e,t){return this._sendRequestWithParam(Player.Actions.SEEK_TO,e,t)},Player.prototype.save=function(e){const t=`${this.getPlayerEndpointUri()}/snapshot`,r=new cosmos.Request(cosmos.Action.GET,t);return this._resolver.resolve(r,e)},Player.prototype.restore=function(e,t){const r=`${this.getPlayerEndpointUri()}/snapshot`,o=new cosmos.Request(cosmos.Action.PUT,r,null,e);return this._resolver.resolve(o,t)},Player.prototype.getQueue=function(e){const t=`${this.getPlayerEndpointUri()}/queue`,r=new cosmos.Request(cosmos.Action.GET,t);return this._resolver.resolve(r,e)},Player.prototype.setQueue=function(e,t){const r=`${this.getPlayerEndpointUri()}/queue`,o=new cosmos.Request(cosmos.Action.PUT,r,null,e);return this._resolver.resolve(o,t)},Player.prototype.subscribeToQueue=function(e){const t=new cosmos.Request(cosmos.Action.SUB,`${this.getPlayerEndpointUri()}/queue`);return this._resolver.resolve(t,e)},Player.prototype.getState=function(e,t){const r=new cosmos.Request(cosmos.Action.GET,this.getPlayerEndpointUriWithParams(t));return this._resolver.resolve(r,e)},Player.prototype.subscribe=function(e,t){const r=new cosmos.Request(cosmos.Action.SUB,this.getPlayerEndpointUriWithParams(t));return this._resolver.resolve(r,e)},Player.prototype.onError=function(e){const t=new cosmos.Request(cosmos.Action.SUB,`${this.getPlayerEndpointUri()}/error`);return this._resolver.resolve(t,e)},Player.prototype._makePlayOrigin=function(){return{view_uri:this._viewUri,feature_identifier:this._featureId,feature_version:this._featureVersion,referrer_identifier:this._referrerIdentifier}},Player.prototype.getPlayerEndpointUri=function(){return PLAYER_URI+this._id},Player.prototype.getPlayerEndpointUriWithParams=function(e={}){const t=Object.keys(e).reduce(function(t,r){return t.push(`${r}=${encodeURIComponent(e[r])}`),t},[]);return t.length>0?`${this.getPlayerEndpointUri()}?${t.join("&")}`:this.getPlayerEndpointUri()},Player.prototype._sendRequestWithAction=function(e,t){return this._sendRequestWithParams(e,null,t)},Player.prototype._sendRequestWithParam=function(e,t,r){const o={value:t};return this._sendRequestWithParams(e,o,r)},Player.prototype._sendRequestWithParams=function(e,t,r){const o=`${this.getPlayerEndpointUri()}/${e}`,n=t||{};n.logging_params={command_initiated_time:this._getTime()};const s=new cosmos.Request(cosmos.Action.POST,o,null,n);return this._resolver.resolve(s,r)},exports.Player=Player;

},{"../cosmos-api":54,"./play":176,"when/node":474}],179:[function(require,module,exports){
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.getMadeForAttributionEnabled=exports.splitFeedbackUri=exports.makeFeedbackUri=void 0,exports.fetchMadeFors=fetchMadeFors,exports.fetchMadeFor=fetchMadeFor,exports.buildMadeFor=buildMadeFor,exports.originalPlaylistUri=originalPlaylistUri,exports.allowsFeedback=allowsFeedback,exports.getFeedback=getFeedback;var _spotifyLiburi=require("spotify-liburi"),_spotifyLiburi2=_interopRequireDefault(_spotifyLiburi),_bridge=require("../bridge"),_bridge2=_interopRequireDefault(_bridge),_liveWrappedUri=require("../live-wrapped-uri"),_liveWrappedUri2=_interopRequireDefault(_liveWrappedUri);function _interopRequireDefault(e){return e&&e.__esModule?e:{default:e}}function fetchMadeFors(e,r){const i=e.map(e=>fetchMadeFor(e,r));return Promise.all(i)}function fetchMadeFor(e,r){if(!e)return Promise.resolve(null);const i=e.username;if(!i)return Promise.resolve(null);let t=e.name;return t?Promise.resolve(buildMadeFor(t,i,r)):new Promise(e=>{const o=_spotifyLiburi2.default.profileURI(i).toURI();_bridge2.default.request("user_metadata",[o],(o,a)=>{t=o?i:a.name||i,e(buildMadeFor(t,i,r))})})}function buildMadeFor(e,r,i){const t=r===i;return{isCurrentUser:t,name:e,shortName:e.split(" ").shift(),username:r,renderAsYou:t&&r===e&&/^\d+$/.test(r),uri:_spotifyLiburi2.default.profileURI(r).toURI()}}function originalPlaylistUri(e){return _liveWrappedUri2.default.getOriginUri(e)||e}function allowsFeedback(e){return!!e&&"1"===e["like-feedback-available"]}function getFeedback(e){return e?"1"===e["like-feedback-selected"]?"up":"1"===e["dislike-feedback-selected"]?"down":null:null}const makeFeedbackUri=exports.makeFeedbackUri=((e,r)=>`spotify:internal:${e}:feedback:${r}`),splitFeedbackUri=exports.splitFeedbackUri=(e=>e.split("spotify:internal:").pop().split(":feedback:")),getMadeForAttributionEnabled=exports.getMadeForAttributionEnabled=(()=>window.top.initialState.madeForAttributionEnabled);

},{"../bridge":50,"../live-wrapped-uri":147,"spotify-liburi":450}],180:[function(require,module,exports){
(function (global){
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.addAlbumToPlaylist=addAlbumToPlaylist,exports.addStationToPlaylist=addStationToPlaylist,exports.addStuffToPlaylist=addStuffToPlaylist,exports.getRefreshedPlaylistData=getRefreshedPlaylistData,exports.createRefreshedPlaylist=createRefreshedPlaylist,exports.shouldPlaylistBeOffline=shouldPlaylistBeOffline,exports.getPlaylist2ShowsCell=getPlaylist2ShowsCell,exports.isPlaylist2Shows=isPlaylist2Shows,exports.resyncPlaylist=resyncPlaylist;var _spotifyLiburi=require("spotify-liburi"),_spotifyLiburi2=_interopRequireDefault(_spotifyLiburi),_bridge=require("../../libs/bridge"),_bridge2=_interopRequireDefault(_bridge),_live=require("../../libs/live"),_live2=_interopRequireDefault(_live),_playlistActions=require("./playlist-actions"),_playlistData=require("./playlist-data"),_offlineStatus=require("./offline-status"),OfflineStatus=_interopRequireWildcard(_offlineStatus),_formatLists=require("./format-lists"),formatListUtils=_interopRequireWildcard(_formatLists);function _interopRequireWildcard(t){if(t&&t.__esModule)return t;var l={};if(null!=t)for(var e in t)Object.prototype.hasOwnProperty.call(t,e)&&(l[e]=t[e]);return l.default=t,l}function _interopRequireDefault(t){return t&&t.__esModule?t:{default:t}}function addAlbumToPlaylist(t,l,e){const a=[l.toString(),0,-1];return _bridge2.default.request("album_tracks_snapshot",a,(l,a)=>{l?e(l):(0,_playlistActions.addTracksToPlaylist)(t,a.array,e)})}function addStationToPlaylist(t,l,e){(0,_live2.default)(l.toString()).query("rows(track(uri))",(l,a)=>{if(l)return void e(l);const s=a.rows.map(t=>t.track.uri);(0,_playlistActions.addTracksToPlaylist)(t,s,e)})}function addStuffToPlaylist(t,l,e){if(l[0].type===_spotifyLiburi2.default.Type.ALBUM)addAlbumToPlaylist(t,l[0],e),l.length>1&&console.warn("Passed more than a single album to addStuffToPlaylist(). Adding only one.");else if(l[0].type===_spotifyLiburi2.default.Type.STATION||l[0].type===_spotifyLiburi2.default.Type.DAILY_MIX)addStationToPlaylist(t,l[0],e);else{const a=l.map(t=>t.toString());(0,_playlistActions.addTracksToPlaylist)(t,a,e)}}function fetchPlaylistName(t,l){(0,_playlistData.fetchPlaylistMetadata)(t,{name:!0},(t,e)=>{e&&e.name?l(t,e.name):l(t)})}function getRefreshedPlaylistData(t,l){fetchPlaylistName(t,async(e,a)=>{if(e)return void l(e);const s=await(0,_playlistData.fetchPlaylistV1UriFromPlaylist)(t.toString()),i=(0,_playlistActions.refreshedPlaylistName)(a);_bridge2.default.cosmosJSON({method:"POST",uri:"hm://playlistfreshener/freshen",body:{playlistURI:s,type:"W2V_freshener"}},(t,e)=>{if(t)return void l(t);const a=e.recommendedTracks.map(t=>`spotify:track:${t.id}`);l(null,{name:i,tracks:a})})})}function createRefreshedPlaylist(t,l){getRefreshedPlaylistData(t,(t,{name:e,tracks:a}={})=>{t?l(t):(0,_playlistActions.createNewPlaylist)(e,(t,e)=>{t?l(t):(0,_playlistActions.addTracksToPlaylist)(e,a,t=>{l(t,e)})})})}function shouldPlaylistBeOffline(t,l){(0,_playlistData.fetchPlaylistMetadata)(t,{offline:!0},(t,e)=>{if(e&&e.offline){const a=OfflineStatus.shouldBeOffline(e.offline);l(t,a)}else l(t,e)})}function getPlaylist2ShowsCell(){return(global.initialState||global.top&&global.top.initialState||{}).playlist2ShowsCell||null}function isPlaylist2Shows(t){if(!("Enabled"===getPlaylist2ShowsCell()))return!1;return["format-shows","format-shows-shuffle"].includes(t)}function resyncPlaylist(t,l){const e={method:"POST",uri:`sp://core-playlist/v1/playlist/${t}/resync`};return _bridge2.default.cosmos(e,(t,e)=>{if(l)if(t)l(t);else if(200!==e.status&&204!==e.status){const t=new Error(`Cosmos Request Error. Status: ${e.status}`);t.status=e.status,l(t)}else l(null,e)})}const playlistUtils={OfflineStatus:OfflineStatus,addTracksToPlaylist:_playlistActions.addTracksToPlaylist,getCollaborativeStatus:_playlistData.getCollaborativeStatus,createNewPlaylist:_playlistActions.createNewPlaylist,createNewPlaylistBefore:_playlistActions.createNewPlaylistBefore,createNewPlaylistAfter:_playlistActions.createNewPlaylistAfter,setPlaylistCollaborative:_playlistActions.setPlaylistCollaborative,setPlaylistPublished:_playlistActions.setPlaylistPublished,logAddToPlaylist:_playlistActions.logAddToPlaylist,setPlaylistName:_playlistActions.setPlaylistName,removePlaylist:_playlistActions.removePlaylist,removePlaylistFolderRecursively:_playlistActions.removePlaylistFolderRecursively,followPlaylist:_playlistActions.followPlaylist,offlineSyncPlaylist:_playlistActions.offlineSyncPlaylist,fetchPlaylistMetadata:_playlistData.fetchPlaylistMetadata,subscribeToMetadata:_playlistData.subscribeToMetadata,fetchPlaylistV1UriFromPlaylist:_playlistData.fetchPlaylistV1UriFromPlaylist,getPlaylistV2UriFromPlaylist:_playlistData.getPlaylistV2UriFromPlaylist,fetchIsPlaylistOwnedByCurrentUser:_playlistData.fetchIsPlaylistOwnedByCurrentUser,playlistRequest:_playlistData.playlistRequest,getAvailablePlaylistName:_playlistData.getAvailablePlaylistName,formatListUtils:formatListUtils,isPlaylist2Shows:isPlaylist2Shows,getPlaylist2ShowsCell:getPlaylist2ShowsCell,addStuffToPlaylist:addStuffToPlaylist,resyncPlaylist:resyncPlaylist,createRefreshedPlaylist:createRefreshedPlaylist,shouldPlaylistBeOffline:shouldPlaylistBeOffline};exports.default=playlistUtils;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../libs/bridge":50,"../../libs/live":148,"./format-lists":179,"./offline-status":181,"./playlist-actions":182,"./playlist-data":183,"spotify-liburi":450}],181:[function(require,module,exports){
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.YES=exports.DOWNLOADING=exports.WAITING_SYNC_NOT_ALLOWED=exports.WAITING_NO_CONNECTION=exports.WAITING_OFFLINE_MODE=exports.WAITING=exports.NO=void 0,exports.isDownloading=isDownloading,exports.shouldBeOffline=shouldBeOffline,exports.progressFromStatus=progressFromStatus,exports.getLabelForStatus=getLabelForStatus,exports.sendUserMessageForStatus=sendUserMessageForStatus;var _bridge=require("../../libs/bridge"),_bridge2=_interopRequireDefault(_bridge);function _interopRequireDefault(e){return e&&e.__esModule?e:{default:e}}const NO=exports.NO="no",WAITING=exports.WAITING="waiting",WAITING_OFFLINE_MODE=exports.WAITING_OFFLINE_MODE="waitingOfflineMode",WAITING_NO_CONNECTION=exports.WAITING_NO_CONNECTION="waitingNoConnection",WAITING_SYNC_NOT_ALLOWED=exports.WAITING_SYNC_NOT_ALLOWED="waitingSyncNotAllowed",DOWNLOADING=exports.DOWNLOADING="downloading",YES=exports.YES="yes";function isDownloading(e){return e===DOWNLOADING}function shouldBeOffline(e){switch(e){case WAITING:case WAITING_OFFLINE_MODE:case WAITING_NO_CONNECTION:case DOWNLOADING:case WAITING_SYNC_NOT_ALLOWED:case YES:return!0;case NO:default:return!1}}function progressFromStatus(e){switch(e){case WAITING:case WAITING_OFFLINE_MODE:case WAITING_NO_CONNECTION:case WAITING_SYNC_NOT_ALLOWED:case NO:return 0;case YES:return 1;case DOWNLOADING:default:return}}function getLabelForStatus(e,s){switch(e){case DOWNLOADING:return"Downloading";case WAITING_OFFLINE_MODE:case WAITING_NO_CONNECTION:case WAITING_SYNC_NOT_ALLOWED:return"WaitingForConnection";case WAITING:return"WaitingForDownload";case YES:return s?"DownloadedSongs":"Downloaded";case NO:default:return s?"DownloadSongs":"Download"}}function sendUserMessageForStatus(e){switch(e){case WAITING_OFFLINE_MODE:return _bridge2.default.cosmosJSON({method:"POST",uri:"sp://messages/v1/container/user-message",body:{id:"cant-offline-sync-playlist-in-offline-mode"}}),!0;default:return!1}}

},{"../../libs/bridge":50}],182:[function(require,module,exports){
(function (global){
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.DUPLICATE_ACTIONS=void 0,exports.addTracksToPlaylist=addTracksToPlaylist,exports.setPlaylistPublished=setPlaylistPublished,exports.createNewPlaylist=createNewPlaylist,exports.createNewPlaylistBefore=createNewPlaylistBefore,exports.createNewPlaylistAfter=createNewPlaylistAfter,exports.setPlaylistName=setPlaylistName,exports.setPlaylistCollaborative=setPlaylistCollaborative,exports.followPlaylist=followPlaylist,exports.removePlaylist=removePlaylist,exports.removePlaylistFolderRecursively=removePlaylistFolderRecursively,exports.logAddToPlaylist=logAddToPlaylist,exports.refreshedPlaylistName=refreshedPlaylistName,exports.offlineSyncPlaylist=offlineSyncPlaylist;var _cosmosApi=require("../cosmos-api"),_cosmosApi2=_interopRequireDefault(_cosmosApi),_AddToPlaylist=require("../../libs/logger/messages/AddToPlaylist3"),_AddToPlaylist2=_interopRequireDefault(_AddToPlaylist),_live=require("../../libs/live"),_live2=_interopRequireDefault(_live),_bridge=require("../../libs/bridge"),_bridge2=_interopRequireDefault(_bridge),_playlistData=require("./playlist-data");function _interopRequireDefault(e){return e&&e.__esModule?e:{default:e}}const DUPLICATE_ACTIONS=exports.DUPLICATE_ACTIONS={ADD_ALL:"add_all",ADD_UNIQUE:"add_unique",CANCEL:"cancel"};function getDuplicates(e,t,l){_cosmosApi2.default.resolver.post({url:`sp://core-playlist/v1/playlist/${encodeURIComponent(e)}/contains`,body:{items:t}},function(e,o){if(e)return void l([]);const s=o.getJSONBody().found,i=[],r=[];t.forEach((e,l)=>{s[l]?i.push(t[l]):r.push(t[l])}),l(i,r)})}function maybeFilterDuplicates(e,t,l){getDuplicates(e,t,function(o,s){o.length?_cosmosApi2.default.resolver.post({url:"sp://messages/v1/avoidduplicates",body:{action:"confirm",source:global.__spotify.app_uri,playlistUri:e,numItems:t.length,numDuplicates:o.length}},function(e){if(e)return void l(t);const o=_cosmosApi2.default.resolver.subscribe({url:"sp://messages/v1/avoidduplicates"},function(e,i){if(o.cancel(),e)l(t);else switch(i.getJSONBody().action){case DUPLICATE_ACTIONS.ADD_ALL:l(t);break;case DUPLICATE_ACTIONS.ADD_UNIQUE:l(s);break;case DUPLICATE_ACTIONS.CANCEL:l([]);break;default:throw new Error("Invalid DUPLICATE_ACTION.")}})}):l(t)})}function addTracksToPlaylist(e,t,l){maybeFilterDuplicates(e,t,function(t){t.length?_cosmosApi2.default.resolver.post({url:`sp://core-playlist/v1/playlist/${encodeURIComponent(e)}`,body:{operation:"add",uris:t,after:"end"}},function(e,t){e&&t&&t.getJSONBody()&&/exceed the maximum playlist size/i.test(t.getJSONBody().error)&&_cosmosApi2.default.resolver.post({url:"sp://messages/v1/container/user-message",body:{id:"playlist-limit-exceeded"}}),e?l(e):l()}):l()})}function setPlaylistPublished(e,t,l){_bridge2.default.cosmosJSON({method:"POST",uri:"sp://core-playlist/v1/rootlist",body:{operation:"set",attributes:{published:t},rows:[e.toString()]}},l)}function createNewPlaylist(e,t){_bridge2.default.cosmosJSON({method:"POST",uri:"sp://core-playlist/v1/rootlist",body:{operation:"create",playlist:!0,before:"start",name:e}},(e,l)=>t(e,l&&l.uri))}function createNewPlaylistBefore(e,t,l){_bridge2.default.cosmosJSON({method:"POST",uri:"sp://core-playlist/v1/rootlist",body:{operation:"create",playlist:!0,before:t,name:e}},(e,t)=>l(e,t&&t.uri))}function createNewPlaylistAfter(e,t,l){_bridge2.default.cosmosJSON({method:"POST",uri:"sp://core-playlist/v1/rootlist",body:{operation:"create",playlist:!0,after:t,name:e}},(e,t)=>l(e,t&&t.uri))}function setPlaylistName(e,t,l){_bridge2.default.cosmosJSON({method:"POST",uri:`sp://core-playlist/v1/playlist/${encodeURIComponent(e)}`,body:{operation:"set",attributes:{name:t}}},(o,s)=>{o||(0,_live2.default)(e).update({name:t}),l(o,s)})}function setPlaylistCollaborative(e,t,l){_bridge2.default.cosmosJSON({method:"POST",uri:`sp://core-playlist/v1/playlist/${encodeURIComponent(e)}`,body:{operation:"set",attributes:{collaborative:t}}},(o,s)=>{o?l(o,s):t?(0,_playlistData.getCollaborativeStatus)(e,(t,o)=>{t||null===o.published?l(t||new Error("`published` property unexpectedly missing"),s):o.published?exports.setPlaylistPublished(e,!1,l):l(null,s)}):l(null,s)})}function broadcastFollowState(e,t){_bridge2.default.cosmosJSON({method:"POST",uri:"sp://messages/v1/followstate",body:{uri:e.toString(),isFollowing:t}})}function followPlaylist(e,t){_bridge2.default.cosmosJSON({method:"POST",uri:"sp://core-playlist/v1/rootlist",body:{operation:"add",before:"start",uris:[e.toString()]}},(l,o)=>{l||broadcastFollowState(e.toString(),!0),t(l,o)})}function removePlaylist(e,t){_bridge2.default.cosmosJSON({method:"POST",uri:"sp://core-playlist/v1/rootlist",body:{operation:"remove",rows:[e.toString()]}},(l,o)=>{l||broadcastFollowState(e.toString(),!1),t(l,o)})}function removePlaylistFolderRecursively(e,t){_bridge2.default.cosmosJSON({method:"POST",uri:"sp://core-playlist/v1/rootlist",body:{operation:"remove",contents:!0,rows:[e.toString()]}},t)}function logAddToPlaylist(e){let t;t=e.isNew?"create-new-playlist":e.isInFolder?"add-to-playlist-in-folder":"add-to-playlist",_AddToPlaylist2.default.log({intent:t,item_uri:e.uris[0].toURI(),number_items:e.uris.length.toString(),section:"all-playlists",source:e.appUri,source_action:"add-to-playlist",playlist_index:e.playlistIndex,playlist_uri:e.playlistUri,total_number_playlists:e.numberOfVisibleItems,time:Math.round(Date.now()/1e3)})}function refreshedPlaylistName(e){if(!e)return"Similar Playlist";const t=e.match(new RegExp("(.*)\\((\\d+)\\)$"));return t?`${t[1].trim()} (${l=t[2],parseInt(l,10)+1})`:`${e} (2)`;var l}function offlineSyncPlaylist(e,t,l){_bridge2.default.cosmos({method:t?"POST":"DELETE",uri:`sp://offline/v1/resources?uri=${e}`},l)}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../libs/bridge":50,"../../libs/live":148,"../../libs/logger/messages/AddToPlaylist3":157,"../cosmos-api":54,"./playlist-data":183}],183:[function(require,module,exports){
(function (global){
"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var _extends=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var i=arguments[t];for(var r in i)Object.prototype.hasOwnProperty.call(i,r)&&(e[r]=i[r])}return e};exports.fetchPlaylistMetadata=fetchPlaylistMetadata,exports.subscribeToMetadata=subscribeToMetadata,exports.getCollaborativeStatus=getCollaborativeStatus,exports.fetchPlaylistOwner=fetchPlaylistOwner,exports.fetchIsPlaylistOwnedByCurrentUser=fetchIsPlaylistOwnedByCurrentUser,exports.fetchPlaylistV1UriFromPlaylist=fetchPlaylistV1UriFromPlaylist,exports.getPlaylistV2UriFromPlaylist=getPlaylistV2UriFromPlaylist,exports.getCorePlaylistUrl=getCorePlaylistUrl,exports.fetchIsFormatShows=fetchIsFormatShows,exports.playlistRequest=playlistRequest,exports.getAvailablePlaylistName=getAvailablePlaylistName;var _spotifyLiburi=require("spotify-liburi"),_spotifyLiburi2=_interopRequireDefault(_spotifyLiburi),_bridge=require("../../libs/bridge"),_bridge2=_interopRequireDefault(_bridge),_liveWrappedUri=require("../../libs/live-wrapped-uri"),_liveWrappedUri2=_interopRequireDefault(_liveWrappedUri),_coreSortParams=require("../../libs/core-sort-params"),_coreSortParams2=_interopRequireDefault(_coreSortParams),_abba=require("../../libs/abba"),_abba2=_interopRequireDefault(_abba);function _interopRequireDefault(e){return e&&e.__esModule?e:{default:e}}function fetchPlaylistMetadata(e,t,i){const r=_spotifyLiburi2.default.from(e).toURI(),s=encodeURIComponent(r);_bridge2.default.cosmosJSON({method:"GET",uri:`sp://core-playlist/v1/playlist/${s}/metadata`,body:{policy:t}},(e,{error:t=null,metadata:r}={})=>i(e||t,r))}function subscribeToMetadata(e,t,i){const r=_spotifyLiburi2.default.from(e).toURI(),s=encodeURIComponent(r);return _bridge2.default.cosmosJSON({method:"SUB",uri:`sp://core-playlist/v1/playlist/${s}/metadata`,body:{policy:t}},(e,t)=>i(e,t&&t.metadata))}function getCollaborativeStatus(e,t){fetchPlaylistMetadata(e.toString(),{collaborative:!0,published:!0},t)}function isLocalFilesUri(e){return/:internal:local-files.*/.test(e)}async function fetchPlaylistOwner(e){const t=_spotifyLiburi2.default.from(e);if(t.type===_spotifyLiburi2.default.Type.PLAYLIST)return t.username;if(t.type===_spotifyLiburi2.default.Type.PLAYLIST_V2)return await new Promise((t,i)=>fetchPlaylistMetadata(e,{owner:{username:!0}},(r,{owner:{username:s}={}}={})=>{r?i(r):s?t(s):i(new Error(`No owner username found for ${e}`))}));throw new Error(`The uri ${e} is not any kind of playlist uri`)}async function fetchIsPlaylistOwnedByCurrentUser(e){return await fetchPlaylistOwner(e)===global.__spotify.username}async function fetchPlaylistV1UriFromPlaylist(e){const{type:t,id:i}=_spotifyLiburi2.default.from(e);if(t===_spotifyLiburi2.default.Type.PLAYLIST_V2){const t=await exports.fetchPlaylistOwner(e);return _spotifyLiburi2.default.playlistURI(t,i).toURI()}if(t===_spotifyLiburi2.default.Type.PLAYLIST)return e;throw new Error(`The uri ${e} is not any kind of playlist uri`)}function getPlaylistV2UriFromPlaylist(e){const{type:t,id:i}=_spotifyLiburi2.default.from(e);if(t===_spotifyLiburi2.default.Type.PLAYLIST)return _spotifyLiburi2.default.playlistV2URI(i).toURI();if(t===_spotifyLiburi2.default.Type.PLAYLIST_V2)return e;throw new Error(`The uri ${e} is not any kind of playlist uri`)}function getCorePlaylistUrl(e,{type:t,start:i,length:r,includeEpisodes:s,version:o="v1"}={},a,l){const{originUri:n=e,sort:u,filter:p}=_liveWrappedUri2.default.parse(e)||{};let y=p?p.query.split(","):[],f=!0,d=!0;isLocalFilesUri(e)||(f=!y.includes("playable eq true")&&!l,d="Enabled"===a,y=y.filter(e=>!e.startsWith("playable")&&!e.startsWith("isPremiumOnly")&&!e.startsWith("availability")));const c=_spotifyLiburi2.default.from(n).toURI();let b=isLocalFilesUri(e)?"sp://local-files/v2":`sp://core-playlist/${o}/playlist/${encodeURIComponent(c)}`;t&&(b+=`/${isLocalFilesUri(e)&&"rows"===t?"tracks":t}`);const m=[];if(u&&"metadata"!==t){const e="desc"===u.direction?"DESC":"ASC";m.push(`sort=${encodeURIComponent((0,_coreSortParams2.default)(u.query,e))}`)}return"number"==typeof i&&m.push(`start=${i}`),"number"==typeof r&&m.push(`length=${r}`),!0===s&&m.push("includeEpisodes=true"),f||m.push("showUnavailable=false"),d||m.push("alwaysShowWindowed=false"),y.length&&m.push(`filter=${y.map(encodeURIComponent).join(",")}`),"play"===t&&m.push(`uri=${encodeURIComponent(e)}`),m.length&&(b+=`?${m.join("&")}`),b}function fetchIsFormatShows(e,{includeEpisodes:t=!0}={}){return isLocalFilesUri(e)?Promise.resolve(!1):new Promise((i,r)=>{_bridge2.default.cosmosJSON({method:"GET",uri:exports.getCorePlaylistUrl(e,{type:"metadata",version:"v1",includeEpisodes:t}),body:{policy:{formatListType:!0}}},(e,t)=>{e?r(e):i(t.metadata&&/^format-shows/.test(t.metadata.formatListType))})})}function playlistRequest(e,{method:t="GET",policy:i={},body:r={},type:s,start:o,length:a,includeEpisodes:l,version:n}={},u){let p;return Promise.all([_abba2.default.fetch("windowed-playlist-show-tracklist"),exports.fetchIsFormatShows(e,{includeEpisodes:l})]).then(([y,f])=>{let d;p=_bridge2.default.cosmos({method:t,uri:exports.getCorePlaylistUrl(e,{type:s,start:o,length:a,includeEpisodes:l,version:n},y,f),body:JSON.stringify(_extends({},r,{policy:_extends({},r.policy||{},i)}))},(e,i)=>{if(e)u(e,i);else if(i&&!i.body&&i.status>=400)u(new Error(`${i.uri} responded with status ${i.status}`),i);else try{if("SUB"===t){if(i.body===d)return;d=i.body}u(null,JSON.parse(i.body))}catch(e){e.message=`Failed to parse cosmos response: ${e.message}`,u(e,i)}})}).catch(u),{cancel(){p&&p()}}}function getAvailablePlaylistName(e,t){_bridge2.default.cosmosJSON({method:"GET",uri:`sp://core-playlist/v1/rootlist?filter=${encodeURIComponent(`name startsWith ${encodeURIComponent(e)}`)}`,body:{policy:{playlist:{name:!0}}}},(i,r)=>{if(i)return void t(i);const s=r.rows.map(({name:t})=>t.substr(e.length).trim()||"1").filter(e=>/\d+/.test(e)).map(Number).sort((e,t)=>e-t).pop();t(null,`${e}${s?` ${s+1}`:""}`)})}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../libs/abba":48,"../../libs/bridge":50,"../../libs/core-sort-params":53,"../../libs/live-wrapped-uri":147,"spotify-liburi":450}],184:[function(require,module,exports){
"use strict";const batch=require("spotify-batch"),bridge=require("../bridge"),PREF_ALL="preferences_all",PREF_GET="preferences_get",PREF_SET="preferences_set",PREF_SUB="preferences_event_wait";function transformStringIntoObjectAndSetValue(e,t,n){const r={};return e.split(n||".").reduce(function(e,n,r,c){return r<c.length-1?e[n]={}:e[n]=t,e[n]},r),r}function transformObjectIntoFlatObject(e,t){const n={},r=t||".";return function e(t,c){let o=null;for(const s in t)if("object"==typeof t[s]){const n=c?[c,s].join(r):s;e(t[s],n)}else o=c?[c,s].join(r):s,n[o]=t[s]}(e),n}function deepMerge(...e){const t=e=>e&&"object"==typeof e;return e.reduce((e,n)=>(Object.keys(n).forEach(r=>{const c=e[r],o=n[r];Array.isArray(c)&&Array.isArray(o)?e[r]=c.concat(...o):t(c)&&t(o)?e[r]=deepMerge(c,o):e[r]=o}),e),{})}function normalizeData(e,t,n){const r="*"===e?null:RegExp(`^${e}`);let c=null;if("object"!=typeof t)return t;c=Object.keys(t).map(function(e){return!(null!==r&&!r.test(e))&&[e,t[e]]}).filter(Boolean).reduce(function(e,t){return e[t[0]]=t[1],e},{});const o=Object.keys(c).reduce((e,t)=>deepMerge(e,transformStringIntoObjectAndSetValue(t,c[t])),{});return"*"===e||!0===n?o:e.split(".").reduce(function(e,t){return e[t]},o)}function subscribeToKey(e,t,n,r,c){const o=c||{isCancelled:!1,cancel:function(){this.isCancelled=!0}};return e(PREF_SUB,[],function(c,s){if(o.isCancelled)return;let i=!1,u=n;if(s){const e=normalizeData(t,s);e!==u&&(u=e,i=!0)}subscribeToKey(e,t,u,r,o),i&&r(null,u)}),o}function Preferences(e,t){if(!(this instanceof Preferences))return new Preferences(e,t);this.path=e||"*",this.rpc=t||bridge.request.bind(bridge)}module.exports=Preferences,Preferences.prototype.all=function(e){const t=this.path;return this.rpc(PREF_ALL,[],function(n,r){n?e(n):e(null,"*"===t?r:normalizeData(t,r,!0))}),this},Preferences.prototype.set=function(e,t,n){const r=this.path;let c=null,o=null;if("object"==typeof e){const n=t;c=transformObjectIntoFlatObject(e),o=batch().concurrency(1),Object.keys(c).forEach(e=>{o.push(t=>{this.set(e,c[e],t)})}),o.run(n)}else{const c="*"===r?e:[r,e].join(".");this.rpc(PREF_SET,[c,t],n)}return this},Preferences.prototype.setAtomicFlags=function(e,t,n){this.get(e,(r,c)=>{if(r)n(r);else{let r=c;t.forEach(function(e){const t=e[0],n=e[1];void 0!==n&&null!==n&&(n?r|=t:r&=~t)}),this.set(e,r,n)}})},Preferences.prototype.get=function(e,t){const n="*"===this.path?e:[this.path,e].join(".");return this.rpc(PREF_GET,[n],(e,r)=>{null===(r?normalizeData(n,r):null)?this.rpc(PREF_ALL,[],function(e,r){e?t(e):t(null,normalizeData(n,r))}):t(null,normalizeData(n,r))}),this},Preferences.prototype.subscribe=function(e,t){let n=null,r=!1;return this.get(e,(c,o)=>{if(r)return;const s="*"===this.path?e:[this.path,e].join(".");n=subscribeToKey(this.rpc,s,o,t),t(c,o)}),{cancel:function(){r=!0,n&&n.cancel()}}};

},{"../bridge":50,"spotify-batch":444}],185:[function(require,module,exports){
(function (process,global){
"use strict";const now=require("mout/time/now"),forEach=require("mout/array/forEach"),indexOf=require("mout/array/indexOf"),callbacks={timeout:{},frame:[],immediate:[]},iterate=function(e){const t=now();forEach(e.splice(0),function(e){e.callback.call(e.context,t)})},push=function(e,t,a,i){e.length||i(function(){iterate(e)});const c={callback:t,context:a};return e.push(c),function(){const t=indexOf(e,c);t>-1&&e.splice(t,1)}},defer={};let clear;global.process&&process.nextTick?defer.immediate=function(e,t){return push(callbacks.immediate,e,t,process.nextTick)}:global.setImmediate?defer.immediate=function(e,t){return push(callbacks.immediate,e,t,setImmediate)}:global.postMessage&&global.addEventListener?(addEventListener("message",function(e){e.source===global&&"@deferred"===e.data&&(e.stopPropagation(),iterate(callbacks.immediate))},!0),defer.immediate=function(e,t){return push(callbacks.immediate,e,t,function(){postMessage("@deferred","*")})}):defer.immediate=function(e,t){return push(callbacks.immediate,e,t,function(e){setTimeout(e,0)})},defer.timeout=function(e,t,a){const i=callbacks.timeout;return clear||(clear=defer.immediate(function(){clear=null,callbacks.timeout={}})),push(i[t]||(i[t]=[]),e,a,function(e){setTimeout(e,t)})},module.exports=defer;

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"_process":432,"mout/array/forEach":391,"mout/array/indexOf":392,"mout/time/now":430}],186:[function(require,module,exports){
"use strict";const indexOf=require("mout/array/indexOf"),forEach=require("mout/array/forEach"),prime=require("./index"),defer=require("./defer"),slice=Array.prototype.slice;let resetCount=0;const Emitter=prime({constructor:function(e){this._stoppable=e},on:function(e,t){const i=this._listeners||(this._listeners={}),s=i[e]||(i[e]=[]);return-1===indexOf(s,t)&&s.push(t),this},off:function(e,t){const i=this._listeners;if(i){const s=i[e];if(s){const r=indexOf(s,t);r>-1&&s.splice(r,1),s.length||delete i[e];for(const e in i)if(i.hasOwnProperty(e))return this;delete this._listeners}}return this},emit:function(e){const t=slice.call(arguments,1),i=()=>{const i=this._listeners;if(i){const s=i[e];s&&forEach(s.slice(0),e=>{const i=e.apply(this,t);if(this._stoppable)return i})}if(this._promiseWaiters&&this._promiseWaiters[e]){const i=this._promiseWaiters[e].slice();this._promiseWaiters[e]=[],i.forEach(e=>e(...t))}};if(t[t.length-1]===Emitter.EMIT_SYNC)t.pop(),i();else{const e=resetCount;defer.immediate(()=>{e===resetCount&&i()})}return this},reset:function(){resetCount++,this._listeners={}},whenNextEvent:function(e){return new Promise(t=>{this._promiseWaiters=this._promiseWaiters||{},this._promiseWaiters[e]=[...this._promiseWaiters[e]||[],t]})}});Emitter.EMIT_SYNC={},module.exports=Emitter;

},{"./defer":185,"./index":187,"mout/array/forEach":391,"mout/array/indexOf":392}],187:[function(require,module,exports){
"use strict";const hasOwn=require("mout/object/hasOwn"),mixIn=require("mout/object/mixIn"),create=require("mout/lang/createObject"),kindOf=require("mout/lang/kindOf");let hasDescriptors=!0;try{Object.defineProperty({},"~",{}),Object.getOwnPropertyDescriptor({},"~")}catch(t){hasDescriptors=!1}const hasEnumBug=!{valueOf:0}.propertyIsEnumerable("valueOf"),buggy=["toString","valueOf"],verbs=/^constructor|inherits|mixin$/,implement=function(t){const e=this.prototype;for(const r in t)if(!r.match(verbs)){if(hasDescriptors){const n=Object.getOwnPropertyDescriptor(t,r);if(n){Object.defineProperty(e,r,n);continue}}e[r]=t[r]}return hasEnumBug&&buggy.forEach(r=>{const n=t[r];n!==Object.prototype[r]&&(e[r]=n)}),this},prime=function(t){let e=t;"Function"===kindOf(e)&&(e={constructor:t});const r=e.inherits;let n;if(n=hasOwn(e,"constructor")?e.constructor:r?function(){return r.apply(this,arguments)}:function(){},r){mixIn(n,r);const t=r.prototype,e=n.prototype=create(t);n.parent=t,e.constructor=n}n.implement||(n.implement=implement);let o=e.mixin;if(o){"Array"!==kindOf(o)&&(o=[o]);for(let t=0;t<o.length;t++)n.implement(create(o[t].prototype))}return n.implement(e)};module.exports=prime;

},{"mout/lang/createObject":403,"mout/lang/kindOf":413,"mout/object/hasOwn":421,"mout/object/mixIn":423}],188:[function(require,module,exports){
"use strict";const indexOf=require("mout/array/indexOf"),prime=require("./index"),Map=prime({constructor:function(){this.length=0,this._values=[],this._keys=[]},set:function(t,s){const e=indexOf(this._keys,t);return-1===e?(this._keys.push(t),this._values.push(s),this.length++):this._values[e]=s,this},get:function(t){const s=indexOf(this._keys,t);return-1===s?null:this._values[s]},count:function(){return this.length},forEach:function(t,s){for(let e=0,n=this.length;e<n&&!1!==t.call(s,this._values[e],this._keys[e],this);e++);return this},map:function(t,s){const e=new Map;return this.forEach(function(n,i){e.set(i,t.call(s,n,i,this))},this),e},filter:function(t,s){const e=new Map;return this.forEach(function(n,i){t.call(s,n,i,this)&&e.set(i,n)},this),e},every:function(t,s){let e=!0;return this.forEach(function(n,i){t.call(s,n,i,this)||(e=!1)},this),e},some:function(t,s){let e=!1;return this.forEach(function(n,i){t.call(s,n,i,this)&&(e=!0)},this),e},indexOf:function(t){const s=indexOf(this._values,t);return s>-1?this._keys[s]:null},remove:function(t){const s=indexOf(this._values,t);return-1!==s?(this._values.splice(s,1),this.length--,this._keys.splice(s,1)[0]):null},unset:function(t){const s=indexOf(this._keys,t);return-1!==s?(this._keys.splice(s,1),this.length--,this._values.splice(s,1)[0]):null},keys:function(){return this._keys.slice()},values:function(){return this._values.slice()}}),map=function(){return new Map};map.prototype=Map.prototype,module.exports=map;

},{"./index":187,"mout/array/indexOf":392}],189:[function(require,module,exports){
"use strict";const prime=require("../../libs/prime"),map=require("mout/array/map"),push_=Array.prototype.push,slice_=Array.prototype.slice,Range=prime({constructor:function(t,n){this.update(t,n)},update:function(t,n){if(null!==t&&(this.start=t),null!==n&&(this.end=n),null===this.start||null===this.end||this.start>this.end)throw new Error(`invalid range: [${this.start}, ${this.end}]`);return this.length=this.end-this.start,this},copy:function(){return new Range(this.start,this.end)},above:function(t){return!!t&&this.start>=t.end},below:function(t){return!!t&&this.end<=t.start},adjacent:function(t){return!!t&&(this.end===t.start||this.start===t.end)},intersects:function(t){return!!t&&(!this.above(t)&&!this.below(t))},contains:function(t){return!!t&&(this.start<=t.start&&this.end>=t.end)},contained:function(t){let n;if(!(n=t instanceof Range?arguments:t))return!1;for(let t=0;void 0!==n[t];t++){const e=n[t];if(e.start<=this.start&&e.end>=this.end)return!0}return!1},fits:function(t,n){return!t&&!n||(t?n?this.start>=t.end&&this.end<=n.start:this.start>=t.end:this.end<=n.start)},between:function(t,n){return t||n?t?n?this.end>t.end&&this.start<n.start?new Range(Math.max(t.end,this.start),Math.min(n.start,this.end)):null:this.end<=t.end?null:new Range(Math.max(t.end,this.start),this.end):this.start>=n.start?null:new Range(this.start,Math.min(this.end,n.start)):this.copy()},intersection:function(t){const n=[];let e;e=t instanceof Range?arguments:t;for(let t=0;t<e.length;t++){const s=e[t];if(this.below(s))break;s.intersects(this)&&n.push(new Range(Math.max(this.start,s.start),Math.min(this.end,s.end)))}return n},subtract:function(t){const n=[];let e;e=t instanceof Range?arguments:t;for(let t=-1;t<e.length;t++){const s=e[t],r=e[t+1],i=this.between(s,r);i&&n.push(i)}return n},extract:function(t){const n=t instanceof Range?slice_.call(arguments):t.slice();for(let t=0;t<n.length;t++){const e=n[t-1],s=n[t];let r=null;if(this.below(s))r=new Range(s.start-this.length,s.end-this.length);else if(this.intersects(s)){const e=s.subtract(this);2===e.length?r=new Range(e[0].start,e[1].end-this.length):1===e.length?s.end>this.end?r=new Range(e[0].start-this.length,e[0].end-this.length):this.start>s.start&&(r=new Range(e[0].start,e[0].end)):n.splice(t--,1)}else n.splice(t,1,s.copy());r&&(e&&e.end===r.start?n.splice(t---1,2,new Range(e.start,r.end)):n.splice(t,1,r))}return n},insert:function(t){const n=t instanceof Range?slice_.call(arguments):t.slice();for(let t=0;t<n.length;t++){const e=n[t];this.start>=e.end?n.splice(t,1,e.copy()):this.start>e.start&&this.start<e.end?n.splice(t,1,new Range(e.start,this.start),new Range(this.start,e.end)):n.splice(t,1,new Range(e.start+this.length,e.end+this.length))}return this.merge(n)},merge:function(t){let n,e,s;if(!(n=map(n=t instanceof Range?arguments:t,function(t){return t.copy()})).length)return[this.copy()];for(e=-1,s=n.length;e<s;e++){const t=n[e],s=n[e+1],r=this.between(t,s);r&&(!t&&s?r.end===s.start?s.update(r.start,s.end):(e++,n.unshift(r)):t&&s?t.end===r.start&&r.end===s.start?(t.update(t.start,s.end),n.splice(1+e--,1)):t.end===r.start?t.update(t.start,r.end):r.end===s.start?s.update(r.start,s.end):n.splice(e+1,0,r):t&&!s&&(t.end===r.start?t.update(t.start,r.end):(e++,n.push(r))))}return n},remove:function(t){let n;n=t instanceof Range?arguments:t;const e=[];for(let t=0;t<n.length;t++){const s=n[t].subtract(this);s.length&&push_.apply(e,s)}return e},toIndices:function(){const t=[];for(let n=this.start;n<this.end;n++)t.push(n);return t},toString:function(){return`${[this.start,this.end]}`}});Range.fromString=function(t){const n=t.split(",");return new Range(+n[0],+n[1])},Range.fromIndices=function(t){t.sort(function(t,n){return t>n?1:-1});const n=[];let e,s;for(let r=0;r<t.length;r++){for(s=e=t[r];t[r+1]-t[r]==1;)s=t[r+1],r++;n.push(new Range(e,s+1))}return n},module.exports=Range;

},{"../../libs/prime":187,"mout/array/map":394}],190:[function(require,module,exports){
(function (global){
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.install=install;var _ravenJs=require("raven-js"),_ravenJs2=_interopRequireDefault(_ravenJs),_abba=require("../abba"),_abba2=_interopRequireDefault(_abba),_productState=require("../client-state/src/product-state"),_messageProxy=require("../message-proxy"),_debug=require("../debug"),_debug2=_interopRequireDefault(_debug);function _interopRequireDefault(e){return e&&e.__esModule?e:{default:e}}const debug=(0,_debug2.default)("sentry"),dsn="https://29161b091d014a3e9abe8f73f325d46b@sentry.io/57674",SAMPLE_RATE_ABBA="sentry-desktop-sample-rate-v2",SAMPLE_RATE_FLAG="sentry-sample-rate",errorsDuringInstall=[];function install(){function e(e){return errorsDuringInstall.push(e.error),!1}return window.addEventListener("error",e),Promise.all([_getAbbaSampleRate(),_getSessionId()]).then(t=>{let r=.1*parseFloat(t[0]);const a=t[1];(0,_productState.hasFlag)(SAMPLE_RATE_FLAG)&&(r=global.__spotify.product_state[SAMPLE_RATE_FLAG]);let n="production";(0,_productState.hasValue)("ta-environment",1)?n="ta":global.__spotify&&global.__spotify.developer_mode&&(n="development");const o={sampleRate:r,environment:n,autoBreadcrumbs:{console:!1},release:_getGlobal("client_version","0.0.0"),tags:{locale:_getGlobal("locale","en"),gitRevision:_getGlobal("app_manifest",{}).GitRevision,uuid:a}};debug("config",o),_ravenJs2.default.config(dsn,o).install(),errorsDuringInstall.forEach(e=>{debug("reporting queued error",e),_ravenJs2.default.captureException(e)}),window.removeEventListener("error",e),window.addEventListener("unhandledrejection",e=>{_ravenJs2.default.captureException(e.reason)})})}function _getGlobal(e,t){return global.__spotify&&global.__spotify.hasOwnProperty(e)?global.__spotify[e]:t}function _getAbbaSampleRate(){return _abba2.default.fetch([SAMPLE_RATE_ABBA]).then(e=>e[SAMPLE_RATE_ABBA]||0).catch(()=>"spotify:app:login"===_getGlobal("app_uri")?.5:0)}function _getSessionId(){return new Promise(e=>{(0,_messageProxy.messageProxy)({method:"GET",uri:"client-state",target:"top"},(t,r)=>{e(t?0:r.state.session_uuid)})})}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../abba":48,"../client-state/src/product-state":52,"../debug":59,"../message-proxy":165,"raven-js":436}],191:[function(require,module,exports){
"use strict";const $=require("./base"),trim=require("mout/string/trim"),forEach=require("mout/array/forEach"),filter=require("mout/array/filter"),indexOf=require("mout/array/indexOf");$.implement({setAttribute:function(t,e){return this.forEach(function(s){s.setAttribute(t,e)})},getAttribute:function(t){const e=this[0].getAttributeNode(t);return e&&e.specified?e.value:null},hasAttribute:function(t){const e=this[0];if(e.hasAttribute)return e.hasAttribute(t);const s=e.getAttributeNode(t);return!(!s||!s.specified)},removeAttribute:function(t){return this.forEach(function(e){const s=e.getAttributeNode(t);s&&e.removeAttributeNode(s)})}});const accessors={};forEach(["type","value","name","href","title","id"],function(t){accessors[t]=function(e){return void 0!==e?this.forEach(function(s){s[t]=e}):this[0][t]}}),forEach(["checked","disabled","selected"],function(t){accessors[t]=function(e){return void 0!==e?this.forEach(function(s){s[t]=!!e}):!!this[0][t]}});const classes=function(t){const e=trim(t).replace(/\s+/g," ").split(" "),s={};return filter(e,function(t){return""!==t&&!s[t]&&(s[t]=t)}).sort()};accessors.className=function(t){return void 0!==t?this.forEach(function(e){e.className=classes(t).join(" ")}):classes(this[0].className).join(" ")},$.implement({attribute:function(t,e){const s=accessors[t];let n;return s&&(n=s.call(this,e)),e&&(n=this.setAttribute(t,e)),null===e&&(n=this.removeAttribute(t)),void 0===e&&(n=this.getAttribute(t)),n}}),$.implement(accessors),$.implement({check:function(){return this.checked(!0)},uncheck:function(){return this.checked(!1)},disable:function(){return this.disabled(!0)},enable:function(){return this.disabled(!1)},select:function(){return this.selected(!0)},deselect:function(){return this.selected(!1)}}),$.implement({classNames:function(){return classes(this[0].className)},hasClass:function(t){return indexOf(this.classNames(),t)>-1},addClass:function(t){return this.forEach(function(e){const s=e.className,n=classes(`${s} ${t}`).join(" ");s!==n&&(e.className=n)})},removeClass:function(t){return this.forEach(function(e){const s=classes(e.className);forEach(classes(t),function(t){const e=indexOf(s,t);e>-1&&s.splice(e,1)}),e.className=s.join(" ")})},toggleClass:function(t,e){const s=void 0!==e?e:!this.hasClass(t);return s?this.addClass(t):this.removeClass(t),!!s}}),$.prototype.toString=function(){const t=this.tag(),e=this.id(),s=this.classNames();let n=t;return e&&(n+=`#${e}`),s.length&&(n+=`.${s.join(".")}`),n};const textProperty=null===document.createElement("div").textContent?"innerText":"textContent";$.implement({tag:function(){return this[0].tagName.toLowerCase()},html:function(t){return void 0!==t?this.forEach(function(e){e.innerHTML=t}):this[0].innerHTML},text:function(t){return void 0!==t?this.forEach(function(e){e[textProperty]=t}):this[0][textProperty]},data:function(t,e){switch(e){case void 0:return this.getAttribute(`data-${t}`);case null:return this.removeAttribute(`data-${t}`);default:return this.setAttribute(`data-${t}`,e)}}}),module.exports=$;

},{"./base":192,"mout/array/filter":390,"mout/array/forEach":391,"mout/array/indexOf":392,"mout/string/trim":429}],192:[function(require,module,exports){
(function (global){
"use strict";const prime=require("../../libs/prime"),forEach=require("mout/array/forEach"),map=require("mout/array/map"),filter=require("mout/array/filter"),every=require("mout/array/every"),some=require("mout/array/some"),doc=global.document||{};let index=0;const __dc=doc.__counter,counter=doc.__counter=(__dc?parseInt(__dc,36)+1:0).toString(36),key=`uid:${counter}`,uniqueID=function(e){return e===window?"window":e===document?"document":e===document.documentElement?"html":e[key]||(e[key]=(index++).toString(36))},instances=new WeakMap,$=prime({constructor:function e(t,n){if(!t)return this&&this.constructor===e?new Elements:null;let r,i;if(t.constructor!==Elements){if(r=new Elements,"string"==typeof t)return r.search?(r[r.length++]=n||document,r.search(t)):null;if(t.nodeType||t===window)r[r.length++]=t;else if(t.length){const o={};for(let u=0,c=t.length;u<c;u++){const c=e(t[u],n);if(c&&c.length)for(let e=0,t=c.length;e<t;e++){const t=c[e];o[i=uniqueID(t)]||(r[r.length++]=t,o[i]=!0)}}}}else r=t;if(!r.length)return null;if(1===r.length){const e=instances.get(r[0]);if(e)return e;instances.set(r[0],r)}return r}}),Elements=prime({inherits:$,constructor:function(){this.length=0},unlink:function(){return this.map(function(e){return instances.delete(e),e})},forEach:function(e,t){return forEach(this,e,t),this},map:function(e,t){return map(this,e,t)},filter:function(e,t){return filter(this,e,t)},every:function(e,t){return every(this,e,t)},some:function(e,t){return some(this,e,t)}});module.exports=$;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../libs/prime":187,"mout/array/every":389,"mout/array/filter":390,"mout/array/forEach":391,"mout/array/map":394,"mout/array/some":397}],193:[function(require,module,exports){
"use strict";const Map=require("../../libs/prime/map"),$=require("./events");require("./traversal"),$.implement({delegate:function(e,t,n){return this.forEach(function(r){const o=$(r),i=o._delegation||(o._delegation={}),s=i[e]||(i[e]={}),c=s[t]||(s[t]=new Map);if(c.get(n))return;const a=function(e){const r=$(e.target||e.srcElement),i=r.matches(t)?r:r.parent(t);let s;return i&&(s=n.call(o,e,i)),s};c.set(n,a),o.on(e,a)})},undelegate:function(e,t,n){return this.forEach(function(r){const o=$(r),i=o._delegation;if(!i)return;const s=i[e];if(!s)return;const c=s[t];if(!c)return;const a=c.get(n);if(a){o.off(e,a),c.remove(a),c.count()||delete s[t];let n=!0,r=!0;for(const e in s)if(s.hasOwnProperty(e)){n=!1;break}n&&delete i[e];for(const e in i)if(i.hasOwnProperty(e)){r=!1;break}r&&delete o._delegation}})}}),module.exports=$;

},{"../../libs/prime/map":188,"./events":194,"./traversal":197}],194:[function(require,module,exports){
"use strict";const Emitter=require("../../libs/prime/emitter"),$=require("./base");$.implement({on:function(t,e,n){return this.forEach(function(r){const i=$(r),o=t+(n?":capture":"");Emitter.prototype.on.call(i,o,e);const s=i._domListeners||(i._domListeners={});if(!s[o]){const e=function(t){Emitter.prototype.emit.call(i,o,t||window.event,Emitter.EMIT_SYNC)};r.addEventListener(t,e,n||!1),s[o]=e}})},off:function(t,e,n){return this.forEach(function(r){const i=$(r),o=t+(n?":capture":""),s=i._domListeners,c=i._listeners;if(s&&c){const n=s[o];if(n&&(Emitter.prototype.off.call(i,o,e),!i._listeners||!i._listeners[t])){r.removeEventListener(t,n,!1),delete s[t];for(const t in s)if(s.hasOwnProperty(t))return;delete i._domListeners}}})},emit:function(){const t=arguments;return this.forEach(function(e){Emitter.prototype.emit.apply($(e),t)})}}),module.exports=$;

},{"../../libs/prime/emitter":186,"./base":192}],195:[function(require,module,exports){
"use strict";const $=require("./base");require("./attributes"),require("./events"),require("./insertion"),require("./traversal"),require("./delegation"),module.exports=$;

},{"./attributes":191,"./base":192,"./delegation":193,"./events":194,"./insertion":196,"./traversal":197}],196:[function(require,module,exports){
"use strict";const $=require("./base");$.implement({appendChild:function(t){return this[0].appendChild($(t)[0]),this},insertBefore:function(t,e){return this[0].insertBefore($(t)[0],$(e)[0]),this},removeChild:function(t){return this[0].removeChild($(t)[0]),this},replaceChild:function(t,e){return this[0].replaceChild($(t)[0],$(e)[0]),this}}),$.implement({before:function(t){const e=$(t)[0],n=e.parentNode;return n&&this.forEach(function(t){n.insertBefore(t,e)}),this},after:function(t){const e=$(t)[0],n=e.parentNode;return n&&this.forEach(function(t){n.insertBefore(t,e.nextSibling)}),this},bottom:function(t){const e=$(t)[0];return this.forEach(function(t){e.appendChild(t)})},top:function(t){const e=$(t)[0];return this.forEach(function(t){e.insertBefore(t,e.firstChild)})}}),$.implement({insert:$.prototype.bottom,remove:function(){return this.forEach(function(t){const e=t.parentNode;e&&e.removeChild(t)})},replace:function(t){const e=$(t)[0];return e.parentNode.replaceChild(this[0],e),this}}),module.exports=$;

},{"./base":192}],197:[function(require,module,exports){
"use strict";var _slick=require("slick"),_slick2=_interopRequireDefault(_slick);function _interopRequireDefault(t){return t&&t.__esModule?t:{default:t}}const map=require("mout/array/map"),$=require("./base"),gen=function(t,n){return map(_slick2.default.parse(n||"*"),function(n){return`${t} ${n}`}).join(", ")},push_=Array.prototype.push;$.implement({search:function(t){if(1===this.length)return $(_slick2.default.search(t,this[0],new $));let n=[];for(let e=0;e<this.length;e++){const i=this[e];push_.apply(n,_slick2.default.search(t,i))}return(n=$(n))&&n.sort()},find:function(t){if(1===this.length)return $(_slick2.default.find(t,this[0]));for(let n=0;n<this.length;n++){const e=this[n],i=_slick2.default.find(t,e);if(i)return $(i)}return null},sort:function(){return _slick2.default.sort(this)},matches:function(t){return _slick2.default.matches(this[0],t)},contains:function(t){return _slick2.default.contains(this[0],t)},nextSiblings:function(t){return this.search(gen("~",t))},nextSibling:function(t){return this.find(gen("+",t))},previousSiblings:function(t){return this.search(gen("!~",t))},previousSibling:function(t){return this.find(gen("!+",t))},children:function(t){return this.search(gen(">",t))},firstChild:function(t){return this.find(gen("^",t))},lastChild:function(t){return this.find(gen("!^",t))},parent:function(t){const n=[];for(let e=0;e<this.length;e++){let i=this[e].parentNode;for(;i&&i!==document;){if(!t||_slick2.default.matches(i,t)){n.push(i);break}i=i.parentNode}}return $(n)},parents:function(t){const n=[];for(let e=0;e<this.length;e++){let i=this[e];for(;i&&i!==document;)t&&!_slick2.default.matches(i,t)||n.push(i),i=i.parentNode}return $(n)}}),module.exports=$;

},{"./base":192,"mout/array/map":394,"slick":442}],198:[function(require,module,exports){
"use strict";const $=require("../spotify-elements"),live=require("../live"),liburi=require("spotify-liburi"),center=require("./center"),IS_ADDED_PROPERTY="added",BUTTON_SELECTOR="[data-button=add]",JUSTCHANGED_CLASSNAME="just-changed",ADDED_CLASSNAME="added",INTERACTION_INTENT_ATTR="data-interaction-intent",INTERACTION_INTENT_SAVE="save",INTERACTION_INTENT_ADD="add",INTERACTION_INTENT_REMOVE="remove",INTERACTION_INTENT_FOLLOW="follow",INTERACTION_INTENT_UNFOLLOW="unfollow",INTERACTION_TARGET_ATTR="data-interaction-target",TOGGLE_FOLLOW_STATE_BUTTON="toggle-follow-state-button",SAVE_REMOVE_BUTTON="save-remove-button",changeHandlers={};let isAttached=!1;function getAddedClass(t){const e=t[0].closest("data-class-added");return e?e.getAttribute("data-class-added"):ADDED_CLASSNAME}function getURIFromNode(t){const e=t[0].closest("[data-uri]");return e?e.getAttribute("data-uri"):null}const eventHandlers={click:function(t,e){const a=$(e[0].closest("[data-uri]"));if(!a)return;let o=a.data("uri");if(!o)return;const n=liburi.from(o);n&&(n.type===liburi.Type.COLLECTION_ALBUM?o=liburi.albumURI(n.id).toURI():n.type===liburi.Type.COLLECTION_ARTIST&&(o=liburi.artistURI(n.id).toURI()));const s=getAddedClass(e),d={added:!a.hasClass(s)};e.addClass("just-changed"),e.on("mouseout",function t(a){a.target===e[0]&&(e.off("mouseout",t),e.removeClass("just-changed"))},!0),live(o).publish(d)},changeHandler:function(t,e,a,o){if("added"===e){0===t.setStateForURI(o,a)&&(live(o).off("update",changeHandlers[o]),delete changeHandlers[o])}}},actions={setStateForURI:function(t,e){let a=0;const o=$(document).search(BUTTON_SELECTOR);if(!o)return a;for(let n=0,s=o.length;n<s;n++){const s=$(o[n]);t===getURIFromNode(s)&&(a++,actions.setStateForButtonNode(s,e))}return a},setStateForButtonNode:function(t,e){const a=$(t[0].closest("[data-uri]"));if(!a)return;const o=getAddedClass(t);actions.setVisualState(e,a,t,o)},setVisualState:function(t,e,a,o){if(t){e.hasClass(o)||e.addClass(o);const t=a.data("tooltip-remove");t&&(a.setAttribute("data-tooltip",t),a.setAttribute("aria-label",t)),a.setAttribute("data-log-click","remove-button");const n=a.getAttribute(INTERACTION_TARGET_ATTR)===TOGGLE_FOLLOW_STATE_BUTTON?"unfollow":"remove";a.setAttribute(INTERACTION_INTENT_ATTR,n)}else{e.hasClass(o)&&e.removeClass(o);const t=a.data("tooltip-add");switch(t&&(a.setAttribute("data-tooltip",t),a.setAttribute("aria-label",t)),a.getAttribute(INTERACTION_TARGET_ATTR)){case SAVE_REMOVE_BUTTON:a.setAttribute(INTERACTION_INTENT_ATTR,"save");break;case TOGGLE_FOLLOW_STATE_BUTTON:a.setAttribute(INTERACTION_INTENT_ATTR,"follow");break;default:a.setAttribute(INTERACTION_INTENT_ATTR,"add")}a.setAttribute("data-log-click","add-button")}},addListenerForNode:function(t){const e=getURIFromNode(t);if(changeHandlers[e])return void live(e).get("added",function(e,a){if(e)throw e;actions.setStateForButtonNode(t,a)},live.ASAP);changeHandlers[e]=function(t){for(const a in t){if(!t.hasOwnProperty(a))continue;const o=t[a];eventHandlers.changeHandler(actions,a,o,e)}};const a=live(e);a.get("added",function(o,n){if(o)throw o;actions.setStateForButtonNode(t,n),a.on("update",changeHandlers[e])},live.ASAP)}},update=exports.update=function(t,e){if(isAttached)if(t&&$(t).matches(BUTTON_SELECTOR))actions.addListenerForNode($(t));else{const a=($(e)||$(t)||$(document)).search(BUTTON_SELECTOR);if(!a)return;for(let t=0,e=a.length;t<e;t++)actions.addListenerForNode($(a[t]))}},handleScrollShow=function(t){update(t.pageNode,t.nodes)};exports._classNames={ADDED:ADDED_CLASSNAME,JUSTCHANGED:"just-changed"},exports.attach=function(){isAttached||(isAttached=!0,$(document).delegate("click",BUTTON_SELECTOR,eventHandlers.click),center.on("scroll-show-before",handleScrollShow))},exports.detach=function(){isAttached&&(isAttached=!1,$(document).undelegate("click",BUTTON_SELECTOR,eventHandlers.click),center.off("scroll-show-before",handleScrollShow))};

},{"../live":148,"../spotify-elements":195,"./center":206,"spotify-liburi":450}],199:[function(require,module,exports){
"use strict";const $=require("../spotify-elements"),Navigator=require("../navigation/navigator"),SELECTOR="a",nav=new Navigator,handleAnchorClick=function(t,e){const a=e[0].getAttribute("href");a&&"#"!==a[0]&&(t.preventDefault(),nav.openURI(a))};let isAttached=!1;exports.attach=function(){isAttached||(isAttached=!0,$(document).delegate("click","a",handleAnchorClick))},exports.detach=function(){isAttached&&(isAttached=!1,$(document).undelegate("click","a",handleAnchorClick))},exports.update=function(){};

},{"../navigation/navigator":169,"../spotify-elements":195}],200:[function(require,module,exports){
"use strict";const modules=[require("./touch"),require("./pressed"),require("./loading"),require("./remove")];exports.attach=function(){modules.forEach(function(e){e.attach()})},exports.detach=function(){modules.forEach(function(e){e.detach()})},exports.update=function(){modules.forEach(function(e){e.update()})};

},{"./loading":201,"./pressed":202,"./remove":203,"./touch":204}],201:[function(require,module,exports){
"use strict";const CARD=".card",IMAGE_LOADING_TRANSITION=1e3;let currentCards=[];function addCardImage(t){let e;const r=t.querySelector("[data-image-url]");if(r&&(e=r.getAttribute("data-image-url")),e){const r=function(e){return()=>{t.classList.add("image-loaded"),clearTimeout(e)}},a=function(){t.classList.add("image-error")},d=setTimeout(function(){t.classList.add("image-delayed")},IMAGE_LOADING_TRANSITION),c=new Image;c.addEventListener("load",r(d)),c.addEventListener("error",a),c.src=e}}let isAttached=!1;exports.attach=function(){isAttached||(isAttached=!0)},exports.detach=function(){isAttached&&(isAttached=!1,currentCards=[])},exports.update=function(){if(!isAttached)return;currentCards=currentCards.filter(function(t){return t.closest("body")}),document.querySelectorAll(CARD).forEach(t=>{-1!==currentCards.indexOf(t)||(currentCards.push(t),addCardImage(t))})},exports._reset=function(){currentCards=[]};

},{}],202:[function(require,module,exports){
"use strict";const $=require("../../spotify-elements"),CARD="[data-card-pressed-container]",TRIGGER="[data-card-trigger-pressed-state]",doc=$(document);let pressedElement;function handleMouseDown(e,s){"button"!==e.target.nodeName.toLowerCase()&&2!==e.button&&(s[0].closest(CARD).classList.add("pressed"),pressedElement=s[0])}function handleMouseUp(e,s){s[0].closest(CARD).classList.remove("pressed"),pressedElement===s[0]&&(pressedElement=null)}function handleDragEnd(e,s){s[0].closest(CARD).classList.remove("pressed"),pressedElement===s[0]&&(pressedElement=null)}function handleDocumentMouseUp(){pressedElement&&(pressedElement.closest(CARD).classList.remove("pressed"),pressedElement=null)}let isAttached=!1;exports.attach=function(){isAttached||(isAttached=!0,doc.delegate("mousedown",TRIGGER,handleMouseDown),doc.delegate("mouseup",TRIGGER,handleMouseUp),doc.delegate("dragend",TRIGGER,handleDragEnd),doc.on("mouseup",handleDocumentMouseUp))},exports.detach=function(){isAttached&&(isAttached=!1,doc.undelegate("mousedown",TRIGGER,handleMouseDown),doc.undelegate("mouseup",TRIGGER,handleMouseUp),doc.undelegate("dragend",TRIGGER,handleDragEnd),doc.off("mouseup",handleDocumentMouseUp))},exports.update=function(){};

},{"../../spotify-elements":195}],203:[function(require,module,exports){
"use strict";const center=require("../center"),BUTTON="[data-card-remove-button]";function handleClick(t){const e=t.target;if(!e.matches(BUTTON))return;const c=e.closest("[data-uri]");if(!c)return;const n=c.getAttribute("data-uri");center.emit("card-remove",{uri:n,element:e}),t.preventDefault(),t.stopPropagation()}let isAttached=!1;exports.attach=function(){isAttached||(isAttached=!0,document.addEventListener("click",handleClick,!0))},exports.detach=function(){isAttached&&(isAttached=!1,document.removeEventListener("click",handleClick,!0))},exports.update=function(){};

},{"../center":206}],204:[function(require,module,exports){
"use strict";const $=require("../../spotify-elements"),CARD=".card",IMAGE_HIT_AREA=".card-image-hit-area",doc=$(document);let hoverActive=!1,touchArray=[];const addEvent=function(e){touchArray.push(e)};function getCards(){return doc.search(CARD)}function isCard(e){return"function"==typeof e.closest&&!!e.closest(CARD)}function handleEvent(e){const t=e.target;if(isCard(t))switch(e.type){case"touchstart":addEvent(e),hoverActive&&disableHover();break;case"touchmove":addEvent(e);break;case"touchend":t&&1===touchArray.length&&"touchstart"===touchArray[0].type&&(e.preventDefault(),t.click()),touchArray=[];break;case"contextmenu":addEvent(e);break;case"mousemove":hoverActive||enableHover()}}function disableHover(){const e=getCards();e&&(e.forEach(function(e){const t=$(e).find(IMAGE_HIT_AREA);t&&t.addClass("no-hover")}),hoverActive=!1)}function enableHover(){const e=getCards();e&&(e.forEach(function(e){const t=$(e).find(IMAGE_HIT_AREA);t&&t.removeClass("no-hover")}),hoverActive=!0)}let isAttached=!1;exports.attach=function(){isAttached||(isAttached=!0,doc.on("touchstart",handleEvent),doc.on("touchmove",handleEvent),doc.on("touchend",handleEvent),doc.on("mousemove",handleEvent),doc.on("contextmenu",handleEvent))},exports.detach=function(){isAttached&&(isAttached=!1,doc.off("touchstart",handleEvent),doc.off("touchmove",handleEvent),doc.off("touchend",handleEvent),doc.off("mousemove",handleEvent),doc.off("contextmenu",handleEvent))},exports.update=function(){},exports._reset=function(){hoverActive=!0};

},{"../../spotify-elements":195}],205:[function(require,module,exports){
(function (global){
"use strict";const $=require("../spotify-elements"),doc=$(document),win=$(window),SWIPE_SENSITIVITY=1,SCROLL_LOCK_LIMIT=10,SWIPE_LAG=14,carouselPosition=function(t){return t.style.left||"0"},getCarouselObjectsWidth=function(t){const e=t.children;return e?{itemWidth:parseFloat(global.getComputedStyle(e[0]).width),carouselInnerWidth:parseFloat(global.getComputedStyle(t).width),carouselTotalWidth:t.scrollWidth}:null},calculateMinLeftPixels=function(t){let e=0;const a=getCarouselObjectsWidth(t);if(!a)return e;const n=Math.round(a.carouselInnerWidth/a.itemWidth),o=Math.round(a.carouselTotalWidth/a.itemWidth),l=Math.ceil(o/n);return e=-a.carouselInnerWidth*(l-1)},getNextPageInPercent=function(t,e,a){const n=e.clientWidth,o=calculateMinLeftPixels(e),l=t.endsWith("%"),c=parseInt(t,10);let s;return l?s=a?c+100:c-100:(s=Math.abs(c/n),0!==c||a?c===o&&a?s=-100*(s-1):(s=a?Math.floor(s):Math.ceil(s),s*=-100):s=-100),s},resetTransitions=function(t){t&&$(t).removeClass("crsl-inner-drag").removeClass("crsl-inner-swipe")},updateButtonStates=function(t,e){const a=$(`[data-carousel=${t}][data-button=carousel-right]`),n=$(`[data-carousel=${t}][data-button=carousel-left]`),o=$(`[data-carousel=${t}][data-carousel-main]`),l=$(o).search("[data-carousel-inner]")[0];let c;c="number"==typeof e?e:l.style.left?parseInt(l.style.left,10):0;const s=l.clientWidth-c/100*l.clientWidth+10>l.scrollWidth;l.clientWidth===l.scrollWidth&&(l.style.left="0%"),c>=0?n.setAttribute("disabled","disabled"):n.removeAttribute("disabled"),s?a.setAttribute("disabled","disabled"):a.removeAttribute("disabled")},handleButtonClick=function(t,e){if(t.hasAttribute("disabled"))return;const a=t.data("carousel"),n=$(`[data-carousel=${a}][data-carousel-main] [data-carousel-inner]`)[0],o=carouselPosition(n);let l;if(o){l=getNextPageInPercent(o,n,e)}else l=e?0:-100;resetTransitions(n),updateButtonStates(a,l),n.style.left=`${l}%`},handleClickLeft=function(t,e){handleButtonClick(e,!0)},handleClickRight=function(t,e){handleButtonClick(e,!1)},getCarouselInner=function(t){return t.search("[data-carousel-inner]")},handleTouchStart=function(t,e){let a=!1;function n(t){a?t.preventDefault():(doc.undelegate("touchmove","[data-carousel]",h),doc.undelegate("touchend","[data-carousel]",g))}doc.on("scroll",n);let o,l,c,s=getCarouselInner(e);if(!s)return;s=s[0];const r=calculateMinLeftPixels(s);if(0===r)return;doc.delegate("touchmove","[data-carousel]",h),doc.delegate("touchend","[data-carousel]",g),t.touches&&(o=t.touches[0].pageX,l=o);const i=function(){s&&$(s).addClass("crsl-inner-drag").removeClass("crsl-inner-swipe")},u=function(t){const e=t.endsWith("px");let a=parseFloat(t);if(!e){const e=Math.abs(t/100),n=getCarouselObjectsWidth(s);n&&(a=-n.carouselInnerWidth*e)}return a},d=function(t){let e=Math.min(t,0);return e=Math.max(e,r)};function h(){if(s&&(i(),t.touches)){const e=t.touches[0].pageX;c=l-e;let n=carouselPosition(s),o=(n=u(n,s))-c;o=d(o,r),s.style.left=`${o}px`,l=e,c>SCROLL_LOCK_LIMIT&&(a=!0),a&&t.preventDefault()}}const f=function(t){s&&$(s).addClass("crsl-inner-swipe").removeClass("crsl-inner-drag");let e=carouselPosition(s);e=u(e,s);const a=getCarouselObjectsWidth(s),n=a?parseInt(a.itemWidth,10):null;if(!n)return;let o=e+n*(-t/14);o=d(o,r),s.style.left=`${o}px`},b=function(){const t=e.data("carousel");let a=carouselPosition(s);a=u(a,s);const n=$(`[data-carousel=${t}][data-button=carousel-right]`),o=$(`[data-carousel=${t}][data-button=carousel-left]`);Math.round(a)<=Math.round(r)?n.setAttribute("disabled","disabled"):n.removeAttribute("disabled"),a>=0?o.setAttribute("disabled","disabled"):o.removeAttribute("disabled")};function g(){doc.undelegate("touchmove","[data-carousel]",h),doc.undelegate("touchend","[data-carousel]",g),doc.off("scroll",n),s&&(Math.abs(c)>SWIPE_SENSITIVITY&&f(c),b(e))}},updateAllButtons=function(t){if(t&&t.ownerDocument&&!t.ownerDocument.body.contains(t))return;const e=($(t)||doc).search("[data-carousel-main]");e&&e.forEach(function(t){updateButtonStates($(t).data("carousel"))})};let isAttached=!1;exports.update=function(t){isAttached&&updateAllButtons(t)},exports.attach=function(){isAttached||(isAttached=!0,doc.delegate("click","[data-button=carousel-right]",handleClickRight),doc.delegate("click","[data-button=carousel-left]",handleClickLeft),doc.delegate("touchstart","[data-carousel][data-carousel-main]",handleTouchStart),win.on("resize",updateAllButtons))},exports.detach=function(){isAttached&&(isAttached=!1,doc.undelegate("click","[data-button=carousel-right]",handleClickRight),doc.undelegate("click","[data-button=carousel-left]",handleClickLeft),doc.undelegate("touchstart","[data-carousel][data-carousel-main]",handleTouchStart),win.off("resize",updateAllButtons))};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../spotify-elements":195}],206:[function(require,module,exports){
"use strict";const Emitter=require("../../libs/prime/emitter");module.exports=new Emitter;

},{"../../libs/prime/emitter":186}],207:[function(require,module,exports){
(function (global){
"use strict";const $=require("../spotify-elements"),live=require("../live"),selection=require("./selection"),wrappedUriUtils=require("../live-wrapped-uri"),cosmos=require("../cosmos-api").default,liburi=require("spotify-liburi");let getMetadataForUris;const CONTEXTMENU=["a[data-uri]","[data-contextmenu]"].join(","),makeContextMenuData=function(t,e,n,i,o){const a=[];return t.forEach(t=>{if(void 0!==t){const n=t.keys||[],i=t.indices||[];let o=e||i[0];o=void 0===o?null:o;const s=t.uri,r={uri:s,keys:n,indices:i,primaryIndex:o},u=t.origin;if(u){if(null!==o){const t=live(s).get("rows"),e=live(u.uri).get("rows");if(t&&e){const n=t.keys[o];u.primaryIndex=e.indexOf(n)}}r.origin=u}a.push(r)}}),{contexts:a,x:i,y:o,uris:n}},handleContextMenuActiveClass=function(t){const e=t.parents("[data-contextmenu-spy]"),n=$([t,e]);n.addClass("contextmenu-active"),setTimeout(()=>{const t=cosmos.resolver.subscribe({url:"sp://messages/v1/context_menu_state"},function(e,i){e||"hide"!==i.getJSONBody().state||(n.removeClass("contextmenu-active"),t.cancel())})},0)},showContextMenu=function(t){const e=global.__spotify.app_uri,n="collection"===liburi.from(e).id;if(t.appURI=e,t.entityURI=live("spotify:application").get("state")?live("spotify:application").get("state").getURI():null,getMetadataForUris)getMetadataForUris(t.uris,e=>{t.metadata=e,live("spotify:client").emit("show-context-menu",t)});else{t.metadata=[],t.uris.forEach(e=>{const i=!!n||live(e).get("added");void 0!==i&&t.metadata.push({uri:e,added:i})}),live("spotify:client").emit("show-context-menu",t)}},handleContextMenuEvent=function(t,e){t.preventDefault(),t.stopPropagation();const n=t.clientX,i=t.clientY;if(handleContextMenuActiveClass(e),"a"===e[0].tagName.toLowerCase()){const t=e.data("uri");t&&showContextMenu({uris:[t],x:n,y:i})}else{const t=e.parent("[data-list]"),o=+e.data("index");let a=!1;const s=selection.getIndicesPerList();if(t&&!(a=selection.isNodeSelected(e))){selection.clear();const e=t.getAttribute("data-uri");e&&selection.add(e,o)}const r=a&&-1!==o?selection.getUris():[e.data("uri")];showContextMenu(makeContextMenuData(s,o,r,n,i))}},handleContextMenuButton=function(t,e){let n,i=e.data("uri")||(n=e.parent("[data-uri]"))&&n.data("uri");if(!i)return;i=wrappedUriUtils.getOriginUri(i)||i;const o=(n=e.parent("[data-list][data-uri]"))&&n.data("uri"),a=(n=e.parent("[data-index]"))&&+n.data("index"),s=$(e[0].closest('[data-button="contextmenu"]')),r=(s||n||e)[0].getBoundingClientRect();let u=r.left+r.width/2,c=r.top+r.height;c>window.innerHeight&&(c=window.innerHeight-1),u>window.innerWidth&&(u=window.innerWidth-1);const d=null===a||void 0===a?null:[a];let l;if(o){if(l={uri:o},d){l.indices=d;const t=live(o).get("rows");l.keys=t?d.map(function(e){return t.keys[e]}):[]}const t=wrappedUriUtils.getOriginUri(o);if(t&&(l.origin={uri:t},d)){const e=live(o).get("rows"),n=live(t).get("rows");if(e&&n){const t=d.map(function(t){const i=e.keys[t];return n.indexOf(i)}),i=d.map(function(t){return e.keys[t]});l.origin.indices=t,l.origin.keys=i}}}showContextMenu(makeContextMenuData([l],a,[i],u,c)),handleContextMenuActiveClass(s)};let isAttached=!1;exports.attach=function(){isAttached||(isAttached=!0,$(document).delegate("contextmenu",CONTEXTMENU,handleContextMenuEvent),$(document).delegate("click","[data-button=contextmenu]",handleContextMenuButton))},exports.detach=function(){isAttached&&(isAttached=!1,$(document).undelegate("contextmenu",CONTEXTMENU,handleContextMenuEvent),$(document).undelegate("click","[data-button=contextmenu]",handleContextMenuButton))},exports.update=function(){},exports.setMetadataRequestFunction=((t=null)=>{getMetadataForUris=t});

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../cosmos-api":54,"../live":148,"../live-wrapped-uri":147,"../spotify-elements":195,"./selection":266,"spotify-liburi":450}],208:[function(require,module,exports){
"use strict";const hooks=require("../util/hooks"),QUEUE_URI="spotify:internal:queue:future";function onListDropValidation(t,o,i,a,n){const e=i.getAttribute("data-uri");e&&e===QUEUE_URI&&(-1!==n||(t.valid=!1))}function attach(){hooks.add("list-drop-validation",onListDropValidation)}function detach(){hooks.remove("list-drop-validation",onListDropValidation)}exports.attach=attach,exports.detach=detach;

},{"../util/hooks":217}],209:[function(require,module,exports){
"use strict";const $=require("../../../spotify-elements"),liburi=require("spotify-liburi"),live=require("../../../live"),intersection=require("mout/array/intersection"),hooks=require("../util/hooks"),eventModel=require("../util/eventmodel"),selection=require("../../selection"),SELECTOR_LIST="[data-list]",SELECTOR_LIST_ITEM="[data-list-item]",SELECTOR_DRAGGABLE="a, [draggable]",ATTR_TARGET="data-drop-target";let dragFolderElement=null;function onDragStart(t,e){if(e.closest("[data-glue-draggable]"))return;dragFolderElement=null;const i=selection.getUris();if(i.length>1)return;const o=i[0],n=o&&liburi.fromString(o);if(n&&n.type===liburi.Type.FOLDER){const t=selection.getNodes();for(let e=0,i=t.length;e<i;e++){const i=t[e];if(i.getAttribute("data-uri")===o){dragFolderElement=i;break}}}}function onDragEnd(){dragFolderElement=null}function onSetDragData(t,e,i){if("spotify:rootlist"!==i){let i=0;for(let t=0,o=e.length;t<o&&liburi.isPlaylistV1OrV2(e[t]);t++){live(e[t]).get("added")&&i++}i===e.length&&t.dataTransfer.setData("text/x-spotify-only-followed-playlists","")}}function onListDropValidation(t,e,i,o){if("spotify:rootlist"===i.getAttribute("data-uri")){if(hasOnlyFollowedPlaylists(e))return void(t.valid=!1);if(isInsideDraggedFolder(e,o))return void(t.valid=!1);if(isInFolderBottomHalf(e)&&("drop"!==e.type||!isMatchingTarget(e,i)))return void(t.valid=!1)}}function onTargetValidation(t,e,i){const o=i.closest(SELECTOR_LIST);if(o){if("spotify:rootlist"===o.getAttribute("data-uri")){if(hasOnlyFollowedPlaylists(e))return void(t.valid=!1);if("dragleave"!==e.type&&isMatchingTarget(e,o)){const i=getFolderNode(e);if(i)return void(isBelowMiddleOfNode(e.clientY,i)?t.valid=!0:t.valid=!1)}}}}function onGetMoveIndices(t,e,i){if("spotify:rootlist"===t){const t=i[0],o=e.get(t),n=o&&o.get("playlist"),r=n&&n.uri;if((r&&liburi.fromString(r).type)===liburi.Type.FOLDER){if(1===i.length){const o=getFolderLength(e,r,t);for(let e=1;e<=o;e++)i.push(t+e)}if(1===i.length)return void(i.length=0);const o=e.get(i[i.length-1]),n=o&&o.get("playlist");if((n&&n.uri)!==`${r}:end`)return void(i.length=0)}}}function hasOnlyFollowedPlaylists(t){return t.dataTransfer.types.indexOf("text/x-spotify-only-followed-playlists")>-1}function isInsideDraggedFolder(t,e){if(dragFolderElement){const i="below"===e?getLastRowNode():getRowNode(t);if(i){let o=+i.getAttribute("data-index");if("inside"===e&&(isBelowMiddleOfNode(t.clientY,i)||o--),isIndexInsideDraggedFolder(o))return!0}}return!1}function isInFolderBottomHalf(t){const e=getFolderNode(t);return!!e&&isBelowMiddleOfNode(t.clientY,e)}function isBelowMiddleOfNode(t,e){const i=e.getBoundingClientRect();return t>=i.top+i.height/2}function isIndexInsideDraggedFolder(t){if(!dragFolderElement)return!1;const e=live("spotify:rootlist").get("rows");if(!e)return!1;const i=dragFolderElement.getAttribute("data-uri");if(!i)return!1;const o=+dragFolderElement.getAttribute("data-index"),n=o+getFolderLength(e,i,o);return o>-1&&n>o&&t>=o&&t<=n}function isMatchingTarget(t,e){const i=t.dataTransfer.types,o=e.getAttribute(ATTR_TARGET);if(o){if(intersection(o.split("|"),i).length>0)return!0}return!1}function getFolderNode(t){const e=getRowNode(t);if(e){const t=e.getAttribute("data-uri"),i=liburi.from(t);if(i&&i.type===liburi.Type.FOLDER)return e}return null}function getRowNode(t){return t.target.closest(SELECTOR_LIST_ITEM)}function getLastRowNode(){const t=$(SELECTOR_LIST),e=t&&t[t.length-1];if(e){const t=$(e).search(SELECTOR_LIST_ITEM),i=t&&t[t.length-1];if(i)return i}return null}function getFolderLength(t,e,i){let o=t.get(i),n=o&&o.get("playlist"),r=n&&n.uri;if(r!==e)return 0;const l=`${e}:end`;let a=0;for(let e=i+1,d=t.length;e<d&&(a++,(r=(n=(o=t.get(e))&&o.get("playlist"))&&n.uri)!==l);e++);return a}function attach(){eventModel.delegate("dragstart",SELECTOR_DRAGGABLE,onDragStart),eventModel.delegate("dragend","body",onDragEnd),hooks.add("set-drag-data",onSetDragData),hooks.add("list-drop-validation",onListDropValidation),hooks.add("target-validation",onTargetValidation),hooks.add("get-move-indices",onGetMoveIndices)}function detach(){eventModel.undelegate("dragstart",SELECTOR_DRAGGABLE,onDragStart),eventModel.undelegate("dragend","body",onDragEnd),hooks.remove("set-drag-data",onSetDragData),hooks.remove("list-drop-validation",onListDropValidation),hooks.remove("target-validation",onTargetValidation),hooks.remove("get-move-indices",onGetMoveIndices)}exports.attach=attach,exports.detach=detach;

},{"../../../live":148,"../../../spotify-elements":195,"../../selection":266,"../util/eventmodel":216,"../util/hooks":217,"mout/array/intersection":393,"spotify-liburi":450}],210:[function(require,module,exports){
"use strict";const liburi=require("spotify-liburi"),sortUriUtils=require("../../../live-sort-uri"),hooks=require("../util/hooks"),eventModel=require("../util/eventmodel"),selection=require("../../selection"),SELECTOR_DRAGGABLE="a, [draggable]";let dragSelectionState=null;function onDragStart(t,i){i.closest("[data-glue-draggable]")||(dragSelectionState=selection.getIndicesPerList())}function onDragEnd(){dragSelectionState=null}function onListDropValidation(t,i,e){const a=e.getAttribute("data-uri");a&&sortUriUtils.isValid(a)&&"drop"!==i.type&&(t.valid=!1)}function onListTargetValidation(t,i){const e=i.getAttribute("data-uri");e&&sortUriUtils.isValid(e)&&(dragSelectionState?1===dragSelectionState.length&&dragSelectionState[0].uri!==e&&(t.valid=!0):t.valid=!0)}function onIsListOfTracks(t,i,e){if(sortUriUtils.isValid(e)){const i=sortUriUtils.getOriginUri(e);liburi.isPlaylistV1OrV2(i)&&(t.valid=!0)}}function attach(){eventModel.delegate("dragstart",SELECTOR_DRAGGABLE,onDragStart),eventModel.delegate("dragend","body",onDragEnd),hooks.add("list-drop-validation",onListDropValidation),hooks.add("list-target-validation",onListTargetValidation),hooks.add("is-list-of-tracks",onIsListOfTracks)}function detach(){eventModel.undelegate("dragstart",SELECTOR_DRAGGABLE,onDragStart),eventModel.undelegate("dragend","body",onDragEnd),hooks.remove("list-drop-validation",onListDropValidation),hooks.remove("list-target-validation",onListTargetValidation),hooks.remove("is-list-of-tracks",onIsListOfTracks)}exports.attach=attach,exports.detach=detach;

},{"../../../live-sort-uri":146,"../../selection":266,"../util/eventmodel":216,"../util/hooks":217,"spotify-liburi":450}],211:[function(require,module,exports){
(function (global){
"use strict";const liburi=require("spotify-liburi"),selection=require("../selection"),hooks=require("./util/hooks"),eventModel=require("./util/eventmodel"),itemText=require("./util/itemtext"),getLogContext=require("../util/get-log-context"),SELECTOR_DRAGGABLE="a, [draggable]";function onDragStart(t,e){if(e.closest("[data-glue-draggable]"))return;if(selection.isNodeSelected(e)){const r=selection.getUris();if(r.length>0){const i=selection.getIndicesPerList(),n=1===i.length?i[0]&&i[0].uri:null;setEventData(t,r,null,n||null,getLogContext(e))}}else{let r=e.getAttribute("data-uri");if(!r){const t=liburi.from(e.getAttribute("href"));r=t?t.toURI():""}const i=itemText.getForElement(e);r&&setEventData(t,[r],[i],null,getLogContext(e))}}function setEventData(t,e,r,i,n){const a=getUrlsPerMimeType(e),o=getUrlsForUris(e),s=o.join("\n"),l=getLinkHTML(e,o,r);t.dataTransfer.setData("text/uri-list",s);for(const e in a){if(!a.hasOwnProperty(e))continue;const r=a[e];t.dataTransfer.setData(e,r.join("\n"))}t.dataTransfer.setData("text/plain",s),t.dataTransfer.setData("text/html",l),i&&(t.dataTransfer.setData("text/x-spotify-data-context",i),t.dataTransfer.setData(`text/x-spotify-data-context-${i}`,"")),n&&t.dataTransfer.setData("text/x-spotify-data-log-context",n),t.dataTransfer.setData("text/x-spotify-data-app-uri",global.__spotify&&global.__spotify.app_uri||null),hooks.run("set-drag-data",t,e,i)}function getUrlsPerMimeType(t){const e={};for(let r=0,i=t.length;r<i;r++){const i=t[r],n=getMimeType(i);(e[n]||(e[n]=[])).push(getShareLink(i))}return e}function getUrlsForUris(t){const e=new Array(t.length);for(let r=0,i=t.length;r<i;r++)e[r]=getShareLink(t[r]);return e}function getShareLink(t){const e=liburi.from(t);return e?e.toOpenURL():t}function getMimeType(t){const e="text/x-spotify-",r=liburi.from(t);if(r){const t=r.type;if(t===liburi.Type.TRACK||t===liburi.Type.LOCAL)return`${e}tracks`;if(t===liburi.Type.ALBUM||t===liburi.Type.LOCAL_ALBUM)return`${e}albums`;if(t===liburi.Type.ARTIST||t===liburi.Type.LOCAL_ARTIST)return`${e}artists`;if(t===liburi.Type.USER||t===liburi.Type.PROFILE)return`${e}users`;if(t===liburi.Type.PLAYLIST||t===liburi.Type.PLAYLIST_V2)return`${e}playlists`;if(t===liburi.Type.FOLDER)return`${e}folders`;if(t===liburi.Type.STATION&&!(r.args.length>2&&"cluster"===r.args[2]))return`${e}stations`;if(t===liburi.Type.EPISODE)return`${e}episodes`}return`${e}unknown`}function getLinkHTML(t,e,r){let i="";for(let n=0,a=t.length;n<a;n++){const a=r&&r[n]||itemText.getForUri(t[n]);i+=`<a href="${e[n]}">${a}</a>`,n<t.length-1&&(i+="<br>")}return i}function attach(){eventModel.delegate("dragstart",SELECTOR_DRAGGABLE,onDragStart)}function detach(){eventModel.undelegate("dragstart",SELECTOR_DRAGGABLE,onDragStart)}exports.attach=attach,exports.detach=detach;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../selection":266,"../util/get-log-context":280,"./util/eventmodel":216,"./util/hooks":217,"./util/itemtext":218,"spotify-liburi":450}],212:[function(require,module,exports){
"use strict";const liburi=require("spotify-liburi"),defer=require("../../../libs/prime/defer"),selection=require("../selection"),eventModel=require("./util/eventmodel"),itemText=require("./util/itemtext"),i18n=require("../i18n/index"),SELECTOR_DRAGGABLE="a, [draggable]",DRAGIMAGE_POS_X=-10,DRAGIMAGE_POS_Y=-5;let dragImageElement=null,dragImageShelter=null;function onDragStart(e,t){if(t.closest("[data-glue-draggable]"))return;let r="";if(selection.isNodeSelected(t)){const e=selection.getUris();r=1===e.length?itemText.getForUri(e[0]):getLocalizedTypeFromUris(e)}else r=itemText.getForElement(t);const a=getDragImage(r);e.dataTransfer.setDragImage(a,DRAGIMAGE_POS_X,DRAGIMAGE_POS_Y),removeDragImage()}function getDragImage(e){return dragImageElement||((dragImageElement=document.createElement("div")).className="dnd-image"),dragImageShelter||((dragImageShelter=document.createElement("div")).className="dnd-image-shelter"),dragImageElement.textContent=e,document.body.appendChild(dragImageElement),document.body.appendChild(dragImageShelter),dragImageElement}function removeDragImage(){defer.immediate(function(){dragImageElement&&dragImageElement.parentNode&&dragImageElement.parentNode.removeChild(dragImageElement),dragImageShelter&&dragImageShelter.parentNode&&dragImageShelter.parentNode.removeChild(dragImageShelter)})}function getLocalizedTypeFromUris(e){let t="item";const r=liburi.from(e[0]),a=r&&r.type;if(a){t=a;for(let r=0,n=e.length;r<n;r++){const n=liburi.from(e[r]);if(!n||n.type!==a){t="item";break}}}"profile"===t&&(t="user");const n=`${t}s`;let g=i18n.get(`drag_tooltip_many_${n}`,e.length);return g===`drag_tooltip_many_${n}`&&"items"!==n&&(g=i18n.get("drag_tooltip_many_items",e.length)),g||n}function attach(){eventModel.delegate("dragstart",SELECTOR_DRAGGABLE,onDragStart)}function detach(){eventModel.undelegate("dragstart",SELECTOR_DRAGGABLE,onDragStart)}exports.attach=attach,exports.detach=detach;

},{"../../../libs/prime/defer":185,"../i18n/index":222,"../selection":266,"./util/eventmodel":216,"./util/itemtext":218,"spotify-liburi":450}],213:[function(require,module,exports){
"use strict";const dragDataModule=require("./dragdata"),dragImageModule=require("./dragimage"),targetModule=require("./target"),listModule=require("./list"),sortlistModule=require("./custom/sortlist"),rootlistModule=require("./custom/rootlist"),queueModule=require("./custom/queue");function attach(){dragDataModule.attach(),dragImageModule.attach(),targetModule.attach(),listModule.attach(),queueModule.attach(),sortlistModule.attach(),rootlistModule.attach()}function detach(){dragDataModule.detach(),dragImageModule.detach(),targetModule.detach(),listModule.detach(),queueModule.detach(),sortlistModule.detach(),rootlistModule.detach()}exports.attach=attach,exports.detach=detach,exports.update=function(){};

},{"./custom/queue":208,"./custom/rootlist":209,"./custom/sortlist":210,"./dragdata":211,"./dragimage":212,"./list":214,"./target":215}],214:[function(require,module,exports){
"use strict";const $=require("../../spotify-elements"),intersection=require("mout/array/intersection"),Range=require("../../range2"),live=require("../../live"),liburi=require("spotify-liburi"),listOperations=require("../../../libs/live-list-operations"),hooks=require("./util/hooks"),eventModel=require("./util/eventmodel"),selection=require("../selection"),SELECTOR_DROP_TARGET="[data-drop-target]",SELECTOR_LIST="[data-list]",SELECTOR_LIST_ITEM="[data-list-item]",SELECTOR_LIST_TARGET="[data-drop-target], body",SELECTOR_DRAGGABLE="a, [draggable]",ATTR_TARGET="data-drop-target";let dropIndicator=null,draggedLinkContext=null;const disabledLists={},cachedSelectionState=function(){let t={lastTime:0,lastValue:null};return{get:function(){const e=Date.now();return e-t.lastTime>500&&(t={lastValue:selection.getIndicesPerList(),lastTime:e}),t.lastValue},clear:function(){t.lastTime=0}}}();function onDragStart(t,e){if(e.closest("[data-glue-draggable]"))return;draggedLinkContext=null,cachedSelectionState.clear();const n=getMatchingTarget(t);if(n){if($(n).matches(SELECTOR_LIST)){const o=n.getAttribute("data-uri");if("a"===e.tagName.toLowerCase()&&(draggedLinkContext=o),disabledLists[o])return void t.preventDefault();const i=getRowNode(t);if(i){const e=getTargetIndex(t.clientY,i);-1!==e&&t.dataTransfer.setData("text/x-spotify-data-log-source-index",e)}}}}function onDragOver(t,e){let n=!1,o=null;const i=e===document.body;let r=null;if(r=i?getListTargetFromBody(t):getMatchingListTarget(t)){const e=i?"below":"inside";let a=-1;(o="below"===e?getLastRowFromLastList():getRowNode(t))&&(a=getTargetIndex(t.clientY,o)),validateListDrop(t,r,r.getAttribute("data-uri"),e,a)&&(i?n=!0:o&&(n=!0))}if(n)t.preventDefault(),i?showDropIndicatorBelowList(r):o&&showDropIndicatorForRow(o,t.clientY);else{hideDropIndicator();const n={valid:!1};if(r&&hooks.run("list-target-validation",n,r),n.valid)t.preventDefault();else if(!i&&r){const n={valid:!1};hooks.run("target-validation",n,t,e),n.valid||(t.dataTransfer.dropEffect="none")}}}function onDragLeave(){hideDropIndicator()}function onDragEnd(){hideDropIndicator(),draggedLinkContext=null}function onDrop(t,e){hideDropIndicator();const n=e===document.body;let o=null;if(o=n?getListTargetFromBody(t):getMatchingListTarget(t)){const e=n?"below":"inside";let i=-1;const r="below"===e?getLastRowFromLastList():getRowNode(t);r&&(i=getTargetIndex(t.clientY,r));const a=o.getAttribute("data-uri");validateListDrop(t,o,a,e,i)&&a&&(performListChangesForEvent(t,o,a,e),t.handled=!0)}}function showDropIndicatorBelowList(t){const e=t.getBoundingClientRect();showDropIndicator(e.left,e.bottom,e.width)}function showDropIndicatorForRow(t,e){const n=isBelowMiddleOfNode(e,t),o=t.getBoundingClientRect();showDropIndicator(o.left,o.top+(n?o.height:0),o.width)}function showDropIndicator(t,e,n){const o=window.pageXOffset+t,i=window.pageYOffset+e,r=n;dropIndicator||((dropIndicator=document.createElement("div")).className="tr-drag-indicator"),dropIndicator.style.left=`${o}px`,dropIndicator.style.width=`${r}px`,dropIndicator.style.top=`${i}px`,dropIndicator.parentNode||document.body.appendChild(dropIndicator)}function hideDropIndicator(){dropIndicator&&dropIndicator.parentNode&&dropIndicator.parentNode.removeChild(dropIndicator)}function performListChangesForEvent(t,e,n,o){const i=live(n).get("rows");if(!i)return;let r=0;if("below"===o){const e=getLastRowFromLastList();e&&(r=getTargetIndex(t.clientY,e))}else{const e=getRowNode(t);if(!e)return;r=getTargetIndex(t.clientY,e)}const a=t.dataTransfer.getData("text/x-spotify-data-context");a&&a===n?performMoveChanges(n,i,r):performInsertChanges(t,e,n,i,r),t.data={targetIndex:r}}function performMoveChanges(t,e,n){const o=getMoveIndices(t,e);if(0===o.length)return;const i=listOperations.getMoveOperations(o,n);0!==i.length&&(e.publish(i),temporarilyDisableList(t,e))}function performInsertChanges(t,e,n,o,i){getInsertValues(t,e,o,n,function(t,e){if(t)return;if(0===e.length)return;const r=[{type:"insert",index:i,values:e}];o.publish(r),temporarilyDisableList(n,o)})}function validateListDrop(t,e,n,o,i){const r=t.dataTransfer.types,a=`text/x-spotify-data-context-${n}`.toLowerCase();if(r.includes(a)&&!validatePotentialOperations(t,e,o))return!1;const s=e.getAttribute("data-uri");if(s&&draggedLinkContext===s)return!1;const l={valid:!0};return hooks.run("list-drop-validation",l,t,e,o,i),!!l.valid}function validatePotentialOperations(t,e,n){const o=cachedSelectionState.get();if(1===o.length){if(e.getAttribute("data-uri")!==o[0].uri)return!0;const i=Range.fromIndices(o[0].indicesWithHidden);if(1===i.length){const e=i[0];e.update(e.start,e.end+1);const o="below"===n?getLastRowFromLastList():getRowNode(t);if(o){const n=getTargetIndex(t.clientY,o);if(n>-1){if(new Range(n,n+1).contained(e))return!1}}}}return!0}function getMatchingTarget(t){let e=t.target;for(;e;){if(isMatchingTarget(t,e))return e;e=e.parentElement}return null}function getMatchingListTarget(t){let e=t.target;for(;e;){if($(e).matches(SELECTOR_LIST)&&isMatchingTarget(t,e))return e;e=e.parentElement}return null}function getListTargetFromBody(t){const e=getLastListNode();if(e){if(t.target.contains(e)&&isMatchingTarget(t,e)&&isBelowNode(t.clientX,t.clientY,e))return e}return null}function getRowNode(t){return t.target.closest(SELECTOR_LIST_ITEM)}function getLastRowFromLastList(){const t=getLastListNode();if(t){const e=$(t).search(SELECTOR_LIST_ITEM),n=e&&e[e.length-1];if(n)return n}return null}function getLastListNode(){const t=document.querySelectorAll(SELECTOR_LIST);return t&&t[t.length-1]||null}function getTargetIndex(t,e){let n=e.getAttribute("data-index");return null===n?n=-1:(n=parseInt(n,10),isNaN(n)?n=-1:isBelowMiddleOfNode(t,e)&&n++),n}function getMoveIndices(t,e){const n=selection.getIndicesPerList();if(1!==n.length)return[];const o=n[0].indices.slice();return 0===o.length?[]:(hooks.run("get-move-indices",t,e,o),o.sort(function(t,e){return t-e}),o)}function getInsertValues(t,e,n,o,i){const r=t.dataTransfer.types,a=e.getAttribute(ATTR_TARGET);if(!a)return void i(null,[]);const s=intersection(a.split("|"),r);0!==s.length?getRowsFromData(getDataFromTypes(t,s),isListOfTracks(n,o),function(t,e){t?i(t):i(null,e)}):i(null,[])}function getDataFromTypes(t,e){const n={};for(let o=0,i=e.length;o<i;o++){const i=e[o],r=n[i]=[],a=0===i.indexOf("text/x-spotify"),s=t.dataTransfer.getData(i),l=a?s.split("\n"):[s];for(let t=0,e=l.length;t<e;t++){const e=l[t];if(a){const t=liburi.from(e);t&&r.push(t.toURI())}else r.push(e)}}return n}function getRowsFromData(t,e,n){const o=[];if(t["text/x-spotify-tracks"]&&o.push(getRowObjects("track",t["text/x-spotify-tracks"])),t["text/x-spotify-albums"]){const n=t["text/x-spotify-albums"];e?o.push(fetchListTrackRows(n)):o.push(getRowObjects("album",n))}if(t["text/x-spotify-playlists"]){const n=t["text/x-spotify-playlists"];e?o.push(fetchListTrackRows(n)):o.push(getRowObjects("playlist",n))}t["text/x-spotify-artists"]&&o.push(getRowObjects("artist",t["text/x-spotify-artists"])),t["text/x-spotify-users"]&&o.push(getRowObjects("user",t["text/x-spotify-users"])),Promise.all(o).then(function(t){let e=[];e=e.concat.apply(e,t),n(null,e)},function(t){n(t)})}function fetchListTrackRows(t){const e=t.map(function(t){return new Promise(function(e,n){live(t).query("rows(track(uri))",function(t,o){if(t)return void n(t);const i=o.rows.map(function(t){return live(t)});e(i)},live.ASAP)})});return Promise.all(e).then(function(t){let e=[];return e=e.concat.apply(e,t)})}function getRowObjects(t,e){return e.map(function(e){const n={};return n[t]={uri:e},live(n)})}function isListOfTracks(t,e){if(liburi.isPlaylistV1OrV2(e))return!0;const n={valid:!1};if(hooks.run("is-list-of-tracks",n,t,e),!n.valid){const e=t.get(0);if(e&&e.get("track"))return!0}return!!n.valid}function isBelowNode(t,e,n){const o=n.getBoundingClientRect(),i=e>=o.bottom,r=t>=o.left&&t<=o.right;return i&&r}function isBelowMiddleOfNode(t,e){const n=e.getBoundingClientRect();return t>=n.top+n.height/2}function isMatchingTarget(t,e){const n=t.dataTransfer.types,o=e.getAttribute(ATTR_TARGET);if(o){if(intersection(o.split("|"),n).length>0)return!0}return!1}function temporarilyDisableList(t,e){disabledLists[t]=!0;const n=function(o){return()=>{clearTimeout(o),e.off("update",n),setTimeout(function(){delete disabledLists[t]},100)}},o=setTimeout(()=>{n(o)},500);e.on("update",n(o))}function attach(){eventModel.delegate("dragstart",SELECTOR_DRAGGABLE,onDragStart),eventModel.delegate("dragover",SELECTOR_LIST_TARGET,onDragOver),eventModel.delegate("dragleave",SELECTOR_LIST_TARGET,onDragLeave),eventModel.delegate("dragend","body",onDragEnd),eventModel.delegate("drop",SELECTOR_LIST_TARGET,onDrop)}function detach(){eventModel.undelegate("dragstart",SELECTOR_DRAGGABLE,onDragStart),eventModel.undelegate("dragover",SELECTOR_LIST_TARGET,onDragOver),eventModel.undelegate("dragleave",SELECTOR_LIST_TARGET,onDragLeave),eventModel.undelegate("dragend","body",onDragEnd),eventModel.undelegate("drop",SELECTOR_LIST_TARGET,onDrop)}exports.attach=attach,exports.detach=detach;

},{"../../../libs/live-list-operations":93,"../../live":148,"../../range2":189,"../../spotify-elements":195,"../selection":266,"./util/eventmodel":216,"./util/hooks":217,"mout/array/intersection":393,"spotify-liburi":450}],215:[function(require,module,exports){
(function (global){
"use strict";const $=require("../../spotify-elements"),liburi=require("spotify-liburi"),defer=require("../../../libs/prime/defer"),center=require("../center"),eventModel=require("./util/eventmodel"),hooks=require("./util/hooks"),getLogContext=require("../util/get-log-context"),UserDragAndDropInteraction1=require("../../logger/messages/UserDragAndDropInteraction1"),SELECTOR_DROP_TARGET="[data-drop-target]",SELECTOR_DRAGGABLE="a, [draggable]",ATTR_TARGET="data-drop-target",ATTR_TARGET_INCLUDE_TEXT="data-drop-target-include-text",ATTR_NO_CLASSNAME="data-drop-no-classname",CLASSNAME_ACTIVE="drop-target-active",TEXT_PLAIN="text/plain";let longHoldTimerId=0,longHoldTimerDuration=1e3,draggedElement=null,lastEnteredElement=null;function onDragStart(e,t){t.closest("[data-glue-draggable]")||(draggedElement=t,lastEnteredElement=null)}function onDragEnd(){draggedElement=null,lastEnteredElement=null,stopLongHoldTimer(),removeAnyActiveClass()}function onDragEnter(e,t){validateTarget(e,t)&&setEnter(e,t)}function onDragLeave(e,t){validateTarget(e,t)&&setLeave(e,t)}function onDragOver(e,t){validateTarget(e,t)?(e.preventDefault(),e.dataTransfer.dropEffect="copy",setEnter(e,t)):setLeave(e,t)}function onDrop(e,t){if(stopLongHoldTimer(),removeAnyActiveClass(),validateTarget(e,t)){const n=getMimeTypesForTarget(e,t),r=getDropData(e,n),a=e.dataTransfer.getData("text/x-spotify-data-context")||null,o=e.dataTransfer.getData("text/x-spotify-data-log-context")||null,l=e.dataTransfer.getData("text/x-spotify-data-app-uri")||null;let d=parseInt(e.dataTransfer.getData("text/x-spotify-data-log-source-index"),0);isNaN(d)&&(d=null);const i=t.closest("[data-uri]"),g=i&&i.getAttribute("data-uri")||null,s=getLogContext(t),T=global.__spotify&&global.__spotify.app_uri||null;defer.immediate(function(){center.emit("drop",{handled:e.handled,node:t,sourceUri:a,targetUri:g,data:r});const n=r[Object.keys(r)[0]][0],i=liburi.from(n).type,u=Object.keys(r).reduce(function(e,t){return e+r[t].length},0),E=e.data&&e.data.targetIndex||null;UserDragAndDropInteraction1.log({item_type:i,item_uri:n,number_items:u,source_view_uri:l,source_uri:a,source_index:d,source_component:o,target_view_uri:T,target_uri:g,target_index:E,target_component:s})})}e.preventDefault(),lastEnteredElement=null}function setEnter(e,t){if(t===lastEnteredElement)return;lastEnteredElement=t,t.hasAttribute(ATTR_NO_CLASSNAME)||$(t).addClass(CLASSNAME_ACTIVE);const n=getMimeTypesForTarget(e,t);center.emit("dragenter",{node:t,types:n}),startLongHoldTimer(t,n)}function setLeave(e,t){if(t!==lastEnteredElement)return;lastEnteredElement=null,t.hasAttribute(ATTR_NO_CLASSNAME)||$(t).removeClass(CLASSNAME_ACTIVE);const n=getMimeTypesForTarget(e,t);center.emit("dragleave",{node:t,types:n}),stopLongHoldTimer()}function validateTarget(e,t){if(t===draggedElement)return!1;if(getMimeTypesForTarget(e,t).length){const n={valid:!0};if(hooks.run("target-validation",n,e,t),n.valid)return!0}return!1}function getDropData(e,t){const n={};for(let r=0,a=t.length;r<a;r++){const a=n[t[r]]=[],o=e.dataTransfer.getData(t[r]),l=0===t[r].indexOf("text/x-spotify"),d=l?o.split("\n"):[o];for(let e=0,t=d.length;e<t;e++){let t=d[e];if(l){const e=liburi.from(t);e&&(t=e.toURI())}t&&a.push(t)}}return t.indexOf("text/x-spotify-data-context")>-1&&(n["text/x-spotify-data-context"]=[e.dataTransfer.getData("text/x-spotify-data-context")]),n}function startLongHoldTimer(e,t){longHoldTimerId||(longHoldTimerId=setTimeout(function(){center.emit("dragover-long",{node:e,types:t})},longHoldTimerDuration))}function stopLongHoldTimer(){clearTimeout(longHoldTimerId),longHoldTimerId=0}function removeAnyActiveClass(){const e=$(`.${CLASSNAME_ACTIVE}`);e&&e.removeClass(CLASSNAME_ACTIVE)}function getMimeTypesForTarget(e,t){const n=[],r=e.dataTransfer.types;let a=t.getAttribute(ATTR_TARGET);const o=t.hasAttribute(ATTR_TARGET_INCLUDE_TEXT);if(a){a=a.split("|");for(let e=0,t=r.length;e<t;e++){const t=r[e];a.indexOf(t)>-1&&n.push(t)}o&&n.length&&-1===n.indexOf(TEXT_PLAIN)&&n.push(TEXT_PLAIN)}return n}function attach(){eventModel.delegate("dragstart",SELECTOR_DRAGGABLE,onDragStart),eventModel.delegate("dragenter",SELECTOR_DROP_TARGET,onDragEnter),eventModel.delegate("dragleave",SELECTOR_DROP_TARGET,onDragLeave),eventModel.delegate("dragover",SELECTOR_DROP_TARGET,onDragOver),eventModel.delegate("dragend","body",onDragEnd),eventModel.delegate("drop",SELECTOR_DROP_TARGET,onDrop)}function detach(){eventModel.undelegate("dragstart",SELECTOR_DRAGGABLE,onDragStart),eventModel.undelegate("dragenter",SELECTOR_DROP_TARGET,onDragEnter),eventModel.undelegate("dragleave",SELECTOR_DROP_TARGET,onDragLeave),eventModel.undelegate("dragover",SELECTOR_DROP_TARGET,onDragOver),eventModel.undelegate("dragend","body",onDragEnd),eventModel.undelegate("drop",SELECTOR_DROP_TARGET,onDrop)}exports.attach=attach,exports.detach=detach;const originalDuration=longHoldTimerDuration;exports.setLongHoldDuration=function(e){longHoldTimerDuration=e},exports.resetLongHoldDuration=function(){longHoldTimerDuration=originalDuration};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../../libs/prime/defer":185,"../../logger/messages/UserDragAndDropInteraction1":160,"../../spotify-elements":195,"../center":206,"../util/get-log-context":280,"./util/eventmodel":216,"./util/hooks":217,"spotify-liburi":450}],216:[function(require,module,exports){
"use strict";const $=require("../../../spotify-elements"),attached={},delegations={};let movementHandlerCount=0,hasEntered=!1,lastEnteredElement=null,lastEnterTarget=null,lastEnterEvent=null,wasLastEventEnter=!1;function resetState(){hasEntered=!1,lastEnteredElement=null,lastEnterTarget=null,lastEnterEvent=null,wasLastEventEnter=!1}function onEvent(e){const t=getPrimaryHandler(e.type);t?t(e):handleDelegationsForEvent(e)}function onPrimaryDragEnter(e){wasLastEventEnter=!0,hasEntered?lastEnteredElement!==e.target&&(lastEnterEvent=e):(hasEntered=!0,lastEnteredElement=e.target,handleDelegationsForEvent(e))}function onPrimaryDragLeave(e){wasLastEventEnter=!1,lastEnteredElement=null,handleDelegationsForEvent(e),hasEntered&&(lastEnterEvent?(lastEnteredElement=lastEnterEvent.target,handleDelegationsForEvent(lastEnterEvent),lastEnterEvent=null):hasEntered=!1)}function onPrimaryDrop(e){resetState(),handleDelegationsForEvent(e)}function onPrimaryDragEnd(e){resetState(),handleDelegationsForEvent(e)}function onDragEnter(e,t,n){t!==lastEnterTarget&&(lastEnterTarget=t,callUserHandler(e,t,n))}function onDragLeave(e,t,n,a){let r=!1;const l=lastEnterEvent&&lastEnterEvent.target;if(l){const e=t===l,n=!e&&t.contains(l),s=$(l).matches(a);e||n&&!s||(r=!0)}wasLastEventEnter||(r=!0),r&&(lastEnterTarget=null,callUserHandler(e,t,n))}function handleDelegationsForEvent(e){const t=e.type,n=delegations[t];n&&n.length>0&&n.forEach(function(n){const a=n.selector,r=e.target!==document&&e.target.closest(a);if(r){(getHandler(t)||callUserHandler)(e,r,n.handler,a)}})}function callUserHandler(e,t,n){n.call(exports,e,t)}function getPrimaryHandler(e){switch(e){case"dragenter":return onPrimaryDragEnter;case"dragleave":return onPrimaryDragLeave;case"dragend":return onPrimaryDragEnd;case"drop":return onPrimaryDrop}return null}function getHandler(e){switch(e){case"dragenter":return onDragEnter;case"dragleave":return onDragLeave}return null}function isMovementType(e){switch(e){case"dragenter":case"dragleave":case"dragend":case"drop":return!0}return!1}function attach(e){attached[e]||(attached[e]=!0,document.addEventListener(e,onEvent,!1))}function detach(e){attached[e]&&(attached[e]=!1,document.removeEventListener(e,onEvent,!1))}function delegate(e,t,n){isMovementType(e)?1===++movementHandlerCount&&(attach("dragenter"),attach("dragleave"),attach("dragend"),attach("drop")):attached[e]||attach(e),delegations[e]||(delegations[e]=[]),delegations[e].push({selector:t,handler:n})}function undelegate(e,t,n){isMovementType(e)&&0===(movementHandlerCount=Math.max(0,movementHandlerCount-1))&&(detach("dragenter"),detach("dragleave"),detach("dragend"),detach("drop"));const a=delegations[e];if(a){for(let e=0,r=a.length;e<r;e++){const r=a[e];if(r.selector===t&&r.handler===n){a.splice(e,1);break}}isMovementType||0!==a.length||detach(e)}}exports.delegate=delegate,exports.undelegate=undelegate;

},{"../../../spotify-elements":195}],217:[function(require,module,exports){
"use strict";const hooks={};function add(o,s){hooks[o]||(hooks[o]=[]),hooks[o].push(s)}function remove(o,s){if(hooks[o]){const e=hooks[o].indexOf(s);e>-1&&hooks[o].splice(e,1)}}function run(o){const s=hooks[o];if(s&&s.length>0){const o=Array.prototype.slice.call(arguments,1);for(let e=0,n=s.length;e<n;e++)s[e].apply(null,o)}}exports.add=add,exports.remove=remove,exports.run=run;

},{}],218:[function(require,module,exports){
"use strict";const live=require("../../../live"),liburi=require("spotify-liburi");function getForUri(e){const t=liburi.from(e);if(!t)return"";const r=t.type;return r===liburi.Type.TRACK||r===liburi.Type.LOCAL?getForTrack(e):r===liburi.Type.ARTIST||r===liburi.Type.LOCAL_ARTIST?getForArtist(e):r===liburi.Type.ALBUM||r===liburi.Type.LOCAL_ALBUM?getForAlbum(e):r===liburi.Type.PLAYLIST||r===liburi.Type.PLAYLIST_V2?getForPlaylist(e):r===liburi.Type.USER||r===liburi.Type.PROFILE?getForUser(e):r===liburi.Type.FOLDER?getForFolder(e):r===liburi.Type.STATION?getForStation(e):r===liburi.Type.EPISODE?getForEpisode(e):r===liburi.Type.SHOW?getForShow(e):""}function getForTrack(e){const t=live(e),r=t.get("name");if(!r)return"";const i=t.get("artists");if(!i||0===i.length)return r;const n=i.get(0,i.length).map(function(e){return e.get("name")}).join(", ");return n?separateDragTextItems(r,n):r}function getForArtist(e){return live(e).get("name")||""}function getForAlbum(e){const t=live(e),r=t.get("name");if(!r)return"";const i=t.get("artists");if(!i||0===i.length)return r;const n=i.get(0).get("name");return n?separateDragTextItems(n,r):r}function getForPlaylist(e){const t=live(e),r=t.get("name");if(!r)return"";const i=t.get("owner"),n=i&&(i.get("name")||i.get("username"));return n?separateDragTextItems(r,n):r}function getForUser(e){const t=live(e).get("name");if(t)return t;const r=liburi.fromString(e);return r&&r.username||""}function getForFolder(e){return live(e).get("name")}function getForStation(e){return live(e).get("name")}function getForEpisode(e){return live(e).get("name")}function getForShow(e){return live(e).get("name")}function separateDragTextItems(e,t){return`${e} – ${t}`}function getForElement(e){let t=e.getAttribute("data-drag-text");if(t)return t;let r=e.getAttribute("data-uri");if(!r){const t=liburi.from(e.getAttribute("href"));r=t?t.toURI():""}return r&&(t=getForUri(r))?t:(t=e.getAttribute("title"))||e.textContent}exports.getForUri=getForUri,exports.getForElement=getForElement;

},{"../../../live":148,"spotify-liburi":450}],219:[function(require,module,exports){
"use strict";var _liveWrappedUri=require("../live-wrapped-uri"),_liveWrappedUri2=_interopRequireDefault(_liveWrappedUri),_formatLists=require("../playlist-utils/format-lists");function _interopRequireDefault(t){return t&&t.__esModule?t:{default:t}}const $=require("../spotify-elements"),live=require("../live"),dom=require("./util/dom"),center=require("./center"),SELECTOR_FEEDBACK_BUTTON="[data-button=feedback]",SELECTOR_HEART_BUTTON="[data-button=heart]",SELECTOR_BAN_BUTTON="[data-button=contextmenu]",SELECTOR_UNDO_HEART_BUTTON="[data-button=undo-heart]",SELECTOR_UNDO_BAN_BUTTON="[data-button=undo-ban]",HEART_CLASSNAME="spoticon-heart-16",BAN_CLASSNAME="spoticon-ban-16",ACTIVE_HEART_CLASSNAME="spoticon-heart-active-16",ACTIVE_BAN_CLASSNAME="spoticon-ban-active-16";let isAttached=!1;function handleFeedbackClick(t,e){const a=dom.getAttributeFromNodeOrParent(t.target,"data-button"),o=dom.getAttributeFromNodeOrParent(e[0],"data-uri");let n=dom.getContextFromNodeOrParent(e[0]);_liveWrappedUri2.default.parse(n)&&(n=_liveWrappedUri2.default.parse(n).originUri),o&&n&&("heart"===a?live(n).emit("heart",o):"undo-heart"!==a&&"undo-ban"!==a||live(n).emit(a,o))}function updateFeedbackUI(t,e){const a=t.querySelector(SELECTOR_HEART_BUTTON)||t.querySelector(SELECTOR_UNDO_HEART_BUTTON),o=t.querySelector(SELECTOR_BAN_BUTTON)||t.querySelector(SELECTOR_UNDO_BAN_BUTTON),n=t.parentNode.classList.contains("tl-row")?t.parentNode:null,r="up"===e,i="down"===e,s=!r&&!i;t&&(t.classList.toggle("thumbs-up",r),t.classList.toggle("thumbs-none",s),t.classList.toggle("thumbs-down",i)),a&&updateHeartUI(a,e),o&&updateBanUI(o,e),n?(n.classList.toggle("thumbs-up",r),n.classList.toggle("thumbs-none",s),n.classList.toggle("thumbs-down",i)):a&&a.classList.toggle("active",r)}function updateHeartUI(t,e){if("up"===e){t.classList.remove(HEART_CLASSNAME),t.classList.add(ACTIVE_HEART_CLASSNAME),t.setAttribute("data-button","undo-heart");const e=t.getAttribute("data-tooltip-undo");t.setAttribute("data-tooltip",e),t.setAttribute("aria-label",e),t.setAttribute("data-interaction-intent","undo-heart")}else if(null===e){t.classList.add(HEART_CLASSNAME),t.classList.remove(ACTIVE_HEART_CLASSNAME),t.setAttribute("data-button","heart");const e=t.getAttribute("data-tooltip-heart");t.setAttribute("data-tooltip",e),t.setAttribute("aria-label",e),t.setAttribute("data-interaction-intent","heart")}}function updateBanUI(t,e){if("down"===e){t.classList.remove(BAN_CLASSNAME),t.classList.add(ACTIVE_BAN_CLASSNAME),t.setAttribute("data-button","undo-ban");const e=t.getAttribute("data-tooltip-undo");t.setAttribute("data-tooltip",e),t.setAttribute("aria-label",e),t.setAttribute("data-interaction-intent","undo-ban")}else if(null===e){t.classList.add(BAN_CLASSNAME),t.classList.remove(ACTIVE_BAN_CLASSNAME),t.setAttribute("data-button","contextmenu");const e=t.getAttribute("data-tooltip-ban");t.setAttribute("data-tooltip",e),t.setAttribute("aria-label",e),t.setAttribute("data-interaction-intent","show-ban-options")}}function getURIFromNode(t){const e=t[0].closest("[data-uri]");return e?e.getAttribute("data-uri"):null}const changeHandlers={},eventHandlers={changeHandler:function(t,e,a,o){if("thumb"===e){0===t.setStateForURI(o,a)&&(live(o).off("update",changeHandlers[o]),delete changeHandlers[o])}}},actions={addListenerForNode:function(t,e){const a=getURIFromNode(t);let o;if(e&&e[0]&&(o=dom.getContextFromNodeOrParent(e[0])),!a||!o)return;_liveWrappedUri2.default.parse(o)&&(o=_liveWrappedUri2.default.parse(o).originUri);const n=(0,_formatLists.makeFeedbackUri)(o,a);if(changeHandlers[n])return void live(n).get("thumb",function(e,a){if(e)throw e;actions.setStateForFeedbackNode(t,a)},live.ASAP);changeHandlers[n]=function(t){for(const e in t){if(!t.hasOwnProperty(e))continue;const a=t[e];eventHandlers.changeHandler(actions,e,a,n)}};const r=live(n);r.get("thumb",function(e,a){if(e)throw e;actions.setStateForFeedbackNode(t,a),r.on("update",changeHandlers[n])},live.ASAP)},setStateForURI:function(t,e){let a=0;const o=(0,_formatLists.splitFeedbackUri)(t)[1],n=$(document).search("[data-button=feedback]");if(!n)return a;for(let t=0,r=n.length;t<r;t++){const r=$(n[t]);o===getURIFromNode(r)&&(a++,actions.setStateForFeedbackNode(r,e))}return a},setStateForFeedbackNode:function(t,e){const a=$(t[0].closest('[data-button="feedback"]'))||$(t[0].querySelector('[data-button="feedback"]'));a&&updateFeedbackUI(a[0],e)}},update=exports.update=function(t,e){if(!isAttached)return;const a=$(e)||$(t)||$(document).search("[data-button=feedback]");if(!a)return;const o=t||$(document).search("[data-context]");for(let t=0,e=a.length;t<e;t++)actions.addListenerForNode($(a[t]),$(o))},handleScrollShow=function(t){update(t.pageNode,t.nodes)};exports.attach=function(){if(isAttached)return;isAttached=!0,$(document).delegate("click","[data-button=feedback]",handleFeedbackClick),center.on("scroll-show-before",handleScrollShow)},exports.detach=function(){if(!isAttached)return;isAttached=!1,$(document).undelegate("click","[data-button=feedback]",handleFeedbackClick),center.off("scroll-show-before",handleScrollShow)};

},{"../live":148,"../live-wrapped-uri":147,"../playlist-utils/format-lists":179,"../spotify-elements":195,"./center":206,"./util/dom":279}],220:[function(require,module,exports){
"use strict";const $=require("../spotify-elements"),live=require("../live"),center=require("./center"),stickyEvents=require("./sticky"),cosmos=require("./util/cosmos"),merge=require("mout/object/merge"),deepEquals=require("mout/lang/deepEquals"),getOriginUri=require("../live-wrapped-uri").getOriginUri,appUtil=require("./util/app"),SCROLL_PADDING=8,STRING_FILTER_KEY="list-filter-string-",SESSION_STORAGE="spotify:session-storage";let states,lastEmittedStates,controlMessageSubscription,isAttached=!1;function update(t){if(!isAttached)return;const e=$(t)||$(document),a=e.matches("[data-filter]")?[e[0]]:e.search("[data-filter]");a&&a.forEach(function(t){const e=getURI(t);if(e){if(!states[e]){const a=$(t).find("input[type=text]")[0].value;a&&updateState(e,{activated:!0,enteredString:a})}handleStale(e)}})}function handleStale(t){render(t);const e=getState(t);if(!deepEquals(e,lastEmittedStates[t])){lastEmittedStates[t]=e;const a=e.activated?e.enteredString:"";emitFilterRequest(t,a),persistFilterOnSessionStorage(t,a)}}function render(t){const e=$(document).search("[data-uri] [data-filter]");e&&e.filter(function(e){return getURI(e)===t}).forEach(function(e){const a=getState(t),n=$(e).find("input[type=text]")[0],i=$(e).find(".h-search-wrapper")[0];a.activated?($(i).hasClass("focus")||($(i).addClass("focus"),e.setAttribute("data-sticky",""),stickyEvents.update()),n.value!==a.enteredString&&(n.value=a.enteredString)):(n.blur(),$(i).hasClass("focus")&&($(i).removeClass("focus"),e.removeAttribute("data-sticky"),stickyEvents.update()),n.value="")})}function focusAndSelectInput(t){document.activeElement!==t&&(t.focus(),t.select())}function scrollIntoView(t){const e=t.getBoundingClientRect(),a=e.top-SCROLL_PADDING;(a<0||e.bottom>window.innerHeight)&&window.scrollTo(0,window.pageYOffset+a)}function emitFilterRequest(t,e){center.emit("filter-request",t,e)}function persistFilterOnSessionStorage(t,e){const a=getOriginUri(t)||t,n={};n[STRING_FILTER_KEY+a]=e,live(SESSION_STORAGE).publish(n)}function handleCancelClick(t){clear(getURI(t.target))}function handleInputInput(t){updateState(getURI(t.target),{enteredString:t.target.value})}function handleInputKeyup(t){27===t.keyCode&&clear(getURI(t.target))}function handleInputFocus(t){updateState(getURI(t.target),{activated:!0})}function handleInputFocusOut(t){""===getState(getURI(t.target)).enteredString&&updateState(getURI(t.target),{activated:!1})}function clear(t){updateState(t,{activated:!1,enteredString:""})}function getState(t){return states[t]||{activated:!1,enteredString:""}}function updateState(t,e){states[t]=merge(getState(t),e),handleStale(t)}function getURI(t){let e=t.getAttribute("data-uri");if(!e){const a=$(t).parents("[data-uri]");a&&(e=a[0].getAttribute("data-uri"))}return(e=getOriginUri(e)||e)||null}const attach=function(){isAttached||(isAttached=!0,states={},lastEmittedStates={},controlMessageSubscription=cosmos.subscribe({url:"sp://messages/v1/container/control"},function(t,e){if(!appUtil.isActive())return;e&&e.body&&"filter"===e.body.type&&$("[data-filter]").forEach(function(t,e){updateState(getURI(t),{activated:!0});const a=$(t).find("input[type=text]")[0];a&&(0===e&&scrollIntoView(a),focusAndSelectInput(a))})}),center.on("filter-reset",clear),$(document).delegate("click","[data-filter] .h-search-close",handleCancelClick),$(document).delegate("click","[data-filter-reset]",handleCancelClick),$(document).delegate("input","[data-filter] input",handleInputInput),$(document).delegate("keyup","[data-filter] input",handleInputKeyup),$(document).delegate("focusin","[data-filter] input",handleInputFocus),$(document).delegate("focusout","[data-filter] input",handleInputFocusOut))},detach=function(){isAttached&&(states=null,controlMessageSubscription.cancel(),center.off("filter-reset",clear),$(document).undelegate("click","[data-filter] .h-search-close",handleCancelClick),$(document).undelegate("click","[data-filter-reset]",handleCancelClick),$(document).undelegate("input","[data-filter] input",handleInputInput),$(document).undelegate("keyup","[data-filter] input",handleInputKeyup),$(document).undelegate("focusin","[data-filter] input",handleInputFocus),$(document).undelegate("focusout","[data-filter] input",handleInputFocusOut),isAttached=!1)},broadcast=function(t){if(void 0===t)throw new Error("broadcast requires enabled argument");cosmos.post({url:"sp://messages/v1/container/control",body:{type:"update_menu_state",enable_filter_item:t}})};module.exports={attach:attach,detach:detach,update:update,broadcast:broadcast};

},{"../live":148,"../live-wrapped-uri":147,"../spotify-elements":195,"./center":206,"./sticky":272,"./util/app":277,"./util/cosmos":278,"mout/lang/deepEquals":405,"mout/object/merge":422}],221:[function(require,module,exports){
(function (global){
"use strict";var _glue=require("../glue"),_glue2=_interopRequireDefault(_glue),_frameUpdater=require("../frame-updater"),_cancellationTokenSource=require("../cancellation-token-source"),_cancellationTokenSource2=_interopRequireDefault(_cancellationTokenSource);function _interopRequireDefault(e){return e&&e.__esModule?e:{default:e}}let isAttached=!1,isFontLoaded=!1,topBarHeight=0,headerHeight=0,lastHeaderHeight=0,stickyHeight=0,currentScrollY=0,lastScrollY=0,lastScrollYDiffs=[0,0,0,0,0],lastLoadedImageNode=null,scrollListenerId=0,needsTitleSizeUpdate=!0,lastUpdatedTitleNode=null,lastUpdatedTitleContent="",fontPromise=null,cancellationTokenSource=null,frameRequestIds=[],lastHeaderNode=null,scrollNode=null,lastDescriptionNode=null,lastDescriptionMouseEnterHandler=null,lastDescriptionMouseLeaveHandler=null,fullDescriptionNode=null;function updateHeaderAlphaMask(){const e=document.querySelector("[data-glue-page-header-content]");if(e){const t=currentScrollY+topBarHeight,a=t+24;e.style.webkitMaskImage=`linear-gradient(to bottom, transparent ${t}px, black ${a}px)`}}function updateHeaderBackgroundPosition(){const e=document.querySelector("[data-glue-page-header-background]");if(e){const t=currentScrollY>headerHeight-stickyHeight;e.style.position=t?"fixed":"",e.style.top=t?`-${headerHeight-stickyHeight}px`:"",e.style._bottom=t?"auto":"",e.style.bottom=e.style._bottom,e.style.height=t?`${headerHeight}px`:""}const t=document.querySelector("[data-glue-page-header-background-image]");if(t){const e=t.style.transform||"";t.style.transform=`${e.replace(/translateY\(.*?\)/,"")} translateY(${Math.min(currentScrollY,headerHeight-stickyHeight)}px)`.trim()}}function updateHeaderBackgroundScrollOverlay(){const e=document.querySelector("[data-glue-page-header-background-scroll-overlay]");if(e){const t=.4;e.style.opacity=Math.round(Math.min(1,currentScrollY/(headerHeight-stickyHeight))*t*1e3)/1e3}}function updateHeaderBackgroundScrollOverlayEllipse(){const e=Math.min(1,currentScrollY/(headerHeight-stickyHeight)),t=document.querySelector("[data-glue-page-header-background-scroll-overlay-ellipse]");t&&(t.style.opacity=Math.round(1e3*Math.min(1,2*e))/1e3);const a=document.querySelector("[data-glue-page-header-background-scroll-overlay-ellipse-backdrop]");a&&(a.style.opacity=Math.round(1e3*e)/1e3)}function updateHeaderImageScaling(){const e=document.querySelector("[data-glue-page-header-background-image]");if(e){const t=document.querySelector("[data-glue-page-header-background-image-loader]");if(!!t&&t.classList.contains("glue-page-header__background-image-loader--is-loaded")){const t=1.07,a=1,o=Math.min(1,currentScrollY/(headerHeight-stickyHeight)),r=Math.round(1e3*(t-o*(t-a)))/1e3,l=e.style.transform||"";e.style.transform=`${l.replace(/scale\(.*?\)/,"")} scale(${r})`.trim()}}}function addDescriptionHandlers(){const e=document.querySelector("[data-glue-page-header]"),t=document.querySelector("[data-glue-page-header-description]");e&&t&&(lastDescriptionMouseEnterHandler=(t=>{if(t.target.scrollHeight!==t.target.clientHeight){const a=t.target.getBoundingClientRect();(fullDescriptionNode=t.target.cloneNode(!0)).addEventListener("mouseleave",lastDescriptionMouseLeaveHandler),fullDescriptionNode.classList.add("glue-page-header__full-description-overlay"),fullDescriptionNode.style.top=`${a.top}px`,fullDescriptionNode.style.left=`${a.left}px`,fullDescriptionNode.style.width=`${a.width}px`,e.appendChild(fullDescriptionNode)}}),lastDescriptionMouseLeaveHandler=(e=>{fullDescriptionNode&&e.relatedTarget!==fullDescriptionNode&&!fullDescriptionNode.contains(e.relatedTarget)&&(fullDescriptionNode.parentNode.removeChild(fullDescriptionNode),fullDescriptionNode.removeEventListener("mouseleave",lastDescriptionMouseLeaveHandler),fullDescriptionNode=null)}),(lastDescriptionNode=t).addEventListener("mouseenter",lastDescriptionMouseEnterHandler),lastDescriptionNode.addEventListener("mouseleave",lastDescriptionMouseLeaveHandler))}function removeDescriptionHandlers(){fullDescriptionNode&&(fullDescriptionNode.removeEventListener("mouseleave",lastDescriptionMouseLeaveHandler),fullDescriptionNode.parentNode.removeChild(fullDescriptionNode),fullDescriptionNode=null),lastDescriptionMouseEnterHandler&&(lastDescriptionNode.removeEventListener("mouseenter",lastDescriptionMouseEnterHandler),lastDescriptionMouseEnterHandler=null),lastDescriptionMouseLeaveHandler&&(lastDescriptionNode.removeEventListener("mouseleave",lastDescriptionMouseLeaveHandler),lastDescriptionMouseLeaveHandler=null),lastDescriptionNode=null}function handleResize(){needsTitleSizeUpdate=!0,exports._ensureFontIsLoaded(e=>{e?console.error(e):(exports._updateTitleTypeSize(),exports._updateHeaderSizes(),exports._updateHeader())})}exports._updateHeader=function(){const e=document.querySelector("[data-glue-page-header]");(e!==lastHeaderNode||currentScrollY<headerHeight||lastScrollY<headerHeight||headerHeight!==lastHeaderHeight)&&(lastHeaderNode=e,lastHeaderHeight=headerHeight,removeDescriptionHandlers(),addDescriptionHandlers(),updateHeaderBackgroundPosition(),updateHeaderAlphaMask(),updateHeaderBackgroundScrollOverlay(),updateHeaderBackgroundScrollOverlayEllipse(),updateHeaderImageScaling())},exports._updateHeaderSizes=function(){const e=document.querySelector("[data-glue-page-header]");if(e){const t=scrollNode===document?document.body:scrollNode;topBarHeight=parseInt(t.getAttribute("data-top-bar-height"),10)||0,headerHeight=e.offsetHeight,stickyHeight=parseInt(e.getAttribute("data-glue-page-header-sticky-height"),10)||0}else topBarHeight=0,headerHeight=0,stickyHeight=0},exports._updateTitleTypeSize=function(){const e=document.querySelector("[data-glue-page-header-content] [data-glue-page-header-title]");if(e){const t=e!==lastUpdatedTitleNode,a=e.textContent!==lastUpdatedTitleContent;e&&(needsTitleSizeUpdate||t||a)&&(needsTitleSizeUpdate=!1,lastUpdatedTitleNode=e,lastUpdatedTitleContent=e.textContent,_glue2.default.responsiveTitleType.setSizeForTitle(e,{useLargeTitle:e.hasAttribute("data-glue-page-header-use-large-title")}),exports._updateHeaderSizes())}},exports._updateScrollClassNames=function(){const e=document.querySelector("[data-glue-page-header]");if(e){!e._hasBeenSeen?(e._hasBeenSeen=!0,e.classList.add("glue-page-header--with-no-animations")):frameRequestIds.push((0,_frameUpdater.requestFrame)(null,()=>{e.classList.remove("glue-page-header--with-no-animations")})),lastScrollYDiffs.push(Math.abs(currentScrollY-lastScrollY)),lastScrollYDiffs.shift();const t=30,a=lastScrollYDiffs.reduce((e,a)=>e||a>t,!1);a?e.classList.add("glue-page-header--with-fast-scrolling"):e.classList.remove("glue-page-header--with-fast-scrolling"),global.onPageHeaderToggleFastScrolling&&global.onPageHeaderToggleFastScrolling(a)}},exports._updateHeaderImageLoading=function(){const e=document.querySelector("[data-glue-page-header-background-image]");if(e){if(e===lastLoadedImageNode)return;const t=e.getAttribute("data-glue-page-header-background-image-url");if(lastLoadedImageNode=e,t){const e=new window.Image;e.onload=(()=>{const e=document.querySelector("[data-glue-page-header-background-image-loader]");e.classList.contains("glue-page-header__background-image-loader--is-loaded")||(e.classList.add("glue-page-header__background-image-loader--is-loaded"),e.classList.add("glue-page-header__background-image-loader--with-loading-animation"),updateHeaderImageScaling(),e.addEventListener("transitionend",function t(){e.removeEventListener("transitionend",t),e.classList.remove("glue-page-header__background-image-loader--with-loading-animation")}))}),e.src=t}}},exports._updateScrollValue=function(){currentScrollY=scrollNode===document?window.scrollY:scrollNode.scrollTop},exports._updateLastScrollValue=function(){lastScrollY=currentScrollY},exports._ensureFontIsLoaded=function(e){if(isFontLoaded)return void e(null);fontPromise||(fontPromise=_glue2.default.responsiveTitleType.loadFont());const t=cancellationTokenSource.token();fontPromise.then(()=>{t.isCanceled()?e(t.operationCanceledError()):(isFontLoaded=!0,e(null))},a=>{e(t.errorIfCanceled()||a)})},exports.attach=function(){isAttached||(isAttached=!0,cancellationTokenSource=new _cancellationTokenSource2.default,scrollNode||(scrollNode=document),exports._ensureFontIsLoaded(e=>e&&console.error(e)),exports._updateHeaderSizes(),scrollListenerId=(0,_frameUpdater.addDebouncedScrollListener)(scrollNode,()=>{exports._updateScrollValue()},()=>{exports._updateScrollClassNames(),exports._updateHeader(),exports._updateLastScrollValue()}),window.addEventListener("resize",handleResize))},exports.detach=function(){isAttached&&(cancellationTokenSource.cancel(),cancellationTokenSource=null,frameRequestIds.forEach(e=>{(0,_frameUpdater.cancelFrame)(e)}),frameRequestIds=[],removeDescriptionHandlers(),isAttached=!1,isFontLoaded=!1,fontPromise=null,headerHeight=0,stickyHeight=0,currentScrollY=0,lastScrollY=0,lastScrollYDiffs=[0,0,0,0,0],needsTitleSizeUpdate=!0,lastUpdatedTitleNode=null,lastUpdatedTitleContent="",scrollNode=null,lastDescriptionNode=null,lastDescriptionMouseEnterHandler=null,lastDescriptionMouseLeaveHandler=null,fullDescriptionNode=null,(0,_frameUpdater.removeDebouncedScrollListener)(scrollListenerId),window.removeEventListener("resize",handleResize))},exports.update=function(){isAttached&&(frameRequestIds.push((0,_frameUpdater.requestFrame)(()=>{exports._updateScrollValue()},()=>{exports._updateScrollClassNames(),exports._updateHeaderImageLoading()})),exports._ensureFontIsLoaded(e=>{e?console.error(e):frameRequestIds.push((0,_frameUpdater.requestFrame)(()=>{exports._updateHeaderSizes()},()=>{exports._updateTitleTypeSize(),exports._updateHeader()}))}))},exports.setScrollNode=function(e){scrollNode=e};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../cancellation-token-source":51,"../frame-updater":61,"../glue":85}],222:[function(require,module,exports){
"use strict";const i18n=require("../../../libs/spotify-i18n")({ar:require("./json/ar.json"),cs:require("./json/cs.json"),de:require("./json/de.json"),el:require("./json/el.json"),en:require("./json/en.json"),es:require("./json/es.json"),"es-419":require("./json/es-419.json"),fi:require("./json/fi.json"),fr:require("./json/fr.json"),"fr-CA":require("./json/fr-CA.json"),hu:require("./json/hu.json"),id:require("./json/id.json"),it:require("./json/it.json"),ja:require("./json/ja.json"),nl:require("./json/nl.json"),pl:require("./json/pl.json"),"pt-BR":require("./json/pt-BR.json"),sv:require("./json/sv.json"),th:require("./json/th.json"),tr:require("./json/tr.json"),vi:require("./json/vi.json"),"zh-Hant":require("./json/zh-Hant.json"),ms:require("./json/ms.json")});module.exports=i18n;

},{"../../../libs/spotify-i18n":301,"./json/ar.json":223,"./json/cs.json":224,"./json/de.json":225,"./json/el.json":226,"./json/en.json":227,"./json/es-419.json":228,"./json/es.json":229,"./json/fi.json":230,"./json/fr-CA.json":231,"./json/fr.json":232,"./json/hu.json":233,"./json/id.json":234,"./json/it.json":235,"./json/ja.json":236,"./json/ms.json":237,"./json/nl.json":238,"./json/pl.json":239,"./json/pt-BR.json":240,"./json/sv.json":241,"./json/th.json":242,"./json/tr.json":243,"./json/vi.json":244,"./json/zh-Hant.json":245}],223:[function(require,module,exports){
module.exports={
  "drag_tooltip_many_items": {
    "one": "1 ملف",
    "other": "{0} ملفات"
  },
  "drag_tooltip_many_tracks": {
    "one": "مقطع واحد",
    "other": "{0} مقاطع"
  },
  "drag_tooltip_many_artists": {
    "one": "1 فنان",
    "other": "{0} فنانين"
  },
  "drag_tooltip_many_albums": {
    "one": "1 ألبوم",
    "other": "{0} ألبومات"
  },
  "drag_tooltip_many_playlists": {
    "one": "1 قائمة أغاني",
    "other": "{0} قوائم أغاني"
  },
  "drag_tooltip_many_users": {
    "one": "1 مستخدم",
    "other": "{0} مستخدمين"
  }
}
},{}],224:[function(require,module,exports){
module.exports={
  "drag_tooltip_many_items": {
    "one": "1 položka",
    "other": "Počet položek: {0}"
  },
  "drag_tooltip_many_tracks": {
    "one": "1 skladba",
    "other": "Počet skladeb: {0}"
  },
  "drag_tooltip_many_artists": {
    "one": "1 umělec",
    "other": "Počet umělců: {0}"
  },
  "drag_tooltip_many_albums": {
    "one": "1 album",
    "other": "Počet alb: {0}"
  },
  "drag_tooltip_many_playlists": {
    "one": "1 playlist",
    "other": "{0} playlistů"
  },
  "drag_tooltip_many_users": {
    "one": "1 uživatel",
    "other": "Počet uživatelů: {0}"
  }
}
},{}],225:[function(require,module,exports){
module.exports={
  "drag_tooltip_many_items": {
    "one": "1 Element",
    "other": "{0} Elemente"
  },
  "drag_tooltip_many_tracks": {
    "one": "1 Titel",
    "other": "{0} Titel"
  },
  "drag_tooltip_many_artists": {
    "one": "1 Künstler",
    "other": "{0} Künstler"
  },
  "drag_tooltip_many_albums": {
    "one": "1 Album",
    "other": "{0} Alben"
  },
  "drag_tooltip_many_playlists": {
    "one": "1 Playlist",
    "other": "{0} Playlists"
  },
  "drag_tooltip_many_users": {
    "one": "1 User",
    "other": "{0} User"
  }
}
},{}],226:[function(require,module,exports){
module.exports={
  "drag_tooltip_many_items": {
    "one": "1 στοιχείο",
    "other": "{0} στοιχεία"
  },
  "drag_tooltip_many_tracks": {
    "one": "1 κομμάτι",
    "other": "{0} κομμάτια"
  },
  "drag_tooltip_many_artists": {
    "one": "1 καλλιτέχνης",
    "other": "{0} καλλιτέχνες"
  },
  "drag_tooltip_many_albums": {
    "one": "1 άλμπουμ",
    "other": "{0} άλμπουμ"
  },
  "drag_tooltip_many_playlists": {
    "one": "1 playlist",
    "other": "{0} λίστες"
  },
  "drag_tooltip_many_users": {
    "one": "1 χρήστης",
    "other": "{0} χρήστες"
  }
}
},{}],227:[function(require,module,exports){
module.exports={
  "drag_tooltip_many_items": {
    "one": "1 item",
    "other": "{0} items"
  },
  "drag_tooltip_many_tracks": {
    "one": "1 track",
    "other": "{0} tracks"
  },
  "drag_tooltip_many_artists": {
    "one": "1 artist",
    "other": "{0} artists"
  },
  "drag_tooltip_many_albums": {
    "one": "1 album",
    "other": "{0} albums"
  },
  "drag_tooltip_many_playlists": {
    "one": "1 playlist",
    "other": "{0} playlists"
  },
  "drag_tooltip_many_users": {
    "one": "1 user",
    "other": "{0} users"
  }
}
},{}],228:[function(require,module,exports){
module.exports={
  "drag_tooltip_many_items": {
    "one": "1 elemento",
    "other": "{0} elementos"
  },
  "drag_tooltip_many_tracks": {
    "one": "1 canción",
    "other": "{0} canciones"
  },
  "drag_tooltip_many_artists": {
    "one": "1 artista",
    "other": "{0} artistas"
  },
  "drag_tooltip_many_albums": {
    "one": "1 álbum",
    "other": "{0} álbumes"
  },
  "drag_tooltip_many_playlists": {
    "one": "1 playlist",
    "other": "Playlists de {0}"
  },
  "drag_tooltip_many_users": {
    "one": "1 usuario",
    "other": "{0} usuarios"
  }
}
},{}],229:[function(require,module,exports){
module.exports={
  "drag_tooltip_many_items": {
    "one": "1 elemento",
    "other": "{0} elementos"
  },
  "drag_tooltip_many_tracks": {
    "one": "1 canción",
    "other": "{0} canciones"
  },
  "drag_tooltip_many_artists": {
    "one": "1 artista",
    "other": "{0} artistas"
  },
  "drag_tooltip_many_albums": {
    "one": "1 álbum",
    "other": "{0} álbumes"
  },
  "drag_tooltip_many_playlists": {
    "one": "1 playlist",
    "other": "{0} playlists"
  },
  "drag_tooltip_many_users": {
    "one": "1 usuario",
    "other": "{0} usuarios"
  }
}
},{}],230:[function(require,module,exports){
module.exports={
  "drag_tooltip_many_items": {
    "one": "1 kohde",
    "other": "{0} kohdetta"
  },
  "drag_tooltip_many_tracks": {
    "one": "1 kappale",
    "other": "{0} kappaletta"
  },
  "drag_tooltip_many_artists": {
    "one": "1 artisti",
    "other": "{0} artistia"
  },
  "drag_tooltip_many_albums": {
    "one": "1 albumi",
    "other": "{0} albumia"
  },
  "drag_tooltip_many_playlists": {
    "one": "1 soittolista",
    "other": "{0} soittolistaa"
  },
  "drag_tooltip_many_users": {
    "one": "1 käyttäjä",
    "other": "{0} käyttäjää"
  }
}
},{}],231:[function(require,module,exports){
module.exports={
  "drag_tooltip_many_items": {
    "one": "1 article",
    "other": "{0} articles"
  },
  "drag_tooltip_many_tracks": {
    "one": "1 chanson",
    "other": "{0} chansons"
  },
  "drag_tooltip_many_artists": {
    "one": "1 artiste",
    "other": "{0} artistes"
  },
  "drag_tooltip_many_albums": {
    "one": "1 album",
    "other": "{0} albums"
  },
  "drag_tooltip_many_playlists": {
    "one": "1 liste de lecture",
    "other": "{0} listes de lecture"
  },
  "drag_tooltip_many_users": {
    "one": "1 utilisateur",
    "other": "{0} utilisateur"
  }
}
},{}],232:[function(require,module,exports){
module.exports={
  "drag_tooltip_many_items": {
    "one": "1 élément",
    "other": "{0} éléments"
  },
  "drag_tooltip_many_tracks": {
    "one": "1 titre",
    "other": "{0} titres"
  },
  "drag_tooltip_many_artists": {
    "one": "1 artiste",
    "other": "{0} artistes"
  },
  "drag_tooltip_many_albums": {
    "one": "1 album",
    "other": "{0} albums"
  },
  "drag_tooltip_many_playlists": {
    "one": "1 playlist",
    "other": "{0} playlists"
  },
  "drag_tooltip_many_users": {
    "one": "1 utilisateur",
    "other": "{0} utilisateurs"
  }
}
},{}],233:[function(require,module,exports){
module.exports={
  "drag_tooltip_many_items": {
    "one": "1 elem",
    "other": "{0} elem"
  },
  "drag_tooltip_many_tracks": {
    "one": "1 dal",
    "other": " {0} dal"
  },
  "drag_tooltip_many_artists": {
    "one": "1 előadó",
    "other": "{0} előadó"
  },
  "drag_tooltip_many_albums": {
    "one": "1 album",
    "other": "{0} album"
  },
  "drag_tooltip_many_playlists": {
    "one": "1 műsorlista",
    "other": "{0} lejátszási lista"
  },
  "drag_tooltip_many_users": {
    "one": "1 felhasználó",
    "other": "{0} felhasználó"
  }
}
},{}],234:[function(require,module,exports){
module.exports={
  "drag_tooltip_many_items": {
    "one": "1 item",
    "other": "{0} item"
  },
  "drag_tooltip_many_tracks": {
    "one": "1 lagu",
    "other": "{0} lagu"
  },
  "drag_tooltip_many_artists": {
    "one": "1 artis",
    "other": "{0} artis"
  },
  "drag_tooltip_many_albums": {
    "one": "1 album",
    "other": "{0} album"
  },
  "drag_tooltip_many_playlists": {
    "one": "1 playlist",
    "other": "{0} playlist"
  },
  "drag_tooltip_many_users": {
    "one": "1 pengguna",
    "other": "{0} pengguna"
  }
}
},{}],235:[function(require,module,exports){
module.exports={
  "drag_tooltip_many_items": {
    "one": "1 elemento",
    "other": "{0} elementi"
  },
  "drag_tooltip_many_tracks": {
    "one": "1 brano",
    "other": "{0} brani"
  },
  "drag_tooltip_many_artists": {
    "one": "1 artista",
    "other": "{0} artisti"
  },
  "drag_tooltip_many_albums": {
    "one": "1 album",
    "other": "{0} album"
  },
  "drag_tooltip_many_playlists": {
    "one": "1 playlist",
    "other": "{0} playlist"
  },
  "drag_tooltip_many_users": {
    "one": "1 utente",
    "other": "{0} utenti"
  }
}
},{}],236:[function(require,module,exports){
module.exports={
  "drag_tooltip_many_items": {
    "one": "1個のアイテム",
    "other": "{0}個のアイテム"
  },
  "drag_tooltip_many_tracks": {
    "one": "1曲",
    "other": "{0}曲"
  },
  "drag_tooltip_many_artists": {
    "one": "1人のアーティスト",
    "other": "{0}人のアーティスト"
  },
  "drag_tooltip_many_albums": {
    "one": "1枚のアルバム",
    "other": "{0}枚のアルバム"
  },
  "drag_tooltip_many_playlists": {
    "one": "1つのプレイリスト",
    "other": "{0}個のプレイリスト"
  },
  "drag_tooltip_many_users": {
    "one": "1人のユーザー",
    "other": "{0}人のユーザー"
  }
}
},{}],237:[function(require,module,exports){
module.exports={
  "drag_tooltip_many_items": {
    "one": "1 item",
    "other": "{0} item"
  },
  "drag_tooltip_many_tracks": {
    "one": "1 lagu",
    "other": "{0} lagu"
  },
  "drag_tooltip_many_artists": {
    "one": "1 artis",
    "other": "{0} artis"
  },
  "drag_tooltip_many_albums": {
    "one": "1 album",
    "other": "{0} album"
  },
  "drag_tooltip_many_playlists": {
    "one": "1 senarai main",
    "other": "{0} senarai main"
  },
  "drag_tooltip_many_users": {
    "one": "1 pengguna",
    "other": "{0} pengguna"
  }
}
},{}],238:[function(require,module,exports){
module.exports={
  "drag_tooltip_many_items": {
    "one": "1 item",
    "other": "{0} items"
  },
  "drag_tooltip_many_tracks": {
    "one": "1 nummer",
    "other": "{0} nummers"
  },
  "drag_tooltip_many_artists": {
    "one": "1 artist",
    "other": "{0} artiesten"
  },
  "drag_tooltip_many_albums": {
    "one": "1 album",
    "other": "{0} albums"
  },
  "drag_tooltip_many_playlists": {
    "one": "1 afspeellijst",
    "other": "{0} afspeellijsten"
  },
  "drag_tooltip_many_users": {
    "one": "1 gebruiker",
    "other": "{0} gebruikers"
  }
}
},{}],239:[function(require,module,exports){
module.exports={
  "drag_tooltip_many_items": {
    "one": "1 element",
    "other": "Elementy: {0}"
  },
  "drag_tooltip_many_tracks": {
    "one": "1utwór",
    "other": "Liczba utworów: {0}"
  },
  "drag_tooltip_many_artists": {
    "one": "1 wykonawca",
    "other": "Wykonawcy: {0}"
  },
  "drag_tooltip_many_albums": {
    "one": "1 album",
    "other": "Albumy: {0}"
  },
  "drag_tooltip_many_playlists": {
    "one": "1 playlista",
    "other": "{0} playlisty"
  },
  "drag_tooltip_many_users": {
    "one": "1 użytkownik",
    "other": "Użytkownicy: {0}"
  }
}
},{}],240:[function(require,module,exports){
module.exports={
  "drag_tooltip_many_items": {
    "one": "1 item",
    "other": "{0} itens"
  },
  "drag_tooltip_many_tracks": {
    "one": "1 faixa",
    "other": "{0} faixas"
  },
  "drag_tooltip_many_artists": {
    "one": "1 artista",
    "other": "{0} artistas"
  },
  "drag_tooltip_many_albums": {
    "one": "1 álbum",
    "other": "{0} álbuns"
  },
  "drag_tooltip_many_playlists": {
    "one": "1 playlist",
    "other": "{0} playlists"
  },
  "drag_tooltip_many_users": {
    "one": "1 usuário",
    "other": "{0} usuários"
  }
}
},{}],241:[function(require,module,exports){
module.exports={
  "drag_tooltip_many_items": {
    "one": "1 objekt",
    "other": "{0} objekt"
  },
  "drag_tooltip_many_tracks": {
    "one": "Ett spår",
    "other": "{0} spår"
  },
  "drag_tooltip_many_artists": {
    "one": "1 artist",
    "other": "{0} artister"
  },
  "drag_tooltip_many_albums": {
    "one": "1 album",
    "other": "{0} album"
  },
  "drag_tooltip_many_playlists": {
    "one": "1 spellista",
    "other": "{0} spellistor"
  },
  "drag_tooltip_many_users": {
    "one": "1 användare",
    "other": "{0} användare"
  }
}
},{}],242:[function(require,module,exports){
module.exports={
  "drag_tooltip_many_items": {
    "one": "1 รายการ",
    "other": "{0} รายการ"
  },
  "drag_tooltip_many_tracks": {
    "one": "1 แทร็ก",
    "other": "{0} แทร็ก"
  },
  "drag_tooltip_many_artists": {
    "one": "ศิลปิน 1 ราย",
    "other": "ศิลปิน {0} ราย"
  },
  "drag_tooltip_many_albums": {
    "one": "1 อัลบั้ม",
    "other": "{0} อัลบั้ม"
  },
  "drag_tooltip_many_playlists": {
    "one": "1 เพลย์ลิสต์",
    "other": "{0} เพลย์ลิสต์"
  },
  "drag_tooltip_many_users": {
    "one": "ผู้ใช้ 1 คน",
    "other": "ผู้ใช้ {0} คน"
  }
}
},{}],243:[function(require,module,exports){
module.exports={
  "drag_tooltip_many_items": {
    "one": "1 Öge",
    "other": "{0} öge"
  },
  "drag_tooltip_many_tracks": {
    "one": "1 parça",
    "other": "{0} parça"
  },
  "drag_tooltip_many_artists": {
    "one": "1 sanatçı",
    "other": "{0} sanatçı"
  },
  "drag_tooltip_many_albums": {
    "one": "1 albüm",
    "other": "{0} albüm"
  },
  "drag_tooltip_many_playlists": {
    "one": "1 çalma listesi",
    "other": "{0} çalma listesi"
  },
  "drag_tooltip_many_users": {
    "one": "1 kullanıcı",
    "other": "{0} kullanıcı"
  }
}
},{}],244:[function(require,module,exports){
module.exports={
  "drag_tooltip_many_items": {
    "one": "1 mục",
    "other": "{0} mục"
  },
  "drag_tooltip_many_tracks": {
    "one": "1 bản nhạc",
    "other": "{0} bản nhạc"
  },
  "drag_tooltip_many_artists": {
    "one": "1 nghệ sĩ",
    "other": "{0} nghệ sĩ"
  },
  "drag_tooltip_many_albums": {
    "one": "1 album",
    "other": "{0} album"
  },
  "drag_tooltip_many_playlists": {
    "one": "1 playlist",
    "other": "{0} playlist"
  },
  "drag_tooltip_many_users": {
    "one": "1 người dùng",
    "other": "{0} người dùng"
  }
}
},{}],245:[function(require,module,exports){
module.exports={
  "drag_tooltip_many_items": {
    "one": "1 個項目",
    "other": "{0} 個項目"
  },
  "drag_tooltip_many_tracks": {
    "one": "1 首歌曲",
    "other": "{0} 首歌曲"
  },
  "drag_tooltip_many_artists": {
    "one": "1 位藝人",
    "other": "{0} 位藝人"
  },
  "drag_tooltip_many_albums": {
    "one": "1 張專輯",
    "other": "{0} 張專輯"
  },
  "drag_tooltip_many_playlists": {
    "one": "1 個播放清單",
    "other": "{0} 個播放清單"
  },
  "drag_tooltip_many_users": {
    "one": "1 位使用者",
    "other": "{0} 位使用者"
  }
}
},{}],246:[function(require,module,exports){
"use strict";const modules=[require("./lang"),require("./anchor"),require("./player"),require("./dragndrop"),require("./add"),require("./selection"),require("./contextmenu"),require("./sticky"),require("./navbar"),require("./offline"),require("./filter"),require("./tooltip"),require("./list"),require("./menu"),require("./scroll"),require("./carousel"),require("./scrollbar"),require("./header"),require("./slider"),require("./select"),require("./sort"),require("./thumbs"),require("./feedback"),require("./nft-feedback"),require("./list-quick-jump"),require("./cards"),require("./rtl")],events={};let isAttached=!1;events.update=function(e){isAttached&&modules.forEach(function(r){r.update(e)})},events.attach=function(){isAttached||(isAttached=!0,modules.forEach(function(e){e.attach()}))},events.detach=function(){isAttached&&(isAttached=!1,modules.forEach(function(e){e.detach()}))},module.exports=events;

},{"./add":198,"./anchor":199,"./cards":200,"./carousel":205,"./contextmenu":207,"./dragndrop":213,"./feedback":219,"./filter":220,"./header":221,"./lang":247,"./list":249,"./list-quick-jump":248,"./menu":250,"./navbar":251,"./nft-feedback":252,"./offline":253,"./player":255,"./rtl":260,"./scroll":261,"./scrollbar":262,"./select":263,"./selection":266,"./slider":270,"./sort":271,"./sticky":272,"./thumbs":273,"./tooltip":274}],247:[function(require,module,exports){
"use strict";let isAttached=!1;exports.update=(()=>{}),exports.attach=(()=>{if(isAttached)return;isAttached=!0;const t=window.__spotify&&window.__spotify.locale;t&&document.documentElement.setAttribute("lang",t)}),exports.detach=(()=>{isAttached&&(isAttached=!1,document.documentElement.removeAttribute("lang"))});

},{}],248:[function(require,module,exports){
"use strict";const center=require("./center"),cosmos=require("./util/cosmos"),SPACE_KEYCODE=32,BACKSPACE_KEYCODE=8,DELETE_KEYCODE=46;exports.attach=function(){document.addEventListener("keypress",onKeyPress,!1),document.addEventListener("keydown",onKeyDown,!1)},exports.detach=function(){document.removeEventListener("keypress",onKeyPress,!1),document.removeEventListener("keydown",onKeyDown,!1)},exports.update=function(){};const selector=":not([data-sticky-active]) > [data-list-quick-jump]",SEARCH_STRING_CONCATENATION_TIMEOUT=1e3,searchStringsByUri={},searchTimeoutsByUri={};function onKeyPress(e){shouldEventBeIgnored(e)||processEvent(e)}function onKeyDown(e){if(shouldEventBeIgnored(e))return;e.keyCode===BACKSPACE_KEYCODE&&processEvent(e)}function processEvent(e){const t=e.keyCode===BACKSPACE_KEYCODE,r=e.keyCode===SPACE_KEYCODE?" ":String.fromCharCode(e.keyCode).trim();if(!r&&!t)return;const s=getListNode(e.target);if(!s)return;const n=getUri(s);if(!n)return;if(t&&!searchStringsByUri[n])return;n in searchStringsByUri||(searchStringsByUri[n]=""),t?searchStringsByUri[n]=searchStringsByUri[n].slice(0,-1):r&&(searchStringsByUri[n]+=r),center.emit("list-quick-jump-request",n,searchStringsByUri[n]||null),searchTimeoutsByUri[n]&&clearTimeout(searchTimeoutsByUri[n]),e.keyCode===SPACE_KEYCODE&&e.preventDefault();const o=[{keyCode:SPACE_KEYCODE},{keyCode:BACKSPACE_KEYCODE},{keyCode:DELETE_KEYCODE}];cosmos.post({url:"sp://messages/v1/ignoreshortcuts",body:{action:"ignore",shortcuts:o}}),searchTimeoutsByUri[n]=setTimeout(function(){cosmos.post({url:"sp://messages/v1/ignoreshortcuts",body:{action:"unignore",shortcuts:o}}),delete searchStringsByUri[n],delete searchTimeoutsByUri[n],center.emit("list-quick-jump-request",n,null)},SEARCH_STRING_CONCATENATION_TIMEOUT)}function shouldEventBeIgnored(e){return e.metaKey||e.ctrlKey||e.target.matches("input, textarea, [contenteditable]")}function getListNode(e){let t=e.closest(selector);if(!t){const e=document.querySelectorAll(selector);e&&1===e.length&&(t=e[0])}return t}function getUri(e){const t=e.closest("[data-uri]");return t&&t.getAttribute("data-uri")}

},{"./center":206,"./util/cosmos":278}],249:[function(require,module,exports){
(function (global){
"use strict";const $=require("../spotify-elements"),live=require("../live"),center=require("./center"),selection=require("./selection"),cosmos=require("./util/cosmos"),appUtil=require("./util/app"),ROW_SELECTOR="[data-list-item]",UNAVAILABLE_CLASS_NAME="unavailable",OFFLINE_DOWNLOADED_CLASS_NAME="offline-downloaded",OFFLINE_DOWNLOADING_CLASS_NAME="offline-downloading",OFFLINE_WAITING_CLASS_NAME="offline-waiting",storedTrackURIsForUnplayable={},storedTrackURIsForOffline={};function updatePlayabilityForRows(e,o){const t=$(document).search(`${ROW_SELECTOR}[data-uri="${e}"]`);t&&updatePlayabilityForElements(t,o)}function updatePlayabilityForElements(e,o){o?e.removeClass(UNAVAILABLE_CLASS_NAME):e.addClass(UNAVAILABLE_CLASS_NAME)}function updateOfflineForRows(e,o,t){const n=$(document).search(`${ROW_SELECTOR}[data-uri="${e}"]`);n&&updateOfflineForElements(n,o,t)}function updateOfflineForElements(e,o,t){o?1===t?(e.addClass(OFFLINE_DOWNLOADED_CLASS_NAME),e.removeClass(OFFLINE_DOWNLOADING_CLASS_NAME),e.removeClass(OFFLINE_WAITING_CLASS_NAME)):0===t?(e.addClass(OFFLINE_WAITING_CLASS_NAME),e.removeClass(OFFLINE_DOWNLOADED_CLASS_NAME),e.removeClass(OFFLINE_DOWNLOADING_CLASS_NAME)):(e.addClass(OFFLINE_DOWNLOADING_CLASS_NAME),e.removeClass(OFFLINE_DOWNLOADED_CLASS_NAME),e.removeClass(OFFLINE_WAITING_CLASS_NAME)):(e.removeClass(OFFLINE_DOWNLOADED_CLASS_NAME),e.removeClass(OFFLINE_DOWNLOADING_CLASS_NAME),e.removeClass(OFFLINE_WAITING_CLASS_NAME))}function updateUnplayableRows(e,o){const t=o||($(e)||$(document)).search(ROW_SELECTOR);t&&t.forEach(function(e){const o=$(e).data("uri"),t=live(o),n=t.get("playable");void 0!==n&&updatePlayabilityForElements($(e),n),o in storedTrackURIsForUnplayable||(storedTrackURIsForUnplayable[o]=!0,t.on("update",function(e){"playable"in e&&updatePlayabilityForRows(o,e.playable)}))})}function updateOfflineSyncing(e,o){const t=o||($(e)||$(document)).search(ROW_SELECTOR);t&&t.forEach(function(e){const o=$(e).data("uri"),t=live(o);t.query("shouldBeOffline, offlineProgress",function(n,s){if(n)throw n;updateOfflineForElements($(e),s.shouldBeOffline,s.offlineProgress),o in storedTrackURIsForOffline||(storedTrackURIsForOffline[o]=!0,t.on("update",function(e){("shouldBeOffline"in e||"offlineProgress"in e)&&updateOfflineForRows(o,t.get("shouldBeOffline"),t.get("offlineProgress"))}))},live.ASAP)})}const ignoredShortcuts={};function handleKeyDown(e){if(!e.target.closest(ROW_SELECTOR)||ignoredShortcuts[JSON.stringify({keyCode:e.keyCode})])return;let o=!1;const t=/Win/.test(global.window.navigator.userAgent),n=8===e.keyCode,s=46===e.keyCode;(o=t?s:n||s)&&removeCurrentlySelectedListItems()}function removeCurrentlySelectedListItems(){const e=selection.getIndicesPerList();if(e.length>0){let o=null;e.forEach(function(e){let t=e;t.origin&&(t=t.origin);const n=live(t.uri),s=t.indices.sort(function(e,o){return e-o});n.query("allows(removeTracks)",function(e,t){if(e)throw e;t.allows.removeTracks&&n.get("rows",function(e,t){if(e)throw e;const n=s.map(function(e,o){return{type:"remove",index:e-o,length:1}});t.publish(n),null===o&&(o=s[0])})})})}}function handleScrollShow(e){updateUnplayableRows(e.container,e.nodes),updateOfflineSyncing(e.container,e.nodes)}exports._classNames={UNAVAILABLE:UNAVAILABLE_CLASS_NAME,OFFLINE_WAITING:OFFLINE_WAITING_CLASS_NAME,OFFLINE_DOWNLOADING:OFFLINE_DOWNLOADING_CLASS_NAME,OFFLINE_DOWNLOADED:OFFLINE_DOWNLOADED_CLASS_NAME};let isAttached=!1;exports.update=function(e){isAttached&&(updateUnplayableRows(e),updateOfflineSyncing(e))};const doc=$(document);let deleteSubscription,ignoredShortcutsSubscription;exports.attach=function(){isAttached||(isAttached=!0,doc.on("keydown",handleKeyDown),center.on("scroll-show-before",handleScrollShow),deleteSubscription=cosmos.subscribe({url:"sp://messages/v1/container/control"},function(e,o){if(e)throw e;const t=o.body;t&&"delete"===t.type&&appUtil.isActiveAndFocused()&&removeCurrentlySelectedListItems()}),ignoredShortcutsSubscription=cosmos.subscribe({url:"sp://messages/v1/ignoreshortcuts"},function(e,o){"ignore"===o.body.action?o.body.shortcuts.forEach(function(e){ignoredShortcuts[JSON.stringify(e)]=1}):"unignore"===o.body.action&&o.body.shortcuts.forEach(function(e){delete ignoredShortcuts[JSON.stringify(e)]})}))},exports.detach=function(){isAttached&&(isAttached=!1,doc.off("keydown",handleKeyDown),center.off("scroll-show-before",handleScrollShow),deleteSubscription&&(deleteSubscription.cancel(),deleteSubscription=null),ignoredShortcutsSubscription&&(ignoredShortcutsSubscription.cancel(),ignoredShortcutsSubscription=null))};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../live":148,"../spotify-elements":195,"./center":206,"./selection":266,"./util/app":277,"./util/cosmos":278}],250:[function(require,module,exports){
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.attach=attach,exports.detach=detach,exports.update=update;var _throttle=require("./util/throttle"),_throttle2=_interopRequireDefault(_throttle),_center=require("./center"),_center2=_interopRequireDefault(_center),_navigation=require("../navigation"),_navigation2=_interopRequireDefault(_navigation),_appState=require("../navigation/app-state"),_appState2=_interopRequireDefault(_appState);function _interopRequireDefault(e){return e&&e.__esModule?e:{default:e}}const SELECTOR_MENU="[data-menu]",SELECTOR_MENU_ITEM="[data-menu-item]",SELECTOR_MENU_ITEM_DISABLED="[data-menu-item-disabled]",SELECTOR_MENU_ITEM_ENABLED="[data-menu-item]:not([data-menu-item-disabled])",SELECTOR_SUBMENU='[data-submenu="true"]',ATTRIBUTE_MENU="data-menu",ATTRIBUTE_MENU_ITEM="data-menu-item",navigator=new _navigation2.default.Navigator;let isAttached=!1;const state={menu:null};function onMouseMove(e){if(e.target.matches(SELECTOR_MENU))return;const t=e.target.closest(SELECTOR_MENU_ITEM);if(!t)return;const n=getStateForMenu(t.closest(SELECTOR_MENU));let o=getStateForActiveMenu();t!==o.selectedNode&&(t.matches(SELECTOR_MENU_ITEM_DISABLED)?deselectItemInMenu(o):(selectItemInMenu(o,n,t),o=getStateForActiveMenu()),t.matches(SELECTOR_SUBMENU)?n.menu||openSubMenu(n,t):o.menu&&closeSubMenuOf(o))}const onMouseMoveThrottled=(0,_throttle2.default)(onMouseMove);function onFocus(e){const t=e.target.closest(SELECTOR_MENU);t&&!state.menu&&(state.menu={node:t,selectedNode:null,menu:null,active:!0,parent:null},t.addEventListener("mousemove",onMouseMoveThrottled),t.addEventListener("mouseleave",onMouseLeave),t.addEventListener("touchstart",onMouseMove,!0))}function onBlur(e){const{target:t,relatedTarget:n}=e;state.menu&&(t===state.menu.node?n&&t.contains(n)||hideMenu():state.menu.node.contains(t)&&!state.menu.node.contains(n)&&hideMenu())}function onKeyDown(e){if(!state.menu)return;const t=e.keyCode,n=27===t,o=38===t,u=40===t,s=37===t,i=39===t;if(13===t){const e=getStateForActiveMenu().selectedNode,t=e&&e.querySelector("a[href]");return t&&navigator.requestOpenState(new _appState2.default(t.getAttribute("href"))),void emitActivateItemEvent(e)}if(n)hideMenu();else if(o||u){const e=getStateForActiveMenu();if(e.node){const t=u?getMenuItemBelow(e):getMenuItemAbove(e);t&&selectItemInMenu(e,e,t)}}else if(i){const e=getStateForActiveMenu();if(e.selectedNode&&e.selectedNode.matches(SELECTOR_SUBMENU)){e.menu||openSubMenu(e,e.selectedNode);const t=e.menu.node,n=t.firstElementChild||t.firstChild;selectItemInMenu(e,e.menu,n)}}else if(s){const e=getStateForActiveMenu();e.parent&&closeSubMenuOf(e.parent)}else;}function onMouseLeave(e){if(!e.relatedTarget||!e.relatedTarget.closest(SELECTOR_MENU)){const e=getStateForActiveMenu();deselectItemInMenu(e),e.menu&&closeSubMenuOf(e)}}function onItemClick(e){emitActivateItemEvent(getStateForMenu(e.target.closest(SELECTOR_MENU)).selectedNode)}function onItemTouchStart(e){e.preventDefault(),onItemClick(e)}function emitActivateItemEvent(e){_center2.default.emit("menu-activate-item",{menu:{id:state.menu.node.getAttribute(ATTRIBUTE_MENU)||"",element:state.menu.node},item:{id:e.getAttribute(ATTRIBUTE_MENU_ITEM)||"",element:e}})}function selectItemInMenu(e,t,n){const o=e.menu===t,u=isSecondContainedInFirst(t,e);o?removeItemListeners(e.selectedNode):deselectItemInMenu(e),u&&deselectItemInMenu(t),e.active=!1,t.selectedNode!==n&&(n.classList.add("selected"),n.focus(),addItemListeners(n),t.selectedNode=n),t.active=!0}function deselectItemInMenu(e){if(e.selectedNode){const t=e.selectedNode;t.classList.remove("selected"),removeItemListeners(t),e.selectedNode=null}}function addItemListeners(e){e.addEventListener("click",onItemClick),e.addEventListener("touchstart",onItemTouchStart)}function removeItemListeners(e){e.removeEventListener("click",onItemClick),e.removeEventListener("touchstart",onItemTouchStart)}function openSubMenu(e,t){const n=t.querySelector(SELECTOR_MENU);n&&(e.menu={parent:e,node:n,selectedNode:null,menu:null,active:!1},n.classList.add("open"))}function closeSubMenuOf(e){e.menu.menu&&closeSubMenuOf(e.menu),e.selectedNode.focus(),e.menu.active&&(e.menu.active=!1,e.active=!0),deselectItemInMenu(e.menu),e.menu.node.classList.remove("open"),e.menu=null}function hideMenu(){if(state.menu){const e=state.menu.node;e.removeEventListener("mousemove",onMouseMoveThrottled),e.removeEventListener("mouseleave",onMouseLeave),e.removeEventListener("touchstart",onMouseMove,!0);let t=state.menu;for(;t;)deselectItemInMenu(t),t.node.classList.remove("open"),t=t.menu;delete state.menu,_center2.default.emit("menu-hide",{menu:{id:e.getAttribute(ATTRIBUTE_MENU)||"",element:e}})}}function isSecondContainedInFirst(e,t){let n=e.menu;for(;n&&n!==t;)n=n.menu;return!!n}function getStateForMenu(e){let t=state.menu;for(;t&&t.node!==e;)t=t.menu;return t}function getStateForActiveMenu(){let e=state.menu;for(;e&&!e.active;)e=e.menu;return e}function getMenuItemBelow(e){if(!e.selectedNode)return e.node.querySelector(SELECTOR_MENU_ITEM_ENABLED);let t=e.selectedNode.nextElementSibling;for(;t;){const e=t.matches(SELECTOR_MENU_ITEM),n=t.matches(SELECTOR_MENU_ITEM_DISABLED);if(e&&!n)break;t=t.nextElementSibling}return t}function getMenuItemAbove(e){if(!e.selectedNode){const t=e.node.querySelectorAll(SELECTOR_MENU_ITEM_ENABLED);return t[t.length-1]||null}let t=e.selectedNode.previousElementSibling;for(;t;){const e=t.matches(SELECTOR_MENU_ITEM),n=t.matches(SELECTOR_MENU_ITEM_DISABLED);if(e&&!n)break;t=t.previousElementSibling}return t}function attach(){isAttached||(isAttached=!0,document.addEventListener("keydown",onKeyDown),document.addEventListener("focus",onFocus,!0),document.addEventListener("blur",onBlur,!0))}function detach(){isAttached&&(isAttached=!1,state.menu=null,document.removeEventListener("keydown",onKeyDown),document.removeEventListener("focus",onFocus,!0),document.removeEventListener("blur",onBlur,!0))}function update(){}

},{"../navigation":168,"../navigation/app-state":167,"./center":206,"./util/throttle":281}],251:[function(require,module,exports){
(function (global){
"use strict";const $=require("../spotify-elements"),live=require("../live"),center=require("./center"),NAVBAR_ATTR_NAME="data-navbar",ITEM_ID_ATTR_NAME="data-navbar-item-id",ITEM_MATCHER_ATTR_NAME="data-navbar-item-matcher",VIEW_ID_ATTR_NAME="data-navbar-view-id",ACTIVE_ID_ATTR_NAME="data-navbar-active-id",HISTORY_POS_ATTR_NAME="data-navbar-history-position",CLASSNAME_ACTIVE="active",OVERFLOW_MENU_ID="navbar-overflow-menu",STICKY_WRAPPER_ATTR_NAME="data-sticky-fixed-wrapper",APPLICATION_MODEL_URI="spotify:application",storedMatchers={};let navbarOverflowItems,isShowingNavbarOverflow,shouldShowNavbarOverflow;const getSelector=function(e,t,n){return t&&n?`[${e}${t}"${n}"`+"]":`[${e}]`},updateOverflowMenu=function(){const e=document.querySelector("[data-navbar-item-id=navbar-overflow-menu]");if(e){if(navbarOverflowItems&&navbarOverflowItems.length||(shouldShowNavbarOverflow=!1),shouldShowNavbarOverflow){isShowingNavbarOverflow=!0;const t=navbarOverflowItems.map(function(e){const t=e.querySelector("a[href]");return{name:e.firstElementChild&&e.firstElementChild.textContent||"",id:e.getAttribute(ITEM_ID_ATTR_NAME),url:t&&t.getAttribute("href"),active:e.classList.contains("active")}}),n=e.getBoundingClientRect();global.top.postMessage({type:"show-navbar-overflow",items:t,right:n.right,top:n.bottom},"*")}!shouldShowNavbarOverflow&&isShowingNavbarOverflow&&(isShowingNavbarOverflow=!1,global.top.postMessage({type:"hide-navbar-overflow"},"*"))}},getTabsForId=function(e){if(!e)return[];const t=document.querySelectorAll(getSelector(ITEM_ID_ATTR_NAME,"=",e));return Array.prototype.slice.call(t)},getView=function(e){return document.querySelector(getSelector(VIEW_ID_ATTR_NAME,"=",e))},getNavbar=function(e){const t=e||document.documentElement,n=getSelector("data-navbar");return t.matches(n)?t:t.querySelector(n)},getActiveTab=function(){const e=getNavbar();if(!e)return null;const t=e.getAttribute(ACTIVE_ID_ATTR_NAME);return getTabsForId(t)[0]},getTabs=function(){const e=document.querySelectorAll(getSelector(ITEM_ID_ATTR_NAME));return Array.prototype.slice.call(e)},setActiveTabs=function(e,t){const n=getNavbar();if(!n)return;n.setAttribute(ACTIVE_ID_ATTR_NAME,e),t.forEach(function(e){e.classList.add("active")});const o=getTabs();o.length&&o.forEach(function(t){t.getAttribute(ITEM_ID_ATTR_NAME)!==e&&t.classList.remove("active")})},getViews=function(){const e=document.querySelectorAll(getSelector(VIEW_ID_ATTR_NAME));return Array.prototype.slice.call(e)},hide=function(e){e.style.display="none"},show=function(e){e.style.display="block"},setActiveView=function(e,t){if(!t)return;const n=getViews();for(let e=0,o=n.length;e<o;e++)n[e]!==t[0]&&(n[e].style.display="none");show(t)},setActive=function(e,t,n){const o=getActiveTab();(o&&o.getAttribute(ITEM_ID_ATTR_NAME))!==e&&(setActiveTabs(e,t),setActiveView(0,n),center.emit("navbar-change",{id:e}))},activateItem=function(e){updateScrollPosition();const t=getView(e),n=getTabsForId(e);setActive(e,n,t)},handleClick=function(e,t){const n=t.getAttribute(ITEM_ID_ATTR_NAME);if(n===OVERFLOW_MENU_ID)return shouldShowNavbarOverflow=!0,void updateOverflowMenu();activateItem(n),e.preventDefault()},hideOverflow=function(){isShowingNavbarOverflow&&(shouldShowNavbarOverflow=!1,updateOverflowMenu())},onMessage=function(e){e.data&&"navbar-overflow-click"===e.data.name&&activateItem(e.data.itemId),e.data&&"hide-navbar-overflow"===e.data.name&&hideOverflow()},getFirstTabId=function(){const e=document.querySelector(getSelector(ITEM_ID_ATTR_NAME));return e?e.getAttribute(ITEM_ID_ATTR_NAME)===OVERFLOW_MENU_ID?null:e.getAttribute(ITEM_ID_ATTR_NAME):null},setActiveForMatchingId=function(e){let t,n,o=0;for(;o<e.length&&(!t||!t.length);)e[o]&&(n=e[o],t=getTabsForId(n)),o++;const r=n;if(!t||!t.length)return;const i=getView(r);setActive(r,t,i)},fixAppURI=function(e){return e.split(":").slice(0,3).join(":")},getIdFromMatchers=function(e){for(const t in storedMatchers)if(storedMatchers.hasOwnProperty(t)){if(new RegExp(t).test(e))return storedMatchers[t]}return null},updateForNode=function(e){const t=getNavbar(e);t&&live("spotify:application").query("appURI, arguments",function(e,n){if(e)throw e;let o=fixAppURI(n.appURI);n.arguments&&(o+=`:${n.arguments}`);const r=getIdFromMatchers(o);if(r)setActiveForMatchingId([r]);else{const e=+t.getAttribute(HISTORY_POS_ATTR_NAME)||0,r=n.arguments.split(":")[e],i=getFirstTabId();setActiveForMatchingId([o,r,i])}})};function updateForOverflow(e){const t=getNavbar(e);if(!t)return;let n=e.querySelectorAll("[data-navbar] > [data-navbar-item-id]:not(.overflow-menu-button)");if(!n)return;n=Array.prototype.slice.call(n);const o=t.querySelector(".overflow-menu-button");if(n.length<2)return t.style.visibility="visible",void(o&&(o.style.display="none"));const r=getWidth(t);if(!r)return;o&&(o.style.display="inline"),n.forEach(function(e){e.style.display="block",e.classList.remove("last-visible")});const i=measureNavbar(n,o);let a=r,l=getFirstOverflownIndex(a,i.itemWidths);const c=n.length!==l;c&&(a-=i.overflowMenuButtonWidth,l=getFirstOverflownIndex(a,i.itemWidths)),navbarOverflowItems||(navbarOverflowItems=[]),navbarOverflowItems.length=0,n.forEach(function(e,t){const o=t>=l;o&&navbarOverflowItems.push(e);const r=!c&&t===n.length-1;e.style.display=o?"none":"block",e.classList.toggle("last-visible",r)}),o&&(o.style.display=c?"inline":"none"),updateOverflowMenu(),t.style.visibility="visible"}function updateScrollPosition(){const e=window.pageYOffset,t=Array.prototype.slice.call(document.querySelectorAll(`[${STICKY_WRAPPER_ATTR_NAME}]`));if(0===t.length)return;const n=t.reduce(function(e,t){const n=t.getBoundingClientRect().top;return n<e?n:e},0),o=parseInt(document.body.getAttribute("data-top-bar-height"),10)||0;n<0&&window.scrollTo(0,e+n+1-o)}function handleResize(){updateForOverflow(document.body)}function measureNavbar(e,t){const n=e[0],o=e[1],r=Math.floor(n.getBoundingClientRect().right),i=(Math.floor(o.getBoundingClientRect().left)-r)/2;let a=[];e&&(a=e.map(function(e,t,n){const o=0===t?0:i,r=t===n.length-1?0:i;return getWidth(e)+o+r}));let l=0;return t&&(l=getWidth(t)+i),{itemWidths:a,overflowMenuButtonWidth:l}}function getWidth(e){return e&&e.offsetWidth||0}function getFirstOverflownIndex(e,t){let n=0,o=0;for(;void 0!==t[n]&&o<e;)o+=t[n],n++;return o<e?n:n-1}const getMatchers=function(e){let t=e.querySelectorAll(getSelector(ITEM_MATCHER_ATTR_NAME));t.length&&(t=Array.prototype.slice.call(t)).forEach(function(e){const t=e.getAttribute(ITEM_MATCHER_ATTR_NAME),n=e.getAttribute(ITEM_ID_ATTR_NAME);storedMatchers[t]=n})},onApplicationChange=function(e){("arguments"in e||"active"in e)&&updateForNode(document.documentElement)};let isAttached=!1;exports.update=function(e){isAttached&&(updateForNode(e||document.documentElement),getMatchers(e||document.documentElement),updateForOverflow(e||document.documentElement))},exports.attach=function(){isAttached||(isAttached=!0,$(document).delegate("click",getSelector(ITEM_ID_ATTR_NAME),handleClick),window.addEventListener("message",onMessage),live("spotify:application").on("update",onApplicationChange),window.addEventListener("resize",handleResize),center.on("navbar-hide",hideOverflow))},exports.detach=function(){isAttached&&(isAttached=!1,navbarOverflowItems=null,isShowingNavbarOverflow=!1,shouldShowNavbarOverflow=!1,$(document).undelegate("click",getSelector(ITEM_ID_ATTR_NAME),handleClick),window.removeEventListener("message",onMessage),live("spotify:application").off("update",onApplicationChange),window.removeEventListener("resize",handleResize),center.off("navbar-hide",hideOverflow))};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../live":148,"../spotify-elements":195,"./center":206}],252:[function(require,module,exports){
"use strict";var _liveWrappedUri=require("../live-wrapped-uri"),_liveWrappedUri2=_interopRequireDefault(_liveWrappedUri),_station=require("../live-models/station");function _interopRequireDefault(e){return e&&e.__esModule?e:{default:e}}const dom=require("./util/dom"),$=require("../spotify-elements"),live=require("../live"),SELECTOR_NFT_FEEDBACK_BUTTON=".nft-enabled .feedback-enabled [data-button=add]";let isAttached=!1;function handleFeedbackClick(e,t){const i=t[0],r=dom.getAttributeFromNodeOrParent(i,"data-uri");let a=dom.getContextFromNodeOrParent(i);if(_liveWrappedUri2.default.parse(a)&&(a=_liveWrappedUri2.default.parse(a).originUri),!r||!a)return;const d=i.getAttribute("data-interaction-intent");if((0,_station.isOrdinaryRadioUri)(a))"save"===d&&live(a).emit("thumb-up",r);else switch(d){case"save":live(a).emit("heart",r);break;case"remove":live(a).emit("undo-heart",r)}}exports.update=(()=>{}),exports.attach=(()=>{if(isAttached)return;isAttached=!0,$(document).delegate("click",SELECTOR_NFT_FEEDBACK_BUTTON,handleFeedbackClick)}),exports.detach=(()=>{if(!isAttached)return;isAttached=!1,$(document).undelegate("click",SELECTOR_NFT_FEEDBACK_BUTTON,handleFeedbackClick)});

},{"../live":148,"../live-models/station":133,"../live-wrapped-uri":147,"../spotify-elements":195,"./util/dom":279}],253:[function(require,module,exports){
"use strict";const $=require("../spotify-elements"),live=require("../live");let sessionModel;function onSessionUpdate(e){"online"in e&&(e.online?$(document.body).removeClass("offline"):$(document.body).addClass("offline"))}function updateWithSessionValue(){live("spotify:client").query("session(online)",function(e,s){if(e)throw e;onSessionUpdate({online:s.session.online})})}let isAttached=!1;exports.update=function(){isAttached&&updateWithSessionValue()},exports.attach=function(){isAttached||(isAttached=!0,sessionModel||live("spotify:client").get("session",function(e,s){if(e)throw e;(sessionModel=s).on("update",onSessionUpdate)}))},exports.detach=function(){isAttached&&(isAttached=!1,sessionModel&&(sessionModel.off("update",onSessionUpdate),sessionModel=null))};

},{"../live":148,"../spotify-elements":195}],254:[function(require,module,exports){
"use strict";var _extends=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var o=arguments[t];for(var l in o)Object.prototype.hasOwnProperty.call(o,l)&&(e[l]=o[l])}return e};const $=require("../../spotify-elements"),utils=require("./utils"),SELECTOR_LIST_ROW="[data-context] [data-list-item]",SELECTOR_PLAY_BUTTON="[data-button=play]",SELECTOR_PLAY_CONTEXT_BUTTON="[data-button=play-context]";let lastEventTypes=[];const methods={getPlayerVariantUri:utils.createEmptyMethod("getPlayerVariantUri"),handlePlayButton:utils.createEmptyMethod("handlePlayButton"),handlePlayFromRow:utils.createEmptyMethod("handlePlayFromRow")};function handlePlayButtonClick(e,t){const o=t[0],l=utils.getUriFromButton(o);if(!l)return;const n=methods.getPlayerVariantUri(),s="queue"!==methods.getPlayerTrackProvider()&&utils.compareContexts(n,l),a=utils.getAttributeValueFromNode(o,"data-play-source");methods.handlePlayButton(o,{isPlayingContext:s,contextUri:l,source:a,reason:"playbtn"})}function handleListRow(e){const t=e[0],o=$(t.closest("[data-context]"));if(o&&!t.classList.contains("thumbs-down")){const e=utils.getAttributeValueFromNode(t,"data-play-source");methods.handlePlayFromRow(t,{contextUri:o.data("uri"),source:e,reason:"clickrow"})}}function handleRowDoubleClick(e,t){utils.isInteractiveElement(e.target)||handleListRow(t)}function handleRowKeyDown(e,t){if(13===e.keyCode){if(utils.isFormOrLinkElement(e.target))return;e.preventDefault(),e.stopPropagation(),handleListRow(t)}}function handleContextMenu(e){lastEventTypes.push(e.type)}function handleRowTouchStart(e){lastEventTypes.push(e.type)}function handleRowTouchMove(e){lastEventTypes.push(e.type)}function handleRowTouchEnd(e,t){1===lastEventTypes.length&&"touchstart"===lastEventTypes[0]&&(utils.isInteractiveElement(e.target)||(e.preventDefault(),handleListRow(t))),lastEventTypes=[]}const defaultSelectors={selectorPlayButton:"[data-button=play]",selectorListRow:SELECTOR_LIST_ROW,selectorPlayContextButton:"[data-button=play-context]"};let selectors=defaultSelectors;exports.attach=function(){const e=$(document);e.delegate("keydown",selectors.selectorListRow,handleRowKeyDown),e.delegate("click",selectors.selectorPlayButton,handlePlayButtonClick),e.delegate("click",selectors.selectorPlayContextButton,handlePlayButtonClick),e.delegate("dblclick",selectors.selectorListRow,handleRowDoubleClick),e.delegate("touchstart",selectors.selectorListRow,handleRowTouchStart),e.delegate("touchend",selectors.selectorListRow,handleRowTouchEnd),e.delegate("touchmove",selectors.selectorListRow,handleRowTouchMove),e.delegate("contextmenu",selectors.selectorListRow,handleContextMenu)},exports.detach=function(){const e=$(document);e.undelegate("keydown",selectors.selectorListRow,handleRowKeyDown),e.undelegate("click",selectors.selectorPlayButton,handlePlayButtonClick),e.undelegate("click",selectors.selectorPlayContextButton,handlePlayButtonClick),e.undelegate("dblclick",selectors.selectorListRow,handleRowDoubleClick),e.undelegate("touchstart",selectors.selectorListRow,handleRowTouchStart),e.undelegate("touchend",selectors.selectorListRow,handleRowTouchEnd),e.undelegate("touchmove",selectors.selectorListRow,handleRowTouchMove),e.undelegate("contextmenu",selectors.selectorListRow,handleContextMenu)},exports.setSelectors=function(e={}){exports.detach(),selectors=_extends({},defaultSelectors,e),exports.attach()},exports.setMethods=function(e){for(const t in e)e.hasOwnProperty(t)&&(methods[t]=e[t])};

},{"../../spotify-elements":195,"./utils":257}],255:[function(require,module,exports){
"use strict";const playerWithIndices=require("./withIndices"),playerWithUids=require("./withUids"),actions=require("./actions");let playerModule=playerWithIndices;exports.setMode=function(e){switch(e){case"indices":playerModule=playerWithIndices;break;case"uids":playerModule=playerWithUids}},exports.setSelectors=actions.setSelectors,exports.attach=function(){playerModule.attach()},exports.detach=function(){playerModule.detach()},exports.update=function(e){playerModule.update(e)};

},{"./actions":254,"./withIndices":258,"./withUids":259}],256:[function(require,module,exports){
"use strict";const difference=require("mout/array/difference"),$=require("../../spotify-elements"),live=require("../../live"),center=require("../center"),utils=require("./utils"),CURRENT="current",PAUSED="paused",PLAYING="playing",LOG_PLAY_BUTTON="play-button",LOG_PAUSE_BUTTON="pause-button",LOG_INTENT_PLAY="play",LOG_INTENT_PAUSE="pause",SELECTOR_PLAY_BUTTON="[data-button=play]",SELECTOR_PLAY_CONTEXT_BUTTON="[data-button=play-context]",SELECTOR_ALL_PLAY_BUTTONS=`${SELECTOR_PLAY_BUTTON},[data-button=play-context]`,INTERACTION_INTENT_ATTR="data-interaction-intent",SELECTOR_PLAYABLE_ROW="[data-context-index]",methods={getPlayerVariantUri:utils.createEmptyMethod("getPlayerVariantUri"),getPlayerIsPlaying:utils.createEmptyMethod("getPlayerIsPlaying"),getPlayingNodes:utils.createEmptyMethod("getPlayingNodes"),subscribeToPlayerChange:utils.createEmptyMethod("subscribeToPlayerChange")};let playableChangeHandlers={},playerSubscription=null;function updateDOM(e){const t=e||document;updateButtonsBasedOnPlayable(t);const a=getPlayingNodes(t),n=getCurrentNodes(t);if(n){let e=n;a&&(e=difference(n,a)),e.forEach(removePlayingStateFromNode)}if(a){let e=a;n&&(e=difference(a,n)),e.forEach(addPlayingStateToNode),difference(a,e).forEach(updatePlayingStateForNode)}}function updateButtonsBasedOnPlayable(e){const t=$(e).search("[data-button=play-context]");t&&t.forEach(updateButtonBasedOnPlayable)}function updateButtonBasedOnPlayable(e){if($(e).parent("[data-list-item]"))return;const t=utils.getUriFromButton(e),a=live(t).get("playable");void 0!==a&&(a?e.removeAttribute("disabled"):e.setAttribute("disabled","disabled"),playableChangeHandlers[t]||(playableChangeHandlers[t]=function(e){e.hasOwnProperty("playable")&&updateButtonsBasedOnPlayable(document.body)},live(t).on("update",playableChangeHandlers[t])))}function getCurrentNodes(e){return $(e).search("[data-playback-active=true]")}function getPlayingNodes(e){let t=[];if("queue"!==methods.getPlayerTrackProvider()){const a=methods.getPlayerVariantUri(),n=utils.getContextSelectorsWithVariants(a),r=$(e).search(n.join(", "));r&&(t=Array.prototype.slice.call(r))}return methods.getPlayingNodes(e,t)}function removePlayingStateFromNode(e){const t=[CURRENT,PAUSED,PLAYING].join(" "),a=$(e);if(a.removeClass(t).removeAttribute("data-playback-active"),a.matches(SELECTOR_ALL_PLAY_BUTTONS)&&(a.attribute("data-log-click",LOG_PLAY_BUTTON),a.attribute(INTERACTION_INTENT_ATTR,LOG_INTENT_PLAY)),a.matches(SELECTOR_PLAYABLE_ROW)){const e=a[0].querySelector(SELECTOR_PLAY_BUTTON);e&&e.setAttribute(INTERACTION_INTENT_ATTR,LOG_INTENT_PLAY)}}function addPlayingStateToNode(e){const t=methods.getPlayerIsPlaying(),a=[CURRENT,t?PLAYING:PAUSED].join(" "),n=$(e);if(n.addClass(a).data("playback-active",!0),n.matches(SELECTOR_ALL_PLAY_BUTTONS)&&(n.attribute("data-log-click",t?LOG_PAUSE_BUTTON:LOG_PLAY_BUTTON),n.attribute(INTERACTION_INTENT_ATTR,t?LOG_INTENT_PAUSE:LOG_INTENT_PLAY)),n.matches(SELECTOR_PLAYABLE_ROW)){const e=n[0].querySelector(SELECTOR_PLAY_BUTTON);e&&e.setAttribute(INTERACTION_INTENT_ATTR,t?LOG_INTENT_PAUSE:LOG_INTENT_PLAY)}}function updatePlayingStateForNode(e){const t=methods.getPlayerIsPlaying(),a=t?PAUSED:PLAYING,n=t?PLAYING:PAUSED,r=$(e);if(r.hasClass(a)&&r.removeClass(a),r.hasClass(n)||r.addClass(n),r.matches(SELECTOR_ALL_PLAY_BUTTONS)&&(r.attribute("data-log-click",t?LOG_PAUSE_BUTTON:LOG_PLAY_BUTTON),r.attribute(INTERACTION_INTENT_ATTR,t?LOG_INTENT_PAUSE:LOG_INTENT_PLAY)),e.matches(SELECTOR_PLAYABLE_ROW)){const a=e.querySelector(SELECTOR_PLAY_BUTTON);a&&a.setAttribute(INTERACTION_INTENT_ATTR,t?LOG_INTENT_PAUSE:LOG_INTENT_PLAY)}}function handleScrollShowAfter(e){const t=$(e.container);let a=null;updateDOM((a=t.matches("[data-context]")?t:t.parent("[data-context]"))&&a[0].parentElement||document)}exports.attach=function(){playerSubscription=methods.subscribeToPlayerChange(function(){updateDOM()}),center.on("scroll-show-after",handleScrollShowAfter)},exports.detach=function(){playerSubscription&&(playerSubscription.cancel(),playerSubscription=null);for(const e in playableChangeHandlers)playableChangeHandlers.hasOwnProperty(e)&&live(e).off("update",playableChangeHandlers[e]);playableChangeHandlers={},center.off("scroll-show-after",handleScrollShowAfter)},exports.update=updateDOM,exports.setMethods=function(e){for(const t in e)e.hasOwnProperty(t)&&(methods[t]=e[t])};

},{"../../live":148,"../../spotify-elements":195,"../center":206,"./utils":257,"mout/array/difference":387}],257:[function(require,module,exports){
(function (global){
"use strict";const liburi=require("spotify-liburi"),getOriginUri=require("../../live-wrapped-uri").getOriginUri;function getUriFromButton(t){const e=t.closest("[data-context]");return e&&e.getAttribute("data-uri")||""}function getAttributeValueFromNode(t,e){const r=`[${e}]`,o=t.closest(r);return o&&o.getAttribute(e)||""}function isFormOrLinkElement(t){const e=t.tagName.toLowerCase();return["input","textarea","button","select","optgroup","option","a"].indexOf(e)>-1}function isInteractiveElement(t){const e=t.tagName.toLowerCase();return"a"===e||"button"===e}function getContextSelector(t,e){return`[data-context][data-uri${t}${e}]`}function getContextSelectorsWithVariants(t){const e=getOriginUri(t)||t,r=normalizeUri(e),o=normalizeUri(e.replace(/^spotify:/,":")),n=[getContextSelector("=",e)];return n.push(getContextSelector("^=","spotify:internal:filterlist:")+getContextSelector("$=",e.replace(/^spotify:/,":"))),n.push(getContextSelector("^=","spotify:internal:sortlist:")+getContextSelector("$=",e.replace(/^spotify:/,":"))),e!==r&&(n.push(getContextSelector("=",r)),n.push(getContextSelector("^=","spotify:internal:filterlist:")+getContextSelector("$=",o)),n.push(getContextSelector("^=","spotify:internal:sortlist:")+getContextSelector("$=",o))),n}function compareContexts(t,e){if(!t||!e)return!1;return normalizeUri(getOriginUri(t)||t)===normalizeUri(getOriginUri(e)||e)}function normalizeUri(t){const e=liburi.from(t);let r=e?e.toString():t;return r=(r=r.replace(/^spotify:app:internal:/,"spotify:internal:")).replace(/:internal:filterlist:[^:]+/,function(t){return t.replace(/\+/g,"%20")})}function createEmptyMethod(t){return function(){global.console&&console.warn(`spotify-events/player: \`${t}\` is not implemented.`)}}exports.getUriFromButton=getUriFromButton,exports.getAttributeValueFromNode=getAttributeValueFromNode,exports.isFormOrLinkElement=isFormOrLinkElement,exports.isInteractiveElement=isInteractiveElement,exports.getContextSelector=getContextSelector,exports.getContextSelectorsWithVariants=getContextSelectorsWithVariants,exports.compareContexts=compareContexts,exports.normalizeUri=normalizeUri,exports.createEmptyMethod=createEmptyMethod;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../live-wrapped-uri":147,"spotify-liburi":450}],258:[function(require,module,exports){
"use strict";const live=require("../../live"),Range=require("../../range2"),$=require("../../spotify-elements"),playerActions=require("./actions"),playerUpdates=require("./updates"),utils=require("./utils");let isAttached=!1;function getPlayerTrackProvider(){const e=live("spotify:player").get("track");return e&&e.get("provider")||""}function getPlayerVariantUri(){const e=live("spotify:player").get("variant");return e?e.uri:""}function getPlayerIndex(){const e=live("spotify:player").get("index");return e?e.get("track"):-1}function getPlayerTrackUri(){const e=live("spotify:player").get("track");return e&&e.uri||""}function getPlayerUid(){return live("spotify:player").get("uid")}function getPlayerIsPlaying(){const e=live("spotify:player").get("isPlaying"),t=live("spotify:player").get("isPaused");return e&&!t}function subscribeToPlayerChange(e){live("spotify:player").on("update",e);let t=!0;return{cancel:function(){t&&(live("spotify:player").off("update",e),t=!1)}}}function handlePlayButton(e,t){const r=$(e),a=getPlayerIndex(),n=getPlayerTrackUri(),i=getPlayerUid();let o,s,l,c;const u=r.data("range");if(u){o=Range.fromString(u);const e=live(t.contextUri).get("rows");if(e){const t=o.toIndices();l=t.map(function(t){return e.keys[t]}),c=t.map(function(t){return e.get(t).get("track").uri})}s=null}else{let e=null;if(e=r.matches("[data-context-index]")?r:r.parent("[data-context-index]")){s=parseInt(e.data("context-index"),10);const r=live(t.contextUri).get("rows");r&&(l=[r.keys[s]],c=[r.get(s).get("track").uri])}else s=null}let y=!1;if(t.isPlayingContext)if(o)y=o.contains(new Range(a,a+1));else if(null!==s){const e=c&&c[0],t=l&&l[0];y=e===n&&(s===a||t===i)}else y=!0;if(y)getPlayerIsPlaying()?live("spotify:player").emit("pause"):live("spotify:player").emit("resume");else{const e={context:t.contextUri,index:s,source:t.source,reason:t.reason};o&&(e.range=[o.start,o.end]),l&&(e.uids=l),c&&(e.uris=c),live("spotify:player").emit("play",e)}}function handlePlayFromRow(e,t){let r=parseInt(e.getAttribute("data-context-index"),10);isNaN(r)&&(r=-1);const a=e.getAttribute("data-uid")||"",n=e.getAttribute("data-uri")||"",i={context:t.contextUri,index:r,source:t.source,reason:t.reason};a&&(i.uids=[a]),n&&(i.uris=[n]),live("spotify:player").emit("play",i)}function getPlayingNodes(e,t){const r=getPlayerIndex(),a=getPlayerTrackUri(),n=getPlayerVariantUri(),i=filterRanges(r,t),o=utils.getContextSelectorsWithVariants(n),s=getContextNodesForRows(e,o,r,a)||[],l=getContextNodesForRanges(e,o,r)||[];let c=[];if(t.length){const e=$(t).search("[data-button=play-context]");e&&(c=e.filter(e=>{const r=e.closest("[data-context]");return t.indexOf(r)>=0}))}const u=$([i,s,l,c]);return u?Array.prototype.slice.call(u):[]}function getContextNodesForRows(e,t,r,a){const n=`[data-uri="${a}"]`,i=`[data-context-index=${r}]${n}`,o=t.map(e=>`${e} ${i}`),s=$(e).find(o);if(s)return s;const l=t.map(e=>`${e} ${n}`);return $(e).find(l)}function getContextNodesForRanges(e,t,r){const a=t.map(function(e){return`${`${e} [data-range]`}, ${e+"[data-range]"}`});let n=$(e).search(a.join(", "));return filterRanges(r,n=n?Array.prototype.slice.call(n):[])}function filterRanges(e,t){const r=new Range(e,e+1);return t.filter(function(e){let t=$(e).data("range");return!t||!!r&&(t=Range.fromString(t)).contains(r)})}exports.attach=function(){isAttached||(isAttached=!0,playerActions.setMethods({getPlayerTrackProvider:getPlayerTrackProvider,getPlayerVariantUri:getPlayerVariantUri,handlePlayButton:handlePlayButton,handlePlayFromRow:handlePlayFromRow}),playerUpdates.setMethods({getPlayerTrackProvider:getPlayerTrackProvider,getPlayerVariantUri:getPlayerVariantUri,getPlayerIsPlaying:getPlayerIsPlaying,getPlayingNodes:getPlayingNodes,subscribeToPlayerChange:subscribeToPlayerChange}),playerActions.attach(),playerUpdates.attach())},exports.detach=function(){isAttached&&(isAttached=!1,playerActions.detach(),playerUpdates.detach())},exports.update=function(e){isAttached&&playerUpdates.update(e)};

},{"../../live":148,"../../range2":189,"../../spotify-elements":195,"./actions":254,"./updates":256,"./utils":257}],259:[function(require,module,exports){
"use strict";const live=require("../../live"),$=require("../../spotify-elements"),playerActions=require("./actions"),playerUpdates=require("./updates"),utils=require("./utils");let isAttached=!1;function getPlayerTrackProvider(){const e=live("spotify:player").get("track");return e&&e.get("provider")||""}function getPlayerVariantUri(){const e=live("spotify:player").get("variant");return e?e.uri:""}function getPlayerPageIndex(){const e=live("spotify:player").get("index"),t=e&&e.get("page");return"number"==typeof t?t:-1}function getPlayerTrackUid(){return live("spotify:player").get("uid")||""}function getPlayerTrackUri(){const e=live("spotify:player").get("track");return e&&e.uri||""}function getPlayerIsPlaying(){const e=live("spotify:player").get("isPlaying"),t=live("spotify:player").get("isPaused");return e&&!t}function getPlayerIsPlayingFromOpen(){const e=live("spotify:player").get("playOrigin"),t=e&&e.get("externalReferrer");return t&&0===t.indexOf("https://open.spotify.com/")}function subscribeToPlayerChange(e){live("spotify:player").on("update",e);let t=!0;return{cancel:function(){t&&(live("spotify:player").off("update",e),t=!1)}}}function handlePlayButton(e,t){let r=t.isPlayingContext;const a=utils.getAttributeValueFromNode(e,"data-uid"),i=utils.getAttributeValueFromNode(e,"data-track-uri"),n=parseInt(utils.getAttributeValueFromNode(e,"data-context-page"),10);if(r&&(r=verifyIsPlayingIndex(a,i,n)),r)getPlayerIsPlaying()?live("spotify:player").emit("pause"):live("spotify:player").emit("resume");else{const e={context:t.contextUri,source:t.source,reason:t.reason};a&&(e.uid=a),i&&(e.trackUri=i),isNaN(n)||(e.page=n),live("spotify:player").emit("play",e)}}function verifyIsPlayingIndex(e,t,r){if(e){return getPlayerTrackUid()===e}if(t){return getPlayerTrackUri()===t}if(!isNaN(r)){return getPlayerPageIndex()===r}return!0}function handlePlayFromRow(e,t){const r={context:t.contextUri,source:t.source,reason:t.reason},a=e.getAttribute("data-uid");a&&(r.uid=a);const i=parseInt(utils.getAttributeValueFromNode(e,"data-context-page"),10);isNaN(i)||(r.page=i),live("spotify:player").emit("play",r)}function getPlayingNodes(e,t){const r=getPlayerPageIndex(),a=getPlayerTrackUid(),i=getPlayerTrackUri(),n=getPlayerVariantUri(),o=filterPages(r,t),l=getContextNodesForRows(e,utils.getContextSelectorsWithVariants(n),a,i)||[],s=getContextNodesForPages(e,utils.getContextSelectorsWithVariants(n),r)||[];let c=[];if(t.length){const e=$(t).search("[data-button=play-context]");e&&(c=e.filter(e=>{const r=e.closest("[data-context]");return t.indexOf(r)>=0}))}const u=$([o,l,s,c]);return u?Array.prototype.slice.call(u):[]}function getContextNodesForRows(e,t,r,a){const i=getPlayerIsPlayingFromOpen(),n=t.map(function(e){let t=`${e} `;return i&&(t+=`[data-uri=${a}]`),i||(t+=`[data-uid=${r}]`),t}).join(", ");let o=$(e).search(n);if(o){if(o=Array.prototype.slice.call(o),i){const e=$(o[0]).data("uid");o=o.filter(function(t){return e===$(t).data("uid")})}}else o=[];return o}function getContextNodesForPages(e,t,r){const a=t.map(function(e){return`${`${e} [data-context-page]`}, ${e+"[data-context-page]"}`});let i=$(e).search(a.join(", "));return filterPages(r,i=i?Array.prototype.slice.call(i):[])}function filterPages(e,t){return t.filter(function(t){const r=parseInt(t.getAttribute("data-context-page"),10);return!!isNaN(r)||!isNaN(e)&&e===r})}exports.attach=function(){isAttached||(isAttached=!0,playerActions.setMethods({getPlayerTrackProvider:getPlayerTrackProvider,getPlayerVariantUri:getPlayerVariantUri,handlePlayButton:handlePlayButton,handlePlayFromRow:handlePlayFromRow}),playerUpdates.setMethods({getPlayerTrackProvider:getPlayerTrackProvider,getPlayerVariantUri:getPlayerVariantUri,getPlayerIsPlaying:getPlayerIsPlaying,getPlayingNodes:getPlayingNodes,subscribeToPlayerChange:subscribeToPlayerChange}),playerActions.attach(),playerUpdates.attach())},exports.detach=function(){isAttached&&(isAttached=!1,playerActions.detach(),playerUpdates.detach())},exports.update=function(e){isAttached&&playerUpdates.update(e)};

},{"../../live":148,"../../spotify-elements":195,"./actions":254,"./updates":256,"./utils":257}],260:[function(require,module,exports){
"use strict";function updateInput(t){t.hasAttribute("data-rtl-dir-flip")&&(""===t.value?t.removeAttribute("dir"):t.setAttribute("dir","auto"))}function handleGlobalChangeEvent(t){updateInput(t.target)}let isAttached=!1;exports.update=(t=>{(t||document).querySelectorAll("input, textarea").forEach(updateInput)}),exports.attach=(()=>{isAttached||(isAttached=!0,document.addEventListener("input",handleGlobalChangeEvent))}),exports.detach=(()=>{isAttached&&(isAttached=!1,document.removeEventListener("input",handleGlobalChangeEvent))});

},{}],261:[function(require,module,exports){
"use strict";const Range=require("../range2"),contains=require("mout/array/contains"),$=require("../spotify-elements"),SYNC=require("../../libs/prime/emitter").EMIT_SYNC,attentionHighlight=require("../../libs/glue").attentionHighlight,throttle=require("./util/throttle"),ListManager=require("./util/ListManager.js"),center=require("./center"),doc=$(document),win=$(window);let scrollContainers=[],listManagers=[],scrollHandlers=[];const pendingScrollContainers=[],pendingHiddenIndices=[];let cleanupHandlers=[];const getBounds=function(e,t){let n=e;n!==window&&n!==document.body||(n=document.body);const o=n===document.body?0:n.getBoundingClientRect().top,i=n===document.body?document.documentElement.clientHeight:n.clientHeight,r=t.getBoundingClientRect().top,c=t.offsetHeight;return{view:{top:o,height:i,bottom:o+i},container:{top:r,height:c,bottom:r+c}}},getRange=function(e,t,n,o=0){const i=getBounds(e,t),r=-(i.container.top-i.view.top);let c=Math.floor((r-o)/n);const s=Math.ceil((r+i.view.height+o)/n);return c<0&&(c=0),!(s<=c)&&new Range(c,s)},init=function(e,t,n,o,i){const r=e[0],c=t[0];let s=-1;t.addClass("scroll-container-enabled");const l=(e,n)=>{if($(e)===t){const e=c.querySelector(`[data-index='${n}']`);if(!e)return void(s=n);s=-1;let t=document.querySelector("[data-table-row-attention-highlight]");t||((t=document.createElement("div")).className="tl-attention-highlight",t.setAttribute("data-table-row-attention-highlight",""),document.body.appendChild(t));const o=window.pageYOffset,i=e.getBoundingClientRect(),r=document.body.offsetWidth;t.classList.add("visible"),t.style.top=`${i.top+o}px`,t.style.left=`${i.left}px`,t.style.right=`${r-i.right}px`,setTimeout(()=>{t.classList.remove("visible")},attentionHighlight.HIDE_DELAY)}},a=new ListManager(c,{height:o,length:n,tag:i,debug:!1,request:function(e,t){center.emit("scroll-request",c,e,t,SYNC)}});listManagers.push(a);const d=pendingScrollContainers.indexOf(t);d>-1&&(a.reset(n,pendingHiddenIndices[d]),pendingScrollContainers.splice(d,1),pendingHiddenIndices.splice(d,1)),a.on("before-show",function(e,n){center.emit("scroll-show-before",{pageNode:t,container:t,range:e,nodes:n},SYNC)}),a.on("after-show",function(e,n){center.emit("scroll-show-after",{pageNode:t,container:t,range:e,nodes:n},SYNC)}),a.on("index-change",function(e){center.emit("scroll-index-change",{pageNode:t,container:t,ranges:e},SYNC)});let h=!1;const u=function(e,n,o,i){if($(e)===t){"number"==typeof i&&i>0?a.resetFrom(i,n,o):a.reset(n,o),t._scrollEvent()}},g=function(){const e=getBounds(r,c);let n=getRange(r,c,o);if(n){a.on("after-show",function e(){a.off("after-show",e),s>-1&&s>=n.start&&s<n.end&&l(t,s)});const e=2;n=new Range(n.start-e,n.end+e),a.show(new Range(n.start,n.end))}h||e.container.bottom<2e3&&(h=!0,center.emit("scroll-request-more",c,function(e,t){if(e)throw e;h=!1,u(c,t)}))};scrollHandlers.push(g),t._scrollEvent=throttle(g),center.on("scroll-reset",u),t._scrollResetEvent=u;const f=function(e,n,o={}){if(r!==window)throw new Error("Can't scroll to index if view is not `window`");if($(e)===t){const e=getBounds(r,c),t=o.centerRowIfScrollIsNeeded?(e.view.height-a.height)/2:0,i=a.height*n,s=e.container.top+i;let l=s+window.pageYOffset,d=(doc.search("[data-sticky-active]")||[]).map(function(e){return e.offsetHeight}).reduce(function(e,t){return e+t},0);if(document.querySelector("[data-top-bar-height]")&&(d+=parseInt(document.querySelector("[data-top-bar-height]").getAttribute("data-top-bar-height"),10)),s<=d)l-=t+d;else{if(!(s+a.height>e.view.height))return;l+=t+a.height-e.view.height}r.scrollTo(0,l)}},p=()=>{const e=document.querySelector("[data-table-row-attention-highlight]");e&&e.parentNode.removeChild(e)};center.on("scroll-to-index",f),center.on("attention-highlight-index",l),center.on("hide-attention-highlight",p),e.on("scroll",g),win.on("resize",g),g(),cleanupHandlers.push({container:t,clean:function(){center.off("scroll-reset",u),center.off("scroll-to-index",f),center.off("attention-highlight-index",l),center.off("hide-attention-highlight",p),e.off("scroll",g),win.off("resize",g),delete t._scrollEvent,delete t._scrollResetEvent,s=-1,t.removeClass("scroll-container-enabled")}})};function onScrollSetHidden(e){const t=e.indices,n=$(e.itemContainer),o=scrollContainers.indexOf(n);if(o>-1){const e=listManagers[o];e&&e.reset(e.length,t);const n=scrollHandlers[o];n&&n()}else pendingScrollContainers.push(n),pendingHiddenIndices.push(t)}let isAttached=!1;exports.update=function(e){if(!isAttached)return;const t=$(e)||doc;let n=doc.search("[data-scroll-container]");const o=[],i=[];scrollContainers=scrollContainers.filter(function(e,t){if(!contains(n,e[0])){for(let t=0;t<cleanupHandlers.length;t++)if(cleanupHandlers[t].container===e){cleanupHandlers[t].clean(),cleanupHandlers.splice(t,1);break}return!1}return i.push(listManagers[t]),o.push(scrollHandlers[t]),!0}),listManagers=i,scrollHandlers=o,t!==doc&&(n=t.search("[data-scroll-container]")),n&&n.forEach(function(e){const t=$(e);if(t._scrollEvent||e.children.length)return;scrollContainers.push(t);const n=t.parent("[data-scroll-view]")||win;center.emit("scroll-request",t[0],new Range(0,3),function(e,o,i){if(e)throw e;let r=o;if(contains(doc.search("[data-scroll-container]"),t[0])){(r=$(r)).insert(t);const e=r[1],o=e.offsetHeight,c=$(e).tag();r.remove(),init(n,t,i,o,c)}},SYNC)})},exports.attach=function(){isAttached||(isAttached=!0,center.on("scroll-set-hidden",onScrollSetHidden))},exports.detach=function(){isAttached&&(isAttached=!1,center.off("scroll-set-hidden",onScrollSetHidden),scrollContainers=[],cleanupHandlers.forEach(function({clean:e}){e()}),cleanupHandlers=[])};

},{"../../libs/glue":85,"../../libs/prime/emitter":186,"../range2":189,"../spotify-elements":195,"./center":206,"./util/ListManager.js":275,"./util/throttle":281,"mout/array/contains":386}],262:[function(require,module,exports){
"use strict";var _cosmosApi=require("../cosmos-api"),_cosmosApi2=_interopRequireDefault(_cosmosApi),_os=require("../os");function _interopRequireDefault(e){return e&&e.__esModule?e:{default:e}}let controlMessageSubscription,isAttached=!1,currentStyle="always-visible",fixAttemptCounter=0;const platformToClassNamePlatform={[_os.PLATFORM_UNKNOWN]:"linux",[_os.PLATFORM_MAC]:"mac",[_os.PLATFORM_WINDOWS]:"windows"};let previousPlatformId=platformToClassNamePlatform[_os.PLATFORM_UNKNOWN],currentPlatformId=platformToClassNamePlatform[_os.PLATFORM_UNKNOWN];function refreshStyle(){"always-visible"===currentStyle||"mac"!==currentPlatformId?(document.body.classList.remove(`scrollbar-style-visible-${previousPlatformId}`),document.body.classList.remove("scrollbar-style-when-scrolling-mac"),document.body.classList.add(`scrollbar-style-visible-${currentPlatformId}`)):(document.body.classList.remove(`scrollbar-style-visible-${currentPlatformId}`),document.body.classList.remove(`scrollbar-style-visible-${previousPlatformId}`),document.body.classList.add("scrollbar-style-when-scrolling-mac"))}function performScrollBarFix(){const e=[],o=["scroll","auto","overlay"];[...document.querySelectorAll("*")].forEach(t=>{const r=window.getComputedStyle(t),s=r.overflowX,l=r.overflowY;o.includes(s)&&e.push({node:t,property:"overflow-x"}),o.includes(l)&&e.push({node:t,property:"overflow-y"})});const t=document.createElement("style");t.innerHTML="\n    html::-webkit-scrollbar,\n    body::-webkit-scrollbar {\n      background-color: rgba(1, 2, 3, 0) !important;\n    }\n  ".trimRight();const r=`data-scrollbar-fix-${++fixAttemptCounter}-id`;let s=0;e.forEach(({node:e,property:o})=>{if(e!==document.body){const l=++s;e.setAttribute(r,l),t.innerHTML+=`\n    [${r}="${l}"] { ${o}: hidden !important; }`}}),document.head.appendChild(t),setTimeout(()=>{document.head.removeChild(t),e.forEach(({node:e})=>{e.removeAttribute(r)})},0)}exports.performScrollBarFix=performScrollBarFix,exports.update=function(){},exports.attach=function(){if(isAttached)return;isAttached=!0;const e=window.__spotify&&window.__spotify.scroller_style;currentStyle="overlay"===e?"overlay":"always-visible",(0,_os.subscribeToPlatform)((e,o)=>{currentPlatformId=platformToClassNamePlatform[e],previousPlatformId=platformToClassNamePlatform[o],refreshStyle()}),window.addEventListener("message",e=>{"set_active"===e.data.name&&e.data.active&&performScrollBarFix()}),controlMessageSubscription=_cosmosApi2.default.resolver.subscribe({url:"sp://messages/v1/container/control"},(e,o)=>{if(e)controlMessageSubscription.cancel();else{const e=o.getJSONBody();if(e){let o=!1;switch(e.type){case"set_scroller_style_always_visible":currentStyle="always-visible",o=!0;break;case"set_scroller_style_overlay":currentStyle="overlay",o=!0}o&&refreshStyle(),o&&(performScrollBarFix(),setTimeout(performScrollBarFix,1e3))}}})},exports.detach=function(){isAttached&&(isAttached=!1,fixAttemptCounter=0,controlMessageSubscription&&(controlMessageSubscription.cancel(),controlMessageSubscription=null))};

},{"../cosmos-api":54,"../os":174}],263:[function(require,module,exports){
"use strict";const $=require("../spotify-elements"),center=require("./center"),live=require("../live"),ATTR_SELECT="select",ATTR_PROPERTY="select-property",SELECTOR_SELECT=`[data-${ATTR_SELECT}]`,storedNodes=[];function handleChange(e,t){const n=t.data(ATTR_PROPERTY),c=t[0];n?publish(c,n):emitUpdate(c,selectedValue(c))}function selectedValue(e){return e.options[e.selectedIndex].value}function onSelectSet(e){if(!e.id)return;const t=$(`[data-${ATTR_SELECT}=${e.id}]`);if(!t)return;const n=t[0],c=e.selected,i=t.data(ATTR_PROPERTY);i?publish(n,i,c):setState(n,c)}function publish(e,t,n){const c=getUriFromNode(e);if(!c)return;const i=live(c);if(void 0===i.get(t))return;const o=void 0===n?selectedValue(e):n,s={};s[t]=o,i.publish(s)}function updateNode(e){if(storedNodes.indexOf(e)>-1)return;storedNodes.push(e);const t=$(e).data(ATTR_PROPERTY);if(!t)return;const n=getUriFromNode(e);if(!n)return;const c=live(n);c.get(t,function(n,i){if(n)throw n;setState(e,i),c.on("update",function(n){t in n&&setState(e,n[t])})})}function setState(e,t){updateNodeWithValue(e,t),emitUpdate(e,t)}function updateNodeWithValue(e,t){const n=$(e).find(`option[value="${t}"]`);n&&!n.attribute("selected")&&n.select()}function emitUpdate(e,t){const n=$(e).data(ATTR_SELECT)||null;center.emit("select-change",{element:e,id:n,selected:t})}function getUriFromNode(e){const t=e.closest("[data-uri]");return t?t.getAttribute("data-uri"):null}let isAttached=!1;exports.update=function(e){if(!isAttached)return;const t=$(e||document).search(SELECTOR_SELECT);t&&t.forEach(updateNode)},exports.attach=function(){if(isAttached)return;isAttached=!0,$(document).delegate("change",SELECTOR_SELECT,handleChange),center.on("select-set",onSelectSet)},exports.detach=function(){if(!isAttached)return;isAttached=!1,$(document).undelegate("change",SELECTOR_SELECT,handleChange),center.off("select-set",onSelectSet)};

},{"../live":148,"../spotify-elements":195,"./center":206}],264:[function(require,module,exports){
"use strict";const $=require("../../spotify-elements"),live=require("../../live"),containers=[];function reset(){containers.length=0}function update(){const t=$(document).search(":not(.sticky-clone) > [data-list]");t&&t.forEach(function(t){containers.includes(t)||(containers.push(t),containers.sort((t,e)=>{let n;return n=t===e?0:t.compareDocumentPosition(e)&Node.DOCUMENT_POSITION_PRECEDING?1:-1}))})}function getContainerLength(t){const e=$(containers[t]);if(!e)return 0;const n=e.data("uri");if(!n)return 0;const r=live(n).get("rows");return r?r.length:0}function getContainerIndex(t){for(let e=0,n=containers.length;e<n;e++){if(getUri(e)===t)return e}return-1}function getUri(t){const e=containers[t];return e&&e.getAttribute("data-uri")||null}function getUris(){const t=[];for(let e=0,n=containers.length;e<n;e++)t.push(getUri(e));return t}function getLiveList(t){const e=getUri(t);return live(e).get("rows")||null}exports.elements=containers,exports.reset=reset,exports.update=update,exports.getContainerLength=getContainerLength,exports.getContainerIndex=getContainerIndex,exports.getUri=getUri,exports.getUris=getUris,exports.getLiveList=getLiveList;

},{"../../live":148,"../../spotify-elements":195}],265:[function(require,module,exports){
(function (global){
"use strict";const $=require("../../spotify-elements"),intersection=require("mout/array/intersection"),live=require("../../live"),liburi=require("spotify-liburi"),center=require("../center"),selection=require("./index"),model=require("./model"),rows=require("./rows"),containers=require("./containers"),positions=require("./positions"),Position=require("../util/Position"),cosmos=require("../util/cosmos");let focusEventValid=!1,mouseDownTarget=null;const listListeners={},listListenerUris=[],SELECTABLE="[data-list-item]",CLIPBOARD_ENDPOINT="sp://desktop/v1/clipboard";function isOnDocument(e){return e.target===document.documentElement}function getNodeFromEvent(e){return e.target!==document&&e.target.closest(SELECTABLE)}function isFilterTarget(e){return e!==document&&!!e.closest("[data-filter]")}function handleMouseDown(e,t){if(isOnDocument(e))return;focusEventValid=!1;const n=getNodeFromEvent(e);if(t){if(e.target!==mouseDownTarget)return void(mouseDownTarget=null);mouseDownTarget=null}else mouseDownTarget=e.target;n?handleRowMouseDown(e,n,t):handleOutsideMouseDown(e)}function handleRowMouseDown(e,t,n){const o=1===getButtonFromEvent(e),i=positions.getFromNode(t);if(!i)return;const s=model.isSelected(i);let l=isMac()?e.metaKey:e.ctrlKey,r=e.shiftKey||l,d=!e.shiftKey;if(isMultiSelectEnabled()||(l=r=!1,d=!0),r&&d&&s&&o){if(!n)return;handleDeselectOnSingleMultiSelect(i)}else if(d){if(o&&s&&!n)return;if(r&&!n)return;handleSingleSelect(i,e,n)}else{if(n)return;handleShiftMultiSelect(i)}rows.update()}function handleOutsideMouseDown(e){const t=e.target!==document&&!!e.target.closest("[data-sort]"),n=isFilterTarget(e.target),o=model.hasSelection();t||n||!o||(model.clear(),rows.update())}function handleFocus(e){if(!focusEventValid)return;const t=getNodeFromEvent(e);t?handleRowFocus(e,t):handleOutsideFocus(e),focusEventValid=!1}function handleRowFocus(e,t){const n=positions.getFromNode(t);n&&!model.isSelected(n)&&(model.clear(),model.add(n),model.setFocus(n),model.setOrigin(n),rows.update())}function handleOutsideFocus(e){isFilterTarget(e.target)||(model.clear(),rows.update())}function handleMouseUp(e){isOnDocument(e)||handleMouseDown(e,!0)}function handleDeselectOnSingleMultiSelect(e){const t=model.getOrigin(),n=model.getFocus();let o=positions.getDirection(t,n);o||(o=1);const i=e.isSame(t),s=e.isSame(n);let l,r;(i||s)&&(l=getClosestSelected(e,"up"),r=getClosestSelected(e,"down")),i&&model.setOrigin(1===o?r||l:l||r),e.isSame(n)&&model.setFocus(1===o?l||r:r||l),model.remove(e)}function handleShiftMultiSelect(e){let t=model.getOrigin();const n=model.getFocus();t&&n&&!t.isSame(n)&&model.remove(t,n),t||(t=new Position(0,0),model.setOrigin(t)),model.add(t,e),model.setFocus(e)}function handleSingleSelect(e,t){const n=model.getOrigin(),o=getButtonFromEvent(t),i=1===o,s=2===o,l=model.isSelected(e);let r=isMac()?t.metaKey:t.ctrlKey,d=t.shiftKey||r;let c;if(isMultiSelectEnabled()||(r=d=!1),(!d&&i||!l&&s)&&model.clear(),model.add(e),model.setFocus(e,{isTouch:isTouchEvent(t)}),n&&!n.isSame(e)){const t=positions.getClosest(e,"down");if(!(c=t&&model.isSelected(t))){const t=positions.getClosest(e,"up");c=t&&model.isSelected(t)}}c||model.setOrigin(e)}function handleKeyDown(e){if(isFilterTarget(e.target))return;focusEventValid=!0;const t=38===e.keyCode,n=40===e.keyCode;if(!isKeyboardNavEnabled())return;if(!t&&!n)return;const o=model.getOrigin(),i=model.getFocus();let s=i;do{s=s&&positions.getClosest(s,n?"down":"up")}while(s&&model.isPositionHidden(s));if((t||n)&&!e.metaKey&&!e.ctrlKey&&s){if(e.shiftKey&&isMultiSelectEnabled()&&o&&i){const e=n?1:-1,t=positions.getDirection(o,i);0===t||e===t?(model.add(s),scrollIntoView(s)):model.remove(i)}else model.clear(),model.add(s),model.setOrigin(s),scrollIntoView(s),e.preventDefault();model.setFocus(s)}rows.update()}function handleScrollShowAfter(e){const t=e.pageNode&&e.pageNode[0];rows.update(t)}function handleSetHidden(e){model.setHiddenIndices(e.indices,e.uri)}function handleAddByUri(e,t,n){const o=$(`[data-uri=${e}]`),i=intersection(containers.elements,o);let s=t;if(!i||i.length<1)return;const l=$(i[0]);let r=l&&containers.elements.indexOf(l[0]);if(l&&l.matches("[data-context]")){const e=positions.getPositionFromGlobalIndex(s);r=e.containerIndex,s=e.index}else if(-1===r)return void console.warn("No container matching this uri was found or selection doesn't know about the container. Possibly you need to run events.update.");isMultiSelectEnabled()||model.clear();const d=new Position(r,s);model.getOrigin()||model.setOrigin(d),model.setFocus(d),model.add(d),rows.update(),!0!==n&&scrollIntoView(d)}function handleSelectAll(){if(!isMultiSelectEnabled())return;model.clear();const e=new Position(0,0);model.setOrigin(e);const t=positions.getLastPositionForSelectAll();model.setFocus(t),model.add(e,t),rows.update()}function handleCopy(){cosmos.put({url:CLIPBOARD_ENDPOINT,body:handleGetUris().map(e=>{const t=liburi.from(e);return t&&t.toOpenURL()}).filter(Boolean).join("\n")})}function handleCopyAdvanced(){cosmos.put({url:CLIPBOARD_ENDPOINT,body:handleGetUris().filter(Boolean).join("\n")})}function handleCut(){handleCopy(),cosmos.post({url:"sp://messages/v1/container/control",body:{type:"delete"}})}function handleGetUris(){const e=model.selections,t=[];let n;const o=e=>!!n[e];for(let i=0;i<e.length;i++){if(!(n=e[i]))continue;let s;const l=containers.getLiveList(i);if(!l)continue;const r=l.keys.filter(o);for(let e=0,n=r.length;e<n;e++){const n=l.valueOf(r[e]);n&&((s=n.get("track"))||(s=n.get("playlist")),s||(s=n.get("album")),s||(s=n.get("artist")),s||(s=n.get("user")),s||(s=n),t.push(s.get("uri")))}}return t}function getButtonFromEvent(e){if(isTouchEvent(e))return 1;switch(e.button){case 0:return 1;case 2:return 2;case 1:return 3;default:return 0}}function isMac(){if(!global.window)return!1;if(!global.window.navigator)return!1;return(global.window.navigator.userAgent||"").indexOf("Mac")>-1}function isMultiSelectEnabled(){return null===$("body").data("multi-select-disabled")&&(!!global.window&&!!global.window._getSpotifyModule)}function isKeyboardNavEnabled(){return null===$("body").data("keyboard-select-disabled")}function isTouchEvent(e){return!!e.changedTouches}function getClosestSelected(e,t){let n=e;for(;n;)if((n=positions.getClosest(n,t))&&model.isSelected(n))return n;return null}function scrollIntoView(e){const t=containers.elements[e.containerIndex],n=t&&t.querySelector("[data-scroll-container]");if(n)center.emit("scroll-to-index",n,e.index);else{const t=positions.getNodeFromPosition(e);if(!t)return;const n=t.getBoundingClientRect().top;(n<0||n>=window.innerHeight)&&t.scrollIntoView(n<0)}}function updateListListeners(){const e=containers.getUris();for(let t=0,n=e.length;t<n;t++){const n=e[t];if(n&&-1===listListenerUris.indexOf(n)){const e=live(n).get("rows");if(e){const t=createListListener(n);e.on("update",t),listListeners[n]=t,listListenerUris.push(n)}}}}function createListListener(e){return function(t){const n=containers.getUris().indexOf(e);if(n>-1){for(let e=0,o=t.length;e<o;e++){if("remove"===t[e].type){model.updateContainer(n);break}}rows.update()}}}function resetListListeners(){for(let e=0,t=listListenerUris.length;e<t;e++){const n=listListenerUris[e],o=listListeners[n],i=live(n).get("rows");i&&o&&(i.off("update",o),delete listListeners[n],listListenerUris.splice(e,1),e--,t--)}}function handleListSwap(e){const t=live(e.before).get("rows");if(!t)return;const n=selection.getIndicesPerList().filter(function(t){return t.uri===e.before})[0];let o=[];n&&(o=n.indices.map(function(e){return t.keys[e]})),center.on("scroll-reset",function t(){center.off("scroll-reset",t),live(e.after).get("rows",function(t,n){o.forEach(function(t){const o=n.keys.indexOf(t);-1!==o&&handleAddByUri(e.after,o,!0)})},live.ASAP)})}exports.handleMouseDown=handleMouseDown,exports.handleMouseUp=handleMouseUp,exports.handleKeyDown=handleKeyDown,exports.handleFocus=handleFocus,exports.handleScrollShowAfter=handleScrollShowAfter,exports.handleSetHidden=handleSetHidden,exports.handleAddByUri=handleAddByUri,exports.handleSelectAll=handleSelectAll,exports.handleCopy=handleCopy,exports.handleCopyAdvanced=handleCopyAdvanced,exports.handleCut=handleCut,exports.handleGetUris=handleGetUris,exports.updateListListeners=updateListListeners,exports.resetListListeners=resetListListeners,exports.handleListSwap=handleListSwap;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../live":148,"../../spotify-elements":195,"../center":206,"../util/Position":276,"../util/cosmos":278,"./containers":264,"./index":266,"./model":267,"./positions":268,"./rows":269,"mout/array/intersection":393,"spotify-liburi":450}],266:[function(require,module,exports){
"use strict";const $=require("../../spotify-elements"),live=require("../../live"),getOriginUri=require("../../live-wrapped-uri").getOriginUri,center=require("../center"),controller=require("./controller"),containers=require("./containers"),model=require("./model"),rows=require("./rows"),positions=require("./positions"),Position=require("../util/Position"),appUtil=require("../util/app"),cosmos=require("../util/cosmos");let controlMessageSubscription;exports.attach=function(){const e=$(document);e.on("mousedown",controller.handleMouseDown),e.on("touchstart",controller.handleMouseDown),e.on("mouseup",controller.handleMouseUp),e.on("touchend",controller.handleMouseUp),e.on("keydown",controller.handleKeyDown),e.on("focus",controller.handleFocus,!0),center.on("scroll-show-after",controller.handleScrollShowAfter),center.on("selection-set-hidden",controller.handleSetHidden),center.on("list-swap",controller.handleListSwap),controlMessageSubscription=cosmos.subscribe({url:"sp://messages/v1/container/control"},function(e,o){if(e)throw e;const n=o.body;n&&appUtil.isActiveAndFocused()&&("select_all"===n.type?controller.handleSelectAll():"copy"===n.type?controller.handleCopy():"copy_advanced"===n.type?controller.handleCopyAdvanced():"cut"===n.type&&controller.handleCut())})},exports.detach=function(){const e=$(document);e.off("mousedown",controller.handleMouseDown),e.off("touchstart",controller.handleMouseDown),e.off("mouseup",controller.handleMouseUp),e.off("touchend",controller.handleMouseUp),e.off("keydown",controller.handleKeyDown),e.off("focus",controller.handleFocus,!0),center.off("scroll-show-after",controller.handleScrollShowAfter),center.off("selection-set-hidden",controller.handleSetHidden),center.off("list-swap",controller.handleListSwap),controlMessageSubscription&&(controlMessageSubscription.cancel(),controlMessageSubscription=null)},exports.update=function(){containers.update(),controller.updateListListeners()},exports.add=function(e,o){controller.handleAddByUri(e,o)},exports.hasHoles=function(){return model.hasHoles()},exports.isNodeSelected=function(e){const o="innerHTML"in e?e:e[0];if(!o)return!1;const n=positions.getFromNode(o);return!!n&&model.isSelected(n)},exports.reset=function(){controller.resetListListeners(),model.reset(),rows.update(),containers.reset()},exports.clear=function(){model.clear(),rows.update()},exports.setOrigin=function(e,o){model.setOrigin(new Position(e,o))},exports.setFocus=function(e,o){model.setFocus(new Position(e,o))},exports.getOrigin=function(){const e=model.getOrigin();return e?{containerIndex:e.containerIndex,index:e.index}:null},exports.getFocus=function(){const e=model.getFocus();return e?{containerIndex:e.containerIndex,index:e.index}:null},exports.getIndicesPerList=function(){const e=model.selections,o=[];let n;const t=e=>n.keys[e];for(let r=0;r<e.length;r++){const s=e[r];if(s&&Object.keys(s).length){const e=containers.getUri(r);if(!e)continue;if(!(n=containers.getLiveList(r)))continue;const s=model.getIndicesForContainer(r);if(!s)continue;const i=s.map(t),l=model.getIndicesWithHiddenForContainer(r),c={containerIndex:r,uri:e,indices:s,keys:i,indicesWithHidden:l,keysWithHidden:l.map(t)},d=getOriginUri(e);if(d){const o=live(e).get("rows"),n=live(d).get("rows");let t,r;if(o&&n){let e;const i={};t=new Array(s.length),r=new Array(s.length);const l=n.keys;for(let e=0;e<l.length;e++)i[l[e]]=e;for(let l=0;l<s.length;l++)e=o.keys[s[l]],t[l]=i[e],r[l]=n.keys[t[l]]}c.origin={uri:d,indices:t||[],keys:r||[]}}o.push(c)}}return o},exports.getIndicesGlobal=function(){const e=model.selections,o=containers.elements,n=[],t=[];if(0===o.length)return null;const r=o[0].closest("[data-context]"),s=r&&r.getAttribute("data-uri");if(!s)return null;let i;const l=e=>!!i[e];for(let r=0;r<e.length;r++){i=e[r];const s=containers.getLiveList(r);if(s&&i){const e=s.keys.filter(l);for(let i=0,l=e.length;i<l;i++){const l=s.keys.indexOf(e[i]);n.push(positions.getGlobalIndexFromPosition(new Position(r,l))),t.push($(o[r]))}}}return{uri:s,indices:n,containers:t}},exports.getUris=function(){return controller.handleGetUris()},exports.getNodes=function(){return rows.getSelectedRows()};

},{"../../live":148,"../../live-wrapped-uri":147,"../../spotify-elements":195,"../center":206,"../util/Position":276,"../util/app":277,"../util/cosmos":278,"./containers":264,"./controller":265,"./model":267,"./positions":268,"./rows":269}],267:[function(require,module,exports){
"use strict";const live=require("../../live"),Range=require("../../range2"),containers=require("./containers"),positions=require("./positions"),Position=require("../util/Position"),selections=[];let hiddenKeysPerContainer={},originContainerIndex=null,originKey=null,focusContainerIndex=null,focusKey=null,focusIsTouch=!1;function getOrigin(){if(null===originContainerIndex)return null;if(null===originKey)return null;const e=containers.getLiveList(originContainerIndex);if(e){const n=e.keys.indexOf(originKey);return-1===n?null:new Position(originContainerIndex,n)}return null}function getFocus(){if(null===focusContainerIndex)return null;if(null===focusKey)return null;const e=containers.getLiveList(focusContainerIndex);if(e){const n=e.keys.indexOf(focusKey);return new Position(focusContainerIndex,n)}return null}function setOrigin(e){if(e){const n=containers.getLiveList(e.containerIndex);if(n)return originContainerIndex=e.containerIndex,void(originKey=n.keys[e.index]||null)}originContainerIndex=null,originKey=null}function setFocus(e,n){if(focusIsTouch=!(!n||!n.isTouch),e){const n=containers.getLiveList(e.containerIndex);if(n)return focusContainerIndex=e.containerIndex,void(focusKey=n.keys[e.index])}focusContainerIndex=null,focusKey=null}function wasFocusTriggeredByTouch(){return focusIsTouch}function setHiddenIndices(e,n){const t=live(n).get("rows");if(t){const i=t.keys,o={};for(let n=0,t=e.length;n<t;n++){const t=i[e[n]];t&&(o[t]=!0)}const s=containers.getContainerIndex(n);hiddenKeysPerContainer[s]=o,updateContainer(s)}}function isPositionHidden(e){const n=getIds(e,e)[0][0],t=hiddenKeysPerContainer[e.containerIndex];return t&&t[n]}function add(e,n){let t=n||e,i=e;if(-1===positions.getDirection(i,t)){const e=i;i=t,t=e}const o=getIds(i,t);for(let e=0,n=o.length;e<n;e++){const n=i.containerIndex+e,t=selections[n]||(selections[n]=Object.create(null)),s=o[e],r=hiddenKeysPerContainer[n];for(let e=0;e<s.length;e++){const n=s[e];r&&r[n]||(t[n]=!0)}}}function remove(e,n){let t=n||e,i=e;if(-1===positions.getDirection(i,t)){const e=i;i=t,t=e}const o=getIds(i,t);for(let e=0,n=o.length;e<n;e++){const n=i.containerIndex+e,t=selections[n]||(selections[n]=Object.create(null)),s=o[e];for(let e=0;e<s.length;e++){delete t[s[e]]}}}function clear(){selections.length=0,setOrigin(null),setFocus(null)}function reset(){clear(),hiddenKeysPerContainer={}}function updateContainer(e){const n=selections[e];if(!n)return;const t=containers.getLiveList(e);if(t)for(const i in n){let o=!t.hasKey(i);if(!o){const n=hiddenKeysPerContainer[e];o=!!n&&n[i]}o&&delete n[i]}}function getIds(e,n){const t=[],i=e.containerIndex,o=n.containerIndex;for(let s=i;s<=o;s++){const r=s===i?e.index:0;let c;if(s===o)c=n.index;else{const e=containers.getContainerLength(s);e>0&&(c=e-1)}if(void 0===c)t.push([]);else{const e=[];t.push(e);const n=containers.getUri(s),i=live(n).get("rows");if(i){const n=i.keys;for(let t=r;t<c+1;t++)e.push(n[t])}}}return t}function isSelected(e){const n=selections[e.containerIndex];if(!n)return!1;const t=containers.getLiveList(e.containerIndex);if(t){return!!n[t.keys[e.index]]}return!1}function hasHoles(){let e=0;for(let n=0;n<selections.length;n++){const t=selections[n],i=containers.getLiveList(n),o=Object.keys(t);if(o.length>0&&(e++,i)){const n=[];for(let e=0,t=o.length;e<t;e++)n.push(i.indexOf(o[e]));let t;n.sort(function(e,n){return e-n});for(let i=0,o=n.length;i<o;i++){const o=n[i];if(i>0&&o>t+1){e++;break}t=o}}if(e>1)return!0}return!1}function hasSelection(){for(let e=0,n=selections.length;e<n;e++)if(selections[e]&&Object.keys(selections[e]).length>0)return!0;return!1}function getIndicesForContainer(e){const n=selections[e];if(!n)return null;let t=[];const i=containers.getLiveList(e),o=i.keys.filter(function(e){return!!n[e]});return i&&o.length&&(t=o.length>1?i.indexOfMany(o):[i.indexOf(o[0])]),t.length?t:null}function getIndicesWithHiddenForContainer(e){let n=getIndicesForContainer(e);if(!n)return null;const t=hiddenKeysPerContainer[e];if(!t)return n;const i=Range.fromIndices(n);if(1===i.length)return n;const o=containers.getLiveList(e);if(!o)return n;const s=Object.keys(t);let r=[];s.length&&(r=s.length>1?o.indexOfMany(s):[o.indexOf(s[0])]),r=r.filter(function(e){return e>-1});const c=Range.fromIndices(r),l=c.map(function(e){return e.start}),u=c.map(function(e){return e.end});for(let e=0,t=i.length;e<t;e++){const t=i[e],o=i[e+1],s=l.indexOf(t.end);if(s>-1){const e=u[s];if(!o||e===o.start){const e=c[s].toIndices();e.length>0&&(n=n.concat(e))}}}return n.sort(function(e,n){return e-n}),n.length?n:null}exports.selections=selections,exports.getOrigin=getOrigin,exports.getFocus=getFocus,exports.setOrigin=setOrigin,exports.setFocus=setFocus,exports.wasFocusTriggeredByTouch=wasFocusTriggeredByTouch,exports.setHiddenIndices=setHiddenIndices,exports.isPositionHidden=isPositionHidden,exports.add=add,exports.remove=remove,exports.clear=clear,exports.reset=reset,exports.updateContainer=updateContainer,exports.isSelected=isSelected,exports.hasHoles=hasHoles,exports.hasSelection=hasSelection,exports.getIndicesForContainer=getIndicesForContainer,exports.getIndicesWithHiddenForContainer=getIndicesWithHiddenForContainer;

},{"../../live":148,"../../range2":189,"../util/Position":276,"./containers":264,"./positions":268}],268:[function(require,module,exports){
"use strict";const $=require("../../spotify-elements"),containers=require("./containers"),Position=require("../util/Position");function getClosest(t,e){const n="down"===e;let o=t.containerIndex;const i=t.index;let r=containers.getContainerLength(o),s=n?i+1:i-1;return s<r&&s>=0?new Position(o,s):(o=n?o+1:o-1,(r=containers.getContainerLength(o))?new Position(o,s=n?0:r-1):null)}function getFromNode(t){if(!t.parentNode)return null;if(!t.hasAttribute("data-index"))return null;const e=containers.elements;if(0===e.length)return null;for(let n=0,o=e.length;n<o;n++)if(e[n]&&containsNode(e[n],t)){const e=+t.getAttribute("data-index");return new Position(n,e)}return null}function containsNode(t,e){let n=e;for(;n&&n.parentNode!==t;)n=n.parentNode;return!!n}function getNodeFromPosition(t){const e=containers.elements[t.containerIndex];if(!e)return null;const n=$(e).find(`[data-index=${t.index}]`);return n?n[0]:null}function getDirection(t,e){return t&&e?t.containerIndex!==e.containerIndex?t.containerIndex<e.containerIndex?1:-1:t.index===e.index?0:t.index<e.index?1:-1:0}function getPositionFromGlobalIndex(t){let e,n=t,o=0,i=0;for(let r=0,s=containers.elements.length;r<s&&!((i+=e=containers.getContainerLength(r))>t);r++)o=r+1,n-=e;return new Position(o,n)}function getGlobalIndexFromPosition(t){let e=t.index;for(let n=t.containerIndex-1;n>=0;n--)e+=containers.getContainerLength(n);return e}function getLastPosition(){const t=containers.elements.length-1,e=containers.getContainerLength(t)-1;return new Position(t,e)}function getLastPositionForSelectAll(){let t;containers.elements.forEach(function(e,n){"false"!==e.getAttribute("data-list-may-select-all")&&(t=n)});const e=containers.getContainerLength(t)-1;return new Position(t,e)}exports.getClosest=getClosest,exports.getFromNode=getFromNode,exports.getNodeFromPosition=getNodeFromPosition,exports.getDirection=getDirection,exports.getPositionFromGlobalIndex=getPositionFromGlobalIndex,exports.getGlobalIndexFromPosition=getGlobalIndexFromPosition,exports.getLastPosition=getLastPosition,exports.getLastPositionForSelectAll=getLastPositionForSelectAll;

},{"../../spotify-elements":195,"../util/Position":276,"./containers":264}],269:[function(require,module,exports){
"use strict";const $=require("../../spotify-elements"),difference=require("mout/array/difference"),model=require("./model"),containers=require("./containers"),positions=require("./positions"),SELECTOR_ROW="[data-list-item]",CLASSNAME_SELECTED="selected",CLASSNAME_FOCUSED="selection-focus",CLASSNAME_FOCUSED_TOUCH="selection-focus-touch";let focusTimeout;function update(e){const t=getSelectedRows(e),o=getRowsToSelect(e),n=difference(t,o),s=difference(o,t);t.forEach(function(e){$(e).removeClass(CLASSNAME_FOCUSED),$(e).removeClass(CLASSNAME_FOCUSED_TOUCH)}),n.forEach(function(e){$(e).removeClass(CLASSNAME_SELECTED)}),s.forEach(function(e){$(e).addClass(CLASSNAME_SELECTED)});const c=model.getFocus();if(c){const e=positions.getNodeFromPosition(c);e&&(clearTimeout(focusTimeout),focusTimeout=setTimeout(function(){const t=document.activeElement&&$(document.activeElement).matches("input, textarea"),o=document.activeElement&&$(document.activeElement).matches("button");!isElementInViewport(e)||t||o||e.focus()},0),$(e).addClass(CLASSNAME_FOCUSED),model.wasFocusTriggeredByTouch()&&$(e).addClass(CLASSNAME_FOCUSED_TOUCH))}}function getSelectedRows(e){const t=[];return(e?[e]:containers.elements).forEach(function(e){const o=$(e).search(`${SELECTOR_ROW}.${CLASSNAME_SELECTED}`);o&&Array.prototype.push.apply(t,o)}),t}function getRowsToSelect(e){const t=[],o=containers.elements;return model.selections.forEach(function(n,s){if(!n)return;const c=containers.getLiveList(s);if(!c)return;let i=o[s];if(e&&!o[s].contains(e)&&(i=null),!i)return;const r=$(i).search(SELECTOR_ROW);if(!r)return;const u=r.filter(function(e){const t=+e.getAttribute("data-index"),o=c.keys[t];return!!n[o]});Array.prototype.push.apply(t,u)}),t}function isElementInViewport(e){const t=e.getBoundingClientRect();return t.top>=0&&t.bottom<=document.documentElement.clientHeight}exports.update=update,exports.getSelectedRows=getSelectedRows;

},{"../../spotify-elements":195,"./containers":264,"./model":267,"./positions":268,"mout/array/difference":387}],270:[function(require,module,exports){
"use strict";const $=require("../spotify-elements"),center=require("./center"),live=require("../live"),ATTR_SLIDER="slider",ATTR_PROPERTY="slider-property",SELECTOR_SLIDER=`[data-${ATTR_SLIDER}]`,CLASSNAME_ENABLED="enabled",CLASSNAME_DISABLED="disabled",ATTR_ALLOWED="slider-allowed-property",TA_ID_SLIDER_STATE="data-ta-slider-state",SPACE_KEY_CODE=32,storedNodes=[];function handleClick(e,t){const n=t.data(ATTR_PROPERTY);t.data(ATTR_ALLOWED)&&!live(t.data("uri")).get(t.data(ATTR_ALLOWED))||(n?toggleModelPropertyAndPublish(t[0],n):emitChangeEvent(t[0],!t.hasClass(CLASSNAME_ENABLED)))}function handleKeyUp(e,t){e.keyCode===SPACE_KEY_CODE&&handleClick(e,t)}function onSliderSet(e){if(!e.id)return;const t=$(`[data-${ATTR_SLIDER}=${e.id}]`);if(!t)return;const n=t[0],d=!!e.enabled,i=t.data(ATTR_PROPERTY);i?toggleModelPropertyAndPublish(n,i,d):setState(n,d)}function toggleModelPropertyAndPublish(e,t,n){const d=getUriFromNode(e);if(!d)return;const i=live(d),a=i.get(t);if(void 0===a)return;const r=void 0===n?!a:n,o={};o[t]=r,i.publish(o)}function updateNode(e){if(storedNodes.indexOf(e)>-1)return;storedNodes.push(e);const t=$(e),n=t.data(ATTR_PROPERTY),d=t.data(ATTR_ALLOWED);if(!n)return;const i=getUriFromNode(e);if(!i)return;const a=live(i);a.get(n,function(t,i){if(t)throw t;setState(e,!!i),emitChangeEvent(e,!!i),a.on("update",function(t){n in t&&(setState(e,!!t[n]),emitChangeEvent(e,!!t[n])),d&&d in t&&disableNode(e,!t[d])})})}function setState(e,t){const n=$(e);t?(n.addClass(CLASSNAME_ENABLED),n.setAttribute("aria-checked","true"),n.setAttribute(TA_ID_SLIDER_STATE,"enabled")):(n.removeClass(CLASSNAME_ENABLED),n.setAttribute("aria-checked","false"),n.setAttribute(TA_ID_SLIDER_STATE,"disabled"))}function disableNode(e,t){const n=$(e);t?n.addClass(CLASSNAME_DISABLED):n.removeClass(CLASSNAME_DISABLED)}function emitChangeEvent(e,t){const n=$(e).data(ATTR_SLIDER)||null;center.emit("slider-change",{element:e,id:n,enabled:t})}function getUriFromNode(e){const t=e.closest("[data-uri]");return t?t.getAttribute("data-uri"):null}let isAttached=!1;exports.update=function(e){if(!isAttached)return;const t=$(e||document).search(SELECTOR_SLIDER);t&&t.forEach(updateNode)},exports.attach=function(){if(isAttached)return;isAttached=!0;const e=$(document);e.delegate("click",SELECTOR_SLIDER,handleClick),e.delegate("keyup",SELECTOR_SLIDER,handleKeyUp),center.on("slider-set",onSliderSet)},exports.detach=function(){if(!isAttached)return;isAttached=!1;const e=$(document);e.undelegate("click",SELECTOR_SLIDER,handleClick),e.undelegate("keyup",SELECTOR_SLIDER,handleKeyUp),center.off("slider-set",onSliderSet)};

},{"../live":148,"../spotify-elements":195,"./center":206}],271:[function(require,module,exports){
"use strict";const live=require("../live"),center=require("./center"),sortUriUtils=require("../live-sort-uri"),UIInteraction5=require("../logger/messages/UIInteraction5"),$=require("../spotify-elements"),ASC="tl-sort-asc",DESC="tl-sort-desc",setClassNames=function(t,e,r){const i=t.data("uri"),s=void 0!==e?e:sortUriUtils.getQuery(i),a=void 0!==r?r:sortUriUtils.getDirection(i),o=t.search("[data-sort]");if(o)for(let t=0;t<o.length;t++){const e=$(o[t]);e.removeClass(`${ASC} ${DESC}`),e.data("sort")===s&&e.addClass("asc"===a?ASC:DESC)}},handleSort=function(t,e){const r=e.parent("[data-list]");if(!r)return;const i=r.data("uri");if(!i)return;const s=sortUriUtils.getQuery(i),a=sortUriUtils.getDirection(i);let o=e.data("sort");let n=s===o?"asc"===a?"desc":"asc":"asc";const c=s===o&&"desc"===a,l=sortUriUtils.getOriginUri(i)||i;let d;c?(d=l,o=null,n=null):d=sortUriUtils.create(l,n,o),live(d).get("rows",function(){}),setClassNames(r,o,n),center.emit("sort-header-click",{uri:l,requested:{query:o||null,direction:n||null},current:{query:s||null,direction:a||null}}),center.emit("list-swap",{before:i,after:d}),UIInteraction5.log({pageuri:live("spotify:application").get("appURI")||"unknown",feature_id:"zlink",section_id:"sort-header",target_uri:d,interaction_type:"hit",user_intent:"sort",timestamp:Math.round(Date.now()/1e3)})},handlePreviousProxyClick=function(t,e){handleSort(0,e.previousSibling())};let isAttached=!1;exports.update=function(t){if(!isAttached)return;const e=$(t)||$(document),r=e.matches("[data-list]")?[e]:e.search("[data-list]");if(r)for(let t=0;t<r.length;t++){const e=$(r[t]);e.search("[data-sort]")&&setClassNames(e)}},exports.attach=function(){isAttached||(isAttached=!0,$(document).delegate("click","[data-sort]",handleSort),$(document).delegate("click","[data-sort-previous]",handlePreviousProxyClick))},exports.detach=function(){isAttached&&(isAttached=!1,$(document).undelegate("click","[data-sort]",handleSort),$(document).undelegate("click","[data-sort-previous]",handlePreviousProxyClick))};

},{"../live":148,"../live-sort-uri":146,"../logger/messages/UIInteraction5":159,"../spotify-elements":195,"./center":206}],272:[function(require,module,exports){
(function (global){
"use strict";var _frameUpdater=require("../frame-updater");const center=require("./center"),sort=require("./sort"),DEFAULT_STICKY_CLASS_NAME="sticky-top";let timestamp,isAttached=!1,scrollListenerId=0,nodesGBCR=null,rootGBCR=null,lastTotalStickyHeight=0,isDragScrolling=!1,dragScrollingSpeed=0,scrollTopOffset=0,currentScrollX=0,currentScrollY=0,rects=null,scrollNode=null;const getStickyClassName=function(e){const t=document.documentElement;let o,n;for(n=e;n!==t;n=n.parentNode)if(o=n.getAttribute("data-class-sticky"))return o;return"sticky-top"},getRects=function(e){const t=timestamp+e,o=document.querySelectorAll("[data-sticky]");if(t>(timestamp=Date.now())&&nodesGBCR&&o.length===nodesGBCR.length){let e=!0;for(let t=0;t<o.length;t++)e=e&&o[t]===nodesGBCR[t].node;if(e)return{nodes:nodesGBCR,root:rootGBCR}}return rootGBCR=scrollNode===document?document.documentElement.getBoundingClientRect():{top:(rootGBCR=scrollNode.getBoundingClientRect()).top-currentScrollY,right:rootGBCR.right,bottom:rootGBCR.bottom,left:rootGBCR.left,width:rootGBCR.width,height:rootGBCR.height},{nodes:nodesGBCR=Array.prototype.map.call(document.querySelectorAll("[data-sticky]"),function(e){const t=e.parentNode.getBoundingClientRect(),o=e.getBoundingClientRect();return{stickyClassName:getStickyClassName(e),node:e,rect:{top:t.top,height:o.height,left:t.left,right:t.right}}}),root:rootGBCR}},removeClone=function(e){const t=e.stickyClone;t.parentNode&&t.parentNode.removeChild(t),e.stickyListSwapListener&&center.off("list-swap",e.stickyListSwapListener),e.style.removeProperty("visibility"),delete e.stickyClone,delete e.stickyListSwapListener},resetSticky=function(e){"thead"===e.nodeName.toLowerCase()&&e.stickyClone&&removeClone(e),e.classList.remove(getStickyClassName(e));const t=e.closest("[data-glue-page-header]");t&&(t.classList.remove("glue-page-header--with-active-sticky-header"),global.onPageHeaderToggleStickyMode&&global.onPageHeaderToggleStickyMode(!1)),e.removeAttribute("data-sticky-active",""),e.style.right="",e.style.left="",e.style.position="",e.style.top=""},resetOldStickies=function(){const e=document.querySelectorAll("[data-sticky-active]:not([data-sticky])");for(let t=0,o=e.length;t<o;t++)e[t].isStickyClone||resetSticky(e[t])},readValuesWithTTL=function(e){const t=(scrollNode===document?document.body:scrollNode).getAttribute("data-top-bar-height");scrollTopOffset=parseInt(t,10)||0,currentScrollY=scrollNode===document?window.scrollY:scrollNode.scrollTop,rects=getRects(e)},createClone=function(e){const t=document.createElement("div"),o=e.cloneNode(!0),n=e.parentNode.cloneNode(!1);n.appendChild(o).removeAttribute("data-sticky"),t.appendChild(n),t.className="sticky-clone",t.isStickyClone=!0;const r=function(t){const n=o.parentNode;n&&n.getAttribute("data-uri")&&(n.setAttribute("data-uri",t.after),sort.update(e.parentNode))};return center.on("list-swap",r),e.parentNode.parentNode.appendChild(t),e.style.visibility="hidden",e.stickyListSwapListener=r,e.stickyClone=t,t},updateStickies=function(){const e=currentScrollY+scrollTopOffset,t=rects.root.width;let o=rects.root.top,n=scrollTopOffset;const r=rects.nodes;resetOldStickies(),0===r.length&&global.onPageHeaderToggleStickyMode&&global.onPageHeaderToggleStickyMode(!1),r.forEach(function(l,s){const i=l.node,c=l.rect,a=i.stickyClone,d=l.stickyClassName;let g=a||i;if(c.top-o<e){const l=r[s-1];if(l){const t=l.node,r=l.rect;if(t.hasAttribute("data-sticky-single")&&t.classList.contains(d)){const l=Math.abs(c.top-rects.root.top-(e+n));if(l<r.height){const e=n-r.height-l;t.style.top=`${e}px`,o-=l,n-=l}else resetSticky(t),o-=r.height,n-=r.height}}const a=c.left-rects.root.left,u=c.right-rects.root.left;if(g.classList.contains(d))g.style.right=`${t-u}px`,g.style.left=`${a}px`,g.style.top=`${n}px`;else{"thead"!==i.nodeName.toLowerCase()||i.stickyClone||(g=createClone(i)),g.classList.add(d);const e=g.closest("[data-glue-page-header]");e&&(e.classList.add("glue-page-header--with-active-sticky-header"),global.onPageHeaderToggleStickyMode&&global.onPageHeaderToggleStickyMode(!0)),g.setAttribute("data-sticky-active",""),g.setAttribute("data-ta-id","sticky-node"),g.style.right=`${t-u}px`,g.style.left=`${a}px`,g.style.position="fixed",g.style.top=`${n}px`}n+=c.height,o+=c.height}else g.classList.contains(d)&&resetSticky(i)}),lastTotalStickyHeight=n},handleResize=function(){readValuesWithTTL(0),updateStickies()},dragScrollingTick=function(){isDragScrolling&&currentScrollY>0&&((0,_frameUpdater.requestFrame)(()=>{currentScrollX=window.scrollX,currentScrollY=window.scrollY},()=>{dragScrollingTick()}),window.scrollTo(currentScrollX,currentScrollY-dragScrollingSpeed))},onPointerDragMove=function(e){const t=e.clientY-lastTotalStickyHeight;if(t>0&&t<20){const e=(20-Math.max(0,t))/20;dragScrollingSpeed=20*e,isDragScrolling||(isDragScrolling=!0,dragScrollingTick())}else isDragScrolling=!1},onPointerDragEnd=function(){isDragScrolling=!1,document.removeEventListener("dragover",onPointerDragMove),document.removeEventListener("dragend",onPointerDragEnd),document.removeEventListener("mouseup",onPointerDragEnd)},handleMouseDown=function(){document.addEventListener("dragover",onPointerDragMove),document.addEventListener("dragend",onPointerDragEnd),document.addEventListener("mouseup",onPointerDragEnd)};exports.DEFAULT_STICKY_CLASS_NAME="sticky-top",exports.attach=function(){isAttached||(isAttached=!0,scrollNode||(scrollNode=document),scrollListenerId=(0,_frameUpdater.addDebouncedScrollListener)(scrollNode,()=>{readValuesWithTTL(4e3)},()=>{updateStickies()}),window.addEventListener("resize",handleResize),document.addEventListener("mousedown",handleMouseDown),global.top&&global.top.document&&global.top.document.addEventListener("mousedown",handleMouseDown))},exports.detach=function(){isAttached&&(isAttached=!1,(0,_frameUpdater.removeDebouncedScrollListener)(scrollListenerId),window.removeEventListener("resize",handleResize),document.removeEventListener("mousedown",handleMouseDown),global.top&&global.top.document&&global.top.document.removeEventListener("mousedown",handleMouseDown),nodesGBCR=null,rootGBCR=null,lastTotalStickyHeight=0,isDragScrolling=!1,dragScrollingSpeed=0,scrollNode=null)},exports.update=function(){isAttached&&(nodesGBCR=null,rootGBCR=null,readValuesWithTTL(4e3),updateStickies())},exports.setScrollNode=function(e){scrollNode=e},exports._getStickyClassName=getStickyClassName;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../frame-updater":61,"./center":206,"./sort":271}],273:[function(require,module,exports){
"use strict";const $=require("../spotify-elements"),live=require("../live"),dom=require("./util/dom"),SELECTOR_THUMBS_DOWN_BUTTON="[data-button=thumbs-down]",SELECTOR_THUMBS_UP_BUTTON="[data-button=thumbs-up]";function handleThumbsButtonClick(t,e){const u=dom.getAttributeFromNodeOrParent(e[0],"data-button"),n=dom.getAttributeFromNodeOrParent(e[0],"data-uri"),o=dom.getContextFromNodeOrParent(e[0]);n&&o&&("thumbs-down"===u?live(o).emit("thumb-down",n):"thumbs-up"===u&&live(o).emit("thumb-up",n))}let isAttached=!1;exports.attach=function(){if(isAttached)return;isAttached=!0;const t=$(document);t.delegate("click","[data-button=thumbs-down]",handleThumbsButtonClick),t.delegate("click","[data-button=thumbs-up]",handleThumbsButtonClick)},exports.detach=function(){if(!isAttached)return;isAttached=!1;const t=$(document);t.undelegate("click","[data-button=thumbs-down]",handleThumbsButtonClick),t.undelegate("click","[data-button=thumbs-up]",handleThumbsButtonClick)},exports.update=function(){};

},{"../live":148,"../spotify-elements":195,"./util/dom":279}],274:[function(require,module,exports){
"use strict";const $=require("../spotify-elements"),tooltipMargin=8,tooltipArrowSize=5,tooltipNode=document.createElement("div");tooltipNode.id="tooltip";const tooltipTextNode=document.createElement("span");tooltipTextNode.setAttribute("dir","auto");const tooltipArrowTop=document.createElement("div");tooltipArrowTop.className="tooltip-arrow-top";const tooltipArrowBottom=document.createElement("div");tooltipArrowBottom.className="tooltip-arrow-bottom",tooltipNode.appendChild(tooltipArrowTop),tooltipNode.appendChild(tooltipArrowBottom),tooltipNode.appendChild(tooltipTextNode);let attachedNode=null,tooltipContainer=null,tooltipArrow=null;const addTooltipToDOM=function(t){(tooltipContainer=t).appendChild(tooltipNode)},removeTooltipFromDOM=function(){attachedNode=null,tooltipNode.parentNode&&tooltipContainer.removeChild(tooltipNode),tooltipContainer=null},getTooltipContainer=function(t){const o=t.getAttribute("data-tooltip-container");let e;return o&&(e=document.querySelector(o)),e||document.body},setText=function(t){tooltipTextNode.innerHTML=t},showTooltip=function(t,o){const e=o[0];let i=0,l=0;const d=o.data("tooltip")||o.getAttribute("title");if(!d)return;attachedNode=o,o.tooltipCheck||(o.removeAttribute("title"),o.setAttribute("data-tooltip",d),o.tooltipCheck=!0);const p=getTooltipContainer(o);tooltipContainer&&p===tooltipContainer||addTooltipToDOM(p),setText(d);const n=tooltipNode.clientHeight,a=tooltipNode.offsetWidth,r=window.pageYOffset,s=e.getBoundingClientRect(),c=e.offsetHeight,u=e.offsetWidth,h=parseInt(s.top,10)+r,m=parseInt(s.left,10)+u/2,N=h+c,T=document.documentElement.clientWidth,w=document.documentElement.clientHeight;N+n+8-r>w?(i=h-n-8,tooltipArrowTop.classList.remove("visible"),tooltipArrowBottom.classList.add("visible"),tooltipArrow=tooltipArrowBottom):((i=h+c+8)-r>w&&(i=w-n),tooltipArrowTop.classList.add("visible"),tooltipArrowBottom.classList.remove("visible"),tooltipArrow=tooltipArrowTop),(l=m-a/2)+a>=T-8?l=T-8-a:l<8&&(l=8),tooltipNode.style.top=`${i}px`,tooltipNode.style.left=`${l}px`,tooltipArrow.style.left=`${m-l-5}px`,o.hasAttribute("data-tooltip-instant")?tooltipNode.classList.add("instant"):tooltipNode.classList.remove("instant"),tooltipNode.classList.add("visible")},hideTooltip=function(){attachedNode&&(attachedNode=null,setText(""),tooltipNode.classList.remove("visible"),tooltipNode.style.left=0,tooltipNode.style.top=0,tooltipArrow&&(tooltipArrow.style.left=0))};let isAttached=!1;exports.attach=function(){if(isAttached)return;isAttached=!0;const t=$(document);t.delegate("mouseover","[data-tooltip]",showTooltip),t.delegate("mouseout","[data-tooltip]",hideTooltip),t.on("keydown",hideTooltip),t.on("mousedown",hideTooltip)},exports.detach=function(){if(!isAttached)return;isAttached=!1,attachedNode=null,tooltipNode.parentNode&&tooltipContainer.removeChild(tooltipNode),tooltipContainer=null;const t=$(document);t.undelegate("mouseover","[data-tooltip]",showTooltip),t.undelegate("mouseout","[data-tooltip]",hideTooltip),t.off("keydown",hideTooltip),t.off("mousedown",hideTooltip)},exports.update=function(){isAttached&&attachedNode&&(attachedNode.data("tooltip")?showTooltip(0,attachedNode):hideTooltip())},exports._setText=setText,exports._getTooltipNode=(()=>tooltipNode);

},{"../spotify-elements":195}],275:[function(require,module,exports){
"use strict";const prime=require("../../../libs/prime"),Emitter=require("../../../libs/prime/emitter"),Range=require("../../range2"),SYNC=Emitter.EMIT_SYNC;module.exports=prime({mixin:Emitter,constructor:function(t,e){this.container=t,this.height=e.height||0,this.length=e.length||0,this.tag=e.tag||"li",this.request=e.request,this._id=0,this.reset()},resetFrom:function(t,e,i){const n=this._range;t<n.end&&(this.reset(e,i),this.show(n))},reset:function(t,e){const i=this.tag;void 0!==t&&(this.length=t);const n=this.length*this.height;if(e)throw new TypeError("Hidden indices are not supported anymore!");this.container.innerHTML=`<${i} style="height:${n}px"></${i}>`+`<${i} style="height:0px"></${i}>`,this._range=new Range(0,0),this._waitingRange=new Range(0,0),this.emit("index-change",[],SYNC)},show:function(t){const e=this.length,i=this._range,n=this._waitingRange,s=new Range(Math.max(0,t.start),Math.min(e,t.end));s.start===i.start&&s.end===i.end||s.start===n.start&&s.end===n.end||this._drawRange(s)},_drawRange:function(t){const e=this.container,i=this._range,n=this.height,s=this.length,h=++this._id;this._waitingRange=t,this.request(t,(r,a)=>{let g,o=0;if(h!==this._id)return;this._range=t,this._waitingRange=new Range(0,0);const c=e.firstChild,l=e.lastChild;c.style.height=`${t.start*n}px`,l.style.height=`${(s-t.end)*n}px`,i.subtract(t).forEach(function(t){const n=t.length;for(g=0;g<n;g++)e.removeChild(e.children[t.start-i.start-o+1]);o+=n}),t.subtract(i).forEach(n=>{const s=n.length,h=n.start-t.start,r=a.slice(h,h+s);let o;for(this.emit("before-show",n,r,SYNC),o=n.below(i)?c.nextSibling:l,g=0;g<s;g++)e.insertBefore(r[g],o);this.emit("after-show",n,r,SYNC)}),this.emit("index-change",[t],SYNC)})}});

},{"../../../libs/prime":187,"../../../libs/prime/emitter":186,"../../range2":189}],276:[function(require,module,exports){
"use strict";const Position=function(n,i){this.containerIndex=n,this.index=i};Position.prototype.isSame=function(n){return this.containerIndex===n.containerIndex&&this.index===n.index},module.exports=Position;

},{}],277:[function(require,module,exports){
"use strict";const live=require("../../live");function checkIfActive(){return live("spotify:application").get("active")||!1}function checkIfFocused(){const e=window.top.document.activeElement,c=e&&e.contentWindow;return c?c===window:window.top===window}exports.isActive=function(){return checkIfActive()},exports.isActiveAndFocused=function(){return checkIfActive()&&checkIfFocused()};

},{"../../live":148}],278:[function(require,module,exports){
"use strict";const live=require("../../live"),cosmos=require("../../cosmos-api").default,liburi=require("spotify-liburi"),ASAP=live.ASAP;function DELETE(e,t){return e.method=exports.cosmos.Action.DELETE,request(e,t)}function GET(e,t){return e.method=exports.cosmos.Action.GET,request(e,t)}function SUB(e,t){return e.method=exports.cosmos.Action.SUB,request(e,t)}function POST(e,t){return e.method=exports.cosmos.Action.POST,request(e,t)}function PUT(e,t){return e.method=exports.cosmos.Action.PUT,request(e,t)}function HEAD(e,t){return e.method=exports.cosmos.Action.HEAD,request(e,t)}function request(e,t){const o=e.method;let s,r;return delete e.method,sanitizeURL(e.url,function(n,u){if(n)return void t(n);if(r)return;const i=new exports.cosmos.Request(o||exports.cosmos.Action.GET,u,e.headers,e.body);s=exports.cosmos.resolver.resolve(i,function(e,o){if(t)if(e)t(e);else try{t(null,{body:JSON.parse(o.getBody()||"{}"),headers:o.getHeaders(),status:o.getStatusCode()})}catch(e){e.response=o,t(e)}})}),{cancel:function(){return s&&s.cancel?(s.cancel(),s=null):r||(r=!0),null}}}function sanitizeURL(e,t){e.indexOf("@")>-1?live("spotify:client").query("currentUser(username)",function(o,s){o?t(o):t(null,e.replace("@",liburi.getCanonicalUsername(s.currentUser.username)))},ASAP):t(null,e)}exports.request=request,exports.get=GET,exports.post=POST,exports.subscribe=SUB,exports.delete=DELETE,exports.put=PUT,exports.head=HEAD,exports.cosmos=cosmos,exports.sanitizeURL=sanitizeURL;

},{"../../cosmos-api":54,"../../live":148,"spotify-liburi":450}],279:[function(require,module,exports){
"use strict";function getContextFromNodeOrParent(t){const e=t.closest("[data-context]");return e&&e.getAttribute("data-uri")||""}function getAttributeFromNodeOrParent(t,e){const r=`[${e}]`,o=t.closest(r);return o&&o.getAttribute(e)||""}exports.getContextFromNodeOrParent=getContextFromNodeOrParent,exports.getAttributeFromNodeOrParent=getAttributeFromNodeOrParent;

},{}],280:[function(require,module,exports){
"use strict";module.exports=function(t){let e=t;const o=[];for(;e;)e.matches&&e.matches("[data-log-context]")&&o.unshift(e.getAttribute("data-log-context")),e=e.parentNode;return o.join("/")||null};

},{}],281:[function(require,module,exports){
"use strict";const rAF=window.requestAnimationFrame||function(t){setTimeout(t,16)};function throttle(t,n){let e,o=!1;return function(){e=arguments,o||(o=!0,rAF(function(){o=!1,t.apply(n,e)}))}}module.exports=throttle;

},{}],282:[function(require,module,exports){
"use strict";const operators={"==":function(n,r){return n==r},"===":function(n,r){return n===r},"!=":function(n,r){return n!=r},"<":function(n,r){return n<r},">":function(n,r){return n>r},"<=":function(n,r){return n<=r},">=":function(n,r){return n>=r},typeof:function(n,r){return typeof n==r}};function compare(n,r,t){const e=arguments[arguments.length-1],o=t!==e&&t?"==":e.hash.operator||"===";return operators[o](n,r)?e.fn(this):e.inverse(this)}compare.displayName="compare",module.exports=compare;

},{}],283:[function(require,module,exports){
"use strict";const duration=function(t){if(isNaN(t))return t;const o=Math.round(t/1e3);let r=Math.floor(o/3600),n=Math.floor(o%3600/60),a=Math.round(o%3600%60);return r?(r+=":",n<10&&(n=`0${n}`)):r="",a<10&&(a=`0${a}`),`${r+n}:${a}`};duration.displayName="duration",module.exports=duration;

},{}],284:[function(require,module,exports){
"use strict";const nameListTooltip=require("./name-list-tooltip"),facepile=function(e,t){if(!e)return"";const i=e.length,o=Math.min(3,i);let l="";for(let i=0;i<o;i++){const o=e[i];l+=t.fn(o)}return i>o&&(l+=t.inverse({badgeCount:i-o,badgeTooltip:nameListTooltip(e.slice(o),i-o)})),l};facepile.displayName="facepile",module.exports=facepile;

},{"./name-list-tooltip":291}],285:[function(require,module,exports){
(function (global){
"use strict";const getHTTPLink=require("../util/link"),isDesktop=!!global._getSpotifyModule,href=function(e){return isDesktop?e:getHTTPLink(e,"https://play.spotify.com")};href.displayName="href",module.exports=href;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../util/link":299}],286:[function(require,module,exports){
"use strict";const loc=require("./loc"),humanizeDuration=function(o){if(isNaN(o))return o;const t=Math.round(o/1e3),r=Math.floor(t/3600),n=Math.floor(t%3600/60),u=Math.round(t%3600%60);let e="";return r&&(e+=loc("HoursShort",r,{})),n&&(e+=" ",e+=loc("MinutesShort",n,{})),(!r&&!n||0===r&&n<10)&&(e+=" ",e+=loc("SecondsShort",u,{})),e.trim()};humanizeDuration.displayName="humanizeDuration",module.exports=humanizeDuration;

},{"./loc":290}],287:[function(require,module,exports){
"use strict";exports.compare=require("./compare"),exports.duration=require("./duration"),exports.facepile=require("./facepile"),exports.href=require("./href"),exports.humanizeDuration=require("./humanize-duration"),exports.list=require("./list"),exports.loc=require("./loc"),exports.nameListTooltip=require("./name-list-tooltip"),exports.nft=require("./nft"),exports.numeral=require("./numeral"),exports.share=require("./share"),exports.slice=require("./slice"),exports.type=require("./type"),exports.userReaction=require("./user-reaction"),exports.json=require("./json");

},{"./compare":282,"./duration":283,"./facepile":284,"./href":285,"./humanize-duration":286,"./json":288,"./list":289,"./loc":290,"./name-list-tooltip":291,"./nft":292,"./numeral":293,"./share":294,"./slice":295,"./type":296,"./user-reaction":297}],288:[function(require,module,exports){
"use strict";const json=function(s){return JSON.stringify(s)};json.displayName="json",module.exports=json;

},{}],289:[function(require,module,exports){
"use strict";const map=require("mout/array/map"),Handlebars=require("handlebars/dist/cjs/handlebars.runtime").default,lists={},list=function(e){if(!e)return"";const s=Array.prototype.slice.call(arguments),t=s.pop(),a=s[1];return"reset"===e?(delete lists[a],""):(a&&void 0===lists[a]&&(lists[a]=-1),map(e,function(e,s){const r=Handlebars.createFrame(t.data||{});return r.index=a?++lists[a]:s,r.number=r.index+1,r.localIndex=s,r.localNumber=s+1,t.fn(e,{data:r})}).join(t.hash&&t.hash.join||""))};list.displayName="list",module.exports=list;

},{"handlebars/dist/cjs/handlebars.runtime":362,"mout/array/map":394}],290:[function(require,module,exports){
"use strict";var _mixIn=require("mout/object/mixIn"),_mixIn2=_interopRequireDefault(_mixIn),_locales=require("../../locales"),_locales2=_interopRequireDefault(_locales);function _interopRequireDefault(e){return e&&e.__esModule?e:{default:e}}const slice_=Array.prototype.slice;let locale="en",numberFormat=new Intl.NumberFormat(locale),pluralRules=new Intl.PluralRules(locale);const storage={},loc=function(e){let l=slice_.call(arguments,1),t={};const o=l[l.length-1];"object"==typeof o&&"hash"in o&&(t=l.pop());const r=t.hash,a="object"==typeof storage[e]?storage[e][pluralRules.select(l[0])]||storage[e].other:storage[e];return a?(Array.isArray(l[0])&&(l=l[0]),a.replace(/\{([\w-]+)\}/g,function(e,t){const o=+t;let a;return"number"==typeof(a=isNaN(o)?r[t]:l[o])&&(a=numberFormat.format(a)),null!==a?a:""})):""};loc.displayName="loc",loc.register=function(e){return(0,_mixIn2.default)(storage,e),this},loc.setLocale=function(e){locale=e,numberFormat=new Intl.NumberFormat((0,_locales2.default)(locale,"intl")),pluralRules=new Intl.PluralRules((0,_locales2.default)(locale,"intl"))},module.exports=loc;

},{"../../locales":153,"mout/object/mixIn":423}],291:[function(require,module,exports){
"use strict";const loc=require("./loc"),nameListTooltip=function(o,t){if(0===t)return;const n=o.length,e=o.map(function(o){return o.name});if(t-n>0){const o=loc("AndMore",t-n);e.push(o)}return e.join("<br>\n").replace(/'/g,"&#39;")};nameListTooltip.displayName="nameListTooltip",module.exports=nameListTooltip;

},{"./loc":290}],292:[function(require,module,exports){
"use strict";function nft(){const t=arguments[arguments.length-1];return!!top.initialState&&top.initialState.useNftUi?t.fn(this):t.inverse(this)}nft.displayName="nft",module.exports=nft;

},{}],293:[function(require,module,exports){
"use strict";const isNumber=require("mout/lang/isNumber"),numeralHelper=function(e,r){const u=r&&r.hash&&r.hash.format,l=numeralHelper._numeral;return isNumber(e)?l(e).format(u):e};numeralHelper.displayName="numeral",module.exports=numeralHelper,module.exports.setLocale=function(e){numeralHelper._numeral=require("../../spotify-numeral")(e)};

},{"../../spotify-numeral":303,"mout/lang/isNumber":409}],294:[function(require,module,exports){
"use strict";const getHTTPLink=require("../util/link"),share=function(e){return getHTTPLink(e,"https://open.spotify.com")};share.displayName="share",module.exports=share;

},{"../util/link":299}],295:[function(require,module,exports){
"use strict";const kindOf=require("mout/lang/kindOf"),map=require("mout/array/map"),forEach=require("mout/array/forEach"),Handlebars=require("handlebars/dist/cjs/handlebars.runtime").default,slice_=Array.prototype.slice,slice=function(e){let a,r,l,n,i=e;return i?(forEach(slice_.call(arguments,1),function(e){switch(kindOf(e)){case"String":a=e;break;case"Number":null===r?r=e:null===l&&(l=e);break;case"Object":n=e}}),null!==r&&(i=i.slice(r,null!==l?l:i.length)),map(i,function(e,a){const r=Handlebars.createFrame(n.data||{});return r.index=a,n.fn(e,{data:r})}).join(a||"")):""};slice.displayName="slice",module.exports=slice;

},{"handlebars/dist/cjs/handlebars.runtime":362,"mout/array/forEach":391,"mout/array/map":394,"mout/lang/kindOf":413}],296:[function(require,module,exports){
"use strict";const getType=require("../util/type"),type=function(e){if(arguments.length<=2)return getType(e);const t=arguments[arguments.length-1];let n=!1;const r=getType(e);for(let e=1;e<arguments.length-1;e++)if(r===arguments[e]){n=!0;break}return n?t.fn(this):t.inverse(this)};type.displayName="type",module.exports=type;

},{"../util/type":300}],297:[function(require,module,exports){
"use strict";const loc=require("./loc"),userReaction=function(e,t,n){if(!t)return"";const r=`${n}Reaction${t>1?"Multi":"Single"}`;if(t>1)return loc(r,t);if(!e.length)return"";const o=e[0].name;return loc(r,o)};userReaction.displayName="userReaction",module.exports=userReaction;

},{"./loc":290}],298:[function(require,module,exports){
"use strict";const kindOf=require("mout/lang/kindOf"),Handlebars=require("handlebars/dist/cjs/handlebars.runtime").default;exports.runtime=Handlebars,exports.register=function(e){let r={};"Function"===kindOf(e)?r[e.displayName]=e:r=e;for(const e in r)r.hasOwnProperty(e)&&Handlebars.registerHelper(e,r[e]);return this};

},{"handlebars/dist/cjs/handlebars.runtime":362,"mout/lang/kindOf":413}],299:[function(require,module,exports){
"use strict";module.exports=function(t,s){const e=(t||"").match(/^spotify:(.+)$/);if(!e)return t||"";let i=e.pop().replace(/:$/,"").split(/:/);const n=i.shift();return"search"===n&&(i=[i.join(":")]),i.unshift(s,n),i.join("/")};

},{}],300:[function(require,module,exports){
"use strict";module.exports=function(e){if(!e||!e.split)return null;const t=e.split(":");switch(t[1]){case"album":if(4===t.length)return"disc";if(3===t.length)return"album";break;case"artist":if(3===t.length)return"artist";break;case"dailymix":return"dailymix";case"track":if(3===t.length)return"track";break;case"playlist":if(3===t.length)return"playlist";break;case"genre":if(3===t.length)return"genre";break;case"show":if(3===t.length)return"show";break;case"station":if(t.length>3)return"station";break;case"episode":if(3===t.length)return"episode";break;case"local":if(6===t.length)return"track";if(4===t.length)return"album";if(3===t.length)return"artist";break;case"user":if(t.length>3&&"collection"===t[3]&&"album"===t[4])return"collection-album";if(t.length>3&&"collection"===t[3]&&"artist"===t[4])return"collection-artist";if(t.length>3&&"collection"===t[3])return"collection";if(5===t.length&&"folder"===t[3])return"playlist-folder";if(5===t.length&&"cluster"===t[3])return"cluster";if(t.length>3&&t.length<=5&&"facebook"!==t[2])return"playlist";if(3===t.length)return"user";break;case"internal":return t[2];case"app":return t.slice(1).join("-")}return null};

},{}],301:[function(require,module,exports){
"use strict";var _strings=require("../glue/strings"),_strings2=_interopRequireDefault(_strings),_interpolateString=require("./src/interpolate-string"),_interpolateString2=_interopRequireDefault(_interpolateString),_locales=require("../locales"),_locales2=_interopRequireDefault(_locales),_escapeHtml=require("escape-html"),_escapeHtml2=_interopRequireDefault(_escapeHtml);function _interopRequireDefault(e){return e&&e.__esModule?e:{default:e}}module.exports=function(e){if(!e||"object"!=typeof e)throw new Error("`appStringsByLocale` must be a plain object. See spotify-i18n/README.md");function t(){const t="undefined"!=typeof window&&window&&window.__spotify&&window.__spotify.locale;return t in e?t:"en"}const n={};function r(e,r,...i){const l=t(),o=e[l][r],u="object"!=typeof o?o:o[function(e,t){return(n[e]||(n[e]=new Intl.PluralRules((0,_locales2.default)(e,"intl")))).select(t)}(l,i[0])]||o.other;return void 0===u?(0,_escapeHtml2.default)(r):(0,_interpolateString2.default)(u,i,l)}return{locale:t,get:r.bind(null,e),getGlueString:r.bind(null,_strings2.default),glueStrings:function(){return _strings2.default[t()]},appStrings:function(){return e[t()]}}};

},{"../glue/strings":89,"../locales":153,"./src/interpolate-string":302,"escape-html":361}],302:[function(require,module,exports){
"use strict";function interpolateString(e,t=[],r){const n=new Intl.NumberFormat(r||"en");return e.replace(/\{(\d+?)\}/g,function(e,r){const o=t[r];return void 0===o?e:"number"==typeof o?n.format(o):o})}Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=interpolateString;

},{}],303:[function(require,module,exports){
"use strict";var _locales=require("../locales"),_locales2=_interopRequireDefault(_locales);function _interopRequireDefault(e){return e&&e.__esModule?e:{default:e}}function getOrdinalFunction(e){switch(e){case"ar":case"cs":case"de":case"el":case"fi":case"hu":case"ja":case"pl":case"sv":case"ms":return e=>`${e}.`;case"it":case"pt-BR":return e=>`${e}º`;case"fr":case"fr-CA":return e=>`${e}${1===e?"er":"e"}`;case"es":case"es-419":return(e,r=e%10)=>`${e}${1===r||3===r?"er":2===r?"do":7===r||0===r?"mo":8===r?"vo":9===r?"no":"to"}`;case"id":return e=>`${e}`;case"nl":return(e,r=e%100)=>`${e}${0!==e&&r<=1||8===r||r>=20?"ste":"de"}`;case"tr":return e=>{if(0===e)return`${e}'ıncı`;const r={1:"'inci",5:"'inci",8:"'inci",70:"'inci",80:"'inci",2:"'nci",7:"'nci",20:"'nci",50:"'nci",3:"'üncü",4:"'üncü",100:"'üncü",6:"'ncı",9:"'uncu",10:"'uncu",30:"'uncu",60:"'ıncı",90:"'ıncı"},n=e%10;return`${e}${r[n]||r[e%100-n]||r[e>=100?100:null]}`};case"zh-Hant":return e=>`第${e}`;case"en":return(e,r=e%10)=>`${e}${1==~~(e%100/10)?"th":1===r?"st":2===r?"nd":3===r?"rd":"th"}`;case"th":return e=>`${e}`;case"vi":return e=>1===e?"thứ nhất":`thứ ${e}`;default:return console.warn(`No explicit ordinal formatter specified for "${e}" locale – please add to spotify-numeral`),e=>`${e}.`}}module.exports=function(e){const r=getOrdinalFunction(e),n=new Intl.NumberFormat((0,_locales2.default)(e,"intl"));return e=>({format:t=>((e,t="0,0")=>{if("0,0"===t)return n.format(e);if("0o"===t)return r(e);throw new Error(`Unsupported format ${t}`)})(e,t)})};

},{"../locales":153}],304:[function(require,module,exports){
"use strict";const colorLookup={Aubergine:{r:80,g:55,b:80,lightType:!0},Maroon:{r:140,g:25,b:50,lightType:!0},Chocolate:{r:125,g:75,b:50,lightType:!0},Violet:{r:175,g:40,b:150,lightType:!0},"Bright Red":{r:235,g:30,b:49,lightType:!0},Fuchsia:{r:240,g:55,b:165,lightType:!0},Tangerine:{r:255,g:70,b:50,lightType:!0},Salmon:{r:245,g:115,b:160,lightType:!0},Lavender:{r:180,g:155,b:200,lightType:!0},Orange:{r:255,g:100,b:55,lightType:!0},Bole:{r:200,g:125,b:85,lightType:!0},Pink:{r:245,g:197,b:203,lightType:!0},Tan:{r:195,g:150,b:135,lightType:!0},Gold:{r:245,g:155,b:35,lightType:!0},"Factory Yellow":{r:245,g:215,b:45,lightType:!0},Sunflower:{r:245,g:192,b:96,lightType:!0},Forest:{r:0,g:100,b:80,lightType:!0},Midnight:{r:30,g:50,b:100,lightType:!0},Spearmint:{r:75,g:145,b:125,lightType:!0},"Royal Blue":{r:45,g:70,b:185,lightType:!0},"Neon Green":{r:87,g:224,b:72,lightType:!0},"Klein Blue":{r:65,g:0,b:245,lightType:!0},"Electric Seafoam":{r:25,g:230,b:140,lightType:!0},Azure:{r:80,g:155,b:245,lightType:!0},Citric:{r:195,g:232,b:95,lightType:!0},Aquamarine:{r:143,g:224,b:210,lightType:!0},"Powder Green":{r:187,g:230,b:192,lightType:!0},Storm:{r:160,g:195,b:210,lightType:!0},White:{r:255,g:255,b:255,lightType:!1},Black:{r:0,g:0,b:0,lightType:!0}};module.exports=colorLookup;

},{}],305:[function(require,module,exports){
"use strict";const colorPairs={Aubergine:["Salmon","Gold","Powder Green","Aquamarine"],Maroon:["Aquamarine","Tan"],Chocolate:["Aquamarine","Orange"],Violet:["Azure"],"Bright Red":["Pink","Bole","Klein Blue"],Fuchsia:[],Tangerine:["Pink","Citric"],Salmon:["Aubergine","Electric Seafoam","Powder Green"],Lavender:[],Orange:["Midnight","Forest","Factory Yellow","Chocolate"],Bole:["Midnight","Bright Red","Black"],Pink:["Spearmint","Bright Red","Tangerine","Storm"],Tan:["Maroon"],Gold:["Aubergine","Sunflower"],"Factory Yellow":["Fuchsia","Orange"],Sunflower:["Klein Blue","Gold","Spearmint","Storm"],Forest:["Orange","Neon Green"],Midnight:["Orange","Bole","Citric","Azure"],Spearmint:["Pink","Storm","Sunflower"],"Royal Blue":["Electric Seafoam"],"Neon Green":["Black","Forest"],"Klein Blue":["Powder Green","Sunflower","Bright Red"],"Electric Seafoam":["Salmon","Citric","Royal Blue"],Azure:["Violet","Midnight"],Citric:["Midnight","Electric Seafoam","Tangerine"],Aquamarine:["Chocolate","Maroon","Aubergine"],"Powder Green":["Klein Blue","Aubergine","Salmon"],Storm:["Spearmint","Pink","Sunflower"],Black:["Neon Green","Bole","Fuchsia"]};module.exports=colorPairs;

},{}],306:[function(require,module,exports){
"use strict";const colors=require("./colors"),colorLookup=require("./color_lookup"),colorPairs=require("./color_pairs_no_white"),colorTriplets=require("./color_triplets_no_white");function ColorPalette(){this.colors=colors,this.colorLookup=colorLookup,this.colorPairs=colorPairs,this.colorTriplets=colorTriplets,this.excludeColors={"":!0,White:!0}}ColorPalette.prototype.randomColor=function(){let o="";for(;this.excludeColors[o];)o=this.colors[Math.floor(Math.random()*this.colors.length)];return o},ColorPalette.prototype.randomPair=function(o){const r=this.colorPairs[o];return r.length?r[Math.floor(Math.random()*r.length)]:null},ColorPalette.prototype.randomTriplet=function(o){const r=this.colorTriplets[o];return r.length?r[Math.floor(Math.random()*r.length)]:null},module.exports=ColorPalette;

},{"./color_lookup":304,"./color_pairs_no_white":305,"./color_triplets_no_white":307,"./colors":308}],307:[function(require,module,exports){
"use strict";const colorTriplets={Aubergine:[["Gold","Violet"],["Powder Green","Lavender"],["Tan","Aquamarine"],["Salmon","Aquamarine"],["Bole","Bright Red"],["Powder Green","Black"]],Maroon:[["Black","Sunflower"]],Chocolate:[["Powder Green","Orange"],["Pink","Midnight"]],Violet:[["Gold","Aubergine"],["Azure","Fuchsia"]],"Bright Red":[["Bole","Pink"],["Pink","Klein Blue"],["Aubergine","Bole"]],Fuchsia:[["Black","Factory Yellow"],["Azure","Violet"],["Black","Royal Blue"],["Midnight","Pink"]],Tangerine:[["Lavender","Pink"],["Storm","Sunflower"],["Royal Blue","Citric"],["Tan","Sunflower"]],Salmon:[["Forest","Pink"],["Forest","Electric Seafoam"],["Aquamarine","Aubergine"]],Lavender:[["Powder Green","Aubergine"],["Tangerine","Pink"]],Orange:[["Aquamarine","Midnight"],["Forest","Spearmint"],["Azure","Midnight"],["Powder Green","Chocolate"]],Bole:[["Pink","Bright Red"],["Midnight","Aquamarine"],["Aubergine","Bright Red"]],Pink:[["Bole","Bright Red"],["Salmon","Forest"],["Storm","Spearmint"],["Lavender","Tangerine"],["Midnight","Fuchsia"],["Midnight","Chocolate"],["Bright Red","Klein Blue"],["Factory Yellow","Midnight"]],Tan:[["Sunflower","Tangerine"],["Aubergine","Aquamarine"]],Gold:[["Violet","Aubergine"],["Factory Yellow","Midnight"]],"Factory Yellow":[["Black","Fuchsia"],["Gold","Midnight"],["Pink","Midnight"]],Sunflower:[["Tangerine","Storm"],["Powder Green","Spearmint"],["Midnight","Storm"],["Tan","Tangerine"],["Black","Maroon"]],Forest:[["Salmon","Pink"],["Electric Seafoam","Salmon"],["Orange","Spearmint"],["Spearmint","Powder Green"],["Midnight","Citric"]],Midnight:[["Neon Green","Black"],["Aquamarine","Orange"],["Aquamarine","Bole"],["Orange","Azure"],["Storm","Sunflower"],["Pink","Fuchsia"],["Factory Yellow","Gold"],["Pink","Chocolate"],["Aquamarine","Royal Blue"],["Factory Yellow","Pink"],["Forest","Citric"],["Azure","Royal Blue"]],Spearmint:[["Orange","Forest"],["Pink","Storm"],["Powder Green","Sunflower"],["Forest","Powder Green"]],"Royal Blue":[["Tangerine","Citric"],["Aquamarine","Midnight"],["Azure","Midnight"]],"Neon Green":[["Midnight","Black"]],"Klein Blue":[["Azure","Powder Green"],["Pink","Bright Red"]],"Electric Seafoam":[["Forest","Salmon"]],Azure:[["Klein Blue","Powder Green"],["Fuchsia","Violet"],["Orange","Midnight"],["Midnight","Royal Blue"]],Citric:[["Royal Blue","Tangerine"],["Forest","Midnight"]],Aquamarine:[["Midnight","Orange"],["Midnight","Bole"],["Storm","Black"],["Aubergine","Tan"],["Royal Blue","Midnight"],["Salmon","Aubergine"]],"Powder Green":[["Azure","Klein Blue"],["Lavender","Aubergine"],["Spearmint","Sunflower"],["Orange","Chocolate"],["Forest","Spearmint"],["Aubergine","Black"]],Storm:[["Pink","Spearmint"],["Aquamarine","Black"],["Tangerine","Sunflower"],["Midnight","Sunflower"]],Black:[["Midnight","Neon Green"],["Factory Yellow","Fuchsia"],["Aquamarine","Storm"],["Royal Blue","Fuchsia"],["Maroon","Sunflower"],["Aubergine","Powder Green"]]};module.exports=colorTriplets;

},{}],308:[function(require,module,exports){
"use strict";const colors=["Forest","Spearmint","Powder Green","Electric Seafoam","Neon Green","Citric","Factory Yellow","Sunflower","Gold","Bole","Chocolate","Tan","Orange","Tangerine","Bright Red","Maroon","Pink","Salmon","Fuchsia","Violet","Lavender","Aubergine","Midnight","Royal Blue","Klein Blue","Azure","Storm","Aquamarine","White","Black"];module.exports=colors;

},{}],309:[function(require,module,exports){
"use strict";const Utils={getTrackIdFromUri:function(t){const c=/^spotify:track:(.*)/;let r=null;return!!(t.match(c)&&t.match(c).length>1)&&(r=t.match(c)[1])}};module.exports=Utils;

},{}],310:[function(require,module,exports){
"use strict";const Enum=require("../enum/enum"),EVENT_DATA_MAP={};function Analyzer(){this.currentTime=0,this._currentIndices={},this._currentNodes={},this._handlers={}}EVENT_DATA_MAP[Enum.SECTION]="sections",EVENT_DATA_MAP[Enum.SEGMENT]="segments",EVENT_DATA_MAP[Enum.TATUM]="tatums",EVENT_DATA_MAP[Enum.BEAT]="beats",EVENT_DATA_MAP[Enum.BAR]="bars",Analyzer.prototype.on=function(t,e){const n=EVENT_DATA_MAP[t];n&&(this._handlers[n]=this._handlers[n]||[],this._handlers[n].push(e))},Analyzer.prototype.off=function(t,e){const n=EVENT_DATA_MAP[t];if(this._handlers[n]){const t=this._handlers[n].indexOf(e);-1!==t&&this._handlers[n].splice(t,1)}},Analyzer.prototype.setData=function(t){this.data=t},Analyzer.prototype.setTimeSeconds=function(t){if(this.currentTime=t,this.data){let e,n,s,r;for(const i in this._handlers)if(this._handlers[i]){if((e=this._currentNodes[i])&&e.start<=t&&e.start+e.duration>=t)continue;if(n=this.data[i],e&&e.start>t){for(s=n.length-1;s>=0;s--)if(this._confirmEvent(i,n[s],s)){this._dispatch(i,n[s]);break}}else for(s=this._currentIndices[i]||0,r=n.length;s<r;s++)if(this._confirmEvent(i,n[s],s)){this._dispatch(i,n[s]);break}}}},Analyzer.prototype.setTimeMS=function(t){this.setTimeSeconds(t/1e3)},Analyzer.prototype._confirmEvent=function(t,e,n){return e!==this._currentNodes[t]&&(!(e.start>this.currentTime)&&(!(e.start+e.duration<this.currentTime)&&(this._currentIndices[t]=n,this._currentNodes[t]=e,!0)))},Analyzer.prototype._dispatch=function(t,e){const n=this._handlers[t];if(n&&n.length)for(let t=0,s=n.length;t<s;t++)n[t](e)},module.exports=Analyzer;

},{"../enum/enum":311}],311:[function(require,module,exports){
"use strict";const Enum={NORTH:"north",SOUTH:"south",EAST:"east",WEST:"west",NORTH_EAST:"north-east",NORTH_WEST:"north-west",SOUTH_EAST:"south-east",SOUTH_WEST:"south-west",DIAGONAL:"diagonal",VERTICAL:"vertical",HORIZONTAL:"horizontal",SECTION:"section",SEGMENT:"segment",TATUM:"tatum",BEAT:"beat",BAR:"bar"};module.exports=Enum;

},{}],312:[function(require,module,exports){
"use strict";const REGEX_HEX=/^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i;function Color(){this.set.apply(this,arguments)}Color.prototype.set=function(){REGEX_HEX.test(arguments[0])?this.hex=arguments[0]:(this.r=arguments[0]||0,this.g=arguments[1]||0,this.b=arguments[2]||0)},Color.prototype.isEqual=function(t){return this.r===t.r&&this.g===t.g&&this.b===t.b},Color.prototype.clone=function(){return new Color(this.r,this.g,this.b)},Object.defineProperty(Color.prototype,"hex",{get:function(){return`#${this._componentToHex(this.r)}${this._componentToHex(this.g)}${this._componentToHex(this.b)}`},set:function(t){const o=REGEX_HEX.exec(t);o&&(this.r=parseInt(o[1],16),this.g=parseInt(o[2],16),this.b=parseInt(o[3],16))}}),Color.prototype._componentToHex=function(t){const o=t.toString(16);return 1===o.length?`0${o}`:o},module.exports=Color;

},{}],313:[function(require,module,exports){
"use strict";function Grid(t,i,h,l){this.rows=t,this.cols=i,this.cells=[],this.numCells=t*i,this._build(),this.setSize(h||1,l||1)}Grid.prototype.setSize=function(t,i){this.width=t,this.height=i,this.cellWidth=t/this.cols,this.cellHeight=i/this.rows,this.cellDiagonal=Math.sqrt(Math.pow(this.cellWidth,2),Math.pow(this.cellHeight,2));const h=this.cellWidth/2,l=this.cellHeight/2;for(let t,i=0,s=this.cells.length;i<s;i++)(t=this.cells[i]).width=this.cellWidth,t.height=this.cellHeight,t.x=t.col*this.cellWidth,t.y=t.row*this.cellHeight,t.cx=t.x+h,t.cy=t.y+l},Grid.prototype._build=function(){this.cells.length=0;for(let t=0;t<this.numCells;t++)this.cells.push({row:Math.floor(t/this.cols),col:Math.floor(t%this.cols)})},module.exports=Grid;

},{}],314:[function(require,module,exports){
"use strict";const DATA_TYPE="undefined"!=typeof Float32Array?Float32Array:Array,Matrix={create:function(){return Matrix.identity(new DATA_TYPE(9))},identity:function(t){return t[0]=1,t[1]=0,t[2]=0,t[3]=0,t[4]=1,t[5]=0,t[6]=0,t[7]=0,t[8]=1,t},set:function(t,n,r,e,i,o,u,c,a,s){return t[0]=n,t[1]=r,t[2]=e,t[3]=i,t[4]=o,t[5]=u,t[6]=c,t[7]=a,t[8]=s,t},copy:function(t,n){return t[0]=n[0],t[1]=n[1],t[2]=n[2],t[3]=n[3],t[4]=n[4],t[5]=n[5],t[6]=n[6],t[7]=n[7],t[8]=n[8],t},multiply:function(t,n,r){const e=n[0],i=n[1],o=n[2],u=n[3],c=n[4],a=n[5],s=n[6],f=n[7],y=n[8],l=r[0],A=r[1],d=r[2],M=r[3],T=r[4],p=r[5],x=r[6],h=r[7],m=r[8];return t[0]=l*e+A*u+d*s,t[1]=l*i+A*c+d*f,t[2]=l*o+A*a+d*y,t[3]=M*e+T*u+p*s,t[4]=M*i+T*c+p*f,t[5]=M*o+T*a+p*y,t[6]=x*e+h*u+m*s,t[7]=x*i+h*c+m*f,t[8]=x*o+h*a+m*y,t},setScale:function(t,n,r){t[0]=n,t[4]=r},setRotation:function(t,n){const r=Math.cos(n),e=Math.sin(n);t[0]=r,t[1]=e,t[3]=-e,t[4]=r},setTranslation:function(t,n,r){t[2]=n,t[5]=r}};module.exports=Matrix;

},{}],315:[function(require,module,exports){
"use strict";const NumberUtils=require("../util/number"),Tween=require("../tween/tween"),Color=require("./color"),TINT_AMOUNT=.15,BLEND_AMOUNT=.5,OVERLAY_OPACITY=.15,Palette={};function blendOverlay(e,t){const l=e/255,r=t/255;return 255*(l<.5?2*l*r:1-2*(1-l)*(1-r))}Palette.tint=new Color("#000000"),Palette.primary=new Color("#000000"),Palette.secondary=new Color("#FFFFFF"),Palette.overlay=new Color("#000000"),Palette.blended=new Color("#000000"),Palette.black=new Color("#000000"),Palette.white=new Color("#FFFFFF"),Palette.transition=function(e,t,l){const r=t||.8,n=l||Tween.Easing.Sine.inOut,a=Palette.luminance(e.primary)>50?Palette.black:Palette.white,i=Palette.blendOverlay(a,e.primary,.15),o=Palette.blendOverlay(e.primary,e.pairs[0],.5);Tween.destroyAll(Palette.primary),Tween.destroyAll(Palette.secondary),Tween.destroyAll(Palette.overlay),Tween.destroyAll(Palette.blended),Tween.to(Palette.primary,{r:NumberUtils.lerp(e.primary.r,Palette.tint.r,.15),g:NumberUtils.lerp(e.primary.g,Palette.tint.g,.15),b:NumberUtils.lerp(e.primary.b,Palette.tint.b,.15)},r,0,n),Tween.to(Palette.secondary,{r:NumberUtils.lerp(e.pairs[0].r,Palette.tint.r,.15),g:NumberUtils.lerp(e.pairs[0].g,Palette.tint.g,.15),b:NumberUtils.lerp(e.pairs[0].b,Palette.tint.b,.15)},r,.2,n),Tween.to(Palette.overlay,{r:NumberUtils.lerp(i.r,Palette.tint.r,.15),g:NumberUtils.lerp(i.g,Palette.tint.g,.15),b:NumberUtils.lerp(i.b,Palette.tint.b,.15)},r,0,n),Tween.to(Palette.blended,{r:NumberUtils.lerp(o.r,Palette.tint.r,.15),g:NumberUtils.lerp(o.g,Palette.tint.g,.15),b:NumberUtils.lerp(o.b,Palette.tint.b,.15)},r,0,n)},Palette.luminance=function(e){return.299*e.r+.587*e.g+.114*e.b},Palette.blendOverlay=function(e,t,l){const r=blendOverlay(e.r,t.r)*l+t.r*(1-l),n=blendOverlay(e.g,t.g)*l+t.g*(1-l),a=blendOverlay(e.b,t.b)*l+t.b*(1-l);return new Color(r,n,a)},module.exports=Palette;

},{"../tween/tween":326,"../util/number":328,"./color":312}],316:[function(require,module,exports){
"use strict";const TAU=2*Math.PI,PHI=TAU/3,UP=-.5*Math.PI,Polygon={create:function(e,n,o){let a=n,r=o;(void 0===a||isNaN(a))&&(a=UP),(void 0===r||isNaN(r))&&(r=a+TAU);const l=(r-a)/e,i=[0,0],t=[];for(let n,o=0;o<=e;o++)n=a+l*o,i.push(.5*Math.cos(n),.5*Math.sin(n)),o>0&&t.push(0,o,o+1);return{vertices:new Float32Array(i),indices:new Uint16Array(t)}},EquilateralTriangle:{}};Polygon.EquilateralTriangle.vertices=new Float32Array([.5*Math.cos(UP),.5*Math.sin(UP),.5*Math.cos(UP+PHI),.5*Math.sin(UP+PHI),.5*Math.cos(UP-PHI),.5*Math.sin(UP-PHI)]),Polygon.EquilateralTriangle.indices=new Uint16Array([0,1,2]),Polygon.IsoscelesTriangle={},Polygon.IsoscelesTriangle.vertices=new Float32Array([0,-.5,.5,.5,-.5,.5]),Polygon.IsoscelesTriangle.indices=new Uint16Array([0,1,2]),Polygon.Triangle=Polygon.EquilateralTriangle,Polygon.Square={},Polygon.Square.vertices=new Float32Array([-.5,-.5,.5,-.5,.5,.5,-.5,.5]),Polygon.Square.indices=new Uint16Array([0,1,2,0,3,2]),Polygon.Circle=Polygon.create(180),module.exports=Polygon;

},{}],317:[function(require,module,exports){
"use strict";const GLSL={};GLSL.noise2D=["vec3 mod289(vec3 x) {","  return x - floor(x * (1.0 / 289.0)) * 289.0;","}","vec2 mod289(vec2 x) {","  return x - floor(x * (1.0 / 289.0)) * 289.0;","}","vec3 permute(vec3 x) {","  return mod289(((x*34.0)+1.0)*x);","}","float snoise(vec2 v) {","  const vec4 C = vec4(0.211324865405187, 0.366025403784439, -0.577350269189626, 0.024390243902439);","  vec2 i  = floor(v + dot(v, C.yy) );","  vec2 x0 = v -   i + dot(i, C.xx);","  vec2 i1;","  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);","  vec4 x12 = x0.xyxy + C.xxzz;","  x12.xy -= i1;","  i = mod289(i);","  vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 )) + i.x + vec3(0.0, i1.x, 1.0 ));","  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);","  m = m*m ;","  m = m*m ;","  vec3 x = 2.0 * fract(p * C.www) - 1.0;","  vec3 h = abs(x) - 0.5;","  vec3 ox = floor(x + 0.5);","  vec3 a0 = x - ox;","  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );","  vec3 g;","  g.x  = a0.x  * x0.x  + h.x  * x0.y;","  g.yz = a0.yz * x12.xz + h.yz * x12.yw;","  return 130.0 * dot(m, g);","}"].join("\n"),module.exports=GLSL;

},{}],318:[function(require,module,exports){
"use strict";const Sprite=require("./sprite"),Mesh=require("./mesh"),SPRITE_VS=["const vec2 FLIP_Y = vec2(1,-1);","uniform vec3 uResolution;","uniform vec2 uDimensions;","uniform mat3 uTransform;","attribute vec2 aPosition;","void main() {"," vec3 screenspace = vec3(aPosition * uDimensions * FLIP_Y, 1) * uTransform;"," vec2 clipspace = (screenspace.xy / uResolution.xy) * 2.0 - FLIP_Y;"," gl_Position = vec4(clipspace, 0, 1);","}"].join("\n"),SPRITE_FS=["#ifdef GL_ES","precision mediump float;","#endif","uniform vec3 uColor;","uniform float uAlpha;","void main() {"," gl_FragColor = vec4(uColor / 255.0, uAlpha);","}"].join("\n");function Graphics(t){this.canvas=t,this._hasContext=!1,this._setupContext(),this._onContextLost=this._onContextLost.bind(this),this._onContextRestored=this._onContextRestored.bind(this),this.canvas.addEventListener("webglcontextlost",this._onContextLost),this.canvas.addEventListener("webglcontextrestored",this._onContextRestored)}Graphics.prototype.setSize=function(t,e,o){this._hasContext&&(this._useProgram(this._spriteProgram),this.context.uniform3f(this._spriteProgram.uResolution,t,e,o),this.context.viewport(0,0,t*o,e*o)),this.height=e,this.width=t,this.scale=o},Graphics.prototype.clear=function(t){this._hasContext&&(this.context.clearColor(t.r/255,t.g/255,t.b/255,1),this.context.clear(this.context.COLOR_BUFFER_BIT))},Graphics.prototype.draw=function(t){this._hasContext&&(t instanceof Sprite?(this._bindVertexBuffer(t.geometry),this._bindIndexBuffer(t.geometry),this._useProgram(this._spriteProgram),this._spriteProgram.uDimensions._width===t.width&&this._spriteProgram.uDimensions._height===t.height||this.context.uniform2f(this._spriteProgram.uDimensions,this._spriteProgram.uDimensions._width=t.width,this._spriteProgram.uDimensions._height=t.height),this._spriteProgram.uColor._r===t.color.r&&this._spriteProgram.uColor._g===t.color.g&&this._spriteProgram.uColor._b===t.color.b||this.context.uniform3f(this._spriteProgram.uColor,this._spriteProgram.uColor._r=t.color.r,this._spriteProgram.uColor._g=t.color.g,this._spriteProgram.uColor._b=t.color.b),this._spriteProgram.uAlpha._alpha!==t.alpha&&this.context.uniform1f(this._spriteProgram.uAlpha,this._spriteProgram.uAlpha._alpha=t.alpha),this.context.uniformMatrix3fv(this._spriteProgram.uTransform,this.context.FALSE,t.worldTransform),this._currentGeometry!==t.geometry&&(this.context.enableVertexAttribArray(this._spriteProgram.aPosition),this.context.vertexAttribPointer(this._spriteProgram.aPosition,2,this.context.FLOAT,!1,0,0),this._currentGeometry=t.geometry),this.context.drawElements(this.context.TRIANGLES,t.geometry.indexBuffer.length,this.context.UNSIGNED_SHORT,0)):t instanceof Mesh&&(t.program&&t._programChecksum===this._contextChecksum||this._setupMesh(t),this._bindVertexBuffer(t.geometry),this._bindIndexBuffer(t.geometry),t.geometry.needsUpdate=!1,this._useProgram(t.program),this._updateUniforms(t.program,t.uniforms),this._currentGeometry!==t.geometry&&(this.context.enableVertexAttribArray(t.program.aPosition),this.context.vertexAttribPointer(t.program.aPosition,2,this.context.FLOAT,!1,0,0),this._currentGeometry=t.geometry),this.context.drawElements(this.context.TRIANGLES,t.geometry.indexBuffer.length,this.context.UNSIGNED_SHORT,0)))},Graphics.prototype._setupContext=function(){this.context=this._getContext(),this.context?(this._hasContext=!0,this._contextChecksum=Date.now(),this._spriteProgram=this._createSpriteProgram(),this.setSize(this.width,this.height,this.scale)):this._hasContext=!1},Graphics.prototype._getContext=function(){return this.canvas.getContext("webgl")||this.canvas.getContext("experimental-webgl")},Graphics.prototype._createShader=function(t,e){const o=this.context.createShader(e);if(this.context.shaderSource(o,t),this.context.compileShader(o),!this.context.getShaderParameter(o,this.context.COMPILE_STATUS)){const e=this.context.getShaderInfoLog(o);this._logShaderError(e,t)}return o},Graphics.prototype._createProgram=function(t,e){const o=this.context.createProgram(),r=this._createShader(t,this.context.VERTEX_SHADER),i=this._createShader(e,this.context.FRAGMENT_SHADER);if(this.context.attachShader(o,r),this.context.attachShader(o,i),this.context.linkProgram(o),!this.context.getProgramParameter(o,this.context.LINK_STATUS))throw this.context.getProgramInfoLog(o);return o},Graphics.prototype._createSpriteProgram=function(){const t=this._createProgram(SPRITE_VS,SPRITE_FS);return this._storeAttributeLocations(t,["aPosition"]),this._storeUniformLocations(t,["uResolution","uDimensions","uTransform","uColor","uAlpha"]),t},Graphics.prototype._storeAttributeLocations=function(t,e){e.forEach(function(e){t[e]=this.context.getAttribLocation(t,e)},this)},Graphics.prototype._storeUniformLocations=function(t,e){e.forEach(function(e){t[e]=this.context.getUniformLocation(t,e)},this)},Graphics.prototype._useProgram=function(t){this._currentProgram!==t&&(this.context.useProgram(t),this._currentProgram=t)},Graphics.prototype._bindVertexBuffer=function(t){const e=this.context.ARRAY_BUFFER,o=t.vertexBuffer,r=t._vertexBufferChecksum===this._contextChecksum;if(o&&r&&!t.needsUpdate)this.context.bindBuffer(e,t.vertexBuffer);else{const i=t.dynamic?this.context.DYNAMIC_DRAW:this.context.STATIC_DRAW;o&&r||(t.vertexBuffer=this.context.createBuffer(),t._vertexBufferChecksum=this._contextChecksum),t.vertexBuffer.length=t.vertices.length/2,this.context.bindBuffer(e,t.vertexBuffer),this.context.bufferData(e,t.vertices,i)}},Graphics.prototype._bindIndexBuffer=function(t){const e=this.context.ELEMENT_ARRAY_BUFFER,o=t.indexBuffer,r=t._indexBufferChecksum===this._contextChecksum;if(o&&r&&!t.needsUpdate)this.context.bindBuffer(e,t.indexBuffer);else{const i=t.dynamic?this.context.DYNAMIC_DRAW:this.context.STATIC_DRAW;o&&r||(t.indexBuffer=this.context.createBuffer(),t._indexBufferChecksum=this._contextChecksum),t.indexBuffer.length=t.indices.length,this.context.bindBuffer(e,t.indexBuffer),this.context.bufferData(e,t.indices,i)}},Graphics.prototype._updateUniforms=function(t,e){let o,r,i;for(const s in e)s in t&&(o=e[s],r=t[s],i=o.value.toString(),r.value!==i&&(o.value.length?this.context[o.type].apply(this.context,[r].concat(o.value)):this.context[o.type].call(this.context,r,o.value),r.value=i))},Graphics.prototype._logShaderError=function(t,e){let o=/\d+:(\d+)/g.exec(t);if(o){o=parseInt(o[1],10)-1;const t=e.split("\n");console.log(`%c${t.splice(0,o).join("\n")}%c`+`\n${t[0]}\n`+`%c${t.splice(1).join("\n")}`,"color: #ccc","color: red","color: #ccc")}throw t},Graphics.prototype._setupMesh=function(t){t.program=this._createProgram(t.shader.vertex,t.shader.fragment),this._storeAttributeLocations(t.program,t.shader.attributes),this._storeUniformLocations(t.program,t.shader.uniforms),t._programChecksum=this._contextChecksum},Graphics.prototype._onContextLost=function(t){t.preventDefault(),this._currentGeometry=null,this._hasContext=!1},Graphics.prototype._onContextRestored=function(){this._setupContext()},module.exports=Graphics;

},{"./mesh":319,"./sprite":322}],319:[function(require,module,exports){
"use strict";function Mesh(s){for(const t in s)this[t]||(this[t]=s[t])}module.exports=Mesh;

},{}],320:[function(require,module,exports){
"use strict";const Graphics=require("./graphics");function Renderer(){this.domElement=document.createElement("canvas"),this.height=0,this.width=0,this._graphics=new Graphics(this.domElement)}Renderer.prototype.render=function(e){this._graphics.clear(e.backgroundColor),this._traverseNode(e)},Renderer.prototype.setSize=function(e,t){const r=window.devicePixelRatio||1;this._graphics.setSize(e,t,r),this.domElement.style.height=`${t}px`,this.domElement.style.width=`${e}px`,this.domElement.height=t*r,this.domElement.width=e*r},Renderer.prototype.canRender=function(){return!!this._graphics.context},Renderer.prototype._traverseNode=function(e){if(e.geometry&&this._graphics.draw(e),e.children&&e.children.length)for(let t=0,r=e.children.length;t<r;t++)this._traverseNode(e.children[t])},module.exports=Renderer;

},{"./graphics":318}],321:[function(require,module,exports){
"use strict";const Sprite=require("./sprite"),Color=require("../geom/color");function Scene(){Sprite.call(this),this.backgroundColor=new Color("#f2f2f2"),this.fixed=!0}Scene.prototype=Object.create(Sprite.prototype),Scene.prototype.getTotalSpriteCount=function(){let e=0;return function t(o){e++;for(let e=0,r=o.children.length;e<r;e++)t(o.children[e])}(this),e},module.exports=Scene;

},{"../geom/color":312,"./sprite":322}],322:[function(require,module,exports){
"use strict";const Matrix=require("../geom/matrix"),Color=require("../geom/color");function Sprite(t){this.children=[],this.geometry=t,this.parent=null,this.height=100,this.width=100,this.color=new Color("#ff4632"),this.alpha=1,this._localTransformNeedsUpdate=!0,this._worldTransformNeedsUpdate=!0,this._localTransform=Matrix.create(),this._worldTransform=Matrix.create(),this._translationMatrix=Matrix.create(),this._rotationMatrix=Matrix.create(),this._scaleMatrix=Matrix.create(),this._rotation=0,this._scaleX=1,this._scaleY=1,this._x=0,this._y=0}Sprite.prototype.addChild=function(t){return t.parent&&t.parent.removeChild(t),this.children.push(t),t.parent=this,t},Sprite.prototype.addChildAt=function(t,r){const e=Math.min(this.children.length,Math.max(0,r));return this.hasChild(t)&&this.removeChild(t),this.children[e]=t,t.parent=this,t},Sprite.prototype.removeChild=function(t){const r=this.getChildIndex(t);return-1!==r&&(this.children.splice(r,1),t.parent=null),t},Sprite.prototype.removeChildAt=function(t){return this.removeChild(this.children[t])},Sprite.prototype.hasChild=function(t){return-1!==this.getChildIndex(t)},Sprite.prototype.getChildIndex=function(t){return this.children.indexOf(t)},Sprite.prototype.destroy=function(){for(;this.children.length;)this.removeChildAt(0)},Object.defineProperty(Sprite.prototype,"localTransform",{get:function(){return this._localTransformNeedsUpdate&&this._updateLocalTransform(),this._localTransform}}),Object.defineProperty(Sprite.prototype,"worldTransform",{get:function(){return this._worldTransformNeedsUpdate&&this._updateWorldTransform(),this._worldTransform}}),Object.defineProperty(Sprite.prototype,"rotation",{get:function(){return this._rotation},set:function(t){this._localTransformNeedsUpdate=!0,this._worldTransformNeedsUpdate=!0,this._rotation=t}}),Object.defineProperty(Sprite.prototype,"scaleX",{get:function(){return this._scaleX},set:function(t){this._localTransformNeedsUpdate=!0,this._worldTransformNeedsUpdate=!0,this._scaleX=t}}),Object.defineProperty(Sprite.prototype,"scaleY",{get:function(){return this._scaleY},set:function(t){this._localTransformNeedsUpdate=!0,this._worldTransformNeedsUpdate=!0,this._scaleY=t}}),Object.defineProperty(Sprite.prototype,"x",{get:function(){return this._x},set:function(t){this._localTransformNeedsUpdate=!0,this._worldTransformNeedsUpdate=!0,this._x=t}}),Object.defineProperty(Sprite.prototype,"y",{get:function(){return this._y},set:function(t){this._localTransformNeedsUpdate=!0,this._worldTransformNeedsUpdate=!0,this._y=t}}),Sprite.prototype._updateLocalTransform=function(){this._localTransformNeedsUpdate=!1,Matrix.setScale(this._scaleMatrix,this._scaleX,this._scaleY),Matrix.setRotation(this._rotationMatrix,this._rotation),Matrix.setTranslation(this._translationMatrix,this._x,-this._y),Matrix.multiply(this._localTransform,this._scaleMatrix,this._rotationMatrix),Matrix.multiply(this._localTransform,this._localTransform,this._translationMatrix)},Sprite.prototype._updateWorldTransform=function(){if(this._worldTransformNeedsUpdate=!1,this._localTransformNeedsUpdate&&this._updateLocalTransform(),this.parent&&!this.parent.fixed?Matrix.multiply(this._worldTransform,this._localTransform,this.parent.worldTransform):Matrix.copy(this._worldTransform,this._localTransform),this.children.length)for(let t=0,r=this.children.length;t<r;t++)this.children[t]._worldTransformNeedsUpdate=!0},module.exports=Sprite;

},{"../geom/color":312,"../geom/matrix":314}],323:[function(require,module,exports){
"use strict";const Noise=function(){const t={};function o(t,o,n){this.x=t,this.y=o,this.z=n}o.prototype.dot2=function(t,o){return this.x*t+this.y*o},o.prototype.dot3=function(t,o,n){return this.x*t+this.y*o+this.z*n};const n=[new o(1,1,0),new o(-1,1,0),new o(1,-1,0),new o(-1,-1,0),new o(1,0,1),new o(-1,0,1),new o(1,0,-1),new o(-1,0,-1),new o(0,1,1),new o(0,-1,1),new o(0,1,-1),new o(0,-1,-1)],e=[151,160,137,91,90,15,131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,190,6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,88,237,149,56,87,174,20,125,136,171,168,68,175,74,165,71,134,139,48,27,166,77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244,102,143,54,65,25,63,161,1,216,80,73,209,76,132,187,208,89,18,169,200,196,135,130,116,188,159,86,164,100,109,198,173,186,3,64,52,217,226,250,124,123,5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,223,183,170,213,119,248,152,2,44,154,163,70,221,153,101,155,167,43,172,9,129,22,39,253,19,98,108,110,79,113,224,232,178,185,112,104,218,246,97,228,251,34,242,193,238,210,144,12,191,179,162,241,81,51,145,235,249,14,239,107,49,192,214,31,181,199,106,157,184,84,204,176,115,121,50,45,127,4,150,254,138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180],r=new Array(512),s=new Array(512);t.seed=function(t){let o=t;o>0&&o<1&&(o*=65536),(o=Math.floor(o))<256&&(o|=o<<8);for(let t=0;t<256;t++){let l;l=1&t?e[t]^255&o:e[t]^o>>8&255,r[t]=r[t+256]=l,s[t]=s[t+256]=n[l%12]}},t.seed(0);const l=.5*(Math.sqrt(3)-1),i=(3-Math.sqrt(3))/6,c=1/6;function d(t){return t*t*t*(t*(6*t-15)+10)}function f(t,o,n){return(1-n)*t+n*o}return t.simplex2=function(t,o){let n,e,c;const d=(t+o)*l;let f=Math.floor(t+d),u=Math.floor(o+d);const h=(f+u)*i,a=t-f+h,w=o-u+h;let M,p;a>w?(M=1,p=0):(M=0,p=1);const y=a-M+i,x=w-p+i,m=a-1+2*i,q=w-1+2*i,z=s[(f&=255)+r[u&=255]],A=s[f+M+r[u+p]],N=s[f+1+r[u+1]];let b=.5-a*a-w*w,g=.5-y*y-x*x,j=.5-m*m-q*q;return 70*((n=b<0?0:(b*=b)*b*z.dot2(a,w))+(e=g<0?0:(g*=g)*g*A.dot2(y,x))+(c=j<0?0:(j*=j)*j*N.dot2(m,q)))},t.simplex3=function(t,o,n){let e,l,i,d;const f=(t+o+n)*(1/3);let u=Math.floor(t+f),h=Math.floor(o+f),a=Math.floor(n+f);const w=(u+h+a)*c,M=t-u+w,p=o-h+w,y=n-a+w;let x,m,q,z,A,N;M>=p?p>=y?(x=1,m=0,q=0,z=1,A=1,N=0):M>=y?(x=1,m=0,q=0,z=1,A=0,N=1):(x=0,m=0,q=1,z=1,A=0,N=1):p<y?(x=0,m=0,q=1,z=0,A=1,N=1):M<y?(x=0,m=1,q=0,z=0,A=1,N=1):(x=0,m=1,q=0,z=1,A=1,N=0);const b=M-x+c,g=p-m+c,j=y-q+c,k=M-z+2*c,v=p-A+2*c,B=y-N+2*c,C=M-1+.5,D=p-1+.5,E=y-1+.5,F=s[(u&=255)+r[(h&=255)+r[a&=255]]],G=s[u+x+r[h+m+r[a+q]]],H=s[u+z+r[h+A+r[a+N]]],I=s[u+1+r[h+1+r[a+1]]];let J=.6-M*M-p*p-y*y,K=.6-b*b-g*g-j*j,L=.6-k*k-v*v-B*B,O=.6-C*C-D*D-E*E;return 32*((e=J<0?0:(J*=J)*J*F.dot3(M,p,y))+(l=K<0?0:(K*=K)*K*G.dot3(b,g,j))+(i=L<0?0:(L*=L)*L*H.dot3(k,v,B))+(d=O<0?0:(O*=O)*O*I.dot3(C,D,E)))},t.perlin2=function(t,o){let n=t,e=o,l=Math.floor(n),i=Math.floor(e);n-=l,e-=i;const c=s[(l&=255)+r[i&=255]].dot2(n,e),u=s[l+r[i+1]].dot2(n,e-1),h=s[l+1+r[i]].dot2(n-1,e),a=s[l+1+r[i+1]].dot2(n-1,e-1),w=d(n);return f(f(c,h,w),f(u,a,w),d(e))},t.perlin3=function(t,o,n){let e=t,l=o,i=n,c=Math.floor(e),u=Math.floor(l),h=Math.floor(i);e-=c,l-=u,i-=h;const a=s[(c&=255)+r[(u&=255)+r[h&=255]]].dot3(e,l,i),w=s[c+r[u+r[h+1]]].dot3(e,l,i-1),M=s[c+r[u+1+r[h]]].dot3(e,l-1,i),p=s[c+r[u+1+r[h+1]]].dot3(e,l-1,i-1),y=s[c+1+r[u+r[h]]].dot3(e-1,l,i),x=s[c+1+r[u+r[h+1]]].dot3(e-1,l,i-1),m=s[c+1+r[u+1+r[h]]].dot3(e-1,l-1,i),q=s[c+1+r[u+1+r[h+1]]].dot3(e-1,l-1,i-1),z=d(e),A=d(l),N=d(i);return f(f(f(a,y,z),f(w,x,z),N),f(f(M,m,z),f(p,q,z),N),A)},t}();module.exports=Noise;

},{}],324:[function(require,module,exports){
"use strict";const Random=function(n,o){let t=n,a=o;return(void 0===o||isNaN(o))&&(a=t,t=0),t+Math.random()*(a-t)};Random.float=Random,Random.int=function(n,o){return Math.floor(Random.float(n,o))},Random.bit=function(n){return Math.random()<(void 0===n||isNaN(n)?.5:n)?0:1},Random.sign=function(n){return Math.random()<(void 0===n||isNaN(n)?.5:n)?-1:1},Random.bool=function(n){return Math.random()<(void 0===n||isNaN(n)?.5:n)},Random.element=function(n){return n[Math.floor(Math.random()*n.length)]},module.exports=Random;

},{}],325:[function(require,module,exports){
"use strict";const Easing={addCurve:function(n){return n.in=n,n.out=function(a){return 1-n(1-a)},n.inOut=function(a){return a<=.5?n(2*a)/2:(2-n(2*(1-a)))/2},n},Linear:function(n){return n}};Easing.Linear.in=Easing.Linear,Easing.Linear.inOut=Easing.Linear,Easing.Elastic=Easing.addCurve(function(n){let a=n;return Math.pow(2,10*--a)*Math.cos(20*n*Math.PI*1/3)}),Easing.Bounce=Easing.addCurve(function(n){let a,i=0,t=1,r=0;for(;r<1e4;){if(i+=t,t/=2,n>=(7-4*i)/11){a=-Math.pow((11-6*i-11*n)/4,2)+t*t;break}r++}return a}),Easing.Back=Easing.addCurve(function(n){return Math.pow(n,2)*((1.618+1)*n-1.618)}),Easing.Sine=Easing.addCurve(function(n){return 1-Math.sin((1-n)*Math.PI/2)}),Easing.Circ=Easing.addCurve(function(n){return 1-Math.sin(Math.acos(n))}),Easing.Quad=Easing.addCurve(function(n){return Math.pow(n,2)}),Easing.Cubic=Easing.addCurve(function(n){return Math.pow(n,3)}),Easing.Quart=Easing.addCurve(function(n){return Math.pow(n,4)}),Easing.Quint=Easing.addCurve(function(n){return Math.pow(n,5)}),Easing.Expo=Easing.addCurve(function(n){return Math.pow(2,10*(n-1))}),module.exports=Easing;

},{}],326:[function(require,module,exports){
"use strict";const Easing=require("./easing"),_tweens=[];function _trigger(e,t){if(e.length)for(let s=0,n=e.length;s<n;s++)e[s](t)}function _destroy(e){e._startHandlers.length=0,e._progressHandlers.length=0,e._completeHandlers.length=0;const t=_tweens.indexOf(e);-1!==t&&_tweens.splice(t,1)}function Tween(e){this.target=e,this.progress=0,this.paused=!1,this._progressHandlers=[],this._completeHandlers=[],this._startHandlers=[],this._clock=0}Tween.to=function(e,t,s,n,r){return new Tween(e).to(t,s,n,r)},Tween.from=function(e,t,s,n,r){return new Tween(e).from(t,s,n,r)},Tween.tick=function(e){let t,s,n,r,o;for(let i=_tweens.length-1;i>=0;i--)if(t=(s=_tweens[i]).easing===Easing.Linear,!s.paused&&(s._clock+=e,s._clock>=0)){if(0===s.progress){for(n in s.fromValues={},s.toValues)n in s.target&&(s.fromValues[n]=s.target[n]);s._startHandlers.length&&_trigger(s._startHandlers,s)}for(n in s.progress=s._clock/s.duration||0,s.progress<0&&(s.progress=0),s.progress>1&&(s.progress=1),s.toValues)n in s.fromValues&&(r=s.fromValues[n],o=s.toValues[n],s.target[n]=r+(o-r)*(t?s.progress:s.easing(s.progress)));s.progress<1?s._progressHandlers.length&&_trigger(s._progressHandlers,s):(s._completeHandlers.length&&_trigger(s._completeHandlers,s),_destroy(s))}},Tween.destroyAll=function(e){if(e)for(let t=_tweens.length-1;t>=0;t--)_tweens[t].target===e&&_destroy(_tweens[t]);else for(;_tweens.length;)_destroy(_tweens.pop())},Tween.prototype.to=function(e,t,s,n){let r=n,o=s;return"function"==typeof s&&(r=s,o=0),this.toValues=e,this.duration=t||0,this.easing=r||Easing.Linear,this.delay=o||0,this._clock=-this.delay,-1===_tweens.indexOf(this)&&_tweens.unshift(this),this},Tween.prototype.from=function(e,t,s,n){const r={};for(const t in e)t in this.target&&(r[t]=this.target[t],this.target[t]=e[t]);return this.to(r,t,s,n)},Tween.prototype.play=function(){this.paused=!1},Tween.prototype.pause=function(){this.paused=!0},Tween.prototype.stop=function(){this.paused=!0},Tween.prototype.reset=function(){if(this.progress>0)for(const e in this.fromValues)e in this.fromValues&&(this.target[e]=this.fromValues[e]);this.progress=0,this._clock=-this.delay},Tween.prototype.wait=function(e){this._clock-=e},Tween.prototype.destroy=function(){_destroy(this)},Tween.prototype.onStart=function(e){return this._startHandlers.push(e),this},Tween.prototype.onProgress=function(e){return this._progressHandlers.push(e),this},Tween.prototype.onComplete=function(e){return this._completeHandlers.push(e),this},Tween.Easing=Easing,module.exports=Tween;

},{"./easing":325}],327:[function(require,module,exports){
"use strict";const ArrayUtils={shuffle:function(t){for(let r=t.length-1;r>0;r--){const o=Math.floor(Math.random()*(r+1)),s=t[r];t[r]=t[o],t[o]=s}return t}};module.exports=ArrayUtils;

},{}],328:[function(require,module,exports){
"use strict";const NumberUtils={lerp:function(t,r,e){return t+e*(r-t)},map:function(t,r,e,u,n){return(t-r)/(e-r)*(n-u)+u}};module.exports=NumberUtils;

},{}],329:[function(require,module,exports){
"use strict";function ObjectPool(t){this.maxSize=t||100,this.objects=[],this.refresh=null,this.create=null,this.clean=null}ObjectPool.prototype.next=function(){let t;return this.objects.length?(t=this.objects.pop(),"function"==typeof this.refresh&&this.refresh(t)):"function"==typeof this.create&&(t=this.create()),t},ObjectPool.prototype.add=function(t){let e=!1;return this.objects.length<this.maxSize&&-1===this.objects.indexOf(t)&&("function"==typeof this.clean&&this.clean(t),this.objects.push(t),e=!0),e},ObjectPool.prototype.empty=function(t){let e;for(;this.objects.length;)e=this.objects.pop(),"function"==typeof t&&t(e)},module.exports=ObjectPool;

},{}],330:[function(require,module,exports){
"use strict";const Palette=require("./common/geom/palette"),Scene=require("./common/graphics/scene");function Visualization(){this.scene=new Scene,this.clock=0,this.width=0,this.height=0,this._schedule=[],this.scene.backgroundColor=Palette.primary}Visualization.prototype.setup=function(){},Visualization.prototype.tick=function(t){this.clock+=t,this._checkSchedule()},Visualization.prototype.setSize=function(t,e){this.width=t,this.height=e},Visualization.prototype.schedule=function(t,e){this._schedule.push({callback:t,time:this.clock+e}),this._sortSchledule()},Visualization.prototype.handleAudioEvent=function(){},Visualization.prototype.destroy=function(){this._schedule.length=0},Visualization.prototype._sortSchledule=function(){this._schedule.sort(function(t,e){return e.time-t.time})},Visualization.prototype._checkSchedule=function(){if(this._schedule.length)for(let t,e=this._schedule.length-1;e>=0;e--){if(t=this._schedule[e],this.clock<t.time)return;t.callback(),this._schedule.splice(e,1)}},module.exports=Visualization;

},{"./common/geom/palette":315,"./common/graphics/scene":321}],331:[function(require,module,exports){
"use strict";const Config={usePalette:!0,maxCircles:6,layerThreshold:.72,minCircleInterval:5,maxCircleInterval:6,minGrowthDuration:55,maxGrowthDuration:70,minGrowthDelay:0,maxGrowthDelay:2};module.exports=Config;

},{}],332:[function(require,module,exports){
"use strict";const Visualization=require("../../visualization"),ColorPalette=require("../../../palette/color_palette"),ObjectPool=require("../../common/util/pool"),Palette=require("../../common/geom/palette"),Random=require("../../common/math/random"),Color=require("../../common/geom/color"),Config=require("./config"),Layer=require("./layer");function Circles(){Visualization.call(this),this._generation=0,this._palette=new ColorPalette,this._layers=[],this._layerPool=new ObjectPool(100),this._layerPool.refresh=this._refreshLayer.bind(this),this._layerPool.create=this._createLayer.bind(this)}Circles.prototype=Object.create(Visualization.prototype),Circles.prototype.setup=function(){Visualization.prototype.setup.call(this),this._addLayer()},Circles.prototype.tick=function(e){Visualization.prototype.tick.call(this,e);for(let t,o=0,r=this._layers.length;o<r;o++)(t=this._layers[o]).tick(e),t.completeEnough||t.progress>=Config.layerThreshold&&(t.completeEnough=!0,this._addLayer());this._pruneLayers()},Circles.prototype.setSize=function(e,t){Visualization.prototype.setSize.call(this,e,t);for(let o=0,r=this._layers.length;o<r;o++)this._layers[o].setSize(e,t)},Circles.prototype.destroy=function(){for(Visualization.prototype.destroy.call(this);this._layers.length;)this._layers.pop().destroy();this._layerPool.empty(function(e){e.destroy()})},Circles.prototype._createLayer=function(){const e=new Layer;return this._refreshLayer(e),e},Circles.prototype._refreshLayer=function(e){e.completeEnough=!1,e.previousLayer=this._layers[this._layers.length-1],e.color=this._getNextColor(),e.setSize(this.width,this.height)},Circles.prototype._addLayer=function(){const e=this._layerPool.next();this.scene.addChild(e),this._layers.push(e),this._generation++},Circles.prototype._getNextColor=function(){if(Config.usePalette)return this._generation%2==0?Palette.secondary:Palette.primary;if(this._currentColorName||(this._currentColorName=this._palette.randomColor(),this.scene.backgroundColor=this._getColorByName(this._currentColorName)),!this._colorQueue||!this._colorQueue.length){const e=this._palette.randomTriplet(this._currentColorName);this._colorQueue=e.concat()}const e=Random.int(this._colorQueue.length);return this._currentColorName=this._colorQueue.splice(e,1)[0],this._getColorByName(this._currentColorName)},Circles.prototype._getColorByName=function(e){const t=this._palette.colorLookup[e];return new Color(t.r,t.g,t.b)},Circles.prototype._pruneLayers=function(){const e=this._layers[0];e&&e.complete&&(this.scene.backgroundColor=e.color,this.scene.removeChild(e),this._layers.shift(),this._layerPool.add(e),e.reset())},module.exports=Circles;

},{"../../../palette/color_palette":306,"../../common/geom/color":312,"../../common/geom/palette":315,"../../common/math/random":324,"../../common/util/pool":329,"../../visualization":330,"./config":331,"./layer":333}],333:[function(require,module,exports){
"use strict";const ObjectPool=require("../../common/util/pool"),Polygon=require("../../common/geom/polygon"),Sprite=require("../../common/graphics/sprite"),Random=require("../../common/math/random"),Config=require("./config.js"),Tween=require("../../common/tween/tween"),Grid=require("../../common/geom/grid");function Layer(t,i){Sprite.call(this),this.previousLayer=i,this.complete=!1,this.progress=0,this.circles=[],this.color=t,this.fixed=!0,this._countdown=0,this._circleEndState={scaleX:1,scaleY:1},this._nextPosition={x:0,y:0},this._deadCells=[],this._grid=new Grid(10,8),this._circlesPool=new ObjectPool(100),this._circlesPool.create=this._createCircle.bind(this)}Layer.prototype=Object.create(Sprite.prototype),Layer.prototype.tick=function(t){this.progress<1&&(this._countdown-=t,this._countdown<=0&&(this.circles.length<Config.maxCircles?(this._addCircle(),this._countdown=Random.float(Config.minCircleInterval,Config.maxCircleInterval)):(this._countdown=1,this._updateGrid())))},Layer.prototype.setSize=function(t,i){this.width=t,this.height=i,this._grid.setSize(t,i)},Layer.prototype.reset=function(){let t;for(this._countdown=0,this.complete=!1,this.progress=0;this.circles.length;)t=this.circles.pop(),this._circlesPool.add(t),Tween.destroyAll(t),this.removeChild(t);for(;this._deadCells.length;)this._grid.cells.push(this._deadCells.pop())},Layer.prototype.destroy=function(){Sprite.prototype.destroy.call(this)},Layer.prototype._createCircle=function(){return new Sprite(Polygon.Circle)},Layer.prototype._addCircle=function(){this._updateNextPosition();const t=this._computeFillRadius(this._nextPosition.x,this._nextPosition.y),i=this._circlesPool.next();i.color=this.color,i.width=i.height=2*t,i.scaleX=i.scaleY=0,i.x=this._nextPosition.x,i.y=this._nextPosition.y;const e=Tween.to(i,this._circleEndState,Random.float(Config.minGrowthDuration,Config.maxGrowthDuration),Random.float(Config.minGrowthDelay,Config.maxGrowthDelay),Tween.Easing.Linear.inOut);0===this.circles.length&&e.onComplete(()=>{this.complete=!0}),this.circles.push(i),this.addChild(i)},Layer.prototype._updateGrid=function(){let t,i,e,o,s,r,h,n,l;for(r=this.circles.length-1;r>=0;r--)for(i=(e=(o=this.circles[r]).width*o.scaleX/2+this._grid.cellDiagonal/2)*e,h=this._grid.cells.length-1;h>=0;h--)(t=(n=(s=this._grid.cells[h]).cx-o.x)*n+(l=s.cy-o.y)*l)<i&&(this._grid.cells.splice(h,1),this._deadCells.push(s));this.progress=1-this._grid.cells.length/this._grid.numCells},Layer.prototype._updateNextPosition=function(){if(this.circles.length&&(this._updateGrid(),this._grid.cells.length)){const t=Random.int(this._grid.cells.length),i=this._grid.cells[t];return this._nextPosition.x=i.cx,void(this._nextPosition.y=i.cy)}if(this.previousLayer){const t=Random.int(Math.min(this.previousLayer.circles.length,2)),i=this.previousLayer.circles[t];if(i){const t=i.width*i.scaleX/2*Random.float(.25,.85),e=Random.float(2*Math.PI),o=i.x+Math.cos(e)*t,s=i.y+Math.sin(e)*t;return this._nextPosition.x=Math.min(.9*this.width,Math.max(.1*this.width,o)),void(this._nextPosition.y=Math.min(.9*this.height,Math.max(.1*this.height,s)))}}this._nextPosition.x=this.width*Random.float(.2,.8),this._nextPosition.y=this.height*Random.float(.2,.8)},Layer.prototype._computeFillRadius=function(t,i){const e=t>this.width/2?t:this.width-t,o=i>this.height/2?i:this.height-i;return Math.sqrt(e*e+o*o)},module.exports=Layer;

},{"../../common/geom/grid":313,"../../common/geom/polygon":316,"../../common/graphics/sprite":322,"../../common/math/random":324,"../../common/tween/tween":326,"../../common/util/pool":329,"./config.js":331}],334:[function(require,module,exports){
"use strict";const Config={dots:{scale:!0,rotate:!1,offsetSpeed:.35,noiseSpeed:.35,minNoiseScale:1,maxNoiseScale:3,minShapeScale:.25,maxShapeScale:1.05,cellSize:80},cross:{scale:!0,rotate:!0,offsetSpeed:.3,noiseSpeed:.3,minNoiseScale:.8,maxNoiseScale:3,minShapeScale:-1.25,maxShapeScale:1.25,minShapeRotation:-Math.PI,maxShapeRotation:Math.PI,cellSize:80},triangles:{scale:!0,rotate:!1,offsetSpeed:.35,noiseSpeed:.35,minNoiseScale:1,maxNoiseScale:3,minShapeScale:.01,maxShapeScale:1,cellSize:95}};module.exports=Config;

},{}],335:[function(require,module,exports){
"use strict";const GridVisualization=require("./index"),Polygon=require("../../common/geom/polygon");function DotsGrid(){GridVisualization.call(this,GridVisualization.DOTS,Polygon.Circle)}DotsGrid.prototype=Object.create(GridVisualization.prototype),module.exports=DotsGrid;

},{"../../common/geom/polygon":316,"./index":336}],336:[function(require,module,exports){
"use strict";const Visualization=require("../../visualization"),NumberUtils=require("../../common/util/number"),ObjectPool=require("../../common/util/pool"),Palette=require("../../common/geom/palette"),Polygon=require("../../common/geom/polygon"),Sprite=require("../../common/graphics/sprite"),Config=require("./config"),Random=require("../../common/math/random"),Tween=require("../../common/tween/tween"),Noise=require("../../common/math/noise"),Grid=require("../../common/geom/grid");function GridVisualization(i,t){Visualization.call(this),this._type=i||GridVisualization.DOTS,this._geometry=t||Polygon.Circle,this._config=Config[this._type],this._noiseRange=this._computeNoiseRange(3),this._shapePool=new ObjectPool(100),this._shapePool.create=this._createShape.bind(this),this._isFirstGrid=!0,this._baseScale=1,this._shapes=[],this._grid=null}GridVisualization.prototype=Object.create(Visualization.prototype),GridVisualization.DOTS="dots",GridVisualization.CROSS="cross",GridVisualization.TRIANGLES="triangles",GridVisualization.prototype.setup=function(){Visualization.prototype.setup.call(this),Noise.seed(1e9*Math.random())},GridVisualization.prototype.tick=function(i){Visualization.prototype.tick.call(this,i);const t=NumberUtils.map(Math.sin(this.clock*this._config.noiseSpeed),-1,1,this._config.minNoiseScale,this._config.maxNoiseScale),e=this.clock*this._config.offsetSpeed;let o;for(let i,s=0,a=this._shapes.length;s<a;s++)i=this._shapes[s],o=this._getNoiseValue(i.nx*t,i.ny*t,e),this._config.scale&&(i.scaleX=i.scaleY=i.drawScale*this._baseScale*NumberUtils.map(o,0,1,this._config.minShapeScale,this._config.maxShapeScale)),this._config.rotate&&(i.rotation=NumberUtils.map(o,0,1,this._config.minShapeRotation,this._config.maxShapeRotation))},GridVisualization.prototype.setSize=function(i,t){Visualization.prototype.setSize.call(this,i,t),this._createGrid()},GridVisualization.prototype.destroy=function(){Visualization.prototype.destroy.call(this)},GridVisualization.prototype._computeNoiseRange=function(i){const t=Math.sqrt(i)/2;return[-t,t]},GridVisualization.prototype._getNoiseValue=function(i,t,e){const o=Noise.perlin3(i,t,e);return NumberUtils.map(o,this._noiseRange[0],this._noiseRange[1],0,1)},GridVisualization.prototype._clear=function(){if(this._shapes.length){let i;for(;this._shapes.length;)i=this._shapes.pop(),this.scene.removeChild(i),this._shapePool.add(i)}},GridVisualization.prototype._createGrid=function(){const i=this._config.cellSize,t=Math.floor(this.height/i),e=Math.floor(this.width/i),o=this.width/e,s=this.height/t,a=(o-i)/2+i/2+i*(-this._geometry.offsetX||0),n=(s-i)/2+i/2+i*(-this._geometry.offsetY||0);this._clear(),this._baseScale=Math.min(o,s)/i,this._grid=new Grid(t,e,this.width,this.height);for(let t,e,o=0,s=this._grid.cells.length;o<s;o++)e=this._grid.cells[o],(t=this._shapePool.next()).color=Palette.overlay,t.x=e.x+a,t.y=e.y+n,t.nx=t.x/this.width,t.ny=t.y/this.height,t.width=i,t.height=i,this.scene.addChild(t),this._shapes.push(t),this._isFirstGrid?(t.drawScale=0,Tween.to(t,{drawScale:1},2,Random.float(6),Tween.Easing.Quint.out)):t.drawScale=1;this._isFirstGrid=!1},GridVisualization.prototype._createShape=function(){return new Sprite(this._geometry)},module.exports=GridVisualization;

},{"../../common/geom/grid":313,"../../common/geom/palette":315,"../../common/geom/polygon":316,"../../common/graphics/sprite":322,"../../common/math/noise":323,"../../common/math/random":324,"../../common/tween/tween":326,"../../common/util/number":328,"../../common/util/pool":329,"../../visualization":330,"./config":334}],337:[function(require,module,exports){
"use strict";const GridVisualization=require("./index"),Geometry={offsetY:-.5,vertices:new Float32Array([0,-1,.5,0,-.5,0]),indices:new Uint16Array([0,1,2])};function TrianglesGrid(){GridVisualization.call(this,GridVisualization.TRIANGLES,Geometry)}TrianglesGrid.prototype=Object.create(GridVisualization.prototype),module.exports=TrianglesGrid;

},{"./index":336}],338:[function(require,module,exports){
"use strict";const Config={lineThickness:12,lineSpacing:12,columnSpacing:160,noiseScale:2,noiseSpeed:.05,maxOffset:100};module.exports=Config;

},{}],339:[function(require,module,exports){
"use strict";const Visualization=require("../../visualization"),NumberUtils=require("../../common/util/number"),Palette=require("../../common/geom/palette"),Config=require("./config"),Tween=require("../../common/tween/tween"),GLSL=require("../../common/graphics/glsl"),Mesh=require("../../common/graphics/mesh");function LinesVisualization(){Visualization.call(this),this._mesh=new Mesh({shader:{vertex:[GLSL.noise2D,"attribute vec2 aPosition;","uniform float uNoiseSpeed;","uniform float uNoiseScale;","uniform float uOffset;","uniform float uScale;","uniform float uTime;","void main() {"," vec2 position = aPosition * vec2(1.0, -1.0);"," vec2 noiseCoord = vec2(","   position.x * uNoiseScale,","   position.y + uTime * uNoiseSpeed"," );"," float noise = snoise(noiseCoord);"," position.x += noise * uOffset * 0.25;"," position.y += noise * uOffset;"," position *= uScale;"," gl_Position = vec4(position, 0, 1);","}"].join("\n"),fragment:["#ifdef GL_ES","precision mediump float;","#endif","uniform vec3 uColor;","void main() {"," gl_FragColor = vec4(uColor, 1);","}"].join("\n"),attributes:["aPosition"],uniforms:["uNoiseScale","uNoiseSpeed","uOffset","uScale","uColor","uTime"]},geometry:{dynamic:!1,vertices:new Float32Array,indices:new Uint16Array},uniforms:{uNoiseScale:{type:"uniform1f",value:0},uNoiseSpeed:{type:"uniform1f",value:0},uOffset:{type:"uniform1f",value:0},uScale:{type:"uniform1f",value:1},uColor:{type:"uniform3f",value:[.5,.5,.5]},uTime:{type:"uniform1f",value:0}}})}LinesVisualization.prototype=Object.create(Visualization.prototype),LinesVisualization.prototype.setup=function(){Visualization.prototype.setup.call(this),this._mesh.uniforms.uNoiseSpeed.value=Config.noiseSpeed,this._mesh.uniforms.uNoiseScale.value=Config.noiseScale,this._mesh.uniforms.uScale.value=10,this._mesh.uniforms.uOffset.value=-Config.maxOffset/this.height,this._alpha=0,Tween.to(this._mesh.uniforms.uOffset,{value:Config.maxOffset/this.height},5,Tween.Easing.Expo.out),Tween.to(this._mesh.uniforms.uScale,{value:1},5,Tween.Easing.Expo.out),Tween.to(this,{_alpha:1},2,.1,Tween.Easing.Quad.inOut),this.scene.addChild(this._mesh)},LinesVisualization.prototype.tick=function(e){Visualization.prototype.tick.call(this,e),this._mesh.uniforms.uTime.value=this.clock;let i=Palette.overlay.r,t=Palette.overlay.g,o=Palette.overlay.b;this._alpha<1&&(i=NumberUtils.lerp(Palette.primary.r,i,this._alpha),t=NumberUtils.lerp(Palette.primary.g,t,this._alpha),o=NumberUtils.lerp(Palette.primary.b,o,this._alpha)),this._mesh.uniforms.uColor.value=[i/255,t/255,o/255]},LinesVisualization.prototype.setSize=function(e,i){Visualization.prototype.setSize.call(this,e,i),this._updateGeometry()},LinesVisualization.prototype._updateGeometry=function(){const e=[],i=[],t=this.width+2*Config.maxOffset,o=this.height+2*Config.maxOffset,s=Config.lineThickness+Config.lineSpacing,n=Config.columnSpacing/this.width*2,a=(Config.lineThickness+Config.lineSpacing)/this.height*2,u=Config.lineThickness/this.height*2,l=Math.ceil(o/s),r=Math.ceil(t/Config.columnSpacing)+1,h=(t-this.width)/this.width,f=(o-this.height)/this.height;for(let t=0;t<l;t++){const o=t*a-1-f;for(let s=0;s<r;s++){const a=s*n-1-h;if(e.push(a,o,a,o+u),s>0){const e=2*(t*r+(s-1));i.push(e+0,e+2,e+1,e+1,e+2,e+3)}}}this._mesh.geometry.vertices=new Float32Array(e),this._mesh.geometry.indices=new Uint16Array(i),this._mesh.geometry.needsUpdate=!0},module.exports=LinesVisualization;

},{"../../common/geom/palette":315,"../../common/graphics/glsl":317,"../../common/graphics/mesh":319,"../../common/tween/tween":326,"../../common/util/number":328,"../../visualization":330,"./config":338}],340:[function(require,module,exports){
"use strict";const Manifest=[];Manifest.push({id:"rectangles",name:"Strokes",reactive:!1,Constructor:require("./rectangles/index")}),Manifest.push({id:"circles",name:"Spots",reactive:!1,Constructor:require("./circles/index")}),Manifest.push({id:"triangles",name:"Spikes",reactive:!1,Constructor:require("./triangles/index")}),Manifest.push({id:"dots_grid",name:"Circles",reactive:!1,Constructor:require("./grid/dots")}),Manifest.push({id:"triangles_grid",name:"Triangles",reactive:!1,Constructor:require("./grid/triangles")}),Manifest.push({id:"lines",name:"Lines",reactive:!1,Constructor:require("./lines/index")}),module.exports=Manifest;

},{"./circles/index":332,"./grid/dots":335,"./grid/triangles":337,"./lines/index":339,"./rectangles/index":343,"./triangles/index":348}],341:[function(require,module,exports){
"use strict";const ObjectPool=require("../../common/util/pool"),ArrayUtils=require("../../common/util/array"),Sprite=require("../../common/graphics/sprite"),Layout=require("./layout"),Shape=require("./shape"),Tween=require("../../common/tween/tween"),Enum=require("../../common/enum/enum"),LAYOUT_TYPES={};LAYOUT_TYPES[Enum.NORTH]=Enum.VERTICAL,LAYOUT_TYPES[Enum.SOUTH]=Enum.VERTICAL,LAYOUT_TYPES[Enum.EAST]=Enum.HORIZONTAL,LAYOUT_TYPES[Enum.WEST]=Enum.HORIZONTAL,LAYOUT_TYPES[Enum.NORTH_EAST]=Enum.DIAGONAL,LAYOUT_TYPES[Enum.NORTH_WEST]=Enum.DIAGONAL,LAYOUT_TYPES[Enum.SOUTH_EAST]=Enum.DIAGONAL,LAYOUT_TYPES[Enum.SOUTH_WEST]=Enum.DIAGONAL;const FLIP_X={};FLIP_X[Enum.NORTH_WEST]=!0,FLIP_X[Enum.SOUTH_WEST]=!0,FLIP_X[Enum.WEST]=!0;const FLIP_Y={};function Burst(t){Sprite.call(this),this.visualization=t,this._layout=new Layout(this),this._shapePool=new ObjectPool(10),this._shapePool.create=this._createShape.bind(this)}FLIP_Y[Enum.SOUTH_EAST]=!0,FLIP_Y[Enum.SOUTH_WEST]=!0,FLIP_Y[Enum.SOUTH]=!0,Burst.prototype=Object.create(Sprite.prototype),Burst.prototype.setup=function(t,e){this.clear(),this.direction=t,this.color=e,this._flipX=!!FLIP_X[t],this._flipY=!!FLIP_Y[t],this._layout.apply(LAYOUT_TYPES[t]),this.setSize(this.visualization.width,this.visualization.height)},Burst.prototype.addShape=function(){const t=this._shapePool.next();return t.color=this.color,t.reset(),t.randomize(),this.addChild(t),t},Burst.prototype.tick=function(t){for(let e=0,i=this.children.length;e<i;e++)this.children[e].tick(t)},Burst.prototype.setSize=function(t,e){this.scaleX=this._flipX?-1:1,this.scaleY=this._flipY?-1:1,this.x=t*(this._flipX?1:0),this.y=e*(this._flipY?1:0);const i=Math.max(t,e);this.children.forEach(function(r){r.x=r.xNorm*t,r.y=r.yNorm*e,r.width=r.widthNorm*i,r.height=r.heightNorm*i,r.appear.x=r.appear.xNorm*t,r.appear.y=r.appear.yNorm*e,r.disappear.x=r.disappear.xNorm*t,r.disappear.y=r.disappear.yNorm*e})},Burst.prototype.appear=function(t){const e=this._createStaggerArray(),i=.15*t,r=Tween.Easing.Quint.out;for(let o,n=0,s=this.children.length;n<s;n++)o=this.children[n],Tween.from(o,o.appear,t,e[n]*i,r)},Burst.prototype.disappear=function(t){const e=Tween.Easing.Quint.inOut;for(let i,r=0,o=this.children.length;r<o;r++)i=this.children[r],Tween.to(i,i.disappear,t,e)},Burst.prototype.clear=function(){let t;for(;this.children.length;)t=this.removeChildAt(0),this._shapePool.add(t),Tween.destroyAll(t)},Burst.prototype._createShape=function(){return new Shape},Burst.prototype._createStaggerArray=function(){const t=this.children.length,e=[];for(let i=0;i<t;i++)e.push(i/t);return ArrayUtils.shuffle(e)},module.exports=Burst;

},{"../../common/enum/enum":311,"../../common/graphics/sprite":322,"../../common/tween/tween":326,"../../common/util/array":327,"../../common/util/pool":329,"./layout":344,"./shape":345}],342:[function(require,module,exports){
"use strict";const Enum=require("../../common/enum/enum"),Config={usePalette:!0,burstInterval:22.5,burstDirections:[Enum.NORTH,Enum.NORTH_EAST,Enum.EAST,Enum.SOUTH_EAST,Enum.SOUTH,Enum.SOUTH_WEST,Enum.WEST,Enum.NORTH_WEST],appearDelay:2.5,appearDuration:7.5,disappearDuration:5.5,backgroundColorChangeDuration:1.5,minRotationFrequency:.05,maxRotationFrequency:.35,minScaleFrequency:.1,maxScaleFrequency:.35,minRotationAmplitude:.03,maxRotationAmplitude:.08,minScaleAmplitude:.05,maxScaleAmplitude:.2};module.exports=Config;

},{"../../common/enum/enum":311}],343:[function(require,module,exports){
"use strict";const Visualization=require("../../visualization"),ArrayUtils=require("../../common/util/array"),ObjectPool=require("../../common/util/pool"),Palette=require("../../common/geom/palette"),Tween=require("../../common/tween/tween"),Config=require("./config"),Burst=require("./burst");function Rectangles(){Visualization.call(this),this._directionQueue=[],this._transitioning=!1,this._currentBurst=null,this._generation=0,this._countdown=0,this._burstPool=new ObjectPool(10),this._burstPool.create=this._createBurst.bind(this)}Rectangles.prototype=Object.create(Visualization.prototype),Rectangles.prototype.setup=function(){Visualization.prototype.setup.call(this)},Rectangles.prototype.tick=function(t){Visualization.prototype.tick.call(this,t),this._countdown-=t,this._countdown<=0&&(this._countdown=Config.burstInterval,this._next());for(let e=0,i=this.scene.children.length;e<i;e++)this.scene.children[e].tick(t)},Rectangles.prototype.setSize=function(t,e){Visualization.prototype.setSize.call(this,t,e);for(let i=0,n=this.scene.children.length;i<n;i++)this.scene.children[i].setSize(t,e)},Rectangles.prototype.destroy=function(){Visualization.prototype.destroy.call(this)},Rectangles.prototype._next=function(){if(!this._transitioning){const t=!!this._currentBurst,e=this._getNextDirection(),i=this._burstPool.next();if(t){const t=this._currentBurst;t.disappear(Config.disappearDuration),this.schedule(()=>{this.scene.removeChild(t),this._burstPool.add(t)},Config.disappearDuration)}this.schedule(()=>{this._transitioning=!1,i.setup(e,Palette.secondary),i.appear(Config.appearDuration),this.scene.addChild(i),t&&this._swapColors()},t?Config.appearDelay:0),this._transitioning=!0,this._currentBurst=i,this._generation++}},Rectangles.prototype._createBurst=function(){return new Burst(this)},Rectangles.prototype._getNextDirection=function(){if(!this._directionQueue.length){if(this._directionQueue=Config.burstDirections.concat(),this._currentDirection){const t=this._directionQueue.indexOf(this._currentDirection);-1!==t&&this._directionQueue.splice(t,1)}ArrayUtils.shuffle(this._directionQueue)}return this._currentDirection=this._directionQueue.shift(),this._currentDirection},Rectangles.prototype._swapColors=function(){Tween.to(Palette.primary,{r:Palette.secondary.r,g:Palette.secondary.g,b:Palette.secondary.b},Config.backgroundColorChangeDuration,Tween.Easing.Quint.inOut),Tween.to(Palette.secondary,{r:Palette.primary.r,g:Palette.primary.g,b:Palette.primary.b},Config.backgroundColorChangeDuration,Tween.Easing.Quint.inOut)},module.exports=Rectangles;

},{"../../common/geom/palette":315,"../../common/tween/tween":326,"../../common/util/array":327,"../../common/util/pool":329,"../../visualization":330,"./burst":341,"./config":342}],344:[function(require,module,exports){
"use strict";const ArrayUtils=require("../../common/util/array"),Sprite=require("../../common/graphics/sprite"),Random=require("../../common/math/random"),Enum=require("../../common/enum/enum"),DISAPPEAR_SCALE=10,DISAPPEAR_RATIO=3;function Layout(a){this.burst=a}Layout.prototype=Object.create(Sprite.prototype),Layout.prototype.apply=function(a){switch(a){case Enum.HORIZONTAL:this._layoutRegular(!1);break;case Enum.VERTICAL:this._layoutRegular(!0);break;default:this._layoutDiagonal()}this._applyScaleCurve(),this._snapshotValues()},Layout.prototype._layoutRegular=function(a){const o=Random.int(3,5),t=Random.float(.45,.55),r=a?Random.float(1.5,3.3):Random.float(1.2,2.2),e=this._generateSizeArray(o,.5,1);let l,n,m;const u=[],d=a?Random.float(.3,.7):Random.float(.4,.6),i=.5*(.5-d);for(let h,s=0;s<o;s++)h=this.burst.addShape(),u.push(h),h.widthNorm=e[s]*t,h.heightNorm=Random.bool()?Random.float(.8,1.2):1,l?(n=a?l.xNorm+l.widthNorm/2+h.widthNorm/2:l.yNorm+l.widthNorm/2+h.widthNorm/2,Random.bool()&&(l.widthNorm*=Random.float(.9,1.5))):n=d-t/2+h.widthNorm/2,m=Random.float(.25),h.xNorm=a?n:m,h.yNorm=a?1-m:n,h.rotation=(a?0:Math.PI/2)+i+(a?Math.atan2(d-h.xNorm,h.yNorm-r):Math.atan2(d-h.yNorm,h.xNorm-r)),l=h,h.appear={defaultScaleX:.75,defaultScaleY:0,xNorm:a?h.xNorm:-.5,yNorm:a?1.5:h.yNorm},h.disappear={defaultScaleX:.75,defaultScaleY:0,xNorm:a?h.xNorm:-.5,yNorm:a?1.5:h.yNorm}},Layout.prototype._layoutDiagonal=function(){const a=Random.int(3,5),o=this._generateSizeArray(a,.5,1),t=Random.float(.31,.38),r=a/2;for(let e,l,n=0;n<a;n++)l=this.burst.addShape(),e=Math.abs(r-n-.5)/r,l.xNorm=n<r?0:e*t,l.yNorm=n<r?1-e*t:1,l.rotation=Math.PI/2+Math.atan2(1.4-l.yNorm,-.4-l.xNorm),l.widthNorm=t/r*(o[n]*a)*(Random.bool()?Random.float(.5,1):1),l.heightNorm=2*Math.sqrt(Math.pow(.5-l.xNorm,2)+Math.pow(.5-l.yNorm,2))*(Random.bool()?Random.float(1,1.25):1),l.appear={defaultScaleX:.75,defaultScaleY:0},l.disappear={defaultScaleX:30,defaultScaleY:10},l.appear={defaultScaleX:.75,defaultScaleY:0,xNorm:-.5,yNorm:1.5},l.disappear={defaultScaleX:.75,defaultScaleY:0,xNorm:-.5,yNorm:1.5}},Layout.prototype._applyScaleCurve=function(){const a=Random.float(1.5,1.85),o=Random.float(1.5,1.85),t=Random.float(Math.PI),r=Random.float(Math.PI),e=this.burst.children.length,l=1/(e-1);for(let n,m,u,d,i=0;i<e;i++)d=this.burst.children[i],Random.bool(.5)&&(d.widthNorm*=Random.float(.85,1)),n=i*l+Random.float(-1,1)*l,m=.5+Math.sin(r+n*Math.PI*o)/2,u=.5+Math.sin(t+n*Math.PI*a)/2,d.defaultScaleX=.6+.25*m,d.defaultScaleY=.4+1.15*u},Layout.prototype._snapshotValues=function(){for(let a=0,o=this.burst.children.length;a<o;a++)this.burst.children[a].snapshotValues()},Layout.prototype._generateSizeArray=function(a,o,t){let r=0;const e=[];let l,n;for(n=0;n<a;n++)r+=l=(n+1)*Random.float(o,t),e.push(l);for(n=0;n<a;n++)e[n]/=r;return ArrayUtils.shuffle(e)},module.exports=Layout;

},{"../../common/enum/enum":311,"../../common/graphics/sprite":322,"../../common/math/random":324,"../../common/util/array":327}],345:[function(require,module,exports){
"use strict";const Polygon=require("../../common/geom/polygon"),Sprite=require("../../common/graphics/sprite"),Random=require("../../common/math/random"),Config=require("./config");function Shape(){Sprite.call(this,Polygon.Square),this.snapshotValues(),this.randomize()}Shape.prototype=Object.create(Sprite.prototype),Shape.prototype.randomize=function(){this.rotationPhase=Random.float(-Math.PI,Math.PI),this.scaleXPhase=Random.float(-Math.PI,Math.PI),this.scaleYPhase=Random.float(-Math.PI,Math.PI),this.rotationFreq=Random.float(Config.minRotationFrequency,Config.maxRotationFrequency),this.scaleXFreq=Random.float(Config.minScaleFrequency,Config.maxScaleFrequency),this.scaleYFreq=Random.float(Config.minScaleFrequency,Config.maxScaleFrequency),this.rotationAmp=Random.float(Config.minRotationAmplitude,Config.maxRotationAmplitude),this.scaleXAmp=Random.float(Config.minScaleAmplitude,Config.maxScaleAmplitude),this.scaleYAmp=Random.float(Config.minScaleAmplitude,Config.maxScaleAmplitude)},Shape.prototype.snapshotValues=function(){this.defaultX=this.x,this.defaultY=this.y,this.defaultScaleX=this.scaleX,this.defaultScaleY=this.scaleY,this.defaultRotation=this.rotation},Shape.prototype.tick=function(t){this.rotation=this.defaultRotation,this.scaleX=this.defaultScaleX,this.scaleY=this.defaultScaleY,this.rotationPhase+=t*this.rotationFreq,this.scaleXPhase+=t*this.scaleXFreq,this.scaleYPhase+=t*this.rotationFreq,this.rotation=this.defaultRotation+Math.sin(this.rotationPhase)*this.rotationAmp,this.scaleX=this.defaultScaleX+Math.sin(this.scaleXPhase)*this.scaleXAmp*.6,this.scaleY=this.defaultScaleY+Math.sin(this.scaleYPhase)*this.scaleYAmp},Shape.prototype.reset=function(){this.x=0,this.y=0,this.scaleX=1,this.scaleY=1,this.rotation=0},module.exports=Shape;

},{"../../common/geom/polygon":316,"../../common/graphics/sprite":322,"../../common/math/random":324,"./config":342}],346:[function(require,module,exports){
"use strict";const ObjectPool=require("../../common/util/pool"),ArrayUtils=require("../../common/util/array"),Sprite=require("../../common/graphics/sprite"),Layout=require("./layout"),Shape=require("./shape"),Tween=require("../../common/tween/tween"),Enum=require("../../common/enum/enum"),LAYOUT_TYPES={};LAYOUT_TYPES[Enum.NORTH]=Enum.VERTICAL,LAYOUT_TYPES[Enum.SOUTH]=Enum.VERTICAL,LAYOUT_TYPES[Enum.EAST]=Enum.HORIZONTAL,LAYOUT_TYPES[Enum.WEST]=Enum.HORIZONTAL,LAYOUT_TYPES[Enum.NORTH_EAST]=Enum.DIAGONAL,LAYOUT_TYPES[Enum.NORTH_WEST]=Enum.DIAGONAL,LAYOUT_TYPES[Enum.SOUTH_EAST]=Enum.DIAGONAL,LAYOUT_TYPES[Enum.SOUTH_WEST]=Enum.DIAGONAL;const FLIP_X={};FLIP_X[Enum.NORTH_WEST]=!0,FLIP_X[Enum.SOUTH_WEST]=!0,FLIP_X[Enum.WEST]=!0;const FLIP_Y={};function Burst(t){Sprite.call(this),this.visualization=t,this._layout=new Layout(this),this._shapePool=new ObjectPool(10),this._shapePool.create=this._createShape.bind(this)}FLIP_Y[Enum.SOUTH_EAST]=!0,FLIP_Y[Enum.SOUTH_WEST]=!0,FLIP_Y[Enum.SOUTH]=!0,Burst.prototype=Object.create(Sprite.prototype),Burst.prototype.setup=function(t,e){this.clear(),this.direction=t,this.color=e,this._flipX=!!FLIP_X[t],this._flipY=!!FLIP_Y[t],this._layout.apply(LAYOUT_TYPES[t]),this.setSize(this.visualization.width,this.visualization.height)},Burst.prototype.addShape=function(){const t=this._shapePool.next();return t.color=this.color,t.reset(),t.randomize(),this.addChild(t),t},Burst.prototype.tick=function(t){for(let e=0,i=this.children.length;e<i;e++)this.children[e].tick(t)},Burst.prototype.setSize=function(t,e){this.scaleX=t*(this._flipX?-1:1),this.scaleY=e*(this._flipY?-1:1),this.x=t*(this._flipX?1:0),this.y=e*(this._flipY?1:0),this.children.forEach(function(t){t.x=t.x})},Burst.prototype.appear=function(t){const e=this._createStaggerArray(),i=.15*t,n=Tween.Easing.Quint.out;for(let r,o=0,s=this.children.length;o<s;o++)r=this.children[o],Tween.from(r,r.appear,t,e[o]*i,n)},Burst.prototype.disappear=function(t){const e=Tween.Easing.Quint.inOut;for(let i,n=0,r=this.children.length;n<r;n++)i=this.children[n],Tween.to(i,i.disappear,t,e)},Burst.prototype.clear=function(){let t;for(;this.children.length;)t=this.removeChildAt(0),this._shapePool.add(t),Tween.destroyAll(t)},Burst.prototype._createShape=function(){return new Shape},Burst.prototype._createStaggerArray=function(){const t=this.children.length,e=[];for(let i=0;i<t;i++)e.push(i/t);return ArrayUtils.shuffle(e)},module.exports=Burst;

},{"../../common/enum/enum":311,"../../common/graphics/sprite":322,"../../common/tween/tween":326,"../../common/util/array":327,"../../common/util/pool":329,"./layout":349,"./shape":350}],347:[function(require,module,exports){
"use strict";const Enum=require("../../common/enum/enum"),Config={usePalette:!0,burstInterval:22.5,burstDirections:[Enum.NORTH,Enum.NORTH_EAST,Enum.EAST,Enum.SOUTH_EAST,Enum.SOUTH,Enum.SOUTH_WEST,Enum.WEST,Enum.NORTH_WEST],appearDelay:5.1,appearDuration:14,disappearDuration:15,minRotationFrequency:.1,maxRotationFrequency:.35,minScaleFrequency:.1,maxScaleFrequency:.35,minRotationAmplitude:.035,maxRotationAmplitude:.085,minScaleAmplitude:.05,maxScaleAmplitude:.35};module.exports=Config;

},{"../../common/enum/enum":311}],348:[function(require,module,exports){
"use strict";const Visualization=require("../../visualization"),ArrayUtils=require("../../common/util/array"),ObjectPool=require("../../common/util/pool"),Palette=require("../../common/geom/palette"),Config=require("./config"),Burst=require("./burst");function Triangles(){Visualization.call(this),this._directionQueue=[],this._transitioning=!1,this._currentBurst=null,this._generation=0,this._countdown=0,this._burstPool=new ObjectPool(10),this._burstPool.create=this._createBurst.bind(this)}Triangles.prototype=Object.create(Visualization.prototype),Triangles.prototype.setup=function(){Visualization.prototype.setup.call(this)},Triangles.prototype.tick=function(t){Visualization.prototype.tick.call(this,t),this._countdown-=t,this._countdown<=0&&(this._countdown=Config.burstInterval,this._next());for(let i=0,e=this.scene.children.length;i<e;i++)this.scene.children[i].tick(t)},Triangles.prototype.setSize=function(t,i){Visualization.prototype.setSize.call(this,t,i);for(let e=0,r=this.scene.children.length;e<r;e++)this.scene.children[e].setSize(t,i)},Triangles.prototype.destroy=function(){Visualization.prototype.destroy.call(this)},Triangles.prototype._next=function(){if(!this._transitioning){const t=Config.appearDuration*(this._currentBurst?1:.8),i=this._currentBurst?Config.appearDelay:0,e=this._getNextDirection(),r=this._getNextColor(),n=this._burstPool.next();if(this._currentBurst){const t=this._currentBurst;t.disappear(Config.disappearDuration),this.schedule(()=>{this.scene.backgroundColor=t.color,this.scene.removeChild(t),this._burstPool.add(t)},Config.disappearDuration)}this.schedule(()=>{this._transitioning=!1,n.setup(e,r),n.appear(t),this.scene.addChild(n)},i),this._transitioning=!0,this._currentBurst=n,this._generation++}},Triangles.prototype._createBurst=function(){return new Burst(this)},Triangles.prototype._getNextDirection=function(){if(!this._directionQueue.length){if(this._directionQueue=Config.burstDirections.concat(),this._currentDirection){const t=this._directionQueue.indexOf(this._currentDirection);-1!==t&&this._directionQueue.splice(t,1)}ArrayUtils.shuffle(this._directionQueue)}return this._currentDirection=this._directionQueue.shift(),this._currentDirection},Triangles.prototype._getNextColor=function(){return this._generation%2==0?Palette.secondary:Palette.primary},module.exports=Triangles;

},{"../../common/geom/palette":315,"../../common/util/array":327,"../../common/util/pool":329,"../../visualization":330,"./burst":346,"./config":347}],349:[function(require,module,exports){
"use strict";const Sprite=require("../../common/graphics/sprite"),Random=require("../../common/math/random"),Enum=require("../../common/enum/enum"),DISAPPEAR_SCALE=5,DISAPPEAR_RATIO=3;function Layout(t){this.burst=t}Layout.prototype=Object.create(Sprite.prototype),Layout.prototype.apply=function(t){switch(t){case Enum.HORIZONTAL:this._layoutRegular(!1);break;case Enum.VERTICAL:this._layoutRegular(!0);break;default:this._layoutDiagonal()}this._applyScaleCurve(),this._snapshotValues()},Layout.prototype._layoutRegular=function(t){const a=Random.int(3,5),o=Random.float(.55,.75),e=this._generateSizeArray(a,.2,1.2);let l,n,r;for(let u,i=0;i<a;i++)(u=this.burst.addShape()).width=e[i]*o*2,u.height=Random.float(1,1.25),n=l?(t?l.x:l.y)+(e[i-1]*o*2+u.width)/4:.5+u.width/4-o/2,r=Random.float(.25),u.x=t?n:r,u.y=t?1-r:n,t||(u.rotation=Math.PI/2),l=u,u.appear={defaultScaleX:.75,defaultScaleY:0,x:t?u.x:-.5,y:t?1.5:u.y},u.disappear={defaultScaleX:15,defaultScaleY:5,x:t?5*(u.x-.5):u.x,y:t?u.y:5*(u.y-.5)}},Layout.prototype._layoutDiagonal=function(){const t=Random.int(3,5),a=Random.float(.5,.6),o=t/2;for(let e,l,n=0;n<t;n++)l=this.burst.addShape(),e=Math.abs(o-n-.5)/o,l.x=n<o?0:e*a,l.y=n<o?1-e*a:1,l.rotation=Math.PI/2+Math.atan2(-1-l.y,2-l.x),l.width=a/o*2,l.height=2.5*Math.sqrt(Math.pow(.5-l.x,2)+Math.pow(.5-l.y,2)),l.appear={defaultScaleX:.75,defaultScaleY:0,x:-.5,y:1.5},l.disappear={defaultScaleX:15,defaultScaleY:5,x:n<o?l.x:5*l.x,y:n<o?1-e*a*5:l.y}},Layout.prototype._applyScaleCurve=function(){const t=Random.float(1.2,1.8),a=Random.float(1.2,1.8),o=Random.float(Math.PI),e=Random.float(Math.PI),l=this.burst.children.length,n=1/(l-1);for(let r,u,i,h,s=0;s<l;s++)h=this.burst.children[s],r=s*n+Random.float(-1,1)*n,u=.5+Math.sin(e+r*Math.PI*a)/2,i=.5+Math.sin(o+r*Math.PI*t)/2,h.defaultScaleX=.6+.45*u,h.defaultScaleY=.4+1.25*i},Layout.prototype._snapshotValues=function(){for(let t=0,a=this.burst.children.length;t<a;t++)this.burst.children[t].snapshotValues()},Layout.prototype._generateSizeArray=function(t,a,o){let e,l;const n=[];let r=0;for(e=0;e<t;e++)r+=l=Random.float(a,o),n.push(l);for(e=0;e<t;e++)n[e]/=r;return n},module.exports=Layout;

},{"../../common/enum/enum":311,"../../common/graphics/sprite":322,"../../common/math/random":324}],350:[function(require,module,exports){
"use strict";const Polygon=require("../../common/geom/polygon"),Sprite=require("../../common/graphics/sprite"),Random=require("../../common/math/random"),Config=require("./config");function Shape(){Sprite.call(this,Polygon.IsoscelesTriangle),this.snapshotValues(),this.randomize()}Shape.prototype=Object.create(Sprite.prototype),Shape.prototype.randomize=function(){this.rotationPhase=Random.float(-Math.PI,Math.PI),this.scaleXPhase=Random.float(-Math.PI,Math.PI),this.scaleYPhase=Random.float(-Math.PI,Math.PI),this.rotationFreq=Random.float(Config.minRotationFrequency,Config.maxRotationFrequency),this.scaleXFreq=Random.float(Config.minScaleFrequency,Config.maxScaleFrequency),this.scaleYFreq=Random.float(Config.minScaleFrequency,Config.maxScaleFrequency),this.rotationAmp=Random.float(Config.minRotationAmplitude,Config.maxRotationAmplitude),this.scaleXAmp=Random.float(Config.minScaleAmplitude,Config.maxScaleAmplitude),this.scaleYAmp=Random.float(Config.minScaleAmplitude,Config.maxScaleAmplitude)},Shape.prototype.snapshotValues=function(){this.defaultX=this.x,this.defaultY=this.y,this.defaultScaleX=this.scaleX,this.defaultScaleY=this.scaleY,this.defaultRotation=this.rotation},Shape.prototype.tick=function(t){this.rotationPhase+=t*this.rotationFreq,this.scaleXPhase+=t*this.scaleXFreq,this.scaleYPhase+=t*this.rotationFreq,this.rotation=this.defaultRotation+Math.sin(this.rotationPhase)*this.rotationAmp,this.scaleX=this.defaultScaleX+Math.sin(this.scaleXPhase)*this.scaleXAmp,this.scaleY=this.defaultScaleY+Math.sin(this.scaleYPhase)*this.scaleYAmp},Shape.prototype.reset=function(){this.x=0,this.y=0,this.scaleX=1,this.scaleY=1,this.rotation=0},module.exports=Shape;

},{"../../common/geom/polygon":316,"../../common/graphics/sprite":322,"../../common/math/random":324,"./config":347}],351:[function(require,module,exports){
"use strict";const eventDispatcher=require("../../../libs/event-dispatcher"),Visualizations=require("./visualization/visualizations/manifest"),Renderer=require("./visualization/common/graphics/renderer"),Analyzer=require("./visualization/common/audio/analyzer"),Palette=require("./visualization/common/geom/palette"),cosmos=require("../../cosmos-api").default,Tween=require("./visualization/common/tween/tween"),Utils=require("./utils"),Enum=require("./visualization/common/enum/enum"),FRAME_BUFFER_SIZE=300,MAX_FRAME_AVERAGE_MS=12,CACHE_EXPIRATION_SECONDS=7200;function VisualizationController(i){this.visualizations=Visualizations,this.container=i,this.running=!1,this._hasUpdatedColorPalette=!1,this._currentVisualizationId=null,this._queuedFetchAudioEvent=null,this._currentVisualization=null,this._audioDataCache=[],this._frameRequest=null,this._isReactive=!1,this._drawTrigger=0,this._drawRate=1,this._frameBuffer=[],this._analyzer=new Analyzer,this._renderer=new Renderer,this.container.appendChild(this._renderer.domElement),this._onAudioDataLoaded=this._onAudioDataLoaded.bind(this),this._onFetchAudioData=this._onFetchAudioData.bind(this),this._resize=this._resize.bind(this),this._tick=this._tick.bind(this),window.addEventListener("resize",this._resize),this._bindAnalyzerEvents(),this._resize()}VisualizationController.prototype.init=function(){eventDispatcher.addEventListener("fetchAudioData",this._onFetchAudioData)},VisualizationController.prototype.play=function(i){this._drawRate=!1===i?2:1,!this.running&&this._currentVisualizationId&&(this._lastTick=null,this.running=!0,this._tick())},VisualizationController.prototype.pause=function(){cancelAnimationFrame(this._frameRequest),this.running=!1},VisualizationController.prototype.stop=function(){cancelAnimationFrame(this._frameRequest),this.running=!1},VisualizationController.prototype.hide=function(){this.container.classList.add("vis-hidden")},VisualizationController.prototype.show=function(){this.container.classList.remove("vis-hidden")},VisualizationController.prototype.changeVisualization=function(i,t){let e;for(let n=0,o=this.visualizations.length;n<o;n++)if((e=this.visualizations[n]).id===i){if(this._currentVisualizationId!==i)return Tween.destroyAll(),this._currentVisualization&&this._currentVisualization.destroy(),this._currentVisualizationId=i,this._currentVisualization=new e.Constructor,this._isReactive=e.reactive,this._resize(),this._currentVisualization.setup(),this._isReactive&&this._queuedFetchAudioEvent&&(this._onFetchAudioData(this._queuedFetchAudioEvent),this._queuedFetchAudioEvent=null),void t(this._renderer.canRender());break}t(!1)},VisualizationController.prototype.updateAudioProperties=function(i){this._analyzer.setData(i)},VisualizationController.prototype.updateColorPalette=function(i){const t=this._hasUpdatedColorPalette?.8:0;Palette.transition(i,t,Tween.Easing.Sine.inOut),this._hasUpdatedColorPalette=!0},VisualizationController.prototype.updateTrackProgress=function(i){this._isReactive&&this._analyzer.setTimeMS(i)},VisualizationController.prototype._tick=function(){if(this.running){if(1===this._drawRate||0===this._drawTrigger){const i=performance.now(),t=(i-(this._lastTick||i))/1e3;if(this._lastTick=i,Tween.tick(t),this._currentVisualization&&(this._currentVisualization.tick(t),this._renderer.render(this._currentVisualization.scene)),this._frameBuffer.push(performance.now()-i),this._frameBuffer.length>300){this._frameBuffer.shift();const i=this._computeFrameAverage();if(i>12)return console.warn("Average frame time too high (%sms)",i.toFixed(3)),console.warn("Stopping visualization"),this.stop(),void this._renderer.domElement.remove()}}this._drawTrigger=(this._drawTrigger+1)%this._drawRate,this._frameRequest=requestAnimationFrame(this._tick)}},VisualizationController.prototype._resize=function(){const i=this.container.clientWidth,t=this.container.clientHeight;this._currentVisualization&&this._currentVisualization.setSize(i,t),this._renderer.setSize(i,t)},VisualizationController.prototype._computeFrameAverage=function(){const i=this._frameBuffer.length;let t=0;for(let e=0;e<i;e++)t+=this._frameBuffer[e];return t/i},VisualizationController.prototype._bindAnalyzerEvents=function(){this._analyzer.on(Enum.SEGMENT,this._onAudioEvent.bind(this,Enum.SEGMENT)),this._analyzer.on(Enum.SECTION,this._onAudioEvent.bind(this,Enum.SECTION)),this._analyzer.on(Enum.TATUM,this._onAudioEvent.bind(this,Enum.TATUM)),this._analyzer.on(Enum.BEAT,this._onAudioEvent.bind(this,Enum.BEAT)),this._analyzer.on(Enum.BAR,this._onAudioEvent.bind(this,Enum.BAR))},VisualizationController.prototype._addToCache=function(i,t){this._checkCache(i)||this._audioDataCache.push({createdAt:Date.now(),data:t,key:i})},VisualizationController.prototype._checkCache=function(i){for(let t,e=0,n=this._audioDataCache.length;e<n;e++)if((t=this._audioDataCache[e]).key===i)return t.data;return null},VisualizationController.prototype._cleanCache=function(){const i=Date.now()-72e5;for(let t,e=this._audioDataCache.length-1;e>=0;e--)(t=this._audioDataCache[e]).createdAt<i&&this._audioDataCache.splice(e,1)},VisualizationController.prototype._onFetchAudioData=function(i){if(!i||!i.params.uri)return;if(!this._isReactive)return void(this._queuedFetchAudioEvent=i);this._cleanCache();const t=i.params.uri,e=`hm://audio-attributes/v1/audio-analysis/${Utils.getTrackIdFromUri(t)}`,n=this._checkCache(e);n?this._onAudioDataLoaded(null,n):cosmos.resolver.get(e,this._onAudioDataLoaded)},VisualizationController.prototype._onAudioDataLoaded=function(i,t){if(500!==t._status)if(!i&&200===t._status&&t._body&&""!==t._body){const i=JSON.parse(t._body);this._addToCache(t._uri,t),this.updateAudioProperties(i)}else this.updateAudioProperties(null);else this.updateAudioProperties(null)},VisualizationController.prototype._onAudioEvent=function(i,t){this._currentVisualization&&this._currentVisualization.handleAudioEvent(i,t)},module.exports=VisualizationController;

},{"../../../libs/event-dispatcher":60,"../../cosmos-api":54,"./utils":309,"./visualization/common/audio/analyzer":310,"./visualization/common/enum/enum":311,"./visualization/common/geom/palette":315,"./visualization/common/graphics/renderer":320,"./visualization/common/tween/tween":326,"./visualization/visualizations/manifest":340}],352:[function(require,module,exports){
(function (Buffer){
/* jshint browserify: true */

/**
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  "License"); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 *
 */

'use strict';

/**
 * Shim entry point used when `avro` is `require`d from browserify.
 *
 * It doesn't expose any of the filesystem methods and patches a few others.
 *
 */

var Tap = require('../../lib/utils').Tap,
    schemas = require('../../lib/schemas'),
    deprecated = require('../deprecated/validator');


function parse(schema, opts) {
  var obj;
  if (typeof schema == 'string') {
    try {
      obj = JSON.parse(schema);
    } catch (err) {
      // Pass. No file reading from the browser.
    }
  }
  if (obj === undefined) {
    obj = schema;
  }
  return schemas.createType(obj, opts);
}

// No utf8 and binary functions on browserify's `Buffer`, we must patch in the
// generic slice and write equivalents.

Tap.prototype.readString = function () {
  var len = this.readLong();
  var pos = this.pos;
  var buf = this.buf;
  this.pos += len;
  if (this.pos > buf.length) {
    return;
  }
  return this.buf.slice(pos, pos + len).toString();
};

Tap.prototype.writeString = function (s) {
  var len = Buffer.byteLength(s);
  this.writeLong(len);
  var pos = this.pos;
  this.pos += len;
  if (this.pos > this.buf.length) {
    return;
  }
  this.buf.write(s, pos);
};

Tap.prototype.writeBinary = function (s, len) {
  var pos = this.pos;
  this.pos += len;
  if (this.pos > this.buf.length) {
    return;
  }
  this.buf.write(s, pos, len, 'binary');
};


module.exports = {
  parse: parse,
  types: schemas.types,
  Validator: deprecated.Validator,
  ProtocolValidator: deprecated.ProtocolValidator
};

}).call(this,require("buffer").Buffer)
},{"../../lib/schemas":355,"../../lib/utils":356,"../deprecated/validator":354,"buffer":358}],353:[function(require,module,exports){
/* jshint browserify: true */

/**
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  "License"); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 *
 */

'use strict';

/**
 * Shim to disable schema fingerprint computation.
 *
 */

function createHash() {
  throw new Error('fingerprinting not supported in the browser');
}


module.exports = {
  createHash: createHash
};

},{}],354:[function(require,module,exports){
// Licensed to the Apache Software Foundation (ASF) under one or more
// contributor license agreements.  See the NOTICE file distributed with
// this work for additional information regarding copyright ownership.
// The ASF licenses this file to You under the Apache License, Version 2.0
// (the "License"); you may not use this file except in compliance with
// the License.  You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

var _ = require("underscore"),
    util = require('util');

var WARNING = 'Validator API is deprecated. Please use the type API instead.';
Validator = util.deprecate(Validator, WARNING);
ProtocolValidator = util.deprecate(ProtocolValidator, WARNING);

var AvroSpec = {
  PrimitiveTypes: ['null', 'boolean', 'int', 'long', 'float', 'double', 'bytes', 'string'],
  ComplexTypes: ['record', 'enum', 'array', 'map', 'union', 'fixed']
};
AvroSpec.Types = AvroSpec.PrimitiveTypes.concat(AvroSpec.ComplexTypes);

var InvalidSchemaError = function(msg) { return new Error('InvalidSchemaError: ' + msg); };
var InvalidProtocolError = function(msg) { return new Error('InvalidProtocolError: ' + msg); };
var ValidationError = function(msg) { return new Error('ValidationError: ' + msg); };
var ProtocolValidationError = function(msg) { return new Error('ProtocolValidationError: ' + msg); };


function Record(name, namespace, fields) {
  function validateArgs(name, namespace, fields) {
    if (!_.isString(name)) {
      throw new InvalidSchemaError('Record name must be string');
    }

    if (!_.isNull(namespace) && !_.isUndefined(namespace) && !_.isString(namespace)) {
      throw new InvalidSchemaError('Record namespace must be string or null');
    }

    if (!_.isArray(fields)) {
      throw new InvalidSchemaError('Record name must be string');
    }
  }

  validateArgs(name, namespace, fields);

  this.name = name;
  this.namespace = namespace;
  this.fields = fields;
}

function makeFullyQualifiedTypeName(schema, namespace) {
  var typeName = null;
  if (_.isString(schema)) {
    typeName = schema;
  } else if (_.isObject(schema)) {
    if (_.isString(schema.namespace)) {
      namespace = schema.namespace;
    }
    if (_.isString(schema.name)) {
      typeName = schema.name;
    } else if (_.isString(schema.type)) {
      typeName = schema.type;
    }
  } else {
    throw new InvalidSchemaError('unable to determine fully qualified type name from schema ' + JSON.stringify(schema) + ' in namespace ' + namespace);
  }

  if (!_.isString(typeName)) {
    throw new InvalidSchemaError('unable to determine type name from schema ' + JSON.stringify(schema) + ' in namespace ' + namespace);
  }

  if (typeName.indexOf('.') !== -1) {
    return typeName;
  } else if (_.contains(AvroSpec.PrimitiveTypes, typeName)) {
    return typeName;
  } else if (_.isString(namespace)) {
    return namespace + '.' + typeName;
  } else {
    return typeName;
  }
}

function Union(typeSchemas, namespace) {
  this.branchNames = function() {
    return _.map(typeSchemas, function(typeSchema) { return makeFullyQualifiedTypeName(typeSchema, namespace); });
  };

  function validateArgs(typeSchemas) {
    if (!_.isArray(typeSchemas) || _.isEmpty(typeSchemas)) {
      throw new InvalidSchemaError('Union must have at least 1 branch');
    }
  }

  validateArgs(typeSchemas);

  this.typeSchemas = typeSchemas;
  this.namespace = namespace;
}

function Enum(symbols) {

  function validateArgs(symbols) {
    if (!_.isArray(symbols)) {
      throw new InvalidSchemaError('Enum must have array of symbols, got ' + JSON.stringify(symbols));
    }
    if (!_.all(symbols, function(symbol) { return _.isString(symbol); })) {
      throw new InvalidSchemaError('Enum symbols must be strings, got ' + JSON.stringify(symbols));
    }
  }

  validateArgs(symbols);

  this.symbols = symbols;
}

function AvroArray(itemSchema) {

  function validateArgs(itemSchema) {
    if (_.isNull(itemSchema) || _.isUndefined(itemSchema)) {
      throw new InvalidSchemaError('Array "items" schema should not be null or undefined');
    }
  }

  validateArgs(itemSchema);

  this.itemSchema = itemSchema;
}

function Map(valueSchema) {

  function validateArgs(valueSchema) {
    if (_.isNull(valueSchema) || _.isUndefined(valueSchema)) {
      throw new InvalidSchemaError('Map "values" schema should not be null or undefined');
    }
  }

  validateArgs(valueSchema);

  this.valueSchema = valueSchema;
}

function Field(name, schema) {
  function validateArgs(name, schema) {
    if (!_.isString(name)) {
      throw new InvalidSchemaError('Field name must be string');
    }
  }

  this.name = name;
  this.schema = schema;
}

function Primitive(type) {
  function validateArgs(type) {
    if (!_.isString(type)) {
      throw new InvalidSchemaError('Primitive type name must be a string');
    }

    if (!_.contains(AvroSpec.PrimitiveTypes, type)) {
      throw new InvalidSchemaError('Primitive type must be one of: ' + JSON.stringify(AvroSpec.PrimitiveTypes) + '; got ' + type);
    }
  }

  validateArgs(type);

  this.type = type;
}

function Validator(schema, namespace, namedTypes) {
  this.validate = function(obj) {
    return _validate(this.schema, obj);
  };

  var _validate = function(schema, obj) {
    if (schema instanceof Record) {
      return _validateRecord(schema, obj);
    } else if (schema instanceof Union) {
      return _validateUnion(schema, obj);
    } else if (schema instanceof Enum) {
      return _validateEnum(schema, obj);
    } else if (schema instanceof AvroArray) {
      return _validateArray(schema, obj);
    } else if (schema instanceof Map) {
      return _validateMap(schema, obj);
    } else if (schema instanceof Primitive) {
      return _validatePrimitive(schema, obj);
    } else {
      throw new InvalidSchemaError('validation not yet implemented: ' + JSON.stringify(schema));
    }
  };

  var _validateRecord = function(schema, obj) {
    if (!_.isObject(obj) || _.isArray(obj)) {
      throw new ValidationError('Expected record Javascript type to be non-array object, got ' + JSON.stringify(obj));
    }

    var schemaFieldNames = _.pluck(schema.fields, 'name').sort();
    var objFieldNames = _.keys(obj).sort();
    if (!_.isEqual(schemaFieldNames, objFieldNames)) {
      throw new ValidationError('Expected record fields ' + JSON.stringify(schemaFieldNames) + '; got ' + JSON.stringify(objFieldNames));
    }

    return _.all(schema.fields, function(field) {
      return _validate(field.schema, obj[field.name]);
    });
  };

  var _validateUnion = function(schema, obj) {
    if (_.isObject(obj)) {
      if (_.isArray(obj)) {
        throw new ValidationError('Expected union Javascript type to be non-array object (or null), got ' + JSON.stringify(obj));
      } else if (_.size(obj) !== 1) {
        throw new ValidationError('Expected union Javascript object to be object with exactly 1 key (or null), got ' + JSON.stringify(obj));
      } else {
        var unionBranch = _.keys(obj)[0];
        if (unionBranch === "") {
          throw new ValidationError('Expected union Javascript object to contain non-empty string branch, got ' + JSON.stringify(obj));
        }
        if (_.contains(schema.branchNames(), unionBranch)) {
          return true;
        } else {
          throw new ValidationError('Expected union branch to be one of ' + JSON.stringify(schema.branchNames()) + '; got ' + JSON.stringify(unionBranch));
        }
      }
    } else if (_.isNull(obj)) {
      if (_.contains(schema.branchNames(), 'null')) {
        return true;
      } else {
        throw new ValidationError('Expected union branch to be one of ' + JSON.stringify(schema.branchNames()) + '; got ' + JSON.stringify(obj));
      }
    } else {
      throw new ValidationError('Expected union Javascript object to be non-array object of size 1 or null, got ' + JSON.stringify(obj));
    }
  };

  var _validateEnum = function(schema, obj) {
    if (_.isString(obj)) {
      if (_.contains(schema.symbols, obj)) {
        return true;
      } else {
        throw new ValidationError('Expected enum value to be one of ' + JSON.stringify(schema.symbols) + '; got ' + JSON.stringify(obj));
      }
    } else {
      throw new ValidationError('Expected enum Javascript object to be string, got ' + JSON.stringify(obj));
    }
  };

  var _validateArray = function(schema, obj) {
    if (_.isArray(obj)) {
      return _.all(obj, function(member) { return _validate(schema.itemSchema, member); });
    } else {
      throw new ValidationError('Expected array Javascript object to be array, got ' + JSON.stringify(obj));
    }
  };

  var _validateMap = function(schema, obj) {
    if (_.isObject(obj) && !_.isArray(obj)) {
      return _.all(obj, function(value) { return _validate(schema.valueSchema, value); });
    } else if (_.isArray(obj)) {
      throw new ValidationError('Expected map Javascript object to be non-array object, got array ' + JSON.stringify(obj));
    } else {
      throw new ValidationError('Expected map Javascript object to be non-array object, got ' + JSON.stringify(obj));
    }
  };

  var _validatePrimitive = function(schema, obj) {
    switch (schema.type) {
      case 'null':
        if (_.isNull(obj) || _.isUndefined(obj)) {
          return true;
        } else {
          throw new ValidationError('Expected Javascript null or undefined for Avro null, got ' + JSON.stringify(obj));
        }
        break;
      case 'boolean':
        if (_.isBoolean(obj)) {
          return true;
        } else {
          throw new ValidationError('Expected Javascript boolean for Avro boolean, got ' + JSON.stringify(obj));
        }
        break;
      case 'int':
        if (_.isNumber(obj) && Math.floor(obj) === obj && Math.abs(obj) <= Math.pow(2, 31)) {
          return true;
        } else {
          throw new ValidationError('Expected Javascript int32 number for Avro int, got ' + JSON.stringify(obj));
        }
        break;
      case 'long':
        if (_.isNumber(obj) && Math.floor(obj) === obj && Math.abs(obj) <= Math.pow(2, 63)) {
          return true;
        } else {
          throw new ValidationError('Expected Javascript int64 number for Avro long, got ' + JSON.stringify(obj));
        }
        break;
      case 'float':
        if (_.isNumber(obj)) { // TODO: handle NaN?
          return true;
        } else {
          throw new ValidationError('Expected Javascript float number for Avro float, got ' + JSON.stringify(obj));
        }
        break;
      case 'double':
        if (_.isNumber(obj)) { // TODO: handle NaN?
          return true;
        } else {
          throw new ValidationError('Expected Javascript double number for Avro double, got ' + JSON.stringify(obj));
        }
        break;
      case 'bytes':
        throw new InvalidSchemaError('not yet implemented: ' + schema.type);
      case 'string':
        if (_.isString(obj)) { // TODO: handle NaN?
          return true;
        } else {
          throw new ValidationError('Expected Javascript string for Avro string, got ' + JSON.stringify(obj));
        }
        break;
      default:
        throw new InvalidSchemaError('unrecognized primitive type: ' + schema.type);
    }
  };

  // TODO: namespace handling is rudimentary. multiple namespaces within a certain nested schema definition
  // are probably buggy.
  var _namedTypes = namedTypes || {};
  var _saveNamedType = function(fullyQualifiedTypeName, schema) {
    if (_.has(_namedTypes, fullyQualifiedTypeName)) {
      if (!_.isEqual(_namedTypes[fullyQualifiedTypeName], schema)) {
        throw new InvalidSchemaError('conflicting definitions for type ' + fullyQualifiedTypeName + ': ' + JSON.stringify(_namedTypes[fullyQualifiedTypeName]) + ' and ' + JSON.stringify(schema));
      }
    } else {
      _namedTypes[fullyQualifiedTypeName] = schema;
    }
  };

  var _lookupTypeByFullyQualifiedName = function(fullyQualifiedTypeName) {
    if (_.has(_namedTypes, fullyQualifiedTypeName)) {
      return _namedTypes[fullyQualifiedTypeName];
    } else {
      return null;
    }
  };

  var _parseNamedType = function(schema, namespace) {
    if (_.contains(AvroSpec.PrimitiveTypes, schema)) {
      return new Primitive(schema);
    } else if (!_.isNull(_lookupTypeByFullyQualifiedName(makeFullyQualifiedTypeName(schema, namespace)))) {
      return _lookupTypeByFullyQualifiedName(makeFullyQualifiedTypeName(schema, namespace));
    } else {
      throw new InvalidSchemaError('unknown type name: ' + JSON.stringify(schema) + '; known type names are ' + JSON.stringify(_.keys(_namedTypes)));
    }
  };

  var _parseSchema = function(schema, parentSchema, namespace) {
    if (_.isNull(schema) || _.isUndefined(schema)) {
      throw new InvalidSchemaError('schema is null, in parentSchema: ' + JSON.stringify(parentSchema));
    } else if (_.isString(schema)) {
      return _parseNamedType(schema, namespace);
    } else if (_.isObject(schema) && !_.isArray(schema)) {
      if (schema.type === 'record') {
        var newRecord = new Record(schema.name, schema.namespace, _.map(schema.fields, function(field) {
          return new Field(field.name, _parseSchema(field.type, schema, schema.namespace || namespace));
        }));
        _saveNamedType(makeFullyQualifiedTypeName(schema, namespace), newRecord);
        return newRecord;
      } else if (schema.type === 'enum') {
        if (_.has(schema, 'symbols')) {
          var newEnum = new Enum(schema.symbols);
          _saveNamedType(makeFullyQualifiedTypeName(schema, namespace), newEnum);
          return newEnum;
        } else {
          throw new InvalidSchemaError('enum must specify symbols, got ' + JSON.stringify(schema));
        }
      } else if (schema.type === 'array') {
        if (_.has(schema, 'items')) {
          return new AvroArray(_parseSchema(schema.items, schema, namespace));
        } else {
          throw new InvalidSchemaError('array must specify "items" schema, got ' + JSON.stringify(schema));
        }
      } else if (schema.type === 'map') {
        if (_.has(schema, 'values')) {
          return new Map(_parseSchema(schema.values, schema, namespace));
        } else {
          throw new InvalidSchemaError('map must specify "values" schema, got ' + JSON.stringify(schema));
        }
      } else if (_.has(schema, 'type') && _.contains(AvroSpec.PrimitiveTypes, schema.type)) {
        return _parseNamedType(schema.type, namespace);
      } else {
        throw new InvalidSchemaError('not yet implemented: ' + schema.type);
      }
    } else if (_.isArray(schema)) {
      if (_.isEmpty(schema)) {
        throw new InvalidSchemaError('unions must have at least 1 branch');
      }
      var branchTypes = _.map(schema, function(branchType) { return _parseSchema(branchType, schema, namespace); });
      return new Union(branchTypes, namespace);
    } else {
      throw new InvalidSchemaError('unexpected Javascript type for schema: ' + (typeof schema));
    }
  };

  this.rawSchema = schema;
  this.schema = _parseSchema(schema, null, namespace);
}

Validator.validate = function(schema, obj) {
  return (new Validator(schema)).validate(obj);
}

function ProtocolValidator(protocol) {
  this.validate = function(typeName, obj) {
    var fullyQualifiedTypeName = makeFullyQualifiedTypeName(typeName, protocol.namespace);
    if (!_.has(_typeSchemaValidators, fullyQualifiedTypeName)) {
      throw new ProtocolValidationError('Protocol does not contain definition for type ' + JSON.stringify(fullyQualifiedTypeName) + ' (fully qualified from input "' + typeName + '"); known types are ' + JSON.stringify(_.keys(_typeSchemaValidators)));
    }
    return _typeSchemaValidators[fullyQualifiedTypeName].validate(obj);
  };

  var _typeSchemaValidators = {};
  var _initSchemaValidators = function(protocol) {
    var namedTypes = {};
    if (!_.has(protocol, 'protocol') || !_.isString(protocol.protocol)) {
      throw new InvalidProtocolError('Protocol must contain a "protocol" attribute with a string value');
    }
    if (_.isArray(protocol.types)) {
      _.each(protocol.types, function(typeSchema) {
        var schemaValidator = new Validator(typeSchema, protocol.namespace, namedTypes);
        var fullyQualifiedTypeName = makeFullyQualifiedTypeName(typeSchema, protocol.namespace);
        _typeSchemaValidators[fullyQualifiedTypeName] = schemaValidator;
      });
    }
  };

  _initSchemaValidators(protocol);
}

ProtocolValidator.validate = function(protocol, typeName, obj) {
  return (new ProtocolValidator(protocol)).validate(typeName, obj);
};

if (typeof exports !== 'undefined') {
  exports['Validator'] = Validator;
  exports['ProtocolValidator'] = ProtocolValidator;
}

},{"underscore":451,"util":454}],355:[function(require,module,exports){
(function (Buffer){
/* jshint node: true */

/**
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  "License"); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 *
 */

'use strict';

var utils = require('./utils'),
    buffer = require('buffer'), // For `SlowBuffer`.
    util = require('util');

// Convenience imports.
var Tap = utils.Tap;
var f = util.format;

// All Avro types.
var TYPES = {
  'array': ArrayType,
  'boolean': BooleanType,
  'bytes': BytesType,
  'double': DoubleType,
  'enum': EnumType,
  'error': RecordType,
  'fixed': FixedType,
  'float': FloatType,
  'int': IntType,
  'long': LongType,
  'map': MapType,
  'null': NullType,
  'record': RecordType,
  'request': RecordType,
  'string': StringType,
  'union': UnionType
};

// Valid (field, type, and symbol) name regex.
var NAME_PATTERN = /^[A-Za-z_][A-Za-z0-9_]*$/;

// Random generator.
var RANDOM = new utils.Lcg();

// Encoding tap (shared for performance).
var TAP = new Tap(new buffer.SlowBuffer(1024));

// Path prefix for validity checks (shared for performance).
var PATH = [];

// Currently active logical type, used for name redirection.
var LOGICAL_TYPE = null;


/**
 * Schema parsing entry point.
 *
 * It isn't exposed directly but called from `parse` inside `index.js` (node)
 * or `avro.js` (browserify) which each add convenience functionality.
 *
 */
function createType(attrs, opts) {
  if (attrs instanceof Type) {
    return attrs;
  }

  opts = getOpts(attrs, opts);

  var type;
  if (typeof attrs == 'string') { // Type reference.
    if (opts.namespace && !~attrs.indexOf('.') && !isPrimitive(attrs)) {
      attrs = opts.namespace + '.' + attrs;
    }
    type = opts.registry[attrs];
    if (type) {
      // Type was already defined, return it.
      return type;
    }
    if (isPrimitive(attrs)) {
      // Reference to a primitive type. These are also defined names by default
      // so we create the appropriate type and it to the registry for future
      // reference.
      return opts.registry[attrs] = createType({type: attrs}, opts);
    }
    throw new Error(f('undefined type name: %s', attrs));
  }

  if (opts.typeHook && (type = opts.typeHook(attrs, opts))) {
    if (!(type instanceof Type)) {
      throw new Error(f('invalid typehook return value: %j', type));
    }
    return type;
  }

  if (attrs.logicalType && !LOGICAL_TYPE) {
    var DerivedType = opts.logicalTypes[attrs.logicalType];
    if (DerivedType) {
      var registry = {};
      Object.keys(opts.registry).forEach(function (key) {
        registry[key] = opts.registry[key];
      });
      try {
        return new DerivedType(attrs, opts);
      } catch (err) {
        if (opts.assertLogicalTypes) {
          throw err;
        }
        LOGICAL_TYPE = null;
        opts.registry = registry; // In case any names were registered.
      }
    }
  }

  if (attrs instanceof Array) { // Union.
    type = new UnionType(attrs, opts);
  } else { // New type definition.
    type = (function (typeName) {
      var Type = TYPES[typeName];
      if (Type === undefined) {
        throw new Error(f('unknown type: %j', typeName));
      }
      return new Type(attrs, opts);
    })(attrs.type);
  }
  return type;
}

/**
 * "Abstract" base Avro type class.
 *
 * This class' constructor will register any named types to support
 * recursive schemas.
 *
 * All type values are represented in memory similarly to their JSON
 * representation, except for `bytes` and `fixed` which are represented as
 * `Buffer`s. See individual subclasses for details.
 *
 */
function Type(registry) {
  var name = this._name;
  var type = LOGICAL_TYPE || this;
  LOGICAL_TYPE = null;

  if (registry === undefined || name === undefined) {
    return;
  }

  var prev = registry[name];
  if (prev !== undefined) {
    throw new Error(f('duplicate type name: %s', name));
  }
  registry[name] = type;
}

Type.__reset = function (size) { TAP.buf = new buffer.SlowBuffer(size); };

Type.prototype.createResolver = function (type, opts) {
  if (!(type instanceof Type)) {
    // More explicit error message than the "incompatible type" thrown
    // otherwise (especially because of the overridden `toJSON` method).
    throw new Error(f('not a type: %j', type));
  }

  if (type instanceof LogicalType && !(this instanceof LogicalType)) {
    // Trying to read a logical type as a built-in: unwrap the logical type.
    return this.createResolver(type._underlyingType, opts);
  }

  opts = opts || {};
  opts.registry = opts.registry || {};

  var resolver, key;
  if (this instanceof RecordType && type instanceof RecordType) {
    key = this._name + ':' + type._name; // ':' is illegal in Avro type names.
    resolver = opts.registry[key];
    if (resolver) {
      return resolver;
    }
  }

  resolver = new Resolver(this);
  if (key) { // Register resolver early for recursive schemas.
    opts.registry[key] = resolver;
  }

  if (type instanceof UnionType) {
    var resolvers = type._types.map(function (t) {
      return this.createResolver(t, opts);
    }, this);
    resolver._read = function (tap) {
      var index = tap.readLong();
      var resolver = resolvers[index];
      if (resolver === undefined) {
        throw new Error(f('invalid union index: %s', index));
      }
      return resolvers[index]._read(tap);
    };
  } else {
    this._updateResolver(resolver, type, opts);
  }

  if (!resolver._read) {
    throw new Error(f('cannot read %s as %s', type, this));
  }
  return resolver;
};

Type.prototype.decode = function (buf, pos, resolver) {
  var tap = new Tap(buf);
  tap.pos = pos | 0;
  var val = readValue(this, tap, resolver);
  if (!tap.isValid()) {
    return {value: undefined, offset: -1};
  }
  return {value: val, offset: tap.pos};
};

Type.prototype.encode = function (val, buf, pos) {
  var tap = new Tap(buf);
  tap.pos = pos | 0;
  this._write(tap, val);
  if (!tap.isValid()) {
    // Don't throw as there is no way to predict this. We also return the
    // number of missing bytes to ease resizing.
    return buf.length - tap.pos;
  }
  return tap.pos;
};

Type.prototype.fromBuffer = function (buf, resolver, noCheck) {
  var tap = new Tap(buf);
  var val = readValue(this, tap, resolver, noCheck);
  if (!tap.isValid()) {
    throw new Error('truncated buffer');
  }
  if (!noCheck && tap.pos < buf.length) {
    throw new Error('trailing data');
  }
  return val;
};

Type.prototype.toBuffer = function (val) {
  TAP.pos = 0;
  this._write(TAP, val);
  if (!TAP.isValid()) {
    Type.__reset(2 * TAP.pos);
    TAP.pos = 0;
    this._write(TAP, val);
  }
  var buf = new Buffer(TAP.pos);
  TAP.buf.copy(buf, 0, 0, TAP.pos);
  return buf;
};

Type.prototype.fromString = function (str) {
  return this._copy(JSON.parse(str), {coerce: 2});
};

Type.prototype.toString = function (val) {
  if (val === undefined) {
    // Consistent behavior with standard `toString` expectations.
    return this.getSchema(true);
  }
  return JSON.stringify(this._copy(val, {coerce: 3}));
};

Type.prototype.clone = function (val, opts) {
  if (opts) {
    opts = {
      coerce: !!opts.coerceBuffers | 0, // Coerce JSON to Buffer.
      fieldHook: opts.fieldHook,
      wrap: !!opts.wrapUnions | 0 // Wrap first match into union.
    };
  }
  return this._copy(val, opts);
};

Type.prototype.isValid = function (val, opts) {
  while (PATH.length) {
    // In case the previous `isValid` call didn't complete successfully (e.g.
    // if an exception was thrown, but then caught in client code), `PATH`
    // might be non-empty, we must manually clear it.
    PATH.pop();
  }
  return this._check(val, opts && opts.errorHook);
};

Type.prototype.compareBuffers = function (buf1, buf2) {
  return this._match(new Tap(buf1), new Tap(buf2));
};

Type.prototype.getName = function (noRef) {
  return noRef ? getTypeName(this) : this._name;
};

Type.prototype.getSchema = function (noDeref) {
  return stringify(this, noDeref);
};

Type.prototype.getFingerprint = function (algorithm) {
  return utils.getHash(this.getSchema(), algorithm);
};

Type.prototype.inspect = function () {
  if (this instanceof PrimitiveType) {
    return f('<%s>', this.constructor.name);
  } else {
    var obj = JSON.parse(this.getSchema(true)); // Slow, only for debugging.
    if (typeof obj == 'object') {
      obj.type = undefined; // Would be redundant with constructor name.
    }
    return f('<%s %j>', this.constructor.name, obj);
  }
};

Type.prototype._check = utils.abstractFunction;
Type.prototype._copy = utils.abstractFunction;
Type.prototype._match = utils.abstractFunction;
Type.prototype._read = utils.abstractFunction;
Type.prototype._skip = utils.abstractFunction;
Type.prototype._updateResolver = utils.abstractFunction;
Type.prototype._write = utils.abstractFunction;
Type.prototype.compare = utils.abstractFunction;
Type.prototype.random = utils.abstractFunction;

// Implementations.

/**
 * Base primitive Avro type.
 *
 * Most of the primitive types share the same cloning and resolution
 * mechanisms, provided by this class. This class also lets us conveniently
 * check whether a type is a primitive using `instanceof`.
 *
 */
function PrimitiveType() { Type.call(this); }
util.inherits(PrimitiveType, Type);
PrimitiveType.prototype._updateResolver = function (resolver, type) {
  if (type.constructor === this.constructor) {
    resolver._read = this._read;
  }
};
PrimitiveType.prototype._copy = function (val) {
  this._check(val, throwInvalidError);
  return val;
};
PrimitiveType.prototype.compare = utils.compare;

/**
 * Nulls.
 *
 */
function NullType() { PrimitiveType.call(this); }
util.inherits(NullType, PrimitiveType);
NullType.prototype._check = function (val, cb) {
  var b = val === null;
  if (!b && cb) {
    cb(PATH.slice(), val, this);
  }
  return b;
};
NullType.prototype._read = function () { return null; };
NullType.prototype._skip = function () {};
NullType.prototype._write = function (tap, val) {
  if (val !== null) {
    throwInvalidError(null, val, this);
  }
};
NullType.prototype._match = function () { return 0; };
NullType.prototype.compare = NullType.prototype._match;
NullType.prototype.random = NullType.prototype._read;
NullType.prototype.toJSON = function () { return 'null'; };

/**
 * Booleans.
 *
 */
function BooleanType() { PrimitiveType.call(this); }
util.inherits(BooleanType, PrimitiveType);
BooleanType.prototype._check = function (val, cb) {
  var b = typeof val == 'boolean';
  if (!b && cb) {
    cb(PATH.slice(), val, this);
  }
  return b;
};
BooleanType.prototype._read = function (tap) { return tap.readBoolean(); };
BooleanType.prototype._skip = function (tap) { tap.skipBoolean(); };
BooleanType.prototype._write = function (tap, val) {
  if (typeof val != 'boolean') {
    throwInvalidError(null, val, this);
  }
  tap.writeBoolean(val);
};
BooleanType.prototype._match = function (tap1, tap2) {
  return tap1.matchBoolean(tap2);
};
BooleanType.prototype.random = function () { return RANDOM.nextBoolean(); };
BooleanType.prototype.toJSON = function () { return 'boolean'; };

/**
 * Integers.
 *
 */
function IntType() { PrimitiveType.call(this); }
util.inherits(IntType, PrimitiveType);
IntType.prototype._check = function (val, cb) {
  var b = val === (val | 0);
  if (!b && cb) {
    cb(PATH.slice(), val, this);
  }
  return b;
};
IntType.prototype._read = function (tap) { return tap.readInt(); };
IntType.prototype._skip = function (tap) { tap.skipInt(); };
IntType.prototype._write = function (tap, val) {
  if (val !== (val | 0)) {
    throwInvalidError(null, val, this);
  }
  tap.writeInt(val);
};
IntType.prototype._match = function (tap1, tap2) {
  return tap1.matchInt(tap2);
};
IntType.prototype.random = function () { return RANDOM.nextInt(1000) | 0; };
IntType.prototype.toJSON = function () { return 'int'; };

/**
 * Longs.
 *
 * We can't capture all the range unfortunately since JavaScript represents all
 * numbers internally as `double`s, so the default implementation plays safe
 * and throws rather than potentially silently change the data. See `using` or
 * `AbstractLongType` below for a way to implement a custom long type.
 *
 */
function LongType() { PrimitiveType.call(this); }
util.inherits(LongType, PrimitiveType);
LongType.prototype._check = function (val, cb) {
  var b = typeof val == 'number' && val % 1 === 0 && isSafeLong(val);
  if (!b && cb) {
    cb(PATH.slice(), val, this);
  }
  return b;
};
LongType.prototype._read = function (tap) {
  var n = tap.readLong();
  if (!isSafeLong(n)) {
    throw new Error('potential precision loss');
  }
  return n;
};
LongType.prototype._skip = function (tap) { tap.skipLong(); };
LongType.prototype._write = function (tap, val) {
  if (typeof val != 'number' || val % 1 || !isSafeLong(val)) {
    throwInvalidError(null, val, this);
  }
  tap.writeLong(val);
};
LongType.prototype._match = function (tap1, tap2) {
  return tap1.matchLong(tap2);
};
LongType.prototype._updateResolver = function (resolver, type) {
  if (type instanceof LongType || type instanceof IntType) {
    resolver._read = type._read;
  }
};
LongType.prototype.random = function () { return RANDOM.nextInt(); };
LongType.prototype.toJSON = function () { return 'long'; };
LongType.using = function (methods, noUnpack) {
  methods = methods || {}; // Will give a more helpful error message.
  // We map some of the methods to a different name to be able to intercept
  // their input and output (otherwise we wouldn't be able to perform any
  // unpacking logic, and the type wouldn't work when nested).
  var mapping = {
    toBuffer: '_toBuffer',
    fromBuffer: '_fromBuffer',
    fromJSON: '_fromJSON',
    toJSON: '_toJSON',
    isValid: '_isValid',
    compare: 'compare'
  };
  var type = new AbstractLongType(noUnpack);
  Object.keys(mapping).forEach(function (name) {
    if (methods[name] === undefined) {
      throw new Error(f('missing method implementation: %s', name));
    }
    type[mapping[name]] = methods[name];
  });
  return type;
};

/**
 * Floats.
 *
 */
function FloatType() { PrimitiveType.call(this); }
util.inherits(FloatType, PrimitiveType);
FloatType.prototype._check = function (val, cb) {
  var b = typeof val == 'number';
  if (!b && cb) {
    cb(PATH.slice(), val, this);
  }
  return b;
};
FloatType.prototype._read = function (tap) { return tap.readFloat(); };
FloatType.prototype._skip = function (tap) { tap.skipFloat(); };
FloatType.prototype._write = function (tap, val) {
  if (typeof val != 'number') {
    throwInvalidError(null, val, this);
  }
  tap.writeFloat(val);
};
FloatType.prototype._match = function (tap1, tap2) {
  return tap1.matchFloat(tap2);
};
FloatType.prototype._updateResolver = function (resolver, type) {
  if (
    type instanceof FloatType ||
    type instanceof LongType ||
    type instanceof IntType
  ) {
    resolver._read = type._read;
  }
};
FloatType.prototype.random = function () { return RANDOM.nextFloat(1e3); };
FloatType.prototype.toJSON = function () { return 'float'; };

/**
 * Doubles.
 *
 */
function DoubleType() { PrimitiveType.call(this); }
util.inherits(DoubleType, PrimitiveType);
DoubleType.prototype._check = function (val, cb) {
  var b = typeof val == 'number';
  if (!b && cb) {
    cb(PATH.slice(), val, this);
  }
  return b;
};
DoubleType.prototype._read = function (tap) { return tap.readDouble(); };
DoubleType.prototype._skip = function (tap) { tap.skipDouble(); };
DoubleType.prototype._write = function (tap, val) {
  if (typeof val != 'number') {
    throwInvalidError(null, val, this);
  }
  tap.writeDouble(val);
};
DoubleType.prototype._match = function (tap1, tap2) {
  return tap1.matchDouble(tap2);
};
DoubleType.prototype._updateResolver = function (resolver, type) {
  if (
    type instanceof DoubleType ||
    type instanceof FloatType ||
    type instanceof LongType ||
    type instanceof IntType
  ) {
    resolver._read = type._read;
  }
};
DoubleType.prototype.random = function () { return RANDOM.nextFloat(); };
DoubleType.prototype.toJSON = function () { return 'double'; };

/**
 * Strings.
 *
 */
function StringType() { PrimitiveType.call(this); }
util.inherits(StringType, PrimitiveType);
StringType.prototype._check = function (val, cb) {
  var b = typeof val == 'string';
  if (!b && cb) {
    cb(PATH.slice(), val, this);
  }
  return b;
};
StringType.prototype._read = function (tap) { return tap.readString(); };
StringType.prototype._skip = function (tap) { tap.skipString(); };
StringType.prototype._write = function (tap, val) {
  if (typeof val != 'string') {
    throwInvalidError(null, val, this);
  }
  tap.writeString(val);
};
StringType.prototype._match = function (tap1, tap2) {
  return tap1.matchString(tap2);
};
StringType.prototype._updateResolver = function (resolver, type) {
  if (type instanceof StringType || type instanceof BytesType) {
    resolver._read = this._read;
  }
};
StringType.prototype.random = function () {
  return RANDOM.nextString(RANDOM.nextInt(32));
};
StringType.prototype.toJSON = function () { return 'string'; };

/**
 * Bytes.
 *
 * These are represented in memory as `Buffer`s rather than binary-encoded
 * strings. This is more efficient (when decoding/encoding from bytes, the
 * common use-case), idiomatic, and convenient.
 *
 * Note the coercion in `_copy`.
 *
 */
function BytesType() { PrimitiveType.call(this); }
util.inherits(BytesType, PrimitiveType);
BytesType.prototype._check = function (val, cb) {
  var b = Buffer.isBuffer(val);
  if (!b && cb) {
    cb(PATH.slice(), val, this);
  }
  return b;
};
BytesType.prototype._read = function (tap) { return tap.readBytes(); };
BytesType.prototype._skip = function (tap) { tap.skipBytes(); };
BytesType.prototype._write = function (tap, val) {
  if (!Buffer.isBuffer(val)) {
    throwInvalidError(null, val, this);
  }
  tap.writeBytes(val);
};
BytesType.prototype._match = function (tap1, tap2) {
  return tap1.matchBytes(tap2);
};
BytesType.prototype._updateResolver = StringType.prototype._updateResolver;
BytesType.prototype._copy = function (obj, opts) {
  var buf;
  switch ((opts && opts.coerce) | 0) {
    case 3: // Coerce buffers to strings.
      this._check(obj, throwInvalidError);
      return obj.toString('binary');
    case 2: // Coerce strings to buffers.
      if (typeof obj != 'string') {
        throw new Error(f('cannot coerce to buffer: %j', obj));
      }
      buf = new Buffer(obj, 'binary');
      this._check(buf, throwInvalidError);
      return buf;
    case 1: // Coerce buffer JSON representation to buffers.
      if (!obj || obj.type !== 'Buffer' || !(obj.data instanceof Array)) {
        throw new Error(f('cannot coerce to buffer: %j', obj));
      }
      buf = new Buffer(obj.data);
      this._check(buf, throwInvalidError);
      return buf;
    default: // Copy buffer.
      this._check(obj, throwInvalidError);
      return new Buffer(obj);
  }
};
BytesType.prototype.compare = Buffer.compare;
BytesType.prototype.random = function () {
  return RANDOM.nextBuffer(RANDOM.nextInt(32));
};
BytesType.prototype.toJSON = function () { return 'bytes'; };

/**
 * Avro unions.
 *
 * Unions are represented in memory similarly to their JSON representation
 * (i.e. inside an object with single key the name of the contained type).
 *
 * This is not ideal, but is the most efficient way to unambiguously support
 * all unions. Here are a few reasons why the wrapping object is necessary:
 *
 * + Unions with multiple number types would have undefined behavior, unless
 *   numbers are wrapped (either everywhere, leading to large performance and
 *   convenience costs; or only when necessary inside unions, making it hard to
 *   understand when numbers are wrapped or not).
 * + Fixed types would have to be wrapped to be distinguished from bytes.
 * + Using record's constructor names would work (after a slight change to use
 *   the fully qualified name), but would mean that generic objects could no
 *   longer be valid records (making it inconvenient to do simple things like
 *   creating new records).
 *
 * Lore: In the past (until d304cab), there used to be an "unwrapped union
 * type" which directly exposed its values, without the wrapping object
 * (similarly to Avro's python implementation). It was removed to keep all
 * representations consistent and make this library simpler to understand
 * (conversions, e.g. for schema evolution, between representations were
 * particularly confusing). Encoding was also much slower (worst case
 * complexity linear in the number of types in the union).
 *
 */
function UnionType(attrs, opts) {
  if (!(attrs instanceof Array)) {
    throw new Error(f('non-array union schema: %j', attrs));
  }
  if (!attrs.length) {
    throw new Error('empty union');
  }

  opts = getOpts(attrs, opts);
  Type.call(this);
  this._types = attrs.map(function (obj) { return createType(obj, opts); });

  this._indices = {};
  this._types.forEach(function (type, i) {
    if (type instanceof UnionType) {
      throw new Error('unions cannot be directly nested');
    }
    var name = type._name || getTypeName(type);
    if (this._indices[name] !== undefined) {
      throw new Error(f('duplicate union name: %j', name));
    }
    this._indices[name] = i;
  }, this);

  this._constructors = this._types.map(function (type) {
    // jshint -W054
    var name = type._name || getTypeName(type);
    if (name === 'null') {
      return null;
    }
    var body;
    if (~name.indexOf('.')) { // Qualified name.
      body = 'this[\'' + name + '\'] = val;';
    } else {
      body = 'this.' + name + ' = val;';
    }
    return new Function('val', body);
  });
}
util.inherits(UnionType, Type);

UnionType.prototype._check = function (val, cb) {
  var b = false;
  if (val === null) {
    // Shortcut type lookup in this case.
    b = this._indices['null'] !== undefined;
  } else if (typeof val == 'object') {
    var keys = Object.keys(val);
    if (keys.length === 1) {
      // We require a single key here to ensure that writes are correct and
      // efficient as soon as a record passes this check.
      var name = keys[0];
      var index = this._indices[name];
      if (index !== undefined) {
        PATH.push(name);
        b = this._types[index]._check(val[name], cb);
        PATH.pop();
        return b;
      }
    }
  }
  if (!b && cb) {
    cb(PATH.slice(), val, this);
  }
  return b;
};

UnionType.prototype._read = function (tap) {
  var index = tap.readLong();
  var Class = this._constructors[index];
  if (Class) {
    return new Class(this._types[index]._read(tap));
  } else if (Class === null) {
    return null;
  } else {
    throw new Error(f('invalid union index: %s', index));
  }
};

UnionType.prototype._skip = function (tap) {
  this._types[tap.readLong()]._skip(tap);
};

UnionType.prototype._write = function (tap, val) {
  var index, keys, name;
  if (val === null) {
    index = this._indices['null'];
    if (index === undefined) {
      throwInvalidError(null, val, this);
    }
    tap.writeLong(index);
  } else {
    keys = Object.keys(val);
    if (keys.length === 1) {
      name = keys[0];
      index = this._indices[name];
    }
    if (index === undefined) {
      throwInvalidError(null, val, this);
    }
    tap.writeLong(index);
    this._types[index]._write(tap, val[name]);
  }
};

UnionType.prototype._match = function (tap1, tap2) {
  var n1 = tap1.readLong();
  var n2 = tap2.readLong();
  if (n1 === n2) {
    return this._types[n1]._match(tap1, tap2);
  } else {
    return n1 < n2 ? -1 : 1;
  }
};

UnionType.prototype._updateResolver = function (resolver, type, opts) {
  // jshint -W083
  // (The loop exits after the first function is created.)
  var i, l, typeResolver, Class;
  for (i = 0, l = this._types.length; i < l; i++) {
    try {
      typeResolver = this._types[i].createResolver(type, opts);
    } catch (err) {
      continue;
    }
    Class = this._constructors[i];
    if (Class) {
      resolver._read = function (tap) {
        return new Class(typeResolver._read(tap));
      };
    } else {
      resolver._read = function () { return null; };
    }
    return;
  }
};

UnionType.prototype._copy = function (val, opts) {
  var wrap = opts && opts.wrap | 0;
  if (wrap === 2) {
    // Promote into first type (used for schema defaults).
    if (val === null && this._constructors[0] === null) {
      return null;
    }
    return new this._constructors[0](this._types[0]._copy(val, opts));
  }
  if (val === null && this._indices['null'] !== undefined) {
    return null;
  }

  var i, l, obj;
  if (typeof val == 'object') {
    var keys = Object.keys(val);
    if (keys.length === 1) {
      var name = keys[0];
      i = this._indices[name];
      if (i === undefined) {
        // We are a bit more flexible than in `_check` here since we have
        // to deal with other serializers being less strict, so we fall
        // back to looking up unqualified names.
        var j, type;
        for (j = 0, l = this._types.length; j < l; j++) {
          type = this._types[j];
          if (type._name && name === unqualify(type._name)) {
            i = j;
            break;
          }
        }
      }
      if (i !== undefined) {
        obj = this._types[i]._copy(val[name], opts);
      }
    }
  }
  if (wrap === 1 && obj === undefined) {
    // Try promoting into first match (convenience, slow).
    i = 0;
    l = this._types.length;
    while (i < l && obj === undefined) {
      try {
        obj = this._types[i]._copy(val, opts);
      } catch (err) {
        i++;
      }
    }
  }
  if (obj !== undefined) {
    return new this._constructors[i](obj);
  }
  throwInvalidError(null, val, this);
};

UnionType.prototype.compare = function (val1, val2) {
  var name1 = val1 === null ? 'null' : Object.keys(val1)[0];
  var name2 = val2 === null ? 'null' : Object.keys(val2)[0];
  var index = this._indices[name1];
  if (name1 === name2) {
    return name1 === 'null' ?
      0 :
      this._types[index].compare(val1[name1], val2[name1]);
  } else {
    return utils.compare(index, this._indices[name2]);
  }
};

UnionType.prototype.getTypes = function () { return this._types.slice(); };

UnionType.prototype.random = function () {
  var index = RANDOM.nextInt(this._types.length);
  var Class = this._constructors[index];
  if (!Class) {
    return null;
  }
  return new Class(this._types[index].random());
};

UnionType.prototype.toJSON = function () { return this._types; };

/**
 * Avro enum type.
 *
 * Represented as strings (with allowed values from the set of symbols). Using
 * integers would be a reasonable option, but the performance boost is arguably
 * offset by the legibility cost and the extra deviation from the JSON encoding
 * convention.
 *
 * An integer representation can still be used (e.g. for compatibility with
 * TypeScript `enum`s) by overriding the `EnumType` with a `LongType` (e.g. via
 * `parse`'s registry).
 *
 */
function EnumType(attrs, opts) {
  if (!(attrs.symbols instanceof Array) || !attrs.symbols.length) {
    throw new Error(f('invalid %j enum symbols: %j', attrs.name, attrs));
  }

  opts = getOpts(attrs, opts);
  var resolutions = resolveNames(attrs, opts.namespace);
  this._name = resolutions.name;
  this._symbols = attrs.symbols;
  this._aliases = resolutions.aliases;
  Type.call(this, opts.registry);

  this._indices = {};
  this._symbols.forEach(function (symbol, i) {
    if (!NAME_PATTERN.test(symbol)) {
      throw new Error(f('invalid %s symbol: %j', this, symbol));
    }
    if (this._indices[symbol] !== undefined) {
      throw new Error(f('duplicate %s symbol: %j', this, symbol));
    }
    this._indices[symbol] = i;
  }, this);
}
util.inherits(EnumType, Type);

EnumType.prototype._check = function (val, cb) {
  var b = this._indices[val] !== undefined;
  if (!b && cb) {
    cb(PATH.slice(), val, this);
  }
  return b;
};

EnumType.prototype._read = function (tap) {
  var index = tap.readLong();
  var symbol = this._symbols[index];
  if (symbol === undefined) {
    throw new Error(f('invalid %s enum index: %s', this._name, index));
  }
  return symbol;
};

EnumType.prototype._skip = function (tap) { tap.skipLong(); };

EnumType.prototype._write = function (tap, val) {
  var index = this._indices[val];
  if (index === undefined) {
    throwInvalidError(null, val, this);
  }
  tap.writeLong(index);
};

EnumType.prototype._match = function (tap1, tap2) {
  return tap1.matchLong(tap2);
};

EnumType.prototype.compare = function (val1, val2) {
  return utils.compare(this._indices[val1], this._indices[val2]);
};

EnumType.prototype._updateResolver = function (resolver, type) {
  var symbols = this._symbols;
  if (
    type instanceof EnumType &&
    ~getAliases(this).indexOf(type._name) &&
    type._symbols.every(function (s) { return ~symbols.indexOf(s); })
  ) {
    resolver._symbols = type._symbols;
    resolver._read = type._read;
  }
};

EnumType.prototype._copy = function (val) {
  this._check(val, throwInvalidError);
  return val;
};

EnumType.prototype.getAliases = function () { return this._aliases; };

EnumType.prototype.getSymbols = function () { return this._symbols.slice(); };

EnumType.prototype.random = function () {
  return RANDOM.choice(this._symbols);
};

EnumType.prototype.toJSON = function () {
  return {name: this._name, type: 'enum', symbols: this._symbols};
};

/**
 * Avro fixed type.
 *
 * Represented simply as a `Buffer`.
 *
 */
function FixedType(attrs, opts) {
  if (attrs.size !== (attrs.size | 0) || attrs.size < 1) {
    throw new Error(f('invalid %j fixed size: %j', attrs.name, attrs.size));
  }

  opts = getOpts(attrs, opts);
  var resolutions = resolveNames(attrs, opts.namespace);
  this._name = resolutions.name;
  this._size = attrs.size | 0;
  this._aliases = resolutions.aliases;
  Type.call(this, opts.registry);
}
util.inherits(FixedType, Type);

FixedType.prototype._check = function (val, cb) {
  var b = Buffer.isBuffer(val) && val.length === this._size;
  if (!b && cb) {
    cb(PATH.slice(), val, this);
  }
  return b;
};

FixedType.prototype._read = function (tap) {
  return tap.readFixed(this._size);
};

FixedType.prototype._skip = function (tap) {
  tap.skipFixed(this._size);
};

FixedType.prototype._write = function (tap, val) {
  if (!Buffer.isBuffer(val) || val.length !== this._size) {
    throwInvalidError(null, val, this);
  }
  tap.writeFixed(val, this._size);
};

FixedType.prototype._match = function (tap1, tap2) {
  return tap1.matchFixed(tap2, this._size);
};

FixedType.prototype.compare = Buffer.compare;

FixedType.prototype._updateResolver = function (resolver, type) {
  if (
    type instanceof FixedType &&
    this._size === type._size &&
    ~getAliases(this).indexOf(type._name)
  ) {
    resolver._size = this._size;
    resolver._read = this._read;
  }
};

FixedType.prototype._copy = BytesType.prototype._copy;

FixedType.prototype.getAliases = function () { return this._aliases; };

FixedType.prototype.getSize = function () { return this._size; };

FixedType.prototype.random = function () {
  return RANDOM.nextBuffer(this._size);
};

FixedType.prototype.toJSON = function () {
  return {name: this._name, type: 'fixed', size: this._size};
};

/**
 * Avro map.
 *
 * Represented as vanilla objects.
 *
 */
function MapType(attrs, opts) {
  if (!attrs.values) {
    throw new Error(f('missing map values: %j', attrs));
  }

  opts = getOpts(attrs, opts);
  Type.call(this);
  this._values = createType(attrs.values, opts);
}
util.inherits(MapType, Type);

MapType.prototype.getValuesType = function () { return this._values; };

MapType.prototype._check = function (val, cb) {
  if (!val || typeof val != 'object' || val instanceof Array) {
    if (cb) {
      cb(PATH.slice(), val, this);
    }
    return false;
  }

  var keys = Object.keys(val);
  var b = true;
  var i, l, j, key;
  if (cb) {
    // Slow path.
    j = PATH.length;
    PATH.push('');
    for (i = 0, l = keys.length; i < l; i++) {
      key = PATH[j] = keys[i];
      if (!this._values._check(val[key], cb)) {
        b = false;
      }
    }
    PATH.pop();
  } else {
    for (i = 0, l = keys.length; i < l; i++) {
      if (!this._values._check(val[keys[i]], cb)) {
        return false;
      }
    }
  }
  return b;
};

MapType.prototype._read = function (tap) {
  var values = this._values;
  var val = {};
  var n;
  while ((n = readArraySize(tap))) {
    while (n--) {
      var key = tap.readString();
      val[key] = values._read(tap);
    }
  }
  return val;
};

MapType.prototype._skip = function (tap) {
  var values = this._values;
  var len, n;
  while ((n = tap.readLong())) {
    if (n < 0) {
      len = tap.readLong();
      tap.pos += len;
    } else {
      while (n--) {
        tap.skipString();
        values._skip(tap);
      }
    }
  }
};

MapType.prototype._write = function (tap, val) {
  if (!val || typeof val != 'object' || val instanceof Array) {
    throwInvalidError(null, val, this);
  }

  var values = this._values;
  var keys = Object.keys(val);
  var n = keys.length;
  var i, key;
  if (n) {
    tap.writeLong(n);
    for (i = 0; i < n; i++) {
      key = keys[i];
      tap.writeString(key);
      values._write(tap, val[key]);
    }
  }
  tap.writeLong(0);
};

MapType.prototype._match = function () {
  throw new Error('maps cannot be compared');
};

MapType.prototype._updateResolver = function (resolver, type, opts) {
  if (type instanceof MapType) {
    resolver._values = this._values.createResolver(type._values, opts);
    resolver._read = this._read;
  }
};

MapType.prototype._copy = function (val, opts) {
  if (val && typeof val == 'object' && !(val instanceof Array)) {
    var values = this._values;
    var keys = Object.keys(val);
    var i, l, key;
    var copy = {};
    for (i = 0, l = keys.length; i < l; i++) {
      key = keys[i];
      copy[key] = values._copy(val[key], opts);
    }
    return copy;
  }
  throwInvalidError(null, val, this);
};

MapType.prototype.compare = MapType.prototype._match;

MapType.prototype.random = function () {
  var val = {};
  var i, l;
  for (i = 0, l = RANDOM.nextInt(10); i < l; i++) {
    val[RANDOM.nextString(RANDOM.nextInt(20))] = this._values.random();
  }
  return val;
};

MapType.prototype.toJSON = function () {
  return {type: 'map', values: this._values};
};

/**
 * Avro array.
 *
 * Represented as vanilla arrays.
 *
 */
function ArrayType(attrs, opts) {
  if (!attrs.items) {
    throw new Error(f('missing array items: %j', attrs));
  }

  opts = getOpts(attrs, opts);

  this._items = createType(attrs.items, opts);
  Type.call(this);
}
util.inherits(ArrayType, Type);

ArrayType.prototype._check = function (val, cb) {
  if (!(val instanceof Array)) {
    if (cb) {
      cb(PATH.slice(), val, this);
    }
    return false;
  }

  var b = true;
  var i, l, j;
  if (cb) {
    // Slow path.
    j = PATH.length;
    PATH.push('');
    for (i = 0, l = val.length; i < l; i++) {
      PATH[j] = '' + i;
      if (!this._items._check(val[i], cb)) {
        b = false;
      }
    }
    PATH.pop();
  } else {
    for (i = 0, l = val.length; i < l; i++) {
      if (!this._items._check(val[i], cb)) {
        return false;
      }
    }
  }
  return b;
};

ArrayType.prototype._read = function (tap) {
  var items = this._items;
  var val = [];
  var n;
  while ((n = tap.readLong())) {
    if (n < 0) {
      n = -n;
      tap.skipLong(); // Skip size.
    }
    while (n--) {
      val.push(items._read(tap));
    }
  }
  return val;
};

ArrayType.prototype._skip = function (tap) {
  var len, n;
  while ((n = tap.readLong())) {
    if (n < 0) {
      len = tap.readLong();
      tap.pos += len;
    } else {
      while (n--) {
        this._items._skip(tap);
      }
    }
  }
};

ArrayType.prototype._write = function (tap, val) {
  if (!(val instanceof Array)) {
    throwInvalidError(null, val, this);
  }

  var n = val.length;
  var i;
  if (n) {
    tap.writeLong(n);
    for (i = 0; i < n; i++) {
      this._items._write(tap, val[i]);
    }
  }
  tap.writeLong(0);
};

ArrayType.prototype._match = function (tap1, tap2) {
  var n1 = tap1.readLong();
  var n2 = tap2.readLong();
  var f;
  while (n1 && n2) {
    f = this._items._match(tap1, tap2);
    if (f) {
      return f;
    }
    if (!--n1) {
      n1 = readArraySize(tap1);
    }
    if (!--n2) {
      n2 = readArraySize(tap2);
    }
  }
  return utils.compare(n1, n2);
};

ArrayType.prototype._updateResolver = function (resolver, type, opts) {
  if (type instanceof ArrayType) {
    resolver._items = this._items.createResolver(type._items, opts);
    resolver._read = this._read;
  }
};

ArrayType.prototype._copy = function (val, opts) {
  if (!(val instanceof Array)) {
    throwInvalidError(null, val, this);
  }
  var items = [];
  var i, l;
  for (i = 0, l = val.length; i < l; i++) {
    items.push(this._items._copy(val[i], opts));
  }
  return items;
};

ArrayType.prototype.compare = function (val1, val2) {
  var n1 = val1.length;
  var n2 = val2.length;
  var i, l, f;
  for (i = 0, l = Math.min(n1, n2); i < l; i++) {
    if ((f = this._items.compare(val1[i], val2[i]))) {
      return f;
    }
  }
  return utils.compare(n1, n2);
};

ArrayType.prototype.getItemsType = function () { return this._items; };

ArrayType.prototype.random = function () {
  var arr = [];
  var i, l;
  for (i = 0, l = RANDOM.nextInt(10); i < l; i++) {
    arr.push(this._items.random());
  }
  return arr;
};

ArrayType.prototype.toJSON = function () {
  return {type: 'array', items: this._items};
};

/**
 * Avro record.
 *
 * Values are represented as instances of a programmatically generated
 * constructor (similar to a "specific record"), available via the
 * `getRecordConstructor` method. This "specific record class" gives
 * significant speedups over using generics objects.
 *
 * Note that vanilla objects are still accepted as valid as long as their
 * fields match (this makes it much more convenient to do simple things like
 * update nested records).
 *
 */
function RecordType(attrs, opts) {
  opts = getOpts(attrs, opts);

  var resolutions = resolveNames(attrs, opts.namespace);
  this._name = resolutions.name;
  this._aliases = resolutions.aliases;
  this._type = attrs.type;
  // Requests shouldn't be registered since their name is only a placeholder.
  Type.call(this, this._type === 'request' ? undefined : opts.registry);

  if (!(attrs.fields instanceof Array)) {
    throw new Error(f('non-array %s fields', this._name));
  }
  this._fields = attrs.fields.map(function (f) {
    return new Field(f, opts);
  });
  if (utils.hasDuplicates(attrs.fields, function (f) { return f.name; })) {
    throw new Error(f('duplicate %s field name', this._name));
  }

  var isError = attrs.type === 'error';
  this._constructor = this._createConstructor(isError);
  this._read = this._createReader();
  this._skip = this._createSkipper();
  this._write = this._createWriter();
  this._check = this._createChecker();
}
util.inherits(RecordType, Type);

RecordType.prototype._createConstructor = function (isError) {
  // jshint -W054
  var outerArgs = [];
  var innerArgs = [];
  var ds = []; // Defaults.
  var innerBody = isError ? '  Error.call(this);\n' : '';
  // Not calling `Error.captureStackTrace` because this wouldn't be compatible
  // with browsers other than Chrome.
  var i, l, field, name, getDefault;
  for (i = 0, l = this._fields.length; i < l; i++) {
    field = this._fields[i];
    getDefault = field.getDefault;
    name = field._name;
    innerArgs.push('v' + i);
    innerBody += '  ';
    if (getDefault() === undefined) {
      innerBody += 'this.' + name + ' = v' + i + ';\n';
    } else {
      innerBody += 'if (v' + i + ' === undefined) { ';
      innerBody += 'this.' + name + ' = d' + ds.length + '(); ';
      innerBody += '} else { this.' + name + ' = v' + i + '; }\n';
      outerArgs.push('d' + ds.length);
      ds.push(getDefault);
    }
  }
  var outerBody = 'return function ' + unqualify(this._name) + '(';
  outerBody += innerArgs.join() + ') {\n' + innerBody + '};';
  var Record = new Function(outerArgs.join(), outerBody).apply(undefined, ds);

  var self = this;
  Record.getType = function () { return self; };
  Record.prototype = {
    constructor: Record,
    $clone: function (opts) { return self.clone(this, opts); },
    $compare: function (val) { return self.compare(this, val); },
    $getType: Record.getType,
    $isValid: function (opts) { return self.isValid(this, opts); },
    $toBuffer: function () { return self.toBuffer(this); },
    $toString: function (noCheck) { return self.toString(this, noCheck); }
  };
  // The names of these properties added to the prototype are prefixed with `$`
  // because it is an invalid property name in Avro but not in JavaScript.
  // (This way we are guaranteed not to be stepped over!)
  if (isError) {
    util.inherits(Record, Error);
    // Not setting the name on the prototype to be consistent with how object
    // fields are mapped to (only if defined in the schema as a field).
  }

  return Record;
};

RecordType.prototype._createChecker = function () {
  // jshint -W054
  var names = ['t', 'P'];
  var values = [this, PATH];
  var body = 'return function check' + unqualify(this._name) + '(val, cb) {\n';
  body += '  if (val === null || typeof val != \'object\') {\n';
  body += '    if (cb) { cb(P.slice(), val, t); }\n';
  body += '    return false;\n';
  body += '  }\n';
  if (!this._fields.length) {
    // Special case, empty record. We handle this directly.
    body += '  return true;\n';
  } else {
    for (i = 0, l = this._fields.length; i < l; i++) {
      field = this._fields[i];
      names.push('t' + i);
      values.push(field._type);
      if (field.getDefault() !== undefined) {
        body += '  var v' + i + ' = val.' + field._name + ';\n';
      }
    }
    body += '  if (cb) {\n';
    body += '    var b = 1;\n';
    body += '    var j = P.length;\n';
    body += '    P.push(\'\');\n';
    var i, l, field;
    for (i = 0, l = this._fields.length; i < l; i++) {
      field = this._fields[i];
      body += '    P[j] = \'' + field._name + '\';\n';
      if (field.getDefault() === undefined) {
        body += '    b &= t' + i + '._check(val.' + field._name + ', cb);\n';
      } else {
        body += '    b &= v' + i + ' === undefined || ';
        body += 't' + i + '._check(v' + i + ', cb);\n';
      }
    }
    body += '    P.pop();\n';
    body += '    return !!b;\n';
    body += '  } else {\n    return (\n      ';
    body += this._fields.map(function (field, i) {
      if (field.getDefault() === undefined) {
        return 't' + i + '._check(val.' + field._name + ')';
      } else {
        return '(v' + i + ' === undefined || t' + i + '._check(v' + i + '))';
      }
    }).join(' &&\n      ');
    body += '\n    );\n  }\n';
  }
  body += '};';
  return new Function(names.join(), body).apply(undefined, values);
};

RecordType.prototype._createReader = function () {
  // jshint -W054
  var uname = unqualify(this._name);
  var names = [];
  var values = [this._constructor];
  var i, l;
  for (i = 0, l = this._fields.length; i < l; i++) {
    names.push('t' + i);
    values.push(this._fields[i]._type);
  }
  var body = 'return function read' + uname + '(tap) {\n';
  body += '  return new ' + uname + '(';
  body += names.map(function (t) { return t + '._read(tap)'; }).join();
  body += ');\n};';
  names.unshift(uname);
  // We can do this since the JS spec guarantees that function arguments are
  // evaluated from left to right.
  return new Function(names.join(), body).apply(undefined, values);
};

RecordType.prototype._createSkipper = function () {
  // jshint -W054
  var args = [];
  var body = 'return function skip' + unqualify(this._name) + '(tap) {\n';
  var values = [];
  var i, l;
  for (i = 0, l = this._fields.length; i < l; i++) {
    args.push('t' + i);
    values.push(this._fields[i]._type);
    body += '  t' + i + '._skip(tap);\n';
  }
  body += '}';
  return new Function(args.join(), body).apply(undefined, values);
};

RecordType.prototype._createWriter = function () {
  // jshint -W054
  // We still do default handling here, in case a normal JS object is passed.
  var args = [];
  var body = 'return function write' + unqualify(this._name) + '(tap, val) {\n';
  var values = [];
  var i, l, field, value;
  for (i = 0, l = this._fields.length; i < l; i++) {
    field = this._fields[i];
    args.push('t' + i);
    values.push(field._type);
    body += '  ';
    if (field.getDefault() === undefined) {
      body += 't' + i + '._write(tap, val.' + field._name + ');\n';
    } else {
      value = field._type.toBuffer(field.getDefault()).toString('binary');
      // Convert the default value to a binary string ahead of time. We aren't
      // converting it to a buffer to avoid retaining too much memory. If we
      // had our own buffer pool, this could be an idea in the future.
      args.push('d' + i);
      values.push(value);
      body += 'var v' + i + ' = val.' + field._name + '; ';
      body += 'if (v' + i + ' === undefined) { ';
      body += 'tap.writeBinary(d' + i + ', ' + value.length + ');';
      body += ' } else { t' + i + '._write(tap, v' + i + '); }\n';
    }
  }
  body += '}';
  return new Function(args.join(), body).apply(undefined, values);
};

RecordType.prototype._updateResolver = function (resolver, type, opts) {
  // jshint -W054
  if (!~getAliases(this).indexOf(type._name)) {
    throw new Error(f('no alias for %s in %s', type._name, this._name));
  }

  var rFields = this._fields;
  var wFields = type._fields;
  var wFieldsMap = utils.toMap(wFields, function (f) { return f._name; });

  var innerArgs = []; // Arguments for reader constructor.
  var resolvers = {}; // Resolvers keyed by writer field name.
  var i, j, field, name, names, matches;
  for (i = 0; i < rFields.length; i++) {
    field = rFields[i];
    names = getAliases(field);
    matches = [];
    for (j = 0; j < names.length; j++) {
      name = names[j];
      if (wFieldsMap[name]) {
        matches.push(name);
      }
    }
    if (matches.length > 1) {
      throw new Error(f('multiple matches for %s', field.name));
    }
    if (!matches.length) {
      if (field.getDefault() === undefined) {
        throw new Error(f('no match for default-less %s', field.name));
      }
      innerArgs.push('undefined');
    } else {
      name = matches[0];
      resolvers[name] = {
        resolver: field._type.createResolver(wFieldsMap[name]._type, opts),
        name: field._name // Reader field name.
      };
      innerArgs.push(field._name);
    }
  }

  // See if we can add a bypass for unused fields at the end of the record.
  var lazyIndex = -1;
  i = wFields.length;
  while (i && resolvers[wFields[--i]._name] === undefined) {
    lazyIndex = i;
  }

  var uname = unqualify(this._name);
  var args = [uname];
  var values = [this._constructor];
  var body = '  return function read' + uname + '(tap,lazy) {\n';
  for (i = 0; i < wFields.length; i++) {
    if (i === lazyIndex) {
      body += '  if (!lazy) {\n';
    }
    field = type._fields[i];
    name = field._name;
    body += (~lazyIndex && i >= lazyIndex) ? '    ' : '  ';
    if (resolvers[name] === undefined) {
      args.push('t' + i);
      values.push(field._type);
      body += 't' + i + '._skip(tap);\n';
    } else {
      args.push('t' + i);
      values.push(resolvers[name].resolver);
      body += 'var ' + resolvers[name].name + ' = ';
      body += 't' + i + '._read(tap);\n';
    }
  }
  if (~lazyIndex) {
    body += '  }\n';
  }
  body +=  '  return new ' + uname + '(' + innerArgs.join() + ');\n};';

  resolver._read = new Function(args.join(), body).apply(undefined, values);
};

RecordType.prototype._match = function (tap1, tap2) {
  var fields = this._fields;
  var i, l, field, order, type;
  for (i = 0, l = fields.length; i < l; i++) {
    field = fields[i];
    order = field._order;
    type = field._type;
    if (order) {
      order *= type._match(tap1, tap2);
      if (order) {
        return order;
      }
    } else {
      type._skip(tap1);
      type._skip(tap2);
    }
  }
  return 0;
};

RecordType.prototype._copy = function (val, opts) {
  // jshint -W058
  var hook = opts && opts.fieldHook;
  var values = [undefined];
  var i, l, field, value;
  for (i = 0, l = this._fields.length; i < l; i++) {
    field = this._fields[i];
    value = field._type._copy(val[field._name], opts);
    if (hook) {
      value = hook(field, value, this);
    }
    values.push(value);
  }
  return new (this._constructor.bind.apply(this._constructor, values));
};

RecordType.prototype.compare = function (val1, val2) {
  var fields = this._fields;
  var i, l, field, name, order, type;
  for (i = 0, l = fields.length; i < l; i++) {
    field = fields[i];
    name = field._name;
    order = field._order;
    type = field._type;
    if (order) {
      order *= type.compare(val1[name], val2[name]);
      if (order) {
        return order;
      }
    }
  }
  return 0;
};

RecordType.prototype.random = function () {
  // jshint -W058
  var fields = this._fields.map(function (f) { return f._type.random(); });
  fields.unshift(undefined);
  return new (this._constructor.bind.apply(this._constructor, fields));
};

RecordType.prototype.getAliases = function () { return this._aliases; };

RecordType.prototype.getFields = function () { return this._fields.slice(); };

RecordType.prototype.getRecordConstructor = function () {
  return this._constructor;
};

RecordType.prototype.toJSON = function () {
  return {name: this._name, type: 'record', fields: this._fields};
};

/**
 * Derived type abstract class.
 *
 */
function LogicalType(attrs, opts, Types) {
  Type.call(this);
  LOGICAL_TYPE = this;
  this._underlyingType = createType(attrs, opts);

  // Convenience type check.
  if (Types && !~Types.indexOf(this._underlyingType.constructor)) {
    var lType = attrs.logicalType;
    var uType = this._underlyingType;
    throw new Error(f('invalid underlying type for %s: %s', lType, uType));
  }
}
util.inherits(LogicalType, Type);

LogicalType.prototype.getUnderlyingType = function () {
  return this._underlyingType;
};

LogicalType.prototype._read = function (tap) {
  return this._fromValue(this._underlyingType._read(tap));
};

LogicalType.prototype._write = function (tap, any) {
  this._underlyingType._write(tap, this._toValue(any));
};

LogicalType.prototype._check = function (any, cb) {
  try {
    var val = this._toValue(any);
  } catch (err) {
    if (cb) {
      cb(PATH.slice(), any, this);
    }
    return false;
  }
  return this._underlyingType._check(val, cb);
};

LogicalType.prototype._copy = function (any, opts) {
  var type = this._underlyingType;
  switch (opts && opts.coerce) {
    case 3: // To string.
      return type._copy(this._toValue(any), opts);
    case 2: // From string.
      return this._fromValue(type._copy(any, opts));
    default: // Normal copy.
      return this._fromValue(type._copy(this._toValue(any), opts));
  }
};

LogicalType.prototype._updateResolver = function (resolver, type, opts) {
  var _fromValue = this._resolve(type, opts);
  if (_fromValue) {
    resolver._read = function (tap) { return _fromValue(type._read(tap)); };
  }
};

LogicalType.prototype.random = function () {
  return this._fromValue(this._underlyingType.random());
};

LogicalType.prototype.compare = function (obj1, obj2) {
  var val1 = this._toValue(obj1);
  var val2 = this._toValue(obj2);
  return this._underlyingType.compare(val1, val2);
};

LogicalType.prototype.toJSON = function () {
  return this._underlyingType.toJSON();
};

// Methods to be implemented.
LogicalType.prototype._fromValue = utils.abstractFunction;
LogicalType.prototype._toValue = utils.abstractFunction;
LogicalType.prototype._resolve = utils.abstractFunction;


// General helpers.

/**
 * Customizable long.
 *
 * This allows support of arbitrarily large long (e.g. larger than
 * `Number.MAX_SAFE_INTEGER`). See `LongType.using` method above.
 *
 */
function AbstractLongType(noUnpack) {
  LongType.call(this);
  this._noUnpack = !!noUnpack;
}
util.inherits(AbstractLongType, LongType);

AbstractLongType.prototype._check = function (val, cb) {
  var b = this._isValid(val);
  if (!b && cb) {
    cb(PATH.slice(), val, this);
  }
  return b;
};

AbstractLongType.prototype._read = function (tap) {
  var buf, pos;
  if (this._noUnpack) {
    pos = tap.pos;
    tap.skipLong();
    buf = tap.buf.slice(pos, tap.pos);
  } else {
    buf = tap.unpackLongBytes(tap);
  }
  if (tap.isValid()) {
    return this._fromBuffer(buf);
  }
};

AbstractLongType.prototype._write = function (tap, val) {
  if (!this._isValid(val)) {
    throwInvalidError(null, val, this);
  }
  var buf = this._toBuffer(val);
  if (this._noUnpack) {
    tap.writeFixed(buf);
  } else {
    tap.packLongBytes(buf);
  }
};

AbstractLongType.prototype._copy = function (val, opts) {
  switch (opts && opts.coerce) {
    case 3: // To string.
      return this._toJSON(val);
    case 2: // From string.
      return this._fromJSON(val);
    default: // Normal copy.
      // Slow but guarantees most consistent results. Faster alternatives would
      // require assumptions on the long class used (e.g. immutability).
      return this._fromJSON(JSON.parse(JSON.stringify(this._toJSON(val))));
  }
};

AbstractLongType.prototype.random = function () {
  return this._fromJSON(LongType.prototype.random());
};

// Methods to be implemented by the user.
AbstractLongType.prototype._fromBuffer = utils.abstractFunction;
AbstractLongType.prototype._toBuffer = utils.abstractFunction;
AbstractLongType.prototype._fromJSON = utils.abstractFunction;
AbstractLongType.prototype._toJSON = utils.abstractFunction;
AbstractLongType.prototype._isValid = utils.abstractFunction;
AbstractLongType.prototype.compare = utils.abstractFunction;

/**
 * Field.
 *
 * @param attrs {Object} The field's schema.
 * @para opts {Object} Schema parsing options (the same as `Type`s').
 *
 */
function Field(attrs, opts) {
  var name = attrs.name;
  if (typeof name != 'string' || !NAME_PATTERN.test(name)) {
    throw new Error(f('invalid field name: %s', name));
  }

  this._name = name;
  this._type = createType(attrs.type, opts);
  this._aliases = attrs.aliases || [];

  this._order = (function (order) {
    switch (order) {
      case 'ascending':
        return 1;
      case 'descending':
        return -1;
      case 'ignore':
        return 0;
      default:
        throw new Error(f('invalid order: %j', order));
    }
  })(attrs.order === undefined ? 'ascending' : attrs.order);

  var value = attrs['default'];
  if (value !== undefined) {
    // We need to convert defaults back to a valid format (unions are
    // disallowed in default definitions, only the first type of each union is
    // allowed instead).
    // http://apache-avro.679487.n3.nabble.com/field-union-default-in-Java-td1175327.html
    var type = this._type;
    var val = type._copy(value, {coerce: 2, wrap: 2});
    // The clone call above will throw an error if the default is invalid.
    if (type instanceof PrimitiveType && !(type instanceof BytesType)) {
      // These are immutable.
      this.getDefault = function () { return val; };
    } else {
      this.getDefault = function () { return type._copy(val); };
    }
  }
}

Field.prototype.getAliases = function () { return this._aliases; };

Field.prototype.getDefault = function () {}; // Undefined default.

Field.prototype.getName = function () { return this._name; };

Field.prototype.getOrder = function () {
  return ['descending', 'ignore', 'ascending'][this._order + 1];
};

Field.prototype.getType = function () { return this._type; };

Field.prototype.inspect = function () { return f('<Field %j>', this._name); };

/**
 * Resolver to read a writer's schema as a new schema.
 *
 * @param readerType {Type} The type to convert to.
 *
 */
function Resolver(readerType) {
  // Add all fields here so that all resolvers share the same hidden class.
  this._readerType = readerType;
  this._items = null;
  this._read = null;
  this._size = 0;
  this._symbols = null;
  this._values = null;
}

Resolver.prototype.inspect = function () { return '<Resolver>'; };

/**
 * Read a value from a tap.
 *
 * @param type {Type} The type to decode.
 * @param tap {Tap} The tap to read from. No checks are performed here.
 * @param resolver {Resolver} Optional resolver. It must match the input type.
 * @param lazy {Boolean} Skip trailing fields when using a resolver.
 *
 */
function readValue(type, tap, resolver, lazy) {
  if (resolver) {
    if (resolver._readerType !== type) {
      throw new Error('invalid resolver');
    }
    return resolver._read(tap, lazy);
  } else {
    return type._read(tap);
  }
}

/**
 * Create default parsing options.
 *
 * @param attrs {Object} Schema to populate options with.
 * @param opts {Object} Base options.
 *
 */
function getOpts(attrs, opts) {
  if (attrs === null) {
    // Let's be helpful for this common error.
    throw new Error('invalid type: null (did you mean "null"?)');
  }
  opts = opts || {};
  opts.registry = opts.registry || {};
  opts.namespace = attrs.namespace || opts.namespace;
  opts.logicalTypes = opts.logicalTypes || {};
  return opts;
}

/**
 * Resolve a schema's name and aliases.
 *
 * @param attrs {Object} True schema (can't be a string).
 * @param namespace {String} Optional parent namespace.
 * @param key {String} Key where the name should be looked up (defaults to
 * `name`).
 *
 */
function resolveNames(attrs, namespace, key) {
  namespace = attrs.namespace || namespace;
  key = key || 'name';

  var name = attrs[key];
  if (!name) {
    throw new Error(f('missing %s property in schema: %j', key, attrs));
  }
  return {
    name: qualify(name),
    aliases: attrs.aliases ? attrs.aliases.map(qualify) : []
  };

  function qualify(name) {
    if (!~name.indexOf('.') && namespace) {
      name = namespace + '.' + name;
    }
    var tail = unqualify(name);
    if (isPrimitive(tail)) {
      // Primitive types cannot be defined in any namespace.
      throw new Error(f('cannot rename primitive type: %j', tail));
    }
    name.split('.').forEach(function (part) {
      if (!NAME_PATTERN.test(part)) {
        throw new Error(f('invalid name: %j', name));
      }
    });
    return name;
  }
}

/**
 * Remove namespace from a name.
 *
 * @param name {String} Full or short name.
 *
 */
function unqualify(name) {
  var parts = name.split('.');
  return parts[parts.length - 1];
}

/**
 * Get all aliases for a type (including its name).
 *
 * @param obj {Type|Object} Typically a type or a field. Its aliases property
 * must exist and be an array.
 *
 */
function getAliases(obj) {
  var names = [obj._name];
  var aliases = obj._aliases;
  var i, l;
  for (i = 0, l = aliases.length; i < l; i++) {
    names.push(aliases[i]);
  }
  return names;
}

/**
 * Get a type's "type" (as a string, e.g. `'record'`, `'string'`).
 *
 * @param type {Type} Any type.
 *
 */
function getTypeName(type) {
  var obj = type.toJSON();
  return typeof obj == 'string' ? obj : obj.type;
}

/**
 * Check whether a type's name is a primitive.
 *
 * @param name {String} Type name (e.g. `'string'`, `'array'`).
 *
 */
function isPrimitive(name) {
  var type = TYPES[name];
  return type !== undefined && type.prototype instanceof PrimitiveType;
}

/**
 * Get the number of elements in an array block.
 *
 * @param tap {Tap} A tap positioned at the beginning of an array block.
 *
 */
function readArraySize(tap) {
  var n = tap.readLong();
  if (n < 0) {
    n = -n;
    tap.skipLong(); // Skip size.
  }
  return n;
}

/**
 * Correctly stringify an object which contains types.
 *
 * @param obj {Object} The object to stringify. Typically, a type itself or an
 * object containing types. Any types inside will be expanded only once then
 * referenced by name.
 * @param noDeref {Boolean} Always reference types by name when possible,
 * rather than expand it the first time it is encountered.
 *
 */
function stringify(obj, noDeref) {
  // Since JS objects are unordered, this implementation (unfortunately)
  // relies on engines returning properties in the same order that they are
  // inserted in. This is not in the JS spec, but can be "somewhat" safely
  // assumed (more here: http://stackoverflow.com/q/5525795/1062617).
  return (function (registry) {
    return JSON.stringify(obj, function (key, value) {
      if (value instanceof Field) {
        return {name: value._name, type: value._type};
      } else if (value && value.name) {
        var name = value.name;
        if (noDeref || registry[name]) {
          return name;
        }
        registry[name] = true;
      }
      return value;
    });
  })({});
}

/**
 * Check whether a long can be represented without precision loss.
 *
 * @param n {Number} The number.
 *
 * Two things to note:
 *
 * + We are not using the `Number` constants for compatibility with older
 *   browsers.
 * + We must remove one from each bound because of rounding errors.
 *
 */
function isSafeLong(n) {
  return n >= -9007199254740990 && n <= 9007199254740990;
}

/**
 * Throw a somewhat helpful error on invalid object.
 *
 * @param path {Array} Passed from hook, but unused (because empty where this
 * function is used, since we aren't keeping track of it for effiency).
 * @param val {...} The object to reject.
 * @param type {Type} The type to check against.
 *
 * This method is mostly used from `_write` to signal an invalid object for a
 * given type. Note that this provides less information than calling `isValid`
 * with a hook since the path is not propagated (for efficiency reasons).
 *
 */
function throwInvalidError(path, val, type) {
  throw new Error(f('invalid %s: %j', type, val));
}


module.exports = {
  createType: createType,
  resolveNames: resolveNames, // Protocols use the same name resolution logic.
  stringify: stringify,
  types: (function () {
    // Export the base types along with all concrete implementations.
    var obj = {Type: Type, LogicalType: LogicalType};
    var types = Object.keys(TYPES);
    var i, l, Class;
    for (i = 0, l = types.length; i < l; i++) {
      Class = TYPES[types[i]];
      obj[Class.name] = Class;
    }
    return obj;
  })()
};

}).call(this,require("buffer").Buffer)
},{"./utils":356,"buffer":358,"util":454}],356:[function(require,module,exports){
(function (Buffer){
/* jshint node: true */

/**
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  "License"); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 *
 */

'use strict';

var crypto = require('crypto');


/**
 * Uppercase the first letter of a string.
 *
 * @param s {String} The string.
 *
 */
function capitalize(s) { return s.charAt(0).toUpperCase() + s.slice(1); }

/**
 * Compare two numbers.
 *
 * @param n1 {Number} The first one.
 * @param n2 {Number} The second one.
 *
 */
function compare(n1, n2) { return n1 === n2 ? 0 : (n1 < n2 ? -1 : 1); }

/**
 * Compute a string's hash.
 *
 * @param str {String} The string to hash.
 * @param algorithm {String} The algorithm used. Defaults to MD5.
 *
 */
function getHash(str, algorithm) {
  algorithm = algorithm || 'md5';
  var hash = crypto.createHash(algorithm);
  hash.end(str);
  return hash.read();
}

/**
 * Find index of value in array.
 *
 * @param arr {Array} Can also be a false-ish value.
 * @param v {Object} Value to find.
 *
 * Returns -1 if not found, -2 if found multiple times.
 *
 */
function singleIndexOf(arr, v) {
  var pos = -1;
  var i, l;
  if (!arr) {
    return -1;
  }
  for (i = 0, l = arr.length; i < l; i++) {
    if (arr[i] === v) {
      if (pos >= 0) {
        return -2;
      }
      pos = i;
    }
  }
  return pos;
}

/**
 * Convert array to map.
 *
 * @param arr {Array} Elements.
 * @param fn {Function} Function returning an element's key.
 *
 */
function toMap(arr, fn) {
  var obj = {};
  var i, elem;
  for (i = 0; i < arr.length; i++) {
    elem = arr[i];
    obj[fn(elem)] = elem;
  }
  return obj;
}

/**
 * Check whether an array has duplicates.
 *
 * @param arr {Array} The array.
 * @param fn {Function} Optional function to apply to each element.
 *
 */
function hasDuplicates(arr, fn) {
  var obj = {};
  var i, l, elem;
  for (i = 0, l = arr.length; i < l; i++) {
    elem = arr[i];
    if (fn) {
      elem = fn(elem);
    }
    if (obj[elem]) {
      return true;
    }
    obj[elem] = true;
  }
  return false;
}

/**
 * "Abstract" function to help with "subclassing".
 *
 */
function abstractFunction() { throw new Error('abstract'); }

/**
 * Generator of random things.
 *
 * Inspired by: http://stackoverflow.com/a/424445/1062617
 *
 */
function Lcg(seed) {
  var a = 1103515245;
  var c = 12345;
  var m = Math.pow(2, 31);
  var state = Math.floor(seed || Math.random() * (m - 1));

  this._max = m;
  this._nextInt = function () { return state = (a * state + c) % m; };
}

Lcg.prototype.nextBoolean = function () {
  // jshint -W018
  return !!(this._nextInt() % 2);
};

Lcg.prototype.nextInt = function (start, end) {
  if (end === undefined) {
    end = start;
    start = 0;
  }
  end = end === undefined ? this._max : end;
  return start + Math.floor(this.nextFloat() * (end - start));
};

Lcg.prototype.nextFloat = function (start, end) {
  if (end === undefined) {
    end = start;
    start = 0;
  }
  end = end === undefined ? 1 : end;
  return start + (end - start) * this._nextInt() / this._max;
};

Lcg.prototype.nextString = function(len, flags) {
  len |= 0;
  flags = flags || 'aA';
  var mask = '';
  if (flags.indexOf('a') > -1) {
    mask += 'abcdefghijklmnopqrstuvwxyz';
  }
  if (flags.indexOf('A') > -1) {
    mask += 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
  }
  if (flags.indexOf('#') > -1) {
    mask += '0123456789';
  }
  if (flags.indexOf('!') > -1) {
    mask += '~`!@#$%^&*()_+-={}[]:";\'<>?,./|\\';
  }
  var result = [];
  for (var i = 0; i < len; i++) {
    result.push(this.choice(mask));
  }
  return result.join('');
};

Lcg.prototype.nextBuffer = function (len) {
  var arr = [];
  var i;
  for (i = 0; i < len; i++) {
    arr.push(this.nextInt(256));
  }
  return new Buffer(arr);
};

Lcg.prototype.choice = function (arr) {
  var len = arr.length;
  if (!len) {
    throw new Error('choosing from empty array');
  }
  return arr[this.nextInt(len)];
};

/**
 * Ordered queue which returns items consecutively.
 *
 * This is actually a heap by index, with the added requirements that elements
 * can only be retrieved consecutively.
 *
 */
function OrderedQueue() {
  this._index = 0;
  this._items = [];
}

OrderedQueue.prototype.push = function (item) {
  var items = this._items;
  var i = items.length | 0;
  var j;
  items.push(item);
  while (i > 0 && items[i].index < items[j = ((i - 1) >> 1)].index) {
    item = items[i];
    items[i] = items[j];
    items[j] = item;
    i = j;
  }
};

OrderedQueue.prototype.pop = function () {
  var items = this._items;
  var len = (items.length - 1) | 0;
  var first = items[0];
  if (!first || first.index > this._index) {
    return null;
  }
  this._index++;
  if (!len) {
    items.pop();
    return first;
  }
  items[0] = items.pop();
  var mid = len >> 1;
  var i = 0;
  var i1, i2, j, item, c, c1, c2;
  while (i < mid) {
    item = items[i];
    i1 = (i << 1) + 1;
    i2 = (i + 1) << 1;
    c1 = items[i1];
    c2 = items[i2];
    if (!c2 || c1.index <= c2.index) {
      c = c1;
      j = i1;
    } else {
      c = c2;
      j = i2;
    }
    if (c.index >= item.index) {
      break;
    }
    items[j] = item;
    items[i] = c;
    i = j;
  }
  return first;
};

/**
 * A tap is a buffer which remembers what has been already read.
 *
 * It is optimized for performance, at the cost of failing silently when
 * overflowing the buffer. This is a purposeful trade-off given the expected
 * rarity of this case and the large performance hit necessary to enforce
 * validity. See `isValid` below for more information.
 *
 */
function Tap(buf, pos) {
  this.buf = buf;
  this.pos = pos | 0;
}

/**
 * Check that the tap is in a valid state.
 *
 * For efficiency reasons, none of the methods below will fail if an overflow
 * occurs (either read, skip, or write). For this reason, it is up to the
 * caller to always check that the read, skip, or write was valid by calling
 * this method.
 *
 */
Tap.prototype.isValid = function () { return this.pos <= this.buf.length; };

/**
 * Returns the contents of the tap up to the current position.
 *
 */
Tap.prototype.getValue = function () { return this.buf.slice(0, this.pos); };

// Read, skip, write methods.
//
// These should fail silently when the buffer overflows. Note this is only
// required to be true when the functions are decoding valid objects. For
// example errors will still be thrown if a bad count is read, leading to a
// negative position offset (which will typically cause a failure in
// `readFixed`).

Tap.prototype.readBoolean = function () { return !!this.buf[this.pos++]; };

Tap.prototype.skipBoolean = function () { this.pos++; };

Tap.prototype.writeBoolean = function (b) { this.buf[this.pos++] = !!b; };

Tap.prototype.readInt = Tap.prototype.readLong = function () {
  var n = 0;
  var k = 0;
  var buf = this.buf;
  var b, h, f, fk;

  do {
    b = buf[this.pos++];
    h = b & 0x80;
    n |= (b & 0x7f) << k;
    k += 7;
  } while (h && k < 28);

  if (h) {
    // Switch to float arithmetic, otherwise we might overflow.
    f = n;
    fk = 268435456; // 2 ** 28.
    do {
      b = buf[this.pos++];
      f += (b & 0x7f) * fk;
      fk *= 128;
    } while (b & 0x80);
    return (f % 2 ? -(f + 1) : f) / 2;
  }

  return (n >> 1) ^ -(n & 1);
};

Tap.prototype.skipInt = Tap.prototype.skipLong = function () {
  var buf = this.buf;
  while (buf[this.pos++] & 0x80) {}
};

Tap.prototype.writeInt = Tap.prototype.writeLong = function (n) {
  var buf = this.buf;
  var f, m;

  if (n >= -1073741824 && n < 1073741824) {
    // Won't overflow, we can use integer arithmetic.
    m = n >= 0 ? n << 1 : (~n << 1) | 1;
    do {
      buf[this.pos] = m & 0x7f;
      m >>= 7;
    } while (m && (buf[this.pos++] |= 0x80));
  } else {
    // We have to use slower floating arithmetic.
    f = n >= 0 ? n * 2 : (-n * 2) - 1;
    do {
      buf[this.pos] = f & 0x7f;
      f /= 128;
    } while (f >= 1 && (buf[this.pos++] |= 0x80));
  }
  this.pos++;
};

Tap.prototype.readFloat = function () {
  var buf = this.buf;
  var pos = this.pos;
  this.pos += 4;
  if (this.pos > buf.length) {
    return;
  }
  return this.buf.readFloatLE(pos);
};

Tap.prototype.skipFloat = function () { this.pos += 4; };

Tap.prototype.writeFloat = function (f) {
  var buf = this.buf;
  var pos = this.pos;
  this.pos += 4;
  if (this.pos > buf.length) {
    return;
  }
  return this.buf.writeFloatLE(f, pos);
};

Tap.prototype.readDouble = function () {
  var buf = this.buf;
  var pos = this.pos;
  this.pos += 8;
  if (this.pos > buf.length) {
    return;
  }
  return this.buf.readDoubleLE(pos);
};

Tap.prototype.skipDouble = function () { this.pos += 8; };

Tap.prototype.writeDouble = function (d) {
  var buf = this.buf;
  var pos = this.pos;
  this.pos += 8;
  if (this.pos > buf.length) {
    return;
  }
  return this.buf.writeDoubleLE(d, pos);
};

Tap.prototype.readFixed = function (len) {
  var pos = this.pos;
  this.pos += len;
  if (this.pos > this.buf.length) {
    return;
  }
  var fixed = new Buffer(len);
  this.buf.copy(fixed, 0, pos, pos + len);
  return fixed;
};

Tap.prototype.skipFixed = function (len) { this.pos += len; };

Tap.prototype.writeFixed = function (buf, len) {
  len = len || buf.length;
  var pos = this.pos;
  this.pos += len;
  if (this.pos > this.buf.length) {
    return;
  }
  buf.copy(this.buf, pos, 0, len);
};

Tap.prototype.readBytes = function () {
  return this.readFixed(this.readLong());
};

Tap.prototype.skipBytes = function () {
  var len = this.readLong();
  this.pos += len;
};

Tap.prototype.writeBytes = function (buf) {
  var len = buf.length;
  this.writeLong(len);
  this.writeFixed(buf, len);
};

Tap.prototype.readString = function () {
  var len = this.readLong();
  var pos = this.pos;
  var buf = this.buf;
  this.pos += len;
  if (this.pos > buf.length) {
    return;
  }
  return this.buf.utf8Slice(pos, pos + len);
};

Tap.prototype.skipString = function () {
  var len = this.readLong();
  this.pos += len;
};

Tap.prototype.writeString = function (s) {
  var len = Buffer.byteLength(s);
  this.writeLong(len);
  var pos = this.pos;
  this.pos += len;
  if (this.pos > this.buf.length) {
    return;
  }
  this.buf.utf8Write(s, pos, len);
};

// Helper used to speed up writing defaults.

Tap.prototype.writeBinary = function (str, len) {
  var pos = this.pos;
  this.pos += len;
  if (this.pos > this.buf.length) {
    return;
  }
  this.buf.binaryWrite(str, pos, len);
};

// Binary comparison methods.
//
// These are not guaranteed to consume the objects they are comparing when
// returning a non-zero result (allowing for performance benefits), so no other
// operations should be done on either tap after a compare returns a non-zero
// value. Also, these methods do not have the same silent failure requirement
// as read, skip, and write since they are assumed to be called on valid
// buffers.

Tap.prototype.matchBoolean = function (tap) {
  return this.buf[this.pos++] - tap.buf[tap.pos++];
};

Tap.prototype.matchInt = Tap.prototype.matchLong = function (tap) {
  var n1 = this.readLong();
  var n2 = tap.readLong();
  return n1 === n2 ? 0 : (n1 < n2 ? -1 : 1);
};

Tap.prototype.matchFloat = function (tap) {
  var n1 = this.readFloat();
  var n2 = tap.readFloat();
  return n1 === n2 ? 0 : (n1 < n2 ? -1 : 1);
};

Tap.prototype.matchDouble = function (tap) {
  var n1 = this.readDouble();
  var n2 = tap.readDouble();
  return n1 === n2 ? 0 : (n1 < n2 ? -1 : 1);
};

Tap.prototype.matchFixed = function (tap, len) {
  return this.readFixed(len).compare(tap.readFixed(len));
};

Tap.prototype.matchBytes = Tap.prototype.matchString = function (tap) {
  var l1 = this.readLong();
  var p1 = this.pos;
  this.pos += l1;
  var l2 = tap.readLong();
  var p2 = tap.pos;
  tap.pos += l2;
  var b1 = this.buf.slice(p1, this.pos);
  var b2 = tap.buf.slice(p2, tap.pos);
  return b1.compare(b2);
};

// Functions for supporting custom long classes.
//
// The two following methods allow the long implementations to not have to
// worry about Avro's zigzag encoding, we directly expose longs as unpacked.

Tap.prototype.unpackLongBytes = function () {
  var res = new Buffer(8);
  var n = 0;
  var i = 0; // Byte index in target buffer.
  var j = 6; // Bit offset in current target buffer byte.
  var buf = this.buf;
  var b, neg;

  b = buf[this.pos++];
  neg = b & 1;
  res.fill(0);

  n |= (b & 0x7f) >> 1;
  while (b & 0x80) {
    b = buf[this.pos++];
    n |= (b & 0x7f) << j;
    j += 7;
    if (j >= 8) {
      // Flush byte.
      j -= 8;
      res[i++] = n;
      n >>= 8;
    }
  }
  res[i] = n;

  if (neg) {
    invert(res, 8);
  }

  return res;
};

Tap.prototype.packLongBytes = function (buf) {
  var neg = (buf[7] & 0x80) >> 7;
  var res = this.buf;
  var j = 1;
  var k = 0;
  var m = 3;
  var n;

  if (neg) {
    invert(buf, 8);
    n = 1;
  } else {
    n = 0;
  }

  var parts = [
    buf.readUIntLE(0, 3),
    buf.readUIntLE(3, 3),
    buf.readUIntLE(6, 2)
  ];
  // Not reading more than 24 bits because we need to be able to combine the
  // "carry" bits from the previous part and JavaScript only supports bitwise
  // operations on 32 bit integers.
  while (m && !parts[--m]) {} // Skip trailing 0s.

  // Leading parts (if any), we never bail early here since we need the
  // continuation bit to be set.
  while (k < m) {
    n |= parts[k++] << j;
    j += 24;
    while (j > 7) {
      res[this.pos++] = (n & 0x7f) | 0x80;
      n >>= 7;
      j -= 7;
    }
  }

  // Final part, similar to normal packing aside from the initial offset.
  n |= parts[m] << j;
  do {
    res[this.pos] = n & 0x7f;
    n >>= 7;
  } while (n && (res[this.pos++] |= 0x80));
  this.pos++;

  // Restore original buffer (could make this optional?).
  if (neg) {
    invert(buf, 8);
  }
};

// Helpers.

/**
 * Invert all bits in a buffer.
 *
 * @param buf {Buffer} Non-empty buffer to invert.
 * @param len {Number} Buffer length (must be positive).
 *
 */
function invert(buf, len) {
  while (len--) {
    buf[len] = ~buf[len];
  }
}


module.exports = {
  abstractFunction: abstractFunction,
  capitalize: capitalize,
  compare: compare,
  getHash: getHash,
  toMap: toMap,
  singleIndexOf: singleIndexOf,
  hasDuplicates: hasDuplicates,
  Lcg: Lcg,
  OrderedQueue: OrderedQueue,
  Tap: Tap
};

}).call(this,require("buffer").Buffer)
},{"buffer":358,"crypto":353}],357:[function(require,module,exports){
'use strict'

exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function placeHoldersCount (b64) {
  var len = b64.length
  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // the number of equal signs (place holders)
  // if there are two placeholders, than the two characters before it
  // represent one byte
  // if there is only one, then the three characters before it represent 2 bytes
  // this is just a cheap hack to not do indexOf twice
  return b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0
}

function byteLength (b64) {
  // base64 is 4/3 + up to two characters of the original data
  return b64.length * 3 / 4 - placeHoldersCount(b64)
}

function toByteArray (b64) {
  var i, j, l, tmp, placeHolders, arr
  var len = b64.length
  placeHolders = placeHoldersCount(b64)

  arr = new Arr(len * 3 / 4 - placeHolders)

  // if there are placeholders, only get up to the last complete 4 chars
  l = placeHolders > 0 ? len - 4 : len

  var L = 0

  for (i = 0, j = 0; i < l; i += 4, j += 3) {
    tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)]
    arr[L++] = (tmp >> 16) & 0xFF
    arr[L++] = (tmp >> 8) & 0xFF
    arr[L++] = tmp & 0xFF
  }

  if (placeHolders === 2) {
    tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[L++] = tmp & 0xFF
  } else if (placeHolders === 1) {
    tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[L++] = (tmp >> 8) & 0xFF
    arr[L++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var output = ''
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    output += lookup[tmp >> 2]
    output += lookup[(tmp << 4) & 0x3F]
    output += '=='
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + (uint8[len - 1])
    output += lookup[tmp >> 10]
    output += lookup[(tmp >> 4) & 0x3F]
    output += lookup[(tmp << 2) & 0x3F]
    output += '='
  }

  parts.push(output)

  return parts.join('')
}

},{}],358:[function(require,module,exports){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */

'use strict'

var base64 = require('base64-js')
var ieee754 = require('ieee754')

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

var K_MAX_LENGTH = 0x7fffffff
exports.kMaxLength = K_MAX_LENGTH

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */
Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport()

if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&
    typeof console.error === 'function') {
  console.error(
    'This browser lacks typed array (Uint8Array) support which is required by ' +
    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'
  )
}

function typedArraySupport () {
  // Can typed array instances can be augmented?
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}
    return arr.foo() === 42
  } catch (e) {
    return false
  }
}

Object.defineProperty(Buffer.prototype, 'parent', {
  get: function () {
    if (!(this instanceof Buffer)) {
      return undefined
    }
    return this.buffer
  }
})

Object.defineProperty(Buffer.prototype, 'offset', {
  get: function () {
    if (!(this instanceof Buffer)) {
      return undefined
    }
    return this.byteOffset
  }
})

function createBuffer (length) {
  if (length > K_MAX_LENGTH) {
    throw new RangeError('Invalid typed array length')
  }
  // Return an augmented `Uint8Array` instance
  var buf = new Uint8Array(length)
  buf.__proto__ = Buffer.prototype
  return buf
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error(
        'If encoding is specified then the first argument must be a string'
      )
    }
    return allocUnsafe(arg)
  }
  return from(arg, encodingOrOffset, length)
}

// Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
if (typeof Symbol !== 'undefined' && Symbol.species &&
    Buffer[Symbol.species] === Buffer) {
  Object.defineProperty(Buffer, Symbol.species, {
    value: null,
    configurable: true,
    enumerable: false,
    writable: false
  })
}

Buffer.poolSize = 8192 // not used by this implementation

function from (value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number')
  }

  if (isArrayBuffer(value) || (value && isArrayBuffer(value.buffer))) {
    return fromArrayBuffer(value, encodingOrOffset, length)
  }

  if (typeof value === 'string') {
    return fromString(value, encodingOrOffset)
  }

  return fromObject(value)
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(value, encodingOrOffset, length)
}

// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148
Buffer.prototype.__proto__ = Uint8Array.prototype
Buffer.__proto__ = Uint8Array

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be of type number')
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative')
  }
}

function alloc (size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(size).fill(fill, encoding)
      : createBuffer(size).fill(fill)
  }
  return createBuffer(size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(size, fill, encoding)
}

function allocUnsafe (size) {
  assertSize(size)
  return createBuffer(size < 0 ? 0 : checked(size) | 0)
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(size)
}

function fromString (string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('Unknown encoding: ' + encoding)
  }

  var length = byteLength(string, encoding) | 0
  var buf = createBuffer(length)

  var actual = buf.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    buf = buf.slice(0, actual)
  }

  return buf
}

function fromArrayLike (array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  var buf = createBuffer(length)
  for (var i = 0; i < length; i += 1) {
    buf[i] = array[i] & 255
  }
  return buf
}

function fromArrayBuffer (array, byteOffset, length) {
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('"offset" is outside of buffer bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('"length" is outside of buffer bounds')
  }

  var buf
  if (byteOffset === undefined && length === undefined) {
    buf = new Uint8Array(array)
  } else if (length === undefined) {
    buf = new Uint8Array(array, byteOffset)
  } else {
    buf = new Uint8Array(array, byteOffset, length)
  }

  // Return an augmented `Uint8Array` instance
  buf.__proto__ = Buffer.prototype
  return buf
}

function fromObject (obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    var buf = createBuffer(len)

    if (buf.length === 0) {
      return buf
    }

    obj.copy(buf, 0, 0, len)
    return buf
  }

  if (obj) {
    if (ArrayBuffer.isView(obj) || 'length' in obj) {
      if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
        return createBuffer(0)
      }
      return fromArrayLike(obj)
    }

    if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
      return fromArrayLike(obj.data)
    }
  }

  throw new TypeError('The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object.')
}

function checked (length) {
  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= K_MAX_LENGTH) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return b != null && b._isBuffer === true
}

Buffer.compare = function compare (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!Array.isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (ArrayBuffer.isView(buf)) {
      buf = Buffer.from(buf)
    }
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (ArrayBuffer.isView(string) || isArrayBuffer(string)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    string = '' + string
  }

  var len = string.length
  if (len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) return utf8ToBytes(string).length // assume utf8
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.toLocaleString = Buffer.prototype.toString

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max) str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('Argument must be a Buffer')
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset  // Coerce to Number.
  if (numberIsNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  var strLen = string.length

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (numberIsNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset >>> 0
    if (isFinite(length)) {
      length = length >>> 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
      : (firstByte > 0xBF) ? 2
      : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf = this.subarray(start, end)
  // Return an augmented `Uint8Array` instance
  newBuf.__proto__ = Buffer.prototype
  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset + 3] = (value >>> 24)
  this[offset + 2] = (value >>> 16)
  this[offset + 1] = (value >>> 8)
  this[offset] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  this[offset + 2] = (value >>> 16)
  this[offset + 3] = (value >>> 24)
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start

  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {
    // Use built-in when available, missing from IE11
    this.copyWithin(targetStart, start, end)
  } else if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (var i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, end),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if ((encoding === 'utf8' && code < 128) ||
          encoding === 'latin1') {
        // Fast path: If `val` fits into a single byte, use that numeric value.
        val = code
      }
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : new Buffer(val, encoding)
    var len = bytes.length
    if (len === 0) {
      throw new TypeError('The value "' + val +
        '" is invalid for argument "value"')
    }
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node takes equal signs as end of the Base64 encoding
  str = str.split('=')[0]
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = str.trim().replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

// ArrayBuffers from another context (i.e. an iframe) do not pass the `instanceof` check
// but they should be treated as valid. See: https://github.com/feross/buffer/issues/166
function isArrayBuffer (obj) {
  return obj instanceof ArrayBuffer ||
    (obj != null && obj.constructor != null && obj.constructor.name === 'ArrayBuffer' &&
      typeof obj.byteLength === 'number')
}

function numberIsNaN (obj) {
  return obj !== obj // eslint-disable-line no-self-compare
}

},{"base64-js":357,"ieee754":382}],359:[function(require,module,exports){
(function (process){
/**
 * This is the web browser implementation of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = require('./debug');
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = 'undefined' != typeof chrome
               && 'undefined' != typeof chrome.storage
                  ? chrome.storage.local
                  : localstorage();

/**
 * Colors.
 */

exports.colors = [
  '#0000CC', '#0000FF', '#0033CC', '#0033FF', '#0066CC', '#0066FF', '#0099CC',
  '#0099FF', '#00CC00', '#00CC33', '#00CC66', '#00CC99', '#00CCCC', '#00CCFF',
  '#3300CC', '#3300FF', '#3333CC', '#3333FF', '#3366CC', '#3366FF', '#3399CC',
  '#3399FF', '#33CC00', '#33CC33', '#33CC66', '#33CC99', '#33CCCC', '#33CCFF',
  '#6600CC', '#6600FF', '#6633CC', '#6633FF', '#66CC00', '#66CC33', '#9900CC',
  '#9900FF', '#9933CC', '#9933FF', '#99CC00', '#99CC33', '#CC0000', '#CC0033',
  '#CC0066', '#CC0099', '#CC00CC', '#CC00FF', '#CC3300', '#CC3333', '#CC3366',
  '#CC3399', '#CC33CC', '#CC33FF', '#CC6600', '#CC6633', '#CC9900', '#CC9933',
  '#CCCC00', '#CCCC33', '#FF0000', '#FF0033', '#FF0066', '#FF0099', '#FF00CC',
  '#FF00FF', '#FF3300', '#FF3333', '#FF3366', '#FF3399', '#FF33CC', '#FF33FF',
  '#FF6600', '#FF6633', '#FF9900', '#FF9933', '#FFCC00', '#FFCC33'
];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

function useColors() {
  // NB: In an Electron preload script, document will be defined but not fully
  // initialized. Since we know we're in Chrome, we'll just detect this case
  // explicitly
  if (typeof window !== 'undefined' && window.process && window.process.type === 'renderer') {
    return true;
  }

  // Internet Explorer and Edge do not support colors.
  if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
    return false;
  }

  // is webkit? http://stackoverflow.com/a/16459606/376773
  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
  return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||
    // is firebug? http://stackoverflow.com/a/398120/376773
    (typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||
    // is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||
    // double check webkit in userAgent just in case we are in a worker
    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
}

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

exports.formatters.j = function(v) {
  try {
    return JSON.stringify(v);
  } catch (err) {
    return '[UnexpectedJSONParseError]: ' + err.message;
  }
};


/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs(args) {
  var useColors = this.useColors;

  args[0] = (useColors ? '%c' : '')
    + this.namespace
    + (useColors ? ' %c' : ' ')
    + args[0]
    + (useColors ? '%c ' : ' ')
    + '+' + exports.humanize(this.diff);

  if (!useColors) return;

  var c = 'color: ' + this.color;
  args.splice(1, 0, c, 'color: inherit')

  // the final "%c" is somewhat tricky, because there could be other
  // arguments passed either before or after the %c, so we need to
  // figure out the correct index to insert the CSS into
  var index = 0;
  var lastC = 0;
  args[0].replace(/%[a-zA-Z%]/g, function(match) {
    if ('%%' === match) return;
    index++;
    if ('%c' === match) {
      // we only are interested in the *last* %c
      // (the user may have provided their own)
      lastC = index;
    }
  });

  args.splice(lastC, 0, c);
}

/**
 * Invokes `console.log()` when available.
 * No-op when `console.log` is not a "function".
 *
 * @api public
 */

function log() {
  // this hackery is required for IE8/9, where
  // the `console.log` function doesn't have 'apply'
  return 'object' === typeof console
    && console.log
    && Function.prototype.apply.call(console.log, console, arguments);
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */

function save(namespaces) {
  try {
    if (null == namespaces) {
      exports.storage.removeItem('debug');
    } else {
      exports.storage.debug = namespaces;
    }
  } catch(e) {}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
  var r;
  try {
    r = exports.storage.debug;
  } catch(e) {}

  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG
  if (!r && typeof process !== 'undefined' && 'env' in process) {
    r = process.env.DEBUG;
  }

  return r;
}

/**
 * Enable namespaces listed in `localStorage.debug` initially.
 */

exports.enable(load());

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage() {
  try {
    return window.localStorage;
  } catch (e) {}
}

}).call(this,require('_process'))
},{"./debug":360,"_process":432}],360:[function(require,module,exports){

/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = createDebug.debug = createDebug['default'] = createDebug;
exports.coerce = coerce;
exports.disable = disable;
exports.enable = enable;
exports.enabled = enabled;
exports.humanize = require('ms');

/**
 * Active `debug` instances.
 */
exports.instances = [];

/**
 * The currently active debug mode names, and names to skip.
 */

exports.names = [];
exports.skips = [];

/**
 * Map of special "%n" handling functions, for the debug "format" argument.
 *
 * Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
 */

exports.formatters = {};

/**
 * Select a color.
 * @param {String} namespace
 * @return {Number}
 * @api private
 */

function selectColor(namespace) {
  var hash = 0, i;

  for (i in namespace) {
    hash  = ((hash << 5) - hash) + namespace.charCodeAt(i);
    hash |= 0; // Convert to 32bit integer
  }

  return exports.colors[Math.abs(hash) % exports.colors.length];
}

/**
 * Create a debugger with the given `namespace`.
 *
 * @param {String} namespace
 * @return {Function}
 * @api public
 */

function createDebug(namespace) {

  var prevTime;

  function debug() {
    // disabled?
    if (!debug.enabled) return;

    var self = debug;

    // set `diff` timestamp
    var curr = +new Date();
    var ms = curr - (prevTime || curr);
    self.diff = ms;
    self.prev = prevTime;
    self.curr = curr;
    prevTime = curr;

    // turn the `arguments` into a proper Array
    var args = new Array(arguments.length);
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }

    args[0] = exports.coerce(args[0]);

    if ('string' !== typeof args[0]) {
      // anything else let's inspect with %O
      args.unshift('%O');
    }

    // apply any `formatters` transformations
    var index = 0;
    args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {
      // if we encounter an escaped % then don't increase the array index
      if (match === '%%') return match;
      index++;
      var formatter = exports.formatters[format];
      if ('function' === typeof formatter) {
        var val = args[index];
        match = formatter.call(self, val);

        // now we need to remove `args[index]` since it's inlined in the `format`
        args.splice(index, 1);
        index--;
      }
      return match;
    });

    // apply env-specific formatting (colors, etc.)
    exports.formatArgs.call(self, args);

    var logFn = debug.log || exports.log || console.log.bind(console);
    logFn.apply(self, args);
  }

  debug.namespace = namespace;
  debug.enabled = exports.enabled(namespace);
  debug.useColors = exports.useColors();
  debug.color = selectColor(namespace);
  debug.destroy = destroy;

  // env-specific initialization logic for debug instances
  if ('function' === typeof exports.init) {
    exports.init(debug);
  }

  exports.instances.push(debug);

  return debug;
}

function destroy () {
  var index = exports.instances.indexOf(this);
  if (index !== -1) {
    exports.instances.splice(index, 1);
    return true;
  } else {
    return false;
  }
}

/**
 * Enables a debug mode by namespaces. This can include modes
 * separated by a colon and wildcards.
 *
 * @param {String} namespaces
 * @api public
 */

function enable(namespaces) {
  exports.save(namespaces);

  exports.names = [];
  exports.skips = [];

  var i;
  var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
  var len = split.length;

  for (i = 0; i < len; i++) {
    if (!split[i]) continue; // ignore empty strings
    namespaces = split[i].replace(/\*/g, '.*?');
    if (namespaces[0] === '-') {
      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
    } else {
      exports.names.push(new RegExp('^' + namespaces + '$'));
    }
  }

  for (i = 0; i < exports.instances.length; i++) {
    var instance = exports.instances[i];
    instance.enabled = exports.enabled(instance.namespace);
  }
}

/**
 * Disable debug output.
 *
 * @api public
 */

function disable() {
  exports.enable('');
}

/**
 * Returns true if the given mode name is enabled, false otherwise.
 *
 * @param {String} name
 * @return {Boolean}
 * @api public
 */

function enabled(name) {
  if (name[name.length - 1] === '*') {
    return true;
  }
  var i, len;
  for (i = 0, len = exports.skips.length; i < len; i++) {
    if (exports.skips[i].test(name)) {
      return false;
    }
  }
  for (i = 0, len = exports.names.length; i < len; i++) {
    if (exports.names[i].test(name)) {
      return true;
    }
  }
  return false;
}

/**
 * Coerce `val`.
 *
 * @param {Mixed} val
 * @return {Mixed}
 * @api private
 */

function coerce(val) {
  if (val instanceof Error) return val.stack || val.message;
  return val;
}

},{"ms":431}],361:[function(require,module,exports){
/*!
 * escape-html
 * Copyright(c) 2012-2013 TJ Holowaychuk
 * Copyright(c) 2015 Andreas Lubbe
 * Copyright(c) 2015 Tiancheng "Timothy" Gu
 * MIT Licensed
 */

'use strict';

/**
 * Module variables.
 * @private
 */

var matchHtmlRegExp = /["'&<>]/;

/**
 * Module exports.
 * @public
 */

module.exports = escapeHtml;

/**
 * Escape special characters in the given string of html.
 *
 * @param  {string} string The string to escape for inserting into HTML
 * @return {string}
 * @public
 */

function escapeHtml(string) {
  var str = '' + string;
  var match = matchHtmlRegExp.exec(str);

  if (!match) {
    return str;
  }

  var escape;
  var html = '';
  var index = 0;
  var lastIndex = 0;

  for (index = match.index; index < str.length; index++) {
    switch (str.charCodeAt(index)) {
      case 34: // "
        escape = '&quot;';
        break;
      case 38: // &
        escape = '&amp;';
        break;
      case 39: // '
        escape = '&#39;';
        break;
      case 60: // <
        escape = '&lt;';
        break;
      case 62: // >
        escape = '&gt;';
        break;
      default:
        continue;
    }

    if (lastIndex !== index) {
      html += str.substring(lastIndex, index);
    }

    lastIndex = index + 1;
    html += escape;
  }

  return lastIndex !== index
    ? html + str.substring(lastIndex, index)
    : html;
}

},{}],362:[function(require,module,exports){
'use strict';

exports.__esModule = true;
// istanbul ignore next

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

// istanbul ignore next

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

var _handlebarsBase = require('./handlebars/base');

var base = _interopRequireWildcard(_handlebarsBase);

// Each of these augment the Handlebars object. No need to setup here.
// (This is done to easily share code between commonjs and browse envs)

var _handlebarsSafeString = require('./handlebars/safe-string');

var _handlebarsSafeString2 = _interopRequireDefault(_handlebarsSafeString);

var _handlebarsException = require('./handlebars/exception');

var _handlebarsException2 = _interopRequireDefault(_handlebarsException);

var _handlebarsUtils = require('./handlebars/utils');

var Utils = _interopRequireWildcard(_handlebarsUtils);

var _handlebarsRuntime = require('./handlebars/runtime');

var runtime = _interopRequireWildcard(_handlebarsRuntime);

var _handlebarsNoConflict = require('./handlebars/no-conflict');

var _handlebarsNoConflict2 = _interopRequireDefault(_handlebarsNoConflict);

// For compatibility and usage outside of module systems, make the Handlebars object a namespace
function create() {
  var hb = new base.HandlebarsEnvironment();

  Utils.extend(hb, base);
  hb.SafeString = _handlebarsSafeString2['default'];
  hb.Exception = _handlebarsException2['default'];
  hb.Utils = Utils;
  hb.escapeExpression = Utils.escapeExpression;

  hb.VM = runtime;
  hb.template = function (spec) {
    return runtime.template(spec, hb);
  };

  return hb;
}

var inst = create();
inst.create = create;

_handlebarsNoConflict2['default'](inst);

inst['default'] = inst;

exports['default'] = inst;
module.exports = exports['default'];


},{"./handlebars/base":363,"./handlebars/exception":366,"./handlebars/no-conflict":376,"./handlebars/runtime":377,"./handlebars/safe-string":378,"./handlebars/utils":379}],363:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports.HandlebarsEnvironment = HandlebarsEnvironment;
// istanbul ignore next

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _utils = require('./utils');

var _exception = require('./exception');

var _exception2 = _interopRequireDefault(_exception);

var _helpers = require('./helpers');

var _decorators = require('./decorators');

var _logger = require('./logger');

var _logger2 = _interopRequireDefault(_logger);

var VERSION = '4.0.11';
exports.VERSION = VERSION;
var COMPILER_REVISION = 7;

exports.COMPILER_REVISION = COMPILER_REVISION;
var REVISION_CHANGES = {
  1: '<= 1.0.rc.2', // 1.0.rc.2 is actually rev2 but doesn't report it
  2: '== 1.0.0-rc.3',
  3: '== 1.0.0-rc.4',
  4: '== 1.x.x',
  5: '== 2.0.0-alpha.x',
  6: '>= 2.0.0-beta.1',
  7: '>= 4.0.0'
};

exports.REVISION_CHANGES = REVISION_CHANGES;
var objectType = '[object Object]';

function HandlebarsEnvironment(helpers, partials, decorators) {
  this.helpers = helpers || {};
  this.partials = partials || {};
  this.decorators = decorators || {};

  _helpers.registerDefaultHelpers(this);
  _decorators.registerDefaultDecorators(this);
}

HandlebarsEnvironment.prototype = {
  constructor: HandlebarsEnvironment,

  logger: _logger2['default'],
  log: _logger2['default'].log,

  registerHelper: function registerHelper(name, fn) {
    if (_utils.toString.call(name) === objectType) {
      if (fn) {
        throw new _exception2['default']('Arg not supported with multiple helpers');
      }
      _utils.extend(this.helpers, name);
    } else {
      this.helpers[name] = fn;
    }
  },
  unregisterHelper: function unregisterHelper(name) {
    delete this.helpers[name];
  },

  registerPartial: function registerPartial(name, partial) {
    if (_utils.toString.call(name) === objectType) {
      _utils.extend(this.partials, name);
    } else {
      if (typeof partial === 'undefined') {
        throw new _exception2['default']('Attempting to register a partial called "' + name + '" as undefined');
      }
      this.partials[name] = partial;
    }
  },
  unregisterPartial: function unregisterPartial(name) {
    delete this.partials[name];
  },

  registerDecorator: function registerDecorator(name, fn) {
    if (_utils.toString.call(name) === objectType) {
      if (fn) {
        throw new _exception2['default']('Arg not supported with multiple decorators');
      }
      _utils.extend(this.decorators, name);
    } else {
      this.decorators[name] = fn;
    }
  },
  unregisterDecorator: function unregisterDecorator(name) {
    delete this.decorators[name];
  }
};

var log = _logger2['default'].log;

exports.log = log;
exports.createFrame = _utils.createFrame;
exports.logger = _logger2['default'];


},{"./decorators":364,"./exception":366,"./helpers":367,"./logger":375,"./utils":379}],364:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports.registerDefaultDecorators = registerDefaultDecorators;
// istanbul ignore next

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _decoratorsInline = require('./decorators/inline');

var _decoratorsInline2 = _interopRequireDefault(_decoratorsInline);

function registerDefaultDecorators(instance) {
  _decoratorsInline2['default'](instance);
}


},{"./decorators/inline":365}],365:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _utils = require('../utils');

exports['default'] = function (instance) {
  instance.registerDecorator('inline', function (fn, props, container, options) {
    var ret = fn;
    if (!props.partials) {
      props.partials = {};
      ret = function (context, options) {
        // Create a new partials stack frame prior to exec.
        var original = container.partials;
        container.partials = _utils.extend({}, original, props.partials);
        var ret = fn(context, options);
        container.partials = original;
        return ret;
      };
    }

    props.partials[options.args[0]] = options.fn;

    return ret;
  });
};

module.exports = exports['default'];


},{"../utils":379}],366:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var errorProps = ['description', 'fileName', 'lineNumber', 'message', 'name', 'number', 'stack'];

function Exception(message, node) {
  var loc = node && node.loc,
      line = undefined,
      column = undefined;
  if (loc) {
    line = loc.start.line;
    column = loc.start.column;

    message += ' - ' + line + ':' + column;
  }

  var tmp = Error.prototype.constructor.call(this, message);

  // Unfortunately errors are not enumerable in Chrome (at least), so `for prop in tmp` doesn't work.
  for (var idx = 0; idx < errorProps.length; idx++) {
    this[errorProps[idx]] = tmp[errorProps[idx]];
  }

  /* istanbul ignore else */
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, Exception);
  }

  try {
    if (loc) {
      this.lineNumber = line;

      // Work around issue under safari where we can't directly set the column value
      /* istanbul ignore next */
      if (Object.defineProperty) {
        Object.defineProperty(this, 'column', {
          value: column,
          enumerable: true
        });
      } else {
        this.column = column;
      }
    }
  } catch (nop) {
    /* Ignore if the browser is very particular */
  }
}

Exception.prototype = new Error();

exports['default'] = Exception;
module.exports = exports['default'];


},{}],367:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports.registerDefaultHelpers = registerDefaultHelpers;
// istanbul ignore next

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _helpersBlockHelperMissing = require('./helpers/block-helper-missing');

var _helpersBlockHelperMissing2 = _interopRequireDefault(_helpersBlockHelperMissing);

var _helpersEach = require('./helpers/each');

var _helpersEach2 = _interopRequireDefault(_helpersEach);

var _helpersHelperMissing = require('./helpers/helper-missing');

var _helpersHelperMissing2 = _interopRequireDefault(_helpersHelperMissing);

var _helpersIf = require('./helpers/if');

var _helpersIf2 = _interopRequireDefault(_helpersIf);

var _helpersLog = require('./helpers/log');

var _helpersLog2 = _interopRequireDefault(_helpersLog);

var _helpersLookup = require('./helpers/lookup');

var _helpersLookup2 = _interopRequireDefault(_helpersLookup);

var _helpersWith = require('./helpers/with');

var _helpersWith2 = _interopRequireDefault(_helpersWith);

function registerDefaultHelpers(instance) {
  _helpersBlockHelperMissing2['default'](instance);
  _helpersEach2['default'](instance);
  _helpersHelperMissing2['default'](instance);
  _helpersIf2['default'](instance);
  _helpersLog2['default'](instance);
  _helpersLookup2['default'](instance);
  _helpersWith2['default'](instance);
}


},{"./helpers/block-helper-missing":368,"./helpers/each":369,"./helpers/helper-missing":370,"./helpers/if":371,"./helpers/log":372,"./helpers/lookup":373,"./helpers/with":374}],368:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _utils = require('../utils');

exports['default'] = function (instance) {
  instance.registerHelper('blockHelperMissing', function (context, options) {
    var inverse = options.inverse,
        fn = options.fn;

    if (context === true) {
      return fn(this);
    } else if (context === false || context == null) {
      return inverse(this);
    } else if (_utils.isArray(context)) {
      if (context.length > 0) {
        if (options.ids) {
          options.ids = [options.name];
        }

        return instance.helpers.each(context, options);
      } else {
        return inverse(this);
      }
    } else {
      if (options.data && options.ids) {
        var data = _utils.createFrame(options.data);
        data.contextPath = _utils.appendContextPath(options.data.contextPath, options.name);
        options = { data: data };
      }

      return fn(context, options);
    }
  });
};

module.exports = exports['default'];


},{"../utils":379}],369:[function(require,module,exports){
'use strict';

exports.__esModule = true;
// istanbul ignore next

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _utils = require('../utils');

var _exception = require('../exception');

var _exception2 = _interopRequireDefault(_exception);

exports['default'] = function (instance) {
  instance.registerHelper('each', function (context, options) {
    if (!options) {
      throw new _exception2['default']('Must pass iterator to #each');
    }

    var fn = options.fn,
        inverse = options.inverse,
        i = 0,
        ret = '',
        data = undefined,
        contextPath = undefined;

    if (options.data && options.ids) {
      contextPath = _utils.appendContextPath(options.data.contextPath, options.ids[0]) + '.';
    }

    if (_utils.isFunction(context)) {
      context = context.call(this);
    }

    if (options.data) {
      data = _utils.createFrame(options.data);
    }

    function execIteration(field, index, last) {
      if (data) {
        data.key = field;
        data.index = index;
        data.first = index === 0;
        data.last = !!last;

        if (contextPath) {
          data.contextPath = contextPath + field;
        }
      }

      ret = ret + fn(context[field], {
        data: data,
        blockParams: _utils.blockParams([context[field], field], [contextPath + field, null])
      });
    }

    if (context && typeof context === 'object') {
      if (_utils.isArray(context)) {
        for (var j = context.length; i < j; i++) {
          if (i in context) {
            execIteration(i, i, i === context.length - 1);
          }
        }
      } else {
        var priorKey = undefined;

        for (var key in context) {
          if (context.hasOwnProperty(key)) {
            // We're running the iterations one step out of sync so we can detect
            // the last iteration without have to scan the object twice and create
            // an itermediate keys array.
            if (priorKey !== undefined) {
              execIteration(priorKey, i - 1);
            }
            priorKey = key;
            i++;
          }
        }
        if (priorKey !== undefined) {
          execIteration(priorKey, i - 1, true);
        }
      }
    }

    if (i === 0) {
      ret = inverse(this);
    }

    return ret;
  });
};

module.exports = exports['default'];


},{"../exception":366,"../utils":379}],370:[function(require,module,exports){
'use strict';

exports.__esModule = true;
// istanbul ignore next

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _exception = require('../exception');

var _exception2 = _interopRequireDefault(_exception);

exports['default'] = function (instance) {
  instance.registerHelper('helperMissing', function () /* [args, ]options */{
    if (arguments.length === 1) {
      // A missing field in a {{foo}} construct.
      return undefined;
    } else {
      // Someone is actually trying to call something, blow up.
      throw new _exception2['default']('Missing helper: "' + arguments[arguments.length - 1].name + '"');
    }
  });
};

module.exports = exports['default'];


},{"../exception":366}],371:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _utils = require('../utils');

exports['default'] = function (instance) {
  instance.registerHelper('if', function (conditional, options) {
    if (_utils.isFunction(conditional)) {
      conditional = conditional.call(this);
    }

    // Default behavior is to render the positive path if the value is truthy and not empty.
    // The `includeZero` option may be set to treat the condtional as purely not empty based on the
    // behavior of isEmpty. Effectively this determines if 0 is handled by the positive path or negative.
    if (!options.hash.includeZero && !conditional || _utils.isEmpty(conditional)) {
      return options.inverse(this);
    } else {
      return options.fn(this);
    }
  });

  instance.registerHelper('unless', function (conditional, options) {
    return instance.helpers['if'].call(this, conditional, { fn: options.inverse, inverse: options.fn, hash: options.hash });
  });
};

module.exports = exports['default'];


},{"../utils":379}],372:[function(require,module,exports){
'use strict';

exports.__esModule = true;

exports['default'] = function (instance) {
  instance.registerHelper('log', function () /* message, options */{
    var args = [undefined],
        options = arguments[arguments.length - 1];
    for (var i = 0; i < arguments.length - 1; i++) {
      args.push(arguments[i]);
    }

    var level = 1;
    if (options.hash.level != null) {
      level = options.hash.level;
    } else if (options.data && options.data.level != null) {
      level = options.data.level;
    }
    args[0] = level;

    instance.log.apply(instance, args);
  });
};

module.exports = exports['default'];


},{}],373:[function(require,module,exports){
'use strict';

exports.__esModule = true;

exports['default'] = function (instance) {
  instance.registerHelper('lookup', function (obj, field) {
    return obj && obj[field];
  });
};

module.exports = exports['default'];


},{}],374:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _utils = require('../utils');

exports['default'] = function (instance) {
  instance.registerHelper('with', function (context, options) {
    if (_utils.isFunction(context)) {
      context = context.call(this);
    }

    var fn = options.fn;

    if (!_utils.isEmpty(context)) {
      var data = options.data;
      if (options.data && options.ids) {
        data = _utils.createFrame(options.data);
        data.contextPath = _utils.appendContextPath(options.data.contextPath, options.ids[0]);
      }

      return fn(context, {
        data: data,
        blockParams: _utils.blockParams([context], [data && data.contextPath])
      });
    } else {
      return options.inverse(this);
    }
  });
};

module.exports = exports['default'];


},{"../utils":379}],375:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _utils = require('./utils');

var logger = {
  methodMap: ['debug', 'info', 'warn', 'error'],
  level: 'info',

  // Maps a given level value to the `methodMap` indexes above.
  lookupLevel: function lookupLevel(level) {
    if (typeof level === 'string') {
      var levelMap = _utils.indexOf(logger.methodMap, level.toLowerCase());
      if (levelMap >= 0) {
        level = levelMap;
      } else {
        level = parseInt(level, 10);
      }
    }

    return level;
  },

  // Can be overridden in the host environment
  log: function log(level) {
    level = logger.lookupLevel(level);

    if (typeof console !== 'undefined' && logger.lookupLevel(logger.level) <= level) {
      var method = logger.methodMap[level];
      if (!console[method]) {
        // eslint-disable-line no-console
        method = 'log';
      }

      for (var _len = arguments.length, message = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        message[_key - 1] = arguments[_key];
      }

      console[method].apply(console, message); // eslint-disable-line no-console
    }
  }
};

exports['default'] = logger;
module.exports = exports['default'];


},{"./utils":379}],376:[function(require,module,exports){
(function (global){
/* global window */
'use strict';

exports.__esModule = true;

exports['default'] = function (Handlebars) {
  /* istanbul ignore next */
  var root = typeof global !== 'undefined' ? global : window,
      $Handlebars = root.Handlebars;
  /* istanbul ignore next */
  Handlebars.noConflict = function () {
    if (root.Handlebars === Handlebars) {
      root.Handlebars = $Handlebars;
    }
    return Handlebars;
  };
};

module.exports = exports['default'];


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],377:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports.checkRevision = checkRevision;
exports.template = template;
exports.wrapProgram = wrapProgram;
exports.resolvePartial = resolvePartial;
exports.invokePartial = invokePartial;
exports.noop = noop;
// istanbul ignore next

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

// istanbul ignore next

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

var _utils = require('./utils');

var Utils = _interopRequireWildcard(_utils);

var _exception = require('./exception');

var _exception2 = _interopRequireDefault(_exception);

var _base = require('./base');

function checkRevision(compilerInfo) {
  var compilerRevision = compilerInfo && compilerInfo[0] || 1,
      currentRevision = _base.COMPILER_REVISION;

  if (compilerRevision !== currentRevision) {
    if (compilerRevision < currentRevision) {
      var runtimeVersions = _base.REVISION_CHANGES[currentRevision],
          compilerVersions = _base.REVISION_CHANGES[compilerRevision];
      throw new _exception2['default']('Template was precompiled with an older version of Handlebars than the current runtime. ' + 'Please update your precompiler to a newer version (' + runtimeVersions + ') or downgrade your runtime to an older version (' + compilerVersions + ').');
    } else {
      // Use the embedded version info since the runtime doesn't know about this revision yet
      throw new _exception2['default']('Template was precompiled with a newer version of Handlebars than the current runtime. ' + 'Please update your runtime to a newer version (' + compilerInfo[1] + ').');
    }
  }
}

function template(templateSpec, env) {
  /* istanbul ignore next */
  if (!env) {
    throw new _exception2['default']('No environment passed to template');
  }
  if (!templateSpec || !templateSpec.main) {
    throw new _exception2['default']('Unknown template object: ' + typeof templateSpec);
  }

  templateSpec.main.decorator = templateSpec.main_d;

  // Note: Using env.VM references rather than local var references throughout this section to allow
  // for external users to override these as psuedo-supported APIs.
  env.VM.checkRevision(templateSpec.compiler);

  function invokePartialWrapper(partial, context, options) {
    if (options.hash) {
      context = Utils.extend({}, context, options.hash);
      if (options.ids) {
        options.ids[0] = true;
      }
    }

    partial = env.VM.resolvePartial.call(this, partial, context, options);
    var result = env.VM.invokePartial.call(this, partial, context, options);

    if (result == null && env.compile) {
      options.partials[options.name] = env.compile(partial, templateSpec.compilerOptions, env);
      result = options.partials[options.name](context, options);
    }
    if (result != null) {
      if (options.indent) {
        var lines = result.split('\n');
        for (var i = 0, l = lines.length; i < l; i++) {
          if (!lines[i] && i + 1 === l) {
            break;
          }

          lines[i] = options.indent + lines[i];
        }
        result = lines.join('\n');
      }
      return result;
    } else {
      throw new _exception2['default']('The partial ' + options.name + ' could not be compiled when running in runtime-only mode');
    }
  }

  // Just add water
  var container = {
    strict: function strict(obj, name) {
      if (!(name in obj)) {
        throw new _exception2['default']('"' + name + '" not defined in ' + obj);
      }
      return obj[name];
    },
    lookup: function lookup(depths, name) {
      var len = depths.length;
      for (var i = 0; i < len; i++) {
        if (depths[i] && depths[i][name] != null) {
          return depths[i][name];
        }
      }
    },
    lambda: function lambda(current, context) {
      return typeof current === 'function' ? current.call(context) : current;
    },

    escapeExpression: Utils.escapeExpression,
    invokePartial: invokePartialWrapper,

    fn: function fn(i) {
      var ret = templateSpec[i];
      ret.decorator = templateSpec[i + '_d'];
      return ret;
    },

    programs: [],
    program: function program(i, data, declaredBlockParams, blockParams, depths) {
      var programWrapper = this.programs[i],
          fn = this.fn(i);
      if (data || depths || blockParams || declaredBlockParams) {
        programWrapper = wrapProgram(this, i, fn, data, declaredBlockParams, blockParams, depths);
      } else if (!programWrapper) {
        programWrapper = this.programs[i] = wrapProgram(this, i, fn);
      }
      return programWrapper;
    },

    data: function data(value, depth) {
      while (value && depth--) {
        value = value._parent;
      }
      return value;
    },
    merge: function merge(param, common) {
      var obj = param || common;

      if (param && common && param !== common) {
        obj = Utils.extend({}, common, param);
      }

      return obj;
    },
    // An empty object to use as replacement for null-contexts
    nullContext: Object.seal({}),

    noop: env.VM.noop,
    compilerInfo: templateSpec.compiler
  };

  function ret(context) {
    var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

    var data = options.data;

    ret._setup(options);
    if (!options.partial && templateSpec.useData) {
      data = initData(context, data);
    }
    var depths = undefined,
        blockParams = templateSpec.useBlockParams ? [] : undefined;
    if (templateSpec.useDepths) {
      if (options.depths) {
        depths = context != options.depths[0] ? [context].concat(options.depths) : options.depths;
      } else {
        depths = [context];
      }
    }

    function main(context /*, options*/) {
      return '' + templateSpec.main(container, context, container.helpers, container.partials, data, blockParams, depths);
    }
    main = executeDecorators(templateSpec.main, main, container, options.depths || [], data, blockParams);
    return main(context, options);
  }
  ret.isTop = true;

  ret._setup = function (options) {
    if (!options.partial) {
      container.helpers = container.merge(options.helpers, env.helpers);

      if (templateSpec.usePartial) {
        container.partials = container.merge(options.partials, env.partials);
      }
      if (templateSpec.usePartial || templateSpec.useDecorators) {
        container.decorators = container.merge(options.decorators, env.decorators);
      }
    } else {
      container.helpers = options.helpers;
      container.partials = options.partials;
      container.decorators = options.decorators;
    }
  };

  ret._child = function (i, data, blockParams, depths) {
    if (templateSpec.useBlockParams && !blockParams) {
      throw new _exception2['default']('must pass block params');
    }
    if (templateSpec.useDepths && !depths) {
      throw new _exception2['default']('must pass parent depths');
    }

    return wrapProgram(container, i, templateSpec[i], data, 0, blockParams, depths);
  };
  return ret;
}

function wrapProgram(container, i, fn, data, declaredBlockParams, blockParams, depths) {
  function prog(context) {
    var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

    var currentDepths = depths;
    if (depths && context != depths[0] && !(context === container.nullContext && depths[0] === null)) {
      currentDepths = [context].concat(depths);
    }

    return fn(container, context, container.helpers, container.partials, options.data || data, blockParams && [options.blockParams].concat(blockParams), currentDepths);
  }

  prog = executeDecorators(fn, prog, container, depths, data, blockParams);

  prog.program = i;
  prog.depth = depths ? depths.length : 0;
  prog.blockParams = declaredBlockParams || 0;
  return prog;
}

function resolvePartial(partial, context, options) {
  if (!partial) {
    if (options.name === '@partial-block') {
      partial = options.data['partial-block'];
    } else {
      partial = options.partials[options.name];
    }
  } else if (!partial.call && !options.name) {
    // This is a dynamic partial that returned a string
    options.name = partial;
    partial = options.partials[partial];
  }
  return partial;
}

function invokePartial(partial, context, options) {
  // Use the current closure context to save the partial-block if this partial
  var currentPartialBlock = options.data && options.data['partial-block'];
  options.partial = true;
  if (options.ids) {
    options.data.contextPath = options.ids[0] || options.data.contextPath;
  }

  var partialBlock = undefined;
  if (options.fn && options.fn !== noop) {
    (function () {
      options.data = _base.createFrame(options.data);
      // Wrapper function to get access to currentPartialBlock from the closure
      var fn = options.fn;
      partialBlock = options.data['partial-block'] = function partialBlockWrapper(context) {
        var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

        // Restore the partial-block from the closure for the execution of the block
        // i.e. the part inside the block of the partial call.
        options.data = _base.createFrame(options.data);
        options.data['partial-block'] = currentPartialBlock;
        return fn(context, options);
      };
      if (fn.partials) {
        options.partials = Utils.extend({}, options.partials, fn.partials);
      }
    })();
  }

  if (partial === undefined && partialBlock) {
    partial = partialBlock;
  }

  if (partial === undefined) {
    throw new _exception2['default']('The partial ' + options.name + ' could not be found');
  } else if (partial instanceof Function) {
    return partial(context, options);
  }
}

function noop() {
  return '';
}

function initData(context, data) {
  if (!data || !('root' in data)) {
    data = data ? _base.createFrame(data) : {};
    data.root = context;
  }
  return data;
}

function executeDecorators(fn, prog, container, depths, data, blockParams) {
  if (fn.decorator) {
    var props = {};
    prog = fn.decorator(prog, props, container, depths && depths[0], data, blockParams, depths);
    Utils.extend(prog, props);
  }
  return prog;
}


},{"./base":363,"./exception":366,"./utils":379}],378:[function(require,module,exports){
// Build out our basic SafeString type
'use strict';

exports.__esModule = true;
function SafeString(string) {
  this.string = string;
}

SafeString.prototype.toString = SafeString.prototype.toHTML = function () {
  return '' + this.string;
};

exports['default'] = SafeString;
module.exports = exports['default'];


},{}],379:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports.extend = extend;
exports.indexOf = indexOf;
exports.escapeExpression = escapeExpression;
exports.isEmpty = isEmpty;
exports.createFrame = createFrame;
exports.blockParams = blockParams;
exports.appendContextPath = appendContextPath;
var escape = {
  '&': '&amp;',
  '<': '&lt;',
  '>': '&gt;',
  '"': '&quot;',
  "'": '&#x27;',
  '`': '&#x60;',
  '=': '&#x3D;'
};

var badChars = /[&<>"'`=]/g,
    possible = /[&<>"'`=]/;

function escapeChar(chr) {
  return escape[chr];
}

function extend(obj /* , ...source */) {
  for (var i = 1; i < arguments.length; i++) {
    for (var key in arguments[i]) {
      if (Object.prototype.hasOwnProperty.call(arguments[i], key)) {
        obj[key] = arguments[i][key];
      }
    }
  }

  return obj;
}

var toString = Object.prototype.toString;

exports.toString = toString;
// Sourced from lodash
// https://github.com/bestiejs/lodash/blob/master/LICENSE.txt
/* eslint-disable func-style */
var isFunction = function isFunction(value) {
  return typeof value === 'function';
};
// fallback for older versions of Chrome and Safari
/* istanbul ignore next */
if (isFunction(/x/)) {
  exports.isFunction = isFunction = function (value) {
    return typeof value === 'function' && toString.call(value) === '[object Function]';
  };
}
exports.isFunction = isFunction;

/* eslint-enable func-style */

/* istanbul ignore next */
var isArray = Array.isArray || function (value) {
  return value && typeof value === 'object' ? toString.call(value) === '[object Array]' : false;
};

exports.isArray = isArray;
// Older IE versions do not directly support indexOf so we must implement our own, sadly.

function indexOf(array, value) {
  for (var i = 0, len = array.length; i < len; i++) {
    if (array[i] === value) {
      return i;
    }
  }
  return -1;
}

function escapeExpression(string) {
  if (typeof string !== 'string') {
    // don't escape SafeStrings, since they're already safe
    if (string && string.toHTML) {
      return string.toHTML();
    } else if (string == null) {
      return '';
    } else if (!string) {
      return string + '';
    }

    // Force a string conversion as this will be done by the append regardless and
    // the regex test will do this transparently behind the scenes, causing issues if
    // an object's to string has escaped characters in it.
    string = '' + string;
  }

  if (!possible.test(string)) {
    return string;
  }
  return string.replace(badChars, escapeChar);
}

function isEmpty(value) {
  if (!value && value !== 0) {
    return true;
  } else if (isArray(value) && value.length === 0) {
    return true;
  } else {
    return false;
  }
}

function createFrame(object) {
  var frame = extend({}, object);
  frame._parent = object;
  return frame;
}

function blockParams(params, ids) {
  params.path = ids;
  return params;
}

function appendContextPath(contextPath, id) {
  return (contextPath ? contextPath + '.' : '') + id;
}


},{}],380:[function(require,module,exports){
// Create a simple path alias to allow browserify to resolve
// the runtime on a supported path.
module.exports = require('./dist/cjs/handlebars.runtime')['default'];

},{"./dist/cjs/handlebars.runtime":362}],381:[function(require,module,exports){
module.exports = require("handlebars/runtime")["default"];

},{"handlebars/runtime":380}],382:[function(require,module,exports){
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

},{}],383:[function(require,module,exports){
var json = typeof JSON !== 'undefined' ? JSON : require('jsonify');

module.exports = function (obj, opts) {
    if (!opts) opts = {};
    if (typeof opts === 'function') opts = { cmp: opts };
    var space = opts.space || '';
    if (typeof space === 'number') space = Array(space+1).join(' ');
    var cycles = (typeof opts.cycles === 'boolean') ? opts.cycles : false;
    var replacer = opts.replacer || function(key, value) { return value; };

    var cmp = opts.cmp && (function (f) {
        return function (node) {
            return function (a, b) {
                var aobj = { key: a, value: node[a] };
                var bobj = { key: b, value: node[b] };
                return f(aobj, bobj);
            };
        };
    })(opts.cmp);

    var seen = [];
    return (function stringify (parent, key, node, level) {
        var indent = space ? ('\n' + new Array(level + 1).join(space)) : '';
        var colonSeparator = space ? ': ' : ':';

        if (node && node.toJSON && typeof node.toJSON === 'function') {
            node = node.toJSON();
        }

        node = replacer.call(parent, key, node);

        if (node === undefined) {
            return;
        }
        if (typeof node !== 'object' || node === null) {
            return json.stringify(node);
        }
        if (isArray(node)) {
            var out = [];
            for (var i = 0; i < node.length; i++) {
                var item = stringify(node, i, node[i], level+1) || json.stringify(null);
                out.push(indent + space + item);
            }
            return '[' + out.join(',') + indent + ']';
        }
        else {
            if (seen.indexOf(node) !== -1) {
                if (cycles) return json.stringify('__cycle__');
                throw new TypeError('Converting circular structure to JSON');
            }
            else seen.push(node);

            var keys = objectKeys(node).sort(cmp && cmp(node));
            var out = [];
            for (var i = 0; i < keys.length; i++) {
                var key = keys[i];
                var value = stringify(node, key, node[key], level+1);

                if(!value) continue;

                var keyValue = json.stringify(key)
                    + colonSeparator
                    + value;
                ;
                out.push(indent + space + keyValue);
            }
            seen.splice(seen.indexOf(node), 1);
            return '{' + out.join(',') + indent + '}';
        }
    })({ '': obj }, '', obj, 0);
};

var isArray = Array.isArray || function (x) {
    return {}.toString.call(x) === '[object Array]';
};

var objectKeys = Object.keys || function (obj) {
    var has = Object.prototype.hasOwnProperty || function () { return true };
    var keys = [];
    for (var key in obj) {
        if (has.call(obj, key)) keys.push(key);
    }
    return keys;
};

},{"jsonify":384}],384:[function(require,module,exports){
exports.parse = JSON.parse;
exports.stringify = JSON.stringify;

},{}],385:[function(require,module,exports){
var indexOf = require('./indexOf');

    /**
     * Combines an array with all the items of another.
     * Does not allow duplicates and is case and type sensitive.
     */
    function combine(arr1, arr2) {
        if (arr2 == null) {
            return arr1;
        }

        var i = -1, len = arr2.length;
        while (++i < len) {
            if (indexOf(arr1, arr2[i]) === -1) {
                arr1.push(arr2[i]);
            }
        }

        return arr1;
    }
    module.exports = combine;


},{"./indexOf":392}],386:[function(require,module,exports){
var indexOf = require('./indexOf');

    /**
     * If array contains values.
     */
    function contains(arr, val) {
        return indexOf(arr, val) !== -1;
    }
    module.exports = contains;


},{"./indexOf":392}],387:[function(require,module,exports){
var unique = require('./unique');
var filter = require('./filter');
var some = require('./some');
var contains = require('./contains');
var slice = require('./slice');


    /**
     * Return a new Array with elements that aren't present in the other Arrays.
     */
    function difference(arr) {
        var arrs = slice(arguments, 1),
            result = filter(unique(arr), function(needle){
                return !some(arrs, function(haystack){
                    return contains(haystack, needle);
                });
            });
        return result;
    }

    module.exports = difference;



},{"./contains":386,"./filter":390,"./slice":396,"./some":397,"./unique":398}],388:[function(require,module,exports){
var is = require('../lang/is');
var isArray = require('../lang/isArray');
var every = require('./every');

    /**
     * Compares if both arrays have the same elements
     */
    function equals(a, b, callback){
        callback = callback || is;

        if (!isArray(a) || !isArray(b)) {
            return callback(a, b);
        }

        if (a.length !== b.length) {
            return false;
        }

        return every(a, makeCompare(callback), b);
    }

    function makeCompare(callback) {
        return function(value, i) {
            return i in this && callback(value, this[i]);
        };
    }

    module.exports = equals;



},{"../lang/is":406,"../lang/isArray":407,"./every":389}],389:[function(require,module,exports){
var makeIterator = require('../function/makeIterator_');

    /**
     * Array every
     */
    function every(arr, callback, thisObj) {
        callback = makeIterator(callback, thisObj);
        var result = true;
        if (arr == null) {
            return result;
        }

        var i = -1, len = arr.length;
        while (++i < len) {
            // we iterate over sparse items since there is no way to make it
            // work properly on IE 7-8. see #64
            if (!callback(arr[i], i, arr) ) {
                result = false;
                break;
            }
        }

        return result;
    }

    module.exports = every;


},{"../function/makeIterator_":400}],390:[function(require,module,exports){
var makeIterator = require('../function/makeIterator_');

    /**
     * Array filter
     */
    function filter(arr, callback, thisObj) {
        callback = makeIterator(callback, thisObj);
        var results = [];
        if (arr == null) {
            return results;
        }

        var i = -1, len = arr.length, value;
        while (++i < len) {
            value = arr[i];
            if (callback(value, i, arr)) {
                results.push(value);
            }
        }

        return results;
    }

    module.exports = filter;



},{"../function/makeIterator_":400}],391:[function(require,module,exports){


    /**
     * Array forEach
     */
    function forEach(arr, callback, thisObj) {
        if (arr == null) {
            return;
        }
        var i = -1,
            len = arr.length;
        while (++i < len) {
            // we iterate over sparse items since there is no way to make it
            // work properly on IE 7-8. see #64
            if ( callback.call(thisObj, arr[i], i, arr) === false ) {
                break;
            }
        }
    }

    module.exports = forEach;



},{}],392:[function(require,module,exports){


    /**
     * Array.indexOf
     */
    function indexOf(arr, item, fromIndex) {
        fromIndex = fromIndex || 0;
        if (arr == null) {
            return -1;
        }

        var len = arr.length,
            i = fromIndex < 0 ? len + fromIndex : fromIndex;
        while (i < len) {
            // we iterate over sparse items since there is no way to make it
            // work properly on IE 7-8. see #64
            if (arr[i] === item) {
                return i;
            }

            i++;
        }

        return -1;
    }

    module.exports = indexOf;


},{}],393:[function(require,module,exports){
var unique = require('./unique');
var filter = require('./filter');
var every = require('./every');
var contains = require('./contains');
var slice = require('./slice');


    /**
     * Return a new Array with elements common to all Arrays.
     * - based on underscore.js implementation
     */
    function intersection(arr) {
        var arrs = slice(arguments, 1),
            result = filter(unique(arr), function(needle){
                return every(arrs, function(haystack){
                    return contains(haystack, needle);
                });
            });
        return result;
    }

    module.exports = intersection;



},{"./contains":386,"./every":389,"./filter":390,"./slice":396,"./unique":398}],394:[function(require,module,exports){
var makeIterator = require('../function/makeIterator_');

    /**
     * Array map
     */
    function map(arr, callback, thisObj) {
        callback = makeIterator(callback, thisObj);
        var results = [];
        if (arr == null){
            return results;
        }

        var i = -1, len = arr.length;
        while (++i < len) {
            results[i] = callback(arr[i], i, arr);
        }

        return results;
    }

     module.exports = map;


},{"../function/makeIterator_":400}],395:[function(require,module,exports){
var indexOf = require('./indexOf');

    /**
     * Remove a single item from the array.
     * (it won't remove duplicates, just a single item)
     */
    function remove(arr, item){
        var idx = indexOf(arr, item);
        if (idx !== -1) arr.splice(idx, 1);
    }

    module.exports = remove;


},{"./indexOf":392}],396:[function(require,module,exports){


    /**
     * Create slice of source array or array-like object
     */
    function slice(arr, start, end){
        var len = arr.length;

        if (start == null) {
            start = 0;
        } else if (start < 0) {
            start = Math.max(len + start, 0);
        } else {
            start = Math.min(start, len);
        }

        if (end == null) {
            end = len;
        } else if (end < 0) {
            end = Math.max(len + end, 0);
        } else {
            end = Math.min(end, len);
        }

        var result = [];
        while (start < end) {
            result.push(arr[start++]);
        }

        return result;
    }

    module.exports = slice;



},{}],397:[function(require,module,exports){
var makeIterator = require('../function/makeIterator_');

    /**
     * Array some
     */
    function some(arr, callback, thisObj) {
        callback = makeIterator(callback, thisObj);
        var result = false;
        if (arr == null) {
            return result;
        }

        var i = -1, len = arr.length;
        while (++i < len) {
            // we iterate over sparse items since there is no way to make it
            // work properly on IE 7-8. see #64
            if ( callback(arr[i], i, arr) ) {
                result = true;
                break;
            }
        }

        return result;
    }

    module.exports = some;


},{"../function/makeIterator_":400}],398:[function(require,module,exports){
var filter = require('./filter');

    /**
     * @return {array} Array of unique items
     */
    function unique(arr, compare){
        compare = compare || isEqual;
        return filter(arr, function(item, i, arr){
            var n = arr.length;
            while (++i < n) {
                if ( compare(item, arr[i]) ) {
                    return false;
                }
            }
            return true;
        });
    }

    function isEqual(a, b){
        return a === b;
    }

    module.exports = unique;



},{"./filter":390}],399:[function(require,module,exports){


    /**
     * Returns the first argument provided to it.
     */
    function identity(val){
        return val;
    }

    module.exports = identity;



},{}],400:[function(require,module,exports){
var identity = require('./identity');
var prop = require('./prop');
var deepMatches = require('../object/deepMatches');

    /**
     * Converts argument into a valid iterator.
     * Used internally on most array/object/collection methods that receives a
     * callback/iterator providing a shortcut syntax.
     */
    function makeIterator(src, thisObj){
        if (src == null) {
            return identity;
        }
        switch(typeof src) {
            case 'function':
                // function is the first to improve perf (most common case)
                // also avoid using `Function#call` if not needed, which boosts
                // perf a lot in some cases
                return (typeof thisObj !== 'undefined')? function(val, i, arr){
                    return src.call(thisObj, val, i, arr);
                } : src;
            case 'object':
                return function(val){
                    return deepMatches(val, src);
                };
            case 'string':
            case 'number':
                return prop(src);
        }
    }

    module.exports = makeIterator;



},{"../object/deepMatches":415,"./identity":399,"./prop":401}],401:[function(require,module,exports){


    /**
     * Returns a function that gets a property of the passed object
     */
    function prop(name){
        return function(obj){
            return obj[name];
        };
    }

    module.exports = prop;



},{}],402:[function(require,module,exports){
var kindOf = require('./kindOf');
var isPlainObject = require('./isPlainObject');
var mixIn = require('../object/mixIn');

    /**
     * Clone native types.
     */
    function clone(val){
        switch (kindOf(val)) {
            case 'Object':
                return cloneObject(val);
            case 'Array':
                return cloneArray(val);
            case 'RegExp':
                return cloneRegExp(val);
            case 'Date':
                return cloneDate(val);
            default:
                return val;
        }
    }

    function cloneObject(source) {
        if (isPlainObject(source)) {
            return mixIn({}, source);
        } else {
            return source;
        }
    }

    function cloneRegExp(r) {
        var flags = '';
        flags += r.multiline ? 'm' : '';
        flags += r.global ? 'g' : '';
        flags += r.ignoreCase ? 'i' : '';
        return new RegExp(r.source, flags);
    }

    function cloneDate(date) {
        return new Date(+date);
    }

    function cloneArray(arr) {
        return arr.slice();
    }

    module.exports = clone;



},{"../object/mixIn":423,"./isPlainObject":411,"./kindOf":413}],403:[function(require,module,exports){
var mixIn = require('../object/mixIn');

    /**
     * Create Object using prototypal inheritance and setting custom properties.
     * - Mix between Douglas Crockford Prototypal Inheritance <http://javascript.crockford.com/prototypal.html> and the EcmaScript 5 `Object.create()` method.
     * @param {object} parent    Parent Object.
     * @param {object} [props] Object properties.
     * @return {object} Created object.
     */
    function createObject(parent, props){
        function F(){}
        F.prototype = parent;
        return mixIn(new F(), props);

    }
    module.exports = createObject;



},{"../object/mixIn":423}],404:[function(require,module,exports){
var clone = require('./clone');
var forOwn = require('../object/forOwn');
var kindOf = require('./kindOf');
var isPlainObject = require('./isPlainObject');

    /**
     * Recursively clone native types.
     */
    function deepClone(val, instanceClone) {
        switch ( kindOf(val) ) {
            case 'Object':
                return cloneObject(val, instanceClone);
            case 'Array':
                return cloneArray(val, instanceClone);
            default:
                return clone(val);
        }
    }

    function cloneObject(source, instanceClone) {
        if (isPlainObject(source)) {
            var out = {};
            forOwn(source, function(val, key) {
                this[key] = deepClone(val, instanceClone);
            }, out);
            return out;
        } else if (instanceClone) {
            return instanceClone(source);
        } else {
            return source;
        }
    }

    function cloneArray(arr, instanceClone) {
        var out = [],
            i = -1,
            n = arr.length,
            val;
        while (++i < n) {
            out[i] = deepClone(arr[i], instanceClone);
        }
        return out;
    }

    module.exports = deepClone;




},{"../object/forOwn":420,"./clone":402,"./isPlainObject":411,"./kindOf":413}],405:[function(require,module,exports){
var is = require('./is');
var isObject = require('./isObject');
var isArray = require('./isArray');
var objEquals = require('../object/equals');
var arrEquals = require('../array/equals');

    /**
     * Recursively checks for same properties and values.
     */
    function deepEquals(a, b, callback){
        callback = callback || is;

        var bothObjects = isObject(a) && isObject(b);
        var bothArrays = !bothObjects && isArray(a) && isArray(b);

        if (!bothObjects && !bothArrays) {
            return callback(a, b);
        }

        function compare(a, b){
            return deepEquals(a, b, callback);
        }

        var method = bothObjects ? objEquals : arrEquals;
        return method(a, b, compare);
    }

    module.exports = deepEquals;



},{"../array/equals":388,"../object/equals":417,"./is":406,"./isArray":407,"./isObject":410}],406:[function(require,module,exports){


    /**
     * Check if both arguments are egal.
     */
    function is(x, y){
        // implementation borrowed from harmony:egal spec
        if (x === y) {
          // 0 === -0, but they are not identical
          return x !== 0 || 1 / x === 1 / y;
        }

        // NaN !== NaN, but they are identical.
        // NaNs are the only non-reflexive value, i.e., if x !== x,
        // then x is a NaN.
        // isNaN is broken: it converts its argument to number, so
        // isNaN("foo") => true
        return x !== x && y !== y;
    }

    module.exports = is;



},{}],407:[function(require,module,exports){
var isKind = require('./isKind');
    /**
     */
    var isArray = Array.isArray || function (val) {
        return isKind(val, 'Array');
    };
    module.exports = isArray;


},{"./isKind":408}],408:[function(require,module,exports){
var kindOf = require('./kindOf');
    /**
     * Check if value is from a specific "kind".
     */
    function isKind(val, kind){
        return kindOf(val) === kind;
    }
    module.exports = isKind;


},{"./kindOf":413}],409:[function(require,module,exports){
var isKind = require('./isKind');
    /**
     */
    function isNumber(val) {
        return isKind(val, 'Number');
    }
    module.exports = isNumber;


},{"./isKind":408}],410:[function(require,module,exports){
var isKind = require('./isKind');
    /**
     */
    function isObject(val) {
        return isKind(val, 'Object');
    }
    module.exports = isObject;


},{"./isKind":408}],411:[function(require,module,exports){


    /**
     * Checks if the value is created by the `Object` constructor.
     */
    function isPlainObject(value) {
        return (!!value && typeof value === 'object' &&
            value.constructor === Object);
    }

    module.exports = isPlainObject;



},{}],412:[function(require,module,exports){
var isKind = require('./isKind');
    /**
     */
    function isRegExp(val) {
        return isKind(val, 'RegExp');
    }
    module.exports = isRegExp;


},{"./isKind":408}],413:[function(require,module,exports){

    /**
     * Gets the "kind" of value. (e.g. "String", "Number", etc)
     */
    function kindOf(val) {
        return Object.prototype.toString.call(val).slice(8, -1);
    }
    module.exports = kindOf;


},{}],414:[function(require,module,exports){


    /**
     * Typecast a value to a String, using an empty string value for null or
     * undefined.
     */
    function toString(val){
        return val == null ? '' : val.toString();
    }

    module.exports = toString;



},{}],415:[function(require,module,exports){
var forOwn = require('./forOwn');
var isArray = require('../lang/isArray');

    function containsMatch(array, pattern) {
        var i = -1, length = array.length;
        while (++i < length) {
            if (deepMatches(array[i], pattern)) {
                return true;
            }
        }

        return false;
    }

    function matchArray(target, pattern) {
        var i = -1, patternLength = pattern.length;
        while (++i < patternLength) {
            if (!containsMatch(target, pattern[i])) {
                return false;
            }
        }

        return true;
    }

    function matchObject(target, pattern) {
        var result = true;
        forOwn(pattern, function(val, key) {
            if (!deepMatches(target[key], val)) {
                // Return false to break out of forOwn early
                return (result = false);
            }
        });

        return result;
    }

    /**
     * Recursively check if the objects match.
     */
    function deepMatches(target, pattern){
        if (target && typeof target === 'object' &&
            pattern && typeof pattern === 'object') {
            if (isArray(target) && isArray(pattern)) {
                return matchArray(target, pattern);
            } else {
                return matchObject(target, pattern);
            }
        } else {
            return target === pattern;
        }
    }

    module.exports = deepMatches;



},{"../lang/isArray":407,"./forOwn":420}],416:[function(require,module,exports){
var forOwn = require('./forOwn');
var isPlainObject = require('../lang/isPlainObject');

    /**
     * Mixes objects into the target object, recursively mixing existing child
     * objects.
     */
    function deepMixIn(target, objects) {
        var i = 0,
            n = arguments.length,
            obj;

        while(++i < n){
            obj = arguments[i];
            if (obj) {
                forOwn(obj, copyProp, target);
            }
        }

        return target;
    }

    function copyProp(val, key) {
        var existing = this[key];
        if (isPlainObject(val) && isPlainObject(existing)) {
            deepMixIn(existing, val);
        } else {
            this[key] = val;
        }
    }

    module.exports = deepMixIn;



},{"../lang/isPlainObject":411,"./forOwn":420}],417:[function(require,module,exports){
var hasOwn = require('./hasOwn');
var every = require('./every');
var isObject = require('../lang/isObject');
var is = require('../lang/is');

    // Makes a function to compare the object values from the specified compare
    // operation callback.
    function makeCompare(callback) {
        return function(value, key) {
            return hasOwn(this, key) && callback(value, this[key]);
        };
    }

    function checkProperties(value, key) {
        return hasOwn(this, key);
    }

    /**
     * Checks if two objects have the same keys and values.
     */
    function equals(a, b, callback) {
        callback = callback || is;

        if (!isObject(a) || !isObject(b)) {
            return callback(a, b);
        }

        return (every(a, makeCompare(callback), b) &&
                every(b, checkProperties, a));
    }

    module.exports = equals;


},{"../lang/is":406,"../lang/isObject":410,"./every":418,"./hasOwn":421}],418:[function(require,module,exports){
var forOwn = require('./forOwn');
var makeIterator = require('../function/makeIterator_');

    /**
     * Object every
     */
    function every(obj, callback, thisObj) {
        callback = makeIterator(callback, thisObj);
        var result = true;
        forOwn(obj, function(val, key) {
            // we consider any falsy values as "false" on purpose so shorthand
            // syntax can be used to check property existence
            if (!callback(val, key, obj)) {
                result = false;
                return false; // break
            }
        });
        return result;
    }

    module.exports = every;



},{"../function/makeIterator_":400,"./forOwn":420}],419:[function(require,module,exports){
var hasOwn = require('./hasOwn');

    var _hasDontEnumBug,
        _dontEnums;

    function checkDontEnum(){
        _dontEnums = [
                'toString',
                'toLocaleString',
                'valueOf',
                'hasOwnProperty',
                'isPrototypeOf',
                'propertyIsEnumerable',
                'constructor'
            ];

        _hasDontEnumBug = true;

        for (var key in {'toString': null}) {
            _hasDontEnumBug = false;
        }
    }

    /**
     * Similar to Array/forEach but works over object properties and fixes Don't
     * Enum bug on IE.
     * based on: http://whattheheadsaid.com/2010/10/a-safer-object-keys-compatibility-implementation
     */
    function forIn(obj, fn, thisObj){
        var key, i = 0;
        // no need to check if argument is a real object that way we can use
        // it for arrays, functions, date, etc.

        //post-pone check till needed
        if (_hasDontEnumBug == null) checkDontEnum();

        for (key in obj) {
            if (exec(fn, obj, key, thisObj) === false) {
                break;
            }
        }


        if (_hasDontEnumBug) {
            var ctor = obj.constructor,
                isProto = !!ctor && obj === ctor.prototype;

            while (key = _dontEnums[i++]) {
                // For constructor, if it is a prototype object the constructor
                // is always non-enumerable unless defined otherwise (and
                // enumerated above).  For non-prototype objects, it will have
                // to be defined on this object, since it cannot be defined on
                // any prototype objects.
                //
                // For other [[DontEnum]] properties, check if the value is
                // different than Object prototype value.
                if (
                    (key !== 'constructor' ||
                        (!isProto && hasOwn(obj, key))) &&
                    obj[key] !== Object.prototype[key]
                ) {
                    if (exec(fn, obj, key, thisObj) === false) {
                        break;
                    }
                }
            }
        }
    }

    function exec(fn, obj, key, thisObj){
        return fn.call(thisObj, obj[key], key, obj);
    }

    module.exports = forIn;



},{"./hasOwn":421}],420:[function(require,module,exports){
var hasOwn = require('./hasOwn');
var forIn = require('./forIn');

    /**
     * Similar to Array/forEach but works over object properties and fixes Don't
     * Enum bug on IE.
     * based on: http://whattheheadsaid.com/2010/10/a-safer-object-keys-compatibility-implementation
     */
    function forOwn(obj, fn, thisObj){
        forIn(obj, function(val, key){
            if (hasOwn(obj, key)) {
                return fn.call(thisObj, obj[key], key, obj);
            }
        });
    }

    module.exports = forOwn;



},{"./forIn":419,"./hasOwn":421}],421:[function(require,module,exports){


    /**
     * Safer Object.hasOwnProperty
     */
     function hasOwn(obj, prop){
         return Object.prototype.hasOwnProperty.call(obj, prop);
     }

     module.exports = hasOwn;



},{}],422:[function(require,module,exports){
var hasOwn = require('./hasOwn');
var deepClone = require('../lang/deepClone');
var isObject = require('../lang/isObject');

    /**
     * Deep merge objects.
     */
    function merge() {
        var i = 1,
            key, val, obj, target;

        // make sure we don't modify source element and it's properties
        // objects are passed by reference
        target = deepClone( arguments[0] );

        while (obj = arguments[i++]) {
            for (key in obj) {
                if ( ! hasOwn(obj, key) ) {
                    continue;
                }

                val = obj[key];

                if ( isObject(val) && isObject(target[key]) ){
                    // inception, deep merge objects
                    target[key] = merge(target[key], val);
                } else {
                    // make sure arrays, regexp, date, objects are cloned
                    target[key] = deepClone(val);
                }

            }
        }

        return target;
    }

    module.exports = merge;



},{"../lang/deepClone":404,"../lang/isObject":410,"./hasOwn":421}],423:[function(require,module,exports){
var forOwn = require('./forOwn');

    /**
    * Combine properties from all the objects into first one.
    * - This method affects target object in place, if you want to create a new Object pass an empty object as first param.
    * @param {object} target    Target Object
    * @param {...object} objects    Objects to be combined (0...n objects).
    * @return {object} Target Object.
    */
    function mixIn(target, objects){
        var i = 0,
            n = arguments.length,
            obj;
        while(++i < n){
            obj = arguments[i];
            if (obj != null) {
                forOwn(obj, copyProp, target);
            }
        }
        return target;
    }

    function copyProp(val, key){
        this[key] = val;
    }

    module.exports = mixIn;


},{"./forOwn":420}],424:[function(require,module,exports){
var slice = require('../array/slice');

    /**
     * Return a copy of the object, filtered to only have values for the whitelisted keys.
     */
    function pick(obj, var_keys){
        var keys = typeof arguments[1] !== 'string'? arguments[1] : slice(arguments, 1),
            out = {},
            i = 0, key;
        while (key = keys[i++]) {
            out[key] = obj[key];
        }
        return out;
    }

    module.exports = pick;



},{"../array/slice":396}],425:[function(require,module,exports){

    /**
     * Contains all Unicode white-spaces. Taken from
     * http://en.wikipedia.org/wiki/Whitespace_character.
     */
    module.exports = [
        ' ', '\n', '\r', '\t', '\f', '\v', '\u00A0', '\u1680', '\u180E',
        '\u2000', '\u2001', '\u2002', '\u2003', '\u2004', '\u2005', '\u2006',
        '\u2007', '\u2008', '\u2009', '\u200A', '\u2028', '\u2029', '\u202F',
        '\u205F', '\u3000'
    ];


},{}],426:[function(require,module,exports){
var toString = require('../lang/toString');

    /**
     * Escape RegExp string chars.
     */
    function escapeRegExp(str) {
        return toString(str).replace(/\W/g,'\\$&');
    }

    module.exports = escapeRegExp;



},{"../lang/toString":414}],427:[function(require,module,exports){
var toString = require('../lang/toString');
var WHITE_SPACES = require('./WHITE_SPACES');
    /**
     * Remove chars from beginning of string.
     */
    function ltrim(str, chars) {
        str = toString(str);
        chars = chars || WHITE_SPACES;

        var start = 0,
            len = str.length,
            charLen = chars.length,
            found = true,
            i, c;

        while (found && start < len) {
            found = false;
            i = -1;
            c = str.charAt(start);

            while (++i < charLen) {
                if (c === chars[i]) {
                    found = true;
                    start++;
                    break;
                }
            }
        }

        return (start >= len) ? '' : str.substr(start, len);
    }

    module.exports = ltrim;


},{"../lang/toString":414,"./WHITE_SPACES":425}],428:[function(require,module,exports){
var toString = require('../lang/toString');
var WHITE_SPACES = require('./WHITE_SPACES');
    /**
     * Remove chars from end of string.
     */
    function rtrim(str, chars) {
        str = toString(str);
        chars = chars || WHITE_SPACES;

        var end = str.length - 1,
            charLen = chars.length,
            found = true,
            i, c;

        while (found && end >= 0) {
            found = false;
            i = -1;
            c = str.charAt(end);

            while (++i < charLen) {
                if (c === chars[i]) {
                    found = true;
                    end--;
                    break;
                }
            }
        }

        return (end >= 0) ? str.substring(0, end + 1) : '';
    }

    module.exports = rtrim;


},{"../lang/toString":414,"./WHITE_SPACES":425}],429:[function(require,module,exports){
var toString = require('../lang/toString');
var WHITE_SPACES = require('./WHITE_SPACES');
var ltrim = require('./ltrim');
var rtrim = require('./rtrim');
    /**
     * Remove white-spaces from beginning and end of string.
     */
    function trim(str, chars) {
        str = toString(str);
        chars = chars || WHITE_SPACES;
        return ltrim(rtrim(str, chars), chars);
    }

    module.exports = trim;


},{"../lang/toString":414,"./WHITE_SPACES":425,"./ltrim":427,"./rtrim":428}],430:[function(require,module,exports){


    /**
     * Get current time in miliseconds
     */
    function now(){
        // yes, we defer the work to another function to allow mocking it
        // during the tests
        return now.get();
    }

    now.get = (typeof Date.now === 'function')? Date.now : function(){
        return +(new Date());
    };

    module.exports = now;



},{}],431:[function(require,module,exports){
/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */

module.exports = function(val, options) {
  options = options || {};
  var type = typeof val;
  if (type === 'string' && val.length > 0) {
    return parse(val);
  } else if (type === 'number' && isNaN(val) === false) {
    return options.long ? fmtLong(val) : fmtShort(val);
  }
  throw new Error(
    'val is not a non-empty string or a valid number. val=' +
      JSON.stringify(val)
  );
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  str = String(str);
  if (str.length > 100) {
    return;
  }
  var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(
    str
  );
  if (!match) {
    return;
  }
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
    default:
      return undefined;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtShort(ms) {
  if (ms >= d) {
    return Math.round(ms / d) + 'd';
  }
  if (ms >= h) {
    return Math.round(ms / h) + 'h';
  }
  if (ms >= m) {
    return Math.round(ms / m) + 'm';
  }
  if (ms >= s) {
    return Math.round(ms / s) + 's';
  }
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtLong(ms) {
  return plural(ms, d, 'day') ||
    plural(ms, h, 'hour') ||
    plural(ms, m, 'minute') ||
    plural(ms, s, 'second') ||
    ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, n, name) {
  if (ms < n) {
    return;
  }
  if (ms < n * 1.5) {
    return Math.floor(ms / n) + ' ' + name;
  }
  return Math.ceil(ms / n) + ' ' + name + 's';
}

},{}],432:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],433:[function(require,module,exports){
function RavenConfigError(message) {
  this.name = 'RavenConfigError';
  this.message = message;
}
RavenConfigError.prototype = new Error();
RavenConfigError.prototype.constructor = RavenConfigError;

module.exports = RavenConfigError;

},{}],434:[function(require,module,exports){
var utils = require('./utils');

var wrapMethod = function(console, level, callback) {
  var originalConsoleLevel = console[level];
  var originalConsole = console;

  if (!(level in console)) {
    return;
  }

  var sentryLevel = level === 'warn' ? 'warning' : level;

  console[level] = function() {
    var args = [].slice.call(arguments);

    var msg = utils.safeJoin(args, ' ');
    var data = {level: sentryLevel, logger: 'console', extra: {arguments: args}};

    if (level === 'assert') {
      if (args[0] === false) {
        // Default browsers message
        msg =
          'Assertion failed: ' + (utils.safeJoin(args.slice(1), ' ') || 'console.assert');
        data.extra.arguments = args.slice(1);
        callback && callback(msg, data);
      }
    } else {
      callback && callback(msg, data);
    }

    // this fails for some browsers. :(
    if (originalConsoleLevel) {
      // IE9 doesn't allow calling apply on console functions directly
      // See: https://stackoverflow.com/questions/5472938/does-ie9-support-console-log-and-is-it-a-real-function#answer-5473193
      Function.prototype.apply.call(originalConsoleLevel, originalConsole, args);
    }
  };
};

module.exports = {
  wrapMethod: wrapMethod
};

},{"./utils":437}],435:[function(require,module,exports){
(function (global){
/*global XDomainRequest:false */

var TraceKit = require('../vendor/TraceKit/tracekit');
var stringify = require('../vendor/json-stringify-safe/stringify');
var md5 = require('../vendor/md5/md5');
var RavenConfigError = require('./configError');

var utils = require('./utils');
var isErrorEvent = utils.isErrorEvent;
var isDOMError = utils.isDOMError;
var isDOMException = utils.isDOMException;
var isError = utils.isError;
var isObject = utils.isObject;
var isPlainObject = utils.isPlainObject;
var isUndefined = utils.isUndefined;
var isFunction = utils.isFunction;
var isString = utils.isString;
var isArray = utils.isArray;
var isEmptyObject = utils.isEmptyObject;
var each = utils.each;
var objectMerge = utils.objectMerge;
var truncate = utils.truncate;
var objectFrozen = utils.objectFrozen;
var hasKey = utils.hasKey;
var joinRegExp = utils.joinRegExp;
var urlencode = utils.urlencode;
var uuid4 = utils.uuid4;
var htmlTreeAsString = utils.htmlTreeAsString;
var isSameException = utils.isSameException;
var isSameStacktrace = utils.isSameStacktrace;
var parseUrl = utils.parseUrl;
var fill = utils.fill;
var supportsFetch = utils.supportsFetch;
var supportsReferrerPolicy = utils.supportsReferrerPolicy;
var serializeKeysForMessage = utils.serializeKeysForMessage;
var serializeException = utils.serializeException;
var sanitize = utils.sanitize;

var wrapConsoleMethod = require('./console').wrapMethod;

var dsnKeys = 'source protocol user pass host port path'.split(' '),
  dsnPattern = /^(?:(\w+):)?\/\/(?:(\w+)(:\w+)?@)?([\w\.-]+)(?::(\d+))?(\/.*)/;

function now() {
  return +new Date();
}

// This is to be defensive in environments where window does not exist (see https://github.com/getsentry/raven-js/pull/785)
var _window =
  typeof window !== 'undefined'
    ? window
    : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};
var _document = _window.document;
var _navigator = _window.navigator;

function keepOriginalCallback(original, callback) {
  return isFunction(callback)
    ? function(data) {
        return callback(data, original);
      }
    : callback;
}

// First, check for JSON support
// If there is no JSON, we no-op the core features of Raven
// since JSON is required to encode the payload
function Raven() {
  this._hasJSON = !!(typeof JSON === 'object' && JSON.stringify);
  // Raven can run in contexts where there's no document (react-native)
  this._hasDocument = !isUndefined(_document);
  this._hasNavigator = !isUndefined(_navigator);
  this._lastCapturedException = null;
  this._lastData = null;
  this._lastEventId = null;
  this._globalServer = null;
  this._globalKey = null;
  this._globalProject = null;
  this._globalContext = {};
  this._globalOptions = {
    // SENTRY_RELEASE can be injected by https://github.com/getsentry/sentry-webpack-plugin
    release: _window.SENTRY_RELEASE && _window.SENTRY_RELEASE.id,
    logger: 'javascript',
    ignoreErrors: [],
    ignoreUrls: [],
    whitelistUrls: [],
    includePaths: [],
    headers: null,
    collectWindowErrors: true,
    captureUnhandledRejections: true,
    maxMessageLength: 0,
    // By default, truncates URL values to 250 chars
    maxUrlLength: 250,
    stackTraceLimit: 50,
    autoBreadcrumbs: true,
    instrument: true,
    sampleRate: 1,
    sanitizeKeys: []
  };
  this._fetchDefaults = {
    method: 'POST',
    keepalive: true,
    // Despite all stars in the sky saying that Edge supports old draft syntax, aka 'never', 'always', 'origin' and 'default
    // https://caniuse.com/#feat=referrer-policy
    // It doesn't. And it throw exception instead of ignoring this parameter...
    // REF: https://github.com/getsentry/raven-js/issues/1233
    referrerPolicy: supportsReferrerPolicy() ? 'origin' : ''
  };
  this._ignoreOnError = 0;
  this._isRavenInstalled = false;
  this._originalErrorStackTraceLimit = Error.stackTraceLimit;
  // capture references to window.console *and* all its methods first
  // before the console plugin has a chance to monkey patch
  this._originalConsole = _window.console || {};
  this._originalConsoleMethods = {};
  this._plugins = [];
  this._startTime = now();
  this._wrappedBuiltIns = [];
  this._breadcrumbs = [];
  this._lastCapturedEvent = null;
  this._keypressTimeout;
  this._location = _window.location;
  this._lastHref = this._location && this._location.href;
  this._resetBackoff();

  // eslint-disable-next-line guard-for-in
  for (var method in this._originalConsole) {
    this._originalConsoleMethods[method] = this._originalConsole[method];
  }
}

/*
 * The core Raven singleton
 *
 * @this {Raven}
 */

Raven.prototype = {
  // Hardcode version string so that raven source can be loaded directly via
  // webpack (using a build step causes webpack #1617). Grunt verifies that
  // this value matches package.json during build.
  //   See: https://github.com/getsentry/raven-js/issues/465
  VERSION: '3.26.2',

  debug: false,

  TraceKit: TraceKit, // alias to TraceKit

  /*
     * Configure Raven with a DSN and extra options
     *
     * @param {string} dsn The public Sentry DSN
     * @param {object} options Set of global options [optional]
     * @return {Raven}
     */
  config: function(dsn, options) {
    var self = this;

    if (self._globalServer) {
      this._logDebug('error', 'Error: Raven has already been configured');
      return self;
    }
    if (!dsn) return self;

    var globalOptions = self._globalOptions;

    // merge in options
    if (options) {
      each(options, function(key, value) {
        // tags and extra are special and need to be put into context
        if (key === 'tags' || key === 'extra' || key === 'user') {
          self._globalContext[key] = value;
        } else {
          globalOptions[key] = value;
        }
      });
    }

    self.setDSN(dsn);

    // "Script error." is hard coded into browsers for errors that it can't read.
    // this is the result of a script being pulled in from an external domain and CORS.
    globalOptions.ignoreErrors.push(/^Script error\.?$/);
    globalOptions.ignoreErrors.push(/^Javascript error: Script error\.? on line 0$/);

    // join regexp rules into one big rule
    globalOptions.ignoreErrors = joinRegExp(globalOptions.ignoreErrors);
    globalOptions.ignoreUrls = globalOptions.ignoreUrls.length
      ? joinRegExp(globalOptions.ignoreUrls)
      : false;
    globalOptions.whitelistUrls = globalOptions.whitelistUrls.length
      ? joinRegExp(globalOptions.whitelistUrls)
      : false;
    globalOptions.includePaths = joinRegExp(globalOptions.includePaths);
    globalOptions.maxBreadcrumbs = Math.max(
      0,
      Math.min(globalOptions.maxBreadcrumbs || 100, 100)
    ); // default and hard limit is 100

    var autoBreadcrumbDefaults = {
      xhr: true,
      console: true,
      dom: true,
      location: true,
      sentry: true
    };

    var autoBreadcrumbs = globalOptions.autoBreadcrumbs;
    if ({}.toString.call(autoBreadcrumbs) === '[object Object]') {
      autoBreadcrumbs = objectMerge(autoBreadcrumbDefaults, autoBreadcrumbs);
    } else if (autoBreadcrumbs !== false) {
      autoBreadcrumbs = autoBreadcrumbDefaults;
    }
    globalOptions.autoBreadcrumbs = autoBreadcrumbs;

    var instrumentDefaults = {
      tryCatch: true
    };

    var instrument = globalOptions.instrument;
    if ({}.toString.call(instrument) === '[object Object]') {
      instrument = objectMerge(instrumentDefaults, instrument);
    } else if (instrument !== false) {
      instrument = instrumentDefaults;
    }
    globalOptions.instrument = instrument;

    TraceKit.collectWindowErrors = !!globalOptions.collectWindowErrors;

    // return for chaining
    return self;
  },

  /*
     * Installs a global window.onerror error handler
     * to capture and report uncaught exceptions.
     * At this point, install() is required to be called due
     * to the way TraceKit is set up.
     *
     * @return {Raven}
     */
  install: function() {
    var self = this;
    if (self.isSetup() && !self._isRavenInstalled) {
      TraceKit.report.subscribe(function() {
        self._handleOnErrorStackInfo.apply(self, arguments);
      });

      if (self._globalOptions.captureUnhandledRejections) {
        self._attachPromiseRejectionHandler();
      }

      self._patchFunctionToString();

      if (self._globalOptions.instrument && self._globalOptions.instrument.tryCatch) {
        self._instrumentTryCatch();
      }

      if (self._globalOptions.autoBreadcrumbs) self._instrumentBreadcrumbs();

      // Install all of the plugins
      self._drainPlugins();

      self._isRavenInstalled = true;
    }

    Error.stackTraceLimit = self._globalOptions.stackTraceLimit;
    return this;
  },

  /*
     * Set the DSN (can be called multiple time unlike config)
     *
     * @param {string} dsn The public Sentry DSN
     */
  setDSN: function(dsn) {
    var self = this,
      uri = self._parseDSN(dsn),
      lastSlash = uri.path.lastIndexOf('/'),
      path = uri.path.substr(1, lastSlash);

    self._dsn = dsn;
    self._globalKey = uri.user;
    self._globalSecret = uri.pass && uri.pass.substr(1);
    self._globalProject = uri.path.substr(lastSlash + 1);

    self._globalServer = self._getGlobalServer(uri);

    self._globalEndpoint =
      self._globalServer + '/' + path + 'api/' + self._globalProject + '/store/';

    // Reset backoff state since we may be pointing at a
    // new project/server
    this._resetBackoff();
  },

  /*
     * Wrap code within a context so Raven can capture errors
     * reliably across domains that is executed immediately.
     *
     * @param {object} options A specific set of options for this context [optional]
     * @param {function} func The callback to be immediately executed within the context
     * @param {array} args An array of arguments to be called with the callback [optional]
     */
  context: function(options, func, args) {
    if (isFunction(options)) {
      args = func || [];
      func = options;
      options = {};
    }

    return this.wrap(options, func).apply(this, args);
  },

  /*
     * Wrap code within a context and returns back a new function to be executed
     *
     * @param {object} options A specific set of options for this context [optional]
     * @param {function} func The function to be wrapped in a new context
     * @param {function} _before A function to call before the try/catch wrapper [optional, private]
     * @return {function} The newly wrapped functions with a context
     */
  wrap: function(options, func, _before) {
    var self = this;
    // 1 argument has been passed, and it's not a function
    // so just return it
    if (isUndefined(func) && !isFunction(options)) {
      return options;
    }

    // options is optional
    if (isFunction(options)) {
      func = options;
      options = undefined;
    }

    // At this point, we've passed along 2 arguments, and the second one
    // is not a function either, so we'll just return the second argument.
    if (!isFunction(func)) {
      return func;
    }

    // We don't wanna wrap it twice!
    try {
      if (func.__raven__) {
        return func;
      }

      // If this has already been wrapped in the past, return that
      if (func.__raven_wrapper__) {
        return func.__raven_wrapper__;
      }
    } catch (e) {
      // Just accessing custom props in some Selenium environments
      // can cause a "Permission denied" exception (see raven-js#495).
      // Bail on wrapping and return the function as-is (defers to window.onerror).
      return func;
    }

    function wrapped() {
      var args = [],
        i = arguments.length,
        deep = !options || (options && options.deep !== false);

      if (_before && isFunction(_before)) {
        _before.apply(this, arguments);
      }

      // Recursively wrap all of a function's arguments that are
      // functions themselves.
      while (i--) args[i] = deep ? self.wrap(options, arguments[i]) : arguments[i];

      try {
        // Attempt to invoke user-land function
        // NOTE: If you are a Sentry user, and you are seeing this stack frame, it
        //       means Raven caught an error invoking your application code. This is
        //       expected behavior and NOT indicative of a bug with Raven.js.
        return func.apply(this, args);
      } catch (e) {
        self._ignoreNextOnError();
        self.captureException(e, options);
        throw e;
      }
    }

    // copy over properties of the old function
    for (var property in func) {
      if (hasKey(func, property)) {
        wrapped[property] = func[property];
      }
    }
    wrapped.prototype = func.prototype;

    func.__raven_wrapper__ = wrapped;
    // Signal that this function has been wrapped/filled already
    // for both debugging and to prevent it to being wrapped/filled twice
    wrapped.__raven__ = true;
    wrapped.__orig__ = func;

    return wrapped;
  },

  /**
   * Uninstalls the global error handler.
   *
   * @return {Raven}
   */
  uninstall: function() {
    TraceKit.report.uninstall();

    this._detachPromiseRejectionHandler();
    this._unpatchFunctionToString();
    this._restoreBuiltIns();
    this._restoreConsole();

    Error.stackTraceLimit = this._originalErrorStackTraceLimit;
    this._isRavenInstalled = false;

    return this;
  },

  /**
   * Callback used for `unhandledrejection` event
   *
   * @param {PromiseRejectionEvent} event An object containing
   *   promise: the Promise that was rejected
   *   reason: the value with which the Promise was rejected
   * @return void
   */
  _promiseRejectionHandler: function(event) {
    this._logDebug('debug', 'Raven caught unhandled promise rejection:', event);
    this.captureException(event.reason, {
      mechanism: {
        type: 'onunhandledrejection',
        handled: false
      }
    });
  },

  /**
   * Installs the global promise rejection handler.
   *
   * @return {raven}
   */
  _attachPromiseRejectionHandler: function() {
    this._promiseRejectionHandler = this._promiseRejectionHandler.bind(this);
    _window.addEventListener &&
      _window.addEventListener('unhandledrejection', this._promiseRejectionHandler);
    return this;
  },

  /**
   * Uninstalls the global promise rejection handler.
   *
   * @return {raven}
   */
  _detachPromiseRejectionHandler: function() {
    _window.removeEventListener &&
      _window.removeEventListener('unhandledrejection', this._promiseRejectionHandler);
    return this;
  },

  /**
   * Manually capture an exception and send it over to Sentry
   *
   * @param {error} ex An exception to be logged
   * @param {object} options A specific set of options for this error [optional]
   * @return {Raven}
   */
  captureException: function(ex, options) {
    options = objectMerge({trimHeadFrames: 0}, options ? options : {});

    if (isErrorEvent(ex) && ex.error) {
      // If it is an ErrorEvent with `error` property, extract it to get actual Error
      ex = ex.error;
    } else if (isDOMError(ex) || isDOMException(ex)) {
      // If it is a DOMError or DOMException (which are legacy APIs, but still supported in some browsers)
      // then we just extract the name and message, as they don't provide anything else
      // https://developer.mozilla.org/en-US/docs/Web/API/DOMError
      // https://developer.mozilla.org/en-US/docs/Web/API/DOMException
      var name = ex.name || (isDOMError(ex) ? 'DOMError' : 'DOMException');
      var message = ex.message ? name + ': ' + ex.message : name;

      return this.captureMessage(
        message,
        objectMerge(options, {
          // neither DOMError or DOMException provide stack trace and we most likely wont get it this way as well
          // but it's barely any overhead so we may at least try
          stacktrace: true,
          trimHeadFrames: options.trimHeadFrames + 1
        })
      );
    } else if (isError(ex)) {
      // we have a real Error object
      ex = ex;
    } else if (isPlainObject(ex)) {
      // If it is plain Object, serialize it manually and extract options
      // This will allow us to group events based on top-level keys
      // which is much better than creating new group when any key/value change
      options = this._getCaptureExceptionOptionsFromPlainObject(options, ex);
      ex = new Error(options.message);
    } else {
      // If none of previous checks were valid, then it means that
      // it's not a DOMError/DOMException
      // it's not a plain Object
      // it's not a valid ErrorEvent (one with an error property)
      // it's not an Error
      // So bail out and capture it as a simple message:
      return this.captureMessage(
        ex,
        objectMerge(options, {
          stacktrace: true, // if we fall back to captureMessage, default to attempting a new trace
          trimHeadFrames: options.trimHeadFrames + 1
        })
      );
    }

    // Store the raw exception object for potential debugging and introspection
    this._lastCapturedException = ex;

    // TraceKit.report will re-raise any exception passed to it,
    // which means you have to wrap it in try/catch. Instead, we
    // can wrap it here and only re-raise if TraceKit.report
    // raises an exception different from the one we asked to
    // report on.
    try {
      var stack = TraceKit.computeStackTrace(ex);
      this._handleStackInfo(stack, options);
    } catch (ex1) {
      if (ex !== ex1) {
        throw ex1;
      }
    }

    return this;
  },

  _getCaptureExceptionOptionsFromPlainObject: function(currentOptions, ex) {
    var exKeys = Object.keys(ex).sort();
    var options = objectMerge(currentOptions, {
      message:
        'Non-Error exception captured with keys: ' + serializeKeysForMessage(exKeys),
      fingerprint: [md5(exKeys)],
      extra: currentOptions.extra || {}
    });
    options.extra.__serialized__ = serializeException(ex);

    return options;
  },

  /*
     * Manually send a message to Sentry
     *
     * @param {string} msg A plain message to be captured in Sentry
     * @param {object} options A specific set of options for this message [optional]
     * @return {Raven}
     */
  captureMessage: function(msg, options) {
    // config() automagically converts ignoreErrors from a list to a RegExp so we need to test for an
    // early call; we'll error on the side of logging anything called before configuration since it's
    // probably something you should see:
    if (
      !!this._globalOptions.ignoreErrors.test &&
      this._globalOptions.ignoreErrors.test(msg)
    ) {
      return;
    }

    options = options || {};
    msg = msg + ''; // Make sure it's actually a string

    var data = objectMerge(
      {
        message: msg
      },
      options
    );

    var ex;
    // Generate a "synthetic" stack trace from this point.
    // NOTE: If you are a Sentry user, and you are seeing this stack frame, it is NOT indicative
    //       of a bug with Raven.js. Sentry generates synthetic traces either by configuration,
    //       or if it catches a thrown object without a "stack" property.
    try {
      throw new Error(msg);
    } catch (ex1) {
      ex = ex1;
    }

    // null exception name so `Error` isn't prefixed to msg
    ex.name = null;
    var stack = TraceKit.computeStackTrace(ex);

    // stack[0] is `throw new Error(msg)` call itself, we are interested in the frame that was just before that, stack[1]
    var initialCall = isArray(stack.stack) && stack.stack[1];

    // if stack[1] is `Raven.captureException`, it means that someone passed a string to it and we redirected that call
    // to be handled by `captureMessage`, thus `initialCall` is the 3rd one, not 2nd
    // initialCall => captureException(string) => captureMessage(string)
    if (initialCall && initialCall.func === 'Raven.captureException') {
      initialCall = stack.stack[2];
    }

    var fileurl = (initialCall && initialCall.url) || '';

    if (
      !!this._globalOptions.ignoreUrls.test &&
      this._globalOptions.ignoreUrls.test(fileurl)
    ) {
      return;
    }

    if (
      !!this._globalOptions.whitelistUrls.test &&
      !this._globalOptions.whitelistUrls.test(fileurl)
    ) {
      return;
    }

    if (this._globalOptions.stacktrace || (options && options.stacktrace)) {
      // fingerprint on msg, not stack trace (legacy behavior, could be revisited)
      data.fingerprint = data.fingerprint == null ? msg : data.fingerprint;

      options = objectMerge(
        {
          trimHeadFrames: 0
        },
        options
      );
      // Since we know this is a synthetic trace, the top frame (this function call)
      // MUST be from Raven.js, so mark it for trimming
      // We add to the trim counter so that callers can choose to trim extra frames, such
      // as utility functions.
      options.trimHeadFrames += 1;

      var frames = this._prepareFrames(stack, options);
      data.stacktrace = {
        // Sentry expects frames oldest to newest
        frames: frames.reverse()
      };
    }

    // Make sure that fingerprint is always wrapped in an array
    if (data.fingerprint) {
      data.fingerprint = isArray(data.fingerprint)
        ? data.fingerprint
        : [data.fingerprint];
    }

    // Fire away!
    this._send(data);

    return this;
  },

  captureBreadcrumb: function(obj) {
    var crumb = objectMerge(
      {
        timestamp: now() / 1000
      },
      obj
    );

    if (isFunction(this._globalOptions.breadcrumbCallback)) {
      var result = this._globalOptions.breadcrumbCallback(crumb);

      if (isObject(result) && !isEmptyObject(result)) {
        crumb = result;
      } else if (result === false) {
        return this;
      }
    }

    this._breadcrumbs.push(crumb);
    if (this._breadcrumbs.length > this._globalOptions.maxBreadcrumbs) {
      this._breadcrumbs.shift();
    }
    return this;
  },

  addPlugin: function(plugin /*arg1, arg2, ... argN*/) {
    var pluginArgs = [].slice.call(arguments, 1);

    this._plugins.push([plugin, pluginArgs]);
    if (this._isRavenInstalled) {
      this._drainPlugins();
    }

    return this;
  },

  /*
     * Set/clear a user to be sent along with the payload.
     *
     * @param {object} user An object representing user data [optional]
     * @return {Raven}
     */
  setUserContext: function(user) {
    // Intentionally do not merge here since that's an unexpected behavior.
    this._globalContext.user = user;

    return this;
  },

  /*
     * Merge extra attributes to be sent along with the payload.
     *
     * @param {object} extra An object representing extra data [optional]
     * @return {Raven}
     */
  setExtraContext: function(extra) {
    this._mergeContext('extra', extra);

    return this;
  },

  /*
     * Merge tags to be sent along with the payload.
     *
     * @param {object} tags An object representing tags [optional]
     * @return {Raven}
     */
  setTagsContext: function(tags) {
    this._mergeContext('tags', tags);

    return this;
  },

  /*
     * Clear all of the context.
     *
     * @return {Raven}
     */
  clearContext: function() {
    this._globalContext = {};

    return this;
  },

  /*
     * Get a copy of the current context. This cannot be mutated.
     *
     * @return {object} copy of context
     */
  getContext: function() {
    // lol javascript
    return JSON.parse(stringify(this._globalContext));
  },

  /*
     * Set environment of application
     *
     * @param {string} environment Typically something like 'production'.
     * @return {Raven}
     */
  setEnvironment: function(environment) {
    this._globalOptions.environment = environment;

    return this;
  },

  /*
     * Set release version of application
     *
     * @param {string} release Typically something like a git SHA to identify version
     * @return {Raven}
     */
  setRelease: function(release) {
    this._globalOptions.release = release;

    return this;
  },

  /*
     * Set the dataCallback option
     *
     * @param {function} callback The callback to run which allows the
     *                            data blob to be mutated before sending
     * @return {Raven}
     */
  setDataCallback: function(callback) {
    var original = this._globalOptions.dataCallback;
    this._globalOptions.dataCallback = keepOriginalCallback(original, callback);
    return this;
  },

  /*
     * Set the breadcrumbCallback option
     *
     * @param {function} callback The callback to run which allows filtering
     *                            or mutating breadcrumbs
     * @return {Raven}
     */
  setBreadcrumbCallback: function(callback) {
    var original = this._globalOptions.breadcrumbCallback;
    this._globalOptions.breadcrumbCallback = keepOriginalCallback(original, callback);
    return this;
  },

  /*
     * Set the shouldSendCallback option
     *
     * @param {function} callback The callback to run which allows
     *                            introspecting the blob before sending
     * @return {Raven}
     */
  setShouldSendCallback: function(callback) {
    var original = this._globalOptions.shouldSendCallback;
    this._globalOptions.shouldSendCallback = keepOriginalCallback(original, callback);
    return this;
  },

  /**
   * Override the default HTTP transport mechanism that transmits data
   * to the Sentry server.
   *
   * @param {function} transport Function invoked instead of the default
   *                             `makeRequest` handler.
   *
   * @return {Raven}
   */
  setTransport: function(transport) {
    this._globalOptions.transport = transport;

    return this;
  },

  /*
     * Get the latest raw exception that was captured by Raven.
     *
     * @return {error}
     */
  lastException: function() {
    return this._lastCapturedException;
  },

  /*
     * Get the last event id
     *
     * @return {string}
     */
  lastEventId: function() {
    return this._lastEventId;
  },

  /*
     * Determine if Raven is setup and ready to go.
     *
     * @return {boolean}
     */
  isSetup: function() {
    if (!this._hasJSON) return false; // needs JSON support
    if (!this._globalServer) {
      if (!this.ravenNotConfiguredError) {
        this.ravenNotConfiguredError = true;
        this._logDebug('error', 'Error: Raven has not been configured.');
      }
      return false;
    }
    return true;
  },

  afterLoad: function() {
    // TODO: remove window dependence?

    // Attempt to initialize Raven on load
    var RavenConfig = _window.RavenConfig;
    if (RavenConfig) {
      this.config(RavenConfig.dsn, RavenConfig.config).install();
    }
  },

  showReportDialog: function(options) {
    if (
      !_document // doesn't work without a document (React native)
    )
      return;

    options = options || {};

    var lastEventId = options.eventId || this.lastEventId();
    if (!lastEventId) {
      throw new RavenConfigError('Missing eventId');
    }

    var dsn = options.dsn || this._dsn;
    if (!dsn) {
      throw new RavenConfigError('Missing DSN');
    }

    var encode = encodeURIComponent;
    var qs = '';
    qs += '?eventId=' + encode(lastEventId);
    qs += '&dsn=' + encode(dsn);

    var user = options.user || this._globalContext.user;
    if (user) {
      if (user.name) qs += '&name=' + encode(user.name);
      if (user.email) qs += '&email=' + encode(user.email);
    }

    var globalServer = this._getGlobalServer(this._parseDSN(dsn));

    var script = _document.createElement('script');
    script.async = true;
    script.src = globalServer + '/api/embed/error-page/' + qs;
    (_document.head || _document.body).appendChild(script);
  },

  /**** Private functions ****/
  _ignoreNextOnError: function() {
    var self = this;
    this._ignoreOnError += 1;
    setTimeout(function() {
      // onerror should trigger before setTimeout
      self._ignoreOnError -= 1;
    });
  },

  _triggerEvent: function(eventType, options) {
    // NOTE: `event` is a native browser thing, so let's avoid conflicting wiht it
    var evt, key;

    if (!this._hasDocument) return;

    options = options || {};

    eventType = 'raven' + eventType.substr(0, 1).toUpperCase() + eventType.substr(1);

    if (_document.createEvent) {
      evt = _document.createEvent('HTMLEvents');
      evt.initEvent(eventType, true, true);
    } else {
      evt = _document.createEventObject();
      evt.eventType = eventType;
    }

    for (key in options)
      if (hasKey(options, key)) {
        evt[key] = options[key];
      }

    if (_document.createEvent) {
      // IE9 if standards
      _document.dispatchEvent(evt);
    } else {
      // IE8 regardless of Quirks or Standards
      // IE9 if quirks
      try {
        _document.fireEvent('on' + evt.eventType.toLowerCase(), evt);
      } catch (e) {
        // Do nothing
      }
    }
  },

  /**
   * Wraps addEventListener to capture UI breadcrumbs
   * @param evtName the event name (e.g. "click")
   * @returns {Function}
   * @private
   */
  _breadcrumbEventHandler: function(evtName) {
    var self = this;
    return function(evt) {
      // reset keypress timeout; e.g. triggering a 'click' after
      // a 'keypress' will reset the keypress debounce so that a new
      // set of keypresses can be recorded
      self._keypressTimeout = null;

      // It's possible this handler might trigger multiple times for the same
      // event (e.g. event propagation through node ancestors). Ignore if we've
      // already captured the event.
      if (self._lastCapturedEvent === evt) return;

      self._lastCapturedEvent = evt;

      // try/catch both:
      // - accessing evt.target (see getsentry/raven-js#838, #768)
      // - `htmlTreeAsString` because it's complex, and just accessing the DOM incorrectly
      //   can throw an exception in some circumstances.
      var target;
      try {
        target = htmlTreeAsString(evt.target);
      } catch (e) {
        target = '<unknown>';
      }

      self.captureBreadcrumb({
        category: 'ui.' + evtName, // e.g. ui.click, ui.input
        message: target
      });
    };
  },

  /**
   * Wraps addEventListener to capture keypress UI events
   * @returns {Function}
   * @private
   */
  _keypressEventHandler: function() {
    var self = this,
      debounceDuration = 1000; // milliseconds

    // TODO: if somehow user switches keypress target before
    //       debounce timeout is triggered, we will only capture
    //       a single breadcrumb from the FIRST target (acceptable?)
    return function(evt) {
      var target;
      try {
        target = evt.target;
      } catch (e) {
        // just accessing event properties can throw an exception in some rare circumstances
        // see: https://github.com/getsentry/raven-js/issues/838
        return;
      }
      var tagName = target && target.tagName;

      // only consider keypress events on actual input elements
      // this will disregard keypresses targeting body (e.g. tabbing
      // through elements, hotkeys, etc)
      if (
        !tagName ||
        (tagName !== 'INPUT' && tagName !== 'TEXTAREA' && !target.isContentEditable)
      )
        return;

      // record first keypress in a series, but ignore subsequent
      // keypresses until debounce clears
      var timeout = self._keypressTimeout;
      if (!timeout) {
        self._breadcrumbEventHandler('input')(evt);
      }
      clearTimeout(timeout);
      self._keypressTimeout = setTimeout(function() {
        self._keypressTimeout = null;
      }, debounceDuration);
    };
  },

  /**
   * Captures a breadcrumb of type "navigation", normalizing input URLs
   * @param to the originating URL
   * @param from the target URL
   * @private
   */
  _captureUrlChange: function(from, to) {
    var parsedLoc = parseUrl(this._location.href);
    var parsedTo = parseUrl(to);
    var parsedFrom = parseUrl(from);

    // because onpopstate only tells you the "new" (to) value of location.href, and
    // not the previous (from) value, we need to track the value of the current URL
    // state ourselves
    this._lastHref = to;

    // Use only the path component of the URL if the URL matches the current
    // document (almost all the time when using pushState)
    if (parsedLoc.protocol === parsedTo.protocol && parsedLoc.host === parsedTo.host)
      to = parsedTo.relative;
    if (parsedLoc.protocol === parsedFrom.protocol && parsedLoc.host === parsedFrom.host)
      from = parsedFrom.relative;

    this.captureBreadcrumb({
      category: 'navigation',
      data: {
        to: to,
        from: from
      }
    });
  },

  _patchFunctionToString: function() {
    var self = this;
    self._originalFunctionToString = Function.prototype.toString;
    // eslint-disable-next-line no-extend-native
    Function.prototype.toString = function() {
      if (typeof this === 'function' && this.__raven__) {
        return self._originalFunctionToString.apply(this.__orig__, arguments);
      }
      return self._originalFunctionToString.apply(this, arguments);
    };
  },

  _unpatchFunctionToString: function() {
    if (this._originalFunctionToString) {
      // eslint-disable-next-line no-extend-native
      Function.prototype.toString = this._originalFunctionToString;
    }
  },

  /**
   * Wrap timer functions and event targets to catch errors and provide
   * better metadata.
   */
  _instrumentTryCatch: function() {
    var self = this;

    var wrappedBuiltIns = self._wrappedBuiltIns;

    function wrapTimeFn(orig) {
      return function(fn, t) {
        // preserve arity
        // Make a copy of the arguments to prevent deoptimization
        // https://github.com/petkaantonov/bluebird/wiki/Optimization-killers#32-leaking-arguments
        var args = new Array(arguments.length);
        for (var i = 0; i < args.length; ++i) {
          args[i] = arguments[i];
        }
        var originalCallback = args[0];
        if (isFunction(originalCallback)) {
          args[0] = self.wrap(
            {
              mechanism: {
                type: 'instrument',
                data: {function: orig.name || '<anonymous>'}
              }
            },
            originalCallback
          );
        }

        // IE < 9 doesn't support .call/.apply on setInterval/setTimeout, but it
        // also supports only two arguments and doesn't care what this is, so we
        // can just call the original function directly.
        if (orig.apply) {
          return orig.apply(this, args);
        } else {
          return orig(args[0], args[1]);
        }
      };
    }

    var autoBreadcrumbs = this._globalOptions.autoBreadcrumbs;

    function wrapEventTarget(global) {
      var proto = _window[global] && _window[global].prototype;
      if (proto && proto.hasOwnProperty && proto.hasOwnProperty('addEventListener')) {
        fill(
          proto,
          'addEventListener',
          function(orig) {
            return function(evtName, fn, capture, secure) {
              // preserve arity
              try {
                if (fn && fn.handleEvent) {
                  fn.handleEvent = self.wrap(
                    {
                      mechanism: {
                        type: 'instrument',
                        data: {
                          target: global,
                          function: 'handleEvent',
                          handler: (fn && fn.name) || '<anonymous>'
                        }
                      }
                    },
                    fn.handleEvent
                  );
                }
              } catch (err) {
                // can sometimes get 'Permission denied to access property "handle Event'
              }

              // More breadcrumb DOM capture ... done here and not in `_instrumentBreadcrumbs`
              // so that we don't have more than one wrapper function
              var before, clickHandler, keypressHandler;

              if (
                autoBreadcrumbs &&
                autoBreadcrumbs.dom &&
                (global === 'EventTarget' || global === 'Node')
              ) {
                // NOTE: generating multiple handlers per addEventListener invocation, should
                //       revisit and verify we can just use one (almost certainly)
                clickHandler = self._breadcrumbEventHandler('click');
                keypressHandler = self._keypressEventHandler();
                before = function(evt) {
                  // need to intercept every DOM event in `before` argument, in case that
                  // same wrapped method is re-used for different events (e.g. mousemove THEN click)
                  // see #724
                  if (!evt) return;

                  var eventType;
                  try {
                    eventType = evt.type;
                  } catch (e) {
                    // just accessing event properties can throw an exception in some rare circumstances
                    // see: https://github.com/getsentry/raven-js/issues/838
                    return;
                  }
                  if (eventType === 'click') return clickHandler(evt);
                  else if (eventType === 'keypress') return keypressHandler(evt);
                };
              }
              return orig.call(
                this,
                evtName,
                self.wrap(
                  {
                    mechanism: {
                      type: 'instrument',
                      data: {
                        target: global,
                        function: 'addEventListener',
                        handler: (fn && fn.name) || '<anonymous>'
                      }
                    }
                  },
                  fn,
                  before
                ),
                capture,
                secure
              );
            };
          },
          wrappedBuiltIns
        );
        fill(
          proto,
          'removeEventListener',
          function(orig) {
            return function(evt, fn, capture, secure) {
              try {
                fn = fn && (fn.__raven_wrapper__ ? fn.__raven_wrapper__ : fn);
              } catch (e) {
                // ignore, accessing __raven_wrapper__ will throw in some Selenium environments
              }
              return orig.call(this, evt, fn, capture, secure);
            };
          },
          wrappedBuiltIns
        );
      }
    }

    fill(_window, 'setTimeout', wrapTimeFn, wrappedBuiltIns);
    fill(_window, 'setInterval', wrapTimeFn, wrappedBuiltIns);
    if (_window.requestAnimationFrame) {
      fill(
        _window,
        'requestAnimationFrame',
        function(orig) {
          return function(cb) {
            return orig(
              self.wrap(
                {
                  mechanism: {
                    type: 'instrument',
                    data: {
                      function: 'requestAnimationFrame',
                      handler: (orig && orig.name) || '<anonymous>'
                    }
                  }
                },
                cb
              )
            );
          };
        },
        wrappedBuiltIns
      );
    }

    // event targets borrowed from bugsnag-js:
    // https://github.com/bugsnag/bugsnag-js/blob/master/src/bugsnag.js#L666
    var eventTargets = [
      'EventTarget',
      'Window',
      'Node',
      'ApplicationCache',
      'AudioTrackList',
      'ChannelMergerNode',
      'CryptoOperation',
      'EventSource',
      'FileReader',
      'HTMLUnknownElement',
      'IDBDatabase',
      'IDBRequest',
      'IDBTransaction',
      'KeyOperation',
      'MediaController',
      'MessagePort',
      'ModalWindow',
      'Notification',
      'SVGElementInstance',
      'Screen',
      'TextTrack',
      'TextTrackCue',
      'TextTrackList',
      'WebSocket',
      'WebSocketWorker',
      'Worker',
      'XMLHttpRequest',
      'XMLHttpRequestEventTarget',
      'XMLHttpRequestUpload'
    ];
    for (var i = 0; i < eventTargets.length; i++) {
      wrapEventTarget(eventTargets[i]);
    }
  },

  /**
   * Instrument browser built-ins w/ breadcrumb capturing
   *  - XMLHttpRequests
   *  - DOM interactions (click/typing)
   *  - window.location changes
   *  - console
   *
   * Can be disabled or individually configured via the `autoBreadcrumbs` config option
   */
  _instrumentBreadcrumbs: function() {
    var self = this;
    var autoBreadcrumbs = this._globalOptions.autoBreadcrumbs;

    var wrappedBuiltIns = self._wrappedBuiltIns;

    function wrapProp(prop, xhr) {
      if (prop in xhr && isFunction(xhr[prop])) {
        fill(xhr, prop, function(orig) {
          return self.wrap(
            {
              mechanism: {
                type: 'instrument',
                data: {function: prop, handler: (orig && orig.name) || '<anonymous>'}
              }
            },
            orig
          );
        }); // intentionally don't track filled methods on XHR instances
      }
    }

    if (autoBreadcrumbs.xhr && 'XMLHttpRequest' in _window) {
      var xhrproto = _window.XMLHttpRequest && _window.XMLHttpRequest.prototype;
      fill(
        xhrproto,
        'open',
        function(origOpen) {
          return function(method, url) {
            // preserve arity

            // if Sentry key appears in URL, don't capture
            if (isString(url) && url.indexOf(self._globalKey) === -1) {
              this.__raven_xhr = {
                method: method,
                url: url,
                status_code: null
              };
            }

            return origOpen.apply(this, arguments);
          };
        },
        wrappedBuiltIns
      );

      fill(
        xhrproto,
        'send',
        function(origSend) {
          return function() {
            // preserve arity
            var xhr = this;

            function onreadystatechangeHandler() {
              if (xhr.__raven_xhr && xhr.readyState === 4) {
                try {
                  // touching statusCode in some platforms throws
                  // an exception
                  xhr.__raven_xhr.status_code = xhr.status;
                } catch (e) {
                  /* do nothing */
                }

                self.captureBreadcrumb({
                  type: 'http',
                  category: 'xhr',
                  data: xhr.__raven_xhr
                });
              }
            }

            var props = ['onload', 'onerror', 'onprogress'];
            for (var j = 0; j < props.length; j++) {
              wrapProp(props[j], xhr);
            }

            if ('onreadystatechange' in xhr && isFunction(xhr.onreadystatechange)) {
              fill(
                xhr,
                'onreadystatechange',
                function(orig) {
                  return self.wrap(
                    {
                      mechanism: {
                        type: 'instrument',
                        data: {
                          function: 'onreadystatechange',
                          handler: (orig && orig.name) || '<anonymous>'
                        }
                      }
                    },
                    orig,
                    onreadystatechangeHandler
                  );
                } /* intentionally don't track this instrumentation */
              );
            } else {
              // if onreadystatechange wasn't actually set by the page on this xhr, we
              // are free to set our own and capture the breadcrumb
              xhr.onreadystatechange = onreadystatechangeHandler;
            }

            return origSend.apply(this, arguments);
          };
        },
        wrappedBuiltIns
      );
    }

    if (autoBreadcrumbs.xhr && supportsFetch()) {
      fill(
        _window,
        'fetch',
        function(origFetch) {
          return function() {
            // preserve arity
            // Make a copy of the arguments to prevent deoptimization
            // https://github.com/petkaantonov/bluebird/wiki/Optimization-killers#32-leaking-arguments
            var args = new Array(arguments.length);
            for (var i = 0; i < args.length; ++i) {
              args[i] = arguments[i];
            }

            var fetchInput = args[0];
            var method = 'GET';
            var url;

            if (typeof fetchInput === 'string') {
              url = fetchInput;
            } else if ('Request' in _window && fetchInput instanceof _window.Request) {
              url = fetchInput.url;
              if (fetchInput.method) {
                method = fetchInput.method;
              }
            } else {
              url = '' + fetchInput;
            }

            // if Sentry key appears in URL, don't capture, as it's our own request
            if (url.indexOf(self._globalKey) !== -1) {
              return origFetch.apply(this, args);
            }

            if (args[1] && args[1].method) {
              method = args[1].method;
            }

            var fetchData = {
              method: method,
              url: url,
              status_code: null
            };

            return origFetch
              .apply(this, args)
              .then(function(response) {
                fetchData.status_code = response.status;

                self.captureBreadcrumb({
                  type: 'http',
                  category: 'fetch',
                  data: fetchData
                });

                return response;
              })
              ['catch'](function(err) {
                // if there is an error performing the request
                self.captureBreadcrumb({
                  type: 'http',
                  category: 'fetch',
                  data: fetchData,
                  level: 'error'
                });

                throw err;
              });
          };
        },
        wrappedBuiltIns
      );
    }

    // Capture breadcrumbs from any click that is unhandled / bubbled up all the way
    // to the document. Do this before we instrument addEventListener.
    if (autoBreadcrumbs.dom && this._hasDocument) {
      if (_document.addEventListener) {
        _document.addEventListener('click', self._breadcrumbEventHandler('click'), false);
        _document.addEventListener('keypress', self._keypressEventHandler(), false);
      } else if (_document.attachEvent) {
        // IE8 Compatibility
        _document.attachEvent('onclick', self._breadcrumbEventHandler('click'));
        _document.attachEvent('onkeypress', self._keypressEventHandler());
      }
    }

    // record navigation (URL) changes
    // NOTE: in Chrome App environment, touching history.pushState, *even inside
    //       a try/catch block*, will cause Chrome to output an error to console.error
    // borrowed from: https://github.com/angular/angular.js/pull/13945/files
    var chrome = _window.chrome;
    var isChromePackagedApp = chrome && chrome.app && chrome.app.runtime;
    var hasPushAndReplaceState =
      !isChromePackagedApp &&
      _window.history &&
      _window.history.pushState &&
      _window.history.replaceState;
    if (autoBreadcrumbs.location && hasPushAndReplaceState) {
      // TODO: remove onpopstate handler on uninstall()
      var oldOnPopState = _window.onpopstate;
      _window.onpopstate = function() {
        var currentHref = self._location.href;
        self._captureUrlChange(self._lastHref, currentHref);

        if (oldOnPopState) {
          return oldOnPopState.apply(this, arguments);
        }
      };

      var historyReplacementFunction = function(origHistFunction) {
        // note history.pushState.length is 0; intentionally not declaring
        // params to preserve 0 arity
        return function(/* state, title, url */) {
          var url = arguments.length > 2 ? arguments[2] : undefined;

          // url argument is optional
          if (url) {
            // coerce to string (this is what pushState does)
            self._captureUrlChange(self._lastHref, url + '');
          }

          return origHistFunction.apply(this, arguments);
        };
      };

      fill(_window.history, 'pushState', historyReplacementFunction, wrappedBuiltIns);
      fill(_window.history, 'replaceState', historyReplacementFunction, wrappedBuiltIns);
    }

    if (autoBreadcrumbs.console && 'console' in _window && console.log) {
      // console
      var consoleMethodCallback = function(msg, data) {
        self.captureBreadcrumb({
          message: msg,
          level: data.level,
          category: 'console'
        });
      };

      each(['debug', 'info', 'warn', 'error', 'log'], function(_, level) {
        wrapConsoleMethod(console, level, consoleMethodCallback);
      });
    }
  },

  _restoreBuiltIns: function() {
    // restore any wrapped builtins
    var builtin;
    while (this._wrappedBuiltIns.length) {
      builtin = this._wrappedBuiltIns.shift();

      var obj = builtin[0],
        name = builtin[1],
        orig = builtin[2];

      obj[name] = orig;
    }
  },

  _restoreConsole: function() {
    // eslint-disable-next-line guard-for-in
    for (var method in this._originalConsoleMethods) {
      this._originalConsole[method] = this._originalConsoleMethods[method];
    }
  },

  _drainPlugins: function() {
    var self = this;

    // FIX ME TODO
    each(this._plugins, function(_, plugin) {
      var installer = plugin[0];
      var args = plugin[1];
      installer.apply(self, [self].concat(args));
    });
  },

  _parseDSN: function(str) {
    var m = dsnPattern.exec(str),
      dsn = {},
      i = 7;

    try {
      while (i--) dsn[dsnKeys[i]] = m[i] || '';
    } catch (e) {
      throw new RavenConfigError('Invalid DSN: ' + str);
    }

    if (dsn.pass && !this._globalOptions.allowSecretKey) {
      throw new RavenConfigError(
        'Do not specify your secret key in the DSN. See: http://bit.ly/raven-secret-key'
      );
    }

    return dsn;
  },

  _getGlobalServer: function(uri) {
    // assemble the endpoint from the uri pieces
    var globalServer = '//' + uri.host + (uri.port ? ':' + uri.port : '');

    if (uri.protocol) {
      globalServer = uri.protocol + ':' + globalServer;
    }
    return globalServer;
  },

  _handleOnErrorStackInfo: function(stackInfo, options) {
    options = options || {};
    options.mechanism = options.mechanism || {
      type: 'onerror',
      handled: false
    };

    // if we are intentionally ignoring errors via onerror, bail out
    if (!this._ignoreOnError) {
      this._handleStackInfo(stackInfo, options);
    }
  },

  _handleStackInfo: function(stackInfo, options) {
    var frames = this._prepareFrames(stackInfo, options);

    this._triggerEvent('handle', {
      stackInfo: stackInfo,
      options: options
    });

    this._processException(
      stackInfo.name,
      stackInfo.message,
      stackInfo.url,
      stackInfo.lineno,
      frames,
      options
    );
  },

  _prepareFrames: function(stackInfo, options) {
    var self = this;
    var frames = [];
    if (stackInfo.stack && stackInfo.stack.length) {
      each(stackInfo.stack, function(i, stack) {
        var frame = self._normalizeFrame(stack, stackInfo.url);
        if (frame) {
          frames.push(frame);
        }
      });

      // e.g. frames captured via captureMessage throw
      if (options && options.trimHeadFrames) {
        for (var j = 0; j < options.trimHeadFrames && j < frames.length; j++) {
          frames[j].in_app = false;
        }
      }
    }
    frames = frames.slice(0, this._globalOptions.stackTraceLimit);
    return frames;
  },

  _normalizeFrame: function(frame, stackInfoUrl) {
    // normalize the frames data
    var normalized = {
      filename: frame.url,
      lineno: frame.line,
      colno: frame.column,
      function: frame.func || '?'
    };

    // Case when we don't have any information about the error
    // E.g. throwing a string or raw object, instead of an `Error` in Firefox
    // Generating synthetic error doesn't add any value here
    //
    // We should probably somehow let a user know that they should fix their code
    if (!frame.url) {
      normalized.filename = stackInfoUrl; // fallback to whole stacks url from onerror handler
    }

    normalized.in_app = !// determine if an exception came from outside of our app
    // first we check the global includePaths list.
    (
      (!!this._globalOptions.includePaths.test &&
        !this._globalOptions.includePaths.test(normalized.filename)) ||
      // Now we check for fun, if the function name is Raven or TraceKit
      /(Raven|TraceKit)\./.test(normalized['function']) ||
      // finally, we do a last ditch effort and check for raven.min.js
      /raven\.(min\.)?js$/.test(normalized.filename)
    );

    return normalized;
  },

  _processException: function(type, message, fileurl, lineno, frames, options) {
    var prefixedMessage = (type ? type + ': ' : '') + (message || '');
    if (
      !!this._globalOptions.ignoreErrors.test &&
      (this._globalOptions.ignoreErrors.test(message) ||
        this._globalOptions.ignoreErrors.test(prefixedMessage))
    ) {
      return;
    }

    var stacktrace;

    if (frames && frames.length) {
      fileurl = frames[0].filename || fileurl;
      // Sentry expects frames oldest to newest
      // and JS sends them as newest to oldest
      frames.reverse();
      stacktrace = {frames: frames};
    } else if (fileurl) {
      stacktrace = {
        frames: [
          {
            filename: fileurl,
            lineno: lineno,
            in_app: true
          }
        ]
      };
    }

    if (
      !!this._globalOptions.ignoreUrls.test &&
      this._globalOptions.ignoreUrls.test(fileurl)
    ) {
      return;
    }

    if (
      !!this._globalOptions.whitelistUrls.test &&
      !this._globalOptions.whitelistUrls.test(fileurl)
    ) {
      return;
    }

    var data = objectMerge(
      {
        // sentry.interfaces.Exception
        exception: {
          values: [
            {
              type: type,
              value: message,
              stacktrace: stacktrace
            }
          ]
        },
        transaction: fileurl
      },
      options
    );

    // Move mechanism from options to exception interface
    // We do this, as requiring user to pass `{exception:{mechanism:{ ... }}}` would be
    // too much
    if (!data.exception.mechanism && data.mechanism) {
      data.exception.mechanism = data.mechanism;
      delete data.mechanism;
    }

    data.exception.mechanism = objectMerge(
      {
        type: 'generic',
        handled: true
      },
      data.exception.mechanism || {}
    );

    // Fire away!
    this._send(data);
  },

  _trimPacket: function(data) {
    // For now, we only want to truncate the two different messages
    // but this could/should be expanded to just trim everything
    var max = this._globalOptions.maxMessageLength;
    if (data.message) {
      data.message = truncate(data.message, max);
    }
    if (data.exception) {
      var exception = data.exception.values[0];
      exception.value = truncate(exception.value, max);
    }

    var request = data.request;
    if (request) {
      if (request.url) {
        request.url = truncate(request.url, this._globalOptions.maxUrlLength);
      }
      if (request.Referer) {
        request.Referer = truncate(request.Referer, this._globalOptions.maxUrlLength);
      }
    }

    if (data.breadcrumbs && data.breadcrumbs.values)
      this._trimBreadcrumbs(data.breadcrumbs);

    return data;
  },

  /**
   * Truncate breadcrumb values (right now just URLs)
   */
  _trimBreadcrumbs: function(breadcrumbs) {
    // known breadcrumb properties with urls
    // TODO: also consider arbitrary prop values that start with (https?)?://
    var urlProps = ['to', 'from', 'url'],
      urlProp,
      crumb,
      data;

    for (var i = 0; i < breadcrumbs.values.length; ++i) {
      crumb = breadcrumbs.values[i];
      if (
        !crumb.hasOwnProperty('data') ||
        !isObject(crumb.data) ||
        objectFrozen(crumb.data)
      )
        continue;

      data = objectMerge({}, crumb.data);
      for (var j = 0; j < urlProps.length; ++j) {
        urlProp = urlProps[j];
        if (data.hasOwnProperty(urlProp) && data[urlProp]) {
          data[urlProp] = truncate(data[urlProp], this._globalOptions.maxUrlLength);
        }
      }
      breadcrumbs.values[i].data = data;
    }
  },

  _getHttpData: function() {
    if (!this._hasNavigator && !this._hasDocument) return;
    var httpData = {};

    if (this._hasNavigator && _navigator.userAgent) {
      httpData.headers = {
        'User-Agent': _navigator.userAgent
      };
    }

    // Check in `window` instead of `document`, as we may be in ServiceWorker environment
    if (_window.location && _window.location.href) {
      httpData.url = _window.location.href;
    }

    if (this._hasDocument && _document.referrer) {
      if (!httpData.headers) httpData.headers = {};
      httpData.headers.Referer = _document.referrer;
    }

    return httpData;
  },

  _resetBackoff: function() {
    this._backoffDuration = 0;
    this._backoffStart = null;
  },

  _shouldBackoff: function() {
    return this._backoffDuration && now() - this._backoffStart < this._backoffDuration;
  },

  /**
   * Returns true if the in-process data payload matches the signature
   * of the previously-sent data
   *
   * NOTE: This has to be done at this level because TraceKit can generate
   *       data from window.onerror WITHOUT an exception object (IE8, IE9,
   *       other old browsers). This can take the form of an "exception"
   *       data object with a single frame (derived from the onerror args).
   */
  _isRepeatData: function(current) {
    var last = this._lastData;

    if (
      !last ||
      current.message !== last.message || // defined for captureMessage
      current.transaction !== last.transaction // defined for captureException/onerror
    )
      return false;

    // Stacktrace interface (i.e. from captureMessage)
    if (current.stacktrace || last.stacktrace) {
      return isSameStacktrace(current.stacktrace, last.stacktrace);
    } else if (current.exception || last.exception) {
      // Exception interface (i.e. from captureException/onerror)
      return isSameException(current.exception, last.exception);
    }

    return true;
  },

  _setBackoffState: function(request) {
    // If we are already in a backoff state, don't change anything
    if (this._shouldBackoff()) {
      return;
    }

    var status = request.status;

    // 400 - project_id doesn't exist or some other fatal
    // 401 - invalid/revoked dsn
    // 429 - too many requests
    if (!(status === 400 || status === 401 || status === 429)) return;

    var retry;
    try {
      // If Retry-After is not in Access-Control-Expose-Headers, most
      // browsers will throw an exception trying to access it
      if (supportsFetch()) {
        retry = request.headers.get('Retry-After');
      } else {
        retry = request.getResponseHeader('Retry-After');
      }

      // Retry-After is returned in seconds
      retry = parseInt(retry, 10) * 1000;
    } catch (e) {
      /* eslint no-empty:0 */
    }

    this._backoffDuration = retry
      ? // If Sentry server returned a Retry-After value, use it
        retry
      : // Otherwise, double the last backoff duration (starts at 1 sec)
        this._backoffDuration * 2 || 1000;

    this._backoffStart = now();
  },

  _send: function(data) {
    var globalOptions = this._globalOptions;

    var baseData = {
        project: this._globalProject,
        logger: globalOptions.logger,
        platform: 'javascript'
      },
      httpData = this._getHttpData();

    if (httpData) {
      baseData.request = httpData;
    }

    // HACK: delete `trimHeadFrames` to prevent from appearing in outbound payload
    if (data.trimHeadFrames) delete data.trimHeadFrames;

    data = objectMerge(baseData, data);

    // Merge in the tags and extra separately since objectMerge doesn't handle a deep merge
    data.tags = objectMerge(objectMerge({}, this._globalContext.tags), data.tags);
    data.extra = objectMerge(objectMerge({}, this._globalContext.extra), data.extra);

    // Send along our own collected metadata with extra
    data.extra['session:duration'] = now() - this._startTime;

    if (this._breadcrumbs && this._breadcrumbs.length > 0) {
      // intentionally make shallow copy so that additions
      // to breadcrumbs aren't accidentally sent in this request
      data.breadcrumbs = {
        values: [].slice.call(this._breadcrumbs, 0)
      };
    }

    if (this._globalContext.user) {
      // sentry.interfaces.User
      data.user = this._globalContext.user;
    }

    // Include the environment if it's defined in globalOptions
    if (globalOptions.environment) data.environment = globalOptions.environment;

    // Include the release if it's defined in globalOptions
    if (globalOptions.release) data.release = globalOptions.release;

    // Include server_name if it's defined in globalOptions
    if (globalOptions.serverName) data.server_name = globalOptions.serverName;

    data = this._sanitizeData(data);

    // Cleanup empty properties before sending them to the server
    Object.keys(data).forEach(function(key) {
      if (data[key] == null || data[key] === '' || isEmptyObject(data[key])) {
        delete data[key];
      }
    });

    if (isFunction(globalOptions.dataCallback)) {
      data = globalOptions.dataCallback(data) || data;
    }

    // Why??????????
    if (!data || isEmptyObject(data)) {
      return;
    }

    // Check if the request should be filtered or not
    if (
      isFunction(globalOptions.shouldSendCallback) &&
      !globalOptions.shouldSendCallback(data)
    ) {
      return;
    }

    // Backoff state: Sentry server previously responded w/ an error (e.g. 429 - too many requests),
    // so drop requests until "cool-off" period has elapsed.
    if (this._shouldBackoff()) {
      this._logDebug('warn', 'Raven dropped error due to backoff: ', data);
      return;
    }

    if (typeof globalOptions.sampleRate === 'number') {
      if (Math.random() < globalOptions.sampleRate) {
        this._sendProcessedPayload(data);
      }
    } else {
      this._sendProcessedPayload(data);
    }
  },

  _sanitizeData: function(data) {
    return sanitize(data, this._globalOptions.sanitizeKeys);
  },

  _getUuid: function() {
    return uuid4();
  },

  _sendProcessedPayload: function(data, callback) {
    var self = this;
    var globalOptions = this._globalOptions;

    if (!this.isSetup()) return;

    // Try and clean up the packet before sending by truncating long values
    data = this._trimPacket(data);

    // ideally duplicate error testing should occur *before* dataCallback/shouldSendCallback,
    // but this would require copying an un-truncated copy of the data packet, which can be
    // arbitrarily deep (extra_data) -- could be worthwhile? will revisit
    if (!this._globalOptions.allowDuplicates && this._isRepeatData(data)) {
      this._logDebug('warn', 'Raven dropped repeat event: ', data);
      return;
    }

    // Send along an event_id if not explicitly passed.
    // This event_id can be used to reference the error within Sentry itself.
    // Set lastEventId after we know the error should actually be sent
    this._lastEventId = data.event_id || (data.event_id = this._getUuid());

    // Store outbound payload after trim
    this._lastData = data;

    this._logDebug('debug', 'Raven about to send:', data);

    var auth = {
      sentry_version: '7',
      sentry_client: 'raven-js/' + this.VERSION,
      sentry_key: this._globalKey
    };

    if (this._globalSecret) {
      auth.sentry_secret = this._globalSecret;
    }

    var exception = data.exception && data.exception.values[0];

    // only capture 'sentry' breadcrumb is autoBreadcrumbs is truthy
    if (
      this._globalOptions.autoBreadcrumbs &&
      this._globalOptions.autoBreadcrumbs.sentry
    ) {
      this.captureBreadcrumb({
        category: 'sentry',
        message: exception
          ? (exception.type ? exception.type + ': ' : '') + exception.value
          : data.message,
        event_id: data.event_id,
        level: data.level || 'error' // presume error unless specified
      });
    }

    var url = this._globalEndpoint;
    (globalOptions.transport || this._makeRequest).call(this, {
      url: url,
      auth: auth,
      data: data,
      options: globalOptions,
      onSuccess: function success() {
        self._resetBackoff();

        self._triggerEvent('success', {
          data: data,
          src: url
        });
        callback && callback();
      },
      onError: function failure(error) {
        self._logDebug('error', 'Raven transport failed to send: ', error);

        if (error.request) {
          self._setBackoffState(error.request);
        }

        self._triggerEvent('failure', {
          data: data,
          src: url
        });
        error = error || new Error('Raven send failed (no additional details provided)');
        callback && callback(error);
      }
    });
  },

  _makeRequest: function(opts) {
    // Auth is intentionally sent as part of query string (NOT as custom HTTP header) to avoid preflight CORS requests
    var url = opts.url + '?' + urlencode(opts.auth);

    var evaluatedHeaders = null;
    var evaluatedFetchParameters = {};

    if (opts.options.headers) {
      evaluatedHeaders = this._evaluateHash(opts.options.headers);
    }

    if (opts.options.fetchParameters) {
      evaluatedFetchParameters = this._evaluateHash(opts.options.fetchParameters);
    }

    if (supportsFetch()) {
      evaluatedFetchParameters.body = stringify(opts.data);

      var defaultFetchOptions = objectMerge({}, this._fetchDefaults);
      var fetchOptions = objectMerge(defaultFetchOptions, evaluatedFetchParameters);

      if (evaluatedHeaders) {
        fetchOptions.headers = evaluatedHeaders;
      }

      return _window
        .fetch(url, fetchOptions)
        .then(function(response) {
          if (response.ok) {
            opts.onSuccess && opts.onSuccess();
          } else {
            var error = new Error('Sentry error code: ' + response.status);
            // It's called request only to keep compatibility with XHR interface
            // and not add more redundant checks in setBackoffState method
            error.request = response;
            opts.onError && opts.onError(error);
          }
        })
        ['catch'](function() {
          opts.onError &&
            opts.onError(new Error('Sentry error code: network unavailable'));
        });
    }

    var request = _window.XMLHttpRequest && new _window.XMLHttpRequest();
    if (!request) return;

    // if browser doesn't support CORS (e.g. IE7), we are out of luck
    var hasCORS = 'withCredentials' in request || typeof XDomainRequest !== 'undefined';

    if (!hasCORS) return;

    if ('withCredentials' in request) {
      request.onreadystatechange = function() {
        if (request.readyState !== 4) {
          return;
        } else if (request.status === 200) {
          opts.onSuccess && opts.onSuccess();
        } else if (opts.onError) {
          var err = new Error('Sentry error code: ' + request.status);
          err.request = request;
          opts.onError(err);
        }
      };
    } else {
      request = new XDomainRequest();
      // xdomainrequest cannot go http -> https (or vice versa),
      // so always use protocol relative
      url = url.replace(/^https?:/, '');

      // onreadystatechange not supported by XDomainRequest
      if (opts.onSuccess) {
        request.onload = opts.onSuccess;
      }
      if (opts.onError) {
        request.onerror = function() {
          var err = new Error('Sentry error code: XDomainRequest');
          err.request = request;
          opts.onError(err);
        };
      }
    }

    request.open('POST', url);

    if (evaluatedHeaders) {
      each(evaluatedHeaders, function(key, value) {
        request.setRequestHeader(key, value);
      });
    }

    request.send(stringify(opts.data));
  },

  _evaluateHash: function(hash) {
    var evaluated = {};

    for (var key in hash) {
      if (hash.hasOwnProperty(key)) {
        var value = hash[key];
        evaluated[key] = typeof value === 'function' ? value() : value;
      }
    }

    return evaluated;
  },

  _logDebug: function(level) {
    // We allow `Raven.debug` and `Raven.config(DSN, { debug: true })` to not make backward incompatible API change
    if (
      this._originalConsoleMethods[level] &&
      (this.debug || this._globalOptions.debug)
    ) {
      // In IE<10 console methods do not have their own 'apply' method
      Function.prototype.apply.call(
        this._originalConsoleMethods[level],
        this._originalConsole,
        [].slice.call(arguments, 1)
      );
    }
  },

  _mergeContext: function(key, context) {
    if (isUndefined(context)) {
      delete this._globalContext[key];
    } else {
      this._globalContext[key] = objectMerge(this._globalContext[key] || {}, context);
    }
  }
};

// Deprecations
Raven.prototype.setUser = Raven.prototype.setUserContext;
Raven.prototype.setReleaseContext = Raven.prototype.setRelease;

module.exports = Raven;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../vendor/TraceKit/tracekit":438,"../vendor/json-stringify-safe/stringify":439,"../vendor/md5/md5":440,"./configError":433,"./console":434,"./utils":437}],436:[function(require,module,exports){
(function (global){
/**
 * Enforces a single instance of the Raven client, and the
 * main entry point for Raven. If you are a consumer of the
 * Raven library, you SHOULD load this file (vs raven.js).
 **/

var RavenConstructor = require('./raven');

// This is to be defensive in environments where window does not exist (see https://github.com/getsentry/raven-js/pull/785)
var _window =
  typeof window !== 'undefined'
    ? window
    : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};
var _Raven = _window.Raven;

var Raven = new RavenConstructor();

/*
 * Allow multiple versions of Raven to be installed.
 * Strip Raven from the global context and returns the instance.
 *
 * @return {Raven}
 */
Raven.noConflict = function() {
  _window.Raven = _Raven;
  return Raven;
};

Raven.afterLoad();

module.exports = Raven;

/**
 * DISCLAIMER:
 *
 * Expose `Client` constructor for cases where user want to track multiple "sub-applications" in one larger app.
 * It's not meant to be used by a wide audience, so pleaaase make sure that you know what you're doing before using it.
 * Accidentally calling `install` multiple times, may result in an unexpected behavior that's very hard to debug.
 *
 * It's called `Client' to be in-line with Raven Node implementation.
 *
 * HOWTO:
 *
 * import Raven from 'raven-js';
 *
 * const someAppReporter = new Raven.Client();
 * const someOtherAppReporter = new Raven.Client();
 *
 * someAppReporter.config('__DSN__', {
 *   ...config goes here
 * });
 *
 * someOtherAppReporter.config('__OTHER_DSN__', {
 *   ...config goes here
 * });
 *
 * someAppReporter.captureMessage(...);
 * someAppReporter.captureException(...);
 * someAppReporter.captureBreadcrumb(...);
 *
 * someOtherAppReporter.captureMessage(...);
 * someOtherAppReporter.captureException(...);
 * someOtherAppReporter.captureBreadcrumb(...);
 *
 * It should "just work".
 */
module.exports.Client = RavenConstructor;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./raven":435}],437:[function(require,module,exports){
(function (global){
var stringify = require('../vendor/json-stringify-safe/stringify');

var _window =
  typeof window !== 'undefined'
    ? window
    : typeof global !== 'undefined'
      ? global
      : typeof self !== 'undefined'
        ? self
        : {};

function isObject(what) {
  return typeof what === 'object' && what !== null;
}

// Yanked from https://git.io/vS8DV re-used under CC0
// with some tiny modifications
function isError(value) {
  switch (Object.prototype.toString.call(value)) {
    case '[object Error]':
      return true;
    case '[object Exception]':
      return true;
    case '[object DOMException]':
      return true;
    default:
      return value instanceof Error;
  }
}

function isErrorEvent(value) {
  return Object.prototype.toString.call(value) === '[object ErrorEvent]';
}

function isDOMError(value) {
  return Object.prototype.toString.call(value) === '[object DOMError]';
}

function isDOMException(value) {
  return Object.prototype.toString.call(value) === '[object DOMException]';
}

function isUndefined(what) {
  return what === void 0;
}

function isFunction(what) {
  return typeof what === 'function';
}

function isPlainObject(what) {
  return Object.prototype.toString.call(what) === '[object Object]';
}

function isString(what) {
  return Object.prototype.toString.call(what) === '[object String]';
}

function isArray(what) {
  return Object.prototype.toString.call(what) === '[object Array]';
}

function isEmptyObject(what) {
  if (!isPlainObject(what)) return false;

  for (var _ in what) {
    if (what.hasOwnProperty(_)) {
      return false;
    }
  }
  return true;
}

function supportsErrorEvent() {
  try {
    new ErrorEvent(''); // eslint-disable-line no-new
    return true;
  } catch (e) {
    return false;
  }
}

function supportsDOMError() {
  try {
    new DOMError(''); // eslint-disable-line no-new
    return true;
  } catch (e) {
    return false;
  }
}

function supportsDOMException() {
  try {
    new DOMException(''); // eslint-disable-line no-new
    return true;
  } catch (e) {
    return false;
  }
}

function supportsFetch() {
  if (!('fetch' in _window)) return false;

  try {
    new Headers(); // eslint-disable-line no-new
    new Request(''); // eslint-disable-line no-new
    new Response(); // eslint-disable-line no-new
    return true;
  } catch (e) {
    return false;
  }
}

// Despite all stars in the sky saying that Edge supports old draft syntax, aka 'never', 'always', 'origin' and 'default
// https://caniuse.com/#feat=referrer-policy
// It doesn't. And it throw exception instead of ignoring this parameter...
// REF: https://github.com/getsentry/raven-js/issues/1233
function supportsReferrerPolicy() {
  if (!supportsFetch()) return false;

  try {
    // eslint-disable-next-line no-new
    new Request('pickleRick', {
      referrerPolicy: 'origin'
    });
    return true;
  } catch (e) {
    return false;
  }
}

function supportsPromiseRejectionEvent() {
  return typeof PromiseRejectionEvent === 'function';
}

function wrappedCallback(callback) {
  function dataCallback(data, original) {
    var normalizedData = callback(data) || data;
    if (original) {
      return original(normalizedData) || normalizedData;
    }
    return normalizedData;
  }

  return dataCallback;
}

function each(obj, callback) {
  var i, j;

  if (isUndefined(obj.length)) {
    for (i in obj) {
      if (hasKey(obj, i)) {
        callback.call(null, i, obj[i]);
      }
    }
  } else {
    j = obj.length;
    if (j) {
      for (i = 0; i < j; i++) {
        callback.call(null, i, obj[i]);
      }
    }
  }
}

function objectMerge(obj1, obj2) {
  if (!obj2) {
    return obj1;
  }
  each(obj2, function(key, value) {
    obj1[key] = value;
  });
  return obj1;
}

/**
 * This function is only used for react-native.
 * react-native freezes object that have already been sent over the
 * js bridge. We need this function in order to check if the object is frozen.
 * So it's ok that objectFrozen returns false if Object.isFrozen is not
 * supported because it's not relevant for other "platforms". See related issue:
 * https://github.com/getsentry/react-native-sentry/issues/57
 */
function objectFrozen(obj) {
  if (!Object.isFrozen) {
    return false;
  }
  return Object.isFrozen(obj);
}

function truncate(str, max) {
  if (typeof max !== 'number') {
    throw new Error('2nd argument to `truncate` function should be a number');
  }
  if (typeof str !== 'string' || max === 0) {
    return str;
  }
  return str.length <= max ? str : str.substr(0, max) + '\u2026';
}

/**
 * hasKey, a better form of hasOwnProperty
 * Example: hasKey(MainHostObject, property) === true/false
 *
 * @param {Object} host object to check property
 * @param {string} key to check
 */
function hasKey(object, key) {
  return Object.prototype.hasOwnProperty.call(object, key);
}

function joinRegExp(patterns) {
  // Combine an array of regular expressions and strings into one large regexp
  // Be mad.
  var sources = [],
    i = 0,
    len = patterns.length,
    pattern;

  for (; i < len; i++) {
    pattern = patterns[i];
    if (isString(pattern)) {
      // If it's a string, we need to escape it
      // Taken from: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions
      sources.push(pattern.replace(/([.*+?^=!:${}()|\[\]\/\\])/g, '\\$1'));
    } else if (pattern && pattern.source) {
      // If it's a regexp already, we want to extract the source
      sources.push(pattern.source);
    }
    // Intentionally skip other cases
  }
  return new RegExp(sources.join('|'), 'i');
}

function urlencode(o) {
  var pairs = [];
  each(o, function(key, value) {
    pairs.push(encodeURIComponent(key) + '=' + encodeURIComponent(value));
  });
  return pairs.join('&');
}

// borrowed from https://tools.ietf.org/html/rfc3986#appendix-B
// intentionally using regex and not <a/> href parsing trick because React Native and other
// environments where DOM might not be available
function parseUrl(url) {
  if (typeof url !== 'string') return {};
  var match = url.match(/^(([^:\/?#]+):)?(\/\/([^\/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?$/);

  // coerce to undefined values to empty string so we don't get 'undefined'
  var query = match[6] || '';
  var fragment = match[8] || '';
  return {
    protocol: match[2],
    host: match[4],
    path: match[5],
    relative: match[5] + query + fragment // everything minus origin
  };
}
function uuid4() {
  var crypto = _window.crypto || _window.msCrypto;

  if (!isUndefined(crypto) && crypto.getRandomValues) {
    // Use window.crypto API if available
    // eslint-disable-next-line no-undef
    var arr = new Uint16Array(8);
    crypto.getRandomValues(arr);

    // set 4 in byte 7
    arr[3] = (arr[3] & 0xfff) | 0x4000;
    // set 2 most significant bits of byte 9 to '10'
    arr[4] = (arr[4] & 0x3fff) | 0x8000;

    var pad = function(num) {
      var v = num.toString(16);
      while (v.length < 4) {
        v = '0' + v;
      }
      return v;
    };

    return (
      pad(arr[0]) +
      pad(arr[1]) +
      pad(arr[2]) +
      pad(arr[3]) +
      pad(arr[4]) +
      pad(arr[5]) +
      pad(arr[6]) +
      pad(arr[7])
    );
  } else {
    // http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/2117523#2117523
    return 'xxxxxxxxxxxx4xxxyxxxxxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
      var r = (Math.random() * 16) | 0,
        v = c === 'x' ? r : (r & 0x3) | 0x8;
      return v.toString(16);
    });
  }
}

/**
 * Given a child DOM element, returns a query-selector statement describing that
 * and its ancestors
 * e.g. [HTMLElement] => body > div > input#foo.btn[name=baz]
 * @param elem
 * @returns {string}
 */
function htmlTreeAsString(elem) {
  /* eslint no-extra-parens:0*/
  var MAX_TRAVERSE_HEIGHT = 5,
    MAX_OUTPUT_LEN = 80,
    out = [],
    height = 0,
    len = 0,
    separator = ' > ',
    sepLength = separator.length,
    nextStr;

  while (elem && height++ < MAX_TRAVERSE_HEIGHT) {
    nextStr = htmlElementAsString(elem);
    // bail out if
    // - nextStr is the 'html' element
    // - the length of the string that would be created exceeds MAX_OUTPUT_LEN
    //   (ignore this limit if we are on the first iteration)
    if (
      nextStr === 'html' ||
      (height > 1 && len + out.length * sepLength + nextStr.length >= MAX_OUTPUT_LEN)
    ) {
      break;
    }

    out.push(nextStr);

    len += nextStr.length;
    elem = elem.parentNode;
  }

  return out.reverse().join(separator);
}

/**
 * Returns a simple, query-selector representation of a DOM element
 * e.g. [HTMLElement] => input#foo.btn[name=baz]
 * @param HTMLElement
 * @returns {string}
 */
function htmlElementAsString(elem) {
  var out = [],
    className,
    classes,
    key,
    attr,
    i;

  if (!elem || !elem.tagName) {
    return '';
  }

  out.push(elem.tagName.toLowerCase());
  if (elem.id) {
    out.push('#' + elem.id);
  }

  className = elem.className;
  if (className && isString(className)) {
    classes = className.split(/\s+/);
    for (i = 0; i < classes.length; i++) {
      out.push('.' + classes[i]);
    }
  }
  var attrWhitelist = ['type', 'name', 'title', 'alt'];
  for (i = 0; i < attrWhitelist.length; i++) {
    key = attrWhitelist[i];
    attr = elem.getAttribute(key);
    if (attr) {
      out.push('[' + key + '="' + attr + '"]');
    }
  }
  return out.join('');
}

/**
 * Returns true if either a OR b is truthy, but not both
 */
function isOnlyOneTruthy(a, b) {
  return !!(!!a ^ !!b);
}

/**
 * Returns true if both parameters are undefined
 */
function isBothUndefined(a, b) {
  return isUndefined(a) && isUndefined(b);
}

/**
 * Returns true if the two input exception interfaces have the same content
 */
function isSameException(ex1, ex2) {
  if (isOnlyOneTruthy(ex1, ex2)) return false;

  ex1 = ex1.values[0];
  ex2 = ex2.values[0];

  if (ex1.type !== ex2.type || ex1.value !== ex2.value) return false;

  // in case both stacktraces are undefined, we can't decide so default to false
  if (isBothUndefined(ex1.stacktrace, ex2.stacktrace)) return false;

  return isSameStacktrace(ex1.stacktrace, ex2.stacktrace);
}

/**
 * Returns true if the two input stack trace interfaces have the same content
 */
function isSameStacktrace(stack1, stack2) {
  if (isOnlyOneTruthy(stack1, stack2)) return false;

  var frames1 = stack1.frames;
  var frames2 = stack2.frames;

  // Exit early if stacktrace is malformed
  if (frames1 === undefined || frames2 === undefined) return false;

  // Exit early if frame count differs
  if (frames1.length !== frames2.length) return false;

  // Iterate through every frame; bail out if anything differs
  var a, b;
  for (var i = 0; i < frames1.length; i++) {
    a = frames1[i];
    b = frames2[i];
    if (
      a.filename !== b.filename ||
      a.lineno !== b.lineno ||
      a.colno !== b.colno ||
      a['function'] !== b['function']
    )
      return false;
  }
  return true;
}

/**
 * Polyfill a method
 * @param obj object e.g. `document`
 * @param name method name present on object e.g. `addEventListener`
 * @param replacement replacement function
 * @param track {optional} record instrumentation to an array
 */
function fill(obj, name, replacement, track) {
  if (obj == null) return;
  var orig = obj[name];
  obj[name] = replacement(orig);
  obj[name].__raven__ = true;
  obj[name].__orig__ = orig;
  if (track) {
    track.push([obj, name, orig]);
  }
}

/**
 * Join values in array
 * @param input array of values to be joined together
 * @param delimiter string to be placed in-between values
 * @returns {string}
 */
function safeJoin(input, delimiter) {
  if (!isArray(input)) return '';

  var output = [];

  for (var i = 0; i < input.length; i++) {
    try {
      output.push(String(input[i]));
    } catch (e) {
      output.push('[value cannot be serialized]');
    }
  }

  return output.join(delimiter);
}

// Default Node.js REPL depth
var MAX_SERIALIZE_EXCEPTION_DEPTH = 3;
// 50kB, as 100kB is max payload size, so half sounds reasonable
var MAX_SERIALIZE_EXCEPTION_SIZE = 50 * 1024;
var MAX_SERIALIZE_KEYS_LENGTH = 40;

function utf8Length(value) {
  return ~-encodeURI(value).split(/%..|./).length;
}

function jsonSize(value) {
  return utf8Length(JSON.stringify(value));
}

function serializeValue(value) {
  if (typeof value === 'string') {
    var maxLength = 40;
    return truncate(value, maxLength);
  } else if (
    typeof value === 'number' ||
    typeof value === 'boolean' ||
    typeof value === 'undefined'
  ) {
    return value;
  }

  var type = Object.prototype.toString.call(value);

  // Node.js REPL notation
  if (type === '[object Object]') return '[Object]';
  if (type === '[object Array]') return '[Array]';
  if (type === '[object Function]')
    return value.name ? '[Function: ' + value.name + ']' : '[Function]';

  return value;
}

function serializeObject(value, depth) {
  if (depth === 0) return serializeValue(value);

  if (isPlainObject(value)) {
    return Object.keys(value).reduce(function(acc, key) {
      acc[key] = serializeObject(value[key], depth - 1);
      return acc;
    }, {});
  } else if (Array.isArray(value)) {
    return value.map(function(val) {
      return serializeObject(val, depth - 1);
    });
  }

  return serializeValue(value);
}

function serializeException(ex, depth, maxSize) {
  if (!isPlainObject(ex)) return ex;

  depth = typeof depth !== 'number' ? MAX_SERIALIZE_EXCEPTION_DEPTH : depth;
  maxSize = typeof depth !== 'number' ? MAX_SERIALIZE_EXCEPTION_SIZE : maxSize;

  var serialized = serializeObject(ex, depth);

  if (jsonSize(stringify(serialized)) > maxSize) {
    return serializeException(ex, depth - 1);
  }

  return serialized;
}

function serializeKeysForMessage(keys, maxLength) {
  if (typeof keys === 'number' || typeof keys === 'string') return keys.toString();
  if (!Array.isArray(keys)) return '';

  keys = keys.filter(function(key) {
    return typeof key === 'string';
  });
  if (keys.length === 0) return '[object has no keys]';

  maxLength = typeof maxLength !== 'number' ? MAX_SERIALIZE_KEYS_LENGTH : maxLength;
  if (keys[0].length >= maxLength) return keys[0];

  for (var usedKeys = keys.length; usedKeys > 0; usedKeys--) {
    var serialized = keys.slice(0, usedKeys).join(', ');
    if (serialized.length > maxLength) continue;
    if (usedKeys === keys.length) return serialized;
    return serialized + '\u2026';
  }

  return '';
}

function sanitize(input, sanitizeKeys) {
  if (!isArray(sanitizeKeys) || (isArray(sanitizeKeys) && sanitizeKeys.length === 0))
    return input;

  var sanitizeRegExp = joinRegExp(sanitizeKeys);
  var sanitizeMask = '********';
  var safeInput;

  try {
    safeInput = JSON.parse(stringify(input));
  } catch (o_O) {
    return input;
  }

  function sanitizeWorker(workerInput) {
    if (isArray(workerInput)) {
      return workerInput.map(function(val) {
        return sanitizeWorker(val);
      });
    }

    if (isPlainObject(workerInput)) {
      return Object.keys(workerInput).reduce(function(acc, k) {
        if (sanitizeRegExp.test(k)) {
          acc[k] = sanitizeMask;
        } else {
          acc[k] = sanitizeWorker(workerInput[k]);
        }
        return acc;
      }, {});
    }

    return workerInput;
  }

  return sanitizeWorker(safeInput);
}

module.exports = {
  isObject: isObject,
  isError: isError,
  isErrorEvent: isErrorEvent,
  isDOMError: isDOMError,
  isDOMException: isDOMException,
  isUndefined: isUndefined,
  isFunction: isFunction,
  isPlainObject: isPlainObject,
  isString: isString,
  isArray: isArray,
  isEmptyObject: isEmptyObject,
  supportsErrorEvent: supportsErrorEvent,
  supportsDOMError: supportsDOMError,
  supportsDOMException: supportsDOMException,
  supportsFetch: supportsFetch,
  supportsReferrerPolicy: supportsReferrerPolicy,
  supportsPromiseRejectionEvent: supportsPromiseRejectionEvent,
  wrappedCallback: wrappedCallback,
  each: each,
  objectMerge: objectMerge,
  truncate: truncate,
  objectFrozen: objectFrozen,
  hasKey: hasKey,
  joinRegExp: joinRegExp,
  urlencode: urlencode,
  uuid4: uuid4,
  htmlTreeAsString: htmlTreeAsString,
  htmlElementAsString: htmlElementAsString,
  isSameException: isSameException,
  isSameStacktrace: isSameStacktrace,
  parseUrl: parseUrl,
  fill: fill,
  safeJoin: safeJoin,
  serializeException: serializeException,
  serializeKeysForMessage: serializeKeysForMessage,
  sanitize: sanitize
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../vendor/json-stringify-safe/stringify":439}],438:[function(require,module,exports){
(function (global){
var utils = require('../../src/utils');

/*
 TraceKit - Cross brower stack traces

 This was originally forked from github.com/occ/TraceKit, but has since been
 largely re-written and is now maintained as part of raven-js.  Tests for
 this are in test/vendor.

 MIT license
*/

var TraceKit = {
  collectWindowErrors: true,
  debug: false
};

// This is to be defensive in environments where window does not exist (see https://github.com/getsentry/raven-js/pull/785)
var _window =
  typeof window !== 'undefined'
    ? window
    : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

// global reference to slice
var _slice = [].slice;
var UNKNOWN_FUNCTION = '?';

// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error#Error_types
var ERROR_TYPES_RE = /^(?:[Uu]ncaught (?:exception: )?)?(?:((?:Eval|Internal|Range|Reference|Syntax|Type|URI|)Error): )?(.*)$/;

function getLocationHref() {
  if (typeof document === 'undefined' || document.location == null) return '';
  return document.location.href;
}

function getLocationOrigin() {
  if (typeof document === 'undefined' || document.location == null) return '';

  // Oh dear IE10...
  if (!document.location.origin) {
    return (
      document.location.protocol +
      '//' +
      document.location.hostname +
      (document.location.port ? ':' + document.location.port : '')
    );
  }

  return document.location.origin;
}

/**
 * TraceKit.report: cross-browser processing of unhandled exceptions
 *
 * Syntax:
 *   TraceKit.report.subscribe(function(stackInfo) { ... })
 *   TraceKit.report.unsubscribe(function(stackInfo) { ... })
 *   TraceKit.report(exception)
 *   try { ...code... } catch(ex) { TraceKit.report(ex); }
 *
 * Supports:
 *   - Firefox: full stack trace with line numbers, plus column number
 *              on top frame; column number is not guaranteed
 *   - Opera:   full stack trace with line and column numbers
 *   - Chrome:  full stack trace with line and column numbers
 *   - Safari:  line and column number for the top frame only; some frames
 *              may be missing, and column number is not guaranteed
 *   - IE:      line and column number for the top frame only; some frames
 *              may be missing, and column number is not guaranteed
 *
 * In theory, TraceKit should work on all of the following versions:
 *   - IE5.5+ (only 8.0 tested)
 *   - Firefox 0.9+ (only 3.5+ tested)
 *   - Opera 7+ (only 10.50 tested; versions 9 and earlier may require
 *     Exceptions Have Stacktrace to be enabled in opera:config)
 *   - Safari 3+ (only 4+ tested)
 *   - Chrome 1+ (only 5+ tested)
 *   - Konqueror 3.5+ (untested)
 *
 * Requires TraceKit.computeStackTrace.
 *
 * Tries to catch all unhandled exceptions and report them to the
 * subscribed handlers. Please note that TraceKit.report will rethrow the
 * exception. This is REQUIRED in order to get a useful stack trace in IE.
 * If the exception does not reach the top of the browser, you will only
 * get a stack trace from the point where TraceKit.report was called.
 *
 * Handlers receive a stackInfo object as described in the
 * TraceKit.computeStackTrace docs.
 */
TraceKit.report = (function reportModuleWrapper() {
  var handlers = [],
    lastArgs = null,
    lastException = null,
    lastExceptionStack = null;

  /**
   * Add a crash handler.
   * @param {Function} handler
   */
  function subscribe(handler) {
    installGlobalHandler();
    handlers.push(handler);
  }

  /**
   * Remove a crash handler.
   * @param {Function} handler
   */
  function unsubscribe(handler) {
    for (var i = handlers.length - 1; i >= 0; --i) {
      if (handlers[i] === handler) {
        handlers.splice(i, 1);
      }
    }
  }

  /**
   * Remove all crash handlers.
   */
  function unsubscribeAll() {
    uninstallGlobalHandler();
    handlers = [];
  }

  /**
   * Dispatch stack information to all handlers.
   * @param {Object.<string, *>} stack
   */
  function notifyHandlers(stack, isWindowError) {
    var exception = null;
    if (isWindowError && !TraceKit.collectWindowErrors) {
      return;
    }
    for (var i in handlers) {
      if (handlers.hasOwnProperty(i)) {
        try {
          handlers[i].apply(null, [stack].concat(_slice.call(arguments, 2)));
        } catch (inner) {
          exception = inner;
        }
      }
    }

    if (exception) {
      throw exception;
    }
  }

  var _oldOnerrorHandler, _onErrorHandlerInstalled;

  /**
   * Ensures all global unhandled exceptions are recorded.
   * Supported by Gecko and IE.
   * @param {string} msg Error message.
   * @param {string} url URL of script that generated the exception.
   * @param {(number|string)} lineNo The line number at which the error
   * occurred.
   * @param {?(number|string)} colNo The column number at which the error
   * occurred.
   * @param {?Error} ex The actual Error object.
   */
  function traceKitWindowOnError(msg, url, lineNo, colNo, ex) {
    var stack = null;
    // If 'ex' is ErrorEvent, get real Error from inside
    var exception = utils.isErrorEvent(ex) ? ex.error : ex;
    // If 'msg' is ErrorEvent, get real message from inside
    var message = utils.isErrorEvent(msg) ? msg.message : msg;

    if (lastExceptionStack) {
      TraceKit.computeStackTrace.augmentStackTraceWithInitialElement(
        lastExceptionStack,
        url,
        lineNo,
        message
      );
      processLastException();
    } else if (exception && utils.isError(exception)) {
      // non-string `exception` arg; attempt to extract stack trace

      // New chrome and blink send along a real error object
      // Let's just report that like a normal error.
      // See: https://mikewest.org/2013/08/debugging-runtime-errors-with-window-onerror
      stack = TraceKit.computeStackTrace(exception);
      notifyHandlers(stack, true);
    } else {
      var location = {
        url: url,
        line: lineNo,
        column: colNo
      };

      var name = undefined;
      var groups;

      if ({}.toString.call(message) === '[object String]') {
        var groups = message.match(ERROR_TYPES_RE);
        if (groups) {
          name = groups[1];
          message = groups[2];
        }
      }

      location.func = UNKNOWN_FUNCTION;

      stack = {
        name: name,
        message: message,
        url: getLocationHref(),
        stack: [location]
      };
      notifyHandlers(stack, true);
    }

    if (_oldOnerrorHandler) {
      return _oldOnerrorHandler.apply(this, arguments);
    }

    return false;
  }

  function installGlobalHandler() {
    if (_onErrorHandlerInstalled) {
      return;
    }
    _oldOnerrorHandler = _window.onerror;
    _window.onerror = traceKitWindowOnError;
    _onErrorHandlerInstalled = true;
  }

  function uninstallGlobalHandler() {
    if (!_onErrorHandlerInstalled) {
      return;
    }
    _window.onerror = _oldOnerrorHandler;
    _onErrorHandlerInstalled = false;
    _oldOnerrorHandler = undefined;
  }

  function processLastException() {
    var _lastExceptionStack = lastExceptionStack,
      _lastArgs = lastArgs;
    lastArgs = null;
    lastExceptionStack = null;
    lastException = null;
    notifyHandlers.apply(null, [_lastExceptionStack, false].concat(_lastArgs));
  }

  /**
   * Reports an unhandled Error to TraceKit.
   * @param {Error} ex
   * @param {?boolean} rethrow If false, do not re-throw the exception.
   * Only used for window.onerror to not cause an infinite loop of
   * rethrowing.
   */
  function report(ex, rethrow) {
    var args = _slice.call(arguments, 1);
    if (lastExceptionStack) {
      if (lastException === ex) {
        return; // already caught by an inner catch block, ignore
      } else {
        processLastException();
      }
    }

    var stack = TraceKit.computeStackTrace(ex);
    lastExceptionStack = stack;
    lastException = ex;
    lastArgs = args;

    // If the stack trace is incomplete, wait for 2 seconds for
    // slow slow IE to see if onerror occurs or not before reporting
    // this exception; otherwise, we will end up with an incomplete
    // stack trace
    setTimeout(function() {
      if (lastException === ex) {
        processLastException();
      }
    }, stack.incomplete ? 2000 : 0);

    if (rethrow !== false) {
      throw ex; // re-throw to propagate to the top level (and cause window.onerror)
    }
  }

  report.subscribe = subscribe;
  report.unsubscribe = unsubscribe;
  report.uninstall = unsubscribeAll;
  return report;
})();

/**
 * TraceKit.computeStackTrace: cross-browser stack traces in JavaScript
 *
 * Syntax:
 *   s = TraceKit.computeStackTrace(exception) // consider using TraceKit.report instead (see below)
 * Returns:
 *   s.name              - exception name
 *   s.message           - exception message
 *   s.stack[i].url      - JavaScript or HTML file URL
 *   s.stack[i].func     - function name, or empty for anonymous functions (if guessing did not work)
 *   s.stack[i].args     - arguments passed to the function, if known
 *   s.stack[i].line     - line number, if known
 *   s.stack[i].column   - column number, if known
 *
 * Supports:
 *   - Firefox:  full stack trace with line numbers and unreliable column
 *               number on top frame
 *   - Opera 10: full stack trace with line and column numbers
 *   - Opera 9-: full stack trace with line numbers
 *   - Chrome:   full stack trace with line and column numbers
 *   - Safari:   line and column number for the topmost stacktrace element
 *               only
 *   - IE:       no line numbers whatsoever
 *
 * Tries to guess names of anonymous functions by looking for assignments
 * in the source code. In IE and Safari, we have to guess source file names
 * by searching for function bodies inside all page scripts. This will not
 * work for scripts that are loaded cross-domain.
 * Here be dragons: some function names may be guessed incorrectly, and
 * duplicate functions may be mismatched.
 *
 * TraceKit.computeStackTrace should only be used for tracing purposes.
 * Logging of unhandled exceptions should be done with TraceKit.report,
 * which builds on top of TraceKit.computeStackTrace and provides better
 * IE support by utilizing the window.onerror event to retrieve information
 * about the top of the stack.
 *
 * Note: In IE and Safari, no stack trace is recorded on the Error object,
 * so computeStackTrace instead walks its *own* chain of callers.
 * This means that:
 *  * in Safari, some methods may be missing from the stack trace;
 *  * in IE, the topmost function in the stack trace will always be the
 *    caller of computeStackTrace.
 *
 * This is okay for tracing (because you are likely to be calling
 * computeStackTrace from the function you want to be the topmost element
 * of the stack trace anyway), but not okay for logging unhandled
 * exceptions (because your catch block will likely be far away from the
 * inner function that actually caused the exception).
 *
 */
TraceKit.computeStackTrace = (function computeStackTraceWrapper() {
  // Contents of Exception in various browsers.
  //
  // SAFARI:
  // ex.message = Can't find variable: qq
  // ex.line = 59
  // ex.sourceId = 580238192
  // ex.sourceURL = http://...
  // ex.expressionBeginOffset = 96
  // ex.expressionCaretOffset = 98
  // ex.expressionEndOffset = 98
  // ex.name = ReferenceError
  //
  // FIREFOX:
  // ex.message = qq is not defined
  // ex.fileName = http://...
  // ex.lineNumber = 59
  // ex.columnNumber = 69
  // ex.stack = ...stack trace... (see the example below)
  // ex.name = ReferenceError
  //
  // CHROME:
  // ex.message = qq is not defined
  // ex.name = ReferenceError
  // ex.type = not_defined
  // ex.arguments = ['aa']
  // ex.stack = ...stack trace...
  //
  // INTERNET EXPLORER:
  // ex.message = ...
  // ex.name = ReferenceError
  //
  // OPERA:
  // ex.message = ...message... (see the example below)
  // ex.name = ReferenceError
  // ex.opera#sourceloc = 11  (pretty much useless, duplicates the info in ex.message)
  // ex.stacktrace = n/a; see 'opera:config#UserPrefs|Exceptions Have Stacktrace'

  /**
   * Computes stack trace information from the stack property.
   * Chrome and Gecko use this property.
   * @param {Error} ex
   * @return {?Object.<string, *>} Stack trace information.
   */
  function computeStackTraceFromStackProp(ex) {
    if (typeof ex.stack === 'undefined' || !ex.stack) return;

    var chrome = /^\s*at (?:(.*?) ?\()?((?:file|https?|blob|chrome-extension|native|eval|webpack|<anonymous>|[a-z]:|\/).*?)(?::(\d+))?(?::(\d+))?\)?\s*$/i;
    var winjs = /^\s*at (?:((?:\[object object\])?.+) )?\(?((?:file|ms-appx(?:-web)|https?|webpack|blob):.*?):(\d+)(?::(\d+))?\)?\s*$/i;
    // NOTE: blob urls are now supposed to always have an origin, therefore it's format
    // which is `blob:http://url/path/with-some-uuid`, is matched by `blob.*?:\/` as well
    var gecko = /^\s*(.*?)(?:\((.*?)\))?(?:^|@)((?:file|https?|blob|chrome|webpack|resource|moz-extension).*?:\/.*?|\[native code\]|[^@]*bundle)(?::(\d+))?(?::(\d+))?\s*$/i;
    // Used to additionally parse URL/line/column from eval frames
    var geckoEval = /(\S+) line (\d+)(?: > eval line \d+)* > eval/i;
    var chromeEval = /\((\S*)(?::(\d+))(?::(\d+))\)/;
    var lines = ex.stack.split('\n');
    var stack = [];
    var submatch;
    var parts;
    var element;
    var reference = /^(.*) is undefined$/.exec(ex.message);

    for (var i = 0, j = lines.length; i < j; ++i) {
      if ((parts = chrome.exec(lines[i]))) {
        var isNative = parts[2] && parts[2].indexOf('native') === 0; // start of line
        var isEval = parts[2] && parts[2].indexOf('eval') === 0; // start of line
        if (isEval && (submatch = chromeEval.exec(parts[2]))) {
          // throw out eval line/column and use top-most line/column number
          parts[2] = submatch[1]; // url
          parts[3] = submatch[2]; // line
          parts[4] = submatch[3]; // column
        }
        element = {
          url: !isNative ? parts[2] : null,
          func: parts[1] || UNKNOWN_FUNCTION,
          args: isNative ? [parts[2]] : [],
          line: parts[3] ? +parts[3] : null,
          column: parts[4] ? +parts[4] : null
        };
      } else if ((parts = winjs.exec(lines[i]))) {
        element = {
          url: parts[2],
          func: parts[1] || UNKNOWN_FUNCTION,
          args: [],
          line: +parts[3],
          column: parts[4] ? +parts[4] : null
        };
      } else if ((parts = gecko.exec(lines[i]))) {
        var isEval = parts[3] && parts[3].indexOf(' > eval') > -1;
        if (isEval && (submatch = geckoEval.exec(parts[3]))) {
          // throw out eval line/column and use top-most line number
          parts[3] = submatch[1];
          parts[4] = submatch[2];
          parts[5] = null; // no column when eval
        } else if (i === 0 && !parts[5] && typeof ex.columnNumber !== 'undefined') {
          // FireFox uses this awesome columnNumber property for its top frame
          // Also note, Firefox's column number is 0-based and everything else expects 1-based,
          // so adding 1
          // NOTE: this hack doesn't work if top-most frame is eval
          stack[0].column = ex.columnNumber + 1;
        }
        element = {
          url: parts[3],
          func: parts[1] || UNKNOWN_FUNCTION,
          args: parts[2] ? parts[2].split(',') : [],
          line: parts[4] ? +parts[4] : null,
          column: parts[5] ? +parts[5] : null
        };
      } else {
        continue;
      }

      if (!element.func && element.line) {
        element.func = UNKNOWN_FUNCTION;
      }

      if (element.url && element.url.substr(0, 5) === 'blob:') {
        // Special case for handling JavaScript loaded into a blob.
        // We use a synchronous AJAX request here as a blob is already in
        // memory - it's not making a network request.  This will generate a warning
        // in the browser console, but there has already been an error so that's not
        // that much of an issue.
        var xhr = new XMLHttpRequest();
        xhr.open('GET', element.url, false);
        xhr.send(null);

        // If we failed to download the source, skip this patch
        if (xhr.status === 200) {
          var source = xhr.responseText || '';

          // We trim the source down to the last 300 characters as sourceMappingURL is always at the end of the file.
          // Why 300? To be in line with: https://github.com/getsentry/sentry/blob/4af29e8f2350e20c28a6933354e4f42437b4ba42/src/sentry/lang/javascript/processor.py#L164-L175
          source = source.slice(-300);

          // Now we dig out the source map URL
          var sourceMaps = source.match(/\/\/# sourceMappingURL=(.*)$/);

          // If we don't find a source map comment or we find more than one, continue on to the next element.
          if (sourceMaps) {
            var sourceMapAddress = sourceMaps[1];

            // Now we check to see if it's a relative URL.
            // If it is, convert it to an absolute one.
            if (sourceMapAddress.charAt(0) === '~') {
              sourceMapAddress = getLocationOrigin() + sourceMapAddress.slice(1);
            }

            // Now we strip the '.map' off of the end of the URL and update the
            // element so that Sentry can match the map to the blob.
            element.url = sourceMapAddress.slice(0, -4);
          }
        }
      }

      stack.push(element);
    }

    if (!stack.length) {
      return null;
    }

    return {
      name: ex.name,
      message: ex.message,
      url: getLocationHref(),
      stack: stack
    };
  }

  /**
   * Adds information about the first frame to incomplete stack traces.
   * Safari and IE require this to get complete data on the first frame.
   * @param {Object.<string, *>} stackInfo Stack trace information from
   * one of the compute* methods.
   * @param {string} url The URL of the script that caused an error.
   * @param {(number|string)} lineNo The line number of the script that
   * caused an error.
   * @param {string=} message The error generated by the browser, which
   * hopefully contains the name of the object that caused the error.
   * @return {boolean} Whether or not the stack information was
   * augmented.
   */
  function augmentStackTraceWithInitialElement(stackInfo, url, lineNo, message) {
    var initial = {
      url: url,
      line: lineNo
    };

    if (initial.url && initial.line) {
      stackInfo.incomplete = false;

      if (!initial.func) {
        initial.func = UNKNOWN_FUNCTION;
      }

      if (stackInfo.stack.length > 0) {
        if (stackInfo.stack[0].url === initial.url) {
          if (stackInfo.stack[0].line === initial.line) {
            return false; // already in stack trace
          } else if (
            !stackInfo.stack[0].line &&
            stackInfo.stack[0].func === initial.func
          ) {
            stackInfo.stack[0].line = initial.line;
            return false;
          }
        }
      }

      stackInfo.stack.unshift(initial);
      stackInfo.partial = true;
      return true;
    } else {
      stackInfo.incomplete = true;
    }

    return false;
  }

  /**
   * Computes stack trace information by walking the arguments.caller
   * chain at the time the exception occurred. This will cause earlier
   * frames to be missed but is the only way to get any stack trace in
   * Safari and IE. The top frame is restored by
   * {@link augmentStackTraceWithInitialElement}.
   * @param {Error} ex
   * @return {?Object.<string, *>} Stack trace information.
   */
  function computeStackTraceByWalkingCallerChain(ex, depth) {
    var functionName = /function\s+([_$a-zA-Z\xA0-\uFFFF][_$a-zA-Z0-9\xA0-\uFFFF]*)?\s*\(/i,
      stack = [],
      funcs = {},
      recursion = false,
      parts,
      item,
      source;

    for (
      var curr = computeStackTraceByWalkingCallerChain.caller;
      curr && !recursion;
      curr = curr.caller
    ) {
      if (curr === computeStackTrace || curr === TraceKit.report) {
        // console.log('skipping internal function');
        continue;
      }

      item = {
        url: null,
        func: UNKNOWN_FUNCTION,
        line: null,
        column: null
      };

      if (curr.name) {
        item.func = curr.name;
      } else if ((parts = functionName.exec(curr.toString()))) {
        item.func = parts[1];
      }

      if (typeof item.func === 'undefined') {
        try {
          item.func = parts.input.substring(0, parts.input.indexOf('{'));
        } catch (e) {}
      }

      if (funcs['' + curr]) {
        recursion = true;
      } else {
        funcs['' + curr] = true;
      }

      stack.push(item);
    }

    if (depth) {
      // console.log('depth is ' + depth);
      // console.log('stack is ' + stack.length);
      stack.splice(0, depth);
    }

    var result = {
      name: ex.name,
      message: ex.message,
      url: getLocationHref(),
      stack: stack
    };
    augmentStackTraceWithInitialElement(
      result,
      ex.sourceURL || ex.fileName,
      ex.line || ex.lineNumber,
      ex.message || ex.description
    );
    return result;
  }

  /**
   * Computes a stack trace for an exception.
   * @param {Error} ex
   * @param {(string|number)=} depth
   */
  function computeStackTrace(ex, depth) {
    var stack = null;
    depth = depth == null ? 0 : +depth;

    try {
      stack = computeStackTraceFromStackProp(ex);
      if (stack) {
        return stack;
      }
    } catch (e) {
      if (TraceKit.debug) {
        throw e;
      }
    }

    try {
      stack = computeStackTraceByWalkingCallerChain(ex, depth + 1);
      if (stack) {
        return stack;
      }
    } catch (e) {
      if (TraceKit.debug) {
        throw e;
      }
    }
    return {
      name: ex.name,
      message: ex.message,
      url: getLocationHref()
    };
  }

  computeStackTrace.augmentStackTraceWithInitialElement = augmentStackTraceWithInitialElement;
  computeStackTrace.computeStackTraceFromStackProp = computeStackTraceFromStackProp;

  return computeStackTrace;
})();

module.exports = TraceKit;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../src/utils":437}],439:[function(require,module,exports){
/*
 json-stringify-safe
 Like JSON.stringify, but doesn't throw on circular references.

 Originally forked from https://github.com/isaacs/json-stringify-safe
 version 5.0.1 on 3/8/2017 and modified to handle Errors serialization
 and IE8 compatibility. Tests for this are in test/vendor.

 ISC license: https://github.com/isaacs/json-stringify-safe/blob/master/LICENSE
*/

exports = module.exports = stringify;
exports.getSerialize = serializer;

function indexOf(haystack, needle) {
  for (var i = 0; i < haystack.length; ++i) {
    if (haystack[i] === needle) return i;
  }
  return -1;
}

function stringify(obj, replacer, spaces, cycleReplacer) {
  return JSON.stringify(obj, serializer(replacer, cycleReplacer), spaces);
}

// https://github.com/ftlabs/js-abbreviate/blob/fa709e5f139e7770a71827b1893f22418097fbda/index.js#L95-L106
function stringifyError(value) {
  var err = {
    // These properties are implemented as magical getters and don't show up in for in
    stack: value.stack,
    message: value.message,
    name: value.name
  };

  for (var i in value) {
    if (Object.prototype.hasOwnProperty.call(value, i)) {
      err[i] = value[i];
    }
  }

  return err;
}

function serializer(replacer, cycleReplacer) {
  var stack = [];
  var keys = [];

  if (cycleReplacer == null) {
    cycleReplacer = function(key, value) {
      if (stack[0] === value) {
        return '[Circular ~]';
      }
      return '[Circular ~.' + keys.slice(0, indexOf(stack, value)).join('.') + ']';
    };
  }

  return function(key, value) {
    if (stack.length > 0) {
      var thisPos = indexOf(stack, this);
      ~thisPos ? stack.splice(thisPos + 1) : stack.push(this);
      ~thisPos ? keys.splice(thisPos, Infinity, key) : keys.push(key);

      if (~indexOf(stack, value)) {
        value = cycleReplacer.call(this, key, value);
      }
    } else {
      stack.push(value);
    }

    return replacer == null
      ? value instanceof Error ? stringifyError(value) : value
      : replacer.call(this, key, value);
  };
}

},{}],440:[function(require,module,exports){
/*
 * JavaScript MD5
 * https://github.com/blueimp/JavaScript-MD5
 *
 * Copyright 2011, Sebastian Tschan
 * https://blueimp.net
 *
 * Licensed under the MIT license:
 * https://opensource.org/licenses/MIT
 *
 * Based on
 * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message
 * Digest Algorithm, as defined in RFC 1321.
 * Version 2.2 Copyright (C) Paul Johnston 1999 - 2009
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for more info.
 */

/*
* Add integers, wrapping at 2^32. This uses 16-bit operations internally
* to work around bugs in some JS interpreters.
*/
function safeAdd(x, y) {
  var lsw = (x & 0xffff) + (y & 0xffff);
  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
  return (msw << 16) | (lsw & 0xffff);
}

/*
* Bitwise rotate a 32-bit number to the left.
*/
function bitRotateLeft(num, cnt) {
  return (num << cnt) | (num >>> (32 - cnt));
}

/*
* These functions implement the four basic operations the algorithm uses.
*/
function md5cmn(q, a, b, x, s, t) {
  return safeAdd(bitRotateLeft(safeAdd(safeAdd(a, q), safeAdd(x, t)), s), b);
}
function md5ff(a, b, c, d, x, s, t) {
  return md5cmn((b & c) | (~b & d), a, b, x, s, t);
}
function md5gg(a, b, c, d, x, s, t) {
  return md5cmn((b & d) | (c & ~d), a, b, x, s, t);
}
function md5hh(a, b, c, d, x, s, t) {
  return md5cmn(b ^ c ^ d, a, b, x, s, t);
}
function md5ii(a, b, c, d, x, s, t) {
  return md5cmn(c ^ (b | ~d), a, b, x, s, t);
}

/*
* Calculate the MD5 of an array of little-endian words, and a bit length.
*/
function binlMD5(x, len) {
  /* append padding */
  x[len >> 5] |= 0x80 << (len % 32);
  x[(((len + 64) >>> 9) << 4) + 14] = len;

  var i;
  var olda;
  var oldb;
  var oldc;
  var oldd;
  var a = 1732584193;
  var b = -271733879;
  var c = -1732584194;
  var d = 271733878;

  for (i = 0; i < x.length; i += 16) {
    olda = a;
    oldb = b;
    oldc = c;
    oldd = d;

    a = md5ff(a, b, c, d, x[i], 7, -680876936);
    d = md5ff(d, a, b, c, x[i + 1], 12, -389564586);
    c = md5ff(c, d, a, b, x[i + 2], 17, 606105819);
    b = md5ff(b, c, d, a, x[i + 3], 22, -1044525330);
    a = md5ff(a, b, c, d, x[i + 4], 7, -176418897);
    d = md5ff(d, a, b, c, x[i + 5], 12, 1200080426);
    c = md5ff(c, d, a, b, x[i + 6], 17, -1473231341);
    b = md5ff(b, c, d, a, x[i + 7], 22, -45705983);
    a = md5ff(a, b, c, d, x[i + 8], 7, 1770035416);
    d = md5ff(d, a, b, c, x[i + 9], 12, -1958414417);
    c = md5ff(c, d, a, b, x[i + 10], 17, -42063);
    b = md5ff(b, c, d, a, x[i + 11], 22, -1990404162);
    a = md5ff(a, b, c, d, x[i + 12], 7, 1804603682);
    d = md5ff(d, a, b, c, x[i + 13], 12, -40341101);
    c = md5ff(c, d, a, b, x[i + 14], 17, -1502002290);
    b = md5ff(b, c, d, a, x[i + 15], 22, 1236535329);

    a = md5gg(a, b, c, d, x[i + 1], 5, -165796510);
    d = md5gg(d, a, b, c, x[i + 6], 9, -1069501632);
    c = md5gg(c, d, a, b, x[i + 11], 14, 643717713);
    b = md5gg(b, c, d, a, x[i], 20, -373897302);
    a = md5gg(a, b, c, d, x[i + 5], 5, -701558691);
    d = md5gg(d, a, b, c, x[i + 10], 9, 38016083);
    c = md5gg(c, d, a, b, x[i + 15], 14, -660478335);
    b = md5gg(b, c, d, a, x[i + 4], 20, -405537848);
    a = md5gg(a, b, c, d, x[i + 9], 5, 568446438);
    d = md5gg(d, a, b, c, x[i + 14], 9, -1019803690);
    c = md5gg(c, d, a, b, x[i + 3], 14, -187363961);
    b = md5gg(b, c, d, a, x[i + 8], 20, 1163531501);
    a = md5gg(a, b, c, d, x[i + 13], 5, -1444681467);
    d = md5gg(d, a, b, c, x[i + 2], 9, -51403784);
    c = md5gg(c, d, a, b, x[i + 7], 14, 1735328473);
    b = md5gg(b, c, d, a, x[i + 12], 20, -1926607734);

    a = md5hh(a, b, c, d, x[i + 5], 4, -378558);
    d = md5hh(d, a, b, c, x[i + 8], 11, -2022574463);
    c = md5hh(c, d, a, b, x[i + 11], 16, 1839030562);
    b = md5hh(b, c, d, a, x[i + 14], 23, -35309556);
    a = md5hh(a, b, c, d, x[i + 1], 4, -1530992060);
    d = md5hh(d, a, b, c, x[i + 4], 11, 1272893353);
    c = md5hh(c, d, a, b, x[i + 7], 16, -155497632);
    b = md5hh(b, c, d, a, x[i + 10], 23, -1094730640);
    a = md5hh(a, b, c, d, x[i + 13], 4, 681279174);
    d = md5hh(d, a, b, c, x[i], 11, -358537222);
    c = md5hh(c, d, a, b, x[i + 3], 16, -722521979);
    b = md5hh(b, c, d, a, x[i + 6], 23, 76029189);
    a = md5hh(a, b, c, d, x[i + 9], 4, -640364487);
    d = md5hh(d, a, b, c, x[i + 12], 11, -421815835);
    c = md5hh(c, d, a, b, x[i + 15], 16, 530742520);
    b = md5hh(b, c, d, a, x[i + 2], 23, -995338651);

    a = md5ii(a, b, c, d, x[i], 6, -198630844);
    d = md5ii(d, a, b, c, x[i + 7], 10, 1126891415);
    c = md5ii(c, d, a, b, x[i + 14], 15, -1416354905);
    b = md5ii(b, c, d, a, x[i + 5], 21, -57434055);
    a = md5ii(a, b, c, d, x[i + 12], 6, 1700485571);
    d = md5ii(d, a, b, c, x[i + 3], 10, -1894986606);
    c = md5ii(c, d, a, b, x[i + 10], 15, -1051523);
    b = md5ii(b, c, d, a, x[i + 1], 21, -2054922799);
    a = md5ii(a, b, c, d, x[i + 8], 6, 1873313359);
    d = md5ii(d, a, b, c, x[i + 15], 10, -30611744);
    c = md5ii(c, d, a, b, x[i + 6], 15, -1560198380);
    b = md5ii(b, c, d, a, x[i + 13], 21, 1309151649);
    a = md5ii(a, b, c, d, x[i + 4], 6, -145523070);
    d = md5ii(d, a, b, c, x[i + 11], 10, -1120210379);
    c = md5ii(c, d, a, b, x[i + 2], 15, 718787259);
    b = md5ii(b, c, d, a, x[i + 9], 21, -343485551);

    a = safeAdd(a, olda);
    b = safeAdd(b, oldb);
    c = safeAdd(c, oldc);
    d = safeAdd(d, oldd);
  }
  return [a, b, c, d];
}

/*
* Convert an array of little-endian words to a string
*/
function binl2rstr(input) {
  var i;
  var output = '';
  var length32 = input.length * 32;
  for (i = 0; i < length32; i += 8) {
    output += String.fromCharCode((input[i >> 5] >>> (i % 32)) & 0xff);
  }
  return output;
}

/*
* Convert a raw string to an array of little-endian words
* Characters >255 have their high-byte silently ignored.
*/
function rstr2binl(input) {
  var i;
  var output = [];
  output[(input.length >> 2) - 1] = undefined;
  for (i = 0; i < output.length; i += 1) {
    output[i] = 0;
  }
  var length8 = input.length * 8;
  for (i = 0; i < length8; i += 8) {
    output[i >> 5] |= (input.charCodeAt(i / 8) & 0xff) << (i % 32);
  }
  return output;
}

/*
* Calculate the MD5 of a raw string
*/
function rstrMD5(s) {
  return binl2rstr(binlMD5(rstr2binl(s), s.length * 8));
}

/*
* Calculate the HMAC-MD5, of a key and some data (raw strings)
*/
function rstrHMACMD5(key, data) {
  var i;
  var bkey = rstr2binl(key);
  var ipad = [];
  var opad = [];
  var hash;
  ipad[15] = opad[15] = undefined;
  if (bkey.length > 16) {
    bkey = binlMD5(bkey, key.length * 8);
  }
  for (i = 0; i < 16; i += 1) {
    ipad[i] = bkey[i] ^ 0x36363636;
    opad[i] = bkey[i] ^ 0x5c5c5c5c;
  }
  hash = binlMD5(ipad.concat(rstr2binl(data)), 512 + data.length * 8);
  return binl2rstr(binlMD5(opad.concat(hash), 512 + 128));
}

/*
* Convert a raw string to a hex string
*/
function rstr2hex(input) {
  var hexTab = '0123456789abcdef';
  var output = '';
  var x;
  var i;
  for (i = 0; i < input.length; i += 1) {
    x = input.charCodeAt(i);
    output += hexTab.charAt((x >>> 4) & 0x0f) + hexTab.charAt(x & 0x0f);
  }
  return output;
}

/*
* Encode a string as utf-8
*/
function str2rstrUTF8(input) {
  return unescape(encodeURIComponent(input));
}

/*
* Take string arguments and return either raw or hex encoded strings
*/
function rawMD5(s) {
  return rstrMD5(str2rstrUTF8(s));
}
function hexMD5(s) {
  return rstr2hex(rawMD5(s));
}
function rawHMACMD5(k, d) {
  return rstrHMACMD5(str2rstrUTF8(k), str2rstrUTF8(d));
}
function hexHMACMD5(k, d) {
  return rstr2hex(rawHMACMD5(k, d));
}

function md5(string, key, raw) {
  if (!key) {
    if (!raw) {
      return hexMD5(string);
    }
    return rawMD5(string);
  }
  if (!raw) {
    return hexHMACMD5(key, string);
  }
  return rawHMACMD5(key, string);
}

module.exports = md5;

},{}],441:[function(require,module,exports){
/*
Slick Finder
*/"use strict"

// Notable changes from Slick.Finder 1.0.x

// faster bottom -> up expression matching
// prefers mental sanity over *obsessive compulsive* milliseconds savings
// uses prototypes instead of objects
// tries to use matchesSelector smartly, whenever available
// can populate objects as well as arrays
// lots of stuff is broken or not implemented

var parse = require("./parser")

// utilities

var index = 0,
    counter = document.__counter = (parseInt(document.__counter || -1, 36) + 1).toString(36),
    key = "uid:" + counter

var uniqueID = function(n, xml){
    if (n === window) return "window"
    if (n === document) return "document"
    if (n === document.documentElement) return "html"

    if (xml) {
        var uid = n.getAttribute(key)
        if (!uid) {
            uid = (index++).toString(36)
            n.setAttribute(key, uid)
        }
        return uid
    } else {
        return n[key] || (n[key] = (index++).toString(36))
    }
}

var uniqueIDXML = function(n) {
    return uniqueID(n, true)
}

var isArray = Array.isArray || function(object){
    return Object.prototype.toString.call(object) === "[object Array]"
}

// tests

var uniqueIndex = 0;

var HAS = {

    GET_ELEMENT_BY_ID: function(test, id){
        id = "slick_" + (uniqueIndex++);
        // checks if the document has getElementById, and it works
        test.innerHTML = '<a id="' + id + '"></a>'
        return !!this.getElementById(id)
    },

    QUERY_SELECTOR: function(test){
        // this supposedly fixes a webkit bug with matchesSelector / querySelector & nth-child
        test.innerHTML = '_<style>:nth-child(2){}</style>'

        // checks if the document has querySelectorAll, and it works
        test.innerHTML = '<a class="MiX"></a>'

        return test.querySelectorAll('.MiX').length === 1
    },

    EXPANDOS: function(test, id){
        id = "slick_" + (uniqueIndex++);
        // checks if the document has elements that support expandos
        test._custom_property_ = id
        return test._custom_property_ === id
    },

    // TODO: use this ?

    // CHECKED_QUERY_SELECTOR: function(test){
    //
    //     // checks if the document supports the checked query selector
    //     test.innerHTML = '<select><option selected="selected">a</option></select>'
    //     return test.querySelectorAll(':checked').length === 1
    // },

    // TODO: use this ?

    // EMPTY_ATTRIBUTE_QUERY_SELECTOR: function(test){
    //
    //     // checks if the document supports the empty attribute query selector
    //     test.innerHTML = '<a class=""></a>'
    //     return test.querySelectorAll('[class*=""]').length === 1
    // },

    MATCHES_SELECTOR: function(test){

        test.className = "MiX"

        // checks if the document has matchesSelector, and we can use it.

        var matches = test.matchesSelector || test.mozMatchesSelector || test.webkitMatchesSelector

        // if matchesSelector trows errors on incorrect syntax we can use it
        if (matches) try {
            matches.call(test, ':slick')
        } catch(e){
            // just as a safety precaution, also test if it works on mixedcase (like querySelectorAll)
            return matches.call(test, ".MiX") ? matches : false
        }

        return false
    },

    GET_ELEMENTS_BY_CLASS_NAME: function(test){
        test.innerHTML = '<a class="f"></a><a class="b"></a>'
        if (test.getElementsByClassName('b').length !== 1) return false

        test.firstChild.className = 'b'
        if (test.getElementsByClassName('b').length !== 2) return false

        // Opera 9.6 getElementsByClassName doesnt detects the class if its not the first one
        test.innerHTML = '<a class="a"></a><a class="f b a"></a>'
        if (test.getElementsByClassName('a').length !== 2) return false

        // tests passed
        return true
    },

    // no need to know

    // GET_ELEMENT_BY_ID_NOT_NAME: function(test, id){
    //     test.innerHTML = '<a name="'+ id +'"></a><b id="'+ id +'"></b>'
    //     return this.getElementById(id) !== test.firstChild
    // },

    // this is always checked for and fixed

    // STAR_GET_ELEMENTS_BY_TAG_NAME: function(test){
    //
    //     // IE returns comment nodes for getElementsByTagName('*') for some documents
    //     test.appendChild(this.createComment(''))
    //     if (test.getElementsByTagName('*').length > 0) return false
    //
    //     // IE returns closed nodes (EG:"</foo>") for getElementsByTagName('*') for some documents
    //     test.innerHTML = 'foo</foo>'
    //     if (test.getElementsByTagName('*').length) return false
    //
    //     // tests passed
    //     return true
    // },

    // this is always checked for and fixed

    // STAR_QUERY_SELECTOR: function(test){
    //
    //     // returns closed nodes (EG:"</foo>") for querySelector('*') for some documents
    //     test.innerHTML = 'foo</foo>'
    //     return !!(test.querySelectorAll('*').length)
    // },

    GET_ATTRIBUTE: function(test){
        // tests for working getAttribute implementation
        var shout = "fus ro dah"
        test.innerHTML = '<a class="' + shout + '"></a>'
        return test.firstChild.getAttribute('class') === shout
    }

}

// Finder

var Finder = function Finder(document){

    this.document        = document
    var root = this.root = document.documentElement
    this.tested          = {}

    // uniqueID

    this.uniqueID = this.has("EXPANDOS") ? uniqueID : uniqueIDXML

    // getAttribute

    this.getAttribute = (this.has("GET_ATTRIBUTE")) ? function(node, name){

        return node.getAttribute(name)

    } : function(node, name){

        node = node.getAttributeNode(name)
        return (node && node.specified) ? node.value : null

    }

    // hasAttribute

    this.hasAttribute = (root.hasAttribute) ? function(node, attribute){

        return node.hasAttribute(attribute)

    } : function(node, attribute) {

        node = node.getAttributeNode(attribute)
        return !!(node && node.specified)

    }

    // contains

    this.contains = (document.contains && root.contains) ? function(context, node){

        return context.contains(node)

    } : (root.compareDocumentPosition) ? function(context, node){

        return context === node || !!(context.compareDocumentPosition(node) & 16)

    } : function(context, node){

        do {
            if (node === context) return true
        } while ((node = node.parentNode))

        return false
    }

    // sort
    // credits to Sizzle (http://sizzlejs.com/)

    this.sorter = (root.compareDocumentPosition) ? function(a, b){

        if (!a.compareDocumentPosition || !b.compareDocumentPosition) return 0
        return a.compareDocumentPosition(b) & 4 ? -1 : a === b ? 0 : 1

    } : ('sourceIndex' in root) ? function(a, b){

        if (!a.sourceIndex || !b.sourceIndex) return 0
        return a.sourceIndex - b.sourceIndex

    } : (document.createRange) ? function(a, b){

        if (!a.ownerDocument || !b.ownerDocument) return 0
        var aRange = a.ownerDocument.createRange(),
            bRange = b.ownerDocument.createRange()

        aRange.setStart(a, 0)
        aRange.setEnd(a, 0)
        bRange.setStart(b, 0)
        bRange.setEnd(b, 0)
        return aRange.compareBoundaryPoints(Range.START_TO_END, bRange)

    } : null

    this.failed = {}

    var nativeMatches = this.has("MATCHES_SELECTOR")

    if (nativeMatches) this.matchesSelector = function(node, expression){

        if (this.failed[expression]) return null

        try {
            return nativeMatches.call(node, expression)
        } catch(e){
            if (slick.debug) console.warn("matchesSelector failed on " + expression)
            this.failed[expression] = true
            return null
        }

    }

    if (this.has("QUERY_SELECTOR")){

        this.querySelectorAll = function(node, expression){

            if (this.failed[expression]) return true

            var result, _id, _expression, _combinator, _node


            // non-document rooted QSA
            // credits to Andrew Dupont

            if (node !== this.document){

                _combinator = expression[0].combinator

                _id         = node.getAttribute("id")
                _expression = expression

                if (!_id){
                    _node = node
                    _id = "__slick__"
                    _node.setAttribute("id", _id)
                }

                expression = "#" + _id + " " + _expression


                // these combinators need a parentNode due to how querySelectorAll works, which is:
                // finding all the elements that match the given selector
                // then filtering by the ones that have the specified element as an ancestor
                if (_combinator.indexOf("~") > -1 || _combinator.indexOf("+") > -1){

                    node = node.parentNode
                    if (!node) result = true
                    // if node has no parentNode, we return "true" as if it failed, without polluting the failed cache

                }

            }

            if (!result) try {
                result = node.querySelectorAll(expression.toString())
            } catch(e){
                if (slick.debug) console.warn("querySelectorAll failed on " + (_expression || expression))
                result = this.failed[_expression || expression] = true
            }

            if (_node) _node.removeAttribute("id")

            return result

        }

    }

}

Finder.prototype.has = function(FEATURE){

    var tested        = this.tested,
        testedFEATURE = tested[FEATURE]

    if (testedFEATURE != null) return testedFEATURE

    var root     = this.root,
        document = this.document,
        testNode = document.createElement("div")

    testNode.setAttribute("style", "display: none;")

    root.appendChild(testNode)

    var TEST = HAS[FEATURE], result = false

    if (TEST) try {
        result = TEST.call(document, testNode)
    } catch(e){}

    if (slick.debug && !result) console.warn("document has no " + FEATURE)

    root.removeChild(testNode)

    return tested[FEATURE] = result

}

var combinators = {

    " ": function(node, part, push){

        var item, items

        var noId = !part.id, noTag = !part.tag, noClass = !part.classes

        if (part.id && node.getElementById && this.has("GET_ELEMENT_BY_ID")){
            item = node.getElementById(part.id)

            // return only if id is found, else keep checking
            // might be a tad slower on non-existing ids, but less insane

            if (item && item.getAttribute('id') === part.id){
                items = [item]
                noId = true
                // if tag is star, no need to check it in match()
                if (part.tag === "*") noTag = true
            }
        }

        if (!items){

            if (part.classes && node.getElementsByClassName && this.has("GET_ELEMENTS_BY_CLASS_NAME")){
                items = node.getElementsByClassName(part.classList)
                noClass = true
                // if tag is star, no need to check it in match()
                if (part.tag === "*") noTag = true
            } else {
                items = node.getElementsByTagName(part.tag)
                // if tag is star, need to check it in match because it could select junk, boho
                if (part.tag !== "*") noTag = true
            }

            if (!items || !items.length) return false

        }

        for (var i = 0; item = items[i++];)
            if ((noTag && noId && noClass && !part.attributes && !part.pseudos) || this.match(item, part, noTag, noId, noClass))
                push(item)

        return true

    },

    ">": function(node, part, push){ // direct children
        if ((node = node.firstChild)) do {
            if (node.nodeType == 1 && this.match(node, part)) push(node)
        } while ((node = node.nextSibling))
    },

    "+": function(node, part, push){ // next sibling
        while ((node = node.nextSibling)) if (node.nodeType == 1){
            if (this.match(node, part)) push(node)
            break
        }
    },

    "^": function(node, part, push){ // first child
        node = node.firstChild
        if (node){
            if (node.nodeType === 1){
                if (this.match(node, part)) push(node)
            } else {
                combinators['+'].call(this, node, part, push)
            }
        }
    },

    "~": function(node, part, push){ // next siblings
        while ((node = node.nextSibling)){
            if (node.nodeType === 1 && this.match(node, part)) push(node)
        }
    },

    "++": function(node, part, push){ // next sibling and previous sibling
        combinators['+'].call(this, node, part, push)
        combinators['!+'].call(this, node, part, push)
    },

    "~~": function(node, part, push){ // next siblings and previous siblings
        combinators['~'].call(this, node, part, push)
        combinators['!~'].call(this, node, part, push)
    },

    "!": function(node, part, push){ // all parent nodes up to document
        while ((node = node.parentNode)) if (node !== this.document && this.match(node, part)) push(node)
    },

    "!>": function(node, part, push){ // direct parent (one level)
        node = node.parentNode
        if (node !== this.document && this.match(node, part)) push(node)
    },

    "!+": function(node, part, push){ // previous sibling
        while ((node = node.previousSibling)) if (node.nodeType == 1){
            if (this.match(node, part)) push(node)
            break
        }
    },

    "!^": function(node, part, push){ // last child
        node = node.lastChild
        if (node){
            if (node.nodeType == 1){
                if (this.match(node, part)) push(node)
            } else {
                combinators['!+'].call(this, node, part, push)
            }
        }
    },

    "!~": function(node, part, push){ // previous siblings
        while ((node = node.previousSibling)){
            if (node.nodeType === 1 && this.match(node, part)) push(node)
        }
    }

}

Finder.prototype.search = function(context, expression, found){

    if (!context) context = this.document
    else if (!context.nodeType && context.document) context = context.document

    var expressions = parse(expression)

    // no expressions were parsed. todo: is this really necessary?
    if (!expressions || !expressions.length) throw new Error("invalid expression")

    if (!found) found = []

    var uniques, push = isArray(found) ? function(node){
        found[found.length] = node
    } : function(node){
        found[found.length++] = node
    }

    // if there is more than one expression we need to check for duplicates when we push to found
    // this simply saves the old push and wraps it around an uid dupe check.
    if (expressions.length > 1){
        uniques = {}
        var plush = push
        push = function(node){
            var uid = uniqueID(node)
            if (!uniques[uid]){
                uniques[uid] = true
                plush(node)
            }
        }
    }

    // walker

    var node, nodes, part

    main: for (var i = 0; expression = expressions[i++];){

        // querySelector

        // TODO: more functional tests

        // if there is querySelectorAll (and the expression does not fail) use it.
        if (!slick.noQSA && this.querySelectorAll){

            nodes = this.querySelectorAll(context, expression)
            if (nodes !== true){
                if (nodes && nodes.length) for (var j = 0; node = nodes[j++];) if (node.nodeName > '@'){
                    push(node)
                }
                continue main
            }
        }

        // if there is only one part in the expression we don't need to check each part for duplicates.
        // todo: this might be too naive. while solid, there can be expression sequences that do not
        // produce duplicates. "body div" for instance, can never give you each div more than once.
        // "body div a" on the other hand might.
        if (expression.length === 1){

            part = expression[0]
            combinators[part.combinator].call(this, context, part, push)

        } else {

            var cs = [context], c, f, u, p = function(node){
                var uid = uniqueID(node)
                if (!u[uid]){
                    u[uid] = true
                    f[f.length] = node
                }
            }

            // loop the expression parts
            for (var j = 0; part = expression[j++];){
                f = []; u = {}
                // loop the contexts
                for (var k = 0; c = cs[k++];) combinators[part.combinator].call(this, c, part, p)
                // nothing was found, the expression failed, continue to the next expression.
                if (!f.length) continue main
                cs = f // set the contexts for future parts (if any)
            }

            if (i === 0) found = f // first expression. directly set found.
            else for (var l = 0; l < f.length; l++) push(f[l]) // any other expression needs to push to found.
        }

    }

    if (uniques && found && found.length > 1) this.sort(found)

    return found

}

Finder.prototype.sort = function(nodes){
    return this.sorter ? Array.prototype.sort.call(nodes, this.sorter) : nodes
}

// TODO: most of these pseudo selectors include <html> and qsa doesnt. fixme.

var pseudos = {


    // TODO: returns different results than qsa empty.

    'empty': function(){
        return !(this && this.nodeType === 1) && !(this.innerText || this.textContent || '').length
    },

    'not': function(expression){
        return !slick.matches(this, expression)
    },

    'contains': function(text){
        return (this.innerText || this.textContent || '').indexOf(text) > -1
    },

    'first-child': function(){
        var node = this
        while ((node = node.previousSibling)) if (node.nodeType == 1) return false
        return true
    },

    'last-child': function(){
        var node = this
        while ((node = node.nextSibling)) if (node.nodeType == 1) return false
        return true
    },

    'only-child': function(){
        var prev = this
        while ((prev = prev.previousSibling)) if (prev.nodeType == 1) return false

        var next = this
        while ((next = next.nextSibling)) if (next.nodeType == 1) return false

        return true
    },

    'first-of-type': function(){
        var node = this, nodeName = node.nodeName
        while ((node = node.previousSibling)) if (node.nodeName == nodeName) return false
        return true
    },

    'last-of-type': function(){
        var node = this, nodeName = node.nodeName
        while ((node = node.nextSibling)) if (node.nodeName == nodeName) return false
        return true
    },

    'only-of-type': function(){
        var prev = this, nodeName = this.nodeName
        while ((prev = prev.previousSibling)) if (prev.nodeName == nodeName) return false
        var next = this
        while ((next = next.nextSibling)) if (next.nodeName == nodeName) return false
        return true
    },

    'enabled': function(){
        return !this.disabled
    },

    'disabled': function(){
        return this.disabled
    },

    'checked': function(){
        return this.checked || this.selected
    },

    'selected': function(){
        return this.selected
    },

    'focus': function(){
        var doc = this.ownerDocument
        return doc.activeElement === this && (this.href || this.type || slick.hasAttribute(this, 'tabindex'))
    },

    'root': function(){
        return (this === this.ownerDocument.documentElement)
    }

}

Finder.prototype.match = function(node, bit, noTag, noId, noClass){

    // TODO: more functional tests ?

    if (!slick.noQSA && this.matchesSelector){
        var matches = this.matchesSelector(node, bit)
        if (matches !== null) return matches
    }

    // normal matching

    if (!noTag && bit.tag){

        var nodeName = node.nodeName.toLowerCase()
        if (bit.tag === "*"){
            if (nodeName < "@") return false
        } else if (nodeName != bit.tag){
            return false
        }

    }

    if (!noId && bit.id && node.getAttribute('id') !== bit.id) return false

    var i, part

    if (!noClass && bit.classes){

        var className = this.getAttribute(node, "class")
        if (!className) return false

        for (part in bit.classes) if (!RegExp('(^|\\s)' + bit.classes[part] + '(\\s|$)').test(className)) return false
    }

    var name, value

    if (bit.attributes) for (i = 0; part = bit.attributes[i++];){

        var operator  = part.operator,
            escaped   = part.escapedValue

        name  = part.name
        value = part.value

        if (!operator){

            if (!this.hasAttribute(node, name)) return false

        } else {

            var actual = this.getAttribute(node, name)
            if (actual == null) return false

            switch (operator){
                case '^=' : if (!RegExp(      '^' + escaped            ).test(actual)) return false; break
                case '$=' : if (!RegExp(            escaped + '$'      ).test(actual)) return false; break
                case '~=' : if (!RegExp('(^|\\s)' + escaped + '(\\s|$)').test(actual)) return false; break
                case '|=' : if (!RegExp(      '^' + escaped + '(-|$)'  ).test(actual)) return false; break

                case '='  : if (actual !== value) return false; break
                case '*=' : if (actual.indexOf(value) === -1) return false; break
                default   : return false
            }

        }
    }

    if (bit.pseudos) for (i = 0; part = bit.pseudos[i++];){

        name  = part.name
        value = part.value

        if (pseudos[name]) return pseudos[name].call(node, value)

        if (value != null){
            if (this.getAttribute(node, name) !== value) return false
        } else {
            if (!this.hasAttribute(node, name)) return false
        }

    }

    return true

}

Finder.prototype.matches = function(node, expression){

    var expressions = parse(expression)

    if (expressions.length === 1 && expressions[0].length === 1){ // simplest match
        return this.match(node, expressions[0][0])
    }

    // TODO: more functional tests ?

    if (!slick.noQSA && this.matchesSelector){
        var matches = this.matchesSelector(node, expressions)
        if (matches !== null) return matches
    }

    var nodes = this.search(this.document, expression, {length: 0})

    for (var i = 0, res; res = nodes[i++];) if (node === res) return true
    return false

}

var finders = {}

var finder = function(context){
    var doc = context || document
    if (doc.ownerDocument) doc = doc.ownerDocument
    else if (doc.document) doc = doc.document

    if (doc.nodeType !== 9) throw new TypeError("invalid document")

    var uid = uniqueID(doc)
    return finders[uid] || (finders[uid] = new Finder(doc))
}

// ... API ...

var slick = function(expression, context){
    return slick.search(expression, context)
}

slick.search = function(expression, context, found){
    return finder(context).search(context, expression, found)
}

slick.find = function(expression, context){
    return finder(context).search(context, expression)[0] || null
}

slick.getAttribute = function(node, name){
    return finder(node).getAttribute(node, name)
}

slick.hasAttribute = function(node, name){
    return finder(node).hasAttribute(node, name)
}

slick.contains = function(context, node){
    return finder(context).contains(context, node)
}

slick.matches = function(node, expression){
    return finder(node).matches(node, expression)
}

slick.sort = function(nodes){
    if (nodes && nodes.length > 1) finder(nodes[0]).sort(nodes)
    return nodes
}

slick.parse = parse;

// slick.debug = true
// slick.noQSA  = true

module.exports = slick

},{"./parser":443}],442:[function(require,module,exports){
(function (global){
/*
slick
*/"use strict"

module.exports = "document" in global ? require("./finder") : { parse: require("./parser") }

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./finder":441,"./parser":443}],443:[function(require,module,exports){
/*
Slick Parser
 - originally created by the almighty Thomas Aylott <@subtlegradient> (http://subtlegradient.com)
*/"use strict"

// Notable changes from Slick.Parser 1.0.x

// The parser now uses 2 classes: Expressions and Expression
// `new Expressions` produces an array-like object containing a list of Expression objects
// - Expressions::toString() produces a cleaned up expressions string
// `new Expression` produces an array-like object
// - Expression::toString() produces a cleaned up expression string
// The only exposed method is parse, which produces a (cached) `new Expressions` instance
// parsed.raw is no longer present, use .toString()
// parsed.expression is now useless, just use the indices
// parsed.reverse() has been removed for now, due to its apparent uselessness
// Other changes in the Expressions object:
// - classNames are now unique, and save both escaped and unescaped values
// - attributes now save both escaped and unescaped values
// - pseudos now save both escaped and unescaped values

var escapeRe   = /([-.*+?^${}()|[\]\/\\])/g,
    unescapeRe = /\\/g

var escape = function(string){
    // XRegExp v2.0.0-beta-3
    // « https://github.com/slevithan/XRegExp/blob/master/src/xregexp.js
    return (string + "").replace(escapeRe, '\\$1')
}

var unescape = function(string){
    return (string + "").replace(unescapeRe, '')
}

var slickRe = RegExp(
/*
#!/usr/bin/env ruby
puts "\t\t" + DATA.read.gsub(/\(\?x\)|\s+#.*$|\s+|\\$|\\n/,'')
__END__
    "(?x)^(?:\
      \\s* ( , ) \\s*               # Separator          \n\
    | \\s* ( <combinator>+ ) \\s*   # Combinator         \n\
    |      ( \\s+ )                 # CombinatorChildren \n\
    |      ( <unicode>+ | \\* )     # Tag                \n\
    | \\#  ( <unicode>+       )     # ID                 \n\
    | \\.  ( <unicode>+       )     # ClassName          \n\
    |                               # Attribute          \n\
    \\[  \
        \\s* (<unicode1>+)  (?:  \
            \\s* ([*^$!~|]?=)  (?:  \
                \\s* (?:\
                    ([\"']?)(.*?)\\9 \
                )\
            )  \
        )?  \\s*  \
    \\](?!\\]) \n\
    |   :+ ( <unicode>+ )(?:\
    \\( (?:\
        (?:([\"'])([^\\12]*)\\12)|((?:\\([^)]+\\)|[^()]*)+)\
    ) \\)\
    )?\
    )"
*/
"^(?:\\s*(,)\\s*|\\s*(<combinator>+)\\s*|(\\s+)|(<unicode>+|\\*)|\\#(<unicode>+)|\\.(<unicode>+)|\\[\\s*(<unicode1>+)(?:\\s*([*^$!~|]?=)(?:\\s*(?:([\"']?)(.*?)\\9)))?\\s*\\](?!\\])|(:+)(<unicode>+)(?:\\((?:(?:([\"'])([^\\13]*)\\13)|((?:\\([^)]+\\)|[^()]*)+))\\))?)"
    .replace(/<combinator>/, '[' + escape(">+~`!@$%^&={}\\;</") + ']')
    .replace(/<unicode>/g, '(?:[\\w\\u00a1-\\uFFFF-]|\\\\[^\\s0-9a-f])')
    .replace(/<unicode1>/g, '(?:[:\\w\\u00a1-\\uFFFF-]|\\\\[^\\s0-9a-f])')
)

// Part

var Part = function Part(combinator){
    this.combinator = combinator || " "
    this.tag = "*"
}

Part.prototype.toString = function(){

    if (!this.raw){

        var xpr = "", k, part

        xpr += this.tag || "*"
        if (this.id) xpr += "#" + this.id
        if (this.classes) xpr += "." + this.classList.join(".")
        if (this.attributes) for (k = 0; part = this.attributes[k++];){
            xpr += "[" + part.name + (part.operator ? part.operator + '"' + part.value + '"' : '') + "]"
        }
        if (this.pseudos) for (k = 0; part = this.pseudos[k++];){
            xpr += ":" + part.name
            if (part.value) xpr += "(" + part.value + ")"
        }

        this.raw = xpr

    }

    return this.raw
}

// Expression

var Expression = function Expression(){
    this.length = 0
}

Expression.prototype.toString = function(){

    if (!this.raw){

        var xpr = ""

        for (var j = 0, bit; bit = this[j++];){
            if (j !== 1) xpr += " "
            if (bit.combinator !== " ") xpr += bit.combinator + " "
            xpr += bit
        }

        this.raw = xpr

    }

    return this.raw
}

var replacer = function(
    rawMatch,

    separator,
    combinator,
    combinatorChildren,

    tagName,
    id,
    className,

    attributeKey,
    attributeOperator,
    attributeQuote,
    attributeValue,

    pseudoMarker,
    pseudoClass,
    pseudoQuote,
    pseudoClassQuotedValue,
    pseudoClassValue
){

    var expression, current

    if (separator || !this.length){
        expression = this[this.length++] = new Expression
        if (separator) return ''
    }

    if (!expression) expression = this[this.length - 1]

    if (combinator || combinatorChildren || !expression.length){
        current = expression[expression.length++] = new Part(combinator)
    }

    if (!current) current = expression[expression.length - 1]

    if (tagName){

        current.tag = unescape(tagName)

    } else if (id){

        current.id = unescape(id)

    } else if (className){

        var unescaped = unescape(className)

        var classes = current.classes || (current.classes = {})
        if (!classes[unescaped]){
            classes[unescaped] = escape(className)
            var classList = current.classList || (current.classList = [])
            classList.push(unescaped)
            classList.sort()
        }

    } else if (pseudoClass){

        pseudoClassValue = pseudoClassValue || pseudoClassQuotedValue

        ;(current.pseudos || (current.pseudos = [])).push({
            type         : pseudoMarker.length == 1 ? 'class' : 'element',
            name         : unescape(pseudoClass),
            escapedName  : escape(pseudoClass),
            value        : pseudoClassValue ? unescape(pseudoClassValue) : null,
            escapedValue : pseudoClassValue ? escape(pseudoClassValue) : null
        })

    } else if (attributeKey){

        attributeValue = attributeValue ? escape(attributeValue) : null

        ;(current.attributes || (current.attributes = [])).push({
            operator     : attributeOperator,
            name         : unescape(attributeKey),
            escapedName  : escape(attributeKey),
            value        : attributeValue ? unescape(attributeValue) : null,
            escapedValue : attributeValue ? escape(attributeValue) : null
        })

    }

    return ''

}

// Expressions

var Expressions = function Expressions(expression){
    this.length = 0

    var self = this

    var original = expression, replaced

    while (expression){
        replaced = expression.replace(slickRe, function(){
            return replacer.apply(self, arguments)
        })
        if (replaced === expression) throw new Error(original + ' is an invalid expression')
        expression = replaced
    }
}

Expressions.prototype.toString = function(){
    if (!this.raw){
        var expressions = []
        for (var i = 0, expression; expression = this[i++];) expressions.push(expression)
        this.raw = expressions.join(", ")
    }

    return this.raw
}

var cache = {}

var parse = function(expression){
    if (expression == null) return null
    expression = ('' + expression).replace(/^\s+|\s+$/g, '')
    return cache[expression] || (cache[expression] = new Expressions(expression))
}

module.exports = parse

},{}],444:[function(require,module,exports){

/**
 * `Batch' constructor
 *
 * @api public
 * @param {Number} max - optional (Default: Infinity)
 */

module.exports = Batch;
function Batch (max) {
  if (!(this instanceof Batch)) {
    return new Batch(max);
  }

  var self = this;

  this.m = 0; // max
  this.c = 0; // concurrency
  this.jobs = [];

  this.concurrency(Infinity);
  this.max(max);

  Object.defineProperty(this, 'length', {
    get: function () {
      return self.jobs.length;
    }
  });
}

/**
 * Set batch concurrency
 *
 * @api public
 * @param {Number} n
 */

Batch.prototype.concurrency = function (n) {
  if (n > 0) {
    this.c = n;
  }
  return this;
};

/**
 * Set max job limit
 *
 * @api publc
 * @param {Number} n
 */

Batch.prototype.max = function (n) {
  this.m = 'number' == typeof n && n > 0 ? n : Infinity;
  return this;
};

/**
 * Push job onto queue
 *
 * @api publc
 * @param {Function} fn
 */

Batch.prototype.push = function (fn) {
  if ('function' != typeof fn) {
    throw new TypeError("expecting a function");
  } else if (this.length < this.m) {
    this.jobs.push(fn);
  }
  return this;
};

/**
 * Shift job off of queue
 *
 * @api public
 */

Batch.prototype.shift = function () {
  return this.jobs.shift();
};

/**
 * Dequeues all queued jobs
 *
 * @api public
 * @param {Function} done - optional
 */

Batch.prototype.run = function (done) {
  done = 'function' == typeof done ? done : Function();
  var self = this;
  var c = this.c;
  var i = 0;

  // empty queue
  if (0 == this.length) {
    return done(null);
  }

  function dequeue  () {
    var job = null;
    if (0 == self.length) {
      return false;
    }

    job = self.shift();

    if ('function' != typeof job) {
      return;
    }

    try { job(next); }
    catch (err) {
      done(err)
      return false;
    }

    function next (err) {
      if (err) {
        done(err);
      } else if (self.length) {
        dequeue();
      } else {
        done();
      }
    }
  }

  while (i++ < c) {
    if (false === dequeue()) {
      break;
    }
  }

  return this;
};

},{}],445:[function(require,module,exports){
(function() {
  /**
   * @file
   * Introduces a function called "defer" that allows functions to be
   * executed in the next available tick.
   *
   * Unlike "setTimeout", "defer" executes the function at the nearest
   * possible time without clamping.
   *
   * @see Spotify.defer
   */
  'use strict';

  var hasWindow = typeof window != 'undefined';
  var hasDefineProperty = typeof Object.defineProperty == 'function';

  if (hasWindow && window.__modDefFn) {
    // If deferred has been attached to the global scope
    module.exports = window.__modDefFn;
    return;
  }

  /**
   * Storage for deferred functions to be executed.
   *
   * @type {Array.<function()>}
   * @private
   */
  var deferred = [];


  /**
   * A bound version of the postMessage routine used to trigger deferred
   * execution.
   *
   * @type {function()}
   * @private
   */
  var send;
  var origin;

  function bindSendDom() {
    origin = (window.location.origin ||
          window.location.protocol + '//' + window.location.hostname);
    send = window.postMessage.bind(window, '@execute_deferreds', origin);
    if (!window.__hasDeferredHandler) {
      if (hasDefineProperty) {
        Object.defineProperty(window, '__hasDeferredHandler', {value: 1});
      } else {
        window.__hasDeferredHandler = 1;
      }
      var handler = function(e) {
        if (e.origin != origin && e.data != '@execute_deferreds') {
          return;
        }
        executeDeferreds();
      };
      if (window.addEventListener) {
        window.addEventListener('message', handler);
      } else {
        window.attachEvent('onmessage', handler);
      }
    }
  }

  function bindSendImmediate() {
    send = setImmediate.bind(null, executeDeferreds);
  }

  function bindSendTimeout() {
    send = setTimeout.bind(null, executeDeferreds, 10);
  }

  function bindSendAuto() {
    if (hasWindow && window.postMessage) {
      bindSendDom();
    } else if (typeof setImmediate != 'undefined') {
      bindSendImmediate();
    } else {
      bindSendTimeout();
    }
  }

  bindSendAuto();

  /**
   * Executes the deferred functions when the window
   * receives an 'execute_deferreds' message.
   *
   * @private
   */
  function executeDeferreds() {
    var fns = deferred.splice(0);
    if (!fns.length) return;
    for (var i = 0, l = fns.length; i < l; i++) {
      try {
        fns[i]();
      } finally {
        // Do nothing.
        null;
      }
    }
  }


  /**
   * Executes the function applied at the nearest possible time without
   * clamping.
   *
   * @param {function()} fn The function to execute.
   */
  var defer = function(fn) {
    var trigger = !deferred.length;
    deferred.push(fn);
    if (trigger) send();
  };

  if (hasWindow && !window.__modDefFn) {
    if (hasDefineProperty) {
      Object.defineProperty(window, '__modDefFn', {value: defer});
    } else {
      window.__modDefFn = defer;
    }
  }

  /**
   * Export interface for binding send method to a particular implementation,
   * which is intended primarily for use by integration tests where the send method
   * can be explicitly set to immediate/timeout, even if mock DOM globals exist.
   */
  defer.use = {
    auto: bindSendAuto,
    dom: bindSendDom,
    immediate: bindSendImmediate,
    timeout: bindSendTimeout,
  };

  /**
   * Export public interface
   */
  module.exports = defer;

})();

},{}],446:[function(require,module,exports){
'use strict';

var hasDefineProperty = typeof Object.defineProperty === 'function';

var DEFAULT_DESCRIPTOR = {
  value: false,
  writable: true
};

/**
 * Represents an Event.
 *
 * **NOTE**: The Event class is an internal class: you cannot instantiate it
 * directly. Instead, you should use the provided
 * {@link module:spotify-eventemitter.createEvent} function.
 *
 * @constructor
 * @param {string} type The type name of the event object.
 * @param {Object} props An object that will be added as properties of the
 *     event object.
 * @see {@link module:spotify-eventemitter.createEvent}
 */
function Event(type, props) {
  /**
   * The type of the event.
   *
   * @type {string}
   */
  this.type = type;

  // Parse the extra event properties. We do this before setting the internal
  // flags in case `props` is actually an Event instance. It makes it easier for
  // us to override the flags later.
  if (props) {
    for (var key in props) {
      if (!props.hasOwnProperty(key) || key == 'type') {
        continue;
      }
      this[key] = props[key];
    }
  }

  if (hasDefineProperty) {
    Object.defineProperty(this, '_prevented', DEFAULT_DESCRIPTOR);
    Object.defineProperty(this, '_stopped', DEFAULT_DESCRIPTOR);
    Object.defineProperty(this, '_immediateStopped', DEFAULT_DESCRIPTOR);
    Object.defineProperty(this, 'defaultPrevented', {
      get: function() {
        return this._prevented;
      }.bind(this),
      set: function(value) {
        return value;
      }
    });
  } else {
    /**
     * External property that indicates whether the event's `preventDefault` 
     * method was called.
     *
     * @type {boolean}
     * @public
     */
    this.defaultPrevented = false;

    /**
     * An internal flag for whether preventDefault was called.
     *
     * @type {boolean}
     * @private
     */
    this._prevented = false;

    /**
     * An internal flag for whether stopPropagation was called
     *
     * @type {boolean}
     * @private
     */
    this._stopped = false;

    /**
     * An internal flag for whether stopImmediatePropagation was called.
     *
     * @type {boolean}
     * @private
     */
    this._immediateStopped = false;
  }
}

/**
 * Returns whether stopPropagation was called on the event.
 *
 * @param {Event} ev The event.
 * @return {boolean} True if stopPropagation was called, false otherwise.
 */
Event.wasPropagationStopped = function(ev) {
  return !!ev._stopped;
};

/**
 * Returns whether stopImmediatePropagation was called on the event.
 *
 * @param {Event} ev The event.
 * @return {boolean} True if stopImmediatePropagation was called, false
 *     otherwise.
 */
Event.wasImmediatePropagationStopped = function(ev) {
  return !!ev._immediateStopped;
};

/**
 * Prevents the default operation for the event.
 */
Event.prototype.preventDefault = function() {
  this._prevented = true;
  if (!hasDefineProperty) {
    this.defaultPrevented = true;
  }
};

/**
 * Stops the propagation of the event.
 */
Event.prototype.stopPropagation = function() {
  this._stopped = true;
};

/**
 * Stops the immediate propagation of the event.
 *
 * Handlers added after any event handler calling this method will not receive
 * the event.
 */
Event.prototype.stopImmediatePropagation = function() {
  this._immediateStopped = true;
};

module.exports = Event;

},{}],447:[function(require,module,exports){
/**
 * @module spotify-eventemitter
 */
'use strict';

/**
 * @private
 */
var _defer = require('spotify-deferred');
var Event = require('./_internal/event');

/**
 * The prefixes added for metalisteners.
 *
 * @const {string}
 * @private
 */
var InternalPrefix = {
  ADD: 'add:',
  REMOVE: 'remove:'
};

/**
 * A function that takes in an event.
 *
 * @typedef {function(Event)}
 * @private
 */
var EventHandler;

/**
 * The event handlers.
 *
 * @typedef {Array.<function>}
 * @private
 */
var EventHandlers;

/**
 * An EventEmitter is an object that can be listened to for events.
 *
 * Instances of this class are not usually used directly; instead, a class that
 * needs EventEmitter functionality would inherit from the EventEmitter class
 * so that it's instances can use events.
 *
 * @constructor
 * @alias module:spotify-eventemitter
 *
 * @example <caption>Direct usage</caption>
 * var EventEmitter = require('spotify-eventemitter');
 * var emitter = new EventEmitter();
 * emitter.on('someEvent', function() {
 *     console.log('someEvent fired!');
 * });
 * emitter.emit('someEvent');
 * @example <caption>Inheritance</caption>
 * var EventEmitter = require('spotify-eventemitter');
 * var inherit = require('spotify-inherit/inherit');
 *
 * function MyClass() {
 *   EventEmitter.call(this);
 * }
 * inherit(MyClass, EventEmitter);
 *
 * var instance = new MyClass();
 * instance.on('someEvent', function() {
 *     console.log('someEvent fired!');
 * });
 * instance.emit('someEvent');
 */
function EventEmitter() {
  /**
   * A map of event names to event handlers.
   *
   * @type {Object.<string, module:spotify-eventemitter~EventHandlers>}
   * @private
   */
  this._listenerMap = {};
}

/**
 * Creates a new Event object.
 *
 * @param {string} type The type name of the event.
 * @param {Object=} opt_params An object containing properties for the new event
 *     object.
 * @return {module:spotify-eventemitter~Event} The new event object.
 */
EventEmitter.createEvent = function(type, opt_params) {
  if (!type) {
    throw new TypeError('Cannot create event with empty type.');
  }
  return new Event(type, opt_params);
};

/**
 * Returns whether there are listeners for a given event.
 *
 */
EventEmitter.prototype._hasListenersFor = function(type) {
  var _listenerMap = this._listenerMap;
  var listeners = _listenerMap && _listenerMap[type];
  return !!(listeners && listeners.length);
};

/**
 * Adds an event listener to the emitter.
 *
 * This method is idempotent: calling it multiple times using the same type
 * and listener arguments will only set the listener once. This behaviour is
 * done to prevent accidental additions of the same event listener.
 *
 * @param {string} type The type of event to listen to.
 * @param {function} listener A function to be called when the emitter fires
 *     the event specified in the type.
 * @return {module:spotify-eventemitter} The event emitter.
 */
EventEmitter.prototype.on = function(type, listener) {
  if (!type) {
    throw new TypeError('Cannot add event listener with empty type.');
  }
  var _listenerMap = this._listenerMap || (this._listenerMap = {});
  var listeners = _listenerMap[type] || (_listenerMap[type] = []);
  if (listeners.indexOf(listener) != -1) {
    // Handler already added, return quickly.
    return this;
  }
  var metaListenerType = InternalPrefix.ADD + type;
  if (this._hasListenersFor(metaListenerType)) {
    var event = this.emitSync(metaListenerType, {listener: listener});
    if (event.defaultPrevented) {
      return this;
    }
  }
  listeners.push(listener);
  return this;
};

/**
 * Adds a "once" event listener to the emitter, which will be removed right
 * after it has been fired.
 *
 * In order to achieve the "once" behaviour, the listener argument passed to
 * this method is wrapped in a function, which is then returned by the method.
 *
 * Because of this wrapping, this method is not idempotent: calling it multiple
 * times with the same type and listener arguments will result to multiple
 * event listeners attached.
 *
 * @param {string} type The type of event to listen to.
 * @param {function} listener A function to be called when the emitter fires
 *     the event specified in the type and then automatically removed.
 * @return {function} The function used to wrap the listener function argument.
 *     This function can be used as an argument to removeEvent.
 */
EventEmitter.prototype.once = function(type, listener) {
  if (!type) {
    throw new TypeError('Cannot add once listener with empty type.');
  }
  var wrapper = function() {
    this.removeListener(type, wrapper);
    return listener.apply(this, arguments);
  };
  this.on(type, wrapper);
  return wrapper;
};

/**
 * Adds multiple event listeners to the emitter.
 *
 * @param {Object.<string, function>} eventListeners An object, the keys of
 *     which correspond to the name of events to listen to, and the value of
 *     each of these keys should be a function that would be added as the
 *     listener for that event.
 * @return {module:spotify-eventemitter} The event emitter.
 */
EventEmitter.prototype.addListeners = function(eventListeners) {
  for (var type in eventListeners) {
    this.on(type, eventListeners[type]);
  }
  return this;
};

/**
 * Removes an event listener from the emitter.
 *
 * @param {string} type The type of event to remove.
 * @param {function} listener The listener function to remove. This must be a
 *     function that was added previously using addEvent.
 * @return {module:spotify-eventemitter} The event emitter.
 */
EventEmitter.prototype.removeListener = function(type, listener) {
  var _listenerMap = this._listenerMap;
  var listeners = _listenerMap && _listenerMap[type];
  if (!listeners) {
    return this;
  }
  var index = listeners.indexOf(listener);
  if (index == -1) {
    return this;
  }
  var metaListenerType = InternalPrefix.REMOVE + type;
  if (this._hasListenersFor(metaListenerType)) {
    var event = this.emitSync(metaListenerType, {
      listener: listener,
      remainingLength: listeners.length - 1
    });
    if (event.defaultPrevented) {
      return this;
    }
  }
  listeners.splice(index, 1);
  if (!listeners.length) {
    _listenerMap[type] = null;
  }
  return this;
};

/**
 * Removes all event listeners from the emitter for a particular type.
 * If no event type is given, all event listeners will be removed.
 *
 * @param {string=} opt_type The event type to remove.
 * @return {module:spotify-eventemitter} The event emitter.
 */
EventEmitter.prototype.removeAllListeners = function(opt_type) {
  var _listenerMap = this._listenerMap;
  if (!_listenerMap) {
    return this;
  }
  if (opt_type === undefined) {
    this._listenerMap = {};
    return this;
  }
  _listenerMap[opt_type] = null;
  return this;
};

/**
 * Removes multiple event listeners from the emitter.
 *
 * @param {Object.<string, function>} eventListeners An object, the keys of
 *     which correspond to the name of events to listen to, and the value of
 *     each of these keys should be a function that would be added as the
 *     listener for that event.
 * @return {module:spotify-eventemitter} The event emitter.
 */
EventEmitter.prototype.removeListeners = function(eventListeners) {
  for (var type in eventListeners) {
    this.removeListener(type, eventListeners[type]);
  }
  return this;
};

// ALIASES

/**
 * Adds an event listener to the emitter.
 *
 * **NOTE**: This method is an alias of
 * {@link module:spotify-eventemitter#on}.
 *
 * This method is idempotent: calling it multiple times using the same type
 * and listener arguments will only set the listener once. This behaviour is
 * done to prevent accidental additions of the same event listener.
 *
 * @param {string} type The type of event to listen to.
 * @param {function} listener A function to be called when the emitter fires
 *     the event specified in the type.
 * @return {module:spotify-eventemitter} The event emitter.
 * @see {@link module:spotify-eventemitter#on}
 */
EventEmitter.prototype.addListener = function(type, listener) {
  return this.on(type, listener);
};

/**
 * Adds a "once" event listener to the emitter, which will be removed right
 * after it has been fired.
 *
 * **NOTE**: This method is an alias of
 * {@link module:spotify-eventemitter#once}.
 *
 * In order to achieve the "once" behaviour, the listener argument passed to
 * this method is wrapped in a function, which is then returned by the method.
 *
 * Because of this wrapping, this method is not idempotent: calling it multiple
 * times with the same type and listener arguments will result to multiple
 * event listeners attached.
 *
 * @param {string} type The type of event to listen to.
 * @param {function} listener A function to be called when the emitter fires
 *     the event specified in the type and then automatically removed.
 * @return {function} The function used to wrap the listener function argument.
 *     This function can be used as an argument to removeEvent.
 * @see {@link module:spotify-eventemitter#once}
 */
EventEmitter.prototype.addOnceListener = function(type, listener) {
  return this.once(type, listener);
};

/**
 * Creates and emits an event on the emitter.
 *
 * This method invokes all the added event listeners of the `type` provided in
 * the order they were added, passing in a new Event object created using the
 * provided `type` and `opt_params` arguments.
 *
 * This method emits events asynchronously: the listeners are not called until
 * the next run loop.
 *
 * @param {string} type The type name of the event to emit.
 * @param {Object=} opt_params An object containing parameters for the Event
 *     object.
 * @return {module:spotify-eventemitter~Event} The Event object that was
 *     created.
 */
EventEmitter.prototype.emit = function(type, opt_params) {
  if (!type) {
    throw new TypeError('Cannot emit empty type event.');
  }
  var event = new Event(type, opt_params);
  _defer(function() {
    this.emitEventSync(event);
  }.bind(this));
  return event;
};

/**
 * Emits an event like the `emit` method, but then calls a provided function
 * after all the event listeners have been called.
 *
 * @param {string} type The type name of the event to emit.
 * @param {Object=} opt_params An object containing parameters for the Event
 *     object.
 * @param {EventHandler} done An event handler that will be called after all of
 *     the event handlers have been called.
 * @return {module:spotify-eventemitter~Event} The Event object that was
 *     created.
 */
EventEmitter.prototype.emitAndWait = function(type, opt_params, done) {
  if (!type) {
    throw new TypeError('Cannot emit empty type event.');
  }
  var event = new Event(type, opt_params);
  _defer(function() {
    this.emitEventSync(event);
    if (typeof done === 'function') {
      done(event);
    }
  }.bind(this));
  return event;
};

/**
 * Emits an event on the emitter.
 *
 * This method invokes all the added event listeners of the `type` of the
 * `event` provided in the order they were added, passing in the `event` as an
 * argument.
 *
 * This method emits events asynchronously: the listeners are not called until
 * the next run loop.
 *
 * @param {module:spotify-eventemitter~Event} event The Event object.
 * @return {module:spotify-eventemitter~Event} The Event object that was passed.
 */
EventEmitter.prototype.emitEvent = function(event) {
  _defer(function() {
    this.emitEventSync(event);
  }.bind(this));
  return event;
};

/**
 * Emits an event like `emitEvent`, but then calls a provided function after all
 * the event listeners have been called.
 *
 * @param {module:spotify-eventemitter~Event} event The Event object.
 * @param {EventHandler} done An event handler that will be called after all of
 *     the event handlers have been called.
 * @return {module:spotify-eventemitter~Event} The Event object that was passed.
 */
EventEmitter.prototype.emitEventAndWait = function(event, done) {
  _defer(function() {
    this.emitEventSync(event);
    if (typeof done === 'function') {
      done(event);
    }
  }.bind(this));
  return event;
};

/**
 * Creates and synchronously emits an event on the emitter.
 *
 * This method invokes all the added event listeners of the `type` provided in
 * the order they were added, passing in a new Event object created using the
 * provided `type` and `opt_params` arguments.
 *
 * @param {string} type The type name of event to emit.
 * @param {Object=} opt_params An object containing parameters for the event
 *     object.
 * @return {module:spotify-eventemitter~Event} The Event object that was
 *     created.
 */
EventEmitter.prototype.emitSync = function(type, opt_params) {
  var event = new Event(type, opt_params);
  this.emitEventSync(event);
  return event;
};

/**
 * Synchronously emits an event on the emitter.
 *
 * This method invokes all the added event listeners of the `type` of the
 * `event` provided in the order they were added, passing in the `event` as an
 * argument.
 *
 * @param {module:spotify-eventemitter~Event} event The Event object.
 * @return {module:spotify-eventemitter~Event} The Event object that was passed.
 */
EventEmitter.prototype.emitEventSync = function(event) {
  var type = event.type;
  var _listenerMap = this._listenerMap;
  var listeners = _listenerMap && _listenerMap[type];
  if (!listeners || !listeners.length) {
    return event;
  }
  listeners = listeners.slice(0);
  for (var i = 0, l = listeners.length; i < l; i++) {
    listeners[i].call(this, event);
    if (Event.wasImmediatePropagationStopped(event)) {
      break;
    }
  }
  return event;
};

/**
 * Proxies an event from another `EventEmitter` instance.
 *
 * This is used when we want to redirect events from internal objects to the
 * wrapping object. For example, if we have EventEmitter `A` that is referenced
 * inside EventEmitter `B` and we want to "re-emit" the event `A#eventName` as
 * `B#otherEventName`, we can call B.proxyEmit(A, 'eventName', 'otherEventName')
 *
 * @param {EventEmitter} source The EventEmitter source of the event.
 * @param {string} sourceType The type of event from the source to redirect.
 * @param {string} proxyType The type of event to fire for the current instance
 *     when `sourceType` is fired by `source`.
 * @return {EventEmitter} The current object.
 */
EventEmitter.prototype.proxyEmit = function(source, sourceType, proxyType) {
  if (!source || typeof source.on !== 'function') {
    throw new TypeError('Source must be an EventEmitter');
  }
  if (source === this) {
    throw new ReferenceError('Cannot create a recursive proxy.');
  }
  if (!sourceType || !proxyType) {
    throw new TypeError('Parameters sourceType and proxyType are required.');
  }
  source.on(sourceType, this.emit.bind(this, proxyType));
  return this;
};

/**
 * A synchronous version of `proxyEmit` (see that method for details).
 *
 * @param {EventEmitter} source The EventEmitter source of the event.
 * @param {string} sourceType The type of event from the source to redirect.
 * @param {string} proxyType The type of event to fire for the current instance
 *     when `sourceType` is fired by `source`.
 * @return {EventEmitter} The current object.
 */
EventEmitter.prototype.proxyEmitSync = function(source, sourceType, proxyType) {
  if (!source || typeof source.on !== 'function') {
    throw new TypeError('Source must be an EventEmitter');
  }
  if (source === this) {
    throw new ReferenceError('Cannot create a recursive proxy.');
  }
  if (!sourceType || !proxyType) {
    throw new TypeError('Parameters sourceType and proxyType are required.');
  }
  source.on(sourceType, this.emitSync.bind(this, proxyType));
  return this;
};

/**
 * Adds a "meta-listener" that will be called every time an event listener for
 * the given type is added to the EventEmitter.
 *
 * @param {string} type The type of event to listen for.
 * @param {function} listener A function that will be called when an event
 *     listener for the given type is added to the emitter.
 * @return {EventEmitter} The current object.
 */
EventEmitter.prototype.onAddListener = function(type, listener) {
  this.on(InternalPrefix.ADD + type, listener);
  return this;
};

/**
 * Adds a "meta-listener" that will be called every time an event listener for
 * the given type is removed from the EventEmitter.
 *
 * @param {string} type The type of event we were listening for.
 * @param {function} listener A function that will be called when an event
 *     listener for the given type is removed from the emitter.
 * @return {EventEmitter} The current object.
 */
EventEmitter.prototype.onRemoveListener = function(type, listener) {
  this.on(InternalPrefix.REMOVE + type, listener);
  return this;
};

module.exports = EventEmitter;

},{"./_internal/event":446,"spotify-deferred":445}],448:[function(require,module,exports){
'use strict';

/**
 * Makes a class inherit from a superclass' prototype indirectly.
 *
 * @param {Spotify.ClassLike} Sub The class that will inherit.
 * @param {Spotify.ClassLike} Super The class to inherit from.
 */
var inherit = function(Sub, Super) {
  var superProto = Super.prototype;
  function Superclass() {}
  Superclass.prototype = Sub._super = superProto;
  Superclass.prototype.constructor = Super;
  Sub.prototype = new Superclass();
};


/**
 * Export public interface
 */
module.exports = inherit;

},{}],449:[function(require,module,exports){
/**
 * Copyright (c) 2017 Spotify AB
 *
 * Fast base62 encoder/decoder.
 *
 * Usage:
 *
 *   Base62.toHex('1C0pasJ0dS2Z46GKh2puYo') // -> '34ff970885ca8fa02c0d6e459377d5d0'
 *                         ^^^
 *                          |
 *               Length-22 base62-encoded ID.
 *         Lengths other than 22 or invalid base62 IDs
 *                  are not supported.
 *
 *   Base62.fromHex('34ff970885ca8fa02c0d6e459377d5d0') // -> '1C0pasJ0dS2Z46GKh2puYo'
 *                         ^^^
 *                          |
 *               Length-32 hex-encoded ID.
 *         Lengths other than 32 are not supported.
 *
 * Written by @ludde, programatically tested and documented by @felipec.
 */
(function() {
  // Alphabets
  var HEX16 = '0123456789abcdef';
  var BASE62 =
    '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';

  // Hexadecimal fragments
  var HEX256 = [];
  HEX256.length = 256;
  for (var i = 0; i < 256; i++) {
    HEX256[i] = HEX16[i >> 4] + HEX16[i & 0xf];
  }

  // Look-up tables
  var ID62 = [];
  ID62.length = 128;
  for (var i = 0; i < BASE62.length; ++i) {
    ID62[BASE62.charCodeAt(i)] = i;
  }
  var ID16 = [];
  for (var i = 0; i < 16; i++) {
    ID16[HEX16.charCodeAt(i)] = i;
  }
  for (var i = 0; i < 6; i++) {
    ID16['ABCDEF'.charCodeAt(i)] = 10 + i;
  }

  var Base62 = {
    toHex: function(s) {
      if (s.length !== 22) {
        // Can only parse base62 ids with length == 22.
        // Invalid base62 ids will lead to garbage in the output.
        return null;
      }

      // 1 / (2^32)
      var MAX_INT_INV = 2.3283064365386963e-10;
      // 2^32
      var MAX_INT = 0x100000000;
      // 62^3
      var P62_3 = 238328;

      var p0, p1, p2, p3;
      var v;
      // First 7 characters fit in 2^53
      // prettier-ignore
      p0 =
        ID62[s.charCodeAt(0)] * 56800235584 +  // * 62^6
        ID62[s.charCodeAt(1)] * 916132832 +    // * 62^5
        ID62[s.charCodeAt(2)] * 14776336 +     // * 62^4
        ID62[s.charCodeAt(3)] * 238328 +       // * 62^3
        ID62[s.charCodeAt(4)] * 3844 +         // * 62^2
        ID62[s.charCodeAt(5)] * 62 +           // * 62^1
        ID62[s.charCodeAt(6)];                 // * 62^0
      p1 = (p0 * MAX_INT_INV) | 0;
      p0 -= p1 * MAX_INT;
      // 62^10 < 2^64
      v =
        ID62[s.charCodeAt(7)] * 3844 +
        ID62[s.charCodeAt(8)] * 62 +
        ID62[s.charCodeAt(9)];
      (p0 = p0 * P62_3 + v), (p0 = p0 - (v = (p0 * MAX_INT_INV) | 0) * MAX_INT);
      p1 = p1 * P62_3 + v;
      // 62^13 < 2^96
      v =
        ID62[s.charCodeAt(10)] * 3844 +
        ID62[s.charCodeAt(11)] * 62 +
        ID62[s.charCodeAt(12)];
      (p0 = p0 * P62_3 + v), (p0 = p0 - (v = (p0 * MAX_INT_INV) | 0) * MAX_INT);
      (p1 = p1 * P62_3 + v), (p1 = p1 - (v = (p1 * MAX_INT_INV) | 0) * MAX_INT);
      p2 = v;
      // 62^16 < 2^96
      v =
        ID62[s.charCodeAt(13)] * 3844 +
        ID62[s.charCodeAt(14)] * 62 +
        ID62[s.charCodeAt(15)];
      (p0 = p0 * P62_3 + v), (p0 = p0 - (v = (p0 * MAX_INT_INV) | 0) * MAX_INT);
      (p1 = p1 * P62_3 + v), (p1 = p1 - (v = (p1 * MAX_INT_INV) | 0) * MAX_INT);
      p2 = p2 * P62_3 + v;
      // 62^19 < 2^128
      v =
        ID62[s.charCodeAt(16)] * 3844 +
        ID62[s.charCodeAt(17)] * 62 +
        ID62[s.charCodeAt(18)];
      (p0 = p0 * P62_3 + v), (p0 = p0 - (v = (p0 * MAX_INT_INV) | 0) * MAX_INT);
      (p1 = p1 * P62_3 + v), (p1 = p1 - (v = (p1 * MAX_INT_INV) | 0) * MAX_INT);
      (p2 = p2 * P62_3 + v), (p2 = p2 - (v = (p2 * MAX_INT_INV) | 0) * MAX_INT);
      p3 = v;
      v =
        ID62[s.charCodeAt(19)] * 3844 +
        ID62[s.charCodeAt(20)] * 62 +
        ID62[s.charCodeAt(21)];
      (p0 = p0 * P62_3 + v), (p0 = p0 - (v = (p0 * MAX_INT_INV) | 0) * MAX_INT);
      (p1 = p1 * P62_3 + v), (p1 = p1 - (v = (p1 * MAX_INT_INV) | 0) * MAX_INT);
      (p2 = p2 * P62_3 + v), (p2 = p2 - (v = (p2 * MAX_INT_INV) | 0) * MAX_INT);
      (p3 = p3 * P62_3 + v), (p3 = p3 - (v = (p3 * MAX_INT_INV) | 0) * MAX_INT);
      if (v) {
        // carry not allowed
        return null;
      }
      // prettier-ignore
      return HEX256[p3>>>24]+HEX256[(p3>>>16)&0xFF]+HEX256[(p3>>>8)&0xFF]+HEX256[(p3)&0xFF] +
             HEX256[p2>>>24]+HEX256[(p2>>>16)&0xFF]+HEX256[(p2>>>8)&0xFF]+HEX256[(p2)&0xFF] +
             HEX256[p1>>>24]+HEX256[(p1>>>16)&0xFF]+HEX256[(p1>>>8)&0xFF]+HEX256[(p1)&0xFF] +
             HEX256[p0>>>24]+HEX256[(p0>>>16)&0xFF]+HEX256[(p0>>>8)&0xFF]+HEX256[(p0)&0xFF];
    },

    fromHex: function(s) {
      var i;
      var p0 = 0, p1 = 0, p2 = 0;
      for (i = 0; i < 10; i++) p2 = p2 * 16 + ID16[s.charCodeAt(i)];
      for (i = 0; i < 11; i++) p1 = p1 * 16 + ID16[s.charCodeAt(i + 10)];
      for (i = 0; i < 11; i++) p0 = p0 * 16 + ID16[s.charCodeAt(i + 21)];
      if (isNaN(p0 + p1 + p2)) {
        return null;
      }
      var P16_11 = 17592186044416; // 16^11
      var INV_62 = 1.0 / 62;

      var acc;
      var ret = '';
      i = 0;
      for (; i < 7; ++i) {
        acc = p2;
        p2 = Math.floor(acc * INV_62);
        acc = (acc - p2 * 62) * P16_11 + p1;
        p1 = Math.floor(acc * INV_62);
        acc = (acc - p1 * 62) * P16_11 + p0;
        p0 = Math.floor(acc * INV_62);
        ret = BASE62[acc - p0 * 62] + ret;
      }
      p1 += p2 * P16_11;
      for (; i < 15; ++i) {
        acc = p1;
        p1 = Math.floor(acc * INV_62);
        acc = (acc - p1 * 62) * P16_11 + p0;
        p0 = Math.floor(acc * INV_62);
        ret = BASE62[acc - p0 * 62] + ret;
      }
      p0 += p1 * P16_11;
      for (; i < 21; ++i) {
        acc = p0;
        p0 = Math.floor(acc * INV_62);
        ret = BASE62[acc - p0 * 62] + ret;
      }
      return BASE62[p0] + ret;
    },

    // Expose the lookup tables
    HEX256: HEX256, // number -> 'hh'
    ID16: ID16,  // hexadecimal char code -> 0..15
    ID62: ID62,  // base62 char code -> 0..61
  };

  if (typeof module !== 'undefined' && typeof module.exports !== 'undefined') {
    module.exports = Base62;
  } else {
    window.Base62 = Base62;
  }
})();

},{}],450:[function(require,module,exports){
'use strict';

/**
 * @private
 */
var Base62 = require('./base62');

/**
 * The URI prefix for URIs.
 *
 * @const
 * @private
 */
var URI_PREFIX = 'spotify:';

/**
 * The URL prefix for Play.
 *
 * @const
 * @private
 */
var PLAY_HTTP_PREFIX = 'http://play.spotify.com/';

/**
 * The HTTPS URL prefix for Play.
 *
 * @const
 * @private
 */
var PLAY_HTTPS_PREFIX = 'https://play.spotify.com/';

/**
 * The URL prefix for Open.
 *
 * @const
 * @private
 */
var OPEN_HTTP_PREFIX = 'http://open.spotify.com/';

/**
 * The HTTPS URL prefix for Open.
 *
 * @const
 * @private
 */
var OPEN_HTTPS_PREFIX = 'https://open.spotify.com/';

var ERROR_INVALID = new TypeError('Invalid Spotify URI!');
var ERROR_NOT_IMPLEMENTED = new TypeError('Not implemented!');


/**
 * The format for the URI to parse.
 *
 * @enum {number}
 * @private
 */
var Format = {
  URI: 0,
  URL: 1
};

/**
 * Represents the result of a URI splitting operation.
 *
 * @typedef {{
 *    format: Format,
 *    components: Array.<string>
 * }}
 * @see _splitIntoComponents
 * @private
 */
var SplittedURI;

/**
 * Split an string URI or HTTP/HTTPS URL into components, skipping the prefix.
 *
 * @param {string} str A string URI to split.
 * @return {SplittedURI} The parsed URI.
 * @private
 */
var _splitIntoComponents = function(str) {
  var components;
  var format;
  var query;
  var anchor;

  var querySplit = str.split('?');
  if (querySplit.length > 1) {
    str = querySplit.shift();
    query = querySplit.pop();

    var queryHashSplit = query.split('#');
    if (queryHashSplit.length > 1) {
      query = queryHashSplit.shift();
      anchor = queryHashSplit.pop();
    }

    query = decodeQueryString(query);
  }

  var hashSplit = str.split('#');
  if (hashSplit.length > 1) {
    // first token
    str = hashSplit.shift();
    // last token
    anchor = hashSplit.pop();
  }

  if (str.indexOf(URI_PREFIX) === 0) {
    components = str.slice(URI_PREFIX.length).split(':');
    format = Format.URI;
  } else {
    // For HTTP URLs, ignore any query string argument
    str = str.split('?')[0];

    if (str.indexOf(PLAY_HTTP_PREFIX) === 0) {
      components = str.slice(PLAY_HTTP_PREFIX.length).split('/');
    } else if (str.indexOf(PLAY_HTTPS_PREFIX) === 0) {
      components = str.slice(PLAY_HTTPS_PREFIX.length).split('/');
    } else if (str.indexOf(OPEN_HTTP_PREFIX) === 0) {
      components = str.slice(OPEN_HTTP_PREFIX.length).split('/');
    } else if (str.indexOf(OPEN_HTTPS_PREFIX) === 0) {
      components = str.slice(OPEN_HTTPS_PREFIX.length).split('/');
    } else {
      throw ERROR_INVALID;
    }
    format = Format.URL;
  }

  if (anchor) {
    components.push(anchor);
  }

  return {
    format: format,
    components: components,
    query: query
  };
};

/**
 * Encodes a component according to a format.
 *
 * @param {string} component A component string.
 * @param {Format} format A format.
 * @return {string} An encoded component string.
 * @private
 */
var _encodeComponent = function(component, format) {
  component = encodeURIComponent(component);
  if (format === Format.URI) {
    component = component.replace(/%20/g, '+');
  }

  // encode characters that are not encoded by default by encodeURIComponent
  // but that the Spotify URI spec encodes: !'*()
  component = component.replace(/[!'()]/g, escape);
  component = component.replace(/\*/g, '%2A');

  return component;
};

/**
 * Decodes a component according to a format.
 *
 * @param {string} component An encoded component string.
 * @param {Format} format A format.
 * @return {string} An decoded component string.
 * @private
 */
var _decodeComponent = function(component, format) {
  var part = format == Format.URI ? component.replace(/\+/g, '%20') : component;
  return decodeURIComponent(part);
};

/**
 * Returns the components of a URI as an array.
 *
 * @param {URI} uri A uri.
 * @param {Format} format The output format.
 * @return {Array.<string>} An array of uri components.
 * @private
 */
var _getComponents = function(uri, format) {
  var base62;
  if (uri.id) {
    base62 = uri._base62Id;
  }

  var components;
  var i;
  var len;
  switch (uri.type) {
    case URI.Type.ALBUM:
      components = [URI.Type.ALBUM, base62];
      if (uri.disc) {
        components.push(uri.disc);
      }
      return components;
    case URI.Type.AD:
      return [URI.Type.AD, uri._base62Id];
    case URI.Type.ARTIST:
      return [URI.Type.ARTIST, base62];
    case URI.Type.ARTIST_TOPLIST:
      return [URI.Type.ARTIST, base62, URI.Type.TOP, uri.toplist];
    case URI.Type.DAILY_MIX:
      return [URI.Type.DAILY_MIX, base62];
    case URI.Type.SEARCH:
      return [URI.Type.SEARCH, _encodeComponent(uri.query, format)];
    case URI.Type.TRACK:
      if (uri.context || uri.play) {
        base62 += encodeQueryString({
          context: uri.context,
          play: uri.play
        });
      }
      if (uri.anchor) {
        base62 += '#' + uri.anchor;
      }
      return [URI.Type.TRACK, base62];
    case URI.Type.TRACKSET:
      var trackIds = [];
      for (i = 0, len = uri.tracks.length; i < len; i++) {
        trackIds.push(uri.tracks[i]._base62Id);
      }
      trackIds = [trackIds.join(',')];
      // Index can be 0 sometimes (required for trackset)
      if (uri.index !== null) {
        trackIds.push('#', uri.index);
      }
      return [URI.Type.TRACKSET, _encodeComponent(uri.name)].concat(trackIds);
    case URI.Type.FACEBOOK:
      return [URI.Type.USER, URI.Type.FACEBOOK, uri.uid];
    case URI.Type.AUDIO_FILE:
      return [URI.Type.AUDIO_FILE, uri.extension, uri._base62Id];
    case URI.Type.FOLDER:
      return [URI.Type.USER, _encodeComponent(uri.username, format), URI.Type.FOLDER, uri._base62Id];
    case URI.Type.FOLLOWERS:
      return [URI.Type.USER, _encodeComponent(uri.username, format), URI.Type.FOLLOWERS];
    case URI.Type.FOLLOWING:
      return [URI.Type.USER, _encodeComponent(uri.username, format), URI.Type.FOLLOWING];
    case URI.Type.PLAYLIST:
      return [URI.Type.USER, _encodeComponent(uri.username, format), URI.Type.PLAYLIST, base62];
    case URI.Type.PLAYLIST_V2:
      return [URI.Type.PLAYLIST, base62];
    case URI.Type.STARRED:
      return [URI.Type.USER, _encodeComponent(uri.username, format), URI.Type.STARRED];
    case URI.Type.TEMP_PLAYLIST:
      return [URI.Type.TEMP_PLAYLIST, uri.origin, uri.data];
    case URI.Type.CONTEXT_GROUP:
      return [URI.Type.CONTEXT_GROUP, uri.origin, uri.name];
    case URI.Type.USER_TOPLIST:
      return [URI.Type.USER, _encodeComponent(uri.username, format), URI.Type.TOP, uri.toplist];
    // Legacy Toplist
    case URI.Type.USER_TOP_TRACKS:
      return [URI.Type.USER, _encodeComponent(uri.username, format), URI.Type.TOPLIST];
    case URI.Type.TOPLIST:
      return [URI.Type.TOP, uri.toplist].concat(uri.global ? [URI.Type.GLOBAL] : ['country', uri.country]);
    case URI.Type.INBOX:
      return [URI.Type.USER, _encodeComponent(uri.username, format), URI.Type.INBOX];
    case URI.Type.ROOTLIST:
      return [URI.Type.USER, _encodeComponent(uri.username, format), URI.Type.ROOTLIST];
    case URI.Type.PUBLISHED_ROOTLIST:
      return [URI.Type.USER, _encodeComponent(uri.username, format), URI.Type.PUBLISHED_ROOTLIST];
    case URI.Type.COLLECTION_TRACK_LIST:
      return [URI.Type.USER, _encodeComponent(uri.username, format), URI.Type.COLLECTION_TRACK_LIST, base62];
    case URI.Type.PROFILE:
      if (uri.args && uri.args.length > 0)
        return [URI.Type.USER, _encodeComponent(uri.username, format)].concat(uri.args);
      return [URI.Type.USER, _encodeComponent(uri.username, format)];
    case URI.Type.LOCAL_ARTIST:
      return [URI.Type.LOCAL, _encodeComponent(uri.artist, format)];
    case URI.Type.LOCAL_ALBUM:
      return [URI.Type.LOCAL, _encodeComponent(uri.artist, format), _encodeComponent(uri.album, format)];
    case URI.Type.LOCAL:
      return [URI.Type.LOCAL,
        _encodeComponent(uri.artist, format),
        _encodeComponent(uri.album, format),
        _encodeComponent(uri.track, format),
        uri.duration];
    case URI.Type.LIBRARY:
      return [URI.Type.USER, _encodeComponent(uri.username, format), URI.Type.LIBRARY].concat(uri.category ? [uri.category] : []);
    case URI.Type.IMAGE:
      return [URI.Type.IMAGE, uri._base62Id];
    case URI.Type.MOSAIC:
      components = uri.ids.slice(0);
      components.unshift(URI.Type.MOSAIC);
      return components;
    case URI.Type.RADIO:
      return [URI.Type.RADIO, uri.args];
    case URI.Type.SPECIAL:
      components = [URI.Type.SPECIAL];
      var args = uri.args || [];
      for (i = 0, len = args.length; i < len; ++i)
        components.push(_encodeComponent(args[i], format));
      return components;
    case URI.Type.STATION:
      components = [URI.Type.STATION];
      var args = uri.args || [];
      for (i = 0, len = args.length; i < len; i++) {
        components.push(_encodeComponent(args[i], format));
      }
      return components;
    case URI.Type.APPLICATION:
      components = [URI.Type.APP, uri._base62Id];
      var args = uri.args || [];
      for (i = 0, len = args.length; i < len; ++i)
        components.push(_encodeComponent(args[i], format));
      return components;
    case URI.Type.COLLECTION_ALBUM:
      return [URI.Type.USER, _encodeComponent(uri.username, format), URI.Type.COLLECTION, URI.Type.ALBUM, base62];
    case URI.Type.COLLECTION_MISSING_ALBUM:
      return [URI.Type.USER, _encodeComponent(uri.username, format), URI.Type.COLLECTION, URI.Type.ALBUM, base62, 'missing'];
    case URI.Type.COLLECTION_ARTIST:
      return [URI.Type.USER, _encodeComponent(uri.username, format), URI.Type.COLLECTION, URI.Type.ARTIST, base62];
    case URI.Type.COLLECTION:
      return [URI.Type.USER, _encodeComponent(uri.username, format), URI.Type.COLLECTION].concat(uri.category ? [uri.category] : []);
    case URI.Type.EPISODE:
      if (uri.context || uri.play) {
        base62 += encodeQueryString({
          context: uri.context,
          play: uri.play
        });
      }
      return [URI.Type.EPISODE, base62];
    case URI.Type.SHOW:
      return [URI.Type.SHOW, base62];
    case URI.Type.CONCERT:
      return [URI.Type.CONCERT, base62];
    default:
      throw ERROR_INVALID;
  }
};

var encodeQueryString = function(values) {
  var str = '?';
  for (var i in values) {
    if (values.hasOwnProperty(i) && values[i] !== undefined) {
      if (str.length > 1) {
        str += '&';
      }
      str += i + '=' + encodeURIComponent(values[i]);
    }
  }
  return str;
};

var decodeQueryString = function(str) {
  return str.split('&').reduce(function(object, pair) {
    pair = pair.split('=');
    object[pair[0]] = decodeURIComponent(pair[1]);
    return object;
  }, {});
};

/**
 * Parses the components of a URI into a real URI object.
 *
 * @param {Array.<string>} components The components of the URI as a string
 *     array.
 * @param {Format} format The format of the source string.
 * @return {URI} The URI object.
 * @private
 */
var _parseFromComponents = function(components, format, query) {
  var _current = 0;
  query = query || {};

  var _getNextComponent = function() {
    return components[_current++];
  };

  var _getIdComponent = function() {
    var component = _getNextComponent();

    if (component.length > 22) {
      throw new Error('Invalid ID');
    }
    return component;
  };

  var _getRemainingComponents = function() {
    return components.slice(_current);
  };

  var _getRemainingString = function() {
    var separator = (format == Format.URI) ? ':' : '/';
    return components.slice(_current).join(separator);
  };

  var part = _getNextComponent();
  var id;
  var i;
  var len;

  switch (part) {
    case URI.Type.ALBUM:
      return URI.albumURI(_getIdComponent(), parseInt(_getNextComponent(), 10));
    case URI.Type.AD:
      return URI.adURI(_getNextComponent());
    case URI.Type.ARTIST:
      id = _getIdComponent();
      if (_getNextComponent() == URI.Type.TOP) {
        return URI.artistToplistURI(id, _getNextComponent());
      } else {
        return URI.artistURI(id);
      }
    case URI.Type.AUDIO_FILE:
      return URI.audioFileURI(_getNextComponent(), _getNextComponent());
    case URI.Type.DAILY_MIX:
      return URI.dailyMixURI(_getIdComponent());
    case URI.Type.TEMP_PLAYLIST:
      return URI.temporaryPlaylistURI(_getNextComponent(), _getRemainingString());
    case URI.Type.PLAYLIST:
      return URI.playlistV2URI(_getIdComponent());
    case URI.Type.SEARCH:
      return URI.searchURI(_decodeComponent(_getRemainingString(), format));
    case URI.Type.TRACK:
      return URI.trackURI(_getIdComponent(), _getNextComponent(), query.context, query.play);
    case URI.Type.TRACKSET:
      var name = _decodeComponent(_getNextComponent());
      var tracksArray = _getNextComponent();
      var hashSign = _getNextComponent();
      var index = parseInt(_getNextComponent(), 10);
      // Sanity check: %23 is URL code for "#"
      if (hashSign !== '%23' || isNaN(index)) {
        index = null;
      }
      var tracksetTracks = [];
      if (tracksArray) {
        tracksArray = _decodeComponent(tracksArray).split(',');
        for (i = 0, len = tracksArray.length; i < len; i++) {
          var trackId = tracksArray[i];
          tracksetTracks.push(URI.trackURI(trackId));
        }
      }
      return URI.tracksetURI(tracksetTracks, name, index);
    case URI.Type.CONTEXT_GROUP:
      return URI.contextGroupURI(_getNextComponent(), _getNextComponent());
    case URI.Type.TOP:
      var type = _getNextComponent();
      if (_getNextComponent() == URI.Type.GLOBAL) {
        return URI.toplistURI(type, null, true);
      } else {
        return URI.toplistURI(type, _getNextComponent(), false);
      }
    case URI.Type.USER:
      var username = _decodeComponent(_getNextComponent(), format);
      var text = _getNextComponent();
      if (username == URI.Type.FACEBOOK && text != null) {
        return URI.facebookURI(parseInt(text, 10));
      } else if (text != null) {
        switch (text) {
          case URI.Type.PLAYLIST:
            return URI.playlistURI(username, _getIdComponent());
          case URI.Type.FOLDER:
            return URI.folderURI(username, _getIdComponent());
          case URI.Type.COLLECTION_TRACK_LIST:
            return URI.collectionTrackList(username, _getIdComponent());
          case URI.Type.COLLECTION:
            var collectionItemType = _getNextComponent();
            switch (collectionItemType) {
              case URI.Type.ALBUM:
                id = _getIdComponent();
                if (_getNextComponent() === 'missing') {
                  return URI.collectionMissingAlbumURI(username, id);
                } else {
                  return URI.collectionAlbumURI(username, id);
                }
              case URI.Type.ARTIST:
                return URI.collectionArtistURI(username, _getIdComponent());
              default:
                return URI.collectionURI(username, collectionItemType);
            }
          case URI.Type.STARRED:
            return URI.starredURI(username);
          case URI.Type.FOLLOWERS:
            return URI.followersURI(username);
          case URI.Type.FOLLOWING:
            return URI.followingURI(username);
          case URI.Type.TOP:
            return URI.userToplistURI(username, _getNextComponent());
          case URI.Type.INBOX:
            return URI.inboxURI(username);
          case URI.Type.ROOTLIST:
            return URI.rootlistURI(username);
          case URI.Type.PUBLISHED_ROOTLIST:
            return URI.publishedRootlistURI(username);
          case URI.Type.TOPLIST:
            // legacy toplist
            return URI.userTopTracksURI(username);
          case URI.Type.LIBRARY:
            return URI.libraryURI(username, _getNextComponent());
        }
      }
      var rem = _getRemainingComponents();
      if (text != null && rem.length > 0) {
        return URI.profileURI(username, [text].concat(rem));
      } else if (text != null) {
        return URI.profileURI(username, [text]);
      } else {
        return URI.profileURI(username);
      }
    case URI.Type.LOCAL:
      var artistNameComponent = _getNextComponent();
      var artistName = artistNameComponent && _decodeComponent(artistNameComponent, format);
      var albumNameComponent = _getNextComponent();
      var albumName = albumNameComponent && _decodeComponent(albumNameComponent, format);
      var trackNameComponent = _getNextComponent();
      var trackName = trackNameComponent && _decodeComponent(trackNameComponent, format);
      var durationComponent = _getNextComponent();
      var duration = parseInt(durationComponent, 10);
      if (trackNameComponent !== undefined) {
        return URI.localURI(artistName, albumName, trackName, duration);
      } else if (albumNameComponent !== undefined) {
        return URI.localAlbumURI(artistName, albumName);
      } else {
        return URI.localArtistURI(artistName);
      }
    case URI.Type.IMAGE:
      return URI.imageURI(_getIdComponent());
    case URI.Type.MOSAIC:
      return URI.mosaicURI(components.slice(_current));
    case URI.Type.RADIO:
      return URI.radioURI(_getRemainingString());
    case URI.Type.SPECIAL:
      var args = _getRemainingComponents();
      for (i = 0, len = args.length; i < len; ++i)
        args[i] = _decodeComponent(args[i], format);
      return URI.specialURI(args);
    case URI.Type.STATION:
      return URI.stationURI(_getRemainingComponents());
    case URI.Type.EPISODE:
      return URI.episodeURI(_getIdComponent(), query.context, query.play);
    case URI.Type.SHOW:
      return URI.showURI(_getIdComponent());
    case URI.Type.CONCERT:
      return URI.concertURI(_getIdComponent());
    case '':
      break;
    default:
      if (part === URI.Type.APP) {
        id = _getNextComponent();
      } else {
        id = part;
      }
      var decodedId = _decodeComponent(id, format);
      if (_encodeComponent(decodedId, format) !== id) {
        break;
      }
      var args = _getRemainingComponents();
      for (i = 0, len = args.length; i < len; ++i)
        args[i] = _decodeComponent(args[i], format);
      return URI.applicationURI(decodedId, args);
  }

  throw ERROR_INVALID;
};

/**
 * A class holding information about a uri.
 *
 * @constructor
 * @param {URI.Type} type
 * @param {Object} props
 */
function URI(type, props) {
  this.type = type;

  // Merge properties into URI object.
  for (var prop in props) {
    if (typeof props[prop] == 'function') {
      continue;
    }
    this[prop] = props[prop];
  }
}

// Lazy convert the id to hexadecimal only when requested
Object.defineProperty(URI.prototype, 'id', {
  get: function() {
    if (!this._hexId) {
      this._hexId = this._base62Id ? URI.idToHex(this._base62Id) : undefined;
    }
    return this._hexId;
  },
  set: function(id) {
    this._base62Id = id ? URI.hexToId(id) : undefined;
    this._hexId = undefined;
  },
  enumerable: true,
  configurable: true
});

/**
 * Creates an application URI object from the current URI object.
 *
 * If the current URI object is already an application type, a copy is made.
 *
 * @return {URI} The current URI as an application URI.
 */
URI.prototype.toAppType = function() {
  if (this.type == URI.Type.APPLICATION) {
    return URI.applicationURI(this.id, this.args);
  } else {
    var components = _getComponents(this, Format.URL);
    var id = components.shift();
    var len = components.length;
    if (len) {
      while (len--) {
        components[len] = _decodeComponent(components[len], Format.URL);
      }
    }
    if (this.type == URI.Type.RADIO) {
      components = components.shift().split(':');
    }
    var result = URI.applicationURI(id, components);
    return result;
  }
};

/**
 * Creates a URI object from an application URI object.
 *
 * If the current URI object is not an application type, a copy is made.
 *
 * @return {URI} The current URI as a real typed URI.
 */
URI.prototype.toRealType = function() {
  if (this.type == URI.Type.APPLICATION) {
    return _parseFromComponents([this.id].concat(this.args), Format.URI);
  } else {
    return new URI(null, this);
  }
};

/**
 * Returns the URI representation of this URI.
 *
 * @return {String} The URI representation of this uri.
 */
URI.prototype.toURI = function() {
  return URI_PREFIX + _getComponents(this, Format.URI).join(':');
};

/**
 * Returns the String representation of this URI.
 *
 * @return {String} The URI representation of this uri.
 * @see {URI#toURI}
 */
URI.prototype.toString = function() {
  return this.toURI();
};

/**
 * Get the URL path of this uri.
 *
 * @param {boolean} opt_leadingSlash True if a leading slash should be prepended.
 * @return {String} The path of this uri.
 */
URI.prototype.toURLPath = function(opt_leadingSlash) {
  var components = _getComponents(this, Format.URL);
  if (components[0] === URI.Type.APP) {
    components.shift();
  }

  // Some URIs are allowed to have empty components. It should be investigated
  // whether we need to strip empty components at all from any URIs. For now,
  // we check specifically for tracksets and local tracks and strip empty
  // components for all other URIs.
  //
  // For tracksets, it's permissible to have a path that looks like
  // 'trackset//trackURI' because the identifier parameter for a trackset can
  // be blank. For local tracks, some metadata can be missing, like missing
  // album name would be 'spotify:local:artist::track:duration'.
  var isTrackset = components[0] === URI.Type.TRACKSET;
  var isLocalTrack = components[0] === URI.Type.LOCAL;
  var shouldStripEmptyComponents = !isTrackset && !isLocalTrack;

  if (shouldStripEmptyComponents) {
    var _temp = [];
    for (var i = 0, l = components.length; i < l; i++) {
      var component = components[i];
      if (!!component) {
        _temp.push(component);
      }
    }
    components = _temp;
  }
  var path = components.join('/');
  return opt_leadingSlash ? '/' + path : path;
};

/**
 * Returns the Play URL string for the uri.
 *
 * @return {string} The Play URL string for the uri.
 */
URI.prototype.toPlayURL = function() {
    return PLAY_HTTPS_PREFIX + this.toURLPath();
};

/**
 * Returns the URL string for the uri.
 *
 * @return {string} The URL string for the uri.
 * @see {URL#toPlayURL}
 */
URI.prototype.toURL = function() {
  return this.toPlayURL();
};

/**
 * Returns the Open URL string for the uri.
 *
 * @return {string} The Open URL string for the uri.
 */
URI.prototype.toOpenURL = function() {
  return OPEN_HTTPS_PREFIX + this.toURLPath();
};

/**
 * Returns the Play HTTPS URL string for the uri.
 *
 * @return {string} The Play HTTPS URL string for the uri.
 */
URI.prototype.toSecurePlayURL = function() {
    return this.toPlayURL();
};

/**
 * Returns the HTTPS URL string for the uri.
 *
 * @return {string} The HTTPS URL string for the uri.
 * @see {URL#toSecurePlayURL}
 */
URI.prototype.toSecureURL = function() {
  return this.toPlayURL();
};

/**
 * Returns the Open HTTPS URL string for the uri.
 *
 * @return {string} The Open HTTPS URL string for the uri.
 */
URI.prototype.toSecureOpenURL = function() {
  return this.toOpenURL();
};

/**
 * Returns the id of the uri as a bytestring.
 *
 * @return {Array} The id of the uri as a bytestring.
 */
URI.prototype.idToByteString = function() {
  var hexId = Base62.toHex(this._base62Id);
  if (!hexId) {
    var zero = '';
    for (var i = 0; i < 16; i++) {
      zero += String.fromCharCode(0);
    }
    return zero;
  }
  var data = '';
  for (var i = 0; i < 32; i += 2) {
    var upper = Base62.ID16[hexId.charCodeAt(i)];
    var lower = Base62.ID16[hexId.charCodeAt(i + 1)];
    var byte = (upper << 4) + lower;
    data += String.fromCharCode(byte);
  }
  return data;
};

URI.prototype.getPath = function() {
  var uri = this.toString().replace(/[#?].*/, '');
  return uri;
}

URI.prototype.getBase62Id = function() {
  return this._base62Id;
}


/**
* Checks whether two URI:s refer to the same thing even though they might
* not necessarily be equal.
*
* These two Playlist URIs, for example, refer to the same playlist:
*
*   spotify:user:napstersean:playlist:3vxotOnOGDlZXyzJPLFnm2
*   spotify:playlist:3vxotOnOGDlZXyzJPLFnm2
*
* @param {*} uri The uri to compare identity for.
* @return {boolean} Whether they shared idenitity
*/
URI.prototype.isSameIdentity = function(uri) {
  var uriObject = URI.from(uri);
  if (!uriObject) return false;
  if (this.toString() === uri.toString()) return true;
  if (
    (this.type === URI.Type.PLAYLIST || this.type === URI.Type.PLAYLIST_V2) &&
    (uriObject.type === URI.Type.PLAYLIST || uriObject.type === URI.Type.PLAYLIST_V2)
  ) {
    return this.id === uriObject.id;
  } else if (this.type === URI.Type.STATION && uriObject.type === URI.Type.STATION) {
    var thisStationContextUriObject = _parseFromComponents(this.args, Format.URI);
    return !!thisStationContextUriObject &&
      thisStationContextUriObject.isSameIdentity(
        _parseFromComponents(uriObject.args, Format.URI)
      );
  } else {
    return false;
  }
}

/**
 * The various URI Types.
 *
 * Note that some of the types in this enum are not real URI types, but are
 * actually URI particles. They are marked so.
 *
 * @enum {string}
 */
URI.Type = {
  EMPTY: 'empty',
  ALBUM: 'album',
  AD: 'ad',
  /** URI particle; not an actual URI. */
  APP: 'app',
  APPLICATION: 'application',
  ARTIST: 'artist',
  ARTIST_TOPLIST: 'artist-toplist',
  AUDIO_FILE: 'audiofile',
  COLLECTION: 'collection',
  COLLECTION_ALBUM: 'collection-album',
  COLLECTION_MISSING_ALBUM: 'collection-missing-album',
  COLLECTION_ARTIST: 'collection-artist',
  CONTEXT_GROUP: 'context-group',
  DAILY_MIX: 'dailymix',
  EPISODE: 'episode',
  /** URI particle; not an actual URI. */
  FACEBOOK: 'facebook',
  FOLDER: 'folder',
  FOLLOWERS: 'followers',
  FOLLOWING: 'following',
  /** URI particle; not an actual URI. */
  GLOBAL: 'global',
  IMAGE: 'image',
  INBOX: 'inbox',
  LOCAL_ARTIST: 'local-artist',
  LOCAL_ALBUM: 'local-album',
  LOCAL: 'local',
  LIBRARY: 'library',
  MOSAIC: 'mosaic',
  PLAYLIST: 'playlist',
  /** Only used for URI classification. Not a valid URI fragment. */
  PLAYLIST_V2: 'playlist-v2',
  PROFILE: 'profile',
  PUBLISHED_ROOTLIST: 'published-rootlist',
  RADIO: 'radio',
  ROOTLIST: 'rootlist',
  COLLECTION_TRACK_LIST: 'collectiontracklist',
  SEARCH: 'search',
  SHOW: 'show',
  CONCERT: 'concert',
  SPECIAL: 'special',
  STARRED: 'starred',
  STATION: 'station',
  TEMP_PLAYLIST: 'temp-playlist',
  /** URI particle; not an actual URI. */
  TOP: 'top',
  TOPLIST: 'toplist',
  TRACK: 'track',
  TRACKSET: 'trackset',
  /** URI particle; not an actual URI. */
  USER: 'user',
  USER_TOPLIST: 'user-toplist',
  USER_TOP_TRACKS: 'user-top-tracks',
  /** Deprecated contant. Please use USER_TOP_TRACKS. */
  USET_TOP_TRACKS: 'user-top-tracks'
};

/**
 * Creates a new URI object from a parsed string argument.
 *
 * @param {string} str The string that will be parsed into a URI object.
 * @throws TypeError If the string argument is not a valid URI, a TypeError will
 *     be thrown.
 * @return {URI} The parsed URI object.
 */
URI.fromString = function(str) {
  var splitted = _splitIntoComponents(str);
  return _parseFromComponents(splitted.components, splitted.format, splitted.query);
};

/**
 * Parses a given object into a URI instance.
 *
 * Unlike URI.fromString, this function could receive any kind of value. If
 * the value is already a URI instance, it is simply returned.
 * Otherwise the value will be stringified before parsing.
 *
 * This function also does not throw an error like URI.fromString, but
 * instead simply returns null if it can't parse the value.
 *
 * @param {*} value The value to parse.
 * @return {URI?} The corresponding URI instance, or null if the
 *     passed value is not a valid value.
 */
URI.from = function(value) {
  try {
    if (value instanceof URI) {
      return value;
    }
    if (typeof value == 'object' && value.type) {
      return new URI(null, value);
    }
    return URI.fromString(value.toString());
  } catch(e) {
    return null;
  }
};

/**
 * Creates a new URI from a bytestring.
 *
 * @param {URI.Type} type The type of the URI.
 * @param {ByteString} idByteString The ID of the URI as a bytestring.
 * @param {Object} opt_args Optional arguments to the URI constructor.
 * @return {URI} The URI object created.
 */
URI.fromByteString = function(type, idByteString, opt_args) {
  while (idByteString.length != 16) {
    idByteString = String.fromCharCode(0) + idByteString;
  }
  var hexId = '';
  for (var i = 0; i < idByteString.length; i++) {
    var byte = idByteString.charCodeAt(i);
    hexId += Base62.HEX256[byte];
  }
  var id = Base62.fromHex(hexId);
  var args = opt_args || {};
  args.id = id;
  return new URI(type, args);
};

/**
 * Clones a given SpotifyURI instance.
 *
 * @param {URI} uri The uri to clone.
 * @return {URI?} An instance of URI.
 */
URI.clone = function(uri) {
  if (!(uri instanceof URI)) {
    return null;
  }
  return new URI(null, uri);
};

/**
 * @deprecated
 */
URI.getCanonical = function(username) {
  return this.getCanonical(username);
};

/**
 * Returns the canonical representation of a username.
 *
 * @param {string} username The username to encode.
 * @return {string} The encoded canonical representation of the username.
 */
URI.getCanonicalUsername = function(username) {
  return _encodeComponent(username, Format.URI);
};

/**
 * Returns the non-canonical representation of a username.
 *
 * @param {string} username The username to encode.
 * @return {string} The unencoded canonical representation of the username.
 */
URI.getDisplayUsername = function(username) {
  return _decodeComponent(username, Format.URI);
};

/**
 * Returns the hex representation of a Base62 encoded id.
 *
 * @param {string} id The base62 encoded id.
 * @return {string} The hex representation of the base62 id.
 */
URI.idToHex = function(id) {
  if (id.length == 22) {
    return Base62.toHex(id);
  }
  return id;
};

/**
 * Returns the base62 representation of a hex encoded id.
 *
 * @param {string} hex The hex encoded id.
 * @return {string} The base62 representation of the id.
 */
URI.hexToId = function(hex) {
  if (hex.length == 32) {
    return Base62.fromHex(hex);
  }
  return hex;
};

/**
 * Creates a new empty URI.
 *
 * @return {URI} The empty URI.
 */
URI.emptyURI = function() {
  return new URI(URI.Type.EMPTY, {});
};

/**
 * Creates a new 'album' type URI.
 *
 * @param {string} id The id of the album.
 * @param {number} disc The disc number of the album.
 * @return {URI} The album URI.
 */
URI.albumURI = function(id, disc) {
  return new URI(URI.Type.ALBUM, {id: id, disc: disc});
};

/**
 * Creates a new 'ad' type URI.
 *
 * @param {string} id The id of the ad.
 * @return {URI} The ad URI.
 */
URI.adURI = function(id) {
  return new URI(URI.Type.AD, {id: id});
};

/**
 * Creates a new 'audiofile' type URI.
 *
 * @param {string} extension The extension of the audiofile.
 * @param {string} id The id of the extension.
 * @return {URI} The audiofile URI.
 */
URI.audioFileURI = function(extension, id) {
  return new URI(URI.Type.AUDIO_FILE, {id: id, extension: extension});
};

/**
 * Creates a new 'artist' type URI.
 *
 * @param {string} id The id of the artist.
 * @return {URI} The artist URI.
 */
URI.artistURI = function(id) {
  return new URI(URI.Type.ARTIST, {id: id});
};

/**
 * Creates a new 'artist-toplist' type URI.
 *
 * @param {string} id The id of the artist.
 * @param {string} toplist The toplist type.
 * @return {URI} The artist-toplist URI.
 */
URI.artistToplistURI = function(id, toplist) {
  return new URI(URI.Type.ARTIST_TOPLIST, {id: id, toplist: toplist});
};

/**
 * Creates a new 'dailymix' type URI.
 *
 * @param {Array.<string>} args An array of arguments for the dailymix.
 * @return {URI} The dailymix URI.
 */
URI.dailyMixURI = function(id) {
  return new URI(URI.Type.DAILY_MIX, {id: id});
};

/**
 * Creates a new 'search' type URI.
 *
 * @param {string} query The unencoded search query.
 * @return {URI} The search URI
 */
URI.searchURI = function(query) {
  return new URI(URI.Type.SEARCH, {query: query});
};

/**
 * Creates a new 'track' type URI.
 *
 * @param {string} id The id of the track.
 * @param {string} anchor The point in the track formatted as mm:ss
 * @return {URI} The track URI.
 */
URI.trackURI = function(id, anchor, context, play) {
  return new URI(URI.Type.TRACK, {
    id: id,
    anchor: anchor,
    context: context ? URI.fromString(context) : context,
    play: play
  });
};

/**
 * Creates a new 'trackset' type URI.
 *
 * @param {Array.<URI>} tracks An array of 'track' type URIs.
 * @param {string} name The name of the trackset.
 * @param {number} index The index in the trackset.
 * @return {URI} The trackset URI.
 */
URI.tracksetURI = function(tracks, name, index) {
  return new URI(URI.Type.TRACKSET, {
    tracks: tracks,
    name: name || '',
    index: isNaN(index) ? null : index
  });
};

/**
 * Creates a new 'facebook' type URI.
 *
 * @param {string} uid The user id.
 * @return {URI} The facebook URI.
 */
URI.facebookURI = function(uid) {
  return new URI(URI.Type.FACEBOOK, {uid: uid});
};

/**
 * Creates a new 'followers' type URI.
 *
 * @param {string} username The non-canonical username.
 * @return {URI} The followers URI.
 */
URI.followersURI = function(username) {
  return new URI(URI.Type.FOLLOWERS, {username: username});
};

/**
 * Creates a new 'following' type URI.
 *
 * @param {string} username The non-canonical username.
 * @return {URI} The following URI.
 */
URI.followingURI = function(username) {
  return new URI(URI.Type.FOLLOWING, {username: username});
};

/**
 * Creates a new 'playlist' type URI.
 *
 * @param {string} username The non-canonical username of the playlist owner.
 * @param {string} id The id of the playlist.
 * @return {URI} The playlist URI.
 */
URI.playlistURI = function(username, id) {
  return new URI(URI.Type.PLAYLIST, {username: username, id: id});
};

/**
 * Creates a new 'playlist-v2' type URI.
 *
 * @param {string} id The id of the playlist.
 * @return {URI} The playlist URI.
 */
URI.playlistV2URI = function(id) {
  return new URI(URI.Type.PLAYLIST_V2, {id: id});
};

/**
 * Creates a new 'folder' type URI.
 *
 * @param {string} username The non-canonical username of the folder owner.
 * @param {string} id The id of the folder.
 * @return {URI} The folder URI.
 */
URI.folderURI = function(username, id) {
  return new URI(URI.Type.FOLDER, {username: username, id: id});
};

/**
 * Creates a new 'collectiontracklist' type URI.
 *
 * @param {string} username The non-canonical username of the collection owner.
 * @param {string} id The id of the tracklist.
 * @return {URI} The collectiontracklist URI.
 */
URI.collectionTrackList = function(username, id) {
  return new URI(URI.Type.COLLECTION_TRACK_LIST, {username: username, id: id});
};

/**
 * Creates a new 'starred' type URI.
 *
 * @param {string} username The non-canonical username of the starred list owner.
 * @return {URI} The starred URI.
 */
URI.starredURI = function(username) {
  return new URI(URI.Type.STARRED, {username: username});
};

/**
 * Creates a new 'user-toplist' type URI.
 *
 * @param {string} username The non-canonical username of the toplist owner.
 * @param {string} toplist The toplist type.
 * @return {URI} The user-toplist URI.
 */
URI.userToplistURI = function(username, toplist) {
  return new URI(URI.Type.USER_TOPLIST, {username: username, toplist: toplist});
};

/**
 * Creates a new 'user-top-tracks' type URI.
 *
 * @deprecated
 * @param {string} username The non-canonical username of the toplist owner.
 * @return {URI} The user-top-tracks URI.
 */
URI.userTopTracksURI = function(username) {
  return new URI(URI.Type.USER_TOP_TRACKS, {username: username});
};

/**
 * Creates a new 'toplist' type URI.
 *
 * @param {string} toplist The toplist type.
 * @param {string} country The country code for the toplist.
 * @param {boolean} global True if this is a global rather than a country list.
 * @return {URI} The toplist URI.
 */
URI.toplistURI = function(toplist, country, global) {
  return new URI(URI.Type.TOPLIST, {toplist: toplist, country: country, global: !!global});
};

/**
 * Creates a new 'inbox' type URI.
 *
 * @param {string} username The non-canonical username of the inbox owner.
 * @return {URI} The inbox URI.
 */
URI.inboxURI = function(username) {
  return new URI(URI.Type.INBOX, {username: username});
};

/**
 * Creates a new 'rootlist' type URI.
 *
 * @param {string} username The non-canonical username of the rootlist owner.
 * @return {URI} The rootlist URI.
 */
URI.rootlistURI = function(username) {
  return new URI(URI.Type.ROOTLIST, {username: username});
};

/**
 * Creates a new 'published-rootlist' type URI.
 *
 * @param {string} username The non-canonical username of the published-rootlist owner.
 * @return {URI} The published-rootlist URI.
 */
URI.publishedRootlistURI = function(username) {
  return new URI(URI.Type.PUBLISHED_ROOTLIST, {username: username});
};

/**
 * Creates a new 'local-artist' type URI.
 *
 * @param {string} artist The artist name.
 * @return {URI} The local-artist URI.
 */
URI.localArtistURI = function(artist) {
  return new URI(URI.Type.LOCAL_ARTIST, {artist: artist});
};

/**
 * Creates a new 'local-album' type URI.
 *
 * @param {string} artist The artist name.
 * @param {string} album The album name.
 * @return {URI} The local-album URI.
 */
URI.localAlbumURI = function(artist, album) {
  return new URI(URI.Type.LOCAL_ALBUM, {artist: artist, album: album});
};

/**
 * Creates a new 'local' type URI.
 *
 * @param {string} artist The artist name.
 * @param {string} album The album name.
 * @param {string} track The track name.
 * @param {number} duration The track duration in ms.
 * @return {URI} The local URI.
 */
URI.localURI = function(artist, album, track, duration) {
  return new URI(URI.Type.LOCAL, {
    artist: artist,
    album: album,
    track: track,
    duration: duration
  });
};

/**
 * Creates a new 'library' type URI.
 *
 * @param {string} username The non-canonical username of the rootlist owner.
 * @param {string} category The category of the library.
 * @return {URI} The library URI.
 */
URI.libraryURI = function(username, category) {
  return new URI(URI.Type.LIBRARY, {username: username, category: category});
};

/**
 * Creates a new 'collection' type URI.
 *
 * @param {string} username The non-canonical username of the rootlist owner.
 * @param {string} category The category of the collection.
 * @return {URI} The collection URI.
 */
URI.collectionURI = function(username, category) {
  return new URI(URI.Type.COLLECTION, {username: username, category: category});
};

/**
 * Creates a new 'temp-playlist' type URI.
 *
 * @param {string} origin The origin of the temporary playlist.
 * @param {string} data Additional data for the playlist.
 * @return {URI} The temp-playlist URI.
 */
URI.temporaryPlaylistURI = function(origin, data) {
  return new URI(URI.Type.TEMP_PLAYLIST, {origin: origin, data: data});
};

/**
 * Creates a new 'context-group' type URI.
 *
 * @deprecated
 * @param {string} origin The origin of the temporary playlist.
 * @param {string} name The name of the context group.
 * @return {URI} The context-group URI.
 */
URI.contextGroupURI = function(origin, name) {
  return new URI(URI.Type.CONTEXT_GROUP, {origin: origin, name: name});
};

/**
 * Creates a new 'profile' type URI.
 *
 * @param {string} username The non-canonical username of the rootlist owner.
 * @param {Array.<string>} args A list of arguments.
 * @return {URI} The profile URI.
 */
URI.profileURI = function(username, args) {
  return new URI(URI.Type.PROFILE, {username: username, args: args});
};

/**
 * Creates a new 'image' type URI.
 *
 * @param {string} id The id of the image.
 * @return {URI} The image URI.
 */
URI.imageURI = function(id) {
  return new URI(URI.Type.IMAGE, {id: id});
};

/**
 * Creates a new 'mosaic' type URI.
 *
 * @param {Array.<string>} ids The ids of the mosaic immages.
 * @return {URI} The mosaic URI.
 */
URI.mosaicURI = function(ids) {
  return new URI(URI.Type.MOSAIC, {ids: ids});
};

/**
 * Creates a new 'radio' type URI.
 *
 * @param {string} args The radio seed arguments.
 * @return {URI} The radio URI.
 */
URI.radioURI = function(args) {
  args = typeof args === 'undefined' ? '' : args;
  return new URI(URI.Type.RADIO, {args: args});
};

/**
 * Creates a new 'special' type URI.
 *
 * @param {Array.<string>} args An array containing the other arguments.
 * @return {URI} The special URI.
 */
URI.specialURI = function(args) {
  args = typeof args === 'undefined' ? [] : args;
  return new URI(URI.Type.SPECIAL, {args: args});
};

/**
 * Creates a new 'station' type URI.
 *
 * @param {Array.<string>} args An array of arguments for the station.
 * @return {URI} The station URI.
 */
URI.stationURI = function(args) {
  args = typeof args === 'undefined' ? [] : args;
  return new URI(URI.Type.STATION, {args: args});
};

/**
 * Creates a new 'application' type URI.
 *
 * @param {string} id The id of the application.
 * @param {Array.<string>} args An array containing the arguments to the app.
 * @return {URI} The application URI.
 */
URI.applicationURI = function(id, args) {
  args = typeof args === 'undefined' ? [] : args;
  return new URI(URI.Type.APPLICATION, {id: id, args: args});
};

/**
 * Creates a new 'collection-album' type URI.
 *
 * @param {string} username The non-canonical username of the rootlist owner.
 * @param {string} id The id of the album.
 * @return {URI} The collection-album URI.
 */
URI.collectionAlbumURI = function(username, id) {
  return new URI(URI.Type.COLLECTION_ALBUM, {username: username, id: id});
};

/**
 * Creates a new 'collection-album-missing' type URI.
 *
 * @param {string} username The non-canonical username of the rootlist owner.
 * @param {string} id The id of the album.
 * @return {URI} The collection-album-missing URI.
 */
URI.collectionMissingAlbumURI = function(username, id) {
  return new URI(URI.Type.COLLECTION_MISSING_ALBUM, {username: username, id: id});
};

/**
 * Creates a new 'collection-artist' type URI.
 *
 * @param {string} username The non-canonical username of the rootlist owner.
 * @param {string} id The id of the artist.
 * @return {URI} The collection-artist URI.
 */
URI.collectionArtistURI = function(username, id) {
  return new URI(URI.Type.COLLECTION_ARTIST, {username: username, id: id});
};

/**
 * Creates a new 'episode' type URI.
 *
 * @param {string} id The id of the episode.
 * @param {string} context An optional context URI
 * @param {boolean} play Toggles autoplay in the episode URI
 * @return {URI} The episode URI.
 */
URI.episodeURI = function(id, context, play) {
  return new URI(URI.Type.EPISODE, {
    id: id,
    context: context ? URI.fromString(context) : context,
    play: play
  });
};

/**
 * Creates a new 'show' type URI.
 *
 * @param {string} id The id of the show.
 * @return {URI} The show URI.
 */
URI.showURI = function(id) {
  return new URI(URI.Type.SHOW, {id: id});
};

/**
 * Creates a new 'concert' type URI.
 *
 * @param {string} id The id of the concert.
 * @return {URI} The concert URI.
 */
URI.concertURI = function(id) {
  return new URI(URI.Type.CONCERT, {id: id});
};

URI.isAlbum = function(uri) { return (URI.from(uri) || {}).type === URI.Type.ALBUM; };
URI.isAd = function(uri) { return (URI.from(uri) || {}).type === URI.Type.AD; };
URI.isApplication = function(uri) { return (URI.from(uri) || {}).type === URI.Type.APPLICATION; };
URI.isArtist = function(uri) { return (URI.from(uri) || {}).type === URI.Type.ARTIST; };
URI.isCollection = function(uri) { return (URI.from(uri) || {}).type === URI.Type.COLLECTION; };
URI.isCollectionAlbum = function(uri) { return (URI.from(uri) || {}).type === URI.Type.COLLECTION_ALBUM; };
URI.isCollectionArtist = function(uri) { return (URI.from(uri) || {}).type === URI.Type.COLLECTION_ARTIST; };
URI.isDailyMix = function(uri) { return (URI.from(uri) || {}).type === URI.Type.DAILY_MIX; };
URI.isEpisode = function(uri) { return (URI.from(uri) || {}).type === URI.Type.EPISODE; };
URI.isFacebook = function(uri) { return (URI.from(uri) || {}).type === URI.Type.FACEBOOK; };
URI.isFolder = function(uri) { return (URI.from(uri) || {}).type === URI.Type.FOLDER; };
URI.isLocalArtist = function(uri) { return (URI.from(uri) || {}).type === URI.Type.LOCAL_ARTIST; };
URI.isLocalAlbum = function(uri) { return (URI.from(uri) || {}).type === URI.Type.LOCAL_ALBUM; };
URI.isLocalTrack = function(uri) { return (URI.from(uri) || {}).type === URI.Type.LOCAL; };
URI.isMosaic = function(uri) { return (URI.from(uri) || {}).type === URI.Type.MOSAIC; };
URI.isPlaylistV1 = function(uri) { return (URI.from(uri) || {}).type === URI.Type.PLAYLIST; };
URI.isPlaylistV2 = function(uri) { return (URI.from(uri) || {}).type === URI.Type.PLAYLIST_V2; };
URI.isRadio = function(uri) { return (URI.from(uri) || {}).type === URI.Type.RADIO; };
URI.isRootlist = function(uri) { return (URI.from(uri) || {}).type === URI.Type.ROOTLIST; };
URI.isSearch = function(uri) { return (URI.from(uri) || {}).type === URI.Type.SEARCH; };
URI.isShow = function(uri) { return (URI.from(uri) || {}).type === URI.Type.SHOW; };
URI.isConcert = function(uri) { return (URI.from(uri) || {}).type === URI.Type.CONCERT; };
URI.isStation = function(uri) { return (URI.from(uri) || {}).type === URI.Type.STATION; };
URI.isTrack = function(uri) { return (URI.from(uri) || {}).type === URI.Type.TRACK; };
URI.isProfile = function(uri) { return (URI.from(uri) || {}).type === URI.Type.PROFILE; };
URI.isPlaylistV1OrV2 = function(uri) {
  var uriObject = URI.from(uri);
  return !!uriObject && (uriObject.type === URI.Type.PLAYLIST || uriObject.type === URI.Type.PLAYLIST_V2);
};

/**
 * Export public interface
 */
module.exports = URI;

},{"./base62":449}],451:[function(require,module,exports){
//     Underscore.js 1.8.3
//     http://underscorejs.org
//     (c) 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
//     Underscore may be freely distributed under the MIT license.

(function() {

  // Baseline setup
  // --------------

  // Establish the root object, `window` in the browser, or `exports` on the server.
  var root = this;

  // Save the previous value of the `_` variable.
  var previousUnderscore = root._;

  // Save bytes in the minified (but not gzipped) version:
  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;

  // Create quick reference variables for speed access to core prototypes.
  var
    push             = ArrayProto.push,
    slice            = ArrayProto.slice,
    toString         = ObjProto.toString,
    hasOwnProperty   = ObjProto.hasOwnProperty;

  // All **ECMAScript 5** native function implementations that we hope to use
  // are declared here.
  var
    nativeIsArray      = Array.isArray,
    nativeKeys         = Object.keys,
    nativeBind         = FuncProto.bind,
    nativeCreate       = Object.create;

  // Naked function reference for surrogate-prototype-swapping.
  var Ctor = function(){};

  // Create a safe reference to the Underscore object for use below.
  var _ = function(obj) {
    if (obj instanceof _) return obj;
    if (!(this instanceof _)) return new _(obj);
    this._wrapped = obj;
  };

  // Export the Underscore object for **Node.js**, with
  // backwards-compatibility for the old `require()` API. If we're in
  // the browser, add `_` as a global object.
  if (typeof exports !== 'undefined') {
    if (typeof module !== 'undefined' && module.exports) {
      exports = module.exports = _;
    }
    exports._ = _;
  } else {
    root._ = _;
  }

  // Current version.
  _.VERSION = '1.8.3';

  // Internal function that returns an efficient (for current engines) version
  // of the passed-in callback, to be repeatedly applied in other Underscore
  // functions.
  var optimizeCb = function(func, context, argCount) {
    if (context === void 0) return func;
    switch (argCount == null ? 3 : argCount) {
      case 1: return function(value) {
        return func.call(context, value);
      };
      case 2: return function(value, other) {
        return func.call(context, value, other);
      };
      case 3: return function(value, index, collection) {
        return func.call(context, value, index, collection);
      };
      case 4: return function(accumulator, value, index, collection) {
        return func.call(context, accumulator, value, index, collection);
      };
    }
    return function() {
      return func.apply(context, arguments);
    };
  };

  // A mostly-internal function to generate callbacks that can be applied
  // to each element in a collection, returning the desired result — either
  // identity, an arbitrary callback, a property matcher, or a property accessor.
  var cb = function(value, context, argCount) {
    if (value == null) return _.identity;
    if (_.isFunction(value)) return optimizeCb(value, context, argCount);
    if (_.isObject(value)) return _.matcher(value);
    return _.property(value);
  };
  _.iteratee = function(value, context) {
    return cb(value, context, Infinity);
  };

  // An internal function for creating assigner functions.
  var createAssigner = function(keysFunc, undefinedOnly) {
    return function(obj) {
      var length = arguments.length;
      if (length < 2 || obj == null) return obj;
      for (var index = 1; index < length; index++) {
        var source = arguments[index],
            keys = keysFunc(source),
            l = keys.length;
        for (var i = 0; i < l; i++) {
          var key = keys[i];
          if (!undefinedOnly || obj[key] === void 0) obj[key] = source[key];
        }
      }
      return obj;
    };
  };

  // An internal function for creating a new object that inherits from another.
  var baseCreate = function(prototype) {
    if (!_.isObject(prototype)) return {};
    if (nativeCreate) return nativeCreate(prototype);
    Ctor.prototype = prototype;
    var result = new Ctor;
    Ctor.prototype = null;
    return result;
  };

  var property = function(key) {
    return function(obj) {
      return obj == null ? void 0 : obj[key];
    };
  };

  // Helper for collection methods to determine whether a collection
  // should be iterated as an array or as an object
  // Related: http://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength
  // Avoids a very nasty iOS 8 JIT bug on ARM-64. #2094
  var MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;
  var getLength = property('length');
  var isArrayLike = function(collection) {
    var length = getLength(collection);
    return typeof length == 'number' && length >= 0 && length <= MAX_ARRAY_INDEX;
  };

  // Collection Functions
  // --------------------

  // The cornerstone, an `each` implementation, aka `forEach`.
  // Handles raw objects in addition to array-likes. Treats all
  // sparse array-likes as if they were dense.
  _.each = _.forEach = function(obj, iteratee, context) {
    iteratee = optimizeCb(iteratee, context);
    var i, length;
    if (isArrayLike(obj)) {
      for (i = 0, length = obj.length; i < length; i++) {
        iteratee(obj[i], i, obj);
      }
    } else {
      var keys = _.keys(obj);
      for (i = 0, length = keys.length; i < length; i++) {
        iteratee(obj[keys[i]], keys[i], obj);
      }
    }
    return obj;
  };

  // Return the results of applying the iteratee to each element.
  _.map = _.collect = function(obj, iteratee, context) {
    iteratee = cb(iteratee, context);
    var keys = !isArrayLike(obj) && _.keys(obj),
        length = (keys || obj).length,
        results = Array(length);
    for (var index = 0; index < length; index++) {
      var currentKey = keys ? keys[index] : index;
      results[index] = iteratee(obj[currentKey], currentKey, obj);
    }
    return results;
  };

  // Create a reducing function iterating left or right.
  function createReduce(dir) {
    // Optimized iterator function as using arguments.length
    // in the main function will deoptimize the, see #1991.
    function iterator(obj, iteratee, memo, keys, index, length) {
      for (; index >= 0 && index < length; index += dir) {
        var currentKey = keys ? keys[index] : index;
        memo = iteratee(memo, obj[currentKey], currentKey, obj);
      }
      return memo;
    }

    return function(obj, iteratee, memo, context) {
      iteratee = optimizeCb(iteratee, context, 4);
      var keys = !isArrayLike(obj) && _.keys(obj),
          length = (keys || obj).length,
          index = dir > 0 ? 0 : length - 1;
      // Determine the initial value if none is provided.
      if (arguments.length < 3) {
        memo = obj[keys ? keys[index] : index];
        index += dir;
      }
      return iterator(obj, iteratee, memo, keys, index, length);
    };
  }

  // **Reduce** builds up a single result from a list of values, aka `inject`,
  // or `foldl`.
  _.reduce = _.foldl = _.inject = createReduce(1);

  // The right-associative version of reduce, also known as `foldr`.
  _.reduceRight = _.foldr = createReduce(-1);

  // Return the first value which passes a truth test. Aliased as `detect`.
  _.find = _.detect = function(obj, predicate, context) {
    var key;
    if (isArrayLike(obj)) {
      key = _.findIndex(obj, predicate, context);
    } else {
      key = _.findKey(obj, predicate, context);
    }
    if (key !== void 0 && key !== -1) return obj[key];
  };

  // Return all the elements that pass a truth test.
  // Aliased as `select`.
  _.filter = _.select = function(obj, predicate, context) {
    var results = [];
    predicate = cb(predicate, context);
    _.each(obj, function(value, index, list) {
      if (predicate(value, index, list)) results.push(value);
    });
    return results;
  };

  // Return all the elements for which a truth test fails.
  _.reject = function(obj, predicate, context) {
    return _.filter(obj, _.negate(cb(predicate)), context);
  };

  // Determine whether all of the elements match a truth test.
  // Aliased as `all`.
  _.every = _.all = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var keys = !isArrayLike(obj) && _.keys(obj),
        length = (keys || obj).length;
    for (var index = 0; index < length; index++) {
      var currentKey = keys ? keys[index] : index;
      if (!predicate(obj[currentKey], currentKey, obj)) return false;
    }
    return true;
  };

  // Determine if at least one element in the object matches a truth test.
  // Aliased as `any`.
  _.some = _.any = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var keys = !isArrayLike(obj) && _.keys(obj),
        length = (keys || obj).length;
    for (var index = 0; index < length; index++) {
      var currentKey = keys ? keys[index] : index;
      if (predicate(obj[currentKey], currentKey, obj)) return true;
    }
    return false;
  };

  // Determine if the array or object contains a given item (using `===`).
  // Aliased as `includes` and `include`.
  _.contains = _.includes = _.include = function(obj, item, fromIndex, guard) {
    if (!isArrayLike(obj)) obj = _.values(obj);
    if (typeof fromIndex != 'number' || guard) fromIndex = 0;
    return _.indexOf(obj, item, fromIndex) >= 0;
  };

  // Invoke a method (with arguments) on every item in a collection.
  _.invoke = function(obj, method) {
    var args = slice.call(arguments, 2);
    var isFunc = _.isFunction(method);
    return _.map(obj, function(value) {
      var func = isFunc ? method : value[method];
      return func == null ? func : func.apply(value, args);
    });
  };

  // Convenience version of a common use case of `map`: fetching a property.
  _.pluck = function(obj, key) {
    return _.map(obj, _.property(key));
  };

  // Convenience version of a common use case of `filter`: selecting only objects
  // containing specific `key:value` pairs.
  _.where = function(obj, attrs) {
    return _.filter(obj, _.matcher(attrs));
  };

  // Convenience version of a common use case of `find`: getting the first object
  // containing specific `key:value` pairs.
  _.findWhere = function(obj, attrs) {
    return _.find(obj, _.matcher(attrs));
  };

  // Return the maximum element (or element-based computation).
  _.max = function(obj, iteratee, context) {
    var result = -Infinity, lastComputed = -Infinity,
        value, computed;
    if (iteratee == null && obj != null) {
      obj = isArrayLike(obj) ? obj : _.values(obj);
      for (var i = 0, length = obj.length; i < length; i++) {
        value = obj[i];
        if (value > result) {
          result = value;
        }
      }
    } else {
      iteratee = cb(iteratee, context);
      _.each(obj, function(value, index, list) {
        computed = iteratee(value, index, list);
        if (computed > lastComputed || computed === -Infinity && result === -Infinity) {
          result = value;
          lastComputed = computed;
        }
      });
    }
    return result;
  };

  // Return the minimum element (or element-based computation).
  _.min = function(obj, iteratee, context) {
    var result = Infinity, lastComputed = Infinity,
        value, computed;
    if (iteratee == null && obj != null) {
      obj = isArrayLike(obj) ? obj : _.values(obj);
      for (var i = 0, length = obj.length; i < length; i++) {
        value = obj[i];
        if (value < result) {
          result = value;
        }
      }
    } else {
      iteratee = cb(iteratee, context);
      _.each(obj, function(value, index, list) {
        computed = iteratee(value, index, list);
        if (computed < lastComputed || computed === Infinity && result === Infinity) {
          result = value;
          lastComputed = computed;
        }
      });
    }
    return result;
  };

  // Shuffle a collection, using the modern version of the
  // [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/Fisher–Yates_shuffle).
  _.shuffle = function(obj) {
    var set = isArrayLike(obj) ? obj : _.values(obj);
    var length = set.length;
    var shuffled = Array(length);
    for (var index = 0, rand; index < length; index++) {
      rand = _.random(0, index);
      if (rand !== index) shuffled[index] = shuffled[rand];
      shuffled[rand] = set[index];
    }
    return shuffled;
  };

  // Sample **n** random values from a collection.
  // If **n** is not specified, returns a single random element.
  // The internal `guard` argument allows it to work with `map`.
  _.sample = function(obj, n, guard) {
    if (n == null || guard) {
      if (!isArrayLike(obj)) obj = _.values(obj);
      return obj[_.random(obj.length - 1)];
    }
    return _.shuffle(obj).slice(0, Math.max(0, n));
  };

  // Sort the object's values by a criterion produced by an iteratee.
  _.sortBy = function(obj, iteratee, context) {
    iteratee = cb(iteratee, context);
    return _.pluck(_.map(obj, function(value, index, list) {
      return {
        value: value,
        index: index,
        criteria: iteratee(value, index, list)
      };
    }).sort(function(left, right) {
      var a = left.criteria;
      var b = right.criteria;
      if (a !== b) {
        if (a > b || a === void 0) return 1;
        if (a < b || b === void 0) return -1;
      }
      return left.index - right.index;
    }), 'value');
  };

  // An internal function used for aggregate "group by" operations.
  var group = function(behavior) {
    return function(obj, iteratee, context) {
      var result = {};
      iteratee = cb(iteratee, context);
      _.each(obj, function(value, index) {
        var key = iteratee(value, index, obj);
        behavior(result, value, key);
      });
      return result;
    };
  };

  // Groups the object's values by a criterion. Pass either a string attribute
  // to group by, or a function that returns the criterion.
  _.groupBy = group(function(result, value, key) {
    if (_.has(result, key)) result[key].push(value); else result[key] = [value];
  });

  // Indexes the object's values by a criterion, similar to `groupBy`, but for
  // when you know that your index values will be unique.
  _.indexBy = group(function(result, value, key) {
    result[key] = value;
  });

  // Counts instances of an object that group by a certain criterion. Pass
  // either a string attribute to count by, or a function that returns the
  // criterion.
  _.countBy = group(function(result, value, key) {
    if (_.has(result, key)) result[key]++; else result[key] = 1;
  });

  // Safely create a real, live array from anything iterable.
  _.toArray = function(obj) {
    if (!obj) return [];
    if (_.isArray(obj)) return slice.call(obj);
    if (isArrayLike(obj)) return _.map(obj, _.identity);
    return _.values(obj);
  };

  // Return the number of elements in an object.
  _.size = function(obj) {
    if (obj == null) return 0;
    return isArrayLike(obj) ? obj.length : _.keys(obj).length;
  };

  // Split a collection into two arrays: one whose elements all satisfy the given
  // predicate, and one whose elements all do not satisfy the predicate.
  _.partition = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var pass = [], fail = [];
    _.each(obj, function(value, key, obj) {
      (predicate(value, key, obj) ? pass : fail).push(value);
    });
    return [pass, fail];
  };

  // Array Functions
  // ---------------

  // Get the first element of an array. Passing **n** will return the first N
  // values in the array. Aliased as `head` and `take`. The **guard** check
  // allows it to work with `_.map`.
  _.first = _.head = _.take = function(array, n, guard) {
    if (array == null) return void 0;
    if (n == null || guard) return array[0];
    return _.initial(array, array.length - n);
  };

  // Returns everything but the last entry of the array. Especially useful on
  // the arguments object. Passing **n** will return all the values in
  // the array, excluding the last N.
  _.initial = function(array, n, guard) {
    return slice.call(array, 0, Math.max(0, array.length - (n == null || guard ? 1 : n)));
  };

  // Get the last element of an array. Passing **n** will return the last N
  // values in the array.
  _.last = function(array, n, guard) {
    if (array == null) return void 0;
    if (n == null || guard) return array[array.length - 1];
    return _.rest(array, Math.max(0, array.length - n));
  };

  // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.
  // Especially useful on the arguments object. Passing an **n** will return
  // the rest N values in the array.
  _.rest = _.tail = _.drop = function(array, n, guard) {
    return slice.call(array, n == null || guard ? 1 : n);
  };

  // Trim out all falsy values from an array.
  _.compact = function(array) {
    return _.filter(array, _.identity);
  };

  // Internal implementation of a recursive `flatten` function.
  var flatten = function(input, shallow, strict, startIndex) {
    var output = [], idx = 0;
    for (var i = startIndex || 0, length = getLength(input); i < length; i++) {
      var value = input[i];
      if (isArrayLike(value) && (_.isArray(value) || _.isArguments(value))) {
        //flatten current level of array or arguments object
        if (!shallow) value = flatten(value, shallow, strict);
        var j = 0, len = value.length;
        output.length += len;
        while (j < len) {
          output[idx++] = value[j++];
        }
      } else if (!strict) {
        output[idx++] = value;
      }
    }
    return output;
  };

  // Flatten out an array, either recursively (by default), or just one level.
  _.flatten = function(array, shallow) {
    return flatten(array, shallow, false);
  };

  // Return a version of the array that does not contain the specified value(s).
  _.without = function(array) {
    return _.difference(array, slice.call(arguments, 1));
  };

  // Produce a duplicate-free version of the array. If the array has already
  // been sorted, you have the option of using a faster algorithm.
  // Aliased as `unique`.
  _.uniq = _.unique = function(array, isSorted, iteratee, context) {
    if (!_.isBoolean(isSorted)) {
      context = iteratee;
      iteratee = isSorted;
      isSorted = false;
    }
    if (iteratee != null) iteratee = cb(iteratee, context);
    var result = [];
    var seen = [];
    for (var i = 0, length = getLength(array); i < length; i++) {
      var value = array[i],
          computed = iteratee ? iteratee(value, i, array) : value;
      if (isSorted) {
        if (!i || seen !== computed) result.push(value);
        seen = computed;
      } else if (iteratee) {
        if (!_.contains(seen, computed)) {
          seen.push(computed);
          result.push(value);
        }
      } else if (!_.contains(result, value)) {
        result.push(value);
      }
    }
    return result;
  };

  // Produce an array that contains the union: each distinct element from all of
  // the passed-in arrays.
  _.union = function() {
    return _.uniq(flatten(arguments, true, true));
  };

  // Produce an array that contains every item shared between all the
  // passed-in arrays.
  _.intersection = function(array) {
    var result = [];
    var argsLength = arguments.length;
    for (var i = 0, length = getLength(array); i < length; i++) {
      var item = array[i];
      if (_.contains(result, item)) continue;
      for (var j = 1; j < argsLength; j++) {
        if (!_.contains(arguments[j], item)) break;
      }
      if (j === argsLength) result.push(item);
    }
    return result;
  };

  // Take the difference between one array and a number of other arrays.
  // Only the elements present in just the first array will remain.
  _.difference = function(array) {
    var rest = flatten(arguments, true, true, 1);
    return _.filter(array, function(value){
      return !_.contains(rest, value);
    });
  };

  // Zip together multiple lists into a single array -- elements that share
  // an index go together.
  _.zip = function() {
    return _.unzip(arguments);
  };

  // Complement of _.zip. Unzip accepts an array of arrays and groups
  // each array's elements on shared indices
  _.unzip = function(array) {
    var length = array && _.max(array, getLength).length || 0;
    var result = Array(length);

    for (var index = 0; index < length; index++) {
      result[index] = _.pluck(array, index);
    }
    return result;
  };

  // Converts lists into objects. Pass either a single array of `[key, value]`
  // pairs, or two parallel arrays of the same length -- one of keys, and one of
  // the corresponding values.
  _.object = function(list, values) {
    var result = {};
    for (var i = 0, length = getLength(list); i < length; i++) {
      if (values) {
        result[list[i]] = values[i];
      } else {
        result[list[i][0]] = list[i][1];
      }
    }
    return result;
  };

  // Generator function to create the findIndex and findLastIndex functions
  function createPredicateIndexFinder(dir) {
    return function(array, predicate, context) {
      predicate = cb(predicate, context);
      var length = getLength(array);
      var index = dir > 0 ? 0 : length - 1;
      for (; index >= 0 && index < length; index += dir) {
        if (predicate(array[index], index, array)) return index;
      }
      return -1;
    };
  }

  // Returns the first index on an array-like that passes a predicate test
  _.findIndex = createPredicateIndexFinder(1);
  _.findLastIndex = createPredicateIndexFinder(-1);

  // Use a comparator function to figure out the smallest index at which
  // an object should be inserted so as to maintain order. Uses binary search.
  _.sortedIndex = function(array, obj, iteratee, context) {
    iteratee = cb(iteratee, context, 1);
    var value = iteratee(obj);
    var low = 0, high = getLength(array);
    while (low < high) {
      var mid = Math.floor((low + high) / 2);
      if (iteratee(array[mid]) < value) low = mid + 1; else high = mid;
    }
    return low;
  };

  // Generator function to create the indexOf and lastIndexOf functions
  function createIndexFinder(dir, predicateFind, sortedIndex) {
    return function(array, item, idx) {
      var i = 0, length = getLength(array);
      if (typeof idx == 'number') {
        if (dir > 0) {
            i = idx >= 0 ? idx : Math.max(idx + length, i);
        } else {
            length = idx >= 0 ? Math.min(idx + 1, length) : idx + length + 1;
        }
      } else if (sortedIndex && idx && length) {
        idx = sortedIndex(array, item);
        return array[idx] === item ? idx : -1;
      }
      if (item !== item) {
        idx = predicateFind(slice.call(array, i, length), _.isNaN);
        return idx >= 0 ? idx + i : -1;
      }
      for (idx = dir > 0 ? i : length - 1; idx >= 0 && idx < length; idx += dir) {
        if (array[idx] === item) return idx;
      }
      return -1;
    };
  }

  // Return the position of the first occurrence of an item in an array,
  // or -1 if the item is not included in the array.
  // If the array is large and already in sort order, pass `true`
  // for **isSorted** to use binary search.
  _.indexOf = createIndexFinder(1, _.findIndex, _.sortedIndex);
  _.lastIndexOf = createIndexFinder(-1, _.findLastIndex);

  // Generate an integer Array containing an arithmetic progression. A port of
  // the native Python `range()` function. See
  // [the Python documentation](http://docs.python.org/library/functions.html#range).
  _.range = function(start, stop, step) {
    if (stop == null) {
      stop = start || 0;
      start = 0;
    }
    step = step || 1;

    var length = Math.max(Math.ceil((stop - start) / step), 0);
    var range = Array(length);

    for (var idx = 0; idx < length; idx++, start += step) {
      range[idx] = start;
    }

    return range;
  };

  // Function (ahem) Functions
  // ------------------

  // Determines whether to execute a function as a constructor
  // or a normal function with the provided arguments
  var executeBound = function(sourceFunc, boundFunc, context, callingContext, args) {
    if (!(callingContext instanceof boundFunc)) return sourceFunc.apply(context, args);
    var self = baseCreate(sourceFunc.prototype);
    var result = sourceFunc.apply(self, args);
    if (_.isObject(result)) return result;
    return self;
  };

  // Create a function bound to a given object (assigning `this`, and arguments,
  // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if
  // available.
  _.bind = function(func, context) {
    if (nativeBind && func.bind === nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));
    if (!_.isFunction(func)) throw new TypeError('Bind must be called on a function');
    var args = slice.call(arguments, 2);
    var bound = function() {
      return executeBound(func, bound, context, this, args.concat(slice.call(arguments)));
    };
    return bound;
  };

  // Partially apply a function by creating a version that has had some of its
  // arguments pre-filled, without changing its dynamic `this` context. _ acts
  // as a placeholder, allowing any combination of arguments to be pre-filled.
  _.partial = function(func) {
    var boundArgs = slice.call(arguments, 1);
    var bound = function() {
      var position = 0, length = boundArgs.length;
      var args = Array(length);
      for (var i = 0; i < length; i++) {
        args[i] = boundArgs[i] === _ ? arguments[position++] : boundArgs[i];
      }
      while (position < arguments.length) args.push(arguments[position++]);
      return executeBound(func, bound, this, this, args);
    };
    return bound;
  };

  // Bind a number of an object's methods to that object. Remaining arguments
  // are the method names to be bound. Useful for ensuring that all callbacks
  // defined on an object belong to it.
  _.bindAll = function(obj) {
    var i, length = arguments.length, key;
    if (length <= 1) throw new Error('bindAll must be passed function names');
    for (i = 1; i < length; i++) {
      key = arguments[i];
      obj[key] = _.bind(obj[key], obj);
    }
    return obj;
  };

  // Memoize an expensive function by storing its results.
  _.memoize = function(func, hasher) {
    var memoize = function(key) {
      var cache = memoize.cache;
      var address = '' + (hasher ? hasher.apply(this, arguments) : key);
      if (!_.has(cache, address)) cache[address] = func.apply(this, arguments);
      return cache[address];
    };
    memoize.cache = {};
    return memoize;
  };

  // Delays a function for the given number of milliseconds, and then calls
  // it with the arguments supplied.
  _.delay = function(func, wait) {
    var args = slice.call(arguments, 2);
    return setTimeout(function(){
      return func.apply(null, args);
    }, wait);
  };

  // Defers a function, scheduling it to run after the current call stack has
  // cleared.
  _.defer = _.partial(_.delay, _, 1);

  // Returns a function, that, when invoked, will only be triggered at most once
  // during a given window of time. Normally, the throttled function will run
  // as much as it can, without ever going more than once per `wait` duration;
  // but if you'd like to disable the execution on the leading edge, pass
  // `{leading: false}`. To disable execution on the trailing edge, ditto.
  _.throttle = function(func, wait, options) {
    var context, args, result;
    var timeout = null;
    var previous = 0;
    if (!options) options = {};
    var later = function() {
      previous = options.leading === false ? 0 : _.now();
      timeout = null;
      result = func.apply(context, args);
      if (!timeout) context = args = null;
    };
    return function() {
      var now = _.now();
      if (!previous && options.leading === false) previous = now;
      var remaining = wait - (now - previous);
      context = this;
      args = arguments;
      if (remaining <= 0 || remaining > wait) {
        if (timeout) {
          clearTimeout(timeout);
          timeout = null;
        }
        previous = now;
        result = func.apply(context, args);
        if (!timeout) context = args = null;
      } else if (!timeout && options.trailing !== false) {
        timeout = setTimeout(later, remaining);
      }
      return result;
    };
  };

  // Returns a function, that, as long as it continues to be invoked, will not
  // be triggered. The function will be called after it stops being called for
  // N milliseconds. If `immediate` is passed, trigger the function on the
  // leading edge, instead of the trailing.
  _.debounce = function(func, wait, immediate) {
    var timeout, args, context, timestamp, result;

    var later = function() {
      var last = _.now() - timestamp;

      if (last < wait && last >= 0) {
        timeout = setTimeout(later, wait - last);
      } else {
        timeout = null;
        if (!immediate) {
          result = func.apply(context, args);
          if (!timeout) context = args = null;
        }
      }
    };

    return function() {
      context = this;
      args = arguments;
      timestamp = _.now();
      var callNow = immediate && !timeout;
      if (!timeout) timeout = setTimeout(later, wait);
      if (callNow) {
        result = func.apply(context, args);
        context = args = null;
      }

      return result;
    };
  };

  // Returns the first function passed as an argument to the second,
  // allowing you to adjust arguments, run code before and after, and
  // conditionally execute the original function.
  _.wrap = function(func, wrapper) {
    return _.partial(wrapper, func);
  };

  // Returns a negated version of the passed-in predicate.
  _.negate = function(predicate) {
    return function() {
      return !predicate.apply(this, arguments);
    };
  };

  // Returns a function that is the composition of a list of functions, each
  // consuming the return value of the function that follows.
  _.compose = function() {
    var args = arguments;
    var start = args.length - 1;
    return function() {
      var i = start;
      var result = args[start].apply(this, arguments);
      while (i--) result = args[i].call(this, result);
      return result;
    };
  };

  // Returns a function that will only be executed on and after the Nth call.
  _.after = function(times, func) {
    return function() {
      if (--times < 1) {
        return func.apply(this, arguments);
      }
    };
  };

  // Returns a function that will only be executed up to (but not including) the Nth call.
  _.before = function(times, func) {
    var memo;
    return function() {
      if (--times > 0) {
        memo = func.apply(this, arguments);
      }
      if (times <= 1) func = null;
      return memo;
    };
  };

  // Returns a function that will be executed at most one time, no matter how
  // often you call it. Useful for lazy initialization.
  _.once = _.partial(_.before, 2);

  // Object Functions
  // ----------------

  // Keys in IE < 9 that won't be iterated by `for key in ...` and thus missed.
  var hasEnumBug = !{toString: null}.propertyIsEnumerable('toString');
  var nonEnumerableProps = ['valueOf', 'isPrototypeOf', 'toString',
                      'propertyIsEnumerable', 'hasOwnProperty', 'toLocaleString'];

  function collectNonEnumProps(obj, keys) {
    var nonEnumIdx = nonEnumerableProps.length;
    var constructor = obj.constructor;
    var proto = (_.isFunction(constructor) && constructor.prototype) || ObjProto;

    // Constructor is a special case.
    var prop = 'constructor';
    if (_.has(obj, prop) && !_.contains(keys, prop)) keys.push(prop);

    while (nonEnumIdx--) {
      prop = nonEnumerableProps[nonEnumIdx];
      if (prop in obj && obj[prop] !== proto[prop] && !_.contains(keys, prop)) {
        keys.push(prop);
      }
    }
  }

  // Retrieve the names of an object's own properties.
  // Delegates to **ECMAScript 5**'s native `Object.keys`
  _.keys = function(obj) {
    if (!_.isObject(obj)) return [];
    if (nativeKeys) return nativeKeys(obj);
    var keys = [];
    for (var key in obj) if (_.has(obj, key)) keys.push(key);
    // Ahem, IE < 9.
    if (hasEnumBug) collectNonEnumProps(obj, keys);
    return keys;
  };

  // Retrieve all the property names of an object.
  _.allKeys = function(obj) {
    if (!_.isObject(obj)) return [];
    var keys = [];
    for (var key in obj) keys.push(key);
    // Ahem, IE < 9.
    if (hasEnumBug) collectNonEnumProps(obj, keys);
    return keys;
  };

  // Retrieve the values of an object's properties.
  _.values = function(obj) {
    var keys = _.keys(obj);
    var length = keys.length;
    var values = Array(length);
    for (var i = 0; i < length; i++) {
      values[i] = obj[keys[i]];
    }
    return values;
  };

  // Returns the results of applying the iteratee to each element of the object
  // In contrast to _.map it returns an object
  _.mapObject = function(obj, iteratee, context) {
    iteratee = cb(iteratee, context);
    var keys =  _.keys(obj),
          length = keys.length,
          results = {},
          currentKey;
      for (var index = 0; index < length; index++) {
        currentKey = keys[index];
        results[currentKey] = iteratee(obj[currentKey], currentKey, obj);
      }
      return results;
  };

  // Convert an object into a list of `[key, value]` pairs.
  _.pairs = function(obj) {
    var keys = _.keys(obj);
    var length = keys.length;
    var pairs = Array(length);
    for (var i = 0; i < length; i++) {
      pairs[i] = [keys[i], obj[keys[i]]];
    }
    return pairs;
  };

  // Invert the keys and values of an object. The values must be serializable.
  _.invert = function(obj) {
    var result = {};
    var keys = _.keys(obj);
    for (var i = 0, length = keys.length; i < length; i++) {
      result[obj[keys[i]]] = keys[i];
    }
    return result;
  };

  // Return a sorted list of the function names available on the object.
  // Aliased as `methods`
  _.functions = _.methods = function(obj) {
    var names = [];
    for (var key in obj) {
      if (_.isFunction(obj[key])) names.push(key);
    }
    return names.sort();
  };

  // Extend a given object with all the properties in passed-in object(s).
  _.extend = createAssigner(_.allKeys);

  // Assigns a given object with all the own properties in the passed-in object(s)
  // (https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/assign)
  _.extendOwn = _.assign = createAssigner(_.keys);

  // Returns the first key on an object that passes a predicate test
  _.findKey = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var keys = _.keys(obj), key;
    for (var i = 0, length = keys.length; i < length; i++) {
      key = keys[i];
      if (predicate(obj[key], key, obj)) return key;
    }
  };

  // Return a copy of the object only containing the whitelisted properties.
  _.pick = function(object, oiteratee, context) {
    var result = {}, obj = object, iteratee, keys;
    if (obj == null) return result;
    if (_.isFunction(oiteratee)) {
      keys = _.allKeys(obj);
      iteratee = optimizeCb(oiteratee, context);
    } else {
      keys = flatten(arguments, false, false, 1);
      iteratee = function(value, key, obj) { return key in obj; };
      obj = Object(obj);
    }
    for (var i = 0, length = keys.length; i < length; i++) {
      var key = keys[i];
      var value = obj[key];
      if (iteratee(value, key, obj)) result[key] = value;
    }
    return result;
  };

   // Return a copy of the object without the blacklisted properties.
  _.omit = function(obj, iteratee, context) {
    if (_.isFunction(iteratee)) {
      iteratee = _.negate(iteratee);
    } else {
      var keys = _.map(flatten(arguments, false, false, 1), String);
      iteratee = function(value, key) {
        return !_.contains(keys, key);
      };
    }
    return _.pick(obj, iteratee, context);
  };

  // Fill in a given object with default properties.
  _.defaults = createAssigner(_.allKeys, true);

  // Creates an object that inherits from the given prototype object.
  // If additional properties are provided then they will be added to the
  // created object.
  _.create = function(prototype, props) {
    var result = baseCreate(prototype);
    if (props) _.extendOwn(result, props);
    return result;
  };

  // Create a (shallow-cloned) duplicate of an object.
  _.clone = function(obj) {
    if (!_.isObject(obj)) return obj;
    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);
  };

  // Invokes interceptor with the obj, and then returns obj.
  // The primary purpose of this method is to "tap into" a method chain, in
  // order to perform operations on intermediate results within the chain.
  _.tap = function(obj, interceptor) {
    interceptor(obj);
    return obj;
  };

  // Returns whether an object has a given set of `key:value` pairs.
  _.isMatch = function(object, attrs) {
    var keys = _.keys(attrs), length = keys.length;
    if (object == null) return !length;
    var obj = Object(object);
    for (var i = 0; i < length; i++) {
      var key = keys[i];
      if (attrs[key] !== obj[key] || !(key in obj)) return false;
    }
    return true;
  };


  // Internal recursive comparison function for `isEqual`.
  var eq = function(a, b, aStack, bStack) {
    // Identical objects are equal. `0 === -0`, but they aren't identical.
    // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).
    if (a === b) return a !== 0 || 1 / a === 1 / b;
    // A strict comparison is necessary because `null == undefined`.
    if (a == null || b == null) return a === b;
    // Unwrap any wrapped objects.
    if (a instanceof _) a = a._wrapped;
    if (b instanceof _) b = b._wrapped;
    // Compare `[[Class]]` names.
    var className = toString.call(a);
    if (className !== toString.call(b)) return false;
    switch (className) {
      // Strings, numbers, regular expressions, dates, and booleans are compared by value.
      case '[object RegExp]':
      // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')
      case '[object String]':
        // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
        // equivalent to `new String("5")`.
        return '' + a === '' + b;
      case '[object Number]':
        // `NaN`s are equivalent, but non-reflexive.
        // Object(NaN) is equivalent to NaN
        if (+a !== +a) return +b !== +b;
        // An `egal` comparison is performed for other numeric values.
        return +a === 0 ? 1 / +a === 1 / b : +a === +b;
      case '[object Date]':
      case '[object Boolean]':
        // Coerce dates and booleans to numeric primitive values. Dates are compared by their
        // millisecond representations. Note that invalid dates with millisecond representations
        // of `NaN` are not equivalent.
        return +a === +b;
    }

    var areArrays = className === '[object Array]';
    if (!areArrays) {
      if (typeof a != 'object' || typeof b != 'object') return false;

      // Objects with different constructors are not equivalent, but `Object`s or `Array`s
      // from different frames are.
      var aCtor = a.constructor, bCtor = b.constructor;
      if (aCtor !== bCtor && !(_.isFunction(aCtor) && aCtor instanceof aCtor &&
                               _.isFunction(bCtor) && bCtor instanceof bCtor)
                          && ('constructor' in a && 'constructor' in b)) {
        return false;
      }
    }
    // Assume equality for cyclic structures. The algorithm for detecting cyclic
    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.

    // Initializing stack of traversed objects.
    // It's done here since we only need them for objects and arrays comparison.
    aStack = aStack || [];
    bStack = bStack || [];
    var length = aStack.length;
    while (length--) {
      // Linear search. Performance is inversely proportional to the number of
      // unique nested structures.
      if (aStack[length] === a) return bStack[length] === b;
    }

    // Add the first object to the stack of traversed objects.
    aStack.push(a);
    bStack.push(b);

    // Recursively compare objects and arrays.
    if (areArrays) {
      // Compare array lengths to determine if a deep comparison is necessary.
      length = a.length;
      if (length !== b.length) return false;
      // Deep compare the contents, ignoring non-numeric properties.
      while (length--) {
        if (!eq(a[length], b[length], aStack, bStack)) return false;
      }
    } else {
      // Deep compare objects.
      var keys = _.keys(a), key;
      length = keys.length;
      // Ensure that both objects contain the same number of properties before comparing deep equality.
      if (_.keys(b).length !== length) return false;
      while (length--) {
        // Deep compare each member
        key = keys[length];
        if (!(_.has(b, key) && eq(a[key], b[key], aStack, bStack))) return false;
      }
    }
    // Remove the first object from the stack of traversed objects.
    aStack.pop();
    bStack.pop();
    return true;
  };

  // Perform a deep comparison to check if two objects are equal.
  _.isEqual = function(a, b) {
    return eq(a, b);
  };

  // Is a given array, string, or object empty?
  // An "empty" object has no enumerable own-properties.
  _.isEmpty = function(obj) {
    if (obj == null) return true;
    if (isArrayLike(obj) && (_.isArray(obj) || _.isString(obj) || _.isArguments(obj))) return obj.length === 0;
    return _.keys(obj).length === 0;
  };

  // Is a given value a DOM element?
  _.isElement = function(obj) {
    return !!(obj && obj.nodeType === 1);
  };

  // Is a given value an array?
  // Delegates to ECMA5's native Array.isArray
  _.isArray = nativeIsArray || function(obj) {
    return toString.call(obj) === '[object Array]';
  };

  // Is a given variable an object?
  _.isObject = function(obj) {
    var type = typeof obj;
    return type === 'function' || type === 'object' && !!obj;
  };

  // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp, isError.
  _.each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp', 'Error'], function(name) {
    _['is' + name] = function(obj) {
      return toString.call(obj) === '[object ' + name + ']';
    };
  });

  // Define a fallback version of the method in browsers (ahem, IE < 9), where
  // there isn't any inspectable "Arguments" type.
  if (!_.isArguments(arguments)) {
    _.isArguments = function(obj) {
      return _.has(obj, 'callee');
    };
  }

  // Optimize `isFunction` if appropriate. Work around some typeof bugs in old v8,
  // IE 11 (#1621), and in Safari 8 (#1929).
  if (typeof /./ != 'function' && typeof Int8Array != 'object') {
    _.isFunction = function(obj) {
      return typeof obj == 'function' || false;
    };
  }

  // Is a given object a finite number?
  _.isFinite = function(obj) {
    return isFinite(obj) && !isNaN(parseFloat(obj));
  };

  // Is the given value `NaN`? (NaN is the only number which does not equal itself).
  _.isNaN = function(obj) {
    return _.isNumber(obj) && obj !== +obj;
  };

  // Is a given value a boolean?
  _.isBoolean = function(obj) {
    return obj === true || obj === false || toString.call(obj) === '[object Boolean]';
  };

  // Is a given value equal to null?
  _.isNull = function(obj) {
    return obj === null;
  };

  // Is a given variable undefined?
  _.isUndefined = function(obj) {
    return obj === void 0;
  };

  // Shortcut function for checking if an object has a given property directly
  // on itself (in other words, not on a prototype).
  _.has = function(obj, key) {
    return obj != null && hasOwnProperty.call(obj, key);
  };

  // Utility Functions
  // -----------------

  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its
  // previous owner. Returns a reference to the Underscore object.
  _.noConflict = function() {
    root._ = previousUnderscore;
    return this;
  };

  // Keep the identity function around for default iteratees.
  _.identity = function(value) {
    return value;
  };

  // Predicate-generating functions. Often useful outside of Underscore.
  _.constant = function(value) {
    return function() {
      return value;
    };
  };

  _.noop = function(){};

  _.property = property;

  // Generates a function for a given object that returns a given property.
  _.propertyOf = function(obj) {
    return obj == null ? function(){} : function(key) {
      return obj[key];
    };
  };

  // Returns a predicate for checking whether an object has a given set of
  // `key:value` pairs.
  _.matcher = _.matches = function(attrs) {
    attrs = _.extendOwn({}, attrs);
    return function(obj) {
      return _.isMatch(obj, attrs);
    };
  };

  // Run a function **n** times.
  _.times = function(n, iteratee, context) {
    var accum = Array(Math.max(0, n));
    iteratee = optimizeCb(iteratee, context, 1);
    for (var i = 0; i < n; i++) accum[i] = iteratee(i);
    return accum;
  };

  // Return a random integer between min and max (inclusive).
  _.random = function(min, max) {
    if (max == null) {
      max = min;
      min = 0;
    }
    return min + Math.floor(Math.random() * (max - min + 1));
  };

  // A (possibly faster) way to get the current timestamp as an integer.
  _.now = Date.now || function() {
    return new Date().getTime();
  };

   // List of HTML entities for escaping.
  var escapeMap = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#x27;',
    '`': '&#x60;'
  };
  var unescapeMap = _.invert(escapeMap);

  // Functions for escaping and unescaping strings to/from HTML interpolation.
  var createEscaper = function(map) {
    var escaper = function(match) {
      return map[match];
    };
    // Regexes for identifying a key that needs to be escaped
    var source = '(?:' + _.keys(map).join('|') + ')';
    var testRegexp = RegExp(source);
    var replaceRegexp = RegExp(source, 'g');
    return function(string) {
      string = string == null ? '' : '' + string;
      return testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string;
    };
  };
  _.escape = createEscaper(escapeMap);
  _.unescape = createEscaper(unescapeMap);

  // If the value of the named `property` is a function then invoke it with the
  // `object` as context; otherwise, return it.
  _.result = function(object, property, fallback) {
    var value = object == null ? void 0 : object[property];
    if (value === void 0) {
      value = fallback;
    }
    return _.isFunction(value) ? value.call(object) : value;
  };

  // Generate a unique integer id (unique within the entire client session).
  // Useful for temporary DOM ids.
  var idCounter = 0;
  _.uniqueId = function(prefix) {
    var id = ++idCounter + '';
    return prefix ? prefix + id : id;
  };

  // By default, Underscore uses ERB-style template delimiters, change the
  // following template settings to use alternative delimiters.
  _.templateSettings = {
    evaluate    : /<%([\s\S]+?)%>/g,
    interpolate : /<%=([\s\S]+?)%>/g,
    escape      : /<%-([\s\S]+?)%>/g
  };

  // When customizing `templateSettings`, if you don't want to define an
  // interpolation, evaluation or escaping regex, we need one that is
  // guaranteed not to match.
  var noMatch = /(.)^/;

  // Certain characters need to be escaped so that they can be put into a
  // string literal.
  var escapes = {
    "'":      "'",
    '\\':     '\\',
    '\r':     'r',
    '\n':     'n',
    '\u2028': 'u2028',
    '\u2029': 'u2029'
  };

  var escaper = /\\|'|\r|\n|\u2028|\u2029/g;

  var escapeChar = function(match) {
    return '\\' + escapes[match];
  };

  // JavaScript micro-templating, similar to John Resig's implementation.
  // Underscore templating handles arbitrary delimiters, preserves whitespace,
  // and correctly escapes quotes within interpolated code.
  // NB: `oldSettings` only exists for backwards compatibility.
  _.template = function(text, settings, oldSettings) {
    if (!settings && oldSettings) settings = oldSettings;
    settings = _.defaults({}, settings, _.templateSettings);

    // Combine delimiters into one regular expression via alternation.
    var matcher = RegExp([
      (settings.escape || noMatch).source,
      (settings.interpolate || noMatch).source,
      (settings.evaluate || noMatch).source
    ].join('|') + '|$', 'g');

    // Compile the template source, escaping string literals appropriately.
    var index = 0;
    var source = "__p+='";
    text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {
      source += text.slice(index, offset).replace(escaper, escapeChar);
      index = offset + match.length;

      if (escape) {
        source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
      } else if (interpolate) {
        source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
      } else if (evaluate) {
        source += "';\n" + evaluate + "\n__p+='";
      }

      // Adobe VMs need the match returned to produce the correct offest.
      return match;
    });
    source += "';\n";

    // If a variable is not specified, place data values in local scope.
    if (!settings.variable) source = 'with(obj||{}){\n' + source + '}\n';

    source = "var __t,__p='',__j=Array.prototype.join," +
      "print=function(){__p+=__j.call(arguments,'');};\n" +
      source + 'return __p;\n';

    try {
      var render = new Function(settings.variable || 'obj', '_', source);
    } catch (e) {
      e.source = source;
      throw e;
    }

    var template = function(data) {
      return render.call(this, data, _);
    };

    // Provide the compiled source as a convenience for precompilation.
    var argument = settings.variable || 'obj';
    template.source = 'function(' + argument + '){\n' + source + '}';

    return template;
  };

  // Add a "chain" function. Start chaining a wrapped Underscore object.
  _.chain = function(obj) {
    var instance = _(obj);
    instance._chain = true;
    return instance;
  };

  // OOP
  // ---------------
  // If Underscore is called as a function, it returns a wrapped object that
  // can be used OO-style. This wrapper holds altered versions of all the
  // underscore functions. Wrapped objects may be chained.

  // Helper function to continue chaining intermediate results.
  var result = function(instance, obj) {
    return instance._chain ? _(obj).chain() : obj;
  };

  // Add your own custom functions to the Underscore object.
  _.mixin = function(obj) {
    _.each(_.functions(obj), function(name) {
      var func = _[name] = obj[name];
      _.prototype[name] = function() {
        var args = [this._wrapped];
        push.apply(args, arguments);
        return result(this, func.apply(_, args));
      };
    });
  };

  // Add all of the Underscore functions to the wrapper object.
  _.mixin(_);

  // Add all mutator Array functions to the wrapper.
  _.each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {
    var method = ArrayProto[name];
    _.prototype[name] = function() {
      var obj = this._wrapped;
      method.apply(obj, arguments);
      if ((name === 'shift' || name === 'splice') && obj.length === 0) delete obj[0];
      return result(this, obj);
    };
  });

  // Add all accessor Array functions to the wrapper.
  _.each(['concat', 'join', 'slice'], function(name) {
    var method = ArrayProto[name];
    _.prototype[name] = function() {
      return result(this, method.apply(this._wrapped, arguments));
    };
  });

  // Extracts the result from a wrapped and chained object.
  _.prototype.value = function() {
    return this._wrapped;
  };

  // Provide unwrapping proxy for some methods used in engine operations
  // such as arithmetic and JSON stringification.
  _.prototype.valueOf = _.prototype.toJSON = _.prototype.value;

  _.prototype.toString = function() {
    return '' + this._wrapped;
  };

  // AMD registration happens at the end for compatibility with AMD loaders
  // that may not enforce next-turn semantics on modules. Even though general
  // practice for AMD registration is to be anonymous, underscore registers
  // as a named module because, like jQuery, it is a base library that is
  // popular enough to be bundled in a third party lib, but not be part of
  // an AMD load request. Those cases could generate an error when an
  // anonymous define() is called outside of a loader request.
  if (typeof define === 'function' && define.amd) {
    define('underscore', [], function() {
      return _;
    });
  }
}.call(this));

},{}],452:[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}

},{}],453:[function(require,module,exports){
module.exports = function isBuffer(arg) {
  return arg && typeof arg === 'object'
    && typeof arg.copy === 'function'
    && typeof arg.fill === 'function'
    && typeof arg.readUInt8 === 'function';
}
},{}],454:[function(require,module,exports){
(function (process,global){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};


// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function(fn, msg) {
  // Allow for deprecating things in the process of starting up.
  if (isUndefined(global.process)) {
    return function() {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  if (process.noDeprecation === true) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
};


var debugs = {};
var debugEnviron;
exports.debuglog = function(set) {
  if (isUndefined(debugEnviron))
    debugEnviron = process.env.NODE_DEBUG || '';
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
      var pid = process.pid;
      debugs[set] = function() {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function() {};
    }
  }
  return debugs[set];
};


/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value)
      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = require('./support/isBuffer');

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = require('inherits');

exports._extend = function(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./support/isBuffer":453,"_process":432,"inherits":452}],455:[function(require,module,exports){
/*
 * UUID-js: A js library to generate and parse UUIDs, TimeUUIDs and generate
 * TimeUUID based on dates for range selections.
 * @see http://www.ietf.org/rfc/rfc4122.txt
 **/

function UUIDjs() {
};

UUIDjs.maxFromBits = function(bits) {
  return Math.pow(2, bits);
};

UUIDjs.limitUI04 = UUIDjs.maxFromBits(4);
UUIDjs.limitUI06 = UUIDjs.maxFromBits(6);
UUIDjs.limitUI08 = UUIDjs.maxFromBits(8);
UUIDjs.limitUI12 = UUIDjs.maxFromBits(12);
UUIDjs.limitUI14 = UUIDjs.maxFromBits(14);
UUIDjs.limitUI16 = UUIDjs.maxFromBits(16);
UUIDjs.limitUI32 = UUIDjs.maxFromBits(32);
UUIDjs.limitUI40 = UUIDjs.maxFromBits(40);
UUIDjs.limitUI48 = UUIDjs.maxFromBits(48);

// Returns a random integer between min and max
// Using Math.round() will give you a non-uniform distribution!
// @see https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Math/random
function getRandomInt(min, max) {
  return Math.floor(Math.random() * (max - min + 1)) + min;
}

UUIDjs.randomUI04 = function() {
  return getRandomInt(0, UUIDjs.limitUI04-1);
};
UUIDjs.randomUI06 = function() {
  return getRandomInt(0, UUIDjs.limitUI06-1);
};
UUIDjs.randomUI08 = function() {
  return getRandomInt(0, UUIDjs.limitUI08-1);
};
UUIDjs.randomUI12 = function() {
  return getRandomInt(0, UUIDjs.limitUI12-1);
};
UUIDjs.randomUI14 = function() {
  return getRandomInt(0, UUIDjs.limitUI14-1);
};
UUIDjs.randomUI16 = function() {
  return getRandomInt(0, UUIDjs.limitUI16-1);
};
UUIDjs.randomUI32 = function() {
  return getRandomInt(0, UUIDjs.limitUI32-1);
};
UUIDjs.randomUI40 = function() {
  return (0 | Math.random() * (1 << 30)) + (0 | Math.random() * (1 << 40 - 30)) * (1 << 30);
};
UUIDjs.randomUI48 = function() {
  return (0 | Math.random() * (1 << 30)) + (0 | Math.random() * (1 << 48 - 30)) * (1 << 30);
};

UUIDjs.paddedString = function(string, length, z) {
  string = String(string);
  z = (!z) ? '0' : z;
  var i = length - string.length;
  for (; i > 0; i >>>= 1, z += z) {
    if (i & 1) {
      string = z + string;
    }
  }
  return string;
};

UUIDjs.prototype.fromParts = function(timeLow, timeMid, timeHiAndVersion, clockSeqHiAndReserved, clockSeqLow, node) {
  this.version = (timeHiAndVersion >> 12) & 0xF;
  this.hex = UUIDjs.paddedString(timeLow.toString(16), 8)
             + '-'
             + UUIDjs.paddedString(timeMid.toString(16), 4)
             + '-'
             + UUIDjs.paddedString(timeHiAndVersion.toString(16), 4)
             + '-'
             + UUIDjs.paddedString(clockSeqHiAndReserved.toString(16), 2)
             + UUIDjs.paddedString(clockSeqLow.toString(16), 2)
             + '-'
             + UUIDjs.paddedString(node.toString(16), 12);
  return this;
};

UUIDjs.prototype.toString = function() {
  return this.hex;
};
UUIDjs.prototype.toURN = function() {
  return 'urn:uuid:' + this.hex;
};

UUIDjs.prototype.toBytes = function() {
  var parts = this.hex.split('-');
  var ints = [];
  var intPos = 0;
  for (var i = 0; i < parts.length; i++) {
    for (var j = 0; j < parts[i].length; j+=2) {
      ints[intPos++] = parseInt(parts[i].substr(j, 2), 16);
    }
  }
  return ints;
};

UUIDjs.prototype.equals = function(uuid) {
  if (!(uuid instanceof UUID)) {
    return false;
  }
  if (this.hex !== uuid.hex) {
    return false;
  }
  return true;
};

UUIDjs.getTimeFieldValues = function(time) {
  var ts = time - Date.UTC(1582, 9, 15);
  var hm = ((ts / 0x100000000) * 10000) & 0xFFFFFFF;
  return { low: ((ts & 0xFFFFFFF) * 10000) % 0x100000000,
            mid: hm & 0xFFFF, hi: hm >>> 16, timestamp: ts };
};

UUIDjs._create4 = function() {
  return new UUIDjs().fromParts(
    UUIDjs.randomUI32(),
    UUIDjs.randomUI16(),
    0x4000 | UUIDjs.randomUI12(),
    0x80   | UUIDjs.randomUI06(),
    UUIDjs.randomUI08(),
    UUIDjs.randomUI48()
  );
};

UUIDjs._create1 = function() {
  var now = new Date().getTime();
  var sequence = UUIDjs.randomUI14();
  var node = (UUIDjs.randomUI08() | 1) * 0x10000000000 + UUIDjs.randomUI40();
  var tick = UUIDjs.randomUI04();
  var timestamp = 0;
  var timestampRatio = 1/4;

  if (now != timestamp) {
    if (now < timestamp) {
      sequence++;
    }
    timestamp = now;
    tick = UUIDjs.randomUI04();
  } else if (Math.random() < timestampRatio && tick < 9984) {
    tick += 1 + UUIDjs.randomUI04();
  } else {
    sequence++;
  }

  var tf = UUIDjs.getTimeFieldValues(timestamp);
  var tl = tf.low + tick;
  var thav = (tf.hi & 0xFFF) | 0x1000;

  sequence &= 0x3FFF;
  var cshar = (sequence >>> 8) | 0x80;
  var csl = sequence & 0xFF;

  return new UUIDjs().fromParts(tl, tf.mid, thav, cshar, csl, node);
};

UUIDjs.create = function(version) {
  version = version || 4;
  return this['_create' + version]();
};

UUIDjs.fromTime = function(time, last) {
  last = (!last) ? false : last;
  var tf = UUIDjs.getTimeFieldValues(time);
  var tl = tf.low;
  var thav = (tf.hi & 0xFFF) | 0x1000;  // set version '0001'
  if (last === false) {
    return new UUIDjs().fromParts(tl, tf.mid, thav, 0, 0, 0);
  } else {
    return new UUIDjs().fromParts(tl, tf.mid, thav, 0x80 | UUIDjs.limitUI06, UUIDjs.limitUI08 - 1, UUIDjs.limitUI48 - 1);
  }
};

UUIDjs.firstFromTime = function(time) {
  return UUIDjs.fromTime(time, false);
};
UUIDjs.lastFromTime = function(time) {
  return UUIDjs.fromTime(time, true);
};

UUIDjs.fromURN = function(strId) {
  var r, p = /^(?:urn:uuid:|\{)?([0-9a-f]{8})-([0-9a-f]{4})-([0-9a-f]{4})-([0-9a-f]{2})([0-9a-f]{2})-([0-9a-f]{12})(?:\})?$/i;
  if ((r = p.exec(strId))) {
    return new UUIDjs().fromParts(parseInt(r[1], 16), parseInt(r[2], 16),
                            parseInt(r[3], 16), parseInt(r[4], 16),
                            parseInt(r[5], 16), parseInt(r[6], 16));
  }
  return null;
};

UUIDjs.fromBytes = function(ints) {
  if (ints.length < 5) {
    return null;
  }
  var str = '';
  var pos = 0;
  var parts = [4, 2, 2, 2, 6];
  for (var i = 0; i < parts.length; i++) {
    for (var j = 0; j < parts[i]; j++) {
      var octet = ints[pos++].toString(16);
      if (octet.length == 1) {
        octet = '0' + octet;
      }
      str += octet;
    }
    if (parts[i] !== 6) {
      str += '-';
    }
  }
  return UUIDjs.fromURN(str);
};

UUIDjs.fromBinary = function(binary) {
  var ints = [];
  for (var i = 0; i < binary.length; i++) {
    ints[i] = binary.charCodeAt(i);
    if (ints[i] > 255 || ints[i] < 0) {
      throw new Error('Unexpected byte in binary data.');
    }
  }
  return UUIDjs.fromBytes(ints);
};

// Aliases to support legacy code. Do not use these when writing new code as
// they may be removed in future versions!
UUIDjs.new = function() {
  return this.create(4);
};
UUIDjs.newTS = function() {
  return this.create(1);
};

module.exports = UUIDjs;

},{}],456:[function(require,module,exports){
/** @license MIT License (c) copyright 2010-2014 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

(function(define) { 'use strict';
define(function (require) {

	var makePromise = require('./makePromise');
	var Scheduler = require('./Scheduler');
	var async = require('./env').asap;

	return makePromise({
		scheduler: new Scheduler(async)
	});

});
})(typeof define === 'function' && define.amd ? define : function (factory) { module.exports = factory(require); });

},{"./Scheduler":457,"./env":469,"./makePromise":472}],457:[function(require,module,exports){
/** @license MIT License (c) copyright 2010-2014 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

(function(define) { 'use strict';
define(function() {

	// Credit to Twisol (https://github.com/Twisol) for suggesting
	// this type of extensible queue + trampoline approach for next-tick conflation.

	/**
	 * Async task scheduler
	 * @param {function} async function to schedule a single async function
	 * @constructor
	 */
	function Scheduler(async) {
		this._async = async;
		this._running = false;

		this._queue = this;
		this._queueLen = 0;
		this._afterQueue = {};
		this._afterQueueLen = 0;

		var self = this;
		this.drain = function() {
			self._drain();
		};
	}

	/**
	 * Enqueue a task
	 * @param {{ run:function }} task
	 */
	Scheduler.prototype.enqueue = function(task) {
		this._queue[this._queueLen++] = task;
		this.run();
	};

	/**
	 * Enqueue a task to run after the main task queue
	 * @param {{ run:function }} task
	 */
	Scheduler.prototype.afterQueue = function(task) {
		this._afterQueue[this._afterQueueLen++] = task;
		this.run();
	};

	Scheduler.prototype.run = function() {
		if (!this._running) {
			this._running = true;
			this._async(this.drain);
		}
	};

	/**
	 * Drain the handler queue entirely, and then the after queue
	 */
	Scheduler.prototype._drain = function() {
		var i = 0;
		for (; i < this._queueLen; ++i) {
			this._queue[i].run();
			this._queue[i] = void 0;
		}

		this._queueLen = 0;
		this._running = false;

		for (i = 0; i < this._afterQueueLen; ++i) {
			this._afterQueue[i].run();
			this._afterQueue[i] = void 0;
		}

		this._afterQueueLen = 0;
	};

	return Scheduler;

});
}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(); }));

},{}],458:[function(require,module,exports){
/** @license MIT License (c) copyright 2010-2014 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

(function(define) { 'use strict';
define(function() {

	/**
	 * Custom error type for promises rejected by promise.timeout
	 * @param {string} message
	 * @constructor
	 */
	function TimeoutError (message) {
		Error.call(this);
		this.message = message;
		this.name = TimeoutError.name;
		if (typeof Error.captureStackTrace === 'function') {
			Error.captureStackTrace(this, TimeoutError);
		}
	}

	TimeoutError.prototype = Object.create(Error.prototype);
	TimeoutError.prototype.constructor = TimeoutError;

	return TimeoutError;
});
}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(); }));
},{}],459:[function(require,module,exports){
/** @license MIT License (c) copyright 2010-2014 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

(function(define) { 'use strict';
define(function() {

	makeApply.tryCatchResolve = tryCatchResolve;

	return makeApply;

	function makeApply(Promise, call) {
		if(arguments.length < 2) {
			call = tryCatchResolve;
		}

		return apply;

		function apply(f, thisArg, args) {
			var p = Promise._defer();
			var l = args.length;
			var params = new Array(l);
			callAndResolve({ f:f, thisArg:thisArg, args:args, params:params, i:l-1, call:call }, p._handler);

			return p;
		}

		function callAndResolve(c, h) {
			if(c.i < 0) {
				return call(c.f, c.thisArg, c.params, h);
			}

			var handler = Promise._handler(c.args[c.i]);
			handler.fold(callAndResolveNext, c, void 0, h);
		}

		function callAndResolveNext(c, x, h) {
			c.params[c.i] = x;
			c.i -= 1;
			callAndResolve(c, h);
		}
	}

	function tryCatchResolve(f, thisArg, args, resolver) {
		try {
			resolver.resolve(f.apply(thisArg, args));
		} catch(e) {
			resolver.reject(e);
		}
	}

});
}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(); }));



},{}],460:[function(require,module,exports){
/** @license MIT License (c) copyright 2010-2014 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

(function(define) { 'use strict';
define(function(require) {

	var state = require('../state');
	var applier = require('../apply');

	return function array(Promise) {

		var applyFold = applier(Promise);
		var toPromise = Promise.resolve;
		var all = Promise.all;

		var ar = Array.prototype.reduce;
		var arr = Array.prototype.reduceRight;
		var slice = Array.prototype.slice;

		// Additional array combinators

		Promise.any = any;
		Promise.some = some;
		Promise.settle = settle;

		Promise.map = map;
		Promise.filter = filter;
		Promise.reduce = reduce;
		Promise.reduceRight = reduceRight;

		/**
		 * When this promise fulfills with an array, do
		 * onFulfilled.apply(void 0, array)
		 * @param {function} onFulfilled function to apply
		 * @returns {Promise} promise for the result of applying onFulfilled
		 */
		Promise.prototype.spread = function(onFulfilled) {
			return this.then(all).then(function(array) {
				return onFulfilled.apply(this, array);
			});
		};

		return Promise;

		/**
		 * One-winner competitive race.
		 * Return a promise that will fulfill when one of the promises
		 * in the input array fulfills, or will reject when all promises
		 * have rejected.
		 * @param {array} promises
		 * @returns {Promise} promise for the first fulfilled value
		 */
		function any(promises) {
			var p = Promise._defer();
			var resolver = p._handler;
			var l = promises.length>>>0;

			var pending = l;
			var errors = [];

			for (var h, x, i = 0; i < l; ++i) {
				x = promises[i];
				if(x === void 0 && !(i in promises)) {
					--pending;
					continue;
				}

				h = Promise._handler(x);
				if(h.state() > 0) {
					resolver.become(h);
					Promise._visitRemaining(promises, i, h);
					break;
				} else {
					h.visit(resolver, handleFulfill, handleReject);
				}
			}

			if(pending === 0) {
				resolver.reject(new RangeError('any(): array must not be empty'));
			}

			return p;

			function handleFulfill(x) {
				/*jshint validthis:true*/
				errors = null;
				this.resolve(x); // this === resolver
			}

			function handleReject(e) {
				/*jshint validthis:true*/
				if(this.resolved) { // this === resolver
					return;
				}

				errors.push(e);
				if(--pending === 0) {
					this.reject(errors);
				}
			}
		}

		/**
		 * N-winner competitive race
		 * Return a promise that will fulfill when n input promises have
		 * fulfilled, or will reject when it becomes impossible for n
		 * input promises to fulfill (ie when promises.length - n + 1
		 * have rejected)
		 * @param {array} promises
		 * @param {number} n
		 * @returns {Promise} promise for the earliest n fulfillment values
		 *
		 * @deprecated
		 */
		function some(promises, n) {
			/*jshint maxcomplexity:7*/
			var p = Promise._defer();
			var resolver = p._handler;

			var results = [];
			var errors = [];

			var l = promises.length>>>0;
			var nFulfill = 0;
			var nReject;
			var x, i; // reused in both for() loops

			// First pass: count actual array items
			for(i=0; i<l; ++i) {
				x = promises[i];
				if(x === void 0 && !(i in promises)) {
					continue;
				}
				++nFulfill;
			}

			// Compute actual goals
			n = Math.max(n, 0);
			nReject = (nFulfill - n + 1);
			nFulfill = Math.min(n, nFulfill);

			if(n > nFulfill) {
				resolver.reject(new RangeError('some(): array must contain at least '
				+ n + ' item(s), but had ' + nFulfill));
			} else if(nFulfill === 0) {
				resolver.resolve(results);
			}

			// Second pass: observe each array item, make progress toward goals
			for(i=0; i<l; ++i) {
				x = promises[i];
				if(x === void 0 && !(i in promises)) {
					continue;
				}

				Promise._handler(x).visit(resolver, fulfill, reject, resolver.notify);
			}

			return p;

			function fulfill(x) {
				/*jshint validthis:true*/
				if(this.resolved) { // this === resolver
					return;
				}

				results.push(x);
				if(--nFulfill === 0) {
					errors = null;
					this.resolve(results);
				}
			}

			function reject(e) {
				/*jshint validthis:true*/
				if(this.resolved) { // this === resolver
					return;
				}

				errors.push(e);
				if(--nReject === 0) {
					results = null;
					this.reject(errors);
				}
			}
		}

		/**
		 * Apply f to the value of each promise in a list of promises
		 * and return a new list containing the results.
		 * @param {array} promises
		 * @param {function(x:*, index:Number):*} f mapping function
		 * @returns {Promise}
		 */
		function map(promises, f) {
			return Promise._traverse(f, promises);
		}

		/**
		 * Filter the provided array of promises using the provided predicate.  Input may
		 * contain promises and values
		 * @param {Array} promises array of promises and values
		 * @param {function(x:*, index:Number):boolean} predicate filtering predicate.
		 *  Must return truthy (or promise for truthy) for items to retain.
		 * @returns {Promise} promise that will fulfill with an array containing all items
		 *  for which predicate returned truthy.
		 */
		function filter(promises, predicate) {
			var a = slice.call(promises);
			return Promise._traverse(predicate, a).then(function(keep) {
				return filterSync(a, keep);
			});
		}

		function filterSync(promises, keep) {
			// Safe because we know all promises have fulfilled if we've made it this far
			var l = keep.length;
			var filtered = new Array(l);
			for(var i=0, j=0; i<l; ++i) {
				if(keep[i]) {
					filtered[j++] = Promise._handler(promises[i]).value;
				}
			}
			filtered.length = j;
			return filtered;

		}

		/**
		 * Return a promise that will always fulfill with an array containing
		 * the outcome states of all input promises.  The returned promise
		 * will never reject.
		 * @param {Array} promises
		 * @returns {Promise} promise for array of settled state descriptors
		 */
		function settle(promises) {
			return all(promises.map(settleOne));
		}

		function settleOne(p) {
			// Optimize the case where we get an already-resolved when.js promise
			//  by extracting its state:
			var handler;
			if (p instanceof Promise) {
				// This is our own Promise type and we can reach its handler internals:
				handler = p._handler.join();
			}
			if((handler && handler.state() === 0) || !handler) {
				// Either still pending, or not a Promise at all:
				return toPromise(p).then(state.fulfilled, state.rejected);
			}

			// The promise is our own, but it is already resolved. Take a shortcut.
			// Since we're not actually handling the resolution, we need to disable
			// rejection reporting.
			handler._unreport();
			return state.inspect(handler);
		}

		/**
		 * Traditional reduce function, similar to `Array.prototype.reduce()`, but
		 * input may contain promises and/or values, and reduceFunc
		 * may return either a value or a promise, *and* initialValue may
		 * be a promise for the starting value.
		 * @param {Array|Promise} promises array or promise for an array of anything,
		 *      may contain a mix of promises and values.
		 * @param {function(accumulated:*, x:*, index:Number):*} f reduce function
		 * @returns {Promise} that will resolve to the final reduced value
		 */
		function reduce(promises, f /*, initialValue */) {
			return arguments.length > 2 ? ar.call(promises, liftCombine(f), arguments[2])
					: ar.call(promises, liftCombine(f));
		}

		/**
		 * Traditional reduce function, similar to `Array.prototype.reduceRight()`, but
		 * input may contain promises and/or values, and reduceFunc
		 * may return either a value or a promise, *and* initialValue may
		 * be a promise for the starting value.
		 * @param {Array|Promise} promises array or promise for an array of anything,
		 *      may contain a mix of promises and values.
		 * @param {function(accumulated:*, x:*, index:Number):*} f reduce function
		 * @returns {Promise} that will resolve to the final reduced value
		 */
		function reduceRight(promises, f /*, initialValue */) {
			return arguments.length > 2 ? arr.call(promises, liftCombine(f), arguments[2])
					: arr.call(promises, liftCombine(f));
		}

		function liftCombine(f) {
			return function(z, x, i) {
				return applyFold(f, void 0, [z,x,i]);
			};
		}
	};

});
}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(require); }));

},{"../apply":459,"../state":473}],461:[function(require,module,exports){
/** @license MIT License (c) copyright 2010-2014 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

(function(define) { 'use strict';
define(function() {

	return function flow(Promise) {

		var resolve = Promise.resolve;
		var reject = Promise.reject;
		var origCatch = Promise.prototype['catch'];

		/**
		 * Handle the ultimate fulfillment value or rejection reason, and assume
		 * responsibility for all errors.  If an error propagates out of result
		 * or handleFatalError, it will be rethrown to the host, resulting in a
		 * loud stack track on most platforms and a crash on some.
		 * @param {function?} onResult
		 * @param {function?} onError
		 * @returns {undefined}
		 */
		Promise.prototype.done = function(onResult, onError) {
			this._handler.visit(this._handler.receiver, onResult, onError);
		};

		/**
		 * Add Error-type and predicate matching to catch.  Examples:
		 * promise.catch(TypeError, handleTypeError)
		 *   .catch(predicate, handleMatchedErrors)
		 *   .catch(handleRemainingErrors)
		 * @param onRejected
		 * @returns {*}
		 */
		Promise.prototype['catch'] = Promise.prototype.otherwise = function(onRejected) {
			if (arguments.length < 2) {
				return origCatch.call(this, onRejected);
			}

			if(typeof onRejected !== 'function') {
				return this.ensure(rejectInvalidPredicate);
			}

			return origCatch.call(this, createCatchFilter(arguments[1], onRejected));
		};

		/**
		 * Wraps the provided catch handler, so that it will only be called
		 * if the predicate evaluates truthy
		 * @param {?function} handler
		 * @param {function} predicate
		 * @returns {function} conditional catch handler
		 */
		function createCatchFilter(handler, predicate) {
			return function(e) {
				return evaluatePredicate(e, predicate)
					? handler.call(this, e)
					: reject(e);
			};
		}

		/**
		 * Ensures that onFulfilledOrRejected will be called regardless of whether
		 * this promise is fulfilled or rejected.  onFulfilledOrRejected WILL NOT
		 * receive the promises' value or reason.  Any returned value will be disregarded.
		 * onFulfilledOrRejected may throw or return a rejected promise to signal
		 * an additional error.
		 * @param {function} handler handler to be called regardless of
		 *  fulfillment or rejection
		 * @returns {Promise}
		 */
		Promise.prototype['finally'] = Promise.prototype.ensure = function(handler) {
			if(typeof handler !== 'function') {
				return this;
			}

			return this.then(function(x) {
				return runSideEffect(handler, this, identity, x);
			}, function(e) {
				return runSideEffect(handler, this, reject, e);
			});
		};

		function runSideEffect (handler, thisArg, propagate, value) {
			var result = handler.call(thisArg);
			return maybeThenable(result)
				? propagateValue(result, propagate, value)
				: propagate(value);
		}

		function propagateValue (result, propagate, x) {
			return resolve(result).then(function () {
				return propagate(x);
			});
		}

		/**
		 * Recover from a failure by returning a defaultValue.  If defaultValue
		 * is a promise, it's fulfillment value will be used.  If defaultValue is
		 * a promise that rejects, the returned promise will reject with the
		 * same reason.
		 * @param {*} defaultValue
		 * @returns {Promise} new promise
		 */
		Promise.prototype['else'] = Promise.prototype.orElse = function(defaultValue) {
			return this.then(void 0, function() {
				return defaultValue;
			});
		};

		/**
		 * Shortcut for .then(function() { return value; })
		 * @param  {*} value
		 * @return {Promise} a promise that:
		 *  - is fulfilled if value is not a promise, or
		 *  - if value is a promise, will fulfill with its value, or reject
		 *    with its reason.
		 */
		Promise.prototype['yield'] = function(value) {
			return this.then(function() {
				return value;
			});
		};

		/**
		 * Runs a side effect when this promise fulfills, without changing the
		 * fulfillment value.
		 * @param {function} onFulfilledSideEffect
		 * @returns {Promise}
		 */
		Promise.prototype.tap = function(onFulfilledSideEffect) {
			return this.then(onFulfilledSideEffect)['yield'](this);
		};

		return Promise;
	};

	function rejectInvalidPredicate() {
		throw new TypeError('catch predicate must be a function');
	}

	function evaluatePredicate(e, predicate) {
		return isError(predicate) ? e instanceof predicate : predicate(e);
	}

	function isError(predicate) {
		return predicate === Error
			|| (predicate != null && predicate.prototype instanceof Error);
	}

	function maybeThenable(x) {
		return (typeof x === 'object' || typeof x === 'function') && x !== null;
	}

	function identity(x) {
		return x;
	}

});
}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(); }));

},{}],462:[function(require,module,exports){
/** @license MIT License (c) copyright 2010-2014 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */
/** @author Jeff Escalante */

(function(define) { 'use strict';
define(function() {

	return function fold(Promise) {

		Promise.prototype.fold = function(f, z) {
			var promise = this._beget();

			this._handler.fold(function(z, x, to) {
				Promise._handler(z).fold(function(x, z, to) {
					to.resolve(f.call(this, z, x));
				}, x, this, to);
			}, z, promise._handler.receiver, promise._handler);

			return promise;
		};

		return Promise;
	};

});
}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(); }));

},{}],463:[function(require,module,exports){
/** @license MIT License (c) copyright 2010-2014 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

(function(define) { 'use strict';
define(function(require) {

	var inspect = require('../state').inspect;

	return function inspection(Promise) {

		Promise.prototype.inspect = function() {
			return inspect(Promise._handler(this));
		};

		return Promise;
	};

});
}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(require); }));

},{"../state":473}],464:[function(require,module,exports){
/** @license MIT License (c) copyright 2010-2014 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

(function(define) { 'use strict';
define(function() {

	return function generate(Promise) {

		var resolve = Promise.resolve;

		Promise.iterate = iterate;
		Promise.unfold = unfold;

		return Promise;

		/**
		 * @deprecated Use github.com/cujojs/most streams and most.iterate
		 * Generate a (potentially infinite) stream of promised values:
		 * x, f(x), f(f(x)), etc. until condition(x) returns true
		 * @param {function} f function to generate a new x from the previous x
		 * @param {function} condition function that, given the current x, returns
		 *  truthy when the iterate should stop
		 * @param {function} handler function to handle the value produced by f
		 * @param {*|Promise} x starting value, may be a promise
		 * @return {Promise} the result of the last call to f before
		 *  condition returns true
		 */
		function iterate(f, condition, handler, x) {
			return unfold(function(x) {
				return [x, f(x)];
			}, condition, handler, x);
		}

		/**
		 * @deprecated Use github.com/cujojs/most streams and most.unfold
		 * Generate a (potentially infinite) stream of promised values
		 * by applying handler(generator(seed)) iteratively until
		 * condition(seed) returns true.
		 * @param {function} unspool function that generates a [value, newSeed]
		 *  given a seed.
		 * @param {function} condition function that, given the current seed, returns
		 *  truthy when the unfold should stop
		 * @param {function} handler function to handle the value produced by unspool
		 * @param x {*|Promise} starting value, may be a promise
		 * @return {Promise} the result of the last value produced by unspool before
		 *  condition returns true
		 */
		function unfold(unspool, condition, handler, x) {
			return resolve(x).then(function(seed) {
				return resolve(condition(seed)).then(function(done) {
					return done ? seed : resolve(unspool(seed)).spread(next);
				});
			});

			function next(item, newSeed) {
				return resolve(handler(item)).then(function() {
					return unfold(unspool, condition, handler, newSeed);
				});
			}
		}
	};

});
}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(); }));

},{}],465:[function(require,module,exports){
/** @license MIT License (c) copyright 2010-2014 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

(function(define) { 'use strict';
define(function() {

	return function progress(Promise) {

		/**
		 * @deprecated
		 * Register a progress handler for this promise
		 * @param {function} onProgress
		 * @returns {Promise}
		 */
		Promise.prototype.progress = function(onProgress) {
			return this.then(void 0, void 0, onProgress);
		};

		return Promise;
	};

});
}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(); }));

},{}],466:[function(require,module,exports){
/** @license MIT License (c) copyright 2010-2014 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

(function(define) { 'use strict';
define(function(require) {

	var env = require('../env');
	var TimeoutError = require('../TimeoutError');

	function setTimeout(f, ms, x, y) {
		return env.setTimer(function() {
			f(x, y, ms);
		}, ms);
	}

	return function timed(Promise) {
		/**
		 * Return a new promise whose fulfillment value is revealed only
		 * after ms milliseconds
		 * @param {number} ms milliseconds
		 * @returns {Promise}
		 */
		Promise.prototype.delay = function(ms) {
			var p = this._beget();
			this._handler.fold(handleDelay, ms, void 0, p._handler);
			return p;
		};

		function handleDelay(ms, x, h) {
			setTimeout(resolveDelay, ms, x, h);
		}

		function resolveDelay(x, h) {
			h.resolve(x);
		}

		/**
		 * Return a new promise that rejects after ms milliseconds unless
		 * this promise fulfills earlier, in which case the returned promise
		 * fulfills with the same value.
		 * @param {number} ms milliseconds
		 * @param {Error|*=} reason optional rejection reason to use, defaults
		 *   to a TimeoutError if not provided
		 * @returns {Promise}
		 */
		Promise.prototype.timeout = function(ms, reason) {
			var p = this._beget();
			var h = p._handler;

			var t = setTimeout(onTimeout, ms, reason, p._handler);

			this._handler.visit(h,
				function onFulfill(x) {
					env.clearTimer(t);
					this.resolve(x); // this = h
				},
				function onReject(x) {
					env.clearTimer(t);
					this.reject(x); // this = h
				},
				h.notify);

			return p;
		};

		function onTimeout(reason, h, ms) {
			var e = typeof reason === 'undefined'
				? new TimeoutError('timed out after ' + ms + 'ms')
				: reason;
			h.reject(e);
		}

		return Promise;
	};

});
}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(require); }));

},{"../TimeoutError":458,"../env":469}],467:[function(require,module,exports){
/** @license MIT License (c) copyright 2010-2014 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

(function(define) { 'use strict';
define(function(require) {

	var setTimer = require('../env').setTimer;
	var format = require('../format');

	return function unhandledRejection(Promise) {

		var logError = noop;
		var logInfo = noop;
		var localConsole;

		if(typeof console !== 'undefined') {
			// Alias console to prevent things like uglify's drop_console option from
			// removing console.log/error. Unhandled rejections fall into the same
			// category as uncaught exceptions, and build tools shouldn't silence them.
			localConsole = console;
			logError = typeof localConsole.error !== 'undefined'
				? function (e) { localConsole.error(e); }
				: function (e) { localConsole.log(e); };

			logInfo = typeof localConsole.info !== 'undefined'
				? function (e) { localConsole.info(e); }
				: function (e) { localConsole.log(e); };
		}

		Promise.onPotentiallyUnhandledRejection = function(rejection) {
			enqueue(report, rejection);
		};

		Promise.onPotentiallyUnhandledRejectionHandled = function(rejection) {
			enqueue(unreport, rejection);
		};

		Promise.onFatalRejection = function(rejection) {
			enqueue(throwit, rejection.value);
		};

		var tasks = [];
		var reported = [];
		var running = null;

		function report(r) {
			if(!r.handled) {
				reported.push(r);
				logError('Potentially unhandled rejection [' + r.id + '] ' + format.formatError(r.value));
			}
		}

		function unreport(r) {
			var i = reported.indexOf(r);
			if(i >= 0) {
				reported.splice(i, 1);
				logInfo('Handled previous rejection [' + r.id + '] ' + format.formatObject(r.value));
			}
		}

		function enqueue(f, x) {
			tasks.push(f, x);
			if(running === null) {
				running = setTimer(flush, 0);
			}
		}

		function flush() {
			running = null;
			while(tasks.length > 0) {
				tasks.shift()(tasks.shift());
			}
		}

		return Promise;
	};

	function throwit(e) {
		throw e;
	}

	function noop() {}

});
}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(require); }));

},{"../env":469,"../format":470}],468:[function(require,module,exports){
/** @license MIT License (c) copyright 2010-2014 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

(function(define) { 'use strict';
define(function() {

	return function addWith(Promise) {
		/**
		 * Returns a promise whose handlers will be called with `this` set to
		 * the supplied receiver.  Subsequent promises derived from the
		 * returned promise will also have their handlers called with receiver
		 * as `this`. Calling `with` with undefined or no arguments will return
		 * a promise whose handlers will again be called in the usual Promises/A+
		 * way (no `this`) thus safely undoing any previous `with` in the
		 * promise chain.
		 *
		 * WARNING: Promises returned from `with`/`withThis` are NOT Promises/A+
		 * compliant, specifically violating 2.2.5 (http://promisesaplus.com/#point-41)
		 *
		 * @param {object} receiver `this` value for all handlers attached to
		 *  the returned promise.
		 * @returns {Promise}
		 */
		Promise.prototype['with'] = Promise.prototype.withThis = function(receiver) {
			var p = this._beget();
			var child = p._handler;
			child.receiver = receiver;
			this._handler.chain(child, receiver);
			return p;
		};

		return Promise;
	};

});
}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(); }));


},{}],469:[function(require,module,exports){
(function (process){
/** @license MIT License (c) copyright 2010-2014 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

/*global process,document,setTimeout,clearTimeout,MutationObserver,WebKitMutationObserver*/
(function(define) { 'use strict';
define(function(require) {
	/*jshint maxcomplexity:6*/

	// Sniff "best" async scheduling option
	// Prefer process.nextTick or MutationObserver, then check for
	// setTimeout, and finally vertx, since its the only env that doesn't
	// have setTimeout

	var MutationObs;
	var capturedSetTimeout = typeof setTimeout !== 'undefined' && setTimeout;

	// Default env
	var setTimer = function(f, ms) { return setTimeout(f, ms); };
	var clearTimer = function(t) { return clearTimeout(t); };
	var asap = function (f) { return capturedSetTimeout(f, 0); };

	// Detect specific env
	if (isNode()) { // Node
		asap = function (f) { return process.nextTick(f); };

	} else if (MutationObs = hasMutationObserver()) { // Modern browser
		asap = initMutationObserver(MutationObs);

	} else if (!capturedSetTimeout) { // vert.x
		var vertxRequire = require;
		var vertx = vertxRequire('vertx');
		setTimer = function (f, ms) { return vertx.setTimer(ms, f); };
		clearTimer = vertx.cancelTimer;
		asap = vertx.runOnLoop || vertx.runOnContext;
	}

	return {
		setTimer: setTimer,
		clearTimer: clearTimer,
		asap: asap
	};

	function isNode () {
		return typeof process !== 'undefined' &&
			Object.prototype.toString.call(process) === '[object process]';
	}

	function hasMutationObserver () {
	    return (typeof MutationObserver !== 'undefined' && MutationObserver) ||
			(typeof WebKitMutationObserver !== 'undefined' && WebKitMutationObserver);
	}

	function initMutationObserver(MutationObserver) {
		var scheduled;
		var node = document.createTextNode('');
		var o = new MutationObserver(run);
		o.observe(node, { characterData: true });

		function run() {
			var f = scheduled;
			scheduled = void 0;
			f();
		}

		var i = 0;
		return function (f) {
			scheduled = f;
			node.data = (i ^= 1);
		};
	}
});
}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(require); }));

}).call(this,require('_process'))
},{"_process":432}],470:[function(require,module,exports){
/** @license MIT License (c) copyright 2010-2014 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

(function(define) { 'use strict';
define(function() {

	return {
		formatError: formatError,
		formatObject: formatObject,
		tryStringify: tryStringify
	};

	/**
	 * Format an error into a string.  If e is an Error and has a stack property,
	 * it's returned.  Otherwise, e is formatted using formatObject, with a
	 * warning added about e not being a proper Error.
	 * @param {*} e
	 * @returns {String} formatted string, suitable for output to developers
	 */
	function formatError(e) {
		var s = typeof e === 'object' && e !== null && (e.stack || e.message) ? e.stack || e.message : formatObject(e);
		return e instanceof Error ? s : s + ' (WARNING: non-Error used)';
	}

	/**
	 * Format an object, detecting "plain" objects and running them through
	 * JSON.stringify if possible.
	 * @param {Object} o
	 * @returns {string}
	 */
	function formatObject(o) {
		var s = String(o);
		if(s === '[object Object]' && typeof JSON !== 'undefined') {
			s = tryStringify(o, s);
		}
		return s;
	}

	/**
	 * Try to return the result of JSON.stringify(x).  If that fails, return
	 * defaultValue
	 * @param {*} x
	 * @param {*} defaultValue
	 * @returns {String|*} JSON.stringify(x) or defaultValue
	 */
	function tryStringify(x, defaultValue) {
		try {
			return JSON.stringify(x);
		} catch(e) {
			return defaultValue;
		}
	}

});
}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(); }));

},{}],471:[function(require,module,exports){
/** @license MIT License (c) copyright 2010-2014 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

(function(define) { 'use strict';
define(function() {

	return function liftAll(liftOne, combine, dst, src) {
		if(typeof combine === 'undefined') {
			combine = defaultCombine;
		}

		return Object.keys(src).reduce(function(dst, key) {
			var f = src[key];
			return typeof f === 'function' ? combine(dst, liftOne(f), key) : dst;
		}, typeof dst === 'undefined' ? defaultDst(src) : dst);
	};

	function defaultCombine(o, f, k) {
		o[k] = f;
		return o;
	}

	function defaultDst(src) {
		return typeof src === 'function' ? src.bind() : Object.create(src);
	}
});
}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(); }));

},{}],472:[function(require,module,exports){
(function (process){
/** @license MIT License (c) copyright 2010-2014 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

(function(define) { 'use strict';
define(function() {

	return function makePromise(environment) {

		var tasks = environment.scheduler;
		var emitRejection = initEmitRejection();

		var objectCreate = Object.create ||
			function(proto) {
				function Child() {}
				Child.prototype = proto;
				return new Child();
			};

		/**
		 * Create a promise whose fate is determined by resolver
		 * @constructor
		 * @returns {Promise} promise
		 * @name Promise
		 */
		function Promise(resolver, handler) {
			this._handler = resolver === Handler ? handler : init(resolver);
		}

		/**
		 * Run the supplied resolver
		 * @param resolver
		 * @returns {Pending}
		 */
		function init(resolver) {
			var handler = new Pending();

			try {
				resolver(promiseResolve, promiseReject, promiseNotify);
			} catch (e) {
				promiseReject(e);
			}

			return handler;

			/**
			 * Transition from pre-resolution state to post-resolution state, notifying
			 * all listeners of the ultimate fulfillment or rejection
			 * @param {*} x resolution value
			 */
			function promiseResolve (x) {
				handler.resolve(x);
			}
			/**
			 * Reject this promise with reason, which will be used verbatim
			 * @param {Error|*} reason rejection reason, strongly suggested
			 *   to be an Error type
			 */
			function promiseReject (reason) {
				handler.reject(reason);
			}

			/**
			 * @deprecated
			 * Issue a progress event, notifying all progress listeners
			 * @param {*} x progress event payload to pass to all listeners
			 */
			function promiseNotify (x) {
				handler.notify(x);
			}
		}

		// Creation

		Promise.resolve = resolve;
		Promise.reject = reject;
		Promise.never = never;

		Promise._defer = defer;
		Promise._handler = getHandler;

		/**
		 * Returns a trusted promise. If x is already a trusted promise, it is
		 * returned, otherwise returns a new trusted Promise which follows x.
		 * @param  {*} x
		 * @return {Promise} promise
		 */
		function resolve(x) {
			return isPromise(x) ? x
				: new Promise(Handler, new Async(getHandler(x)));
		}

		/**
		 * Return a reject promise with x as its reason (x is used verbatim)
		 * @param {*} x
		 * @returns {Promise} rejected promise
		 */
		function reject(x) {
			return new Promise(Handler, new Async(new Rejected(x)));
		}

		/**
		 * Return a promise that remains pending forever
		 * @returns {Promise} forever-pending promise.
		 */
		function never() {
			return foreverPendingPromise; // Should be frozen
		}

		/**
		 * Creates an internal {promise, resolver} pair
		 * @private
		 * @returns {Promise}
		 */
		function defer() {
			return new Promise(Handler, new Pending());
		}

		// Transformation and flow control

		/**
		 * Transform this promise's fulfillment value, returning a new Promise
		 * for the transformed result.  If the promise cannot be fulfilled, onRejected
		 * is called with the reason.  onProgress *may* be called with updates toward
		 * this promise's fulfillment.
		 * @param {function=} onFulfilled fulfillment handler
		 * @param {function=} onRejected rejection handler
		 * @param {function=} onProgress @deprecated progress handler
		 * @return {Promise} new promise
		 */
		Promise.prototype.then = function(onFulfilled, onRejected, onProgress) {
			var parent = this._handler;
			var state = parent.join().state();

			if ((typeof onFulfilled !== 'function' && state > 0) ||
				(typeof onRejected !== 'function' && state < 0)) {
				// Short circuit: value will not change, simply share handler
				return new this.constructor(Handler, parent);
			}

			var p = this._beget();
			var child = p._handler;

			parent.chain(child, parent.receiver, onFulfilled, onRejected, onProgress);

			return p;
		};

		/**
		 * If this promise cannot be fulfilled due to an error, call onRejected to
		 * handle the error. Shortcut for .then(undefined, onRejected)
		 * @param {function?} onRejected
		 * @return {Promise}
		 */
		Promise.prototype['catch'] = function(onRejected) {
			return this.then(void 0, onRejected);
		};

		/**
		 * Creates a new, pending promise of the same type as this promise
		 * @private
		 * @returns {Promise}
		 */
		Promise.prototype._beget = function() {
			return begetFrom(this._handler, this.constructor);
		};

		function begetFrom(parent, Promise) {
			var child = new Pending(parent.receiver, parent.join().context);
			return new Promise(Handler, child);
		}

		// Array combinators

		Promise.all = all;
		Promise.race = race;
		Promise._traverse = traverse;

		/**
		 * Return a promise that will fulfill when all promises in the
		 * input array have fulfilled, or will reject when one of the
		 * promises rejects.
		 * @param {array} promises array of promises
		 * @returns {Promise} promise for array of fulfillment values
		 */
		function all(promises) {
			return traverseWith(snd, null, promises);
		}

		/**
		 * Array<Promise<X>> -> Promise<Array<f(X)>>
		 * @private
		 * @param {function} f function to apply to each promise's value
		 * @param {Array} promises array of promises
		 * @returns {Promise} promise for transformed values
		 */
		function traverse(f, promises) {
			return traverseWith(tryCatch2, f, promises);
		}

		function traverseWith(tryMap, f, promises) {
			var handler = typeof f === 'function' ? mapAt : settleAt;

			var resolver = new Pending();
			var pending = promises.length >>> 0;
			var results = new Array(pending);

			for (var i = 0, x; i < promises.length && !resolver.resolved; ++i) {
				x = promises[i];

				if (x === void 0 && !(i in promises)) {
					--pending;
					continue;
				}

				traverseAt(promises, handler, i, x, resolver);
			}

			if(pending === 0) {
				resolver.become(new Fulfilled(results));
			}

			return new Promise(Handler, resolver);

			function mapAt(i, x, resolver) {
				if(!resolver.resolved) {
					traverseAt(promises, settleAt, i, tryMap(f, x, i), resolver);
				}
			}

			function settleAt(i, x, resolver) {
				results[i] = x;
				if(--pending === 0) {
					resolver.become(new Fulfilled(results));
				}
			}
		}

		function traverseAt(promises, handler, i, x, resolver) {
			if (maybeThenable(x)) {
				var h = getHandlerMaybeThenable(x);
				var s = h.state();

				if (s === 0) {
					h.fold(handler, i, void 0, resolver);
				} else if (s > 0) {
					handler(i, h.value, resolver);
				} else {
					resolver.become(h);
					visitRemaining(promises, i+1, h);
				}
			} else {
				handler(i, x, resolver);
			}
		}

		Promise._visitRemaining = visitRemaining;
		function visitRemaining(promises, start, handler) {
			for(var i=start; i<promises.length; ++i) {
				markAsHandled(getHandler(promises[i]), handler);
			}
		}

		function markAsHandled(h, handler) {
			if(h === handler) {
				return;
			}

			var s = h.state();
			if(s === 0) {
				h.visit(h, void 0, h._unreport);
			} else if(s < 0) {
				h._unreport();
			}
		}

		/**
		 * Fulfill-reject competitive race. Return a promise that will settle
		 * to the same state as the earliest input promise to settle.
		 *
		 * WARNING: The ES6 Promise spec requires that race()ing an empty array
		 * must return a promise that is pending forever.  This implementation
		 * returns a singleton forever-pending promise, the same singleton that is
		 * returned by Promise.never(), thus can be checked with ===
		 *
		 * @param {array} promises array of promises to race
		 * @returns {Promise} if input is non-empty, a promise that will settle
		 * to the same outcome as the earliest input promise to settle. if empty
		 * is empty, returns a promise that will never settle.
		 */
		function race(promises) {
			if(typeof promises !== 'object' || promises === null) {
				return reject(new TypeError('non-iterable passed to race()'));
			}

			// Sigh, race([]) is untestable unless we return *something*
			// that is recognizable without calling .then() on it.
			return promises.length === 0 ? never()
				 : promises.length === 1 ? resolve(promises[0])
				 : runRace(promises);
		}

		function runRace(promises) {
			var resolver = new Pending();
			var i, x, h;
			for(i=0; i<promises.length; ++i) {
				x = promises[i];
				if (x === void 0 && !(i in promises)) {
					continue;
				}

				h = getHandler(x);
				if(h.state() !== 0) {
					resolver.become(h);
					visitRemaining(promises, i+1, h);
					break;
				} else {
					h.visit(resolver, resolver.resolve, resolver.reject);
				}
			}
			return new Promise(Handler, resolver);
		}

		// Promise internals
		// Below this, everything is @private

		/**
		 * Get an appropriate handler for x, without checking for cycles
		 * @param {*} x
		 * @returns {object} handler
		 */
		function getHandler(x) {
			if(isPromise(x)) {
				return x._handler.join();
			}
			return maybeThenable(x) ? getHandlerUntrusted(x) : new Fulfilled(x);
		}

		/**
		 * Get a handler for thenable x.
		 * NOTE: You must only call this if maybeThenable(x) == true
		 * @param {object|function|Promise} x
		 * @returns {object} handler
		 */
		function getHandlerMaybeThenable(x) {
			return isPromise(x) ? x._handler.join() : getHandlerUntrusted(x);
		}

		/**
		 * Get a handler for potentially untrusted thenable x
		 * @param {*} x
		 * @returns {object} handler
		 */
		function getHandlerUntrusted(x) {
			try {
				var untrustedThen = x.then;
				return typeof untrustedThen === 'function'
					? new Thenable(untrustedThen, x)
					: new Fulfilled(x);
			} catch(e) {
				return new Rejected(e);
			}
		}

		/**
		 * Handler for a promise that is pending forever
		 * @constructor
		 */
		function Handler() {}

		Handler.prototype.when
			= Handler.prototype.become
			= Handler.prototype.notify // deprecated
			= Handler.prototype.fail
			= Handler.prototype._unreport
			= Handler.prototype._report
			= noop;

		Handler.prototype._state = 0;

		Handler.prototype.state = function() {
			return this._state;
		};

		/**
		 * Recursively collapse handler chain to find the handler
		 * nearest to the fully resolved value.
		 * @returns {object} handler nearest the fully resolved value
		 */
		Handler.prototype.join = function() {
			var h = this;
			while(h.handler !== void 0) {
				h = h.handler;
			}
			return h;
		};

		Handler.prototype.chain = function(to, receiver, fulfilled, rejected, progress) {
			this.when({
				resolver: to,
				receiver: receiver,
				fulfilled: fulfilled,
				rejected: rejected,
				progress: progress
			});
		};

		Handler.prototype.visit = function(receiver, fulfilled, rejected, progress) {
			this.chain(failIfRejected, receiver, fulfilled, rejected, progress);
		};

		Handler.prototype.fold = function(f, z, c, to) {
			this.when(new Fold(f, z, c, to));
		};

		/**
		 * Handler that invokes fail() on any handler it becomes
		 * @constructor
		 */
		function FailIfRejected() {}

		inherit(Handler, FailIfRejected);

		FailIfRejected.prototype.become = function(h) {
			h.fail();
		};

		var failIfRejected = new FailIfRejected();

		/**
		 * Handler that manages a queue of consumers waiting on a pending promise
		 * @constructor
		 */
		function Pending(receiver, inheritedContext) {
			Promise.createContext(this, inheritedContext);

			this.consumers = void 0;
			this.receiver = receiver;
			this.handler = void 0;
			this.resolved = false;
		}

		inherit(Handler, Pending);

		Pending.prototype._state = 0;

		Pending.prototype.resolve = function(x) {
			this.become(getHandler(x));
		};

		Pending.prototype.reject = function(x) {
			if(this.resolved) {
				return;
			}

			this.become(new Rejected(x));
		};

		Pending.prototype.join = function() {
			if (!this.resolved) {
				return this;
			}

			var h = this;

			while (h.handler !== void 0) {
				h = h.handler;
				if (h === this) {
					return this.handler = cycle();
				}
			}

			return h;
		};

		Pending.prototype.run = function() {
			var q = this.consumers;
			var handler = this.handler;
			this.handler = this.handler.join();
			this.consumers = void 0;

			for (var i = 0; i < q.length; ++i) {
				handler.when(q[i]);
			}
		};

		Pending.prototype.become = function(handler) {
			if(this.resolved) {
				return;
			}

			this.resolved = true;
			this.handler = handler;
			if(this.consumers !== void 0) {
				tasks.enqueue(this);
			}

			if(this.context !== void 0) {
				handler._report(this.context);
			}
		};

		Pending.prototype.when = function(continuation) {
			if(this.resolved) {
				tasks.enqueue(new ContinuationTask(continuation, this.handler));
			} else {
				if(this.consumers === void 0) {
					this.consumers = [continuation];
				} else {
					this.consumers.push(continuation);
				}
			}
		};

		/**
		 * @deprecated
		 */
		Pending.prototype.notify = function(x) {
			if(!this.resolved) {
				tasks.enqueue(new ProgressTask(x, this));
			}
		};

		Pending.prototype.fail = function(context) {
			var c = typeof context === 'undefined' ? this.context : context;
			this.resolved && this.handler.join().fail(c);
		};

		Pending.prototype._report = function(context) {
			this.resolved && this.handler.join()._report(context);
		};

		Pending.prototype._unreport = function() {
			this.resolved && this.handler.join()._unreport();
		};

		/**
		 * Wrap another handler and force it into a future stack
		 * @param {object} handler
		 * @constructor
		 */
		function Async(handler) {
			this.handler = handler;
		}

		inherit(Handler, Async);

		Async.prototype.when = function(continuation) {
			tasks.enqueue(new ContinuationTask(continuation, this));
		};

		Async.prototype._report = function(context) {
			this.join()._report(context);
		};

		Async.prototype._unreport = function() {
			this.join()._unreport();
		};

		/**
		 * Handler that wraps an untrusted thenable and assimilates it in a future stack
		 * @param {function} then
		 * @param {{then: function}} thenable
		 * @constructor
		 */
		function Thenable(then, thenable) {
			Pending.call(this);
			tasks.enqueue(new AssimilateTask(then, thenable, this));
		}

		inherit(Pending, Thenable);

		/**
		 * Handler for a fulfilled promise
		 * @param {*} x fulfillment value
		 * @constructor
		 */
		function Fulfilled(x) {
			Promise.createContext(this);
			this.value = x;
		}

		inherit(Handler, Fulfilled);

		Fulfilled.prototype._state = 1;

		Fulfilled.prototype.fold = function(f, z, c, to) {
			runContinuation3(f, z, this, c, to);
		};

		Fulfilled.prototype.when = function(cont) {
			runContinuation1(cont.fulfilled, this, cont.receiver, cont.resolver);
		};

		var errorId = 0;

		/**
		 * Handler for a rejected promise
		 * @param {*} x rejection reason
		 * @constructor
		 */
		function Rejected(x) {
			Promise.createContext(this);

			this.id = ++errorId;
			this.value = x;
			this.handled = false;
			this.reported = false;

			this._report();
		}

		inherit(Handler, Rejected);

		Rejected.prototype._state = -1;

		Rejected.prototype.fold = function(f, z, c, to) {
			to.become(this);
		};

		Rejected.prototype.when = function(cont) {
			if(typeof cont.rejected === 'function') {
				this._unreport();
			}
			runContinuation1(cont.rejected, this, cont.receiver, cont.resolver);
		};

		Rejected.prototype._report = function(context) {
			tasks.afterQueue(new ReportTask(this, context));
		};

		Rejected.prototype._unreport = function() {
			if(this.handled) {
				return;
			}
			this.handled = true;
			tasks.afterQueue(new UnreportTask(this));
		};

		Rejected.prototype.fail = function(context) {
			this.reported = true;
			emitRejection('unhandledRejection', this);
			Promise.onFatalRejection(this, context === void 0 ? this.context : context);
		};

		function ReportTask(rejection, context) {
			this.rejection = rejection;
			this.context = context;
		}

		ReportTask.prototype.run = function() {
			if(!this.rejection.handled && !this.rejection.reported) {
				this.rejection.reported = true;
				emitRejection('unhandledRejection', this.rejection) ||
					Promise.onPotentiallyUnhandledRejection(this.rejection, this.context);
			}
		};

		function UnreportTask(rejection) {
			this.rejection = rejection;
		}

		UnreportTask.prototype.run = function() {
			if(this.rejection.reported) {
				emitRejection('rejectionHandled', this.rejection) ||
					Promise.onPotentiallyUnhandledRejectionHandled(this.rejection);
			}
		};

		// Unhandled rejection hooks
		// By default, everything is a noop

		Promise.createContext
			= Promise.enterContext
			= Promise.exitContext
			= Promise.onPotentiallyUnhandledRejection
			= Promise.onPotentiallyUnhandledRejectionHandled
			= Promise.onFatalRejection
			= noop;

		// Errors and singletons

		var foreverPendingHandler = new Handler();
		var foreverPendingPromise = new Promise(Handler, foreverPendingHandler);

		function cycle() {
			return new Rejected(new TypeError('Promise cycle'));
		}

		// Task runners

		/**
		 * Run a single consumer
		 * @constructor
		 */
		function ContinuationTask(continuation, handler) {
			this.continuation = continuation;
			this.handler = handler;
		}

		ContinuationTask.prototype.run = function() {
			this.handler.join().when(this.continuation);
		};

		/**
		 * Run a queue of progress handlers
		 * @constructor
		 */
		function ProgressTask(value, handler) {
			this.handler = handler;
			this.value = value;
		}

		ProgressTask.prototype.run = function() {
			var q = this.handler.consumers;
			if(q === void 0) {
				return;
			}

			for (var c, i = 0; i < q.length; ++i) {
				c = q[i];
				runNotify(c.progress, this.value, this.handler, c.receiver, c.resolver);
			}
		};

		/**
		 * Assimilate a thenable, sending it's value to resolver
		 * @param {function} then
		 * @param {object|function} thenable
		 * @param {object} resolver
		 * @constructor
		 */
		function AssimilateTask(then, thenable, resolver) {
			this._then = then;
			this.thenable = thenable;
			this.resolver = resolver;
		}

		AssimilateTask.prototype.run = function() {
			var h = this.resolver;
			tryAssimilate(this._then, this.thenable, _resolve, _reject, _notify);

			function _resolve(x) { h.resolve(x); }
			function _reject(x)  { h.reject(x); }
			function _notify(x)  { h.notify(x); }
		};

		function tryAssimilate(then, thenable, resolve, reject, notify) {
			try {
				then.call(thenable, resolve, reject, notify);
			} catch (e) {
				reject(e);
			}
		}

		/**
		 * Fold a handler value with z
		 * @constructor
		 */
		function Fold(f, z, c, to) {
			this.f = f; this.z = z; this.c = c; this.to = to;
			this.resolver = failIfRejected;
			this.receiver = this;
		}

		Fold.prototype.fulfilled = function(x) {
			this.f.call(this.c, this.z, x, this.to);
		};

		Fold.prototype.rejected = function(x) {
			this.to.reject(x);
		};

		Fold.prototype.progress = function(x) {
			this.to.notify(x);
		};

		// Other helpers

		/**
		 * @param {*} x
		 * @returns {boolean} true iff x is a trusted Promise
		 */
		function isPromise(x) {
			return x instanceof Promise;
		}

		/**
		 * Test just enough to rule out primitives, in order to take faster
		 * paths in some code
		 * @param {*} x
		 * @returns {boolean} false iff x is guaranteed *not* to be a thenable
		 */
		function maybeThenable(x) {
			return (typeof x === 'object' || typeof x === 'function') && x !== null;
		}

		function runContinuation1(f, h, receiver, next) {
			if(typeof f !== 'function') {
				return next.become(h);
			}

			Promise.enterContext(h);
			tryCatchReject(f, h.value, receiver, next);
			Promise.exitContext();
		}

		function runContinuation3(f, x, h, receiver, next) {
			if(typeof f !== 'function') {
				return next.become(h);
			}

			Promise.enterContext(h);
			tryCatchReject3(f, x, h.value, receiver, next);
			Promise.exitContext();
		}

		/**
		 * @deprecated
		 */
		function runNotify(f, x, h, receiver, next) {
			if(typeof f !== 'function') {
				return next.notify(x);
			}

			Promise.enterContext(h);
			tryCatchReturn(f, x, receiver, next);
			Promise.exitContext();
		}

		function tryCatch2(f, a, b) {
			try {
				return f(a, b);
			} catch(e) {
				return reject(e);
			}
		}

		/**
		 * Return f.call(thisArg, x), or if it throws return a rejected promise for
		 * the thrown exception
		 */
		function tryCatchReject(f, x, thisArg, next) {
			try {
				next.become(getHandler(f.call(thisArg, x)));
			} catch(e) {
				next.become(new Rejected(e));
			}
		}

		/**
		 * Same as above, but includes the extra argument parameter.
		 */
		function tryCatchReject3(f, x, y, thisArg, next) {
			try {
				f.call(thisArg, x, y, next);
			} catch(e) {
				next.become(new Rejected(e));
			}
		}

		/**
		 * @deprecated
		 * Return f.call(thisArg, x), or if it throws, *return* the exception
		 */
		function tryCatchReturn(f, x, thisArg, next) {
			try {
				next.notify(f.call(thisArg, x));
			} catch(e) {
				next.notify(e);
			}
		}

		function inherit(Parent, Child) {
			Child.prototype = objectCreate(Parent.prototype);
			Child.prototype.constructor = Child;
		}

		function snd(x, y) {
			return y;
		}

		function noop() {}

		function hasCustomEvent() {
			if(typeof CustomEvent === 'function') {
				try {
					var ev = new CustomEvent('unhandledRejection');
					return ev instanceof CustomEvent;
				} catch (ignoredException) {}
			}
			return false;
		}

		function hasInternetExplorerCustomEvent() {
			if(typeof document !== 'undefined' && typeof document.createEvent === 'function') {
				try {
					// Try to create one event to make sure it's supported
					var ev = document.createEvent('CustomEvent');
					ev.initCustomEvent('eventType', false, true, {});
					return true;
				} catch (ignoredException) {}
			}
			return false;
		}

		function initEmitRejection() {
			/*global process, self, CustomEvent*/
			if(typeof process !== 'undefined' && process !== null
				&& typeof process.emit === 'function') {
				// Returning falsy here means to call the default
				// onPotentiallyUnhandledRejection API.  This is safe even in
				// browserify since process.emit always returns falsy in browserify:
				// https://github.com/defunctzombie/node-process/blob/master/browser.js#L40-L46
				return function(type, rejection) {
					return type === 'unhandledRejection'
						? process.emit(type, rejection.value, rejection)
						: process.emit(type, rejection);
				};
			} else if(typeof self !== 'undefined' && hasCustomEvent()) {
				return (function (self, CustomEvent) {
					return function (type, rejection) {
						var ev = new CustomEvent(type, {
							detail: {
								reason: rejection.value,
								key: rejection
							},
							bubbles: false,
							cancelable: true
						});

						return !self.dispatchEvent(ev);
					};
				}(self, CustomEvent));
			} else if(typeof self !== 'undefined' && hasInternetExplorerCustomEvent()) {
				return (function(self, document) {
					return function(type, rejection) {
						var ev = document.createEvent('CustomEvent');
						ev.initCustomEvent(type, false, true, {
							reason: rejection.value,
							key: rejection
						});

						return !self.dispatchEvent(ev);
					};
				}(self, document));
			}

			return noop;
		}

		return Promise;
	};
});
}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(); }));

}).call(this,require('_process'))
},{"_process":432}],473:[function(require,module,exports){
/** @license MIT License (c) copyright 2010-2014 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

(function(define) { 'use strict';
define(function() {

	return {
		pending: toPendingState,
		fulfilled: toFulfilledState,
		rejected: toRejectedState,
		inspect: inspect
	};

	function toPendingState() {
		return { state: 'pending' };
	}

	function toRejectedState(e) {
		return { state: 'rejected', reason: e };
	}

	function toFulfilledState(x) {
		return { state: 'fulfilled', value: x };
	}

	function inspect(handler) {
		var state = handler.state();
		return state === 0 ? toPendingState()
			 : state > 0   ? toFulfilledState(handler.value)
			               : toRejectedState(handler.value);
	}

});
}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(); }));

},{}],474:[function(require,module,exports){
/** @license MIT License (c) copyright 2013 original author or authors */

/**
 * Collection of helpers for interfacing with node-style asynchronous functions
 * using promises.
 *
 * @author Brian Cavalier
 * @contributor Renato Zannon
 */

(function(define) {
define(function(require) {

	var when = require('./when');
	var _liftAll = require('./lib/liftAll');
	var setTimer = require('./lib/env').setTimer;
	var slice = Array.prototype.slice;

	var _apply = require('./lib/apply')(when.Promise, dispatch);

	return {
		lift: lift,
		liftAll: liftAll,
		apply: apply,
		call: call,
		createCallback: createCallback,
		bindCallback: bindCallback,
		liftCallback: liftCallback
	};

	/**
	 * Takes a node-style async function and calls it immediately (with an optional
	 * array of arguments or promises for arguments). It returns a promise whose
	 * resolution depends on whether the async functions calls its callback with the
	 * conventional error argument or not.
	 *
	 * With this it becomes possible to leverage existing APIs while still reaping
	 * the benefits of promises.
	 *
	 * @example
	 *    function onlySmallNumbers(n, callback) {
	 *		if(n < 10) {
	 *			callback(null, n + 10);
	 *		} else {
	 *			callback(new Error("Calculation failed"));
	 *		}
	 *	}
	 *
	 *    var nodefn = require("when/node/function");
	 *
	 *    // Logs '15'
	 *    nodefn.apply(onlySmallNumbers, [5]).then(console.log, console.error);
	 *
	 *    // Logs 'Calculation failed'
	 *    nodefn.apply(onlySmallNumbers, [15]).then(console.log, console.error);
	 *
	 * @param {function} f node-style function that will be called
	 * @param {Array} [args] array of arguments to func
	 * @returns {Promise} promise for the value func passes to its callback
	 */
	function apply(f, args) {
		return _apply(f, this, args || []);
	}

	function dispatch(f, thisArg, args, h) {
		var cb = createCallback(h);
		try {
			switch(args.length) {
				case 2: f.call(thisArg, args[0], args[1], cb); break;
				case 1: f.call(thisArg, args[0], cb); break;
				case 0: f.call(thisArg, cb); break;
				default:
					args.push(cb);
					f.apply(thisArg, args);
			}
		} catch(e) {
			h.reject(e);
		}
	}

	/**
	 * Has the same behavior that {@link apply} has, with the difference that the
	 * arguments to the function are provided individually, while {@link apply} accepts
	 * a single array.
	 *
	 * @example
	 *    function sumSmallNumbers(x, y, callback) {
	 *		var result = x + y;
	 *		if(result < 10) {
	 *			callback(null, result);
	 *		} else {
	 *			callback(new Error("Calculation failed"));
	 *		}
	 *	}
	 *
	 *    // Logs '5'
	 *    nodefn.call(sumSmallNumbers, 2, 3).then(console.log, console.error);
	 *
	 *    // Logs 'Calculation failed'
	 *    nodefn.call(sumSmallNumbers, 5, 10).then(console.log, console.error);
	 *
	 * @param {function} f node-style function that will be called
	 * @param {...*} [args] arguments that will be forwarded to the function
	 * @returns {Promise} promise for the value func passes to its callback
	 */
	function call(f /*, args... */) {
		return _apply(f, this, slice.call(arguments, 1));
	}

	/**
	 * Takes a node-style function and returns new function that wraps the
	 * original and, instead of taking a callback, returns a promise. Also, it
	 * knows how to handle promises given as arguments, waiting for their
	 * resolution before executing.
	 *
	 * Upon execution, the orginal function is executed as well. If it passes
	 * a truthy value as the first argument to the callback, it will be
	 * interpreted as an error condition, and the promise will be rejected
	 * with it. Otherwise, the call is considered a resolution, and the promise
	 * is resolved with the callback's second argument.
	 *
	 * @example
	 *    var fs = require("fs"), nodefn = require("when/node/function");
	 *
	 *    var promiseRead = nodefn.lift(fs.readFile);
	 *
	 *    // The promise is resolved with the contents of the file if everything
	 *    // goes ok
	 *    promiseRead('exists.txt').then(console.log, console.error);
	 *
	 *    // And will be rejected if something doesn't work out
	 *    // (e.g. the files does not exist)
	 *    promiseRead('doesnt_exist.txt').then(console.log, console.error);
	 *
	 *
	 * @param {Function} f node-style function to be lifted
	 * @param {...*} [args] arguments to be prepended for the new function @deprecated
	 * @returns {Function} a promise-returning function
	 */
	function lift(f /*, args... */) {
		var args1 = arguments.length > 1 ? slice.call(arguments, 1) : [];
		return function() {
			// TODO: Simplify once partialing has been removed
			var l = args1.length;
			var al = arguments.length;
			var args = new Array(al + l);
			var i;
			for(i=0; i<l; ++i) {
				args[i] = args1[i];
			}
			for(i=0; i<al; ++i) {
				args[i+l] = arguments[i];
			}
			return _apply(f, this, args);
		};
	}

	/**
	 * Lift all the functions/methods on src
	 * @param {object|function} src source whose functions will be lifted
	 * @param {function?} combine optional function for customizing the lifting
	 *  process. It is passed dst, the lifted function, and the property name of
	 *  the original function on src.
	 * @param {(object|function)?} dst option destination host onto which to place lifted
	 *  functions. If not provided, liftAll returns a new object.
	 * @returns {*} If dst is provided, returns dst with lifted functions as
	 *  properties.  If dst not provided, returns a new object with lifted functions.
	 */
	function liftAll(src, combine, dst) {
		return _liftAll(lift, combine, dst, src);
	}

	/**
	 * Takes an object that responds to the resolver interface, and returns
	 * a function that will resolve or reject it depending on how it is called.
	 *
	 * @example
	 *	function callbackTakingFunction(callback) {
	 *		if(somethingWrongHappened) {
	 *			callback(error);
	 *		} else {
	 *			callback(null, interestingValue);
	 *		}
	 *	}
	 *
	 *	var when = require('when'), nodefn = require('when/node/function');
	 *
	 *	var deferred = when.defer();
	 *	callbackTakingFunction(nodefn.createCallback(deferred.resolver));
	 *
	 *	deferred.promise.then(function(interestingValue) {
	 *		// Use interestingValue
	 *	});
	 *
	 * @param {Resolver} resolver that will be 'attached' to the callback
	 * @returns {Function} a node-style callback function
	 */
	function createCallback(resolver) {
		return function(err, value) {
			if(err) {
				resolver.reject(err);
			} else if(arguments.length > 2) {
				resolver.resolve(slice.call(arguments, 1));
			} else {
				resolver.resolve(value);
			}
		};
	}

	/**
	 * Attaches a node-style callback to a promise, ensuring the callback is
	 * called for either fulfillment or rejection. Returns a promise with the same
	 * state as the passed-in promise.
	 *
	 * @example
	 *	var deferred = when.defer();
	 *
	 *	function callback(err, value) {
	 *		// Handle err or use value
	 *	}
	 *
	 *	bindCallback(deferred.promise, callback);
	 *
	 *	deferred.resolve('interesting value');
	 *
	 * @param {Promise} promise The promise to be attached to.
	 * @param {Function} callback The node-style callback to attach.
	 * @returns {Promise} A promise with the same state as the passed-in promise.
	 */
	function bindCallback(promise, callback) {
		promise = when(promise);

		if (callback) {
			promise.then(success, wrapped);
		}

		return promise;

		function success(value) {
			wrapped(null, value);
		}

		function wrapped(err, value) {
			setTimer(function () {
				callback(err, value);
			}, 0);
		}
	}

	/**
	 * Takes a node-style callback and returns new function that accepts a
	 * promise, calling the original callback when the promise is either
	 * fulfilled or rejected with the appropriate arguments.
	 *
	 * @example
	 *	var deferred = when.defer();
	 *
	 *	function callback(err, value) {
	 *		// Handle err or use value
	 *	}
	 *
	 *	var wrapped = liftCallback(callback);
	 *
	 *	// `wrapped` can now be passed around at will
	 *	wrapped(deferred.promise);
	 *
	 *	deferred.resolve('interesting value');
	 *
	 * @param {Function} callback The node-style callback to wrap.
	 * @returns {Function} The lifted, promise-accepting function.
	 */
	function liftCallback(callback) {
		return function(promise) {
			return bindCallback(promise, callback);
		};
	}
});

})(typeof define === 'function' && define.amd ? define : function (factory) { module.exports = factory(require); });




},{"./lib/apply":459,"./lib/env":469,"./lib/liftAll":471,"./when":475}],475:[function(require,module,exports){
/** @license MIT License (c) copyright 2010-2014 original author or authors */

/**
 * Promises/A+ and when() implementation
 * when is part of the cujoJS family of libraries (http://cujojs.com/)
 * @author Brian Cavalier
 * @author John Hann
 */
(function(define) { 'use strict';
define(function (require) {

	var timed = require('./lib/decorators/timed');
	var array = require('./lib/decorators/array');
	var flow = require('./lib/decorators/flow');
	var fold = require('./lib/decorators/fold');
	var inspect = require('./lib/decorators/inspect');
	var generate = require('./lib/decorators/iterate');
	var progress = require('./lib/decorators/progress');
	var withThis = require('./lib/decorators/with');
	var unhandledRejection = require('./lib/decorators/unhandledRejection');
	var TimeoutError = require('./lib/TimeoutError');

	var Promise = [array, flow, fold, generate, progress,
		inspect, withThis, timed, unhandledRejection]
		.reduce(function(Promise, feature) {
			return feature(Promise);
		}, require('./lib/Promise'));

	var apply = require('./lib/apply')(Promise);

	// Public API

	when.promise     = promise;              // Create a pending promise
	when.resolve     = Promise.resolve;      // Create a resolved promise
	when.reject      = Promise.reject;       // Create a rejected promise

	when.lift        = lift;                 // lift a function to return promises
	when['try']      = attempt;              // call a function and return a promise
	when.attempt     = attempt;              // alias for when.try

	when.iterate     = Promise.iterate;      // DEPRECATED (use cujojs/most streams) Generate a stream of promises
	when.unfold      = Promise.unfold;       // DEPRECATED (use cujojs/most streams) Generate a stream of promises

	when.join        = join;                 // Join 2 or more promises

	when.all         = all;                  // Resolve a list of promises
	when.settle      = settle;               // Settle a list of promises

	when.any         = lift(Promise.any);    // One-winner race
	when.some        = lift(Promise.some);   // Multi-winner race
	when.race        = lift(Promise.race);   // First-to-settle race

	when.map         = map;                  // Array.map() for promises
	when.filter      = filter;               // Array.filter() for promises
	when.reduce      = lift(Promise.reduce);       // Array.reduce() for promises
	when.reduceRight = lift(Promise.reduceRight);  // Array.reduceRight() for promises

	when.isPromiseLike = isPromiseLike;      // Is something promise-like, aka thenable

	when.Promise     = Promise;              // Promise constructor
	when.defer       = defer;                // Create a {promise, resolve, reject} tuple

	// Error types

	when.TimeoutError = TimeoutError;

	/**
	 * Get a trusted promise for x, or by transforming x with onFulfilled
	 *
	 * @param {*} x
	 * @param {function?} onFulfilled callback to be called when x is
	 *   successfully fulfilled.  If promiseOrValue is an immediate value, callback
	 *   will be invoked immediately.
	 * @param {function?} onRejected callback to be called when x is
	 *   rejected.
	 * @param {function?} onProgress callback to be called when progress updates
	 *   are issued for x. @deprecated
	 * @returns {Promise} a new promise that will fulfill with the return
	 *   value of callback or errback or the completion value of promiseOrValue if
	 *   callback and/or errback is not supplied.
	 */
	function when(x, onFulfilled, onRejected, onProgress) {
		var p = Promise.resolve(x);
		if (arguments.length < 2) {
			return p;
		}

		return p.then(onFulfilled, onRejected, onProgress);
	}

	/**
	 * Creates a new promise whose fate is determined by resolver.
	 * @param {function} resolver function(resolve, reject, notify)
	 * @returns {Promise} promise whose fate is determine by resolver
	 */
	function promise(resolver) {
		return new Promise(resolver);
	}

	/**
	 * Lift the supplied function, creating a version of f that returns
	 * promises, and accepts promises as arguments.
	 * @param {function} f
	 * @returns {Function} version of f that returns promises
	 */
	function lift(f) {
		return function() {
			for(var i=0, l=arguments.length, a=new Array(l); i<l; ++i) {
				a[i] = arguments[i];
			}
			return apply(f, this, a);
		};
	}

	/**
	 * Call f in a future turn, with the supplied args, and return a promise
	 * for the result.
	 * @param {function} f
	 * @returns {Promise}
	 */
	function attempt(f /*, args... */) {
		/*jshint validthis:true */
		for(var i=0, l=arguments.length-1, a=new Array(l); i<l; ++i) {
			a[i] = arguments[i+1];
		}
		return apply(f, this, a);
	}

	/**
	 * Creates a {promise, resolver} pair, either or both of which
	 * may be given out safely to consumers.
	 * @return {{promise: Promise, resolve: function, reject: function, notify: function}}
	 */
	function defer() {
		return new Deferred();
	}

	function Deferred() {
		var p = Promise._defer();

		function resolve(x) { p._handler.resolve(x); }
		function reject(x) { p._handler.reject(x); }
		function notify(x) { p._handler.notify(x); }

		this.promise = p;
		this.resolve = resolve;
		this.reject = reject;
		this.notify = notify;
		this.resolver = { resolve: resolve, reject: reject, notify: notify };
	}

	/**
	 * Determines if x is promise-like, i.e. a thenable object
	 * NOTE: Will return true for *any thenable object*, and isn't truly
	 * safe, since it may attempt to access the `then` property of x (i.e.
	 *  clever/malicious getters may do weird things)
	 * @param {*} x anything
	 * @returns {boolean} true if x is promise-like
	 */
	function isPromiseLike(x) {
		return x && typeof x.then === 'function';
	}

	/**
	 * Return a promise that will resolve only once all the supplied arguments
	 * have resolved. The resolution value of the returned promise will be an array
	 * containing the resolution values of each of the arguments.
	 * @param {...*} arguments may be a mix of promises and values
	 * @returns {Promise}
	 */
	function join(/* ...promises */) {
		return Promise.all(arguments);
	}

	/**
	 * Return a promise that will fulfill once all input promises have
	 * fulfilled, or reject when any one input promise rejects.
	 * @param {array|Promise} promises array (or promise for an array) of promises
	 * @returns {Promise}
	 */
	function all(promises) {
		return when(promises, Promise.all);
	}

	/**
	 * Return a promise that will always fulfill with an array containing
	 * the outcome states of all input promises.  The returned promise
	 * will only reject if `promises` itself is a rejected promise.
	 * @param {array|Promise} promises array (or promise for an array) of promises
	 * @returns {Promise} promise for array of settled state descriptors
	 */
	function settle(promises) {
		return when(promises, Promise.settle);
	}

	/**
	 * Promise-aware array map function, similar to `Array.prototype.map()`,
	 * but input array may contain promises or values.
	 * @param {Array|Promise} promises array of anything, may contain promises and values
	 * @param {function(x:*, index:Number):*} mapFunc map function which may
	 *  return a promise or value
	 * @returns {Promise} promise that will fulfill with an array of mapped values
	 *  or reject if any input promise rejects.
	 */
	function map(promises, mapFunc) {
		return when(promises, function(promises) {
			return Promise.map(promises, mapFunc);
		});
	}

	/**
	 * Filter the provided array of promises using the provided predicate.  Input may
	 * contain promises and values
	 * @param {Array|Promise} promises array of promises and values
	 * @param {function(x:*, index:Number):boolean} predicate filtering predicate.
	 *  Must return truthy (or promise for truthy) for items to retain.
	 * @returns {Promise} promise that will fulfill with an array containing all items
	 *  for which predicate returned truthy.
	 */
	function filter(promises, predicate) {
		return when(promises, function(promises) {
			return Promise.filter(promises, predicate);
		});
	}

	return when;
});
})(typeof define === 'function' && define.amd ? define : function (factory) { module.exports = factory(require); });

},{"./lib/Promise":456,"./lib/TimeoutError":458,"./lib/apply":459,"./lib/decorators/array":460,"./lib/decorators/flow":461,"./lib/decorators/fold":462,"./lib/decorators/inspect":463,"./lib/decorators/iterate":464,"./lib/decorators/progress":465,"./lib/decorators/timed":466,"./lib/decorators/unhandledRejection":467,"./lib/decorators/with":468}]},{},[25]);
