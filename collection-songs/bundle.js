(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
"use strict";const i18n=require("../../../libs/spotify-i18n")({ar:require("./json/ar.json"),cs:require("./json/cs.json"),de:require("./json/de.json"),el:require("./json/el.json"),en:require("./json/en.json"),es:require("./json/es.json"),"es-419":require("./json/es-419.json"),fi:require("./json/fi.json"),fr:require("./json/fr.json"),"fr-CA":require("./json/fr-CA.json"),hu:require("./json/hu.json"),id:require("./json/id.json"),it:require("./json/it.json"),ja:require("./json/ja.json"),nl:require("./json/nl.json"),pl:require("./json/pl.json"),"pt-BR":require("./json/pt-BR.json"),sv:require("./json/sv.json"),th:require("./json/th.json"),tr:require("./json/tr.json"),vi:require("./json/vi.json"),"zh-Hant":require("./json/zh-Hant.json"),ms:require("./json/ms.json")});module.exports=i18n;

},{"../../../libs/spotify-i18n":341,"./json/ar.json":2,"./json/cs.json":3,"./json/de.json":4,"./json/el.json":5,"./json/en.json":6,"./json/es-419.json":7,"./json/es.json":8,"./json/fi.json":9,"./json/fr-CA.json":10,"./json/fr.json":11,"./json/hu.json":12,"./json/id.json":13,"./json/it.json":14,"./json/ja.json":15,"./json/ms.json":16,"./json/nl.json":17,"./json/pl.json":18,"./json/pt-BR.json":19,"./json/sv.json":20,"./json/th.json":21,"./json/tr.json":22,"./json/vi.json":23,"./json/zh-Hant.json":24}],2:[function(require,module,exports){
module.exports={
  "SongsNUXDescription": "ستظهر الأغاني المفضّلة لديك هنا. إذهب إلى صفحة <a href='spotify:app:browse:releases'>&quot;تصفّح&quot;</a> لاكتشاف قوائم أغاني رائعة تناسب مزاجك ولحظاتك.",
  "SongsNUXGoToNewReleases": "اذهب إلى تصفّح",
  "Songs": "أغاني",
  "FavoriteSongs": "الأغاني المفضلة",
  "EmptyFilterResultMessage": "لم يتم العثور على نتائج عن \"{0}\".",
  "RemoveFilter": "احذف الفلتر",
  "ConfirmRemoveTracks": {
    "one": "هل تريد حقًا حذف {0} أغنية من مكتبتك الموسيقية؟",
    "other": "هل تريد حقاً حذف {0} أغاني من مكتبتك الموسيقية؟"
  },
  "ConfirmRemoveTracksCancel": "إلغاء",
  "ConfirmRemoveTracksDelete": "احذف",
  "Download": "تنزيل",
  "DownloadSongs": {
    "one": "قم بتنزيل أغنية",
    "other": "قم بتنزيل الأغاني"
  },
  "Downloaded": "الأغاني التي تمّ تنزيلها",
  "DownloadedSongs": {
    "one": "تمّ تنزيل الأغنية",
    "other": "الأغاني التي تمّ تنزيلها"
  },
  "Downloading": "التنزيل جارٍ...",
  "WaitingForDownload": "جاري الانتظار...",
  "WaitingForConnection": "بانتظار الاتصال بالإنترنت…"
}
},{}],3:[function(require,module,exports){
module.exports={
  "SongsNUXDescription": "Tady se budou zobrazovat tvé oblíbené skladby. Mrkni na stránku <a href='spotify:app:browse:releases'>Procházet</a> , kde najdeš perfektní playlisty pro každou náladu a chvíli.",
  "SongsNUXGoToNewReleases": "Procházet",
  "Songs": "Skladby",
  "FavoriteSongs": "Oblíbené skladby",
  "EmptyFilterResultMessage": "Žádné výsledky pro „{0}“",
  "RemoveFilter": "Odstranit filtr",
  "ConfirmRemoveTracks": {
    "one": "Opravdu chceš ze sbírky Tvoje knihovna odstranit {0} skladbu?",
    "other": "Opravdu chceš ze sbírky Tvoje knihovna odstranit tento počet skladeb: {0}?"
  },
  "ConfirmRemoveTracksCancel": "Zrušit",
  "ConfirmRemoveTracksDelete": "Odstranit",
  "Download": "Stáhnout",
  "DownloadSongs": {
    "one": "Stáhnout skladbu",
    "other": "Stáhnout skladby"
  },
  "Downloaded": "Staženo",
  "DownloadedSongs": {
    "one": "Skladba je stažena.",
    "other": "Skladby jsou staženy."
  },
  "Downloading": "Stahování...",
  "WaitingForDownload": "Čekání...",
  "WaitingForConnection": "Čekáme na připojení..."
}
},{}],4:[function(require,module,exports){
module.exports={
  "SongsNUXDescription": "Hier werden deine Lieblingssongs angezeigt. Unter <a href='spotify:app:browse:releases'>Browse</a> findest du tolle Playlists für jede Stimmung und jeden Moment.",
  "SongsNUXGoToNewReleases": "Zu 'Browse' wechseln",
  "Songs": "Songs",
  "FavoriteSongs": "Lieblingssongs",
  "EmptyFilterResultMessage": "Keine Ergebnisse für \"{0}\".",
  "RemoveFilter": "Filter entfernen",
  "ConfirmRemoveTracks": {
    "one": "Möchtest du {0} Song wirklich aus deiner Bibliothek entfernen?",
    "other": "Möchtest du {0} Songs wirklich aus deiner Bibliothek entfernen?"
  },
  "ConfirmRemoveTracksCancel": "Abbrechen",
  "ConfirmRemoveTracksDelete": "Entfernen",
  "Download": "Herunterladen",
  "DownloadSongs": {
    "one": "Song herunterladen",
    "other": "Songs herunterladen"
  },
  "Downloaded": "Heruntergeladen",
  "DownloadedSongs": {
    "one": "Song heruntergeladen",
    "other": "Songs heruntergeladen"
  },
  "Downloading": "Wird heruntergeladen …",
  "WaitingForDownload": "Vorgang läuft …",
  "WaitingForConnection": "Verbindung wird hergestellt …"
}
},{}],5:[function(require,module,exports){
module.exports={
  "SongsNUXDescription": "Εδώ θα βρίσκεις τα αγαπημένα σου τραγούδια. Πήγαινε στη σελίδα <a href='spotify:app:browse:releases'>Περιήγηση</a> για να βρεις απίστευτες playlist για κάθε διάθεση και στιγμή.",
  "SongsNUXGoToNewReleases": "Μετάβαση στην Περιήγηση",
  "Songs": "Τραγούδια",
  "FavoriteSongs": "Αγαπημένα τραγούδια",
  "EmptyFilterResultMessage": "Δεν βρέθηκαν αποτελέσματα για \"{0}\".",
  "RemoveFilter": "Αφαίρεση φίλτρου",
  "ConfirmRemoveTracks": {
    "one": "Θες στ' αλήθεια να καταργήσεις {0} τραγούδι από τη Βιβλιοθ΄ήκη;",
    "other": "Θες στ' αλήθεια να καταργήσεις {0} τραγούδια από τη Βιβλιοθ΄ήκη;"
  },
  "ConfirmRemoveTracksCancel": "Ακύρωση",
  "ConfirmRemoveTracksDelete": "Αφαίρεση",
  "Download": "Λήψη",
  "DownloadSongs": {
    "one": "Κάνε download το τραγούδι",
    "other": "Κάνε download τα τραγούδια"
  },
  "Downloaded": "Έγινε λήψη",
  "DownloadedSongs": {
    "one": "Έγινε download του τραγουδιού",
    "other": "Έγινε download των τραγουδιών"
  },
  "Downloading": "Γίνεται download...",
  "WaitingForDownload": "Αναμονή...",
  "WaitingForConnection": "Αναμονή για σύνδεση..."
}
},{}],6:[function(require,module,exports){
module.exports={
  "SongsNUXDescription": "Your favorite songs will appear here. Go to your <a href='spotify:app:browse:releases'>Browse</a> page to find amazing playlists for every mood and moment.",
  "SongsNUXGoToNewReleases": "Go to Browse",
  "Songs": "Songs",
  "FavoriteSongs": "Favorite Songs",
  "EmptyFilterResultMessage": "No results for \"{0}\".",
  "RemoveFilter": "Remove Filter",
  "ConfirmRemoveTracks": {
    "one": "Do you really want to remove {0} song from Your Library?",
    "other": "Do you really want to remove {0} songs from Your Library?"
  },
  "ConfirmRemoveTracksCancel": "Cancel",
  "ConfirmRemoveTracksDelete": "Remove",
  "Download": "Download",
  "DownloadSongs": {
    "one": "Download Song",
    "other": "Download Songs"
  },
  "Downloaded": "Downloaded",
  "DownloadedSongs": {
    "one": "Song Downloaded",
    "other": "Songs Downloaded"
  },
  "Downloading": "Downloading...",
  "WaitingForDownload": "Waiting...",
  "WaitingForConnection": "Waiting for connection..."
}
},{}],7:[function(require,module,exports){
module.exports={
  "SongsNUXDescription": "Aquí aparecerán tus canciones favoritas. En la página <a href='spotify:app:browse:releases'>Explorar</a>, encontrarás playlists perfectas para todo momento y cada estado de ánimo.",
  "SongsNUXGoToNewReleases": "Ir a Explorar",
  "Songs": "Canciones",
  "FavoriteSongs": "Canciones favoritas",
  "EmptyFilterResultMessage": "No hay resultados para \"{0}\".",
  "RemoveFilter": "Eliminar filtro",
  "ConfirmRemoveTracks": {
    "one": "¿Estás seguro de que quieres eliminar {0} canción de Tu Biblioteca?",
    "other": "¿Estás seguro de que quieres eliminar {0} canciones de Tu Biblioteca?"
  },
  "ConfirmRemoveTracksCancel": "Cancelar",
  "ConfirmRemoveTracksDelete": "Eliminar",
  "Download": "Descargar",
  "DownloadSongs": {
    "one": "Descargar canción",
    "other": "Descargar canciones"
  },
  "Downloaded": "Descargados",
  "DownloadedSongs": {
    "one": "Canción descargada",
    "other": "Canciones descargadas"
  },
  "Downloading": "Descargando...",
  "WaitingForDownload": "Esperando...",
  "WaitingForConnection": "Esperando conexión..."
}
},{}],8:[function(require,module,exports){
module.exports={
  "SongsNUXDescription": "Aquí aparecerán tus canciones favoritas. Entra en tu página de <a href='spotify:app:browse:releases'>Explorar</a> para encontrar playlists alucinantes para cualquier momento o estado de ánimo.",
  "SongsNUXGoToNewReleases": "Ir a Explorar",
  "Songs": "Canciones",
  "FavoriteSongs": "Canciones favoritas",
  "EmptyFilterResultMessage": "No hay ningún resultado para \"{0}\".",
  "RemoveFilter": "Eliminar filtro",
  "ConfirmRemoveTracks": {
    "one": "¿Seguro que quieres retirar {0} canción de Tu biblioteca?",
    "other": "¿Seguro que quieres retirar {0} canciones de Tu biblioteca?"
  },
  "ConfirmRemoveTracksCancel": "Cancelar",
  "ConfirmRemoveTracksDelete": "Retirar",
  "Download": "Descargar",
  "DownloadSongs": {
    "one": "Descargar canción",
    "other": "Descargar canciones"
  },
  "Downloaded": "Descargadas",
  "DownloadedSongs": {
    "one": "Canción descargada",
    "other": "Canciones descargadas"
  },
  "Downloading": "Descargando...",
  "WaitingForDownload": "Esperando...",
  "WaitingForConnection": "Esperando la conexión..."
}
},{}],9:[function(require,module,exports){
module.exports={
  "SongsNUXDescription": "Suosikkikappaleesi näkyvät tässä. <a href='spotify:app:browse:releases'>Browse</a>-osiosta löydät sopivan soittolistan jokaiseen tilanteeseen ja fiilikseen.",
  "SongsNUXGoToNewReleases": "Siirry Browse-toimintoon",
  "Songs": "Kappaleet",
  "FavoriteSongs": "Suosikkikappaleet",
  "EmptyFilterResultMessage": "Ei tuloksia hakuehdolla {0}.",
  "RemoveFilter": "Poista suodatin",
  "ConfirmRemoveTracks": {
    "one": "Haluatko varmasti poistaa {0} kappaleen omasta kirjastostasi?",
    "other": "Haluatko varmasti poistaa {0} kappaletta omasta kirjastostasi?"
  },
  "ConfirmRemoveTracksCancel": "Peruuta",
  "ConfirmRemoveTracksDelete": "Poista",
  "Download": "Lataa",
  "DownloadSongs": {
    "one": "Lataa kappale",
    "other": "Lataa kappaleet"
  },
  "Downloaded": "Ladatut",
  "DownloadedSongs": {
    "one": "Kappale ladattu",
    "other": "Kappaleet ladattu"
  },
  "Downloading": "Ladataan…",
  "WaitingForDownload": "Odottaa…",
  "WaitingForConnection": "Odotetaan yhteyttä…"
}
},{}],10:[function(require,module,exports){
module.exports={
  "SongsNUXDescription": "Vous trouverez votre chansons préférées ici. Accédez à votre page <a href='spotify:app:browse:releases'>Parcourir</a> pour trouver des listes de lecture géniales pour toutes vos envies.",
  "SongsNUXGoToNewReleases": "Aller à Parcourir",
  "Songs": "Titres",
  "FavoriteSongs": "Chansons préférées",
  "EmptyFilterResultMessage": "Aucun résultat pour « {0} ».",
  "RemoveFilter": "Supprimer le filtre",
  "ConfirmRemoveTracks": {
    "one": "Voulez-vous vraiment supprimer {0} chanson de votre Bibliothèque?",
    "other": "Voulez-vous vraiment supprimer {0} chansons de votre Bibliothèque?"
  },
  "ConfirmRemoveTracksCancel": "Annuler",
  "ConfirmRemoveTracksDelete": "Supprimer",
  "Download": "Synchroniser",
  "DownloadSongs": {
    "one": "Télécharger la chanson",
    "other": "Télécharger des chansons"
  },
  "Downloaded": "Téléchargement terminé",
  "DownloadedSongs": {
    "one": "Chanson téléchargée",
    "other": "Chansons téléchargées"
  },
  "Downloading": "Téléchargement en cours…",
  "WaitingForDownload": "En attente…",
  "WaitingForConnection": "En attente de connexion…"
}
},{}],11:[function(require,module,exports){
module.exports={
  "SongsNUXDescription": "Vos titres préférés apparaîtront ici. Accédez à votre page <a href='spotify:app:browse:releases'>Parcourir</a> afin de trouver de super playlists pour toutes vos envies.",
  "SongsNUXGoToNewReleases": "Aller à Parcourir",
  "Songs": "Titres",
  "FavoriteSongs": "Titres préférés",
  "EmptyFilterResultMessage": "Aucun résultat pour « {0} ».",
  "RemoveFilter": "Supprimer le filtre",
  "ConfirmRemoveTracks": {
    "one": "Êtes-vous sûr de vouloir supprimer {0} titre de Bibliothèque ?",
    "other": "Êtes-vous sûr de vouloir supprimer {0} titres de Bibliothèque ?"
  },
  "ConfirmRemoveTracksCancel": "Annuler",
  "ConfirmRemoveTracksDelete": "Supprimer",
  "Download": "Télécharger",
  "DownloadSongs": {
    "one": "Télécharger le titre",
    "other": "Télécharger des titres"
  },
  "Downloaded": "Téléchargé(s)",
  "DownloadedSongs": {
    "one": "Titre téléchargé",
    "other": "Titres téléchargés"
  },
  "Downloading": "Téléchargement en cours…",
  "WaitingForDownload": "En attente...",
  "WaitingForConnection": "En attente de connexion…"
}
},{}],12:[function(require,module,exports){
module.exports={
  "SongsNUXDescription": "Itt jelennek meg a kedvenc dalaid. A <a href='spotify:app:browse:releases'>Böngészés</a> oldalon minden hangulathoz és pillanathoz találsz tökéletes műsorlistát.",
  "SongsNUXGoToNewReleases": "Böngészés lap megnyitása",
  "Songs": "Dalok",
  "FavoriteSongs": "Kedvenc dalok",
  "EmptyFilterResultMessage": "Nincs találat a keresett {0} kifejezésre.",
  "RemoveFilter": "Szűrő törlése",
  "ConfirmRemoveTracks": {
    "one": "Tényleg törölsz {0} dalt a Gyűjteményedből?",
    "other": "Tényleg törölsz {0} dalt a Gyűjteményedből?"
  },
  "ConfirmRemoveTracksCancel": "Mégse",
  "ConfirmRemoveTracksDelete": "Eltávolítás",
  "Download": "Letöltés",
  "DownloadSongs": {
    "one": "Dal letöltése",
    "other": "Dalok letöltése"
  },
  "Downloaded": "Letöltött",
  "DownloadedSongs": {
    "one": "Dal letöltve",
    "other": "Dalok letöltve"
  },
  "Downloading": "Letöltés...",
  "WaitingForDownload": "Várunk...",
  "WaitingForConnection": "Csatlakozásra vár..."
}
},{}],13:[function(require,module,exports){
module.exports={
  "SongsNUXDescription": "Lagu favoritmu akan ditampilkan di sini. Buka halaman <a href='spotify:app:browse:releases'>Browse</a> untuk menemukan playlist yang menarik untuk setiap suasana hati dan momen.",
  "SongsNUXGoToNewReleases": "Ke Browse",
  "Songs": "Lagu",
  "FavoriteSongs": "Lagu Favorit",
  "EmptyFilterResultMessage": "Tidak ada hasil untuk \"{0}\".",
  "RemoveFilter": "Hapus Filter",
  "ConfirmRemoveTracks": {
    "one": "Kamu yakin ingin menghapus {0} lagu dari Koleksi Kamu?",
    "other": "Kamu yakin ingin menghapus {0} lagu dari Koleksi Kamu?"
  },
  "ConfirmRemoveTracksCancel": "Batalkan",
  "ConfirmRemoveTracksDelete": "Hapus",
  "Download": "Download",
  "DownloadSongs": {
    "one": "Download Lagu",
    "other": "Download Lagu"
  },
  "Downloaded": "Didownload",
  "DownloadedSongs": {
    "one": "Lagu Di-download",
    "other": "Lagu yang Di-download"
  },
  "Downloading": "Mendownload...",
  "WaitingForDownload": "Menunggu...",
  "WaitingForConnection": "Menunggu terhubung..."
}
},{}],14:[function(require,module,exports){
module.exports={
  "SongsNUXDescription": "Qui trovi i tuoi brani preferiti. Vai alla pagina <a href='spotify:app:browse:releases'>Naviga</a> per scoprire playlist sorprendenti per qualsiasi momento e stato d'animo",
  "SongsNUXGoToNewReleases": "Vai a Naviga",
  "Songs": "Brani",
  "FavoriteSongs": "Brani preferiti",
  "EmptyFilterResultMessage": "Nessun risultato per \"{0}\"",
  "RemoveFilter": "Rimuovi filtro",
  "ConfirmRemoveTracks": {
    "one": "Vuoi davvero eliminare {0} brano da La tua libreria?",
    "other": "Vuoi davvero eliminare {0} brani da La tua libreria?"
  },
  "ConfirmRemoveTracksCancel": "Annulla",
  "ConfirmRemoveTracksDelete": "Rimuovi",
  "Download": "Download",
  "DownloadSongs": {
    "one": "Scarica brano",
    "other": "Scarica brani"
  },
  "Downloaded": "Download effettuato",
  "DownloadedSongs": {
    "one": "Brano scaricato",
    "other": "Brani scaricati"
  },
  "Downloading": "Download in corso…",
  "WaitingForDownload": "Attendi...",
  "WaitingForConnection": "In attesa della connessione..."
}
},{}],15:[function(require,module,exports){
module.exports={
  "SongsNUXDescription": "お気に入りの曲はここに表示されます。<a href='spotify:app:browse:releases'>Browse</a>ページにアクセスして、今の気分やシチュエーションにぴったりのプレイリストを見つけてください。",
  "SongsNUXGoToNewReleases": "Browseに進む",
  "Songs": "ソング",
  "FavoriteSongs": "お気に入りソング",
  "EmptyFilterResultMessage": "「{0}」に該当する結果は見つかりませんでした。",
  "RemoveFilter": "フィルターを削除",
  "ConfirmRemoveTracks": {
    "one": "本当にMy Musicから{0}曲を削除しますか？",
    "other": "本当にMy Musicから{0}曲を削除しますか？"
  },
  "ConfirmRemoveTracksCancel": "キャンセル",
  "ConfirmRemoveTracksDelete": "削除",
  "Download": "ダウンロード",
  "DownloadSongs": {
    "one": "曲をダウンロードする",
    "other": "曲をダウンロードする"
  },
  "Downloaded": "ダウンロード済み",
  "DownloadedSongs": {
    "one": "ダウンロード済みの曲",
    "other": "ダウンロード済みの曲"
  },
  "Downloading": "ダウンロード中...",
  "WaitingForDownload": "待機中...",
  "WaitingForConnection": "接続中です..."
}
},{}],16:[function(require,module,exports){
module.exports={
  "SongsNUXDescription": "Lagu kegemaran anda akan muncul di sini. Pergi ke laman <a href='spotify:app:browse:releases'>Semak Imbas</a> anda untuk mencari playlist yang menakjubkan bagi setiap emosi dan detik.",
  "SongsNUXGoToNewReleases": "Pergi ke Semak imbas",
  "Songs": "Lagu",
  "FavoriteSongs": "Lagu Kegemaran",
  "EmptyFilterResultMessage": "Tiada hasil untuk \"{0}\".",
  "RemoveFilter": "Keluarkan Penapis",
  "ConfirmRemoveTracks": {
    "one": "Adakah anda pasti mahu mengeluarkan {0} lagu dari Pustaka Anda?",
    "other": "Adakah anda pasti mahu mengeluarkan {0} lagu dari Pustaka Anda?"
  },
  "ConfirmRemoveTracksCancel": "Batal",
  "ConfirmRemoveTracksDelete": "Keluarkan",
  "Download": "Muat Turun ",
  "DownloadSongs": {
    "one": "Muat Turun Lagu",
    "other": "Muat Turun Lagu"
  },
  "Downloaded": "Telah dimuat turun",
  "DownloadedSongs": {
    "one": "Lagu Dimuat Turun",
    "other": "Lagu Dimuat Turun"
  },
  "Downloading": "Sedang memuat turun... ",
  "WaitingForDownload": "Sedang menunggu...",
  "WaitingForConnection": "Menunggu sambungan ..."
}
},{}],17:[function(require,module,exports){
module.exports={
  "SongsNUXDescription": "Je favoriete nummers worden hier weergegeven. Ga naar <a href='spotify:app:browse:releases'>Bladeren</a> om geweldige afspeellijsten te vinden voor elke stemming en voor ieder moment.",
  "SongsNUXGoToNewReleases": "Ga naar Bladeren.",
  "Songs": "Nummers",
  "FavoriteSongs": "Favoriete nummers",
  "EmptyFilterResultMessage": "Geen resultaten voor \"{0}\".",
  "RemoveFilter": "Filter verwijderen",
  "ConfirmRemoveTracks": {
    "one": "Wil je echt {0} nummer uit je Bibliotheek verwijderen?",
    "other": "Wil je echt {0} nummers uit je Bibliotheek verwijderen?"
  },
  "ConfirmRemoveTracksCancel": "Annuleren",
  "ConfirmRemoveTracksDelete": "Verwijderen",
  "Download": "Downloaden",
  "DownloadSongs": {
    "one": "Nummer downloaden",
    "other": "Nummers downloaden"
  },
  "Downloaded": "Gedownload",
  "DownloadedSongs": {
    "one": "Nummer gedownload",
    "other": "Nummers gedownload"
  },
  "Downloading": "Downloaden...",
  "WaitingForDownload": "Wachten...",
  "WaitingForConnection": "Wachten op verbinding ..."
}
},{}],18:[function(require,module,exports){
module.exports={
  "SongsNUXDescription": "Twoje ulubione utwory będą widoczne w tym miejscu. Przejdź na <a href='spotify:app:browse:releases'>stronę przeglądania</a> i znajdź fantastyczne playlisty na każdą okazję.",
  "SongsNUXGoToNewReleases": "Przejdź do katalogu przeglądania",
  "Songs": "Utwory",
  "FavoriteSongs": "Ulubione utwory",
  "EmptyFilterResultMessage": "Brak wyników wyszukiwania dla \"{0}\".",
  "RemoveFilter": "Usuń filtr",
  "ConfirmRemoveTracks": {
    "one": "Czy na pewno chcesz usunąć {0} utwór z Biblioteki?",
    "other": "Czy na pewno chcesz usunąć utwory ({0}) z Biblioteki?"
  },
  "ConfirmRemoveTracksCancel": "Anuluj",
  "ConfirmRemoveTracksDelete": "Usuń",
  "Download": "Pobieranie",
  "DownloadSongs": {
    "one": "Pobierz utwór",
    "other": "Pobierz utwory"
  },
  "Downloaded": "Pobrane",
  "DownloadedSongs": {
    "one": "Utwór został pobrany",
    "other": "Utwory zostały pobrane"
  },
  "Downloading": "Pobieranie...",
  "WaitingForDownload": "Oczekiwanie...",
  "WaitingForConnection": "Oczekiwanie na połączenie..."
}
},{}],19:[function(require,module,exports){
module.exports={
  "SongsNUXDescription": "Suas músicas favoritas aparecerão aqui. Na seção <a href='spotify:app:browse:releases'>Navegar</a>, você encontra as playlists perfeitas para embalar todos os momentos da sua vida.",
  "SongsNUXGoToNewReleases": "Ir para Navegar",
  "Songs": "Músicas",
  "FavoriteSongs": "Músicas Favoritas",
  "EmptyFilterResultMessage": "Nenhum resultado encontrado para \"{0}\".",
  "RemoveFilter": "Remover filtro",
  "ConfirmRemoveTracks": {
    "one": "Quer mesmo remover {0} música da Sua Biblioteca?",
    "other": "Quer mesmo remover {0} músicas da Sua Biblioteca?"
  },
  "ConfirmRemoveTracksCancel": "Cancelar",
  "ConfirmRemoveTracksDelete": "Remover",
  "Download": "Baixar",
  "DownloadSongs": {
    "one": "Baixar música",
    "other": "Baixar músicas"
  },
  "Downloaded": "Baixadas",
  "DownloadedSongs": {
    "one": "Música baixada",
    "other": "Músicas baixadas"
  },
  "Downloading": "Baixando…",
  "WaitingForDownload": "Esperando…",
  "WaitingForConnection": "Esperando uma conexão…"
}
},{}],20:[function(require,module,exports){
module.exports={
  "SongsNUXDescription": "Här visas dina favoritlåtar. Gå till <a href='spotify:app:browse:releases'>Utforska</a> och hitta fantastiska spellistor som passar alla stämningar och tillfällen.",
  "SongsNUXGoToNewReleases": "Gå till Utforska",
  "Songs": "Låtar",
  "FavoriteSongs": "Favoritlåtar",
  "EmptyFilterResultMessage": "Inga resultat för {0}.",
  "RemoveFilter": "Ta bort filter",
  "ConfirmRemoveTracks": {
    "one": "Vill du verkligen ta bort {0} från Ditt bibliotek?",
    "other": "Vill du verkligen ta bort {0} låtar från Ditt bibliotek?"
  },
  "ConfirmRemoveTracksCancel": "Avbryt",
  "ConfirmRemoveTracksDelete": "Ta bort",
  "Download": "Ladda ned",
  "DownloadSongs": {
    "one": "Ladda ned låt",
    "other": "Ladda ned låtar"
  },
  "Downloaded": "Nedladdat",
  "DownloadedSongs": {
    "one": "Låt nedladdad",
    "other": "Låtar nedladdade"
  },
  "Downloading": "Laddar ned ...",
  "WaitingForDownload": "Väntar ...",
  "WaitingForConnection": "Håller på att ansluta ..."
}
},{}],21:[function(require,module,exports){
module.exports={
  "SongsNUXDescription": "เพลงโปรดของคุณจะอยู่ที่นี่ ไปที่หน้า<a href='spotify:app:browse:releases'>รายการ</a>ของคุณเพื่อพบกับเพลย์ลิสต์โดนใจที่เหมาะกับทุกจังหวะอารมณ์",
  "SongsNUXGoToNewReleases": "ไปที่หน้ารายการ",
  "Songs": "เพลง",
  "FavoriteSongs": "เพลงโปรด",
  "EmptyFilterResultMessage": "ไม่พบผลการค้นหาสำหรับ \"{0}\"",
  "RemoveFilter": "ลบตัวกรองออก",
  "ConfirmRemoveTracks": {
    "one": "คุณต้องการลบ {0} เพลงออกจากคอลเลกชันของคุณจริงๆ ใช่ไหม",
    "other": "คุณต้องการลบ {0} เพลงออกจากคอลเลกชันของคุณจริงๆ ใช่ไหม"
  },
  "ConfirmRemoveTracksCancel": "ยกเลิก",
  "ConfirmRemoveTracksDelete": "นำออก",
  "Download": "ดาวน์โหลด",
  "DownloadSongs": {
    "one": "ดาวน์โหลดเพลง",
    "other": "ดาวน์โหลดเพลง"
  },
  "Downloaded": "ดาวน์โหลดแล้ว",
  "DownloadedSongs": {
    "one": "ดาวน์โหลดเพลงแล้ว",
    "other": "ดาวน์โหลดเพลงแล้ว"
  },
  "Downloading": "กำลังดาวน์โหลด...",
  "WaitingForDownload": "กำลังรอ...",
  "WaitingForConnection": "กำลังรอการเชื่อมต่อ..."
}
},{}],22:[function(require,module,exports){
module.exports={
  "SongsNUXDescription": "En sevdiğin şarkılar burada görünecek. Her ruh hali ve ana hitap eden harika çalma listeleri bulmak için <a href='spotify:app:browse:releases'>Göz at</a>'ına git.",
  "SongsNUXGoToNewReleases": "Gözat'a Git",
  "Songs": "Şarkılar",
  "FavoriteSongs": "Favori Şarkılar",
  "EmptyFilterResultMessage": "\"{0}\" için hiç sonuç bulunamadı.",
  "RemoveFilter": "Filtreyi Kaldır",
  "ConfirmRemoveTracks": {
    "one": "Kitaplığından {0} şarkıyı gerçekten kaldırmak istiyor musun?",
    "other": "Kitaplığın'dan {0} şarkıyı gerçekten kaldırmak istiyor musun?"
  },
  "ConfirmRemoveTracksCancel": "İptal",
  "ConfirmRemoveTracksDelete": "Çıkar",
  "Download": "İndir",
  "DownloadSongs": {
    "one": "Şarkı İndir",
    "other": "Şarkı İndir"
  },
  "Downloaded": "İndirilenler",
  "DownloadedSongs": {
    "one": "İndirilen Şarkı",
    "other": "İndirilen Şarkılar"
  },
  "Downloading": "İndiriliyor...",
  "WaitingForDownload": "Bekliyor...",
  "WaitingForConnection": "Bağlantı için bekleniyor..."
}
},{}],23:[function(require,module,exports){
module.exports={
  "SongsNUXDescription": "Các bài hát yêu thích của bạn sẽ hiển thị tại đây. Truy cập vào trang <a href='spotify:app:browse:releases'>Duyệt tìm</a> để tìm kiếm playlist thú vị cho từng khoảnh khắc và tâm trạng.",
  "SongsNUXGoToNewReleases": "Đi tới Duyệt tìm",
  "Songs": "Bài hát",
  "FavoriteSongs": "Bài hát Yêu thích",
  "EmptyFilterResultMessage": "Không tìm thấy kết quả cho \"{0}\".",
  "RemoveFilter": "Xoá Bộ lọc",
  "ConfirmRemoveTracks": {
    "one": "Bạn có thực sự muốn xóa {0} bài hát từ Thư viện của bạn?",
    "other": "Bạn có thực sự muốn xóa {0} bài hát từ Thư viện của bạn?"
  },
  "ConfirmRemoveTracksCancel": "Huỷ",
  "ConfirmRemoveTracksDelete": "Xóa",
  "Download": "Tải xuống",
  "DownloadSongs": {
    "one": "Tải xuống Bài hát",
    "other": "Tải xuống các Bài hát"
  },
  "Downloaded": "Đã tải xuống",
  "DownloadedSongs": {
    "one": "Bài hát đã Tải xuống",
    "other": "Bài hát đã Tải xuống"
  },
  "Downloading": "Đang tải xuống...",
  "WaitingForDownload": "Đang chờ...",
  "WaitingForConnection": "Đang chờ kết nối..."
}
},{}],24:[function(require,module,exports){
module.exports={
  "SongsNUXDescription": "你最喜愛的歌曲將在這裡顯示。前往<a href='spotify:app:browse:releases'>瀏覽</a>頁面，尋找適合不同心情和時刻的超讚播放清單。",
  "SongsNUXGoToNewReleases": "前往瀏覽",
  "Songs": "歌曲",
  "FavoriteSongs": "最愛的歌曲",
  "EmptyFilterResultMessage": "沒有「{0}」的搜尋結果。",
  "RemoveFilter": "移除篩選條件",
  "ConfirmRemoveTracks": {
    "one": "你確定要從你的音樂庫移除 {0} 首歌嗎？",
    "other": "你確定要從你的音樂庫移除 {0} 首歌嗎？"
  },
  "ConfirmRemoveTracksCancel": "取消",
  "ConfirmRemoveTracksDelete": "移除",
  "Download": "下載",
  "DownloadSongs": {
    "one": "下載歌曲",
    "other": "下載歌曲"
  },
  "Downloaded": "已下載",
  "DownloadedSongs": {
    "one": "歌曲已下載",
    "other": "多首歌曲已下載"
  },
  "Downloading": "下載中…",
  "WaitingForDownload": "等待中...",
  "WaitingForConnection": "正在等待連線..."
}
},{}],25:[function(require,module,exports){
(function (global){
"use strict";var _sentry=require("../../libs/sentry"),sentry=_interopRequireWildcard(_sentry),_spotifyHandlebars=require("../../libs/spotify-handlebars"),_spotifyHandlebars2=_interopRequireDefault(_spotifyHandlebars),_helpers=require("../../libs/spotify-handlebars/helpers"),_helpers2=_interopRequireDefault(_helpers),_header=require("../../libs/spotify-events/header"),_header2=_interopRequireDefault(_header),_sticky=require("../../libs/spotify-events/sticky"),_sticky2=_interopRequireDefault(_sticky),_filter=require("../../libs/spotify-events/filter"),_filter2=_interopRequireDefault(_filter),_rtl=require("../../libs/spotify-events/rtl"),_rtl2=_interopRequireDefault(_rtl),_center=require("../../libs/spotify-events/center"),_center2=_interopRequireDefault(_center),_glue=require("../../libs/glue"),_glue2=_interopRequireDefault(_glue),_i18n=require("./i18n"),_i18n2=_interopRequireDefault(_i18n),_cosmosApi=require("../../libs/cosmos-api"),_cosmosApi2=_interopRequireDefault(_cosmosApi),_live=require("../../libs/live"),_live2=_interopRequireDefault(_live),_spotifyLiburi=require("spotify-liburi"),_spotifyLiburi2=_interopRequireDefault(_spotifyLiburi),_abba=require("../../libs/abba"),_abba2=_interopRequireDefault(_abba),_player=require("../../libs/live-models/player"),_player2=_interopRequireDefault(_player),_application=require("../../libs/live-models/application"),_application2=_interopRequireDefault(_application),_client=require("../../libs/live-models/client"),_client2=_interopRequireDefault(_client),_add=require("../../libs/live-models/add"),_add2=_interopRequireDefault(_add),_controller=require("./src/controller"),_controller2=_interopRequireDefault(_controller),_i18n3=require("./src/facade/i18n"),_i18n4=_interopRequireDefault(_i18n3),_subscribeToPlayMessage=require("./src/subscribe-to-play-message"),_subscribeToPlayMessage2=_interopRequireDefault(_subscribeToPlayMessage),_subscribeToHighlightMessage=require("./src/subscribe-to-highlight-message"),_subscribeToHighlightMessage2=_interopRequireDefault(_subscribeToHighlightMessage),_bridge=require("../../libs/expose-dev-mode-debug-globals/bridge"),_bridge2=_interopRequireDefault(_bridge),_live3=require("../../libs/expose-dev-mode-debug-globals/live"),_live4=_interopRequireDefault(_live3),_cosmos=require("../../libs/expose-dev-mode-debug-globals/cosmos"),_cosmos2=_interopRequireDefault(_cosmos),_spfetch=require("../../libs/expose-dev-mode-debug-globals/spfetch"),_spfetch2=_interopRequireDefault(_spfetch),_errorAndOffline=require("./src/views/error-and-offline"),_errorAndOffline2=_interopRequireDefault(_errorAndOffline),_yourMusicSongsList=require("./src/views/your-music-songs-list"),_yourMusicSongsList2=_interopRequireDefault(_yourMusicSongsList),_yourMusicHeader=require("./src/views/your-music-header"),_yourMusicHeader2=_interopRequireDefault(_yourMusicHeader),_slider=require("../../libs/spotify-events/slider"),sliderEvents=_interopRequireWildcard(_slider),_offlineSlider=require("./src/offline-slider"),_offlineSlider2=_interopRequireDefault(_offlineSlider);function _interopRequireDefault(e){return e&&e.__esModule?e:{default:e}}function _interopRequireWildcard(e){if(e&&e.__esModule)return e;var i={};if(null!=e)for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&(i[r]=e[r]);return i.default=e,i}sentry.install(),_glue2.default.gridOverlay.listen(),_helpers2.default.loc.register(_i18n2.default.glueStrings()),_helpers2.default.loc.register(_i18n2.default.appStrings()),_helpers2.default.loc.setLocale(_i18n2.default.locale()),_helpers2.default.numeral.setLocale(_i18n2.default.locale()),_spotifyHandlebars2.default.register(_helpers2.default),_player2.default.register(),_application2.default.register(),_client2.default.register(),_add2.default.register();const uri=_spotifyLiburi2.default.collectionURI(global.__spotify.username).toURI(),views={error:_errorAndOffline2.default.init(document.getElementById("error-placeholder")),list:_yourMusicSongsList2.default.init(uri,document.getElementById("list-placeholder")),header:_yourMusicHeader2.default.init(document.getElementById("header-placeholder"))},dependencies={i18n:_i18n4.default,live:_live2.default,URI:_spotifyLiburi2.default,cosmos:_cosmosApi2.default,center:_center2.default,offlineSlider:new _offlineSlider2.default,abba:_abba2.default};(0,_controller2.default)(views,dependencies),_subscribeToPlayMessage2.default.init(uri,views.list),_subscribeToHighlightMessage2.default.init(uri,views.list),_header2.default.attach(),_sticky2.default.attach(),_filter2.default.attach(),sliderEvents.attach(),_rtl2.default.attach(),_bridge2.default.init(),_live4.default.init(),_cosmos2.default.init(),_spfetch2.default.init();

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../libs/abba":39,"../../libs/cosmos-api":45,"../../libs/expose-dev-mode-debug-globals/bridge":54,"../../libs/expose-dev-mode-debug-globals/cosmos":55,"../../libs/expose-dev-mode-debug-globals/live":57,"../../libs/expose-dev-mode-debug-globals/spfetch":58,"../../libs/glue":83,"../../libs/live":192,"../../libs/live-models/add":164,"../../libs/live-models/application":171,"../../libs/live-models/client":172,"../../libs/live-models/player":177,"../../libs/sentry":230,"../../libs/spotify-events/center":246,"../../libs/spotify-events/filter":260,"../../libs/spotify-events/header":261,"../../libs/spotify-events/rtl":300,"../../libs/spotify-events/slider":310,"../../libs/spotify-events/sticky":312,"../../libs/spotify-handlebars":338,"../../libs/spotify-handlebars/helpers":327,"./i18n":1,"./src/controller":26,"./src/facade/i18n":27,"./src/offline-slider":28,"./src/subscribe-to-highlight-message":29,"./src/subscribe-to-play-message":30,"./src/views/error-and-offline":32,"./src/views/your-music-header":33,"./src/views/your-music-songs-list":35,"spotify-liburi":475}],26:[function(require,module,exports){
(function (global){
"use strict";Object.defineProperty(exports,"__esModule",{value:!0});const ABBA_FLAG_COLLECTION_SONGS_DOWNLOAD=exports.ABBA_FLAG_COLLECTION_SONGS_DOWNLOAD="desktop_collection_songs_download";async function init(e,o){e.error.render({errorMessage:o.i18n("SongsNUXDescription"),errorEscapeMessage:o.i18n("SongsNUXGoToNewReleases"),errorEscapeUrl:"spotify:app:browse"}),e.list.emitter.on("is-empty",o=>{e.error.isVisible(o)});const t=!!top.initialState&&top.initialState.useNftUi,s=(s,n=null)=>{const r={pageHeader:{background:{type:"color"},buttons:{playButton:!0},title:t?o.i18n("FavoriteSongs"):o.i18n("Songs"),uri:s},slider:n};e.header.render(r)};o.cosmos.resolver.post({url:"sp://messages/v1/container/control",body:{type:"update_menu_state",enable_filter_item:!0}}),o.center.on("drop",e=>{for(const t in e.data)e.data.hasOwnProperty(t)&&e.data[t].forEach(e=>{o.live(e).publish({added:!0})})}),o.cosmos.resolver.subscribe("sp://messages/v1/container/control",(e,t)=>{if(e)throw e;if(o.live("spotify:application").get("active")){const e=t.getJSONBody();e&&"paste"===e.type&&o.cosmos.resolver.get("sp://desktop/v1/clipboard",(e,t)=>{if(e)throw e;const s=t.getJSONBody();(s&&s.data||"").trim().split(/\s+/g).forEach(e=>{const t=o.URI.from(e);switch(t&&t.type){case o.URI.Type.TRACK:case o.URI.Type.ALBUM:o.live(t.toString()).publish({added:!0})}})})}}),window.parent.postMessage({type:"notify_ready",pageId:"collection-songs"},"*"),window.parent.postMessage({type:"notify_loaded",pageId:"collection/songs",now:window.parent.performance.now()},"*");const n=global.__spotify.username,r=o.URI.collectionURI(n).toURI();s(r);let i=!1;try{i="Enabled"===await o.abba.fetch(ABBA_FLAG_COLLECTION_SONGS_DOWNLOAD)}catch(e){console.error(`Could not fetch ABBA flag "${ABBA_FLAG_COLLECTION_SONGS_DOWNLOAD}": ${e}`)}i&&(o.offlineSlider.subscribeToOfflineSyncUpdates(r,(e,t)=>{if(!e&&t){const e={offline:t,formatListType:"not-shows"},n=o.offlineSlider.createSliderData(r,e);s(r,n)}}),o.center.on("slider-change",e=>{o.offlineSlider.onDownloadSliderChange(e)}))}exports.default=init;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],27:[function(require,module,exports){
"use strict";var _i18n=require("../../i18n"),_i18n2=_interopRequireDefault(_i18n);function _interopRequireDefault(e){return e&&e.__esModule?e:{default:e}}module.exports=(e=>_i18n2.default.get(e));

},{"../../i18n":1}],28:[function(require,module,exports){
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.DOWNLOAD_SLIDER_ID=void 0;var _offlineStatus=require("./../../../libs/playlist-utils/offline-status.js"),OfflineStatus=_interopRequireWildcard(_offlineStatus),_i18n=require("../i18n"),i18n=_interopRequireWildcard(_i18n),_center=require("../../../libs/spotify-events/center"),_center2=_interopRequireDefault(_center),_bridge=require("../../../libs/bridge"),_bridge2=_interopRequireDefault(_bridge),_abba=require("../../../libs/abba"),_abba2=_interopRequireDefault(_abba);function _interopRequireDefault(e){return e&&e.__esModule?e:{default:e}}function _interopRequireWildcard(e){if(e&&e.__esModule)return e;var i={};if(null!=e)for(var t in e)Object.prototype.hasOwnProperty.call(e,t)&&(i[t]=e[t]);return i.default=e,i}const DOWNLOAD_SLIDER_ID=exports.DOWNLOAD_SLIDER_ID="collection-songs-download-slider";class OfflineSlider{constructor({abbaFetch:e=_abba2.default.fetch.bind(_abba2.default),centerEmit:i=_center2.default.emit.bind(_center2.default),bridgeCosmos:t=_bridge2.default.cosmosJSON.bind(_bridge2.default)}={}){this._offlineSync=this._offlineSync.bind(this),this.abbaFetch=e,this.centerEmit=i,this.bridgeCosmos=t,this.offlineAvailabilityUpdates={}}createSliderData(e,i){const t=OfflineStatus.getLabelForStatus(i.offline,"format-shows"===i.formatListType),r=OfflineStatus.shouldBeOffline(i.offline);return{id:DOWNLOAD_SLIDER_ID,label:i18n.get(t),uri:e,enabled:r}}_offlineSync(e,i,t){this.bridgeCosmos({method:i?"POST":"DELETE",uri:`sp://offline/v1/resources?uri=${e}`},t)}subscribeToOfflineSyncUpdates(e,i){this.bridgeCosmos({method:"SUB",uri:`sp://offline/v1/resources?uri=${e}`},(t,r)=>{if(t)i(t);else if(r&&r.resources){const t=r.resources.offline_availability;if(t===this.offlineAvailabilityUpdates[e])return;this.offlineAvailabilityUpdates[e]=t,i(null,t)}})}onDownloadSliderChange(e){if(!e.id||e.id!==DOWNLOAD_SLIDER_ID)return;const i=e.element.dataset.uri;if(!i)return;const t=e.enabled;t||this.centerEmit("slider-set",{id:DOWNLOAD_SLIDER_ID,enabled:!1});this._offlineSync(i,t,function(){})}}exports.default=OfflineSlider;

},{"../../../libs/abba":39,"../../../libs/bridge":41,"../../../libs/spotify-events/center":246,"../i18n":1,"./../../../libs/playlist-utils/offline-status.js":222}],29:[function(require,module,exports){
"use strict";var _ensuredCosmosMessage=require("../../../libs/ensured-cosmos-message"),_ensuredCosmosMessage2=_interopRequireDefault(_ensuredCosmosMessage);function _interopRequireDefault(e){return e&&e.__esModule?e:{default:e}}exports.init=((e,s)=>{const o=new Promise(e=>{s.onReady(()=>{e(s)})});_ensuredCosmosMessage2.default.subscribe("highlight-context-index",(s,r)=>{if(s)throw s;r.uri===e&&o.then(e=>{e.scrollTo(r.index)})})});

},{"../../../libs/ensured-cosmos-message":53}],30:[function(require,module,exports){
"use strict";var _ensuredCosmosMessage=require("../../../libs/ensured-cosmos-message"),_ensuredCosmosMessage2=_interopRequireDefault(_ensuredCosmosMessage),_live=require("../../../libs/live"),_live2=_interopRequireDefault(_live);function _interopRequireDefault(e){return e&&e.__esModule?e:{default:e}}exports.init=(e=>{_ensuredCosmosMessage2.default.subscribe("your-music-songs-play",()=>{(0,_live2.default)("spotify:player").emit("play",{context:e})})});

},{"../../../libs/ensured-cosmos-message":53,"../../../libs/live":192}],31:[function(require,module,exports){
"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var _confirmDialog=require("../../templates/confirm-dialog.hbs"),_confirmDialog2=_interopRequireDefault(_confirmDialog);function _interopRequireDefault(i){return i&&i.__esModule?i:{default:i}}const confirmDialog={init(){return this.confirmDialogContainer=document.querySelector("#confirm-delete-container"),this.hideFn=this.hide.bind(this),this.handleClickFn=this.handleClick.bind(this),this.handleKeyupFn=this.handleKeyup.bind(this),this},show(i,e){this.confirmCallback=e,this.confirmDialogContainer.innerHTML=(0,_confirmDialog2.default)({numberOfTracks:i}),this.confirmDialogContainer.classList.remove("hidden"),this.confirmDialogContainer.addEventListener("click",this.handleClickFn),document.addEventListener("click",this.hideFn),document.addEventListener("keyup",this.handleKeyupFn)},handleClick(i){i.preventDefault();const{target:e}=i;"confirm-button"===e.id?(this.confirmCallback(),this.hide()):"cancel-button"===e.id&&this.hide()},handleKeyup(i){const{key:e}=i;"Enter"===e?(this.confirmCallback(),this.hide()):"Escape"===e&&this.hide()},hide(){this.confirmDialogContainer.removeEventListener("click",this.handleClickFn),document.removeEventListener("click",this.hideFn),document.removeEventListener("keyup",this.handleKeyupFn),this.confirmDialogContainer.innerHTML="",this.confirmDialogContainer.classList.add("hidden")}};exports.default=confirmDialog;

},{"../../templates/confirm-dialog.hbs":36}],32:[function(require,module,exports){
"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var _errorAndOffline=require("../../../../libs/glue/templates/error-and-offline.hbs"),_errorAndOffline2=_interopRequireDefault(_errorAndOffline);function _interopRequireDefault(e){return e&&e.__esModule?e:{default:e}}const errorView={init(e){return this.targetNode=e,this},isVisible(e){this.targetNode.style.display=e?"block":"none"},render(e){this.targetNode.innerHTML=(0,_errorAndOffline2.default)(e)}};exports.default=errorView;

},{"../../../../libs/glue/templates/error-and-offline.hbs":98}],33:[function(require,module,exports){
"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var _spotifyEvents=require("../../../../libs/spotify-events"),_spotifyEvents2=_interopRequireDefault(_spotifyEvents),_header=require("../../templates/header.hbs"),_header2=_interopRequireDefault(_header);function _interopRequireDefault(e){return e&&e.__esModule?e:{default:e}}const headerView={init(e){return this.targetNode=e,this},render(e){this.targetNode.innerHTML=(0,_header2.default)(e),_spotifyEvents2.default.update(this.targetNode)}};exports.default=headerView;

},{"../../../../libs/spotify-events":286,"../../templates/header.hbs":38}],34:[function(require,module,exports){
"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var _dateFormatter=require("../../../../../libs/date-formatter"),_dateFormatter2=_interopRequireDefault(_dateFormatter),_cosmosApi=require("../../../../../libs/cosmos-api"),_cosmosApi2=_interopRequireDefault(_cosmosApi);function _interopRequireDefault(e){return e&&e.__esModule?e:{default:e}}const endpoints={all:"sp://core-collection/unstable/@/list/tracks/all",items:"sp://core-collection/v1/items"},DEFAULT_SORTING="sort=addTime DESC,album.name,album.artist.name,discNumber,trackNumber";function makeSortQuery(e){if(!e||!e.sorting)return DEFAULT_SORTING;const t=e.sorting[0][0],r=e.sorting[0][1];if(!t)return DEFAULT_SORTING;const i="descending"===r?"DESC":"ASC";return`sort=${{name:`name ${i}`,artists:`artist.name ${i},album.name,discNumber,trackNumber`,album:`album.name ${i},discNumber,trackNumber`,timeSinceAdded:`addTime ${"DESC"===i?"ASC":"DESC"},album.name,album.artist.name,discNumber,trackNumber`,duration:`length ${i}`,descending:"DESC",ascending:"ASC"}[t]}`}function makeFilterQuery(e){return e&&e.filter?`filter=text contains ${e.filter}`:""}function makeCorepheusResponseGlueFriendly(e){return e.items.map(e=>{const t="yes"===e.offline;return{track:{uri:e.link,name:e.name,album:{uri:e.album.link,name:e.album.name},artists:e.artists.map(e=>({uri:e.link,name:e.name})),duration:e.length?1e3*e.length:0,playable:e.playable,shouldBeOffline:t,offlineProgress:t?1:0,isInCollection:!0,added:!0,explicit:e.isExplicit},dateAdded:(0,_dateFormatter2.default)(1e3*e.addTime),dateAddedNumber:1e3*e.addTime}})}exports.default={getRangeOfRowData(e,t,r,i){const a=`${endpoints.all}?start=${e}&length=${t}&${makeSortQuery(r)}&${makeFilterQuery(r)}`;_cosmosApi2.default.resolver.get({url:a,body:{policy:{list:{link:!0,addTime:!0,name:!0,index:!0,length:!0,playable:!0,offline:!0,isExplicit:!0,album:{link:!0,name:!0},artists:{link:!0,name:!0}}}}},(e,t)=>{if(e)throw e;const r=makeCorepheusResponseGlueFriendly(t.getJSONBody());i(null,r)})},getAllURIs(e,t){const r=`${endpoints.all}?decorate=false&${makeSortQuery(e)}&${makeFilterQuery(e)}`;_cosmosApi2.default.resolver.get({url:r,body:{policy:{list:{link:!0}}}},(e,r)=>{if(e)throw e;const i=r.getJSONBody().items.map(e=>e.link);t(null,i)})},onChange(e){_cosmosApi2.default.resolver.subscribe({url:endpoints.all,body:{policy:{list:{link:!1}}}},t=>{if(t)throw t;e(null)})},removeDataRow(e){const t=new _cosmosApi2.default.Request("DELETE",endpoints.items,[],{items:[e]});_cosmosApi2.default.resolver.resolve(t,e=>{if(e)throw e})}};

},{"../../../../../libs/cosmos-api":45,"../../../../../libs/date-formatter":51}],35:[function(require,module,exports){
"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var _corepheus=require("./corepheus"),_corepheus2=_interopRequireDefault(_corepheus),_virtualSongsList=require("../../../../../libs/virtual-songs-list"),_virtualSongsList2=_interopRequireDefault(_virtualSongsList),_tracklistPlaylist=require("../../../../../libs/glue/templates/tracklist-playlist.hbs"),_tracklistPlaylist2=_interopRequireDefault(_tracklistPlaylist),_tracklistPlaylistRow=require("../../../../../libs/glue/templates/tracklist-playlist-row.hbs"),_tracklistPlaylistRow2=_interopRequireDefault(_tracklistPlaylistRow),_emptyFilteredPlaylist=require("../../../templates/empty-filtered-playlist.hbs"),_emptyFilteredPlaylist2=_interopRequireDefault(_emptyFilteredPlaylist),_confirmDialog=require("../confirm-dialog"),_confirmDialog2=_interopRequireDefault(_confirmDialog);function _interopRequireDefault(e){return e&&e.__esModule?e:{default:e}}const listView={init(e,t){const l=(0,_virtualSongsList2.default)({listURI:e,targetNode:t,listTemplate:_tracklistPlaylist2.default,rowTemplate:_tracklistPlaylistRow2.default,filterEmptyTemplate:_emptyFilteredPlaylist2.default,getAllSongURIs:_corepheus2.default.getAllURIs,getSongsDataRange:_corepheus2.default.getRangeOfRowData,removeDataRow:_corepheus2.default.removeDataRow,confirmRemoveDataRows:_confirmDialog2.default.show.bind(_confirmDialog2.default),sortable:!0});return _corepheus2.default.onChange(()=>{l.refresh()}),_confirmDialog2.default.init(),l}};exports.default=listView;

},{"../../../../../libs/glue/templates/tracklist-playlist-row.hbs":119,"../../../../../libs/glue/templates/tracklist-playlist.hbs":120,"../../../../../libs/virtual-songs-list":346,"../../../templates/empty-filtered-playlist.hbs":37,"../confirm-dialog":31,"./corepheus":34}],36:[function(require,module,exports){
var HandlebarsCompiler=require("hbsfy/runtime");module.exports=HandlebarsCompiler.template({compiler:[7,">= 4.0.0"],main:function(n,t,a,o,e){var c=null!=t?t:n.nullContext||{},i=a.helperMissing,l=n.escapeExpression;return'<div id="modal-backdrop" class="modal-backdrop fade in"></div>\n<div id="modal" class="popover modal modal-generic no-scroll fade in">\n  <div class="popover-content confirm-dialog" data-interaction-context="confirm-remove-tracks-dialog">\n    <p>'+l((a.loc||t&&t.loc||i).call(c,"ConfirmRemoveTracks",null!=t?t.numberOfTracks:t,{name:"loc",hash:{},data:e}))+'</p>\n    <div>\n      <button type="button" class="button button-with-stroke" id="cancel-button" data-interaction-target="cancel-button" data-interaction-intent="cancel">\n        '+l((a.loc||t&&t.loc||i).call(c,"ConfirmRemoveTracksCancel",{name:"loc",hash:{},data:e}))+'\n      </button>\n      <button type="button" class="button button-red" id="confirm-button" data-interaction-target="confirm-button" data-interaction-intent="confirm">\n        '+l((a.loc||t&&t.loc||i).call(c,"ConfirmRemoveTracksDelete",{name:"loc",hash:{},data:e}))+"\n      </button>\n    </div>\n  </div>\n</div>\n"},useData:!0});

},{"hbsfy/runtime":383}],37:[function(require,module,exports){
var HandlebarsCompiler=require("hbsfy/runtime");module.exports=HandlebarsCompiler.template({compiler:[7,">= 4.0.0"],main:function(e,t,a,l,n){var r,i=null!=t?t:e.nullContext||{},o=a.helperMissing,s=e.escapeExpression;return'<div class="empty-filtered-content" data-uri="'+s("function"==typeof(r=null!=(r=a.uri||(null!=t?t.uri:t))?r:o)?r.call(i,{name:"uri",hash:{},data:n}):r)+'">\n  <p>\n    '+s((a.loc||t&&t.loc||o).call(i,"EmptyFilterResultMessage",null!=t?t.filterRequestValue:t,{name:"loc",hash:{},data:n}))+'\n    <a class="remove-filter-button" data-interaction-target="remove-filter-button" data-interaction-intent="remove-filter" data-filter-reset>'+s((a.loc||t&&t.loc||o).call(i,"RemoveFilter",{name:"loc",hash:{},data:n}))+"</a>\n  </p>\n</div>\n"},useData:!0});

},{"hbsfy/runtime":383}],38:[function(require,module,exports){
var HandlebarsCompiler=require("hbsfy/runtime"),partial$0=require("../../../libs/glue/templates/headers/page-header.hbs");HandlebarsCompiler.registerPartial("../../../libs/glue/templates/headers/page-header.hbs",partial$0);var partial$1=require("../../../libs/glue/templates/header/search-field.hbs");HandlebarsCompiler.registerPartial("../../../libs/glue/templates/header/search-field.hbs",partial$1);var partial$2=require("../../../libs/glue/templates/slider.hbs");HandlebarsCompiler.registerPartial("../../../libs/glue/templates/slider.hbs",partial$2),module.exports=HandlebarsCompiler.template({1:function(e,a,l,r,s){var i,t;return"        "+e.escapeExpression("function"==typeof(t=null!=(t=l.label||(null!=a?a.label:a))?t:l.helperMissing)?t.call(null!=a?a:e.nullContext||{},{name:"label",hash:{},data:s}):t)+"\n"+(null!=(i=e.invokePartial(r["../../../libs/glue/templates/slider.hbs"],a,{name:"../../../libs/glue/templates/slider.hbs",data:s,indent:"        ",helpers:l,partials:r,decorators:e.decorators}))?i:"")},compiler:[7,">= 4.0.0"],main:function(e,a,l,r,s){var i,t,n,d='<div data-uri="'+e.escapeExpression(e.lambda(null!=(i=null!=a?a.pageHeader:a)?i.uri:i,a))+'">\n  <div class="app-header__content">\n'+(null!=(i=e.invokePartial(r["../../../libs/glue/templates/headers/page-header.hbs"],null!=a?a.pageHeader:a,{name:"../../../libs/glue/templates/headers/page-header.hbs",data:s,indent:"    ",helpers:l,partials:r,decorators:e.decorators}))?i:"")+'  </div>\n  <div class="app-header__filter container">\n    <div class="app-header__filter--search-field">\n'+(null!=(i=e.invokePartial(r["../../../libs/glue/templates/header/search-field.hbs"],a,{name:"../../../libs/glue/templates/header/search-field.hbs",data:s,indent:"      ",helpers:l,partials:r,decorators:e.decorators}))?i:"")+'    </div>\n    <div class="app-header__filter--offline-sync">\n';return t=null!=(t=l.slider||(null!=a?a.slider:a))?t:l.helperMissing,n={name:"slider",hash:{},fn:e.program(1,s,0),inverse:e.noop,data:s},i="function"==typeof t?t.call(null!=a?a:e.nullContext||{},n):t,l.slider||(i=l.blockHelperMissing.call(a,i,n)),null!=i&&(d+=i),d+"    </div>\n  </div>\n</div>\n"},usePartial:!0,useData:!0});

},{"../../../libs/glue/templates/header/search-field.hbs":101,"../../../libs/glue/templates/headers/page-header.hbs":114,"../../../libs/glue/templates/slider.hbs":117,"hbsfy/runtime":383}],39:[function(require,module,exports){
"use strict";var _cosmosApi=require("../cosmos-api"),_cosmosApi2=_interopRequireDefault(_cosmosApi),_jsonStableStringify=require("json-stable-stringify"),_jsonStableStringify2=_interopRequireDefault(_jsonStableStringify);function _interopRequireDefault(e){return e&&e.__esModule?e:{default:e}}let subscriptions=[];function _getFlagsFromCosmos(e,s){_cosmosApi2.default.resolver.post({url:"sp://abba/v1/flags",body:{flags:e}},(e,t)=>{if(e)s(e);else{const{flags:e=[]}=t.getJSONBody();s(null,e)}})}function fetch(e){if("string"==typeof e)return fetch([e]).then(s=>s[e]);const s={},t=readOverrides(),r=e.reduce((e,r)=>(t.hasOwnProperty(r)?(console.warn(`Abba: Override for ${r} : ${t[r]}`),s[r]=t[r]):e.push(r),e),[]);return r.length?new Promise((t,o)=>{_getFlagsFromCosmos(r,(r,n)=>{r?o(r):(n.forEach(e=>{s[e.featureName]=e.cell}),Object.keys(s).length!==e.length&&e.forEach(e=>{s.hasOwnProperty(e)||(s[e]=null)}),t(s))})}):Promise.resolve(s)}function get(e,s){const t=readOverrides();if(t.hasOwnProperty(e))return console.warn(`Abba: Override for ${e} : ${t[e]}`),void setTimeout(()=>s(null,t[e]),0);_getFlagsFromCosmos([e],(t,r)=>{if(t)return void s(t);const o=r[0]&&r[0].featureName===e&&r[0].cell;s(null,o||null)})}function getAll(e){console.warn("Abba:getAll should only be used by TA tests for logging purposes."),_cosmosApi2.default.resolver.get({url:"sp://abba/v1/all_flags",body:{}},(s,t)=>{if(s)e(s);else{const{flags:s=[]}=t.getJSONBody(),r=s.reduce((e,s)=>(e[s.featureName]=s.cell,e),{});e(null,(0,_jsonStableStringify2.default)(r,{space:2}))}})}function getRequestedFlagNames(e){_cosmosApi2.default.resolver.get({url:"sp://abba/v1/requested_flag_names",body:{}},(s,t)=>{s?e(s):e(null,JSON.stringify(t.getJSONBody().sort(),null,2))})}function subscribe(e,s){let t;const r=e=>{e!==t&&(t=e,s(null,e))};let o=_cosmosApi2.default.resolver.subscribe({url:"sp://abba/v1/flags",body:{flags:[e]}},t=>{t?s(t):get(e,(e,t)=>{e?s(e):r(t)})}),n={cancel:()=>{o&&o.cancel();const s=subscriptions[e].indexOf(n);-1!==s&&subscriptions[e].splice(s,1),n=o=null},_update:r};return e in subscriptions||(subscriptions[e]=[]),subscriptions[e].push(n),n}function clearSubscriptions(){subscriptions=[]}function readOverrides(){const e="undefined"!=typeof __spotify&&__spotify.product_state?__spotify.product_state.abbaOverrides||__spotify.product_state.abbaoverrides:"";if(e)try{return JSON.parse(e)}catch(s){console.error("error parsing value=%o, error=%o",e,s)}return{}}module.exports={get:get,subscribe:subscribe,clearSubscriptions:clearSubscriptions,fetch:fetch},"undefined"!=typeof window&&(window.abba={get:get,getAll:getAll,getRequestedFlagNames:getRequestedFlagNames});

},{"../cosmos-api":45,"json-stable-stringify":385}],40:[function(require,module,exports){
"use strict";const TEN_PER_SECOND_FOR_A_YEAR=31536e4,COSMOS_VERBS=["GET","HEAD","POST","PUT","SUB","PATCH","DELETE"],ERROR_PREFIX="bridge.cosmosRequest: ";function cosmosRequest(e,t,o,r){if(o.url)throw new Error(`${ERROR_PREFIX}"url" is not a valid option, did you mean "uri"?`);if("string"!=typeof o.uri)throw new Error(`${ERROR_PREFIX}Expected uri to be string.`);if(-1===COSMOS_VERBS.indexOf(o.method))throw new Error(`${ERROR_PREFIX}Method must match valid verb in uppercase (GET, POST etc)`);if(o.body&&"string"!=typeof o.body)throw new Error(`${ERROR_PREFIX}If body is provided it should be a string.`);if(o.headers&&"[object Object]"!==Object.prototype.toString.call(o.headers))throw new Error(`${ERROR_PREFIX}Expected headers be a plain object.`);const s={action:o.method,uri:o.uri};o.body&&(s.body=o.body),o.headers&&(s.headers=o.headers),e.requestIDCounter=e.requestIDCounter||TEN_PER_SECOND_FOR_A_YEAR,e.requestIDCounter++;const n=[e.requestIDCounter,s];let u=!1;const i=e.requestIDCounter;return function e(s,i){t(s?"cosmos_request_create":"cosmos_request_pull",n,function(s,n){if(!u)try{r&&(s?r(s):r(null,n))}finally{"SUB"!==o.method?t("cosmos_request_cancel",[i]):u||e(!1,i)}})}(!0,i),function(){u=!0,t("cosmos_request_cancel",[i])}}module.exports=cosmosRequest;

},{}],41:[function(require,module,exports){
(function (global){
"use strict";const debug=require("../debug")("bridge"),defer=require("spotify-deferred"),cosmosBaseFunction=require("./cosmos");let scheduledCoreFlush=!1,cosmosState=null;function cosmos(){cosmosState||(cosmosState={});const e=[cosmosState,request];return cosmosBaseFunction.apply(null,e.concat(Array.prototype.slice.call(arguments)))}function _createCallbackWrapper(e){return function(t,s){let r=t;if(r)e(r,s);else{if(s&&!s.body&&s.status>=400)return r=new Error(`${s.uri} responded with status ${s.status}`),void e(r,s);let t;try{t=JSON.parse(s.body)}catch(t){return t.message=`Failed to parse cosmos response: ${t.message}`,void e(t)}e(null,t)}}}function cosmosJSON(e,t){return e.body&&(e.body=JSON.stringify(e.body)),cosmos(e,t?_createCallbackWrapper(t):null)}function request(e,t,s){const r=t||[],o=getCallback(e,r,s);return debug(`req:${e}`,r),exports._request(e,r,o),e.endsWith("_metadata")&&!scheduledCoreFlush&&(scheduledCoreFlush=!0,defer(flushCore)),exports}function _request(e,t,s){global&&"function"==typeof global._getSpotifyModule&&global._getSpotifyModule("bridge").executeRequest(JSON.stringify({name:e,args:t}),{onSuccess:getSuccessHandler(s),onFailure:getFailureHandler(s,e,t)})}function getCallback(e,t,s){const r=s||function(){};return function(s,o){if(s&&"timeout"===s.name){const o=300+Math.floor(100*Math.random());return debug("timeout",s.message),void setTimeout(function(){request(e,t,r)},o)}debug(`res:${e}`,t,o),r(s,o)}}function getSuccessHandler(e){return function(t){let s;debug("success",t);try{s=JSON.parse(t)}catch(t){e(t)}s&&e(null,s)}}function getFailureHandler(e,t,s){return function(r){let o;debug("failure",r);try{o=JSON.parse(r)}catch(t){r instanceof Error?e(r):(t.message+=`\nResponse Data: ${r}`,e(t))}o&&e(createError(t,s,o))}}function createError(e,t,s){const r=` (bridge message: '${e}', args: ${JSON.stringify(t)})`,o=s.message+r,u=new Error(o);return u.name=s.error,u}function flushCore(){scheduledCoreFlush=!1,request("core_flush")}exports.cosmos=cosmos,exports.cosmosJSON=cosmosJSON,exports.request=request,exports._request=_request;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../debug":52,"./cosmos":40,"spotify-deferred":470}],42:[function(require,module,exports){
"use strict";Object.defineProperty(exports,"__esModule",{value:!0});const operationCanceledError={name:"OperationCanceledError",message:"An async operation was cancelled"};class CancellationToken{constructor(e){this.source=e,this.requestId=e.requestId}isCanceled(){return this.requestId!==this.source.requestId}throwIfCanceled(){if(this.isCanceled())throw operationCanceledError}errorIfCanceled(){if(this.isCanceled())return operationCanceledError}operationCanceledError(){return operationCanceledError}}class CancellationTokenSource{constructor(){this.requestId=0}token(){return new CancellationToken(this)}cancel(){this.requestId++}}exports.default=CancellationTokenSource;

},{}],43:[function(require,module,exports){
(function (global){
"use strict";Object.defineProperty(exports,"__esModule",{value:!0});const hasFlag=exports.hasFlag=(t=>!!(global.__spotify&&global.__spotify.product_state&&global.__spotify.product_state.hasOwnProperty(t))),hasValue=exports.hasValue=((t,s)=>hasFlag(t)&&global.__spotify.product_state[t]===s);

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],44:[function(require,module,exports){
"use strict";const parser=require("../live/util/parser"),sortMap={track:{_replace:"",artists:{_replace:"artist"},disc:{_replace:"discNumber"},number:{_replace:"trackNumber"},duration:{_replace:"length"}},timeSinceAdded:{_reverse:!0,_replace:"addTime"},addedBy:{_replace:"",name:{_replace:"addedByDisplayName"}}};function reverse(e){return"ASC"===e?"DESC":"ASC"}function walk(e,r,a,s){const t=[],c=s&&s.slice()||[];return e.mask.forEach(e=>{const s=c.slice();if(e.key){let t=r&&r[e.key]&&null!==r[e.key]._replace&&void 0!==r[e.key]._replace?r[e.key]._replace:e.key;if(""!==t){if(!e.mask){const s=!!(r&&r[e.key]&&r[e.key]._reverse);if(a){const e=a.toUpperCase();t+=` ${s?reverse(e):e}`}}s.push(t)}}if(e.mask){const c=walk(e,r[e.key],a,s);c.length&&t.push(c)}else s.length&&t.push(s.join("."))}),t}function getParams(e,r,a){const s=parser(e);return e?walk(s,a||sortMap,r).join(","):null}module.exports=getParams;

},{"../live/util/parser":195}],45:[function(require,module,exports){
(function (global){
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.resolver=exports.Resolver=exports.Response=exports.Request=exports.Action=void 0;var _request=require("./request"),_response=require("./response"),_resolver=require("./resolver");const window=global.window||{},bridge=window._getSpotifyModule&&"function"==typeof window._getSpotifyModule&&window._getSpotifyModule("bridge"),resolver=bridge?new _resolver.Resolver(bridge):new _resolver.NullResolver;exports.default={Action:_request.Action,Request:_request.Request,Response:_response.Response,Resolver:_resolver.Resolver,resolver:resolver},exports.Action=_request.Action,exports.Request=_request.Request,exports.Response=_response.Response,exports.Resolver=_resolver.Resolver,exports.resolver=resolver;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./request":47,"./resolver":48,"./response":49}],46:[function(require,module,exports){
"use strict";function stringify(e){return"string"!=typeof e?JSON.stringify(e):e}Object.defineProperty(exports,"__esModule",{value:!0});class Message{constructor(e,r,t){if("string"!=typeof e)throw new TypeError("Invalid `uri` argument for Message.");this._uri=e,this._headers=this._headersToLowerCase(r),this._body=stringify(t||"")}static fromObject(e){return e&&e.uri?new Message(e.uri,e.headers,e.body):null}getURI(){return this._uri}getMimeType(){return this._headers.accept}getHeader(e){return this._headers[e.toLowerCase()]||null}getHeaders(){return this._copyHeaders(null)}getBody(){return this._body}getJSONBody(){try{return JSON.parse(this._body)}catch(e){return null}}copy(e,r){return new Message(this._uri,this._copyHeaders(e),void 0!==r?r:this._body)}serialize(){return this.toJSON()}toJSON(){return{uri:this._uri,headers:this._headers,body:this._body}}_headersToLowerCase(e){return null===e||"object"!=typeof e?{}:Object.keys(e).reduce((r,t)=>(r[t.toLowerCase()]=e[t],r),{})}_copyHeaders(e){return Object.assign({},this._headers,this._headersToLowerCase(e))}}exports.Message=Message;

},{}],47:[function(require,module,exports){
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.Request=exports.Action=void 0;var _message=require("./message");const Action=exports.Action={DELETE:"DELETE",GET:"GET",HEAD:"HEAD",POST:"POST",PUT:"PUT",SUB:"SUB",PATCH:"PATCH"};class Request extends _message.Message{constructor(e,t,s,r){if("string"!=typeof e)throw new TypeError("Invalid `action` argument for Request.");super(t,s,r),this._action=e}static fromObject(e){return e&&e.action&&e.uri?new Request(e.action,e.uri,e.headers,e.body):null}getAction(){return this._action}copy(e,t){return new Request(this._action,this._uri,this._copyHeaders(e),void 0!==t?t:this._body)}toJSON(){return{action:this._action,uri:this._uri,headers:this._headers,body:this._body}}}exports.Request=Request;

},{"./message":46}],48:[function(require,module,exports){
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.NullResolver=exports.Resolver=void 0;var _request=require("./request"),_response=require("./response");function isSuccessStatus(e){return e>=200&&e<=299}class Resolver{constructor(e){if(!e||"function"!=typeof e.executeRequest)throw new TypeError("Missing or invalid `bridge` parameter");this._bridge=e,this._requestId=1e6}resolve(e,s){return this._resolve(e,s)}get(e,s){return this._resolveFromParams(_request.Action.GET,e,s)}post(e,s){return this._resolveFromParams(_request.Action.POST,e,s)}subscribe(e,s){return this._resolveFromParams(_request.Action.SUB,e,s)}put(e,s){return this._resolveFromParams(_request.Action.PUT,e,s)}patch(e,s){return this._resolveFromParams(_request.Action.PATCH,e,s)}delete(e,s){return this._resolveFromParams(_request.Action.DELETE,e,s)}_sendRequest(e,s,t){return new Promise((r,n)=>{const o=JSON.stringify({name:e,args:[s,t]});this._bridge.executeRequest(o,{onSuccess:e=>{r(JSON.parse(e))},onFailure:e=>{n(JSON.parse(e))}})})}_parseResponse(e,s){const t=_response.Response.fromObject(s);if(null===t)throw new Error(`Failed to parse response: ${s}`);const r=t.getStatusCode();if(!isSuccessStatus(r)){const s=new Error(`Request to ${e.getURI()} failed with status code ${r}`);throw s.response=t,s}return t}async _createRequestAsync(e,s){const t=s.toJSON(),r=await this._sendRequest("cosmos_request_create",e,t);return this._parseResponse(s,r)}async _pullRequestAsync(e,s){const t=await this._sendRequest("cosmos_request_pull",e,{uri:s.getURI()});return this._parseResponse(s,t)}async _cancelRequestAsync(e){await this._sendRequest("cosmos_request_cancel",e)}_doResolve(e,s){const t=++this._requestId,r={isCancelled:!1};return this._createRequestAsync(t,e).then(e=>{r.isCancelled||s(null,e),this._cancelRequestAsync(t)}).catch(e=>{r.isCancelled||s(e,e.response||null)}),{cancel:()=>{r.isCancelled=!0,this._cancelRequestAsync(t)}}}_doSubscribe(e,s){const t=++this._requestId,r={isCancelled:!1},n=()=>r.isCancelled?Promise.resolve():this._pullRequestAsync(t,e).then(e=>{r.isCancelled||s(null,e)}).then(n);return this._createRequestAsync(t,e).then(e=>(r.isCancelled||s(null,e),n())).catch(e=>{r.isCancelled||s(e,e.response||null)}),{cancel:()=>{r.isCancelled=!0,this._cancelRequestAsync(t)}}}_resolve(e,s){const t="function"==typeof s?s:()=>{};return e.getAction()===_request.Action.SUB?this._doSubscribe(e,t):this._doResolve(e,t)}_resolveFromParams(e,s,t){const r=s||{},n="string"==typeof r?r:r.url,o=r.headers,c=r.body,u=new _request.Request(e,n,o,c);return this._resolve(u,t)}}exports.Resolver=Resolver;class NullResolver{resolve(){return{cancel:()=>{}}}get(){return{cancel:()=>{}}}post(){return{cancel:()=>{}}}subscribe(){return{cancel:()=>{}}}put(){return{cancel:()=>{}}}patch(){return{cancel:()=>{}}}delete(){return{cancel:()=>{}}}}exports.NullResolver=NullResolver;

},{"./request":47,"./response":49}],49:[function(require,module,exports){
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.Response=exports.StatusCode=void 0;var _message=require("./message");const StatusCode=exports.StatusCode={OK:200,CREATED:201,ACCEPTED:202,BAD_REQUEST:400,UNAUTHORIZED:401,FORBIDDEN:403,NOT_FOUND:404,METHOD_NOT_ALLOWED:405,TIMED_OUT:408,CONFLICT:409,GONE:410,INTERNAL_SERVER_ERROR:500,NOT_IMPLEMENTED:501,BAD_GATEWAY:502,SERVICE_UNAVAILABLE:503,ERROR_UNKNOWN:-100,ERROR_ALLOCATION_FAILED:-101,ERROR_INVALID_ENCODING:-102,ERROR_INFINITE_LOOP:-103,ERROR_RESOLVER_NOT_FOUND:-104};class Response extends _message.Message{constructor(e,s,t,r){if("number"!=typeof s)throw new TypeError("Invalid `status` argument for Response.");super(e,t,r),this._status=s}static fromObject(e){return e&&e.uri&&e.status?new Response(e.uri,e.status,e.headers,e.body):null}getMimeType(){return this._headers["content-type"]}getStatusCode(){return this._status}copy(e,s){return new Response(this._uri,this._status,this._copyHeaders(e),void 0!==s?s:this._body)}toJSON(){return{uri:this._uri,status:this._status,headers:this._headers,body:this._body}}}exports.Response=Response;

},{"./message":46}],50:[function(require,module,exports){
"use strict";const FIFTEEN_DAYS_IN_MS=1296e6;module.exports=function(e,t){const n=Date.now();if(!t)return"";if(n-t>1296e6){const e=new Date(t);return`${e.getUTCFullYear()}-${`0${e.getUTCMonth()+1}`.slice(-2)}-${`0${e.getUTCDate()}`.slice(-2)}`}return e(t).from(n)};

},{}],51:[function(require,module,exports){
"use strict";const locale=window.__spotify&&window.__spotify.locale||"en",moment=require("../spotify-moment")(locale),formatDate=require("./format-date");module.exports=function(e){return formatDate(moment,e)};

},{"../spotify-moment":343,"./format-date":50}],52:[function(require,module,exports){
"use strict";let debug,initialized=!1;const spDebug=function e(t){if(!initialized){if(debug=require("debug"),e.enable=debug.enable.bind(debug),e.disable=debug.disable.bind(debug),"undefined"!=typeof window&&window.frameElement){const e=window.frameElement.getAttribute("data-debug");e&&debug.enable(e)}const t="undefined"!=typeof __spotify&&__spotify.product_state?__spotify.product_state:{},i=t.debugEnable||t.debugenable;i&&debug.enable(i),"undefined"!=typeof __spotify&&__spotify.product_state&&"1"===__spotify.product_state["ta-environment"]&&(debug.useColors=(()=>!1),debug.formatters.o=(e=>{try{return JSON.stringify(e)}catch(e){return console.error("Unable to stringify object",e),""}})),initialized=!0}return debug(t)};module.exports=spDebug;

},{"debug":360}],53:[function(require,module,exports){
"use strict";const cosmos=require("../cosmos-api").default,sub=cosmos.resolver.subscribe.bind(cosmos.resolver),post=cosmos.resolver.post.bind(cosmos.resolver),PREFIX="sp://messages/v1/ensured-",send=function(s,o){const e=`${PREFIX+s}-payload`,c=sub(`${PREFIX+s}-ready`,function(){post({url:e,body:o})}),n=sub(`${PREFIX+s}-ack`,function(){c.cancel(),n.cancel()});post({url:e,body:o})},subscribe=function(s,o){const e=sub(`${PREFIX+s}-payload`,function(e,c){post(`${PREFIX+s}-ack`),o(e,c&&c.getJSONBody())});return post(`${PREFIX+s}-ready`),{cancel:e.cancel.bind(e)}};module.exports={send:send,subscribe:subscribe};

},{"../cosmos-api":45}],54:[function(require,module,exports){
(function (global){
"use strict";exports.init=function(){require("./").expose(global,"bridge",require("../bridge"))};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../bridge":41,"./":56}],55:[function(require,module,exports){
(function (global){
"use strict";exports.init=function(){require("./").expose(global,"cosmos",require("../cosmos-api").default)};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../cosmos-api":45,"./":56}],56:[function(require,module,exports){
"use strict";exports.expose=function(e,o,n,s){e.__spotify&&e.__spotify.developer_mode&&Object.defineProperty(e,o,{get:function(){return(s||console.warn.bind(console))(`window.${o} should only be accessed from the `+"console! If you see this and did not use the console something is misbehaving."),n},enumerable:!0,configurable:!0})};

},{}],57:[function(require,module,exports){
(function (global){
"use strict";exports.init=function(){require("./").expose(global,"live",require("../live"))};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../live":192,"./":56}],58:[function(require,module,exports){
(function (global){
"use strict";exports.init=function(){require("./").expose(global,"spfetch",require("../http-requests").spFetch)};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../http-requests":156,"./":56}],59:[function(require,module,exports){
(function (global){
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.addDebouncedScrollListener=addDebouncedScrollListener,exports.removeDebouncedScrollListener=removeDebouncedScrollListener,exports.requestFrame=requestFrame,exports.cancelFrame=cancelFrame,exports._reset=_reset;let scrollNodeToListenerInfoList=new global.Map,idToScrollNode={},frameListenerInfoList=[],hasQueuedScroll=!1,lastScrollEvent=null,lastFrameRequestId=0,globalIdCounter=0;function onScroll(e){if(lastScrollEvent=e,!hasQueuedScroll){hasQueuedScroll=!0;const o=scrollNodeToListenerInfoList.get(e.target);if(o){let e;requestFrame(()=>{hasQueuedScroll=!1,callReadHandlers(e=o.slice(),lastScrollEvent)},()=>{callWriteHandlers(e,lastScrollEvent)})}}}function onFrame(e){lastFrameRequestId=0;const o=frameListenerInfoList;frameListenerInfoList=[],callReadHandlers(o,e),callWriteHandlers(o,e)}function callReadHandlers(e,o){e.forEach(e=>{e.readFunction&&e.readFunction(o)})}function callWriteHandlers(e,o){e.forEach(e=>{"function"==typeof e.writeFunction&&e.writeFunction(o)})}function addDebouncedScrollListener(e,o,r){if(null!==o&&"function"!=typeof o)throw new TypeError("The callback provided to addDebouncedScrollListener as parameter 2 is not a function.");if(void 0!==r&&"function"!=typeof r)throw new TypeError("The callback provided to addDebouncedScrollListener as parameter 3 is not a function.");scrollNodeToListenerInfoList.has(e)||(e.addEventListener("scroll",onScroll),scrollNodeToListenerInfoList.set(e,[]));const t=++globalIdCounter,n={id:t,readFunction:o,writeFunction:r};return idToScrollNode[t]=e,scrollNodeToListenerInfoList.get(e).push(n),t}function removeDebouncedScrollListener(e){const o=idToScrollNode[e];if(o){delete idToScrollNode[e];const r=scrollNodeToListenerInfoList.get(o);if(r)for(let o=0;o<r.length;o++)if(r[o].id===e){r.splice(o,1);break}0===r.length&&(o.removeEventListener("scroll",onScroll),scrollNodeToListenerInfoList.delete(o))}}function requestFrame(e,o){if(null!==e&&"function"!=typeof e)throw new TypeError("The callback provided to requestFrame as parameter 1 is not a function.");if(void 0!==o&&"function"!=typeof o)throw new TypeError("The callback provided to requestFrame as parameter 2 is not a function.");0===lastFrameRequestId&&(lastFrameRequestId=window.requestAnimationFrame(onFrame));const r=++globalIdCounter,t={id:r,readFunction:e,writeFunction:o};return frameListenerInfoList.push(t),r}function cancelFrame(e){for(let o=0;o<frameListenerInfoList.length;o++)if(frameListenerInfoList[o].id===e){frameListenerInfoList.splice(o,1);break}0!==lastFrameRequestId&&0===frameListenerInfoList.length&&(window.cancelAnimationFrame(lastFrameRequestId),lastFrameRequestId=0)}function _reset(){scrollNodeToListenerInfoList=new global.Map,idToScrollNode={},frameListenerInfoList=[],hasQueuedScroll=!1,lastScrollEvent=null,lastFrameRequestId=0,globalIdCounter=0}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],60:[function(require,module,exports){
module.exports={
  "Album": "ألبوم",
  "AndMore": "و {0} أكثر",
  "Artist": "الفنان",
  "By": "من",
  "ByLabel": "من",
  "Create Similar Playlist": "قم بإنشاء قائمة أغاني مماثلة",
  "DateAdded": "تاريخ الإضافة",
  "Duration": "المدة الزمنية",
  "Recommended Songs": "الأغاني المقترحة",
  "Filter": "فلتر",
  "Follow": "تابع",
  "Follower": "متابع",
  "FollowersLabel": {
    "one": "متابع",
    "other": "متابعون"
  },
  "FollowersCount": {
    "one": "{0} متابع",
    "other": "{0} متابعين"
  },
  "Following": "متابع",
  "FollowingLabel": "متابع",
  "ListenersLabel": "مستمعون شهرياً",
  "FollowsYou": "يتابعك",
  "HoldToPreview": "انقر وامسك للعرض المسبق",
  "ListenCount": {
    "one": "1 مرة استماع",
    "other": "{0} استماع"
  },
  "ListenReactionMulti": "{0} مستمع في شبكتك",
  "ListenReactionSingle": "{0} يستمع إلى هذه الأغنية",
  "LocalFile": "الأغاني المُحملة",
  "More": "المزيد",
  "MoreSongsLoad": "يتم تحميل المزيد من الأغاني أثناء الاستماع",
  "Pause": "إيقاف مؤقّت",
  "Play": "استمع",
  "Playlist": "قائمة الأغاني",
  "PressEnterToPlay": "انقر Shift +Enter للاستماع",
  "Popularity": "الشعبية",
  "Progress": "تقدم",
  "Remove": "احذف",
  "RemoveYourMusic": "احذف من مكتبتك الموسيقية",
  "RemoveFromYourFavoriteSongs": "احذف من الأغاني المفضلة",
  "Save": "احفظ",
  "SaveYourMusic": "احفظها في مكتبتك الموسيقية",
  "SaveToYourFavoriteSongs": "احفظ في الأغاني المفضلة",
  "Saved": "تمّ الحفظ",
  "StartRadio": "إبدأ الراديو",
  "Time": "الوقت",
  "Title": "عنوان",
  "Toplist": "الأغاني الأكثر استماعاً",
  "Track": "الأغنية",
  "Unfollow": "ألغي المتابعة",
  "User": "المستخدم",
  "ViewAll": "عرض جميع النتائج",
  "HoursShort": "{0} ساعة",
  "MinutesShort": "{0} دقيقة",
  "SecondsShort": "{0} ثانية",
  "ErrorTitle": "وقعت مشكلة أثناء عرض هذه الصفحة!",
  "ErrorMessage": "هذه الصفحة إما غير موجودة أو حدث خطأ ما.",
  "OfflineTitle": "هذه الصفحة غير متوفرة عندما تكون غير متصل بشبكة الإنترنت!",
  "OfflineMessage": "يرجى الاتصال بشبكة الإنترنت للتحميل.",
  "MadeFor": "تمّ إعدادها لـ {0}",
  "heart_label": "أعجبني",
  "undo_heart_label": "أعجبني",
  "ban_label": "احذف",
  "format_list.ban_label": "لا يعجبني",
  "nft.ban_song_label": "إخفاء هذه الأغنية",
  "nft.undo_ban_song_label": "إلغي إخفاء هذه الأغنية",
  "format_list.undo_ban_label": "لا يعجبني ذلك",
  "VariousArtistsCapitalized": "فنانون متنوعون"
}
},{}],61:[function(require,module,exports){
module.exports={
  "Album": "Album",
  "AndMore": "a {0} další(ch)",
  "Artist": "Umělec",
  "By": "od",
  "ByLabel": "Od",
  "Create Similar Playlist": "Vytvořit podobný playlist",
  "DateAdded": "Datum přidání",
  "Duration": "Délka",
  "Recommended Songs": "Doporučené skladby",
  "Filter": "Filtr",
  "Follow": "Sledovat",
  "Follower": "Sledující",
  "FollowersLabel": {
    "one": "Sledující",
    "other": "sledujících"
  },
  "FollowersCount": {
    "one": "{0} sledující",
    "other": "{0} sledujících"
  },
  "Following": "Sleduješ",
  "FollowingLabel": "Sleduješ",
  "ListenersLabel": "Posluchačů měsíčně",
  "FollowsYou": "Sleduje tě",
  "HoldToPreview": "Pro náhled klikni a podrž",
  "ListenCount": {
    "one": "1 přehrání",
    "other": "{0} přehrání"
  },
  "ListenReactionMulti": "{0} posluchačů ve tvé síti",
  "ListenReactionSingle": "{0} uživatelů tohle poslouchá",
  "LocalFile": "Místní soubory",
  "More": "dalších",
  "MoreSongsLoad": "Během přehrávání se načtou další skladby.",
  "Pause": "Pozastavit",
  "Play": "Přehrát",
  "Playlist": "Playlist",
  "PressEnterToPlay": "Přehrávání spustíš přes Shift + Enter.",
  "Popularity": "Popularita",
  "Progress": "Postup",
  "Remove": "Odstranit",
  "RemoveYourMusic": "Odstranit ze sbírky Tvoje knihovna",
  "RemoveFromYourFavoriteSongs": "Odstranit ze sbírky Oblíbené skladby",
  "Save": "Uložit",
  "SaveYourMusic": "Uložit do sbírky Tvoje knihovna",
  "SaveToYourFavoriteSongs": "Uložit do sbírky Oblíbené skladby",
  "Saved": "Uloženo",
  "StartRadio": "Spustit rádio",
  "Time": "Čas",
  "Title": "Název",
  "Toplist": "Top skladby",
  "Track": "Skladba",
  "Unfollow": "Přestat sledovat",
  "User": "Uživatel",
  "ViewAll": "Zobrazit vše",
  "HoursShort": "{0} h",
  "MinutesShort": "{0} min",
  "SecondsShort": "{0} s",
  "ErrorTitle": "Při zobrazování této stránky došlo k problému!",
  "ErrorMessage": "Tato stránka buď neexistuje, nebo došlo k chybě.",
  "OfflineTitle": "Tato stránka není dostupná offline!",
  "OfflineMessage": "Pro načtení přejdi prosím online.",
  "MadeFor": "Speciálně pro uživatele {0}",
  "heart_label": "Líbí se mi",
  "undo_heart_label": "Líbilo se mi",
  "ban_label": "Odstranit",
  "format_list.ban_label": "Nelíbí se mi",
  "nft.ban_song_label": "Skrýt tuto skladbu",
  "nft.undo_ban_song_label": "Tuto skladbu už neskrývat",
  "format_list.undo_ban_label": "Tohle se ti nelíbí",
  "VariousArtistsCapitalized": "Různí umělci"
}
},{}],62:[function(require,module,exports){
module.exports={
  "Album": "Album",
  "AndMore": "und {0} weitere",
  "Artist": "Künstler",
  "By": "von",
  "ByLabel": "Von",
  "Create Similar Playlist": "Ähnliche Playlist erstellen",
  "DateAdded": "Datum hinzugefügt",
  "Duration": "Dauer",
  "Recommended Songs": "Empfohlene Songs",
  "Filter": "Filter",
  "Follow": "Folgen",
  "Follower": "Follower",
  "FollowersLabel": {
    "one": "Follower",
    "other": "Follower"
  },
  "FollowersCount": {
    "one": "{0} Follower",
    "other": "{0} Follower"
  },
  "Following": "Folge ich",
  "FollowingLabel": "Folge ich",
  "ListenersLabel": "Monatliche Hörer",
  "FollowsYou": "Folgt dir",
  "HoldToPreview": "Zum Reinhören gedrückt halten",
  "ListenCount": {
    "one": "1 Wiedergabe",
    "other": "{0} Mal abgespielt"
  },
  "ListenReactionMulti": "{0} Hörer in Deinem Netzwerk",
  "ListenReactionSingle": "{0} hört sich das an",
  "LocalFile": "Lokale Datei",
  "More": "Mehr",
  "MoreSongsLoad": "Während du Musik hörst, werden weitere Songs geladen.",
  "Pause": "Pause",
  "Play": "Play",
  "Playlist": "Playlist",
  "PressEnterToPlay": "Drück gleichzeitig die Umschalt- und Eingabetaste zum Abspielen",
  "Popularity": "Beliebtheit",
  "Progress": "Fortschritt",
  "Remove": "Entfernen",
  "RemoveYourMusic": "Aus Bibliothek entfernen",
  "RemoveFromYourFavoriteSongs": "Aus deinen Lieblingssongs entfernen",
  "Save": "Speichern",
  "SaveYourMusic": "In Bibliothek speichern",
  "SaveToYourFavoriteSongs": "In deinen Lieblingssongs speichern",
  "Saved": "Gespeichert",
  "StartRadio": "Radio starten",
  "Time": "Dauer",
  "Title": "Titel",
  "Toplist": "Top-Songs",
  "Track": "Song",
  "Unfollow": "Nicht mehr folgen",
  "User": "Benutzer",
  "ViewAll": "Mehr Darstellung",
  "HoursShort": "{0} Std.",
  "MinutesShort": "{0} Min.",
  "SecondsShort": "{0} Sek.",
  "ErrorTitle": "Bei der Anzeige dieser Seite ist ein Fehler aufgetreten.",
  "ErrorMessage": "Diese Seite ist entweder nicht vorhanden oder es ist ein Fehler aufgetreten.",
  "OfflineTitle": "Diese Seite ist offline nicht verfügbar.",
  "OfflineMessage": "Geh zum Laden online.",
  "MadeFor": "Für {0}",
  "heart_label": "Gefällt mir",
  "undo_heart_label": "Gefällt mir",
  "ban_label": "Entfernen",
  "format_list.ban_label": "Gefällt mir nicht",
  "nft.ban_song_label": "Diesen Song ausblenden",
  "nft.undo_ban_song_label": "Diesen Song nicht mehr ausblenden",
  "format_list.undo_ban_label": "Das gefällt dir nicht",
  "VariousArtistsCapitalized": "Diverse Künstler"
}
},{}],63:[function(require,module,exports){
module.exports={
  "Album": "Άλμπουμ",
  "AndMore": "και άλλοι {0}",
  "Artist": "Καλλιτέχνης",
  "By": "από",
  "ByLabel": "Από",
  "Create Similar Playlist": "Δημιουργία παρόμοιας playlist",
  "DateAdded": "Προστέθηκε ημερομηνία",
  "Duration": "Διάρκεια",
  "Recommended Songs": "Προτεινόμενα τραγούδια",
  "Filter": "Φίλτρο",
  "Follow": "Ακολούθησε",
  "Follower": "Οπαδός",
  "FollowersLabel": {
    "one": "Οπαδός",
    "other": "Ακόλουθοι"
  },
  "FollowersCount": {
    "one": "{0} οπαδός",
    "other": "{0} οπαδοί"
  },
  "Following": "Aκολουθείται",
  "FollowingLabel": "Aκολουθείται",
  "ListenersLabel": "Μηνιαίοι ακροατές",
  "FollowsYou": "Σε ακολουθεί",
  "HoldToPreview": "Πάτησε και κράτησε πατημένο για προεπισκόπηση",
  "ListenCount": {
    "one": "1 αναπαραγωγή",
    "other": "{0} αναπαραγωγές"
  },
  "ListenReactionMulti": "{0} ακροατές στο δίκτυό σου",
  "ListenReactionSingle": "Ο χρήστης {0} ακούει αυτό",
  "LocalFile": "Τοπικό αρχείο",
  "More": "Περισσότερα",
  "MoreSongsLoad": "Περισσότερα τραγούδια φορτώνουν ενώ ακούς",
  "Pause": "Παύση",
  "Play": "Αναπαραγωγή",
  "Playlist": "Λίστα",
  "PressEnterToPlay": "Πάτα Shift + Enter για αναπαραγωγή",
  "Popularity": "Δημοφιλία",
  "Progress": "Πρόοδος",
  "Remove": "Αφαίρεση",
  "RemoveYourMusic": "Αφαίρεση από τη Βιβλιοθήκη",
  "RemoveFromYourFavoriteSongs": "Αφαίρεση από τα Αγαπημένα σου τραγούδια",
  "Save": "Αποθήκευση",
  "SaveYourMusic": "Αποθήκευση στη Βιβλιοθήκη",
  "SaveToYourFavoriteSongs": "Αποθήκευση στα Αγαπημένα σου τραγούδια",
  "Saved": "Αποθηκεύτηκε",
  "StartRadio": "Έναρξη ράδιο",
  "Time": "Διάρκεια",
  "Title": "Τίτλος",
  "Toplist": "Κορυφαία τραγούδια",
  "Track": "Τραγούδι",
  "Unfollow": "Άρση ακολούθησης",
  "User": "Χρήστης",
  "ViewAll": "Δες τα όλα",
  "HoursShort": "{0} ώρα",
  "MinutesShort": "{0} λεπ.",
  "SecondsShort": "{0} δευτ.",
  "ErrorTitle": "Παρουσιάστηκε πρόβλημα κατά την προβολή αυτής της σελίδας!",
  "ErrorMessage": "Αυτή η σελίδα δεν υπάρχει ή προέκυψε κάποιο σφάλμα.",
  "OfflineTitle": "Αυτή η σελίδα δεν είναι διαθέσιμη εκτός σύνδεσης!",
  "OfflineMessage": "Συνδέσου στο διαδίκτυο για να πραγματοποιηθεί φόρτωση.",
  "MadeFor": "Ειδικά για: {0}",
  "heart_label": "Μου αρέσει",
  "undo_heart_label": "Αρέσει σε",
  "ban_label": "Αφαίρεση",
  "format_list.ban_label": "Δεν μου αρέσει",
  "nft.ban_song_label": "Απόκρυψη αυτού του τραγουδιού",
  "nft.undo_ban_song_label": "Παύση της απόκρυψης αυτού του τραγουδιού",
  "format_list.undo_ban_label": "Δεν σου αρέσει αυτό",
  "VariousArtistsCapitalized": "Διάφοροι καλλιτέχνες"
}
},{}],64:[function(require,module,exports){
module.exports={
  "Album": "Album",
  "AndMore": "and {0} more",
  "Artist": "Artist",
  "By": "by",
  "ByLabel": "By",
  "Create Similar Playlist": "Create Similar Playlist",
  "DateAdded": "Date Added",
  "Duration": "Duration",
  "Recommended Songs": "Recommended Songs",
  "Filter": "Filter",
  "Follow": "Follow",
  "Follower": "Follower",
  "FollowersLabel": {
    "one": "Follower",
    "other": "Followers"
  },
  "FollowersCount": {
    "one": "{0} follower",
    "other": "{0} followers"
  },
  "Following": "Following",
  "FollowingLabel": "Following",
  "ListenersLabel": "Monthly Listeners",
  "FollowsYou": "Follows You",
  "HoldToPreview": "Click and Hold to Preview",
  "ListenCount": {
    "one": "1 play",
    "other": "{0} plays"
  },
  "ListenReactionMulti": "{0} listeners in your network",
  "ListenReactionSingle": "{0} listens to this",
  "LocalFile": "Local File",
  "More": "More",
  "MoreSongsLoad": "More songs load as you listen",
  "Pause": "Pause",
  "Play": "Play",
  "Playlist": "Playlist",
  "PressEnterToPlay": "Press Shift + Enter to play",
  "Popularity": "Popularity",
  "Progress": "Progress",
  "Remove": "Remove",
  "RemoveYourMusic": "Remove from Your Library",
  "RemoveFromYourFavoriteSongs": "Remove from your Favorite Songs",
  "Save": "Save",
  "SaveYourMusic": "Save to Your Library",
  "SaveToYourFavoriteSongs": "Save to your Favorite Songs",
  "Saved": "Saved",
  "StartRadio": "Start Radio",
  "Time": "Time",
  "Title": "Title",
  "Toplist": "Top songs",
  "Track": "Song",
  "Unfollow": "Unfollow",
  "User": "User",
  "ViewAll": "View All",
  "HoursShort": "{0} hr",
  "MinutesShort": "{0} min",
  "SecondsShort": "{0} sec",
  "ErrorTitle": "There was a problem displaying this page!",
  "ErrorMessage": "This page either does not exist or an error occurred.",
  "OfflineTitle": "This page is not available offline!",
  "OfflineMessage": "Please go online to load.",
  "MadeFor": "Made for {0}",
  "heart_label": "Like",
  "undo_heart_label": "Liked",
  "ban_label": "Remove",
  "format_list.ban_label": "Don't like",
  "nft.ban_song_label": "Hide this song",
  "nft.undo_ban_song_label": "Stop hiding this song",
  "format_list.undo_ban_label": "You don't like this",
  "VariousArtistsCapitalized": "Various artists"
}
},{}],65:[function(require,module,exports){
module.exports={
  "Album": "Álbum",
  "AndMore": "y {0} más",
  "Artist": "Artista",
  "By": "por",
  "ByLabel": "De",
  "Create Similar Playlist": "Crear playlist similar",
  "DateAdded": "Fecha agregada",
  "Duration": "Duración",
  "Recommended Songs": "Canciones recomendadas",
  "Filter": "Filtrar",
  "Follow": "Seguir",
  "Follower": "Seguidor",
  "FollowersLabel": {
    "one": "Seguidor",
    "other": "Seguidores"
  },
  "FollowersCount": {
    "one": "{0} seguidor",
    "other": "{0} seguidores"
  },
  "Following": "Siguiendo",
  "FollowingLabel": "Siguiendo",
  "ListenersLabel": "Oyentes mensuales",
  "FollowsYou": "Te sigue",
  "HoldToPreview": "Haz clic y mantén pulsado para oír la muestra preliminar",
  "ListenCount": {
    "one": "1 reproducción",
    "other": "{0} reproducciones"
  },
  "ListenReactionMulti": "{0} oyentes en tu red",
  "ListenReactionSingle": "{0} escucha esto",
  "LocalFile": "Archivo local",
  "More": "Más",
  "MoreSongsLoad": "Se cargarán más canciones a medida que escuchas",
  "Pause": "Pausa",
  "Play": "Reproducir",
  "Playlist": "Lista",
  "PressEnterToPlay": "Presiona Shift + Enter para reproducir",
  "Popularity": "Popularidad",
  "Progress": "Progreso",
  "Remove": "Eliminar",
  "RemoveYourMusic": "Eliminar de Tu Biblioteca",
  "RemoveFromYourFavoriteSongs": "Eliminar de tus Canciones favoritas",
  "Save": "Guardar",
  "SaveYourMusic": "Guardar en Tu Biblioteca",
  "SaveToYourFavoriteSongs": "Guardar en tus Canciones favoritas",
  "Saved": "Guardado",
  "StartRadio": "Comenzar Radio",
  "Time": "Tiempo",
  "Title": "Título",
  "Toplist": "Canciones más reproducidas",
  "Track": "Canción",
  "Unfollow": "Dejar de seguir",
  "User": "Usuario",
  "ViewAll": "Ver todos",
  "HoursShort": "{0} hr",
  "MinutesShort": "{0} min",
  "SecondsShort": "{0} seg",
  "ErrorTitle": "Hubo un problema al mostrar esta página.",
  "ErrorMessage": "Puede ser que esta página no exista o que haya ocurrido un error.",
  "OfflineTitle": "Esta página no se encuentra disponible sin conexión.",
  "OfflineMessage": "Conéctate a la red para cargar.",
  "MadeFor": "Hecho para {0}",
  "heart_label": "Me gusta",
  "undo_heart_label": "Te gusta esto",
  "ban_label": "Eliminar",
  "format_list.ban_label": "No me gusta",
  "nft.ban_song_label": "Ocultar esta canción",
  "nft.undo_ban_song_label": "Dejar de ocultar esta canción",
  "format_list.undo_ban_label": "No te gusta esto",
  "VariousArtistsCapitalized": "Varios artistas"
}
},{}],66:[function(require,module,exports){
module.exports={
  "Album": "Álbum",
  "AndMore": "y {0} más",
  "Artist": "Artista",
  "By": "por",
  "ByLabel": "De",
  "Create Similar Playlist": "Crear playlist similar",
  "DateAdded": "Fecha en la que se añadió",
  "Duration": "Duración",
  "Recommended Songs": "Canciones recomendadas",
  "Filter": "Filtrar",
  "Follow": "Seguir",
  "Follower": "Seguidor",
  "FollowersLabel": {
    "one": "Seguidor",
    "other": "Seguidores"
  },
  "FollowersCount": {
    "one": "{0} seguidor",
    "other": "{0} seguidores"
  },
  "Following": "Siguiendo",
  "FollowingLabel": "Siguiendo",
  "ListenersLabel": "Oyentes mensuales",
  "FollowsYou": "Te sigue",
  "HoldToPreview": "Pulsa y mantén pulsado para oír la muestra preliminar",
  "ListenCount": {
    "one": "1 reproducción",
    "other": "{0} reproducciones"
  },
  "ListenReactionMulti": "{0} oyentes en tu red",
  "ListenReactionSingle": "{0} escucha esto",
  "LocalFile": "Archivo local",
  "More": "Más",
  "MoreSongsLoad": "Se cargarán más canciones mientras escuchas",
  "Pause": "Pausar",
  "Play": "Reproducir",
  "Playlist": "Lista",
  "PressEnterToPlay": "Pulsa Mayús + Intro para reproducir",
  "Popularity": "Popularidad",
  "Progress": "Completado",
  "Remove": "Retirar",
  "RemoveYourMusic": "Eliminar de Tu biblioteca",
  "RemoveFromYourFavoriteSongs": "Retirar de tus Canciones favoritas",
  "Save": "Guardar",
  "SaveYourMusic": "Guardar en Tu biblioteca",
  "SaveToYourFavoriteSongs": "Guardar en tus Canciones favoritas",
  "Saved": "Guardada",
  "StartRadio": "Comenzar radio",
  "Time": "Tiempo",
  "Title": "Título",
  "Toplist": "Canciones más escuchadas",
  "Track": "Canción",
  "Unfollow": "Dejar de seguir",
  "User": "Usuario",
  "ViewAll": "Ver todos",
  "HoursShort": "{0} hr",
  "MinutesShort": "{0} min",
  "SecondsShort": "{0} seg",
  "ErrorTitle": "Se ha producido un problema al mostrar esta página.",
  "ErrorMessage": "Esta página no existe o se ha producido un error.",
  "OfflineTitle": "Esta página no está disponible sin conexión.",
  "OfflineMessage": "Por favor, conéctate para cargar.",
  "MadeFor": "Hecha para {0}",
  "heart_label": "Me gusta",
  "undo_heart_label": "Te gusta",
  "ban_label": "Retirar",
  "format_list.ban_label": "No me gusta",
  "nft.ban_song_label": "Ocultar esta canción",
  "nft.undo_ban_song_label": "Dejar de ocultar esta canción",
  "format_list.undo_ban_label": "No te gusta esto",
  "VariousArtistsCapitalized": "Varios artistas"
}
},{}],67:[function(require,module,exports){
module.exports={
  "Album": "Albumi",
  "AndMore": "ja {0} muuta",
  "Artist": "Artisti",
  "By": "tekijältä",
  "ByLabel": "tekijältä",
  "Create Similar Playlist": "Luo samankaltainen soittolista",
  "DateAdded": "Lisäyspäivä",
  "Duration": "Kesto",
  "Recommended Songs": "Suositellut kappaleet",
  "Filter": "Suodatin",
  "Follow": "Seuraa",
  "Follower": "Seuraaja",
  "FollowersLabel": {
    "one": "Seuraaja",
    "other": "Seuraajat"
  },
  "FollowersCount": {
    "one": "{0} seuraaja",
    "other": "{0} seuraajaa"
  },
  "Following": "Seurataan",
  "FollowingLabel": "Seurataan",
  "ListenersLabel": "Kuuntelijat kuukauden aikana",
  "FollowsYou": "Seuraa sinua",
  "HoldToPreview": "Kuuntele pätkä pitämällä tätä painettuna",
  "ListenCount": {
    "one": "1 toisto",
    "other": "{0} toistoa"
  },
  "ListenReactionMulti": "{0} kuuntelijaa verkostossasi",
  "ListenReactionSingle": "{0} kuuntelee tätä",
  "LocalFile": "Paikallinen tiedosto",
  "More": "Lisää",
  "MoreSongsLoad": "Lisää kappaleita ladataan kuuntelun aikana",
  "Pause": "Tauko",
  "Play": "Toista",
  "Playlist": "Soittolista",
  "PressEnterToPlay": "Toista painamalla Vaihto+Enter",
  "Popularity": "Suosio",
  "Progress": "Edistyminen",
  "Remove": "Poista",
  "RemoveYourMusic": "Poista omasta kirjastosta",
  "RemoveFromYourFavoriteSongs": "Poista suosikkikappaleista",
  "Save": "Tallenna",
  "SaveYourMusic": "Tallenna omaan kirjastoon",
  "SaveToYourFavoriteSongs": "Tallenna suosikkikappaleisiin",
  "Saved": "Tallennettu",
  "StartRadio": "Käynnistä radio",
  "Time": "Kesto",
  "Title": "Nimi",
  "Toplist": "Suosituimmat kappaleet",
  "Track": "Kappale",
  "Unfollow": "Lopeta seuraaminen",
  "User": "Käyttäjä",
  "ViewAll": "Näytä kaikki",
  "HoursShort": "{0} h",
  "MinutesShort": "{0} min",
  "SecondsShort": "{0} s",
  "ErrorTitle": "Sivun näyttämisessä ilmeni ongelma!",
  "ErrorMessage": "Sivua ei ole, tai tapahtui virhe.",
  "OfflineTitle": "Sivu ei ole saatavilla offline-tilassa!",
  "OfflineMessage": "Siirry online-tilaan, jotta voit ladata.",
  "MadeFor": "Luotu käyttäjälle {0}",
  "heart_label": "Tykkää",
  "undo_heart_label": "Tykätty",
  "ban_label": "Poista",
  "format_list.ban_label": "En tykkää",
  "nft.ban_song_label": "Piilota tämä kappale",
  "nft.undo_ban_song_label": "Lopeta kappaleen piilottaminen",
  "format_list.undo_ban_label": "Et tykkää tästä",
  "VariousArtistsCapitalized": "Eri esittäjiä"
}
},{}],68:[function(require,module,exports){
module.exports={
  "Album": "Album",
  "AndMore": "et {0} autres",
  "Artist": "Artiste",
  "By": "par",
  "ByLabel": "Par",
  "Create Similar Playlist": "Créer une liste de lecture semblable",
  "DateAdded": "Ajouté le",
  "Duration": "Durée",
  "Recommended Songs": "Chansons recommandées",
  "Filter": "Filtrer",
  "Follow": "Suivre",
  "Follower": "Abonné",
  "FollowersLabel": {
    "one": "Abonné",
    "other": "Abonné"
  },
  "FollowersCount": {
    "one": "{0} abonné",
    "other": "{0} abonnés"
  },
  "Following": "Suivis",
  "FollowingLabel": "Suivis",
  "ListenersLabel": "Auditeurs mensuels",
  "FollowsYou": "Vous suit",
  "HoldToPreview": "Cliquez longuement pour avoir un aperçu",
  "ListenCount": {
    "one": "1 lecture",
    "other": "{0} écoutes"
  },
  "ListenReactionMulti": "{0} auditeurs dans votre réseau",
  "ListenReactionSingle": "{0} écoute ceci",
  "LocalFile": "Fichier local",
  "More": "Plus",
  "MoreSongsLoad": "D'autres chansons se chargent pendant que vous écoutez",
  "Pause": "Pause",
  "Play": "Lecture",
  "Playlist": "Playlist",
  "PressEnterToPlay": "Appuyez sur Maj + Entrée pour faire jouer",
  "Popularity": "Popularité",
  "Progress": "Progression",
  "Remove": "Supprimer",
  "RemoveYourMusic": "Supprimer de la Bibliothèque",
  "RemoveFromYourFavoriteSongs": "Supprimer de vos chansons favorites",
  "Save": "Sauvegarder",
  "SaveYourMusic": "Enregistrer dans la Bibliothèque",
  "SaveToYourFavoriteSongs": "Enregistrer dans vos chansons favorites",
  "Saved": "Sauvegardé",
  "StartRadio": "Lancer la radio",
  "Time": "Durée",
  "Title": "Titre",
  "Toplist": "Meilleures chansons",
  "Track": "Titre",
  "Unfollow": "Ne plus suivre",
  "User": "Utilisateur",
  "ViewAll": "Voir tout",
  "HoursShort": "{0} h",
  "MinutesShort": "{0} min",
  "SecondsShort": "{0} s",
  "ErrorTitle": "Un problème est survenu lors de l'affichage de cette page!",
  "ErrorMessage": "Cette page n'existe pas ou une erreur s'est produite.",
  "OfflineTitle": "Cette page n'est pas accessible hors ligne!",
  "OfflineMessage": "Veuillez accéder à Internet pour charger le contenu.",
  "MadeFor": "Créée pour {0}",
  "heart_label": "J'aime",
  "undo_heart_label": "A aimé",
  "ban_label": "Supprimer",
  "format_list.ban_label": "Je n'aime pas",
  "nft.ban_song_label": "Masquer cette chanson",
  "nft.undo_ban_song_label": "Ne plus masquer cette chanson",
  "format_list.undo_ban_label": "Vous n’aimez pas cela",
  "VariousArtistsCapitalized": "Différents artistes"
}
},{}],69:[function(require,module,exports){
module.exports={
  "Album": "Album",
  "AndMore": "et {0} autres",
  "Artist": "Artiste",
  "By": "par",
  "ByLabel": "Par",
  "Create Similar Playlist": "Créer une playlist similaire",
  "DateAdded": "Ajouté le",
  "Duration": "Durée",
  "Recommended Songs": "Titres recommandés",
  "Filter": "Filtre",
  "Follow": "S'abonner",
  "Follower": "Abonné",
  "FollowersLabel": {
    "one": "Abonné",
    "other": "Abonnés"
  },
  "FollowersCount": {
    "one": "{0} abonné",
    "other": "{0} abonnés"
  },
  "Following": "Abonné",
  "FollowingLabel": "Abonné",
  "ListenersLabel": "Nombres de personnes qui écoutent par mois",
  "FollowsYou": "Est abonné à vous",
  "HoldToPreview": "Cliquez longuement pour avoir un aperçu",
  "ListenCount": {
    "one": "1 lecture",
    "other": "{0} écoutes"
  },
  "ListenReactionMulti": "{0} auditeurs dans votre réseau",
  "ListenReactionSingle": "{0} écoute ceci.",
  "LocalFile": "Fichier local",
  "More": "Plus",
  "MoreSongsLoad": "D'autres titres se chargent pendant que vous écoutez.",
  "Pause": "Pause",
  "Play": "Lire",
  "Playlist": "Playlist",
  "PressEnterToPlay": "Appuyez sur Maj et Entrée pour écouter",
  "Popularity": "Popularité",
  "Progress": "Progression",
  "Remove": "Supprimer",
  "RemoveYourMusic": "Supprimer de Bibliothèque",
  "RemoveFromYourFavoriteSongs": "Supprimer de vos titres favoris",
  "Save": "Sauvegarder",
  "SaveYourMusic": "Sauvegarder dans Bibliothèque",
  "SaveToYourFavoriteSongs": "Ajouter à vos titres favoris",
  "Saved": "Sauvegardé",
  "StartRadio": "Ecouter la radio",
  "Time": "Durée",
  "Title": "Titre",
  "Toplist": "Top titres",
  "Track": "Titre",
  "Unfollow": "Se désabonner",
  "User": "Utilisateur",
  "ViewAll": "Présentation tout",
  "HoursShort": "{0} h",
  "MinutesShort": "{0} min",
  "SecondsShort": "{0} s",
  "ErrorTitle": "Problème d'affichage !",
  "ErrorMessage": "Cette page n'existe pas, ou une erreur s'est produite.",
  "OfflineTitle": "Cette page n'est pas disponible hors connexion !",
  "OfflineMessage": "Connectez-vous pour procéder au chargement.",
  "MadeFor": "Concocté pour {0}",
  "heart_label": "J'aime",
  "undo_heart_label": "A aimé",
  "ban_label": "Supprimer",
  "format_list.ban_label": "Je n'aime pas",
  "nft.ban_song_label": "Masquer ce titre",
  "nft.undo_ban_song_label": "Ne plus masquer ce titre",
  "format_list.undo_ban_label": "Vous n'aimez pas ce contenu",
  "VariousArtistsCapitalized": "Différents artistes"
}
},{}],70:[function(require,module,exports){
module.exports={
  "Album": "Album",
  "AndMore": "és még {0} felhasználó",
  "Artist": "Előadó",
  "By": "tőle:",
  "ByLabel": "Tőle:",
  "Create Similar Playlist": "Hasonló műsorlista létrehozása",
  "DateAdded": "Dátum hozzáadva",
  "Duration": "Időtartam",
  "Recommended Songs": "Ajánlott dalok",
  "Filter": "Szűrő",
  "Follow": "Követés",
  "Follower": "Követő",
  "FollowersLabel": {
    "one": "Követő",
    "other": "Követők"
  },
  "FollowersCount": {
    "one": "{0} követő",
    "other": "{0} követő"
  },
  "Following": "Követések",
  "FollowingLabel": "Követések",
  "ListenersLabel": "Hallgatók havonta",
  "FollowsYou": "Téged követ",
  "HoldToPreview": "Tartsd nyomva a belehallgatáshoz",
  "ListenCount": {
    "one": "1 lejátszás",
    "other": "{0} lejátszás"
  },
  "ListenReactionMulti": "{0} ismerősöd hallgatta meg",
  "ListenReactionSingle": "{0} már meghallgatta",
  "LocalFile": "Helyi fájl",
  "More": "Több",
  "MoreSongsLoad": "Lesz még szám, csak hallgasd tovább",
  "Pause": "Szünet",
  "Play": "Lejátszás",
  "Playlist": "Lejátszási lista",
  "PressEnterToPlay": "A lejátszáshoz nyomd meg a Shift + Enter billentyűket",
  "Popularity": "Népszerűség",
  "Progress": "Állapot",
  "Remove": "Eltávolítás",
  "RemoveYourMusic": "Törlés a Gyűjteményemből",
  "RemoveFromYourFavoriteSongs": "Törlés a Kedvenc dalok közül",
  "Save": "Mentés",
  "SaveYourMusic": "Mentés a Gyűjteményedbe",
  "SaveToYourFavoriteSongs": "Mentés a Kedvenc dalokhoz",
  "Saved": "Mentett",
  "StartRadio": "Rádió bekapcsolása",
  "Time": "Idő",
  "Title": "Cím",
  "Toplist": "Toplista",
  "Track": "Dal",
  "Unfollow": "Nem követem",
  "User": "Felhasználó",
  "ViewAll": "Mindent mutat",
  "HoursShort": "{0} óra",
  "MinutesShort": "{0} perc",
  "SecondsShort": "{0} mp",
  "ErrorTitle": "Hiba történt az oldal megjelenítésekor.",
  "ErrorMessage": "Az oldal nem létezik, vagy hiba történt.",
  "OfflineTitle": "Ez az oldal offline módban nem érhető el.",
  "OfflineMessage": "Csatlakozz az internethez, majd indítsd el.",
  "MadeFor": "{0} felhasználónak készült",
  "heart_label": "Tetszik",
  "undo_heart_label": "Kedvelted",
  "ban_label": "Eltávolítás",
  "format_list.ban_label": "Nem tetszik",
  "nft.ban_song_label": "Dal elrejtése",
  "nft.undo_ban_song_label": "Dal elrejtésének visszavonása",
  "format_list.undo_ban_label": "Ez nem tetszett neked",
  "VariousArtistsCapitalized": "Különböző előadók"
}
},{}],71:[function(require,module,exports){
module.exports={
  "Album": "Album",
  "AndMore": "dan {0} lagi",
  "Artist": "Artis",
  "By": "menurut",
  "ByLabel": "Dari",
  "Create Similar Playlist": "Buat Playlist Serupa",
  "DateAdded": "Tanggal Dimuat",
  "Duration": "Durasi",
  "Recommended Songs": "Lagu yang Direkomendasikan",
  "Filter": "Filter",
  "Follow": "Ikuti",
  "Follower": "Pengikut",
  "FollowersLabel": {
    "one": "Pengikut",
    "other": "Pengikut"
  },
  "FollowersCount": {
    "one": "{0} pengikut",
    "other": "{0} pengikut"
  },
  "Following": "Mengikuti",
  "FollowingLabel": "Mengikuti",
  "ListenersLabel": "Pendengar Bulanan",
  "FollowsYou": "Mengikutimu",
  "HoldToPreview": "Klik dan Tahan untuk Pratinjau",
  "ListenCount": {
    "one": "1 pemutaran",
    "other": "{0} permainan"
  },
  "ListenReactionMulti": "{0} pendengar di jaringanmu",
  "ListenReactionSingle": "{0} mendengarkan ini",
  "LocalFile": "File Lokal",
  "More": "Lainnya",
  "MoreSongsLoad": "Lebih banyak lagu dimuat saat kamu mendengarkan",
  "Pause": "Jeda",
  "Play": "Play",
  "Playlist": "Playlist",
  "PressEnterToPlay": "Tekan Shift + Enter untuk memutar",
  "Popularity": "Popularitas",
  "Progress": "Kemajuan",
  "Remove": "Hapus",
  "RemoveYourMusic": "Hapus dari Koleksi Kamu",
  "RemoveFromYourFavoriteSongs": "Hapus dari Lagu Favoritmu",
  "Save": "Simpan",
  "SaveYourMusic": "Simpan ke Koleksi Kamu",
  "SaveToYourFavoriteSongs": "Simpan ke Lagu Favoritmu",
  "Saved": "Tersimpan",
  "StartRadio": "Mulai Radio",
  "Time": "Waktu",
  "Title": "Judul",
  "Toplist": "Lagu teratas",
  "Track": "Lagu",
  "Unfollow": "Berhenti mengikuti",
  "User": "Pengguna",
  "ViewAll": "Lihat Semua",
  "HoursShort": "{0} jam",
  "MinutesShort": "{0} mnt",
  "SecondsShort": "{0} dtk",
  "ErrorTitle": "Ada masalah saat menampilkan halaman ini!",
  "ErrorMessage": "Halaman ini tidak ada atau terjadi kesalahan.",
  "OfflineTitle": "Halaman ini tidak tersedia secara offline!",
  "OfflineMessage": "Alihkan ke online untuk memuat.",
  "MadeFor": "Dibuat untuk {0}",
  "heart_label": "Suka",
  "undo_heart_label": "Disukai",
  "ban_label": "Hapus",
  "format_list.ban_label": "Tidak suka",
  "nft.ban_song_label": "Sembunyikan lagu ini",
  "nft.undo_ban_song_label": "Berhenti menyembunyikan lagu ini",
  "format_list.undo_ban_label": "Kamu tidak suka ini",
  "VariousArtistsCapitalized": "Berbagai artis"
}
},{}],72:[function(require,module,exports){
module.exports={
  "Album": "Album",
  "AndMore": "e altri {0}",
  "Artist": "Artista",
  "By": "per",
  "ByLabel": "di",
  "Create Similar Playlist": "Crea playlist simile",
  "DateAdded": "Aggiunto il",
  "Duration": "Durata",
  "Recommended Songs": "Brani consigliati",
  "Filter": "Filtra",
  "Follow": "Segui",
  "Follower": "Follower",
  "FollowersLabel": {
    "one": "Follower",
    "other": "Follower"
  },
  "FollowersCount": {
    "one": "{0} follower",
    "other": "{0} follower"
  },
  "Following": "Following",
  "FollowingLabel": "Following",
  "ListenersLabel": "Ascoltatori questo mese",
  "FollowsYou": "Ti segue",
  "HoldToPreview": "Tieni premuto per un'anteprima",
  "ListenCount": {
    "one": "1 riproduzione",
    "other": "{0} riproduzioni"
  },
  "ListenReactionMulti": "{0} ascoltatori nella tua rete",
  "ListenReactionSingle": "{0} ascolta questo",
  "LocalFile": "File locale",
  "More": "Più",
  "MoreSongsLoad": "Durante l'ascolto vengono caricati altri brani",
  "Pause": "Pausa",
  "Play": "Play",
  "Playlist": "Playlist",
  "PressEnterToPlay": "Premi Shift + Invio per riprodurre",
  "Popularity": "Popolarità",
  "Progress": "Progress",
  "Remove": "Rimuovi",
  "RemoveYourMusic": "Elimina da La tua libreria",
  "RemoveFromYourFavoriteSongs": "Rimuovi dai tuoi brani preferiti",
  "Save": "Salva",
  "SaveYourMusic": "Salva in La tua libreria",
  "SaveToYourFavoriteSongs": "Aggiungi ai tuoi brani preferiti",
  "Saved": "Salvato",
  "StartRadio": "Crea una radio",
  "Time": "Durata",
  "Title": "Titolo",
  "Toplist": "Brani top",
  "Track": "Brano",
  "Unfollow": "Non seguire più",
  "User": "Utente",
  "ViewAll": "Visualizza tutto",
  "HoursShort": "{0} ore",
  "MinutesShort": "{0} min.",
  "SecondsShort": "{0} sec",
  "ErrorTitle": "Si è verificato un errore nella visualizzazione di questa pagina.",
  "ErrorMessage": "Questa pagina non esiste o si è verificato un errore.",
  "OfflineTitle": "Questa pagina non è disponibile offline.",
  "OfflineMessage": "Passa online per caricare.",
  "MadeFor": "Realizzata per {0}",
  "heart_label": "Preferiti",
  "undo_heart_label": "Preferiti",
  "ban_label": "Rimuovi",
  "format_list.ban_label": "Non mi piace",
  "nft.ban_song_label": "Nascondi questo brano",
  "nft.undo_ban_song_label": "Non nascondere più questo brano",
  "format_list.undo_ban_label": "Questo elemento non ti piace",
  "VariousArtistsCapitalized": "Artisti vari"
}
},{}],73:[function(require,module,exports){
module.exports={
  "Album": "アルバム",
  "AndMore": "その他{0}人",
  "Artist": "アーティスト",
  "By": "/",
  "ByLabel": "/",
  "Create Similar Playlist": "同様のプレイリストを作成",
  "DateAdded": "追加日",
  "Duration": "期間",
  "Recommended Songs": "おすすめの曲",
  "Filter": "フィルター",
  "Follow": "フォロー",
  "Follower": "フォロワー",
  "FollowersLabel": {
    "one": "フォロワー",
    "other": "フォロワー"
  },
  "FollowersCount": {
    "one": "{0}人のフォロワー",
    "other": "{0}人のフォロワー"
  },
  "Following": "フォロー中",
  "FollowingLabel": "フォロー中",
  "ListenersLabel": "今月のリスナー",
  "FollowsYou": "あなたをフォローしています",
  "HoldToPreview": "プレビューするには、クリックを押しします",
  "ListenCount": {
    "one": "1回再生",
    "other": "{0}回再生"
  },
  "ListenReactionMulti": "ネットワーク内で{0}人が聴いています",
  "ListenReactionSingle": "{0}さんはこれを聴いています",
  "LocalFile": "ローカルファイル",
  "More": "詳細",
  "MoreSongsLoad": "再生すると、さらに曲がロードされます",
  "Pause": "一時停止",
  "Play": "曲の再生",
  "Playlist": "プレイリスト",
  "PressEnterToPlay": "再生するには Shift + Enter キーを押します",
  "Popularity": "人気",
  "Progress": "進捗",
  "Remove": "削除",
  "RemoveYourMusic": "My Musicから削除",
  "RemoveFromYourFavoriteSongs": "My Library から削除する",
  "Save": "保存",
  "SaveYourMusic": "My Musicに保存",
  "SaveToYourFavoriteSongs": "お気に入りソングに保存しました。",
  "Saved": "保存済み",
  "StartRadio": "Radioを開始",
  "Time": "時間",
  "Title": "タイトル",
  "Toplist": "トップ曲",
  "Track": "ソング",
  "Unfollow": "フォローをやめる",
  "User": "ユーザー",
  "ViewAll": "すべて表示",
  "HoursShort": "{0} 時間",
  "MinutesShort": "{0} 分",
  "SecondsShort": "{0} 秒",
  "ErrorTitle": "このページの表示中に問題が発生しました。",
  "ErrorMessage": "このページは存在しないか、表示中にエラーが発生しました。",
  "OfflineTitle": "このページはオフラインでは利用できません。",
  "OfflineMessage": "ロードするには、インターネットに接続してください。",
  "MadeFor": " {0}さんのために作られたプレイリスト",
  "heart_label": "いいね！",
  "undo_heart_label": "お気に入り",
  "ban_label": "削除",
  "format_list.ban_label": "この曲を削除する",
  "nft.ban_song_label": "この曲を非表示にする",
  "nft.undo_ban_song_label": "この曲を表示する",
  "format_list.undo_ban_label": "この曲を削除する",
  "VariousArtistsCapitalized": "様々なアーティスト"
}
},{}],74:[function(require,module,exports){
module.exports={
  "Album": "Album",
  "AndMore": "dan {0} lagi",
  "Artist": "Artis",
  "By": "oleh",
  "ByLabel": "Lebih banyak lagi oleh",
  "Create Similar Playlist": "Cipta Senarai Main Serupa",
  "DateAdded": "Tarikh Ditambah",
  "Duration": "Tempoh",
  "Recommended Songs": "Lagu yang Dicadangkan",
  "Filter": "Penapis",
  "Follow": "Ikut",
  "Follower": "Pengikut",
  "FollowersLabel": {
    "one": "Pengikut",
    "other": "Pengikut"
  },
  "FollowersCount": {
    "one": "{0} pengikut",
    "other": "{0} pengikut"
  },
  "Following": "Mengikuti",
  "FollowingLabel": "Mengikuti",
  "ListenersLabel": "Pendengar Bulanan",
  "FollowsYou": "Megikuti Anda",
  "HoldToPreview": "Klik dan Tahan untuk Pratonton",
  "ListenCount": {
    "one": "1 main",
    "other": "{0} main"
  },
  "ListenReactionMulti": "{0} pendengar dalam rangkaian anda",
  "ListenReactionSingle": "{0} mendengar ini",
  "LocalFile": "Fail Setempat",
  "More": "Lebih banyak",
  "MoreSongsLoad": "Lebih banyak lagu dimuatkan semasa anda mendengar",
  "Pause": "Jeda",
  "Play": "Main",
  "Playlist": "Senarai main",
  "PressEnterToPlay": "Tekan Shift + Enter untuk memainkan",
  "Popularity": "Populariti",
  "Progress": "Perkembangan",
  "Remove": "Keluarkan",
  "RemoveYourMusic": "Keluarkan daripada Pustaka Anda",
  "RemoveFromYourFavoriteSongs": "Keluarkan daripada Lagu Kegemaran anda",
  "Save": "Simpan",
  "SaveYourMusic": "Simpan ke Pustaka Anda",
  "SaveToYourFavoriteSongs": "Simpankan ke dalam Lagu Kegemaran anda",
  "Saved": "Disimpan",
  "StartRadio": "Mulakan Radio",
  "Time": "Masa",
  "Title": "Tajuk",
  "Toplist": "Lagu popular",
  "Track": "Lagu",
  "Unfollow": "Nyahikut",
  "User": "Pengguna",
  "ViewAll": "Lihat Semua",
  "HoursShort": "{0} jam",
  "MinutesShort": "{0} min",
  "SecondsShort": "{0} saat",
  "ErrorTitle": "Terdapat masalah untuk memaparkan laman ini!",
  "ErrorMessage": "Laman ini sama ada tidak wujud atau ralat telah berlaku.",
  "OfflineTitle": "Laman ini tidak tersedia di luar talian!",
  "OfflineMessage": "Sila ke online untuk memuatkan.",
  "MadeFor": "Dibuat untuk {0}",
  "heart_label": "Suka",
  "undo_heart_label": "Disukai",
  "ban_label": "Keluarkan",
  "format_list.ban_label": "Tidak suka",
  "nft.ban_song_label": "Sembunyikan lagu ini",
  "nft.undo_ban_song_label": "Berhenti daripada menyembunyikan lagu ini",
  "format_list.undo_ban_label": "Anda tidak sukakannya",
  "VariousArtistsCapitalized": "Pelbagai artis"
}
},{}],75:[function(require,module,exports){
module.exports={
  "Album": "Album",
  "AndMore": "en {0} meer",
  "Artist": "Artiest",
  "By": "van",
  "ByLabel": "Van",
  "Create Similar Playlist": "Vergelijkbare afspeellijst maken",
  "DateAdded": "Datum toegevoegd",
  "Duration": "Duur",
  "Recommended Songs": "Aanbevolen nummers",
  "Filter": "Filter",
  "Follow": "Volgen",
  "Follower": "Volger",
  "FollowersLabel": {
    "one": "Volger",
    "other": "Volger"
  },
  "FollowersCount": {
    "one": "{0} volger",
    "other": "{0} volgers"
  },
  "Following": "Volgend",
  "FollowingLabel": "Volgend",
  "ListenersLabel": "Luisteraars per maand",
  "FollowsYou": "Volgt jou",
  "HoldToPreview": "Klikken en vasthouden om een stukje te horen",
  "ListenCount": {
    "one": "1 keer afgespeeld",
    "other": "{0} keer afgespeeld"
  },
  "ListenReactionMulti": "{0} luisteraars in jouw netwerk",
  "ListenReactionSingle": "{0} luistert hiernaar",
  "LocalFile": "Lokaal bestand",
  "More": "Meer",
  "MoreSongsLoad": "Meer nummers worden geladen terwijl je luistert",
  "Pause": "Pauze",
  "Play": "Afspelen",
  "Playlist": "Afspeellijst",
  "PressEnterToPlay": "Druk op Shift + Enter om af te spelen",
  "Popularity": "Populariteit",
  "Progress": "Voortgang",
  "Remove": "Verwijderen",
  "RemoveYourMusic": "Verwijderen uit Bibliotheek",
  "RemoveFromYourFavoriteSongs": "Verwijderen uit je Favoriete nummers",
  "Save": "Opslaan",
  "SaveYourMusic": "Opslaan in Bibliotheek",
  "SaveToYourFavoriteSongs": "Opslaan in je Favoriete nummers",
  "Saved": "Opgeslagen",
  "StartRadio": "Radio starten",
  "Time": "Tijd",
  "Title": "Titel",
  "Toplist": "Topnummers",
  "Track": "Nummer",
  "Unfollow": "Niet meer volgen",
  "User": "Gebruiker",
  "ViewAll": "Alles bekijken",
  "HoursShort": "{0} uur",
  "MinutesShort": "{0} min",
  "SecondsShort": "{0} sec",
  "ErrorTitle": "Er is een fout opgetreden bij het weergeven van deze pagina.",
  "ErrorMessage": "Deze weergave bestaat niet of er is een fout opgetreden.",
  "OfflineTitle": "Deze pagina is niet offline beschikbaar.",
  "OfflineMessage": "Ga online om te laden.",
  "MadeFor": "Gemaakt voor {0}",
  "heart_label": "Vind ik leuk",
  "undo_heart_label": "Geliked",
  "ban_label": "Verwijderen",
  "format_list.ban_label": "Niet leuk",
  "nft.ban_song_label": "Dit nummer verbergen",
  "nft.undo_ban_song_label": "Dit nummer niet meer verbergen",
  "format_list.undo_ban_label": "Je vindt dit niet leuk",
  "VariousArtistsCapitalized": "Diverse artiesten"
}
},{}],76:[function(require,module,exports){
module.exports={
  "Album": "Album",
  "AndMore": "i {0} więcej",
  "Artist": "Wykonawca",
  "By": "według",
  "ByLabel": "-",
  "Create Similar Playlist": "Utwórz podobną playlistę",
  "DateAdded": "Data dodania",
  "Duration": "Czas trwania",
  "Recommended Songs": "Polecane utwory",
  "Filter": "Filtruj",
  "Follow": "Obserwuj",
  "Follower": "Obserwujący",
  "FollowersLabel": {
    "one": "Obserwujący",
    "other": "Obserwatorzy"
  },
  "FollowersCount": {
    "one": "{0} obserwujący",
    "other": "{0} obserwujących"
  },
  "Following": "Obserwujesz",
  "FollowingLabel": "Obserwujesz",
  "ListenersLabel": "Słuchacze w tym miesiącu",
  "FollowsYou": "Obserwuje Cię",
  "HoldToPreview": "Aby odsłuchać, kliknij i przytrzymaj.",
  "ListenCount": {
    "one": "1 odtworzenie",
    "other": "Liczba odtworzeń: {0}"
  },
  "ListenReactionMulti": "Liczba słuchaczy w Twojej sieci: {0}",
  "ListenReactionSingle": "Użytkownik {0} słucha tego",
  "LocalFile": "Plik lokalny",
  "More": "Więcej",
  "MoreSongsLoad": "Więcej utworów będzie się pojawiać w miarę słuchania",
  "Pause": "Pauza",
  "Play": "Odtwórz",
  "Playlist": "Playlista",
  "PressEnterToPlay": "Naciśnij Shift+Enter, aby odtworzyć",
  "Popularity": "Popularność",
  "Progress": "Postęp",
  "Remove": "Usuń",
  "RemoveYourMusic": "Usuń z Biblioteki",
  "RemoveFromYourFavoriteSongs": "Usuń z Ulubionych utworów",
  "Save": "Zapisz",
  "SaveYourMusic": "Zapisz w Bibliotece",
  "SaveToYourFavoriteSongs": "Zapisz w Ulubionych utworach",
  "Saved": "Zapisany",
  "StartRadio": "Włącz radio",
  "Time": "Czas",
  "Title": "Tytuł",
  "Toplist": "Najpopularniejsze utwory",
  "Track": "Utwór",
  "Unfollow": "Przestań obserwować",
  "User": "Użytkownik",
  "ViewAll": "Wyświetl wszystko",
  "HoursShort": "{0} godz.",
  "MinutesShort": "{0} min",
  "SecondsShort": "{0} s",
  "ErrorTitle": "Wystąpił błąd podczas wyświetlania tej strony!",
  "ErrorMessage": "Ta strona nie istnieje lub wystąpił błąd.",
  "OfflineTitle": "Ta strona nie jest dostępna w trybie offline!",
  "OfflineMessage": "Przejdź do trybu online, aby załadować.",
  "MadeFor": "Przygotowana dla {0}",
  "heart_label": "Lubię to",
  "undo_heart_label": "Polubiono",
  "ban_label": "Usuń",
  "format_list.ban_label": "Nie lubię",
  "nft.ban_song_label": "Ukryj ten utwór",
  "nft.undo_ban_song_label": "Przestań ukrywać ten utwór",
  "format_list.undo_ban_label": "Nie podoba Ci się",
  "VariousArtistsCapitalized": "Różni wykonawcy"
}
},{}],77:[function(require,module,exports){
module.exports={
  "Album": "Álbum",
  "AndMore": "e mais {0}",
  "Artist": "Artista",
  "By": "de",
  "ByLabel": "De",
  "Create Similar Playlist": "Criar playlist similar",
  "DateAdded": "Adicionado em",
  "Duration": "Duração",
  "Recommended Songs": "Músicas recomendadas",
  "Filter": "Filtrar",
  "Follow": "Seguir",
  "Follower": "Seguidor",
  "FollowersLabel": {
    "one": "Seguidor",
    "other": "Seguidores"
  },
  "FollowersCount": {
    "one": "{0} seguidor",
    "other": "{0} seguidores"
  },
  "Following": "Seguindo",
  "FollowingLabel": "Seguindo",
  "ListenersLabel": "Ouvintes mensais",
  "FollowsYou": "Segue você",
  "HoldToPreview": "Clique e segure para a prévia",
  "ListenCount": {
    "one": "1 reprodução",
    "other": "{0} reproduções"
  },
  "ListenReactionMulti": "{0} ouvintes na sua rede",
  "ListenReactionSingle": "{0} ouvem isso",
  "LocalFile": "Arquivo local",
  "More": "Mais",
  "MoreSongsLoad": "Mais músicas serão carregadas à medida que você for escutando",
  "Pause": "Pause",
  "Play": "Play",
  "Playlist": "Playlist",
  "PressEnterToPlay": "Pressione Shift + Enter para tocar",
  "Popularity": "Popularidade",
  "Progress": "Progresso",
  "Remove": "Remover",
  "RemoveYourMusic": "Remover da Sua Biblioteca",
  "RemoveFromYourFavoriteSongs": "Remover de Músicas Favoritas",
  "Save": "Salvar",
  "SaveYourMusic": "Salvar na Sua Biblioteca",
  "SaveToYourFavoriteSongs": "Salva em Músicas Favoritas",
  "Saved": "Salvo",
  "StartRadio": "Abrir rádio",
  "Time": "Tempo",
  "Title": "Título",
  "Toplist": "Músicas mais tocadas",
  "Track": "Música",
  "Unfollow": "Deixar de seguir",
  "User": "Usuário",
  "ViewAll": "Ver tudo",
  "HoursShort": "{0} h",
  "MinutesShort": "{0} m",
  "SecondsShort": "{0} s",
  "ErrorTitle": "Tivemos um problema ao mostrar esta página!",
  "ErrorMessage": "Essa página não existe ou ocorreu um erro.",
  "OfflineTitle": "Essa página não está disponível offline!",
  "OfflineMessage": "Fique online para carregar.",
  "MadeFor": "Feito para {0}",
  "heart_label": "Curtir",
  "undo_heart_label": "Curtiu",
  "ban_label": "Remover",
  "format_list.ban_label": "Não curto",
  "nft.ban_song_label": "Ocultar esta música",
  "nft.undo_ban_song_label": "Deixar de ocultar esta música",
  "format_list.undo_ban_label": "Você não curte isso",
  "VariousArtistsCapitalized": "Vários artistas"
}
},{}],78:[function(require,module,exports){
module.exports={
  "Album": "Album",
  "AndMore": "och {0} till",
  "Artist": "Artist",
  "By": "av",
  "ByLabel": "Av",
  "Create Similar Playlist": "Skapa en liknande spellista",
  "DateAdded": "Tillagd",
  "Duration": "Längd",
  "Recommended Songs": "Rekommenderade låtar",
  "Filter": "Filtrera",
  "Follow": "Följ",
  "Follower": "Följare",
  "FollowersLabel": {
    "one": "Följare",
    "other": "Följare"
  },
  "FollowersCount": {
    "one": "{0} följare",
    "other": "{0} följare"
  },
  "Following": "Följer",
  "FollowingLabel": "Följer",
  "ListenersLabel": "Lyssnare per månad",
  "FollowsYou": "Följer dig",
  "HoldToPreview": "Klicka och håll kvar för att förhandslyssna",
  "ListenCount": {
    "one": "1 uppspelning",
    "other": "{0} uppspelningar"
  },
  "ListenReactionMulti": "{0} lyssnare i ditt nätverk",
  "ListenReactionSingle": "{0} lyssnar på detta",
  "LocalFile": "Lokal fil",
  "More": "Mer",
  "MoreSongsLoad": "Fler låtar läses in medan du lyssnar",
  "Pause": "Pausa",
  "Play": "Spela upp",
  "Playlist": "Spellista",
  "PressEnterToPlay": "Tryck på Skift + Retur för att spela upp",
  "Popularity": "Popularitet",
  "Progress": "Lyssnat",
  "Remove": "Ta bort",
  "RemoveYourMusic": "Ta bort från Ditt bibliotek",
  "RemoveFromYourFavoriteSongs": "Ta bort från dina favoritlåtar",
  "Save": "Spara",
  "SaveYourMusic": "Spara i Ditt bibliotek",
  "SaveToYourFavoriteSongs": "Spara i dina favoritlåtar",
  "Saved": "Sparade",
  "StartRadio": "Starta radio",
  "Time": "Tid",
  "Title": "Titel",
  "Toplist": "Topplåtar",
  "Track": "Låt",
  "Unfollow": "Sluta följa",
  "User": "Användare",
  "ViewAll": "Visa alla",
  "HoursShort": "{0} tim",
  "MinutesShort": "{0} min",
  "SecondsShort": "{0} sek",
  "ErrorTitle": "Det uppstod ett fel när den här sidan skulle visas!",
  "ErrorMessage": "Den här sidan finns inte eller så uppstod ett fel.",
  "OfflineTitle": "Den här sidan är inte tillgänglig offline!",
  "OfflineMessage": "Anslut till internet om du vill läsa in appen.",
  "MadeFor": "Skapad för {0}",
  "heart_label": "Gilla",
  "undo_heart_label": "Gillar",
  "ban_label": "Ta bort",
  "format_list.ban_label": "Gillar inte",
  "nft.ban_song_label": "Dölj den här låten",
  "nft.undo_ban_song_label": "Sluta dölja den här låten",
  "format_list.undo_ban_label": "Du gillar inte det här",
  "VariousArtistsCapitalized": "Olika artister"
}
},{}],79:[function(require,module,exports){
module.exports={
  "Album": "อัลบั้ม",
  "AndMore": "และอีก {0} คน",
  "Artist": "ศิลปิน",
  "By": "โดย",
  "ByLabel": "จาก",
  "Create Similar Playlist": "สร้างเพลย์ลิสต์ที่คล้ายกัน",
  "DateAdded": "เพิ่มวันที่แล้ว",
  "Duration": "ระยะเวลา",
  "Recommended Songs": "เพลงที่แนะนำ",
  "Filter": "ตัวกรอง",
  "Follow": "ติดตาม",
  "Follower": "ผู้ติดตาม",
  "FollowersLabel": {
    "one": "ผู้ติดตาม",
    "other": "ผู้ติดตาม"
  },
  "FollowersCount": {
    "one": "ผู้ติดตาม {0} คน",
    "other": "ผู้ติดตาม {0} คน"
  },
  "Following": "กำลังติดตาม",
  "FollowingLabel": "กำลังติดตาม",
  "ListenersLabel": "ผู้ฟังรายเดือน",
  "FollowsYou": "ติดตามคุณ",
  "HoldToPreview": "คลิกค้างไว้เพื่อฟังตัวอย่าง",
  "ListenCount": {
    "one": "เล่น 1 ครั้ง",
    "other": "เล่น {0} ครั้ง"
  },
  "ListenReactionMulti": "ผู้ฟัง {0} คนในเครือข่ายของคุณ",
  "ListenReactionSingle": "{0} ฟังรายการนี้",
  "LocalFile": "ไฟล์ในเครื่อง",
  "More": "เพิ่มเติม",
  "MoreSongsLoad": "เราจะโหลดเพลงเพิ่มระหว่างที่คุณฟัง",
  "Pause": "หยุดชั่วคราว",
  "Play": "เล่น",
  "Playlist": "เพลย์ลิสต์",
  "PressEnterToPlay": "กด Shift + Enter เพื่อเล่น",
  "Popularity": "ความนิยม",
  "Progress": "ความคืบหน้า",
  "Remove": "ลบ",
  "RemoveYourMusic": "ลบจากคอลเลกชันของคุณ",
  "RemoveFromYourFavoriteSongs": "ลบจากเพลงโปรดของคุณ",
  "Save": "บันทึก",
  "SaveYourMusic": "บันทึกในคอลเลกชันของคุณ",
  "SaveToYourFavoriteSongs": "บันทึกในเพลงโปรดของคุณ",
  "Saved": "บันทึกแล้ว",
  "StartRadio": "เริ่มต้นวิทยุ",
  "Time": "เวลา",
  "Title": "ชื่อ",
  "Toplist": "เพลงยอดนิยม",
  "Track": "เพลง",
  "Unfollow": "เลิกติดตาม",
  "User": "ผู้ใช้",
  "ViewAll": "ดูทั้งหมด",
  "HoursShort": "{0} ชั่วโมง",
  "MinutesShort": "{0} นาที",
  "SecondsShort": "{0} วินาที",
  "ErrorTitle": "เกิดปัญหาในการแสดงผลหน้านี้!",
  "ErrorMessage": "ไม่มีหน้านี้หรือเกิดข้อผิดพลาดขึ้น",
  "OfflineTitle": "ไม่สามารถใช้งานหน้านี้ขณะออฟไลน์ได้!",
  "OfflineMessage": "โปรดใช้งานแบบออนไลน์เพื่อโหลด",
  "MadeFor": "จัดทำเพื่อ {0}",
  "heart_label": "ถูกใจ",
  "undo_heart_label": "ถูกใจแล้ว",
  "ban_label": "ลบ",
  "format_list.ban_label": "ไม่ชอบ",
  "nft.ban_song_label": "ซ่อนเพลงนี้",
  "nft.undo_ban_song_label": "เลิกซ่อนเพลงนี้",
  "format_list.undo_ban_label": "คุณไม่ชอบเนื้อหานี้",
  "VariousArtistsCapitalized": "รวมศิลปิน"
}
},{}],80:[function(require,module,exports){
module.exports={
  "Album": "Albüm",
  "AndMore": "ve {0} daha",
  "Artist": "Sanatçı",
  "By": "-",
  "ByLabel": "-",
  "Create Similar Playlist": "Benzer Çalma Listesi Oluştur",
  "DateAdded": "Tarih Eklendi",
  "Duration": "Süre",
  "Recommended Songs": "Önerilen Şarkılar",
  "Filter": "Filtrele",
  "Follow": "Takip Et",
  "Follower": "Takipçi",
  "FollowersLabel": {
    "one": "Takipçi",
    "other": "Takipçi"
  },
  "FollowersCount": {
    "one": "{0} takipçi",
    "other": "{0} takipçi"
  },
  "Following": "Takip Ediliyor",
  "FollowingLabel": "Takip Ediliyor",
  "ListenersLabel": "Aylık Dinleyici",
  "FollowsYou": "Seni Takip Ediyor",
  "HoldToPreview": "Basılı Tut ve Önizle",
  "ListenCount": {
    "one": "1 çalma",
    "other": "{0} dinleme"
  },
  "ListenReactionMulti": "Ağında {0} dinleyici",
  "ListenReactionSingle": "{0} bunu dinliyor",
  "LocalFile": "Yerel Dosya",
  "More": "Daha fazla",
  "MoreSongsLoad": "Sen dinledikçe daha fazla şarkı yüklenir",
  "Pause": "Duraklat",
  "Play": "Çal",
  "Playlist": "Çalma listesi",
  "PressEnterToPlay": "Çalmak için Shift + Enter'a bas",
  "Popularity": "Popülerlik",
  "Progress": "Progress",
  "Remove": "Çıkar",
  "RemoveYourMusic": "Kitaplığın'dan kaldır",
  "RemoveFromYourFavoriteSongs": "Favori Şarkılarından Kaldır",
  "Save": "Kaydet",
  "SaveYourMusic": "Kitaplığın'a kaydet",
  "SaveToYourFavoriteSongs": "Favori Şarkılarına Kaydet",
  "Saved": "Kaydedildi",
  "StartRadio": "Radyoyu Başlat",
  "Time": "Saat",
  "Title": "Başlık",
  "Toplist": "En çok dinlenen şarkılar",
  "Track": "Şarkı",
  "Unfollow": "Takip Etmeyi Bırak",
  "User": "Kullanıcı",
  "ViewAll": "Tümünü Görüntüle",
  "HoursShort": "{0} sa",
  "MinutesShort": "{0} dk",
  "SecondsShort": "{0} sn",
  "ErrorTitle": "Bu sayfa görüntülenirken bir sorun oluştu!",
  "ErrorMessage": "Bu sayfa yok veya bir hata oluştu.",
  "OfflineTitle": "Bu sayfa çevrimdışı kullanılamaz!",
  "OfflineMessage": "Yüklemek için lütfen çevrimiçi ol.",
  "MadeFor": "{0} İçin Yapıldı",
  "heart_label": "Beğen",
  "undo_heart_label": "Beğenildi",
  "ban_label": "Çıkar",
  "format_list.ban_label": "Beğenme",
  "nft.ban_song_label": "Bu şarkıyı gizle",
  "nft.undo_ban_song_label": "Bu şarkıyı gizlemeyi durdur",
  "format_list.undo_ban_label": "Bunu beğenmedin",
  "VariousArtistsCapitalized": "Çeşitli sanatçılar"
}
},{}],81:[function(require,module,exports){
module.exports={
  "Album": "Album",
  "AndMore": "và thêm {0}",
  "Artist": "Nghệ sĩ",
  "By": "của",
  "ByLabel": "Của",
  "Create Similar Playlist": "Tạo Playlist Tương tự",
  "DateAdded": "Đã Thêm Ngày",
  "Duration": "Thời lượng",
  "Recommended Songs": "Bài hát Gợi ý",
  "Filter": "Bộ lọc",
  "Follow": "Theo dõi",
  "Follower": "Người theo dõi",
  "FollowersLabel": {
    "one": "Người theo dõi",
    "other": "Người theo dõi"
  },
  "FollowersCount": {
    "one": "{0} người theo dõi",
    "other": "{0} người theo dõi"
  },
  "Following": "Đang theo dõi",
  "FollowingLabel": "Đang theo dõi",
  "ListenersLabel": "Người nghe Hàng tháng",
  "FollowsYou": "Theo dõi Bạn",
  "HoldToPreview": "Nhấp và Giữ để Xem trước",
  "ListenCount": {
    "one": "1 lượt phát",
    "other": "{0} phát"
  },
  "ListenReactionMulti": "{0} người nghe trong mạng lưới của bạn",
  "ListenReactionSingle": "{0} nghe bản này",
  "LocalFile": "File trên máy",
  "More": "Tuỳ chọn...",
  "MoreSongsLoad": "Tải được nhiều bài hát hơn khi bạn nghe",
  "Pause": "Tạm dừng",
  "Play": "Phát",
  "Playlist": "Playlist",
  "PressEnterToPlay": "Nhấn Shift + Enter để phát",
  "Popularity": "Mức độ phổ biến",
  "Progress": "Tiến độ",
  "Remove": "Xóa",
  "RemoveYourMusic": "Xóa khỏi Thư viện",
  "RemoveFromYourFavoriteSongs": "Xóa khỏi Bài hát Yêu thích của bạn",
  "Save": "Lưu",
  "SaveYourMusic": "Lưu vào Thư viện",
  "SaveToYourFavoriteSongs": "Lưu vào Bài hát Yêu thích của bạn",
  "Saved": "Đã lưu",
  "StartRadio": "Bắt đầu Radio",
  "Time": "Thời gian",
  "Title": "Tiêu đề",
  "Toplist": "Các bài hát hàng đầu",
  "Track": "Bài hát",
  "Unfollow": "Hủy theo dõi",
  "User": "Người dùng",
  "ViewAll": "Xem Tất cả",
  "HoursShort": "{0} giờ",
  "MinutesShort": "{0} phút",
  "SecondsShort": "{0} giây",
  "ErrorTitle": "Đã có sự cố xảy ra khi hiển thị trang này!",
  "ErrorMessage": "Nội dung này hoặc không tồn tại hoặc đã có lỗi xảy ra.",
  "OfflineTitle": "Trang này không có ở chế độ offline!",
  "OfflineMessage": "Vui lòng truy cập trực tuyến để tải.",
  "MadeFor": "Dành cho {0}",
  "heart_label": "Thích",
  "undo_heart_label": "Đã thích",
  "ban_label": "Xóa",
  "format_list.ban_label": "Không thích",
  "nft.ban_song_label": "Ẩn bài hát này",
  "nft.undo_ban_song_label": "Dừng ẩn bài hát này",
  "format_list.undo_ban_label": "Bạn không thích điều này",
  "VariousArtistsCapitalized": "Nhiều nghệ sĩ"
}
},{}],82:[function(require,module,exports){
module.exports={
  "Album": "專輯",
  "AndMore": "還有 {0} 首",
  "Artist": "藝人",
  "By": "－",
  "ByLabel": "來自",
  "Create Similar Playlist": "建立相似的播放清單",
  "DateAdded": "已加入日期",
  "Duration": "長度",
  "Recommended Songs": "推薦歌曲",
  "Filter": "篩選",
  "Follow": "關注",
  "Follower": "粉絲",
  "FollowersLabel": {
    "one": "粉絲",
    "other": "粉絲"
  },
  "FollowersCount": {
    "one": "{0} 粉絲",
    "other": "{0} 位粉絲"
  },
  "Following": "正在關注",
  "FollowingLabel": "正在關注",
  "ListenersLabel": "每月聽眾",
  "FollowsYou": "關注你",
  "HoldToPreview": "按住即可預覽",
  "ListenCount": {
    "one": "1 個播放項目",
    "other": "播放了 {0} 次"
  },
  "ListenReactionMulti": "在你的社群網路中有 {0} 名聽眾",
  "ListenReactionSingle": "{0} 收聽了這首歌曲",
  "LocalFile": "本機檔案",
  "More": "更多",
  "MoreSongsLoad": "聆聽時載入更多歌曲",
  "Pause": "暫停",
  "Play": "播放",
  "Playlist": "播放列表",
  "PressEnterToPlay": "請按 Shift + Enter 播放",
  "Popularity": "流行",
  "Progress": "進度",
  "Remove": "移除",
  "RemoveYourMusic": "從你的音樂庫中移除",
  "RemoveFromYourFavoriteSongs": "從最愛的歌曲中移除",
  "Save": "儲存",
  "SaveYourMusic": "儲存至你的音樂庫",
  "SaveToYourFavoriteSongs": "儲存至最愛的歌曲",
  "Saved": "已儲存",
  "StartRadio": "啟用電臺",
  "Time": "時間",
  "Title": "標題",
  "Toplist": "當紅歌曲",
  "Track": "歌曲",
  "Unfollow": "取消關注",
  "User": "使用者",
  "ViewAll": "檢視全部",
  "HoursShort": "{0} 小時",
  "MinutesShort": "{0} 分鐘",
  "SecondsShort": "{0} 秒鐘",
  "ErrorTitle": "顯示這個頁面時出現問題！",
  "ErrorMessage": "這個頁面可能不存在或發生錯誤。",
  "OfflineTitle": "離線時無法進入這個頁面！",
  "OfflineMessage": "請上網以載入。",
  "MadeFor": "專為 {0} 精心打造",
  "heart_label": "讚",
  "undo_heart_label": "已按讚",
  "ban_label": "移除",
  "format_list.ban_label": "不喜歡",
  "nft.ban_song_label": "隱藏這首歌曲",
  "nft.undo_ban_song_label": "取消隱藏這首歌",
  "format_list.undo_ban_label": "你不喜歡這個",
  "VariousArtistsCapitalized": "多位藝人"
}
},{}],83:[function(require,module,exports){
"use strict";var _gridOverlay=require("./src/gridOverlay"),gridOverlay=_interopRequireWildcard(_gridOverlay),_responsiveTitleType=require("./src/responsiveTitleType"),responsiveTitleType=_interopRequireWildcard(_responsiveTitleType),_attentionHighlight=require("./src/attentionHighlight"),attentionHighlight=_interopRequireWildcard(_attentionHighlight);function _interopRequireWildcard(e){if(e&&e.__esModule)return e;var i={};if(null!=e)for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&(i[r]=e[r]);return i.default=e,i}exports.gridOverlay=gridOverlay,exports.responsiveTitleType=responsiveTitleType,exports.attentionHighlight=attentionHighlight;

},{"./src/attentionHighlight":84,"./src/gridOverlay":85,"./src/responsiveTitleType":86}],84:[function(require,module,exports){
"use strict";Object.defineProperty(exports,"__esModule",{value:!0});const HIDE_DELAY=exports.HIDE_DELAY=2e3;

},{}],85:[function(require,module,exports){
(function (global){
"use strict";const cosmos=require("../../cosmos-api").default,DEFAULT_GRID_COLOR="rgba(251, 74, 131, 0.22)",DEFAULT_GRID_COLOR_HIGHLIGHT="rgba(251, 74, 131, 0.8)",GRID_BASELINE=8;let overlayElement=null,baselineHighlightElement=null,gridColor="",highlightGridColor="";const gridModes=["off","column","baseline"];let currentModeIndex=0;function listen(){global.__spotify.developer_mode&&cosmos.resolver.subscribe({url:"sp://messages/v1/container/control"},function(e,l){if(e)return;const o=l.getJSONBody();o&&"toggle_grid"===o.type&&toggle()})}function toggle(){let e=currentModeIndex+1;e>gridModes.length-1&&(e=0);const l=gridModes[e];"off"===l?disable():enable(l)}function enable(e){e&&gridModes[currentModeIndex]!==e&&(currentModeIndex=gridModes.indexOf(e),overlayElement&&overlayElement.parentNode&&overlayElement.parentNode.removeChild(overlayElement),"baseline"===e&&document.addEventListener("mousemove",onMouseMove,!1),overlayElement=createOverlayElement(),document.body.appendChild(overlayElement))}function disable(){"off"!==gridModes[currentModeIndex]&&(overlayElement&&overlayElement.parentNode&&overlayElement.parentNode.removeChild(overlayElement),currentModeIndex=gridModes.indexOf("off"),overlayElement=null,baselineHighlightElement=null,document.removeEventListener("mousemove",onMouseMove,!1))}function setColor(e,l){gridColor=e,highlightGridColor=l}function reset(){overlayElement=null,baselineHighlightElement=null,gridColor="",highlightGridColor="",currentModeIndex=0}function onMouseMove(e){baselineHighlightElement||((baselineHighlightElement=document.createElement("div")).className="grid-overlay-baseline-highlight",baselineHighlightElement.style.backgroundColor=highlightGridColor||DEFAULT_GRID_COLOR_HIGHLIGHT,overlayElement.appendChild(baselineHighlightElement));const l=e.clientY+window.scrollY,o=Math.floor(l/GRID_BASELINE)*GRID_BASELINE+(l%GRID_BASELINE>4?GRID_BASELINE:0);baselineHighlightElement.style.top=`${o-1}px`}function createOverlayElement(){const e=gridColor||DEFAULT_GRID_COLOR,l=document.createElement("div");if(l.className="grid-overlay container","column"===gridModes[currentModeIndex]){const o=document.createElement("div");o.className="grid-overlay-row row",l.appendChild(o);const n=createSizeLabel();l.appendChild(n);const t="col-xs-1 col-sm-1 col-md-1 col-lg-1";for(let l=0;l<12;l++){const n=document.createElement("div");n.className=`grid-overlay-col-${l+1} ${t}`,n.style.backgroundColor=e,o.appendChild(n)}}else if("baseline"===gridModes[currentModeIndex]){l.classList.add("grid-overlay-baseline");const o=`${(GRID_BASELINE-1)/GRID_BASELINE*100}%`,n=["linear-gradient(","to bottom, ","transparent, ",`transparent ${o}, `,`${e} ${o}`,")"].join("");l.style.backgroundImage=n,l.style._backgroundImage=n}return l}function createSizeLabel(){const e=document.createElement("div");return e.className="grid-overlay-label",[{name:"Extra Small",id:"xs"},{name:"Small",id:"sm"},{name:"Medium",id:"md"},{name:"Large",id:"lg"}].forEach(function(l){const o=document.createElement("span");o.className=`visible-${l.id}`,o.textContent=`${l.name} (${l.id})`,e.appendChild(o)}),e}exports.listen=listen,exports.toggle=toggle,exports.enable=enable,exports.disable=disable,exports.setColor=setColor,exports.reset=reset;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../cosmos-api":45}],86:[function(require,module,exports){
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.loadFont=loadFont,exports.setSizeForTitle=setSizeForTitle;const PADDING_BOTTOM_PERCENTAGE=.07;function getSizeSpecs(){return"th"===window.__spotify.locale?{default:{fontSizes:[[48,36],[36,28]],lineHeights:[[75,58],[58,44]]},large:{fontSizes:[[96,72,48],[48,36,28]],lineHeights:[[148,111,75],[75,58,44]]}}:{default:{fontSizes:[[48,36],[36,28]],lineHeights:[[56,44],[44,36]]},large:{fontSizes:[[96,72,48],[48,36,28]],lineHeights:[[110,82,56],[56,44,36]]}}}function loadFont(){return document.fonts.load("500 48px spotify-circular")}function setSizeForTitle(e,t={}){const i=t.useLargeTitle?"large":"default",{fontSizes:l,lineHeights:o}=getSizeSpecs()[i];let n=1,s=0,r=l[0][0],a=o[0][0],p=n+1,g=Math.ceil(PADDING_BOTTOM_PERCENTAGE*a);for(e.style.webkitLineClamp=p,e.style.fontSize=`${r}px`,e.style.lineHeight=`${a}px`,e.style.paddingBottom=`${g}px`,e.style.marginBottom=`-${g}px`,e.removeAttribute("title");n<=l.length&&e.offsetHeight-g>a*n;)s++,l[n-1][s]||(s=0,n++),n<=l.length&&(r=l[n-1][s],a=o[n-1][s],p=n+1,g=Math.ceil(PADDING_BOTTOM_PERCENTAGE*a),e.style.webkitLineClamp=p,e.style.fontSize=`${r}px`,e.style.lineHeight=`${a}px`,e.style.paddingBottom=`${g}px`,e.style.marginBottom=`-${g}px`);n>l.length&&e.setAttribute("title",e.textContent.trim()),e.style.webkitLineClamp=p-1}

},{}],87:[function(require,module,exports){
"use strict";module.exports={ar:require("../i18n/json/ar.json"),cs:require("../i18n/json/cs.json"),de:require("../i18n/json/de.json"),el:require("../i18n/json/el.json"),en:require("../i18n/json/en.json"),es:require("../i18n/json/es.json"),"es-419":require("../i18n/json/es-419.json"),fi:require("../i18n/json/fi.json"),fr:require("../i18n/json/fr.json"),"fr-CA":require("../i18n/json/fr-CA.json"),hu:require("../i18n/json/hu.json"),id:require("../i18n/json/id.json"),it:require("../i18n/json/it.json"),ja:require("../i18n/json/ja.json"),nl:require("../i18n/json/nl.json"),pl:require("../i18n/json/pl.json"),"pt-BR":require("../i18n/json/pt-BR.json"),sv:require("../i18n/json/sv.json"),th:require("../i18n/json/th.json"),tr:require("../i18n/json/tr.json"),vi:require("../i18n/json/vi.json"),"zh-Hant":require("../i18n/json/zh-Hant.json"),ms:require("../i18n/json/ms.json")};

},{"../i18n/json/ar.json":60,"../i18n/json/cs.json":61,"../i18n/json/de.json":62,"../i18n/json/el.json":63,"../i18n/json/en.json":64,"../i18n/json/es-419.json":65,"../i18n/json/es.json":66,"../i18n/json/fi.json":67,"../i18n/json/fr-CA.json":68,"../i18n/json/fr.json":69,"../i18n/json/hu.json":70,"../i18n/json/id.json":71,"../i18n/json/it.json":72,"../i18n/json/ja.json":73,"../i18n/json/ms.json":74,"../i18n/json/nl.json":75,"../i18n/json/pl.json":76,"../i18n/json/pt-BR.json":77,"../i18n/json/sv.json":78,"../i18n/json/th.json":79,"../i18n/json/tr.json":80,"../i18n/json/vi.json":81,"../i18n/json/zh-Hant.json":82}],88:[function(require,module,exports){
var HandlebarsCompiler=require("hbsfy/runtime");module.exports=HandlebarsCompiler.template({1:function(l,a,e,t,n){var o=null!=a?a:l.nullContext||{},s=e.helperMissing,c=l.escapeExpression;return'  <div class="b-add-text">'+c((e.loc||a&&a.loc||s).call(o,"Save",{name:"loc",hash:{},data:n}))+'</div>\n  <div class="b-added-text b-alt-text">'+c((e.loc||a&&a.loc||s).call(o,"Saved",{name:"loc",hash:{},data:n}))+'</div>\n  <div class="b-remove-text b-alt-text">'+c((e.loc||a&&a.loc||s).call(o,"Remove",{name:"loc",hash:{},data:n}))+"</div>\n"},3:function(l,a,e,t,n){var o=null!=a?a:l.nullContext||{},s=e.helperMissing,c=l.escapeExpression;return'  <div class="b-add-text">'+c((e.loc||a&&a.loc||s).call(o,"Follow",{name:"loc",hash:{},data:n}))+'</div>\n  <div class="b-added-text b-alt-text">'+c((e.loc||a&&a.loc||s).call(o,"Following",{name:"loc",hash:{},data:n}))+'</div>\n  <div class="b-remove-text b-alt-text">'+c((e.loc||a&&a.loc||s).call(o,"Unfollow",{name:"loc",hash:{},data:n}))+"</div>\n"},compiler:[7,">= 4.0.0"],main:function(l,a,e,t,n){var o,s=null!=a?a:l.nullContext||{},c=e.helperMissing;return(null!=(o=(e.type||a&&a.type||c).call(s,null!=a?a.uri:a,"track","album",{name:"type",hash:{},fn:l.program(1,n,0),inverse:l.noop,data:n}))?o:"")+"\n"+(null!=(o=(e.type||a&&a.type||c).call(s,null!=a?a.uri:a,"playlist","user","artist","station","show",{name:"type",hash:{},fn:l.program(3,n,0),inverse:l.noop,data:n}))?o:"")},useData:!0});

},{"hbsfy/runtime":383}],89:[function(require,module,exports){
var HandlebarsCompiler=require("hbsfy/runtime");module.exports=HandlebarsCompiler.template({compiler:[7,">= 4.0.0"],main:function(a,e,l,s,t){var n=null!=e?e:a.nullContext||{},r=l.helperMissing,i=a.escapeExpression;return'<div class="b-play-text">'+i((l.loc||e&&e.loc||r).call(n,"Play",{name:"loc",hash:{},data:t}))+'</div>\n<div class="b-pause-text b-alt-text">'+i((l.loc||e&&e.loc||r).call(n,"Pause",{name:"loc",hash:{},data:t}))+"</div>\n"},useData:!0});

},{"hbsfy/runtime":383}],90:[function(require,module,exports){
var HandlebarsCompiler=require("hbsfy/runtime"),partial$0=require("./internal/image-with-overlay.hbs");HandlebarsCompiler.registerPartial("./internal/image-with-overlay.hbs",partial$0),module.exports=HandlebarsCompiler.template({1:function(a,n,e,r,l){return"      card-video\n"},3:function(a,n,e,r,l){var t;return null!=(t=(e.compare||n&&n.compare||e.helperMissing).call(null!=n?n:a.nullContext||{},null!=n?n.isVideo:n,!1,{name:"compare",hash:{},fn:a.program(4,l,0),inverse:a.program(6,l,0),data:l}))?t:""},4:function(a,n,e,r,l){return""},6:function(a,n,e,r,l){var t,i=null!=n?n:a.nullContext||{},o=e.helperMissing;return null!=(t=(e.compare||n&&n.compare||o).call(i,(e.type||n&&n.type||o).call(i,null!=n?n.uri:n,{name:"type",hash:{},data:l}),"episode",{name:"compare",hash:{},fn:a.program(7,l,0),inverse:a.noop,data:l}))?t:""},7:function(a,n,e,r,l){return"          card-video\n"},9:function(a,n,e,r,l){return"card-type-station-"+a.escapeExpression((e.type||n&&n.type||e.helperMissing).call(null!=n?n:a.nullContext||{},null!=n?n.seedUri:n,{name:"type",hash:{},data:l}))},11:function(a,n,e,r,l){return"      card-show-attention-highlight\n"},13:function(a,n,e,r,l){return"no-image-url"},compiler:[7,">= 4.0.0"],main:function(a,n,e,r,l){var t,i,o=null!=n?n:a.nullContext||{},s=e.helperMissing,u=a.escapeExpression;return'<div\n  class="\n    card\n    card-type-'+u((e.type||n&&n.type||s).call(o,null!=n?n.uri:n,{name:"type",hash:{},data:l}))+"\n"+(null!=(t=(e.compare||n&&n.compare||s).call(o,null!=n?n.isVideo:n,!0,{name:"compare",hash:{},fn:a.program(1,l,0),inverse:a.program(3,l,0),data:l}))?t:"")+"    "+(null!=(t=e.if.call(o,null!=n?n.seedUri:n,{name:"if",hash:{},fn:a.program(9,l,0),inverse:a.noop,data:l}))?t:"")+"\n"+(null!=(t=e.if.call(o,null!=n?n.showAttentionHighlight:n,{name:"if",hash:{},fn:a.program(11,l,0),inverse:a.noop,data:l}))?t:"")+"    "+(null!=(t=e.unless.call(o,null!=n?n.imageUrl:n,{name:"unless",hash:{},fn:a.program(13,l,0),inverse:a.noop,data:l}))?t:"")+'\n  "\n  data-uri="'+u("function"==typeof(i=null!=(i=e.uri||(null!=n?n.uri:n))?i:s)?i.call(o,{name:"uri",hash:{},data:l}):i)+'"\n  data-contextmenu\n  data-drag-text="'+u("function"==typeof(i=null!=(i=e.dragText||(null!=n?n.dragText:n))?i:s)?i.call(o,{name:"dragText",hash:{},data:l}):i)+'"\n  draggable="true"\n  data-ta-id="card"\n>\n  <div class="card-attention-highlight-box">\n  </div>\n  <div class="card-image-wrapper" data-contextmenu-spy data-ta-id="card-image-wrapper">\n'+(null!=(t=a.invokePartial(r["./internal/image-with-overlay.hbs"],n,{name:"./internal/image-with-overlay.hbs",data:l,indent:"    ",helpers:e,partials:r,decorators:a.decorators}))?t:"")+"  </div>\n</div>\n"},usePartial:!0,useData:!0});

},{"./internal/image-with-overlay.hbs":94,"hbsfy/runtime":383}],91:[function(require,module,exports){
var HandlebarsCompiler=require("hbsfy/runtime"),partial$0=require("./internal/image-with-overlay.hbs");HandlebarsCompiler.registerPartial("./internal/image-with-overlay.hbs",partial$0);var partial$1=require("./internal/controls.hbs");HandlebarsCompiler.registerPartial("./internal/controls.hbs",partial$1);var partial$2=require("./internal/linked-image.hbs");HandlebarsCompiler.registerPartial("./internal/linked-image.hbs",partial$2);var partial$3=require("./internal/controls.hbs");HandlebarsCompiler.registerPartial("./internal/controls.hbs",partial$3),module.exports=HandlebarsCompiler.template({1:function(n,a,l,e,t){return"      card-video\n"},3:function(n,a,l,e,t){return"card-type-station-"+n.escapeExpression((l.type||a&&a.type||l.helperMissing).call(null!=a?a:n.nullContext||{},null!=a?a.seedUri:a,{name:"type",hash:{},data:t}))},5:function(n,a,l,e,t){return"      card-show-attention-highlight\n"},7:function(n,a,l,e,t){return"added"},9:function(n,a,l,e,t){return"no-image-url"},11:function(n,a,l,e,t){return"data-context"},13:function(n,a,l,e,t){var r;return'      <div class="card-image-hit-area" data-log-click="media-image">\n'+(null!=(r=n.invokePartial(e["./internal/image-with-overlay.hbs"],a,{name:"./internal/image-with-overlay.hbs",data:t,indent:"        ",helpers:l,partials:e,decorators:n.decorators}))?r:"")+"\n"+(null!=(r=l.unless.call(null!=a?a:n.nullContext||{},null!=a?a.noPlayButton:a,{name:"unless",hash:{},fn:n.program(14,t,0),inverse:n.noop,data:t}))?r:"")+"      </div>\n"},14:function(n,a,l,e,t){var r;return null!=(r=n.invokePartial(e["./internal/controls.hbs"],a,{name:"./internal/controls.hbs",data:t,indent:"          ",helpers:l,partials:e,decorators:n.decorators}))?r:""},16:function(n,a,l,e,t){var r;return'      <div class="card-image-hit-area" data-card-trigger-pressed-state>\n'+(null!=(r=n.invokePartial(e["./internal/linked-image.hbs"],a,{name:"./internal/linked-image.hbs",data:t,indent:"        ",helpers:l,partials:e,decorators:n.decorators}))?r:"")+"\n"+(null!=(r=l.unless.call(null!=a?a:n.nullContext||{},null!=a?a.noPlayButton:a,{name:"unless",hash:{},fn:n.program(14,t,0),inverse:n.noop,data:t}))?r:"")+"      </div>\n"},18:function(n,a,l,e,t){var r;return'      <div class="card-progress">\n        <div class="card-progress__bar" style="--progress: '+n.escapeExpression("function"==typeof(r=null!=(r=l.progress||(null!=a?a.progress:a))?r:l.helperMissing)?r.call(null!=a?a:n.nullContext||{},{name:"progress",hash:{},data:t}):r)+'"></div>\n      </div>\n'},20:function(n,a,l,e,t,r,i){var o,s=null!=a?a:n.nullContext||{};return'  <div\n    class="\n      card-info-wrapper\n'+(null!=(o=l.if.call(s,null!=a?a.subtitleLinks:a,{name:"if",hash:{},fn:n.program(21,t,0,r,i),inverse:n.program(23,t,0,r,i),data:t}))?o:"")+(null!=(o=l.if.call(s,null!=a?a.metadata:a,{name:"if",hash:{},fn:n.program(26,t,0,r,i),inverse:n.noop,data:t}))?o:"")+'    "\n  >\n    <div class="card-info-title">\n'+(null!=(o=l.if.call(s,null!=a?a.noLink:a,{name:"if",hash:{},fn:n.program(28,t,0,r,i),inverse:n.program(30,t,0,r,i),data:t}))?o:"")+"    </div>\n\n"+(null!=(o=l.if.call(s,null!=a?a.subtitleLinks:a,{name:"if",hash:{},fn:n.program(35,t,0,r,i),inverse:n.program(46,t,0,r,i),data:t}))?o:"")+"\n"+(null!=(o=l.if.call(s,null!=a?a.metadata:a,{name:"if",hash:{},fn:n.program(49,t,0,r,i),inverse:n.noop,data:t}))?o:"")+"  </div>\n"},21:function(n,a,l,e,t){return"        card-info-with-subtitle-links\n"},23:function(n,a,l,e,t){var r;return null!=(r=l.if.call(null!=a?a:n.nullContext||{},null!=a?a.description:a,{name:"if",hash:{},fn:n.program(24,t,0),inverse:n.noop,data:t}))?r:""},24:function(n,a,l,e,t){return"          card-info-with-description\n"},26:function(n,a,l,e,t){return"        card-info-with-metadata\n"},28:function(n,a,l,e,t){var r;return'        <span data-log-click="media-title" dir="auto">\n          '+n.escapeExpression("function"==typeof(r=null!=(r=l.title||(null!=a?a.title:a))?r:l.helperMissing)?r.call(null!=a?a:n.nullContext||{},{name:"title",hash:{},data:t}):r)+"\n        </span>\n"},30:function(n,a,l,e,t){var r,i,o=null!=a?a:n.nullContext||{},s=l.helperMissing,u=n.escapeExpression;return'      <a\n        href="'+(null!=(r=l.if.call(o,null!=a?a.targetUri:a,{name:"if",hash:{},fn:n.program(31,t,0),inverse:n.program(33,t,0),data:t}))?r:"")+'"\n        data-uri="'+u("function"==typeof(i=null!=(i=l.uri||(null!=a?a.uri:a))?i:s)?i.call(o,{name:"uri",hash:{},data:t}):i)+'"\n        data-log-click="media-title"\n        data-ta-id="card-title-link"\n        title="'+u("function"==typeof(i=null!=(i=l.title||(null!=a?a.title:a))?i:s)?i.call(o,{name:"title",hash:{},data:t}):i)+'"\n        data-interaction-target="title"\n        dir="auto"\n      >\n        '+u("function"==typeof(i=null!=(i=l.title||(null!=a?a.title:a))?i:s)?i.call(o,{name:"title",hash:{},data:t}):i)+"\n      </a>\n"},31:function(n,a,l,e,t){var r;return n.escapeExpression("function"==typeof(r=null!=(r=l.targetUri||(null!=a?a.targetUri:a))?r:l.helperMissing)?r.call(null!=a?a:n.nullContext||{},{name:"targetUri",hash:{},data:t}):r)},33:function(n,a,l,e,t){var r;return n.escapeExpression("function"==typeof(r=null!=(r=l.uri||(null!=a?a.uri:a))?r:l.helperMissing)?r.call(null!=a?a:n.nullContext||{},{name:"uri",hash:{},data:t}):r)},35:function(n,a,l,e,t,r,i){var o;return'    <div class="card-info-subtitle-links" data-interaction-context="subtitle-links">\n'+(null!=(o=l.each.call(null!=a?a:n.nullContext||{},null!=a?a.subtitleLinks:a,{name:"each",hash:{},fn:n.program(36,t,0,r,i),inverse:n.noop,data:t}))?o:"")+"    </div>\n"},36:function(n,a,l,e,t,r,i){var o;return null!=(o=(l.compare||a&&a.compare||l.helperMissing).call(null!=a?a:n.nullContext||{},null!=a?a.uri:a,"spotify:artist:0LyfQWJT6nXafLPZqxe9Of",{name:"compare",hash:{},fn:n.program(37,t,0,r,i),inverse:n.program(39,t,0,r,i),data:t}))?o:""},37:function(n,a,l,e,t){return"          "+n.escapeExpression((l.loc||a&&a.loc||l.helperMissing).call(null!=a?a:n.nullContext||{},"VariousArtistsCapitalized",{name:"loc",hash:{},data:t}))+"\n"},39:function(n,a,l,e,t,r,i){var o,s,u=null!=a?a:n.nullContext||{},c=l.helperMissing,d="function",p=n.escapeExpression;return'          <a\n            dir="auto"\n            title="'+p(typeof(s=null!=(s=l.name||(null!=a?a.name:a))?s:c)===d?s.call(u,{name:"name",hash:{},data:t}):s)+'"\n            href="'+p(typeof(s=null!=(s=l.uri||(null!=a?a.uri:a))?s:c)===d?s.call(u,{name:"uri",hash:{},data:t}):s)+'"\n            data-uri="'+p(typeof(s=null!=(s=l.uri||(null!=a?a.uri:a))?s:c)===d?s.call(u,{name:"uri",hash:{},data:t}):s)+'"\n            data-ta-id="card-subtitle-link"\n            data-interaction-target="'+p(typeof(s=null!=(s=l.index||t&&t.index)?s:c)===d?s.call(u,{name:"index",hash:{},data:t}):s)+'"\n'+(null!=(o=(l.compare||a&&a.compare||c).call(u,(l.type||a&&a.type||c).call(u,null!=i[1]?i[1].uri:i[1],{name:"type",hash:{},data:t}),"album",{name:"compare",hash:{operator:"=="},fn:n.program(40,t,0,r,i),inverse:n.noop,data:t}))?o:"")+(null!=(o=(l.compare||a&&a.compare||c).call(u,(l.type||a&&a.type||c).call(u,null!=i[1]?i[1].uri:i[1],{name:"type",hash:{},data:t}),"playlist",{name:"compare",hash:{operator:"=="},fn:n.program(42,t,0,r,i),inverse:n.noop,data:t}))?o:"")+"          >"+p(typeof(s=null!=(s=l.name||(null!=a?a.name:a))?s:c)===d?s.call(u,{name:"name",hash:{},data:t}):s)+"</a>"+(null!=(o=l.unless.call(u,t&&t.last,{name:"unless",hash:{},fn:n.program(44,t,0,r,i),inverse:n.noop,data:t}))?o:"")+"\n"},40:function(n,a,l,e,t){return'              data-log-click="artist-name"\n'},42:function(n,a,l,e,t){return'              data-log-click="owner-name"\n'},44:function(n,a,l,e,t){return", "},46:function(n,a,l,e,t){var r;return null!=(r=l.if.call(null!=a?a:n.nullContext||{},null!=a?a.description:a,{name:"if",hash:{},fn:n.program(47,t,0),inverse:n.noop,data:t}))?r:""},47:function(n,a,l,e,t){var r;return'      <div class="card-info-subtitle-description" data-ta-id="card-description">\n        <span dir="auto">'+n.escapeExpression("function"==typeof(r=null!=(r=l.description||(null!=a?a.description:a))?r:l.helperMissing)?r.call(null!=a?a:n.nullContext||{},{name:"description",hash:{},data:t}):r)+"</span>\n      </div>\n"},49:function(n,a,l,e,t){var r,i,o=null!=a?a:n.nullContext||{};return'    <div class="card-info-subtitle-metadata" data-ta-id="card-metadata">\n'+(null!=(r=l.if.call(o,null!=a?a.isNew:a,{name:"if",hash:{},fn:n.program(50,t,0),inverse:n.noop,data:t}))?r:"")+"      "+n.escapeExpression("function"==typeof(i=null!=(i=l.metadata||(null!=a?a.metadata:a))?i:l.helperMissing)?i.call(o,{name:"metadata",hash:{},data:t}):i)+"\n    </div>\n"},50:function(n,a,l,e,t){return'      <div class="card-info-subtitle-new-mark"></div>\n'},compiler:[7,">= 4.0.0"],main:function(n,a,l,e,t,r,i){var o,s,u,c=null!=a?a:n.nullContext||{},d=l.helperMissing,p=n.escapeExpression,h='<div\n  class="\n    card\n    card-type-'+p((l.type||a&&a.type||d).call(c,null!=a?a.uri:a,{name:"type",hash:{},data:t}))+"\n"+(null!=(o=(l.compare||a&&a.compare||d).call(c,null!=a?a.isVideo:a,!0,{name:"compare",hash:{},fn:n.program(1,t,0,r,i),inverse:n.noop,data:t}))?o:"")+"    "+(null!=(o=l.if.call(c,null!=a?a.seedUri:a,{name:"if",hash:{},fn:n.program(3,t,0,r,i),inverse:n.noop,data:t}))?o:"")+"\n"+(null!=(o=l.if.call(c,null!=a?a.showAttentionHighlight:a,{name:"if",hash:{},fn:n.program(5,t,0,r,i),inverse:n.noop,data:t}))?o:"")+"    "+(null!=(o=l.if.call(c,null!=a?a.added:a,{name:"if",hash:{},fn:n.program(7,t,0,r,i),inverse:n.noop,data:t}))?o:"")+"\n    "+(null!=(o=l.unless.call(c,null!=a?a.imageUrl:a,{name:"unless",hash:{},fn:n.program(9,t,0,r,i),inverse:n.noop,data:t}))?o:"")+'\n  "\n  data-log-context="media-object"\n  data-interaction-context="card"\n  data-log-data=\'{ "name": "'+p("function"==typeof(s=null!=(s=l.title||(null!=a?a.title:a))?s:d)?s.call(c,{name:"title",hash:{},data:t}):s)+'", "target_uri": "'+p("function"==typeof(s=null!=(s=l.uri||(null!=a?a.uri:a))?s:d)?s.call(c,{name:"uri",hash:{},data:t}):s)+'" }\'\n  data-uri="'+p("function"==typeof(s=null!=(s=l.uri||(null!=a?a.uri:a))?s:d)?s.call(c,{name:"uri",hash:{},data:t}):s)+'"\n  data-contextmenu\n  ';return s=null!=(s=l.noContext||(null!=a?a.noContext:a))?s:d,u={name:"noContext",hash:{},fn:n.noop,inverse:n.program(11,t,0,r,i),data:t},o="function"==typeof s?s.call(c,u):s,l.noContext||(o=l.blockHelperMissing.call(a,o,u)),null!=o&&(h+=o),h+'\n  data-card-pressed-container\n  data-ta-id="card"\n>\n  <div class="card-attention-highlight-box">\n  </div>\n  <div class="card-image-wrapper" data-contextmenu-spy data-ta-id="card-image-wrapper">\n'+(null!=(o=l.if.call(c,null!=a?a.noLink:a,{name:"if",hash:{},fn:n.program(13,t,0,r,i),inverse:n.program(16,t,0,r,i),data:t}))?o:"")+(null!=(o=l.if.call(c,null!=a?a.progress:a,{name:"if",hash:{},fn:n.program(18,t,0,r,i),inverse:n.noop,data:t}))?o:"")+"  </div>\n\n"+(null!=(o=l.if.call(c,null!=a?a.title:a,{name:"if",hash:{},fn:n.program(20,t,0,r,i),inverse:n.noop,data:t}))?o:"")+"\n</div>\n"},usePartial:!0,useData:!0,useDepths:!0});

},{"./internal/controls.hbs":93,"./internal/image-with-overlay.hbs":94,"./internal/linked-image.hbs":96,"hbsfy/runtime":383}],92:[function(require,module,exports){
var HandlebarsCompiler=require("hbsfy/runtime");module.exports=HandlebarsCompiler.template({1:function(n,t,a,l,e){var r;return'  <button\n    type="button"\n    class="button button-play button-icon-with-stroke card-button-play"\n    data-ta-id="card-button-play"\n    data-log-click="play-button"\n    data-interaction-target="play-pause-button"\n    data-interaction-intent="play"\n'+(null!=(r=a.if.call(null!=t?t:n.nullContext||{},null!=t?t.range:t,{name:"if",hash:{},fn:n.program(2,e,0),inverse:n.program(5,e,0),data:e}))?r:"")+"  >\n  </button>\n"},2:function(n,t,a,l,e){var r,o,u,i='      data-button="play"\n      ';return o=null!=(o=a.range||(null!=t?t.range:t))?o:a.helperMissing,u={name:"range",hash:{},fn:n.program(3,e,0),inverse:n.noop,data:e},r="function"==typeof o?o.call(null!=t?t:n.nullContext||{},u):o,a.range||(r=a.blockHelperMissing.call(t,r,u)),null!=r&&(i+=r),i+"\n"},3:function(n,t,a,l,e){var r,o=null!=t?t:n.nullContext||{},u=a.helperMissing,i=n.escapeExpression;return'data-range="'+i("function"==typeof(r=null!=(r=a.start||(null!=t?t.start:t))?r:u)?r.call(o,{name:"start",hash:{},data:e}):r)+","+i("function"==typeof(r=null!=(r=a.end||(null!=t?t.end:t))?r:u)?r.call(o,{name:"end",hash:{},data:e}):r)+'"'},5:function(n,t,a,l,e){var r,o=null!=t?t:n.nullContext||{};return(null!=(r=a.if.call(o,null!=t?t.contextPage:t,{name:"if",hash:{},fn:n.program(6,e,0),inverse:n.program(9,e,0),data:e}))?r:"")+(null!=(r=a.if.call(o,null!=t?t.contextIndex:t,{name:"if",hash:{},fn:n.program(15,e,0),inverse:n.noop,data:e}))?r:"")},6:function(n,t,a,l,e){var r,o,u,i='        data-button="play"\n        ';return o=null!=(o=a.contextPage||(null!=t?t.contextPage:t))?o:a.helperMissing,u={name:"contextPage",hash:{},fn:n.program(7,e,0),inverse:n.noop,data:e},r="function"==typeof o?o.call(null!=t?t:n.nullContext||{},u):o,a.contextPage||(r=a.blockHelperMissing.call(t,r,u)),null!=r&&(i+=r),i+"\n"},7:function(n,t,a,l,e){return'data-context-page="'+n.escapeExpression(n.lambda(t,t))+'"'},9:function(n,t,a,l,e){var r;return null!=(r=a.if.call(null!=t?t:n.nullContext||{},null!=t?t.trackUri:t,{name:"if",hash:{},fn:n.program(10,e,0),inverse:n.program(13,e,0),data:e}))?r:""},10:function(n,t,a,l,e){var r,o,u,i="          ";return o=null!=(o=a.trackUri||(null!=t?t.trackUri:t))?o:a.helperMissing,u={name:"trackUri",hash:{},fn:n.program(11,e,0),inverse:n.noop,data:e},r="function"==typeof o?o.call(null!=t?t:n.nullContext||{},u):o,a.trackUri||(r=a.blockHelperMissing.call(t,r,u)),null!=r&&(i+=r),i+'\n          data-button="play"\n'},11:function(n,t,a,l,e){return'data-track-uri="'+n.escapeExpression(n.lambda(t,t))+'"'},13:function(n,t,a,l,e){return'          data-button="play-context"\n'},15:function(n,t,a,l,e){var r;return'        data-context-index="'+n.escapeExpression("function"==typeof(r=null!=(r=a.contextIndex||(null!=t?t.contextIndex:t))?r:a.helperMissing)?r.call(null!=t?t:n.nullContext||{},{name:"contextIndex",hash:{},data:e}):r)+'"\n'},compiler:[7,">= 4.0.0"],main:function(n,t,a,l,e){var r;return null!=(r=(a.type||t&&t.type||a.helperMissing).call(null!=t?t:n.nullContext||{},null!=t?t.uri:t,"playlist","track","album","station","artist","episode","collection-album","collection-artist","show","dailymix",{name:"type",hash:{},fn:n.program(1,e,0),inverse:n.noop,data:e}))?r:""},useData:!0});

},{"hbsfy/runtime":383}],93:[function(require,module,exports){
var HandlebarsCompiler=require("hbsfy/runtime"),partial$0=require("./controls-play-button.hbs");HandlebarsCompiler.registerPartial("./controls-play-button.hbs",partial$0),module.exports=HandlebarsCompiler.template({1:function(n,t,a,l,e){var o;return null!=(o=(a.type||t&&t.type||a.helperMissing).call(null!=t?t:n.nullContext||{},null!=t?t.uri:t,"playlist","track","album","station","artist","show","collection-album","collection-artist",{name:"type",hash:{},fn:n.program(2,e,0),inverse:n.noop,data:e}))?o:""},2:function(n,t,a,l,e){var o,r,u,i=null!=t?t:n.nullContext||{},s=a.helperMissing,c="";return r=null!=(r=a.nft||(null!=t?t.nft:t))?r:s,u={name:"nft",hash:{},fn:n.program(3,e,0),inverse:n.program(14,e,0),data:e},o="function"==typeof r?r.call(i,u):r,a.nft||(o=a.blockHelperMissing.call(t,o,u)),null!=o&&(c+=o),c+"\n"+(null!=(o=(a.type||t&&t.type||s).call(i,null!=t?t.uri:t,"playlist","artist","show","collection-artist",{name:"type",hash:{},fn:n.program(20,e,0),inverse:n.noop,data:e}))?o:"")+(null!=(o=(a.type||t&&t.type||s).call(i,null!=t?t.uri:t,"station",{name:"type",hash:{},fn:n.program(28,e,0),inverse:n.noop,data:e}))?o:"")},3:function(n,t,a,l,e){var o,r=null!=t?t:n.nullContext||{},u=a.helperMissing;return(null!=(o=(a.type||t&&t.type||u).call(r,null!=t?t.uri:t,"album","collection-album",{name:"type",hash:{},fn:n.program(4,e,0),inverse:n.noop,data:e}))?o:"")+(null!=(o=(a.type||t&&t.type||u).call(r,null!=t?t.uri:t,"track",{name:"type",hash:{},fn:n.program(9,e,0),inverse:n.noop,data:e}))?o:"")},4:function(n,t,a,l,e){var o,r=null!=t?t:n.nullContext||{},u=a.helperMissing,i=n.escapeExpression;return'        <button\n          type="button"\n          data-button="add"\n          class="button button-add card-button-add"\n          data-ta-id="card-button-add"\n          data-tooltip="'+(null!=(o=a.if.call(r,null!=t?t.added:t,{name:"if",hash:{},fn:n.program(5,e,0),inverse:n.program(7,e,0),data:e}))?o:"")+'"\n          data-tooltip-add="'+i((a.loc||t&&t.loc||u).call(r,"SaveYourMusic",{name:"loc",hash:{},data:e}))+'"\n          data-tooltip-remove="'+i((a.loc||t&&t.loc||u).call(r,"RemoveYourMusic",{name:"loc",hash:{},data:e}))+'"\n          data-log-click="add-button"\n          data-interaction-target="save-remove-button"\n          data-interaction-intent="save"></button>\n'},5:function(n,t,a,l,e){return n.escapeExpression((a.loc||t&&t.loc||a.helperMissing).call(null!=t?t:n.nullContext||{},"RemoveYourMusic",{name:"loc",hash:{},data:e}))},7:function(n,t,a,l,e){return n.escapeExpression((a.loc||t&&t.loc||a.helperMissing).call(null!=t?t:n.nullContext||{},"SaveYourMusic",{name:"loc",hash:{},data:e}))},9:function(n,t,a,l,e){var o,r=null!=t?t:n.nullContext||{},u=a.helperMissing,i=n.escapeExpression;return'        <button\n          type="button"\n          data-button="add"\n          class="button button-add card-button-add"\n          data-ta-id="card-button-add"\n          data-tooltip="'+(null!=(o=a.if.call(r,null!=t?t.added:t,{name:"if",hash:{},fn:n.program(10,e,0),inverse:n.program(12,e,0),data:e}))?o:"")+'"\n          data-tooltip-add="'+i((a.loc||t&&t.loc||u).call(r,"SaveToYourFavoriteSongs",{name:"loc",hash:{},data:e}))+'"\n          data-tooltip-remove="'+i((a.loc||t&&t.loc||u).call(r,"RemoveFromYourFavoriteSongs",{name:"loc",hash:{},data:e}))+'"\n          data-log-click="add-button"\n          data-interaction-target="save-remove-button"\n          data-interaction-intent="save"></button>\n'},10:function(n,t,a,l,e){return n.escapeExpression((a.loc||t&&t.loc||a.helperMissing).call(null!=t?t:n.nullContext||{},"RemoveFromYourFavoriteSongs",{name:"loc",hash:{},data:e}))},12:function(n,t,a,l,e){return n.escapeExpression((a.loc||t&&t.loc||a.helperMissing).call(null!=t?t:n.nullContext||{},"SaveToYourFavoriteSongs",{name:"loc",hash:{},data:e}))},14:function(n,t,a,l,e){var o;return null!=(o=(a.type||t&&t.type||a.helperMissing).call(null!=t?t:n.nullContext||{},null!=t?t.uri:t,"track","album","collection-album",{name:"type",hash:{},fn:n.program(15,e,0),inverse:n.noop,data:e}))?o:""},15:function(n,t,a,l,e){var o,r=null!=t?t:n.nullContext||{},u=a.helperMissing,i=n.escapeExpression;return'        <button\n          type="button"\n          data-button="add"\n          class="button button-add card-button-add"\n          data-ta-id="card-button-add"\n          data-tooltip="'+(null!=(o=a.if.call(r,null!=t?t.added:t,{name:"if",hash:{},fn:n.program(16,e,0),inverse:n.program(18,e,0),data:e}))?o:"")+'"\n          data-tooltip-add="'+i((a.loc||t&&t.loc||u).call(r,"Save",{name:"loc",hash:{},data:e}))+'"\n          data-tooltip-remove="'+i((a.loc||t&&t.loc||u).call(r,"Remove",{name:"loc",hash:{},data:e}))+'"\n          data-log-click="add-button"\n          data-interaction-target="save-remove-button"\n          data-interaction-intent="save"></button>\n'},16:function(n,t,a,l,e){return n.escapeExpression((a.loc||t&&t.loc||a.helperMissing).call(null!=t?t:n.nullContext||{},"Remove",{name:"loc",hash:{},data:e}))},18:function(n,t,a,l,e){return n.escapeExpression((a.loc||t&&t.loc||a.helperMissing).call(null!=t?t:n.nullContext||{},"Save",{name:"loc",hash:{},data:e}))},20:function(n,t,a,l,e){var o,r,u,i="";return r=null!=(r=a.currentUserPlaylist||(null!=t?t.currentUserPlaylist:t))?r:a.helperMissing,u={name:"currentUserPlaylist",hash:{},fn:n.noop,inverse:n.program(21,e,0),data:e},o="function"==typeof r?r.call(null!=t?t:n.nullContext||{},u):r,a.currentUserPlaylist||(o=a.blockHelperMissing.call(t,o,u)),null!=o&&(i+=o),i},21:function(n,t,a,l,e){var o,r,u,i=null!=t?t:n.nullContext||{},s=a.helperMissing,c=a.blockHelperMissing,p='      <button\n        type="button"\n        data-button="add"\n        class="button button-add card-button-add"\n        data-ta-id="card-button-add"\n        data-tooltip="'+(null!=(o=a.if.call(i,null!=t?t.added:t,{name:"if",hash:{},fn:n.program(22,e,0),inverse:n.program(25,e,0),data:e}))?o:"")+'"\n        data-tooltip-add="';return r=null!=(r=a.nft||(null!=t?t.nft:t))?r:s,u={name:"nft",hash:{},fn:n.program(7,e,0),inverse:n.program(26,e,0),data:e},o="function"==typeof r?r.call(i,u):r,a.nft||(o=c.call(t,o,u)),null!=o&&(p+=o),p+='"\n        data-tooltip-remove="',r=null!=(r=a.nft||(null!=t?t.nft:t))?r:s,u={name:"nft",hash:{},fn:n.program(5,e,0),inverse:n.program(23,e,0),data:e},o="function"==typeof r?r.call(i,u):r,a.nft||(o=c.call(t,o,u)),null!=o&&(p+=o),p+'"\n        data-log-click="follow-button"\n        data-interaction-target="toggle-follow-state-button"\n        data-interaction-intent="follow"></button>\n'},22:function(n,t,a,l,e){var o,r,u,i="";return r=null!=(r=a.nft||(null!=t?t.nft:t))?r:a.helperMissing,u={name:"nft",hash:{},fn:n.program(5,e,0),inverse:n.program(23,e,0),data:e},o="function"==typeof r?r.call(null!=t?t:n.nullContext||{},u):r,a.nft||(o=a.blockHelperMissing.call(t,o,u)),null!=o&&(i+=o),i},23:function(n,t,a,l,e){return n.escapeExpression((a.loc||t&&t.loc||a.helperMissing).call(null!=t?t:n.nullContext||{},"Unfollow",{name:"loc",hash:{},data:e}))},25:function(n,t,a,l,e){var o,r,u,i="";return r=null!=(r=a.nft||(null!=t?t.nft:t))?r:a.helperMissing,u={name:"nft",hash:{},fn:n.program(7,e,0),inverse:n.program(26,e,0),data:e},o="function"==typeof r?r.call(null!=t?t:n.nullContext||{},u):r,a.nft||(o=a.blockHelperMissing.call(t,o,u)),null!=o&&(i+=o),i},26:function(n,t,a,l,e){return n.escapeExpression((a.loc||t&&t.loc||a.helperMissing).call(null!=t?t:n.nullContext||{},"Follow",{name:"loc",hash:{},data:e}))},28:function(n,t,a,l,e){var o,r=null!=t?t:n.nullContext||{},u=a.helperMissing;return null!=(o=(a.compare||t&&t.compare||u).call(r,(a.type||t&&t.type||u).call(r,null!=t?t.seedUri:t,{name:"type",hash:{},data:e}),"cluster",{name:"compare",hash:{operator:"!="},fn:n.program(21,e,0),inverse:n.noop,data:e}))?o:""},30:function(n,t,a,l,e){var o;return null!=(o=(a.type||t&&t.type||a.helperMissing).call(null!=t?t:n.nullContext||{},null!=t?t.uri:t,"playlist","track","album","station","artist","collection-album","collection-artist",{name:"type",hash:{},fn:n.program(31,e,0),inverse:n.noop,data:e}))?o:""},31:function(n,t,a,l,e){return'    <button\n      type="button"\n      data-button="contextmenu"\n      class="button button-more button-no-border card-button-more"\n      data-ta-id="card-button-context-menu"\n      data-tooltip="'+n.escapeExpression((a.loc||t&&t.loc||a.helperMissing).call(null!=t?t:n.nullContext||{},"More",{name:"loc",hash:{},data:e}))+'"\n      data-log-click="context-menu-button"\n      data-interaction-target="context-menu-button"\n      data-interaction-intent="show-options"></button>\n'},compiler:[7,">= 4.0.0"],main:function(n,t,a,l,e){var o,r=null!=t?t:n.nullContext||{};return(null!=(o=a.unless.call(r,null!=t?t.playButtonOnly:t,{name:"unless",hash:{},fn:n.program(1,e,0),inverse:n.noop,data:e}))?o:"")+"\n"+(null!=(o=n.invokePartial(l["./controls-play-button.hbs"],t,{name:"./controls-play-button.hbs",data:e,helpers:a,partials:l,decorators:n.decorators}))?o:"")+"\n"+(null!=(o=a.unless.call(r,null!=t?t.playButtonOnly:t,{name:"unless",hash:{},fn:n.program(30,e,0),inverse:n.noop,data:e}))?o:"")},usePartial:!0,useData:!0});

},{"./controls-play-button.hbs":92,"hbsfy/runtime":383}],94:[function(require,module,exports){
var HandlebarsCompiler=require("hbsfy/runtime"),partial$0=require("./image.hbs");HandlebarsCompiler.registerPartial("./image.hbs",partial$0),module.exports=HandlebarsCompiler.template({1:function(a,e,r,l,n){return'  <div class="card-overlay"></div>\n'},compiler:[7,">= 4.0.0"],main:function(a,e,r,l,n){var i;return(null!=(i=a.invokePartial(l["./image.hbs"],e,{name:"./image.hbs",data:n,helpers:r,partials:l,decorators:a.decorators}))?i:"")+"\n"+(null!=(i=r.unless.call(null!=e?e:a.nullContext||{},null!=e?e.noPlayButton:e,{name:"unless",hash:{},fn:a.program(1,n,0),inverse:a.noop,data:n}))?i:"")},usePartial:!0,useData:!0});

},{"./image.hbs":95,"hbsfy/runtime":383}],95:[function(require,module,exports){
var HandlebarsCompiler=require("hbsfy/runtime"),partial$0=require("./placeholder.hbs");HandlebarsCompiler.registerPartial("./placeholder.hbs",partial$0),module.exports=HandlebarsCompiler.template({1:function(a,l,n,e,r){var i;return"style=\"background-image: url('"+a.escapeExpression("function"==typeof(i=null!=(i=n.imageUrl||(null!=l?l.imageUrl:l))?i:n.helperMissing)?i.call(null!=l?l:a.nullContext||{},{name:"imageUrl",hash:{},data:r}):i)+"')\""},3:function(a,l,n,e,r){var i;return'      data-image-url="'+a.escapeExpression("function"==typeof(i=null!=(i=n.imageUrl||(null!=l?l.imageUrl:l))?i:n.helperMissing)?i.call(null!=l?l:a.nullContext||{},{name:"imageUrl",hash:{},data:r}):i)+'"\n'},5:function(a,l,n,e,r){var i,t=null!=l?l:a.nullContext||{},o=n.helperMissing;return null!=(i=(n.compare||l&&l.compare||o).call(t,(n.type||l&&l.type||o).call(t,null!=l?l.seedUri:l,{name:"type",hash:{},data:r}),"cluster",{name:"compare",hash:{operator:"!="},fn:a.program(6,r,0),inverse:a.noop,data:r}))?i:""},6:function(a,l,n,e,r){var i,t=null!=l?l:a.nullContext||{};return(null!=(i=n.if.call(t,null!=l?l.dominantColor:l,{name:"if",hash:{},fn:a.program(7,r,0),inverse:a.noop,data:r}))?i:"")+'      <div class="card-station-layer card-station-mask"></div>\n'+(null!=(i=n.if.call(t,null!=l?l.imageUrl:l,{name:"if",hash:{},fn:a.program(9,r,0),inverse:a.noop,data:r}))?i:"")},7:function(a,l,n,e,r){var i;return'        <div class="card-station-layer card-station-highlight" style="background-color:'+a.escapeExpression("function"==typeof(i=null!=(i=n.dominantColor||(null!=l?l.dominantColor:l))?i:n.helperMissing)?i.call(null!=l?l:a.nullContext||{},{name:"dominantColor",hash:{},data:r}):i)+'"></div>\n'},9:function(a,l,n,e,r){var i;return'        <div class="card-station-overlay" style="background-image: url('+a.escapeExpression("function"==typeof(i=null!=(i=n.imageUrl||(null!=l?l.imageUrl:l))?i:n.helperMissing)?i.call(null!=l?l:a.nullContext||{},{name:"imageUrl",hash:{},data:r}):i)+')"></div>\n'},compiler:[7,">= 4.0.0"],main:function(a,l,n,e,r){var i,t=null!=l?l:a.nullContext||{};return(null!=(i=a.invokePartial(e["./placeholder.hbs"],l,{name:"./placeholder.hbs",data:r,helpers:n,partials:e,decorators:a.decorators}))?i:"")+'\n<div class="card-image-content-wrapper">\n  <div\n    class="card-image"\n    '+(null!=(i=n.if.call(t,null!=l?l.imageUrl:l,{name:"if",hash:{},fn:a.program(1,r,0),inverse:a.noop,data:r}))?i:"")+'\n    data-ta-id="card-image"\n'+(null!=(i=n.if.call(t,null!=l?l.imageUrl:l,{name:"if",hash:{},fn:a.program(3,r,0),inverse:a.noop,data:r}))?i:"")+"  >\n  </div>\n\n"+(null!=(i=(n.type||l&&l.type||n.helperMissing).call(t,null!=l?l.uri:l,"station",{name:"type",hash:{},fn:a.program(5,r,0),inverse:a.noop,data:r}))?i:"")+"</div>\n"},usePartial:!0,useData:!0});

},{"./placeholder.hbs":97,"hbsfy/runtime":383}],96:[function(require,module,exports){
var HandlebarsCompiler=require("hbsfy/runtime"),partial$0=require("./image-with-overlay.hbs");HandlebarsCompiler.registerPartial("./image-with-overlay.hbs",partial$0),module.exports=HandlebarsCompiler.template({1:function(a,e,n,l,r){var t;return a.escapeExpression("function"==typeof(t=null!=(t=n.dragText||(null!=e?e.dragText:e))?t:n.helperMissing)?t.call(null!=e?e:a.nullContext||{},{name:"dragText",hash:{},data:r}):t)},3:function(a,e,n,l,r){var t;return a.escapeExpression("function"==typeof(t=null!=(t=n.title||(null!=e?e.title:e))?t:n.helperMissing)?t.call(null!=e?e:a.nullContext||{},{name:"title",hash:{},data:r}):t)},5:function(a,e,n,l,r){return"no-image-url"},compiler:[7,">= 4.0.0"],main:function(a,e,n,l,r){var t,i,u=null!=e?e:a.nullContext||{},s=n.helperMissing,o=a.escapeExpression;return'<a\n  href="'+o("function"==typeof(i=null!=(i=n.uri||(null!=e?e.uri:e))?i:s)?i.call(u,{name:"uri",hash:{},data:r}):i)+'"\n  data-uri="'+o("function"==typeof(i=null!=(i=n.uri||(null!=e?e.uri:e))?i:s)?i.call(u,{name:"uri",hash:{},data:r}):i)+'"\n  data-log-click="media-image"\n  draggable="true"\n  data-drag-text="'+(null!=(t=n.if.call(u,null!=e?e.dragText:e,{name:"if",hash:{},fn:a.program(1,r,0),inverse:a.program(3,r,0),data:r}))?t:"")+'"\n  class="card-image-link '+(null!=(t=n.unless.call(u,null!=e?e.imageUrl:e,{name:"unless",hash:{},fn:a.program(5,r,0),inverse:a.noop,data:r}))?t:"")+'"\n  data-interaction-target="image"\n  aria-hidden="true"\n>\n  <div class="card-hit-area-counter-scale"></div>\n'+(null!=(t=a.invokePartial(l["./image-with-overlay.hbs"],e,{name:"./image-with-overlay.hbs",data:r,indent:"  ",helpers:n,partials:l,decorators:a.decorators}))?t:"")+"</a>\n"},usePartial:!0,useData:!0});

},{"./image-with-overlay.hbs":94,"hbsfy/runtime":383}],97:[function(require,module,exports){
var HandlebarsCompiler=require("hbsfy/runtime");module.exports=HandlebarsCompiler.template({compiler:[7,">= 4.0.0"],main:function(e,t,l,a,x){return'<div class="card-placeholder-wrapper">\n  <svg class="card-placeholder" viewBox="0 0 10 10" preserveAspectRatio="xMidYMid meet">\n    <text class="playlist-placeholder" x="5" y="9.8">&#xf135;</text>\n    <text class="playlist-folder-placeholder" x="5" y="9.8">&#xf137;</text>\n    <text class="album-placeholder" x="5" y="9.8">&#xf101;</text>\n    <text class="track-placeholder" x="5" y="9.8">&#xf157;</text>\n    <text class="artist-placeholder" x="5" y="9.8">&#xf103;</text>\n    <text class="user-placeholder" x="5" y="9.8">&#xf15d;</text>\n    <text class="genre-placeholder" x="5" y="9.8">&#xf109;</text>\n    <text class="collection-placeholder" x="5" y="9.8">&#xf157;</text>\n    <text class="local-files-placeholder" x="5" y="9.8">&#xf1fb;</text>\n    <text class="episode-placeholder" x="5" y="9.8">&#xf26C;</text>\n  </svg>\n</div>\n'},useData:!0});

},{"hbsfy/runtime":383}],98:[function(require,module,exports){
var HandlebarsCompiler=require("hbsfy/runtime");module.exports=HandlebarsCompiler.template({1:function(e,n,l,a,r){var s,o=null!=n?n:e.nullContext||{},t=l.helperMissing;return'        <h1 class="error-content-title">'+e.escapeExpression((l.loc||n&&n.loc||t).call(o,"ErrorTitle",{name:"loc",hash:{},data:r}))+'</h1>\n        <div class="message">'+(null!=(s=(l.loc||n&&n.loc||t).call(o,"ErrorMessage",{name:"loc",hash:{},data:r}))?s:"")+"</div>\n"},3:function(e,n,l,a,r){var s,o,t=null!=n?n:e.nullContext||{},i=l.helperMissing;return'        <h1 class="error-content-title">'+e.escapeExpression("function"==typeof(o=null!=(o=l.errorTitle||(null!=n?n.errorTitle:n))?o:i)?o.call(t,{name:"errorTitle",hash:{},data:r}):o)+'</h1>\n        <div class="message">'+(null!=(s="function"==typeof(o=null!=(o=l.errorMessage||(null!=n?n.errorMessage:n))?o:i)?o.call(t,{name:"errorMessage",hash:{},data:r}):o)?s:"")+"</div>\n"},5:function(e,n,l,a,r){var s,o=null!=n?n:e.nullContext||{},t=l.helperMissing,i=e.escapeExpression;return'        <button\n          class="button button-white"\n          data-button-link="'+i("function"==typeof(s=null!=(s=l.errorEscapeUrl||(null!=n?n.errorEscapeUrl:n))?s:t)?s.call(o,{name:"errorEscapeUrl",hash:{},data:r}):s)+'"\n          data-log-click="error-escape"\n        >\n          '+i("function"==typeof(s=null!=(s=l.errorEscapeMessage||(null!=n?n.errorEscapeMessage:n))?s:t)?s.call(o,{name:"errorEscapeMessage",hash:{},data:r}):s)+"\n        </a>\n"},7:function(e,n,l,a,r){var s,o=null!=n?n:e.nullContext||{},t=l.helperMissing;return'        <h1 class="offline-content-title">'+e.escapeExpression((l.loc||n&&n.loc||t).call(o,"OfflineTitle",{name:"loc",hash:{},data:r}))+'</h1>\n        <div class="message">'+(null!=(s=(l.loc||n&&n.loc||t).call(o,"OfflineMessage",{name:"loc",hash:{},data:r}))?s:"")+"</div>\n"},9:function(e,n,l,a,r){var s,o,t=null!=n?n:e.nullContext||{},i=l.helperMissing;return'        <h1 class="offline-content-title">'+e.escapeExpression("function"==typeof(o=null!=(o=l.offlineTitle||(null!=n?n.offlineTitle:n))?o:i)?o.call(t,{name:"offlineTitle",hash:{},data:r}):o)+'</h1>\n        <div class="message">'+(null!=(s="function"==typeof(o=null!=(o=l.offlineMessage||(null!=n?n.offlineMessage:n))?o:i)?o.call(t,{name:"offlineMessage",hash:{},data:r}):o)?s:"")+"</div>\n"},11:function(e,n,l,a,r){var s,o=null!=n?n:e.nullContext||{},t=l.helperMissing,i=e.escapeExpression;return'        <button\n          class="button button-white"\n          data-button-link="'+i("function"==typeof(s=null!=(s=l.offlineEscapeUrl||(null!=n?n.offlineEscapeUrl:n))?s:t)?s.call(o,{name:"offlineEscapeUrl",hash:{},data:r}):s)+'"\n          data-log-click="offline-escape"\n        >\n          '+i("function"==typeof(s=null!=(s=l.offlineEscapeMessage||(null!=n?n.offlineEscapeMessage:n))?s:t)?s.call(o,{name:"offlineEscapeMessage",hash:{},data:r}):s)+"\n        </button>\n"},13:function(e,n,l,a,r){var s;return'  <div class="error-version">'+e.escapeExpression("function"==typeof(s=null!=(s=l.errorVersion||(null!=n?n.errorVersion:n))?s:l.helperMissing)?s.call(null!=n?n:e.nullContext||{},{name:"errorVersion",hash:{},data:r}):s)+"</div>\n"},compiler:[7,">= 4.0.0"],main:function(e,n,l,a,r){var s,o=null!=n?n:e.nullContext||{};return'<div class="error-and-offline" data-log-context="error-and-offline">\n  <div class="container">\n    <div class="error-content">\n'+(null!=(s=l.if.call(o,null!=n?n.useDefaultError:n,{name:"if",hash:{},fn:e.program(1,r,0),inverse:e.program(3,r,0),data:r}))?s:"")+(null!=(s=l.if.call(o,null!=n?n.errorEscapeMessage:n,{name:"if",hash:{},fn:e.program(5,r,0),inverse:e.noop,data:r}))?s:"")+'    </div>\n    <div class="offline-content">\n'+(null!=(s=l.if.call(o,null!=n?n.useDefaultOffline:n,{name:"if",hash:{},fn:e.program(7,r,0),inverse:e.program(9,r,0),data:r}))?s:"")+(null!=(s=l.if.call(o,null!=n?n.offlineEscapeMessage:n,{name:"if",hash:{},fn:e.program(11,r,0),inverse:e.noop,data:r}))?s:"")+"    </div>\n  </div>\n"+(null!=(s=l.if.call(o,null!=n?n.errorVersion:n,{name:"if",hash:{},fn:e.program(13,r,0),inverse:e.noop,data:r}))?s:"")+"</div>\n"},useData:!0});

},{"hbsfy/runtime":383}],99:[function(require,module,exports){
var HandlebarsCompiler=require("hbsfy/runtime"),partial$0=require("./cards/card.hbs");HandlebarsCompiler.registerPartial("./cards/card.hbs",partial$0),module.exports=HandlebarsCompiler.template({1:function(a,e,n,l,t){var r,o;return'  <div class="facepile" data-tooltip title="'+a.escapeExpression("function"==typeof(o=null!=(o=n.name||(null!=e?e.name:e))?o:n.helperMissing)?o.call(null!=e?e:a.nullContext||{},{name:"name",hash:{},data:t}):o)+'" data-tooltip-instant>\n'+(null!=(r=a.invokePartial(l["./cards/card.hbs"],e,{name:"./cards/card.hbs",data:t,indent:"    ",helpers:n,partials:l,decorators:a.decorators}))?r:"")+"  </div>\n"},3:function(a,e,n,l,t,r,o){var i,s=null!=e?e:a.nullContext||{},u=n.helperMissing,p=a.escapeExpression;return'  <button\n    type="button"\n    class="button facepile-badge"\n    title="'+p("function"==typeof(i=null!=(i=n.badgeTooltip||(null!=e?e.badgeTooltip:e))?i:u)?i.call(s,{name:"badgeTooltip",hash:{},data:t}):i)+'"\n    data-tooltip\n    data-tooltip-instant\n    data-modal="spotify:modal:socialproof:'+p(a.lambda(null!=o[1]?o[1].uri:o[1],e))+'"\n  >\n    +'+p("function"==typeof(i=null!=(i=n.badgeCount||(null!=e?e.badgeCount:e))?i:u)?i.call(s,{name:"badgeCount",hash:{},data:t}):i)+"\n  </button>\n"},compiler:[7,">= 4.0.0"],main:function(a,e,n,l,t,r,o){var i;return null!=(i=(n.facepile||e&&e.facepile||n.helperMissing).call(null!=e?e:a.nullContext||{},null!=e?e.users:e,{name:"facepile",hash:{},fn:a.program(1,t,0,r,o),inverse:a.program(3,t,0,r,o),data:t}))?i:""},usePartial:!0,useData:!0,useDepths:!0});

},{"./cards/card.hbs":91,"hbsfy/runtime":383}],100:[function(require,module,exports){
var HandlebarsCompiler=require("hbsfy/runtime"),partial$0=require("./facepile-common.hbs");HandlebarsCompiler.registerPartial("./facepile-common.hbs",partial$0),module.exports=HandlebarsCompiler.template({compiler:[7,">= 4.0.0"],main:function(e,a,r,i,l){var o;return'<div class="facepile-list">\n'+(null!=(o=e.invokePartial(i["./facepile-common.hbs"],a,{name:"./facepile-common.hbs",data:l,indent:"\t",helpers:r,partials:i,decorators:e.decorators}))?o:"")+"</div>\n"},usePartial:!0,useData:!0});

},{"./facepile-common.hbs":99,"hbsfy/runtime":383}],101:[function(require,module,exports){
var HandlebarsCompiler=require("hbsfy/runtime");module.exports=HandlebarsCompiler.template({1:function(e,a,l,n,s){return"focus"},3:function(e,a,l,n,s){var t,r=null!=a?a:e.nullContext||{},c=l.helperMissing,i=e.escapeExpression;return'          <li class="h-search-suggestion">\n            <span class="h-search-matches">'+i("function"==typeof(t=null!=(t=l.matches||(null!=a?a.matches:a))?t:c)?t.call(r,{name:"matches",hash:{},data:s}):t)+'</span> <span class="h-search-result">'+i("function"==typeof(t=null!=(t=l.result||(null!=a?a.result:a))?t:c)?t.call(r,{name:"result",hash:{},data:s}):t)+"</span>\n          </li>\n"},compiler:[7,">= 4.0.0"],main:function(e,a,l,n,s){var t,r,c,i=null!=a?a:e.nullContext||{},o=l.helperMissing,u=e.escapeExpression,h='<div class="h-search-field-outer-wrapper" data-interaction-context="filter">\n  <div class="h-search-field-wrapper" data-filter>\n    <div class="h-search-wrapper spoticon-search-16 ';return r=null!=(r=l.searchFocus||(null!=a?a.searchFocus:a))?r:o,c={name:"searchFocus",hash:{},fn:e.program(1,s,0),inverse:e.noop,data:s},t="function"==typeof r?r.call(i,c):r,l.searchFocus||(t=l.blockHelperMissing.call(a,t,c)),null!=t&&(h+=t),h+'">\n      <input class="h-search" type="text" placeholder="'+u((l.loc||a&&a.loc||o).call(i,"Filter",{name:"loc",hash:{},data:s}))+'" value="'+u("function"==typeof(r=null!=(r=l.filterString||(null!=a?a.filterString:a))?r:o)?r.call(i,{name:"filterString",hash:{},data:s}):r)+'" data-rtl-dir-flip />\n      <span class="h-search-close spoticon-x-16" data-interaction-target="remove-filter-button" data-interaction-intent="remove-filter"></span>\n\n      <ul class="h-search-suggestions">\n'+(null!=(t=l.each.call(i,null!=a?a.searchResult:a,{name:"each",hash:{},fn:e.program(3,s,0),inverse:e.noop,data:s}))?t:"")+"      </ul>\n    </div>\n  </div>\n</div>"},useData:!0});

},{"hbsfy/runtime":383}],102:[function(require,module,exports){
var HandlebarsCompiler=require("hbsfy/runtime"),partial$0=require("../../../buttons/add-interior.hbs");HandlebarsCompiler.registerPartial("../../../buttons/add-interior.hbs",partial$0);var partial$1=require("../../../buttons/add-interior.hbs");HandlebarsCompiler.registerPartial("../../../buttons/add-interior.hbs",partial$1),module.exports=HandlebarsCompiler.template({1:function(a,n,t,e,l){var r;return null!=(r=(t.type||n&&n.type||t.helperMissing).call(null!=n?n:a.nullContext||{},null!=n?n.uri:n,"user",{name:"type",hash:{},fn:a.program(2,l,0),inverse:a.program(5,l,0),data:l}))?r:""},2:function(a,n,t,e,l){var r,o,i=null!=n?n:a.nullContext||{};return'    <button\n      class="button button-with-stroke button-add '+(null!=(r=t.if.call(i,null!=n?n.isAdded:n,{name:"if",hash:{},fn:a.program(3,l,0),inverse:a.noop,data:l}))?r:"")+'"\n      data-button="add"\n      data-uri="'+a.escapeExpression("function"==typeof(o=null!=(o=t.uri||(null!=n?n.uri:n))?o:t.helperMissing)?o.call(i,{name:"uri",hash:{},data:l}):o)+'"\n      data-log-click="add-button"\n      data-ta-id="page-header-button-add"\n      data-interaction-target="add-remove-button"\n      data-interaction-intent="add"\n    >\n'+(null!=(r=a.invokePartial(e["../../../buttons/add-interior.hbs"],n,{name:"../../../buttons/add-interior.hbs",data:l,indent:"      ",helpers:t,partials:e,decorators:a.decorators}))?r:"")+"    </button>\n"},3:function(a,n,t,e,l){return"added"},5:function(a,n,t,e,l){var r,o,i=null!=n?n:a.nullContext||{},d=t.helperMissing,u=a.escapeExpression;return'    <button\n      class="button button-header-add button-icon-with-stroke '+(null!=(r=t.if.call(i,null!=n?n.isAdded:n,{name:"if",hash:{},fn:a.program(3,l,0),inverse:a.noop,data:l}))?r:"")+'"\n      data-button="add"\n      data-uri="'+u("function"==typeof(o=null!=(o=t.uri||(null!=n?n.uri:n))?o:d)?o.call(i,{name:"uri",hash:{},data:l}):o)+'"\n      data-log-click="add-button"\n      data-ta-id="page-header-button-add"\n      data-interaction-target="add-remove-button"\n      data-interaction-intent="add"\n      data-tooltip="'+(null!=(r=t.if.call(i,null!=n?n.isAdded:n,{name:"if",hash:{},fn:a.program(6,l,0),inverse:a.program(8,l,0),data:l}))?r:"")+'"\n      data-tooltip-add="'+u((t.loc||n&&n.loc||d).call(i,"SaveYourMusic",{name:"loc",hash:{},data:l}))+'"\n      data-tooltip-remove="'+u((t.loc||n&&n.loc||d).call(i,"RemoveYourMusic",{name:"loc",hash:{},data:l}))+'"\n      aria-label="'+(null!=(r=t.if.call(i,null!=n?n.isAdded:n,{name:"if",hash:{},fn:a.program(6,l,0),inverse:a.program(8,l,0),data:l}))?r:"")+'"\n    >\n    </button>\n'},6:function(a,n,t,e,l){return a.escapeExpression((t.loc||n&&n.loc||t.helperMissing).call(null!=n?n:a.nullContext||{},"RemoveYourMusic",{name:"loc",hash:{},data:l}))},8:function(a,n,t,e,l){return a.escapeExpression((t.loc||n&&n.loc||t.helperMissing).call(null!=n?n:a.nullContext||{},"SaveYourMusic",{name:"loc",hash:{},data:l}))},10:function(a,n,t,e,l){var r,o,i=null!=n?n:a.nullContext||{};return'  <button\n    class="button button-with-stroke button-add '+(null!=(r=t.if.call(i,null!=n?n.isAdded:n,{name:"if",hash:{},fn:a.program(3,l,0),inverse:a.noop,data:l}))?r:"")+'"\n    data-button="add"\n    data-uri="'+a.escapeExpression("function"==typeof(o=null!=(o=t.uri||(null!=n?n.uri:n))?o:t.helperMissing)?o.call(i,{name:"uri",hash:{},data:l}):o)+'"\n    data-log-click="add-button"\n    data-ta-id="page-header-button-add"\n    data-interaction-target="add-remove-button"\n    data-interaction-intent="add"\n  >\n'+(null!=(r=a.invokePartial(e["../../../buttons/add-interior.hbs"],n,{name:"../../../buttons/add-interior.hbs",data:l,indent:"    ",helpers:t,partials:e,decorators:a.decorators}))?r:"")+"  </button>\n"},compiler:[7,">= 4.0.0"],main:function(a,n,t,e,l){var r,o,i,d="";return o=null!=(o=t.nft||(null!=n?n.nft:n))?o:t.helperMissing,i={name:"nft",hash:{},fn:a.program(1,l,0),inverse:a.program(10,l,0),data:l},r="function"==typeof o?o.call(null!=n?n:a.nullContext||{},i):o,t.nft||(r=t.blockHelperMissing.call(n,r,i)),null!=r&&(d+=r),d},usePartial:!0,useData:!0});

},{"../../../buttons/add-interior.hbs":88,"hbsfy/runtime":383}],103:[function(require,module,exports){
var HandlebarsCompiler=require("hbsfy/runtime");module.exports=HandlebarsCompiler.template({compiler:[7,">= 4.0.0"],main:function(t,n,a,e,o){var l=null!=n?n:t.nullContext||{},r=a.helperMissing,i=t.escapeExpression;return'<button\n  class="button button-icon-with-stroke spoticon-more-16"\n  data-button="contextmenu"\n  data-tooltip="'+i((a.loc||n&&n.loc||r).call(l,"More",{name:"loc",hash:{},data:o}))+'"\n  data-log-click="contextmenu-button"\n  data-ta-id="page-header-button-more"\n  aria-label="'+i((a.loc||n&&n.loc||r).call(l,"More",{name:"loc",hash:{},data:o}))+'"\n  data-interaction-target="context-menu-button"\n  data-interaction-intent="show-options"\n>\n</button>\n'},useData:!0});

},{"hbsfy/runtime":383}],104:[function(require,module,exports){
var HandlebarsCompiler=require("hbsfy/runtime"),partial$0=require("../../../buttons/play-interior.hbs");HandlebarsCompiler.registerPartial("../../../buttons/play-interior.hbs",partial$0),module.exports=HandlebarsCompiler.template({1:function(t,a,n,e,l){var r;return'    data-uri="'+t.escapeExpression("function"==typeof(r=null!=(r=n.playContextUri||(null!=a?a.playContextUri:a))?r:n.helperMissing)?r.call(null!=a?a:t.nullContext||{},{name:"playContextUri",hash:{},data:l}):r)+'"\n    data-context\n'},compiler:[7,">= 4.0.0"],main:function(t,a,n,e,l){var r;return'<button\n  class="button button-green button-play"\n  data-button="play-context"\n  data-log-click="play-button"\n  data-ta-id="page-header-button-play"\n'+(null!=(r=n.if.call(null!=a?a:t.nullContext||{},null!=a?a.playContextUri:a,{name:"if",hash:{},fn:t.program(1,l,0),inverse:t.noop,data:l}))?r:"")+'  data-interaction-target="play-pause-button"\n>\n'+(null!=(r=t.invokePartial(e["../../../buttons/play-interior.hbs"],a,{name:"../../../buttons/play-interior.hbs",data:l,indent:"  ",helpers:n,partials:e,decorators:t.decorators}))?r:"")+"</button>"},usePartial:!0,useData:!0});

},{"../../../buttons/play-interior.hbs":89,"hbsfy/runtime":383}],105:[function(require,module,exports){
var HandlebarsCompiler=require("hbsfy/runtime");module.exports=HandlebarsCompiler.template({1:function(a,e,n,l,r){var d,o=null!=e?e:a.nullContext||{};return'    <div\n      class="\n        glue-page-header__background-image-loader\n'+(null!=(d=n.if.call(o,null!=e?e.isLoaded:e,{name:"if",hash:{},fn:a.program(2,r,0),inverse:a.noop,data:r}))?d:"")+'      "\n      data-glue-page-header-background-image-loader\n    >\n      <div\n        class="glue-page-header__background-image"\n'+(null!=(d=n.if.call(o,null!=(d=null!=e?e.background:e)?d.imageUrl:d,{name:"if",hash:{},fn:a.program(4,r,0),inverse:a.noop,data:r}))?d:"")+'        data-glue-page-header-background-image\n        data-glue-page-header-background-image-url="'+a.escapeExpression(a.lambda(null!=(d=null!=e?e.background:e)?d.imageUrl:d,e))+'"\n        data-ta-id="page-header-background-image"\n      >\n      </div>\n    </div>\n    <div class="glue-page-header__background-overlay">\n    </div>\n    <div class="glue-page-header__background-image-overlay-gradient">\n    </div>\n    <div\n      class="glue-page-header__background-scroll-overlay-ellipse-backdrop"\n      data-glue-page-header-background-scroll-overlay-ellipse-backdrop\n    >\n    </div>\n    <div\n      class="glue-page-header__background-scroll-overlay-ellipse"\n      data-glue-page-header-background-scroll-overlay-ellipse\n    >\n    </div>\n'},2:function(a,e,n,l,r){return"          glue-page-header__background-image-loader--is-loaded\n"},4:function(a,e,n,l,r){var d;return'          style="background-image: url('+a.escapeExpression(a.lambda(null!=(d=null!=e?e.background:e)?d.imageUrl:d,e))+')"\n'},6:function(a,e,n,l,r){var d;return'    <div\n      class="glue-page-header__background-color"\n'+(null!=(d=n.if.call(null!=e?e:a.nullContext||{},null!=(d=null!=e?e.background:e)?d.color:d,{name:"if",hash:{},fn:a.program(7,r,0),inverse:a.noop,data:r}))?d:"")+'    >\n    </div>\n    <div class="glue-page-header__background-overlay">\n    </div>\n    <div\n      class="glue-page-header__background-scroll-overlay"\n      data-glue-page-header-background-scroll-overlay\n    >\n    </div>\n'},7:function(a,e,n,l,r){var d;return'        style="background-color: '+a.escapeExpression(a.lambda(null!=(d=null!=e?e.background:e)?d.color:d,e))+'"\n'},compiler:[7,">= 4.0.0"],main:function(a,e,n,l,r){var d;return'<div\n  class="glue-page-header__background"\n  data-glue-page-header-background\n>\n'+(null!=(d=(n.compare||e&&e.compare||n.helperMissing).call(null!=e?e:a.nullContext||{},null!=(d=null!=e?e.background:e)?d.type:d,"image",{name:"compare",hash:{},fn:a.program(1,r,0),inverse:a.program(6,r,0),data:r}))?d:"")+"</div>\n"},useData:!0});

},{"hbsfy/runtime":383}],106:[function(require,module,exports){
var HandlebarsCompiler=require("hbsfy/runtime"),partial$0=require("../generic/button-play.hbs");HandlebarsCompiler.registerPartial("../generic/button-play.hbs",partial$0);var partial$1=require("../generic/button-add.hbs");HandlebarsCompiler.registerPartial("../generic/button-add.hbs",partial$1);var partial$2=require("../generic/button-more.hbs");HandlebarsCompiler.registerPartial("../generic/button-more.hbs",partial$2),module.exports=HandlebarsCompiler.template({1:function(n,a,e,r,t){var l;return'    <div class="glue-page-header__button">\n'+(null!=(l=n.invokePartial(r["../generic/button-play.hbs"],a,{name:"../generic/button-play.hbs",data:t,indent:"      ",helpers:e,partials:r,decorators:n.decorators}))?l:"")+"    </div>\n"},3:function(n,a,e,r,t){var l;return'    <div class="glue-page-header__button">\n'+(null!=(l=n.invokePartial(r["../generic/button-add.hbs"],a,{name:"../generic/button-add.hbs",data:t,indent:"      ",helpers:e,partials:r,decorators:n.decorators}))?l:"")+"    </div>\n"},5:function(n,a,e,r,t){var l;return'    <div class="glue-page-header__button">\n'+(null!=(l=n.invokePartial(r["../generic/button-more.hbs"],a,{name:"../generic/button-more.hbs",data:t,indent:"      ",helpers:e,partials:r,decorators:n.decorators}))?l:"")+"    </div>\n"},7:function(n,a,e,r,t){var l;return null!=(l=e.each.call(null!=a?a:n.nullContext||{},null!=(l=null!=a?a.buttons:a)?l.customButtons:l,{name:"each",hash:{},fn:n.program(8,t,0),inverse:n.noop,data:t}))?l:""},8:function(n,a,e,r,t){var l;return'      <div class="glue-page-header__button">\n        '+(null!=(l=n.lambda(a,a))?l:"")+"\n      </div>\n"},compiler:[7,">= 4.0.0"],main:function(n,a,e,r,t){var l,o=null!=a?a:n.nullContext||{};return'<div class="glue-page-header__buttons">\n'+(null!=(l=e.if.call(o,null!=(l=null!=a?a.buttons:a)?l.playButton:l,{name:"if",hash:{},fn:n.program(1,t,0),inverse:n.noop,data:t}))?l:"")+"\n"+(null!=(l=e.if.call(o,null!=(l=null!=a?a.buttons:a)?l.addButton:l,{name:"if",hash:{},fn:n.program(3,t,0),inverse:n.noop,data:t}))?l:"")+"\n"+(null!=(l=e.if.call(o,null!=(l=null!=a?a.buttons:a)?l.moreButton:l,{name:"if",hash:{},fn:n.program(5,t,0),inverse:n.noop,data:t}))?l:"")+"\n"+(null!=(l=e.if.call(o,null!=(l=null!=a?a.buttons:a)?l.customButtons:l,{name:"if",hash:{},fn:n.program(7,t,0),inverse:n.noop,data:t}))?l:"")+"</div>"},usePartial:!0,useData:!0});

},{"../generic/button-add.hbs":102,"../generic/button-more.hbs":103,"../generic/button-play.hbs":104,"hbsfy/runtime":383}],107:[function(require,module,exports){
var HandlebarsCompiler=require("hbsfy/runtime"),partial$0=require("../../../facepile.hbs");HandlebarsCompiler.registerPartial("../../../facepile.hbs",partial$0),module.exports=HandlebarsCompiler.template({1:function(l,e,a,n,r){var u,i=null!=e?e:l.nullContext||{},t=l.escapeExpression;return'  <div class="glue-page-header__count-label">\n'+(null!=(u=a.if.call(i,null!=(u=null!=e?e.countLabel:e)?u.link:u,{name:"if",hash:{},fn:l.program(2,r,0),inverse:l.noop,data:r}))?u:"")+'      <div class="glue-page-header__count-label-text">\n        '+t(l.lambda(null!=(u=null!=e?e.countLabel:e)?u.label:u,e))+'\n      </div>\n      <div class="glue-page-header__count-label-number">\n        '+t((a.numeral||e&&e.numeral||a.helperMissing).call(i,null!=(u=null!=e?e.countLabel:e)?u.number:u,{name:"numeral",hash:{},data:r}))+"\n      </div>\n"+(null!=(u=a.if.call(i,null!=(u=null!=e?e.countLabel:e)?u.link:u,{name:"if",hash:{},fn:l.program(4,r,0),inverse:l.noop,data:r}))?u:"")+"\n"+(null!=(u=a.if.call(i,null!=(u=null!=e?e.countLabel:e)?u.facePile:u,{name:"if",hash:{},fn:l.program(6,r,0),inverse:l.noop,data:r}))?u:"")+"  </div>\n"},2:function(l,e,a,n,r){var u;return'    <a\n      href="'+l.escapeExpression(l.lambda(null!=(u=null!=e?e.countLabel:e)?u.link:u,e))+'"\n      class="glue-page-header__count-label-link"\n      data-glue-page-header-count-label-link\n      data-interaction-target="monthly-listeners-count"\n    >\n'},4:function(l,e,a,n,r){return"    </a>\n"},6:function(l,e,a,n,r){var u;return'      <div class="glue-page-header__count-label-facepile">\n'+(null!=(u=l.invokePartial(n["../../../facepile.hbs"],null!=(u=null!=e?e.countLabel:e)?u.facePile:u,{name:"../../../facepile.hbs",data:r,indent:"        ",helpers:a,partials:n,decorators:l.decorators}))?u:"")+"      </div>\n"},compiler:[7,">= 4.0.0"],main:function(l,e,a,n,r){var u;return null!=(u=a.if.call(null!=e?e:l.nullContext||{},null!=e?e.countLabel:e,{name:"if",hash:{},fn:l.program(1,r,0),inverse:l.noop,data:r}))?u:""},usePartial:!0,useData:!0});

},{"../../../facepile.hbs":100,"hbsfy/runtime":383}],108:[function(require,module,exports){
var HandlebarsCompiler=require("hbsfy/runtime");module.exports=HandlebarsCompiler.template({1:function(n,e,a,i,l){var r,t;return'  <div\n    class="glue-page-header__description"\n    data-ta-id="page-header-description"\n    data-glue-page-header-description\n  >\n    <span dir="auto">\n      '+(null!=(r="function"==typeof(t=null!=(t=a.descriptionHTML||(null!=e?e.descriptionHTML:e))?t:a.helperMissing)?t.call(null!=e?e:n.nullContext||{},{name:"descriptionHTML",hash:{},data:l}):t)?r:"")+"\n    </span>\n  </div>\n"},3:function(n,e,a,i,l){var r;return null!=(r=a.if.call(null!=e?e:n.nullContext||{},null!=e?e.description:e,{name:"if",hash:{},fn:n.program(4,l,0),inverse:n.noop,data:l}))?r:""},4:function(n,e,a,i,l){var r;return'    <div\n      class="glue-page-header__description"\n      data-ta-id="page-header-description"\n      data-glue-page-header-description\n    >\n      <span dir="auto">\n        '+n.escapeExpression("function"==typeof(r=null!=(r=a.description||(null!=e?e.description:e))?r:a.helperMissing)?r.call(null!=e?e:n.nullContext||{},{name:"description",hash:{},data:l}):r)+"\n      </span>\n    </div>\n"},compiler:[7,">= 4.0.0"],main:function(n,e,a,i,l){var r;return null!=(r=a.if.call(null!=e?e:n.nullContext||{},null!=e?e.descriptionHTML:e,{name:"if",hash:{},fn:n.program(1,l,0),inverse:n.program(3,l,0),data:l}))?r:""},useData:!0});

},{"hbsfy/runtime":383}],109:[function(require,module,exports){
var HandlebarsCompiler=require("hbsfy/runtime"),partial$0=require("../../../cards/card-without-link.hbs");HandlebarsCompiler.registerPartial("../../../cards/card-without-link.hbs",partial$0),module.exports=HandlebarsCompiler.template({1:function(a,e,n,l,r){var i,t;return'  <div class="glue-page-header__image">\n    <div class="glue-page-header__image-inner">\n      '+(null!=(i="function"==typeof(t=null!=(t=n.imageHTML||(null!=e?e.imageHTML:e))?t:n.helperMissing)?t.call(null!=e?e:a.nullContext||{},{name:"imageHTML",hash:{},data:r}):t)?i:"")+"\n    </div>\n  </div>\n"},3:function(a,e,n,l,r){var i;return null!=(i=n.if.call(null!=e?e:a.nullContext||{},null!=e?e.image:e,{name:"if",hash:{},fn:a.program(4,r,0),inverse:a.noop,data:r}))?i:""},4:function(a,e,n,l,r){var i;return'    <div class="glue-page-header__image">\n      <div class="glue-page-header__image-inner">\n'+(null!=(i=a.invokePartial(l["../../../cards/card-without-link.hbs"],null!=e?e.image:e,{name:"../../../cards/card-without-link.hbs",data:r,indent:"        ",helpers:n,partials:l,decorators:a.decorators}))?i:"")+"      </div>\n    </div>\n"},compiler:[7,">= 4.0.0"],main:function(a,e,n,l,r){var i;return null!=(i=n.if.call(null!=e?e:a.nullContext||{},null!=e?e.imageHTML:e,{name:"if",hash:{},fn:a.program(1,r,0),inverse:a.program(3,r,0),data:r}))?i:""},usePartial:!0,useData:!0});

},{"../../../cards/card-without-link.hbs":90,"hbsfy/runtime":383}],110:[function(require,module,exports){
var HandlebarsCompiler=require("hbsfy/runtime");module.exports=HandlebarsCompiler.template({1:function(l,a,e,n,r){var t,u;return'  <div class="glue-page-header__label" data-ta-id="page-header-label">\n    <span dir="auto">'+(null!=(t="function"==typeof(u=null!=(u=e.labelHTML||(null!=a?a.labelHTML:a))?u:e.helperMissing)?u.call(null!=a?a:l.nullContext||{},{name:"labelHTML",hash:{},data:r}):u)?t:"")+"</span>\n  </div>\n"},3:function(l,a,e,n,r){var t;return null!=(t=e.if.call(null!=a?a:l.nullContext||{},null!=a?a.label:a,{name:"if",hash:{},fn:l.program(4,r,0),inverse:l.noop,data:r}))?t:""},4:function(l,a,e,n,r){var t;return'    <div class="glue-page-header__label" data-ta-id="page-header-label"><span dir="auto">'+l.escapeExpression("function"==typeof(t=null!=(t=e.label||(null!=a?a.label:a))?t:e.helperMissing)?t.call(null!=a?a:l.nullContext||{},{name:"label",hash:{},data:r}):t)+"</span></div>\n"},compiler:[7,">= 4.0.0"],main:function(l,a,e,n,r){var t;return null!=(t=e.if.call(null!=a?a:l.nullContext||{},null!=a?a.labelHTML:a,{name:"if",hash:{},fn:l.program(1,r,0),inverse:l.program(3,r,0),data:r}))?t:""},useData:!0});

},{"hbsfy/runtime":383}],111:[function(require,module,exports){
var HandlebarsCompiler=require("hbsfy/runtime");module.exports=HandlebarsCompiler.template({1:function(n,e,a,l,t){var r,o;return'  <div\n    class="glue-page-header__meta-info"\n    data-ta-id="page-header-meta-info"\n  >\n    '+(null!=(r="function"==typeof(o=null!=(o=a.metaInfoHTML||(null!=e?e.metaInfoHTML:e))?o:a.helperMissing)?o.call(null!=e?e:n.nullContext||{},{name:"metaInfoHTML",hash:{},data:t}):o)?r:"")+"\n  </div>\n"},compiler:[7,">= 4.0.0"],main:function(n,e,a,l,t){var r;return null!=(r=a.if.call(null!=e?e:n.nullContext||{},null!=e?e.metaInfoHTML:e,{name:"if",hash:{},fn:n.program(1,t,0),inverse:n.noop,data:t}))?r:""},useData:!0});

},{"hbsfy/runtime":383}],112:[function(require,module,exports){
var HandlebarsCompiler=require("hbsfy/runtime"),partial$0=require("../../../navbar.hbs");HandlebarsCompiler.registerPartial("../../../navbar.hbs",partial$0),module.exports=HandlebarsCompiler.template({1:function(a,r,e,n,l){var i;return'  <div class="glue-page-header__navbar-wrapper">\n'+(null!=(i=a.invokePartial(n["../../../navbar.hbs"],null!=r?r.navBar:r,{name:"../../../navbar.hbs",data:l,indent:"    ",helpers:e,partials:n,decorators:a.decorators}))?i:"")+"  </div>\n"},compiler:[7,">= 4.0.0"],main:function(a,r,e,n,l){var i;return null!=(i=e.if.call(null!=r?r:a.nullContext||{},null!=r?r.navBar:r,{name:"if",hash:{},fn:a.program(1,l,0),inverse:a.noop,data:l}))?i:""},usePartial:!0,useData:!0});

},{"../../../navbar.hbs":116,"hbsfy/runtime":383}],113:[function(require,module,exports){
var HandlebarsCompiler=require("hbsfy/runtime");module.exports=HandlebarsCompiler.template({1:function(n,e,l,a,t){return"data-contextmenu"},3:function(n,e,l,a,t){return'draggable="true"'},5:function(n,e,l,a,t){return"    data-glue-page-header-use-large-title\n"},7:function(n,e,l,a,t){var r;return'    style="color: '+n.escapeExpression("function"==typeof(r=null!=(r=l.titleColor||(null!=e?e.titleColor:e))?r:l.helperMissing)?r.call(null!=e?e:n.nullContext||{},{name:"titleColor",hash:{},data:t}):r)+'"\n'},9:function(n,e,l,a,t){var r,i;return"      "+(null!=(r="function"==typeof(i=null!=(i=l.titleHTML||(null!=e?e.titleHTML:e))?i:l.helperMissing)?i.call(null!=e?e:n.nullContext||{},{name:"titleHTML",hash:{},data:t}):i)?r:"")+"\n"},11:function(n,e,l,a,t){var r;return"      "+n.escapeExpression("function"==typeof(r=null!=(r=l.title||(null!=e?e.title:e))?r:l.helperMissing)?r.call(null!=e?e:n.nullContext||{},{name:"title",hash:{},data:t}):r)+"\n"},compiler:[7,">= 4.0.0"],main:function(n,e,l,a,t){var r,i,u=null!=e?e:n.nullContext||{};return'<h1\n  class="glue-page-header__title"\n  data-uri="'+n.escapeExpression("function"==typeof(i=null!=(i=l.uri||(null!=e?e.uri:e))?i:l.helperMissing)?i.call(u,{name:"uri",hash:{},data:t}):i)+'"\n  data-ta-id="page-header-title"\n  '+(null!=(r=l.if.call(u,null!=e?e.enableContextMenu:e,{name:"if",hash:{},fn:n.program(1,t,0),inverse:n.noop,data:t}))?r:"")+"\n  "+(null!=(r=l.if.call(u,null!=e?e.enableDragging:e,{name:"if",hash:{},fn:n.program(3,t,0),inverse:n.noop,data:t}))?r:"")+"\n  data-glue-page-header-title\n"+(null!=(r=l.if.call(u,null!=e?e.useLargeTitle:e,{name:"if",hash:{},fn:n.program(5,t,0),inverse:n.noop,data:t}))?r:"")+(null!=(r=l.if.call(u,null!=e?e.titleColor:e,{name:"if",hash:{},fn:n.program(7,t,0),inverse:n.noop,data:t}))?r:"")+'>\n  <span dir="auto" class="glue-page-header__title-text">\n'+(null!=(r=l.if.call(u,null!=e?e.titleHTML:e,{name:"if",hash:{},fn:n.program(9,t,0),inverse:n.program(11,t,0),data:t}))?r:"")+"  </span>\n</h1>"},useData:!0});

},{"hbsfy/runtime":383}],114:[function(require,module,exports){
var HandlebarsCompiler=require("hbsfy/runtime"),partial$0=require("./internal/page-header/background.hbs");HandlebarsCompiler.registerPartial("./internal/page-header/background.hbs",partial$0);var partial$1=require("./internal/page-header/image.hbs");HandlebarsCompiler.registerPartial("./internal/page-header/image.hbs",partial$1);var partial$2=require("./internal/page-header/label.hbs");HandlebarsCompiler.registerPartial("./internal/page-header/label.hbs",partial$2);var partial$3=require("./internal/page-header/title.hbs");HandlebarsCompiler.registerPartial("./internal/page-header/title.hbs",partial$3);var partial$4=require("./internal/page-header/description.hbs");HandlebarsCompiler.registerPartial("./internal/page-header/description.hbs",partial$4);var partial$5=require("./internal/page-header/meta-info.hbs");HandlebarsCompiler.registerPartial("./internal/page-header/meta-info.hbs",partial$5);var partial$6=require("./internal/page-header/buttons.hbs");HandlebarsCompiler.registerPartial("./internal/page-header/buttons.hbs",partial$6);var partial$7=require("./internal/page-header/count-label.hbs");HandlebarsCompiler.registerPartial("./internal/page-header/count-label.hbs",partial$7);var partial$8=require("./internal/page-header/buttons.hbs");HandlebarsCompiler.registerPartial("./internal/page-header/buttons.hbs",partial$8);var partial$9=require("./internal/page-header/image.hbs");HandlebarsCompiler.registerPartial("./internal/page-header/image.hbs",partial$9);var partial$10=require("./internal/page-header/title.hbs");HandlebarsCompiler.registerPartial("./internal/page-header/title.hbs",partial$10);var partial$11=require("./internal/page-header/buttons.hbs");HandlebarsCompiler.registerPartial("./internal/page-header/buttons.hbs",partial$11);var partial$12=require("./internal/page-header/navbar.hbs");HandlebarsCompiler.registerPartial("./internal/page-header/navbar.hbs",partial$12),module.exports=HandlebarsCompiler.template({1:function(e,a,n,r,l){return"      glue-page-header--with-navbar\n"},3:function(e,a,n,r,l){return"      glue-page-header--with-count-label\n"},5:function(e,a,n,r,l){return"      glue-page-header--with-responsive-height-small\n"},7:function(e,a,n,r,l){return"      glue-page-header--with-responsive-height-large\n"},9:function(e,a,n,r,l){return"      glue-page-header--"+e.escapeExpression((n.type||a&&a.type||n.helperMissing).call(null!=a?a:e.nullContext||{},null!=a?a.uri:a,{name:"type",hash:{},data:l}))+"\n"},11:function(e,a,n,r,l){var t;return'    data-uri="'+e.escapeExpression("function"==typeof(t=null!=(t=n.uri||(null!=a?a.uri:a))?t:n.helperMissing)?t.call(null!=a?a:e.nullContext||{},{name:"uri",hash:{},data:l}):t)+'"\n'},13:function(e,a,n,r,l){return"    data-context\n"},15:function(e,a,n,r,l){return'    data-glue-page-header-sticky-height="160"\n'},17:function(e,a,n,r,l){return'    data-glue-page-header-sticky-height="116"\n'},19:function(e,a,n,r,l){var t;return'    <div class="row">\n      <div class="'+e.escapeExpression("function"==typeof(t=null!=(t=n.gridClasses||(null!=a?a.gridClasses:a))?t:n.helperMissing)?t.call(null!=a?a:e.nullContext||{},{name:"gridClasses",hash:{},data:l}):t)+'">\n'},21:function(e,a,n,r,l){return"          glue-page-header__content--with-custom-image-size\n"},23:function(e,a,n,r,l){return"          glue-page-header__content--with-button-placement-left\n"},25:function(e,a,n,r,l){return"            glue-page-header__spacer--large\n"},27:function(e,a,n,r,l){return"      </div>\n    </div>\n"},29:function(e,a,n,r,l){var t;return'        <div class="row">\n          <div class="'+e.escapeExpression("function"==typeof(t=null!=(t=n.gridClasses||(null!=a?a.gridClasses:a))?t:n.helperMissing)?t.call(null!=a?a:e.nullContext||{},{name:"gridClasses",hash:{},data:l}):t)+'">\n'},31:function(e,a,n,r,l){var t;return null!=(t=e.invokePartial(r["./internal/page-header/image.hbs"],a,{name:"./internal/page-header/image.hbs",data:l,indent:"            ",helpers:n,partials:r,decorators:e.decorators}))?t:""},33:function(e,a,n,r,l){return"          </div>\n        </div>\n"},compiler:[7,">= 4.0.0"],main:function(e,a,n,r,l){var t,i,s=null!=a?a:e.nullContext||{};return'<header\n  class="\n    glue-page-header\n'+(null!=(t=n.if.call(s,null!=a?a.navBar:a,{name:"if",hash:{},fn:e.program(1,l,0),inverse:e.noop,data:l}))?t:"")+(null!=(t=n.if.call(s,null!=a?a.countLabel:a,{name:"if",hash:{},fn:e.program(3,l,0),inverse:e.noop,data:l}))?t:"")+(null!=(t=n.if.call(s,null!=a?a.useResponsiveHeightSmall:a,{name:"if",hash:{},fn:e.program(5,l,0),inverse:e.noop,data:l}))?t:"")+(null!=(t=n.if.call(s,null!=a?a.useResponsiveHeightLarge:a,{name:"if",hash:{},fn:e.program(7,l,0),inverse:e.noop,data:l}))?t:"")+(null!=(t=n.if.call(s,null!=a?a.uri:a,{name:"if",hash:{},fn:e.program(9,l,0),inverse:e.noop,data:l}))?t:"")+"\n    "+e.escapeExpression("function"==typeof(i=null!=(i=n.modifiers||(null!=a?a.modifiers:a))?i:n.helperMissing)?i.call(s,{name:"modifiers",hash:{},data:l}):i)+'\n  "\n  data-glue-page-header\n  data-ta-id="page-header"\n\n'+(null!=(t=n.if.call(s,null!=a?a.uri:a,{name:"if",hash:{},fn:e.program(11,l,0),inverse:e.noop,data:l}))?t:"")+"\n"+(null!=(t=n.if.call(s,null!=(t=null!=a?a.buttons:a)?t.playButton:t,{name:"if",hash:{},fn:e.program(13,l,0),inverse:e.noop,data:l}))?t:"")+"\n"+(null!=(t=n.if.call(s,null!=a?a.navBar:a,{name:"if",hash:{},fn:e.program(15,l,0),inverse:e.program(17,l,0),data:l}))?t:"")+">\n"+(null!=(t=e.invokePartial(r["./internal/page-header/background.hbs"],a,{name:"./internal/page-header/background.hbs",data:l,indent:"  ",helpers:n,partials:r,decorators:e.decorators}))?t:"")+'\n  <div\n    class="\n      glue-page-header__content-wrapper\n      container\n    "\n    data-glue-page-header-content\n  >\n'+(null!=(t=n.if.call(s,null!=a?a.gridClasses:a,{name:"if",hash:{},fn:e.program(19,l,0),inverse:e.noop,data:l}))?t:"")+'\n    <div\n      class="\n        glue-page-header__content\n'+(null!=(t=n.if.call(s,null!=a?a.useCustomImageSize:a,{name:"if",hash:{},fn:e.program(21,l,0),inverse:e.noop,data:l}))?t:"")+(null!=(t=n.if.call(s,null!=(t=null!=a?a.buttons:a)?t.buttonPlacementLeft:t,{name:"if",hash:{},fn:e.program(23,l,0),inverse:e.noop,data:l}))?t:"")+'      "\n    >\n      <div class="glue-page-header__content-inner" data-ta-id="page-header-inner-content">\n'+(null!=(t=e.invokePartial(r["./internal/page-header/image.hbs"],a,{name:"./internal/page-header/image.hbs",data:l,indent:"        ",helpers:n,partials:r,decorators:e.decorators}))?t:"")+'\n        <div class="glue-page-header__data">\n'+(null!=(t=e.invokePartial(r["./internal/page-header/label.hbs"],a,{name:"./internal/page-header/label.hbs",data:l,indent:"          ",helpers:n,partials:r,decorators:e.decorators}))?t:"")+(null!=(t=e.invokePartial(r["./internal/page-header/title.hbs"],a,{name:"./internal/page-header/title.hbs",data:l,indent:"          ",helpers:n,partials:r,decorators:e.decorators}))?t:"")+(null!=(t=e.invokePartial(r["./internal/page-header/description.hbs"],a,{name:"./internal/page-header/description.hbs",data:l,indent:"          ",helpers:n,partials:r,decorators:e.decorators}))?t:"")+(null!=(t=e.invokePartial(r["./internal/page-header/meta-info.hbs"],a,{name:"./internal/page-header/meta-info.hbs",data:l,indent:"          ",helpers:n,partials:r,decorators:e.decorators}))?t:"")+(null!=(t=e.invokePartial(r["./internal/page-header/buttons.hbs"],a,{name:"./internal/page-header/buttons.hbs",data:l,indent:"          ",helpers:n,partials:r,decorators:e.decorators}))?t:"")+(null!=(t=e.invokePartial(r["./internal/page-header/count-label.hbs"],a,{name:"./internal/page-header/count-label.hbs",data:l,indent:"          ",helpers:n,partials:r,decorators:e.decorators}))?t:"")+'        </div>\n\n        <div class="\n          glue-page-header__spacer\n'+(null!=(t=n.if.call(s,null!=a?a.useLargeSpacer:a,{name:"if",hash:{},fn:e.program(25,l,0),inverse:e.noop,data:l}))?t:"")+'        ">\n        </div>\n      </div>\n\n'+(null!=(t=e.invokePartial(r["./internal/page-header/buttons.hbs"],a,{name:"./internal/page-header/buttons.hbs",data:l,indent:"      ",helpers:n,partials:r,decorators:e.decorators}))?t:"")+"    </div>\n\n"+(null!=(t=n.if.call(s,null!=a?a.gridClasses:a,{name:"if",hash:{},fn:e.program(27,l,0),inverse:e.noop,data:l}))?t:"")+'  </div>\n\n  <div\n    class="glue-page-header__sticky-wrapper"\n    data-sticky-fixed-wrapper\n    aria-hidden="true"\n  >\n    <div class="glue-page-header__sticky" data-sticky>\n      <div class="container">\n'+(null!=(t=n.if.call(s,null!=a?a.gridClasses:a,{name:"if",hash:{},fn:e.program(29,l,0),inverse:e.noop,data:l}))?t:"")+'\n        <div class="glue-page-header__sticky-inner">\n'+(null!=(t=n.unless.call(s,null!=a?a.hideImageInStickyHeader:a,{name:"unless",hash:{},fn:e.program(31,l,0),inverse:e.noop,data:l}))?t:"")+(null!=(t=e.invokePartial(r["./internal/page-header/title.hbs"],a,{name:"./internal/page-header/title.hbs",data:l,indent:"          ",helpers:n,partials:r,decorators:e.decorators}))?t:"")+(null!=(t=e.invokePartial(r["./internal/page-header/buttons.hbs"],a,{name:"./internal/page-header/buttons.hbs",data:l,indent:"          ",helpers:n,partials:r,decorators:e.decorators}))?t:"")+"        </div>\n\n"+(null!=(t=n.if.call(s,null!=a?a.gridClasses:a,{name:"if",hash:{},fn:e.program(33,l,0),inverse:e.noop,data:l}))?t:"")+"      </div>\n    </div>\n  </div>\n\n"+(null!=(t=e.invokePartial(r["./internal/page-header/navbar.hbs"],a,{name:"./internal/page-header/navbar.hbs",data:l,indent:"  ",helpers:n,partials:r,decorators:e.decorators}))?t:"")+"</header>\n"},usePartial:!0,useData:!0});

},{"./internal/page-header/background.hbs":105,"./internal/page-header/buttons.hbs":106,"./internal/page-header/count-label.hbs":107,"./internal/page-header/description.hbs":108,"./internal/page-header/image.hbs":109,"./internal/page-header/label.hbs":110,"./internal/page-header/meta-info.hbs":111,"./internal/page-header/navbar.hbs":112,"./internal/page-header/title.hbs":113,"hbsfy/runtime":383}],115:[function(require,module,exports){
var HandlebarsCompiler=require("hbsfy/runtime");module.exports=HandlebarsCompiler.template({1:function(a,n,l,e,t){var r;return' data-navbar-item-matcher="'+a.escapeExpression("function"==typeof(r=null!=(r=l.matcher||(null!=n?n.matcher:n))?r:l.helperMissing)?r.call(null!=n?n:a.nullContext||{},{name:"matcher",hash:{},data:t}):r)+'"'},3:function(a,n,l,e,t){var r,i=null!=n?n:a.nullContext||{},u=l.helperMissing,s=a.escapeExpression;return'  <a href="'+s("function"==typeof(r=null!=(r=l.url||(null!=n?n.url:n))?r:u)?r.call(i,{name:"url",hash:{},data:t}):r)+'" data-log-click="'+s("function"==typeof(r=null!=(r=l.id||(null!=n?n.id:n))?r:u)?r.call(i,{name:"id",hash:{},data:t}):r)+'" draggable="false" data-interaction-target="link">'+s("function"==typeof(r=null!=(r=l.name||(null!=n?n.name:n))?r:u)?r.call(i,{name:"name",hash:{},data:t}):r)+"</a>\n  "},5:function(a,n,l,e,t){var r;return" "+(null!=(r=l.if.call(null!=n?n:a.nullContext||{},null!=n?n.id:n,{name:"if",hash:{},fn:a.program(6,t,0),inverse:a.program(8,t,0),data:t}))?r:"")+" "},6:function(a,n,l,e,t){var r,i=null!=n?n:a.nullContext||{},u=l.helperMissing,s=a.escapeExpression;return'\n  <a data-log-click="'+s("function"==typeof(r=null!=(r=l.id||(null!=n?n.id:n))?r:u)?r.call(i,{name:"id",hash:{},data:t}):r)+'" draggable="false" data-interaction-target="link">'+s("function"==typeof(r=null!=(r=l.name||(null!=n?n.name:n))?r:u)?r.call(i,{name:"name",hash:{},data:t}):r)+"</a>\n"},8:function(a,n,l,e,t){var r;return'  <p class="navbar-text">'+a.escapeExpression("function"==typeof(r=null!=(r=l.name||(null!=n?n.name:n))?r:l.helperMissing)?r.call(null!=n?n:a.nullContext||{},{name:"name",hash:{},data:t}):r)+"</p>\n  "},compiler:[7,">= 4.0.0"],main:function(a,n,l,e,t){var r,i,u=null!=n?n:a.nullContext||{},s=l.helperMissing,o=a.escapeExpression;return'<li class="'+o("function"==typeof(i=null!=(i=l.className||(null!=n?n.className:n))?i:s)?i.call(u,{name:"className",hash:{},data:t}):i)+'" data-navbar-item-id="'+o("function"==typeof(i=null!=(i=l.id||(null!=n?n.id:n))?i:s)?i.call(u,{name:"id",hash:{},data:t}):i)+'"'+(null!=(r=l.if.call(u,null!=n?n.matcher:n,{name:"if",hash:{},fn:a.program(1,t,0),inverse:a.noop,data:t}))?r:"")+">\n"+(null!=(r=l.if.call(u,null!=n?n.url:n,{name:"if",hash:{},fn:a.program(3,t,0),inverse:a.program(5,t,0),data:t}))?r:"")+"\n</li>\n"},useData:!0});

},{"hbsfy/runtime":383}],116:[function(require,module,exports){
var HandlebarsCompiler=require("hbsfy/runtime"),partial$0=require("./navbar-item.hbs");HandlebarsCompiler.registerPartial("./navbar-item.hbs",partial$0);var partial$1=require("./facepile.hbs");HandlebarsCompiler.registerPartial("./facepile.hbs",partial$1),module.exports=HandlebarsCompiler.template({1:function(a,n,e,l,r){return"no-overflow-menu"},3:function(a,n,e,l,r){var i;return null!=(i=a.invokePartial(l["./navbar-item.hbs"],n,{name:"./navbar-item.hbs",data:r,indent:"          ",helpers:e,partials:l,decorators:a.decorators}))?i:""},5:function(a,n,e,l,r){return'          <li class="overflow-menu-button" data-navbar-item-id="navbar-overflow-menu">\n            <a data-interaction-target="menu-overflow-button" data-interaction-intent="show-overflowed-menu">'+a.escapeExpression((e.loc||n&&n.loc||e.helperMissing).call(null!=n?n:a.nullContext||{},"More",{name:"loc",hash:{},data:r}))+"</a>\n          </li>\n"},7:function(a,n,e,l,r){var i;return null!=(i=e.if.call(null!=n?n:a.nullContext||{},null!=(i=null!=n?n.facePile:n)?i.users:i,{name:"if",hash:{},fn:a.program(8,r,0),inverse:a.noop,data:r}))?i:""},8:function(a,n,e,l,r){var i;return'            <div class="navbar-right facepile-list-container">\n'+(null!=(i=a.invokePartial(l["./facepile.hbs"],null!=n?n.facePile:n,{name:"./facepile.hbs",data:r,indent:"              ",helpers:e,partials:l,decorators:a.decorators}))?i:"")+"            </div>\n"},compiler:[7,">= 4.0.0"],main:function(a,n,e,l,r){var i,t,o,s=null!=n?n:a.nullContext||{},u=e.helperMissing,c=a.escapeExpression,v='<div class="navbar-fixed-wrapper" data-sticky-fixed-wrapper>\n  <div class="navbar" data-sticky="true">\n    <div class="container">\n      <ul class="nav navbar-nav '+(null!=(i=e.if.call(s,null!=n?n.noOverflowMenu:n,{name:"if",hash:{},fn:a.program(1,r,0),inverse:a.noop,data:r}))?i:"")+'"\n        data-navbar="navbar"\n        data-navbar-history-position="'+c("function"==typeof(t=null!=(t=e.historyPosition||(null!=n?n.historyPosition:n))?t:u)?t.call(s,{name:"historyPosition",hash:{},data:r}):t)+'"\n        data-navbar-active-id="'+c("function"==typeof(t=null!=(t=e.activeTab||(null!=n?n.activeTab:n))?t:u)?t.call(s,{name:"activeTab",hash:{},data:r}):t)+'"\n        data-log-context="navbar"\n        data-interaction-context="navbar"\n        data-interaction-list\n        >\n';return t=null!=(t=e["nav-items"]||(null!=n?n["nav-items"]:n))?t:u,o={name:"nav-items",hash:{},fn:a.program(3,r,0),inverse:a.noop,data:r},i="function"==typeof t?t.call(s,o):t,e["nav-items"]||(i=e.blockHelperMissing.call(n,i,o)),null!=i&&(v+=i),v+(null!=(i=e.unless.call(s,null!=n?n.noOverflowMenu:n,{name:"unless",hash:{},fn:a.program(5,r,0),inverse:a.noop,data:r}))?i:"")+(null!=(i=e.if.call(s,null!=n?n.facePile:n,{name:"if",hash:{},fn:a.program(7,r,0),inverse:a.noop,data:r}))?i:"")+"      </ul>\n    </div>\n  </div>\n</div>\n"},usePartial:!0,useData:!0});

},{"./facepile.hbs":100,"./navbar-item.hbs":115,"hbsfy/runtime":383}],117:[function(require,module,exports){
var HandlebarsCompiler=require("hbsfy/runtime");module.exports=HandlebarsCompiler.template({1:function(n,l,a,e,r){return"true"},3:function(n,l,a,e,r){return"false"},5:function(n,l,a,e,r){return" enabled"},7:function(n,l,a,e,r){return" disabled"},9:function(n,l,a,e,r){return"enabled"},11:function(n,l,a,e,r){return"disabled"},13:function(n,l,a,e,r){return'aria-disabled="true"'},15:function(n,l,a,e,r){var i;return'data-slider="'+n.escapeExpression("function"==typeof(i=null!=(i=a.id||(null!=l?l.id:l))?i:a.helperMissing)?i.call(null!=l?l:n.nullContext||{},{name:"id",hash:{},data:r}):i)+'"'},17:function(n,l,a,e,r){return"data-slider"},19:function(n,l,a,e,r){var i;return'data-ta-id="'+n.escapeExpression("function"==typeof(i=null!=(i=a.id||(null!=l?l.id:l))?i:a.helperMissing)?i.call(null!=l?l:n.nullContext||{},{name:"id",hash:{},data:r}):i)+'"'},21:function(n,l,a,e,r){var i;return'aria-labelledby="'+n.escapeExpression("function"==typeof(i=null!=(i=a.labelId||(null!=l?l.labelId:l))?i:a.helperMissing)?i.call(null!=l?l:n.nullContext||{},{name:"labelId",hash:{},data:r}):i)+'"'},23:function(n,l,a,e,r){var i;return'data-uri="'+n.escapeExpression("function"==typeof(i=null!=(i=a.uri||(null!=l?l.uri:l))?i:a.helperMissing)?i.call(null!=l?l:n.nullContext||{},{name:"uri",hash:{},data:r}):i)+'"'},25:function(n,l,a,e,r){var i;return'data-slider-property="'+n.escapeExpression("function"==typeof(i=null!=(i=a.property||(null!=l?l.property:l))?i:a.helperMissing)?i.call(null!=l?l:n.nullContext||{},{name:"property",hash:{},data:r}):i)+'"'},27:function(n,l,a,e,r){var i;return'data-slider-allowed-property="'+n.escapeExpression("function"==typeof(i=null!=(i=a.allowedProperty||(null!=l?l.allowedProperty:l))?i:a.helperMissing)?i.call(null!=l?l:n.nullContext||{},{name:"allowedProperty",hash:{},data:r}):i)+'"'},compiler:[7,">= 4.0.0"],main:function(n,l,a,e,r){var i,t=null!=l?l:n.nullContext||{},o=a.helperMissing;return'<div\n  tabindex="0"\n  role="checkbox"\n  aria-checked="'+(null!=(i=a.if.call(t,null!=l?l.enabled:l,{name:"if",hash:{},fn:n.program(1,r,0),inverse:n.program(3,r,0),data:r}))?i:"")+'"\n  class="slider'+(null!=(i=a.if.call(t,null!=l?l.enabled:l,{name:"if",hash:{},fn:n.program(5,r,0),inverse:n.noop,data:r}))?i:"")+(null!=(i=(a.compare||l&&l.compare||o).call(t,null!=l?l.allowed:l,!1,{name:"compare",hash:{},fn:n.program(7,r,0),inverse:n.noop,data:r}))?i:"")+'"\n  data-ta-slider-state="'+(null!=(i=a.if.call(t,null!=l?l.enabled:l,{name:"if",hash:{},fn:n.program(9,r,0),inverse:n.program(11,r,0),data:r}))?i:"")+'"\n  '+(null!=(i=(a.compare||l&&l.compare||o).call(t,null!=l?l.allowed:l,!1,{name:"compare",hash:{},fn:n.program(13,r,0),inverse:n.noop,data:r}))?i:"")+"\n  "+(null!=(i=a.if.call(t,null!=l?l.id:l,{name:"if",hash:{},fn:n.program(15,r,0),inverse:n.program(17,r,0),data:r}))?i:"")+"\n  "+(null!=(i=a.if.call(t,null!=l?l.id:l,{name:"if",hash:{},fn:n.program(19,r,0),inverse:n.noop,data:r}))?i:"")+"\n  "+(null!=(i=a.if.call(t,null!=l?l.labelId:l,{name:"if",hash:{},fn:n.program(21,r,0),inverse:n.noop,data:r}))?i:"")+"\n  "+(null!=(i=a.if.call(t,null!=l?l.uri:l,{name:"if",hash:{},fn:n.program(23,r,0),inverse:n.noop,data:r}))?i:"")+"\n  "+(null!=(i=a.if.call(t,null!=l?l.property:l,{name:"if",hash:{},fn:n.program(25,r,0),inverse:n.noop,data:r}))?i:"")+"\n  "+(null!=(i=a.if.call(t,null!=l?l.allowedProperty:l,{name:"if",hash:{},fn:n.program(27,r,0),inverse:n.noop,data:r}))?i:"")+">\n  <div></div>\n</div>\n"},useData:!0});

},{"hbsfy/runtime":383}],118:[function(require,module,exports){
var HandlebarsCompiler=require("hbsfy/runtime"),partial$0=require("./tracklist/row-start.hbs");HandlebarsCompiler.registerPartial("./tracklist/row-start.hbs",partial$0);var partial$1=require("./tracklist/play.hbs");HandlebarsCompiler.registerPartial("./tracklist/play.hbs",partial$1);var partial$2=require("./tracklist/save.hbs");HandlebarsCompiler.registerPartial("./tracklist/save.hbs",partial$2);var partial$3=require("./tracklist/name.hbs");HandlebarsCompiler.registerPartial("./tracklist/name.hbs",partial$3);var partial$4=require("./tracklist/artists.hbs");HandlebarsCompiler.registerPartial("./tracklist/artists.hbs",partial$4);var partial$5=require("./tracklist/album.hbs");HandlebarsCompiler.registerPartial("./tracklist/album.hbs",partial$5);var partial$6=require("./tracklist/local.hbs");HandlebarsCompiler.registerPartial("./tracklist/local.hbs",partial$6);var partial$7=require("./tracklist/added-by.hbs");HandlebarsCompiler.registerPartial("./tracklist/added-by.hbs",partial$7);var partial$8=require("./tracklist/date-added.hbs");HandlebarsCompiler.registerPartial("./tracklist/date-added.hbs",partial$8);var partial$9=require("./tracklist/more.hbs");HandlebarsCompiler.registerPartial("./tracklist/more.hbs",partial$9);var partial$10=require("./tracklist/time.hbs");HandlebarsCompiler.registerPartial("./tracklist/time.hbs",partial$10),module.exports=HandlebarsCompiler.template({compiler:[7,">= 4.0.0"],main:function(a,r,t,e,l){var s;return(null!=(s=a.invokePartial(e["./tracklist/row-start.hbs"],r,{name:"./tracklist/row-start.hbs",data:l,helpers:t,partials:e,decorators:a.decorators}))?s:"")+(null!=(s=a.invokePartial(e["./tracklist/play.hbs"],r,{name:"./tracklist/play.hbs",data:l,indent:"  ",helpers:t,partials:e,decorators:a.decorators}))?s:"")+(null!=(s=a.invokePartial(e["./tracklist/save.hbs"],r,{name:"./tracklist/save.hbs",data:l,indent:"  ",helpers:t,partials:e,decorators:a.decorators}))?s:"")+(null!=(s=a.invokePartial(e["./tracklist/name.hbs"],r,{name:"./tracklist/name.hbs",data:l,indent:"  ",helpers:t,partials:e,decorators:a.decorators}))?s:"")+(null!=(s=a.invokePartial(e["./tracklist/artists.hbs"],r,{name:"./tracklist/artists.hbs",data:l,indent:"  ",helpers:t,partials:e,decorators:a.decorators}))?s:"")+(null!=(s=a.invokePartial(e["./tracklist/album.hbs"],r,{name:"./tracklist/album.hbs",data:l,indent:"  ",helpers:t,partials:e,decorators:a.decorators}))?s:"")+(null!=(s=a.invokePartial(e["./tracklist/local.hbs"],r,{name:"./tracklist/local.hbs",data:l,indent:"  ",helpers:t,partials:e,decorators:a.decorators}))?s:"")+(null!=(s=a.invokePartial(e["./tracklist/added-by.hbs"],r,{name:"./tracklist/added-by.hbs",data:l,indent:"  ",helpers:t,partials:e,decorators:a.decorators}))?s:"")+(null!=(s=a.invokePartial(e["./tracklist/date-added.hbs"],r,{name:"./tracklist/date-added.hbs",data:l,indent:"  ",helpers:t,partials:e,decorators:a.decorators}))?s:"")+(null!=(s=a.invokePartial(e["./tracklist/more.hbs"],r,{name:"./tracklist/more.hbs",data:l,indent:"  ",helpers:t,partials:e,decorators:a.decorators}))?s:"")+(null!=(s=a.invokePartial(e["./tracklist/time.hbs"],r,{name:"./tracklist/time.hbs",data:l,indent:"  ",helpers:t,partials:e,decorators:a.decorators}))?s:"")+"</tr>\n"},usePartial:!0,useData:!0});

},{"./tracklist/added-by.hbs":121,"./tracklist/album.hbs":122,"./tracklist/artists.hbs":123,"./tracklist/date-added.hbs":125,"./tracklist/local.hbs":141,"./tracklist/more.hbs":142,"./tracklist/name.hbs":143,"./tracklist/play.hbs":144,"./tracklist/row-start.hbs":145,"./tracklist/save.hbs":146,"./tracklist/time.hbs":151,"hbsfy/runtime":383}],119:[function(require,module,exports){
var HandlebarsCompiler=require("hbsfy/runtime"),partial$0=require("./tracklist/row-start.hbs");HandlebarsCompiler.registerPartial("./tracklist/row-start.hbs",partial$0);var partial$1=require("./tracklist/type.hbs");HandlebarsCompiler.registerPartial("./tracklist/type.hbs",partial$1);var partial$2=require("./tracklist/play.hbs");HandlebarsCompiler.registerPartial("./tracklist/play.hbs",partial$2);var partial$3=require("./tracklist/save.hbs");HandlebarsCompiler.registerPartial("./tracklist/save.hbs",partial$3);var partial$4=require("./tracklist/name.hbs");HandlebarsCompiler.registerPartial("./tracklist/name.hbs",partial$4);var partial$5=require("./tracklist/artists.hbs");HandlebarsCompiler.registerPartial("./tracklist/artists.hbs",partial$5);var partial$6=require("./tracklist/album.hbs");HandlebarsCompiler.registerPartial("./tracklist/album.hbs",partial$6);var partial$7=require("./tracklist/local.hbs");HandlebarsCompiler.registerPartial("./tracklist/local.hbs",partial$7);var partial$8=require("./tracklist/date-added.hbs");HandlebarsCompiler.registerPartial("./tracklist/date-added.hbs",partial$8);var partial$9=require("./tracklist/feedback.hbs");HandlebarsCompiler.registerPartial("./tracklist/feedback.hbs",partial$9);var partial$10=require("./tracklist/more.hbs");HandlebarsCompiler.registerPartial("./tracklist/more.hbs",partial$10);var partial$11=require("./tracklist/more.hbs");HandlebarsCompiler.registerPartial("./tracklist/more.hbs",partial$11);var partial$12=require("./tracklist/time.hbs");HandlebarsCompiler.registerPartial("./tracklist/time.hbs",partial$12),module.exports=HandlebarsCompiler.template({1:function(a,r,t,e,l){var s;return null!=(s=a.invokePartial(e["./tracklist/type.hbs"],r,{name:"./tracklist/type.hbs",data:l,indent:"    ",helpers:t,partials:e,decorators:a.decorators}))?s:""},3:function(a,r,t,e,l){var s;return null!=(s=a.invokePartial(e["./tracklist/play.hbs"],r,{name:"./tracklist/play.hbs",data:l,indent:"    ",helpers:t,partials:e,decorators:a.decorators}))?s:""},5:function(a,r,t,e,l){var s;return(null!=(s=a.invokePartial(e["./tracklist/feedback.hbs"],r,{name:"./tracklist/feedback.hbs",data:l,indent:"    ",helpers:t,partials:e,decorators:a.decorators}))?s:"")+(null!=(s=a.invokePartial(e["./tracklist/more.hbs"],r,{name:"./tracklist/more.hbs",data:l,indent:"    ",helpers:t,partials:e,decorators:a.decorators}))?s:"")},7:function(a,r,t,e,l){var s;return(null!=(s=a.invokePartial(e["./tracklist/more.hbs"],r,{name:"./tracklist/more.hbs",data:l,indent:"    ",helpers:t,partials:e,decorators:a.decorators}))?s:"")+(null!=(s=a.invokePartial(e["./tracklist/time.hbs"],r,{name:"./tracklist/time.hbs",data:l,indent:"    ",helpers:t,partials:e,decorators:a.decorators}))?s:"")},compiler:[7,">= 4.0.0"],main:function(a,r,t,e,l){var s,i=null!=r?r:a.nullContext||{};return(null!=(s=a.invokePartial(e["./tracklist/row-start.hbs"],r,{name:"./tracklist/row-start.hbs",data:l,helpers:t,partials:e,decorators:a.decorators}))?s:"")+(null!=(s=t.if.call(i,null!=r?r.showTrackTypeIcon:r,{name:"if",hash:{},fn:a.program(1,l,0),inverse:a.program(3,l,0),data:l}))?s:"")+(null!=(s=a.invokePartial(e["./tracklist/save.hbs"],r,{name:"./tracklist/save.hbs",data:l,indent:"  ",helpers:t,partials:e,decorators:a.decorators}))?s:"")+(null!=(s=a.invokePartial(e["./tracklist/name.hbs"],r,{name:"./tracklist/name.hbs",data:l,indent:"  ",helpers:t,partials:e,decorators:a.decorators}))?s:"")+(null!=(s=a.invokePartial(e["./tracklist/artists.hbs"],r,{name:"./tracklist/artists.hbs",data:l,indent:"  ",helpers:t,partials:e,decorators:a.decorators}))?s:"")+(null!=(s=a.invokePartial(e["./tracklist/album.hbs"],r,{name:"./tracklist/album.hbs",data:l,indent:"  ",helpers:t,partials:e,decorators:a.decorators}))?s:"")+(null!=(s=a.invokePartial(e["./tracklist/local.hbs"],r,{name:"./tracklist/local.hbs",data:l,indent:"  ",helpers:t,partials:e,decorators:a.decorators}))?s:"")+(null!=(s=a.invokePartial(e["./tracklist/date-added.hbs"],r,{name:"./tracklist/date-added.hbs",data:l,indent:"  ",helpers:t,partials:e,decorators:a.decorators}))?s:"")+(null!=(s=t.if.call(i,null!=r?r.formatListFeedbackEnabled:r,{name:"if",hash:{},fn:a.program(5,l,0),inverse:a.program(7,l,0),data:l}))?s:"")+"</tr>\n"},usePartial:!0,useData:!0});

},{"./tracklist/album.hbs":122,"./tracklist/artists.hbs":123,"./tracklist/date-added.hbs":125,"./tracklist/feedback.hbs":126,"./tracklist/local.hbs":141,"./tracklist/more.hbs":142,"./tracklist/name.hbs":143,"./tracklist/play.hbs":144,"./tracklist/row-start.hbs":145,"./tracklist/save.hbs":146,"./tracklist/time.hbs":151,"./tracklist/type.hbs":152,"hbsfy/runtime":383}],120:[function(require,module,exports){
var HandlebarsCompiler=require("hbsfy/runtime"),partial$0=require("./tracklist/table-attributes.hbs");HandlebarsCompiler.registerPartial("./tracklist/table-attributes.hbs",partial$0);var partial$1=require("./tracklist/header/play.hbs");HandlebarsCompiler.registerPartial("./tracklist/header/play.hbs",partial$1);var partial$2=require("./tracklist/header/save.hbs");HandlebarsCompiler.registerPartial("./tracklist/header/save.hbs",partial$2);var partial$3=require("./tracklist/header/name.hbs");HandlebarsCompiler.registerPartial("./tracklist/header/name.hbs",partial$3);var partial$4=require("./tracklist/header/premium.hbs");HandlebarsCompiler.registerPartial("./tracklist/header/premium.hbs",partial$4);var partial$5=require("./tracklist/header/explicit.hbs");HandlebarsCompiler.registerPartial("./tracklist/header/explicit.hbs",partial$5);var partial$6=require("./tracklist/header/artists.hbs");HandlebarsCompiler.registerPartial("./tracklist/header/artists.hbs",partial$6);var partial$7=require("./tracklist/header/album.hbs");HandlebarsCompiler.registerPartial("./tracklist/header/album.hbs",partial$7);var partial$8=require("./tracklist/header/local.hbs");HandlebarsCompiler.registerPartial("./tracklist/header/local.hbs",partial$8);var partial$9=require("./tracklist/header/added-by.hbs");HandlebarsCompiler.registerPartial("./tracklist/header/added-by.hbs",partial$9);var partial$10=require("./tracklist/header/date-added.hbs");HandlebarsCompiler.registerPartial("./tracklist/header/date-added.hbs",partial$10);var partial$11=require("./tracklist/header/feedback.hbs");HandlebarsCompiler.registerPartial("./tracklist/header/feedback.hbs",partial$11);var partial$12=require("./tracklist/header/more.hbs");HandlebarsCompiler.registerPartial("./tracklist/header/more.hbs",partial$12);var partial$13=require("./tracklist/header/more.hbs");HandlebarsCompiler.registerPartial("./tracklist/header/more.hbs",partial$13);var partial$14=require("./tracklist/header/time.hbs");HandlebarsCompiler.registerPartial("./tracklist/header/time.hbs",partial$14);var partial$15=require("./tracklist/table-body-attributes.hbs");HandlebarsCompiler.registerPartial("./tracklist/table-body-attributes.hbs",partial$15);var partial$16=require("./tracklist-playlist-row-collaborative.hbs");HandlebarsCompiler.registerPartial("./tracklist-playlist-row-collaborative.hbs",partial$16);var partial$17=require("./tracklist-playlist-row.hbs");HandlebarsCompiler.registerPartial("./tracklist-playlist-row.hbs",partial$17),module.exports=HandlebarsCompiler.template({1:function(a,r,e,t,l){return"tracklist-playlist--with-feedback feedback-enabled"},3:function(a,r,e,t,l){var i;return null!=(i=a.invokePartial(t["./tracklist/header/added-by.hbs"],r,{name:"./tracklist/header/added-by.hbs",data:l,indent:"        ",helpers:e,partials:t,decorators:a.decorators}))?i:""},5:function(a,r,e,t,l){var i;return(null!=(i=a.invokePartial(t["./tracklist/header/feedback.hbs"],r,{name:"./tracklist/header/feedback.hbs",data:l,indent:"        ",helpers:e,partials:t,decorators:a.decorators}))?i:"")+(null!=(i=a.invokePartial(t["./tracklist/header/more.hbs"],r,{name:"./tracklist/header/more.hbs",data:l,indent:"        ",helpers:e,partials:t,decorators:a.decorators}))?i:"")},7:function(a,r,e,t,l){var i;return(null!=(i=a.invokePartial(t["./tracklist/header/more.hbs"],r,{name:"./tracklist/header/more.hbs",data:l,indent:"        ",helpers:e,partials:t,decorators:a.decorators}))?i:"")+(null!=(i=a.invokePartial(t["./tracklist/header/time.hbs"],r,{name:"./tracklist/header/time.hbs",data:l,indent:"        ",helpers:e,partials:t,decorators:a.decorators}))?i:"")},9:function(a,r,e,t,l,i,s){var d;return null!=(d=e.if.call(null!=r?r:a.nullContext||{},null!=s[1]?s[1].collaborative:s[1],{name:"if",hash:{},fn:a.program(10,l,0,i,s),inverse:a.program(12,l,0,i,s),data:l}))?d:""},10:function(a,r,e,t,l){var i;return null!=(i=a.invokePartial(t["./tracklist-playlist-row-collaborative.hbs"],r,{name:"./tracklist-playlist-row-collaborative.hbs",data:l,indent:"        ",helpers:e,partials:t,decorators:a.decorators}))?i:""},12:function(a,r,e,t,l){var i;return null!=(i=a.invokePartial(t["./tracklist-playlist-row.hbs"],r,{name:"./tracklist-playlist-row.hbs",data:l,indent:"        ",helpers:e,partials:t,decorators:a.decorators}))?i:""},compiler:[7,">= 4.0.0"],main:function(a,r,e,t,l,i,s){var d,n,o=null!=r?r:a.nullContext||{},h=e.helperMissing;return'<table\n  class="tracklist-playlist '+a.escapeExpression("function"==typeof(n=null!=(n=e.modifiers||(null!=r?r.modifiers:r))?n:h)?n.call(o,{name:"modifiers",hash:{},data:l}):n)+"\n  "+(null!=(d=e.if.call(o,null!=(d=null!=r?r.allows:r)?d.feedback:d,{name:"if",hash:{},fn:a.program(1,l,0,i,s),inverse:a.noop,data:l}))?d:"")+'"\n'+(null!=(d=a.invokePartial(t["./tracklist/table-attributes.hbs"],r,{name:"./tracklist/table-attributes.hbs",data:l,indent:"  ",helpers:e,partials:t,decorators:a.decorators}))?d:"")+'>\n  <thead class="tl-header" data-sticky>\n    <tr>\n'+(null!=(d=a.invokePartial(t["./tracklist/header/play.hbs"],r,{name:"./tracklist/header/play.hbs",data:l,indent:"      ",helpers:e,partials:t,decorators:a.decorators}))?d:"")+(null!=(d=a.invokePartial(t["./tracklist/header/save.hbs"],r,{name:"./tracklist/header/save.hbs",data:l,indent:"      ",helpers:e,partials:t,decorators:a.decorators}))?d:"")+(null!=(d=a.invokePartial(t["./tracklist/header/name.hbs"],r,{name:"./tracklist/header/name.hbs",data:l,indent:"      ",helpers:e,partials:t,decorators:a.decorators}))?d:"")+(null!=(d=a.invokePartial(t["./tracklist/header/premium.hbs"],r,{name:"./tracklist/header/premium.hbs",data:l,indent:"      ",helpers:e,partials:t,decorators:a.decorators}))?d:"")+(null!=(d=a.invokePartial(t["./tracklist/header/explicit.hbs"],r,{name:"./tracklist/header/explicit.hbs",data:l,indent:"      ",helpers:e,partials:t,decorators:a.decorators}))?d:"")+(null!=(d=a.invokePartial(t["./tracklist/header/artists.hbs"],r,{name:"./tracklist/header/artists.hbs",data:l,indent:"      ",helpers:e,partials:t,decorators:a.decorators}))?d:"")+(null!=(d=a.invokePartial(t["./tracklist/header/album.hbs"],r,{name:"./tracklist/header/album.hbs",data:l,indent:"      ",helpers:e,partials:t,decorators:a.decorators}))?d:"")+(null!=(d=a.invokePartial(t["./tracklist/header/local.hbs"],r,{name:"./tracklist/header/local.hbs",data:l,indent:"      ",helpers:e,partials:t,decorators:a.decorators}))?d:"")+(null!=(d=e.if.call(o,null!=r?r.collaborative:r,{name:"if",hash:{},fn:a.program(3,l,0,i,s),inverse:a.noop,data:l}))?d:"")+(null!=(d=a.invokePartial(t["./tracklist/header/date-added.hbs"],r,{name:"./tracklist/header/date-added.hbs",data:l,indent:"      ",helpers:e,partials:t,decorators:a.decorators}))?d:"")+(null!=(d=e.if.call(o,null!=(d=null!=r?r.allows:r)?d.feedback:d,{name:"if",hash:{},fn:a.program(5,l,0,i,s),inverse:a.program(7,l,0,i,s),data:l}))?d:"")+"    </tr>\n  </thead>\n  <tbody "+(null!=(d=a.invokePartial(t["./tracklist/table-body-attributes.hbs"],r,{name:"./tracklist/table-body-attributes.hbs",data:l,helpers:e,partials:t,decorators:a.decorators}))?d:"")+">\n"+(null!=(d=(e.list||r&&r.list||h).call(o,null!=r?r.rows:r,{name:"list",hash:{},fn:a.program(9,l,0,i,s),inverse:a.noop,data:l}))?d:"")+"  </tbody>\n</table>\n"},usePartial:!0,useData:!0,useDepths:!0});

},{"./tracklist-playlist-row-collaborative.hbs":118,"./tracklist-playlist-row.hbs":119,"./tracklist/header/added-by.hbs":127,"./tracklist/header/album.hbs":128,"./tracklist/header/artists.hbs":129,"./tracklist/header/date-added.hbs":130,"./tracklist/header/explicit.hbs":131,"./tracklist/header/feedback.hbs":132,"./tracklist/header/local.hbs":133,"./tracklist/header/more.hbs":134,"./tracklist/header/name.hbs":135,"./tracklist/header/play.hbs":136,"./tracklist/header/premium.hbs":137,"./tracklist/header/save.hbs":138,"./tracklist/header/time.hbs":139,"./tracklist/table-attributes.hbs":147,"./tracklist/table-body-attributes.hbs":148,"hbsfy/runtime":383}],121:[function(require,module,exports){
var HandlebarsCompiler=require("hbsfy/runtime");module.exports=HandlebarsCompiler.template({1:function(l,a,n,e,t){var u,r=null!=a?a:l.nullContext||{},d=n.helperMissing,i=l.escapeExpression;return'<a title="'+i("function"==typeof(u=null!=(u=n.name||(null!=a?a.name:a))?u:d)?u.call(r,{name:"name",hash:{},data:t}):u)+'" href="'+i("function"==typeof(u=null!=(u=n.uri||(null!=a?a.uri:a))?u:d)?u.call(r,{name:"uri",hash:{},data:t}):u)+'" data-uri="'+i("function"==typeof(u=null!=(u=n.uri||(null!=a?a.uri:a))?u:d)?u.call(r,{name:"uri",hash:{},data:t}):u)+'" data-added-by>'+i("function"==typeof(u=null!=(u=n.name||(null!=a?a.name:a))?u:d)?u.call(r,{name:"name",hash:{},data:t}):u)+"</a>"},compiler:[7,">= 4.0.0"],main:function(l,a,n,e,t){var u,r,d,i='<td class="tl-cell tl-added-by">';return r=null!=(r=n.addedBy||(null!=a?a.addedBy:a))?r:n.helperMissing,d={name:"addedBy",hash:{},fn:l.program(1,t,0),inverse:l.noop,data:t},u="function"==typeof r?r.call(null!=a?a:l.nullContext||{},d):r,n.addedBy||(u=n.blockHelperMissing.call(a,u,d)),null!=u&&(i+=u),i+"</td>\n"},useData:!0});

},{"hbsfy/runtime":383}],122:[function(require,module,exports){
var HandlebarsCompiler=require("hbsfy/runtime");module.exports=HandlebarsCompiler.template({1:function(n,l,a,e,t){var u;return null!=(u=a.if.call(null!=l?l:n.nullContext||{},null!=l?l.local:l,{name:"if",hash:{},fn:n.program(2,t,0),inverse:n.program(4,t,0),data:t}))?u:""},2:function(n,l,a,e,t){var u;return'      <span class="tl-cell__content" dir="auto">'+n.escapeExpression("function"==typeof(u=null!=(u=a.name||(null!=l?l.name:l))?u:a.helperMissing)?u.call(null!=l?l:n.nullContext||{},{name:"name",hash:{},data:t}):u)+"</span>\n"},4:function(n,l,a,e,t){var u;return null!=(u=a.if.call(null!=l?l:n.nullContext||{},null!=l?l.uri:l,{name:"if",hash:{},fn:n.program(5,t,0),inverse:n.program(7,t,0),data:t}))?u:""},5:function(n,l,a,e,t){var u,r=null!=l?l:n.nullContext||{},i=a.helperMissing,o=n.escapeExpression;return'        <a title="'+o("function"==typeof(u=null!=(u=a.name||(null!=l?l.name:l))?u:i)?u.call(r,{name:"name",hash:{},data:t}):u)+'" href="'+o("function"==typeof(u=null!=(u=a.uri||(null!=l?l.uri:l))?u:i)?u.call(r,{name:"uri",hash:{},data:t}):u)+'" data-uri="'+o("function"==typeof(u=null!=(u=a.uri||(null!=l?l.uri:l))?u:i)?u.call(r,{name:"uri",hash:{},data:t}):u)+'" data-log-click="album-name" data-interaction-target="album-name" class="tl-cell__content" dir="auto">'+o("function"==typeof(u=null!=(u=a.name||(null!=l?l.name:l))?u:i)?u.call(r,{name:"name",hash:{},data:t}):u)+"</a>\n"},7:function(n,l,a,e,t){var u;return'        <span dir="auto" class="tl-cell__content">'+n.escapeExpression("function"==typeof(u=null!=(u=a.name||(null!=l?l.name:l))?u:a.helperMissing)?u.call(null!=l?l:n.nullContext||{},{name:"name",hash:{},data:t}):u)+"</span>\n"},compiler:[7,">= 4.0.0"],main:function(n,l,a,e,t){var u;return'<td class="tl-cell tl-albums" data-log-context="album-cell">\n'+(null!=(u=a.blockHelperMissing.call(l,n.lambda(null!=(u=null!=l?l.track:l)?u.album:u,l),{name:"track.album",hash:{},fn:n.program(1,t,0),inverse:n.noop,data:t}))?u:"")+"</td>\n"},useData:!0});

},{"hbsfy/runtime":383}],123:[function(require,module,exports){
var HandlebarsCompiler=require("hbsfy/runtime");module.exports=HandlebarsCompiler.template({1:function(a,l,n,e,t){var r;return null!=(r=n.if.call(null!=l?l:a.nullContext||{},null!=l?l.local:l,{name:"if",hash:{},fn:a.program(2,t,0),inverse:a.program(4,t,0),data:t}))?r:""},2:function(a,l,n,e,t){var r;return'<span class="tl-cell__content" dir="auto">'+a.escapeExpression("function"==typeof(r=null!=(r=n.name||(null!=l?l.name:l))?r:n.helperMissing)?r.call(null!=l?l:a.nullContext||{},{name:"name",hash:{},data:t}):r)+"</span>"},4:function(a,l,n,e,t){var r;return null!=(r=(n.compare||l&&l.compare||n.helperMissing).call(null!=l?l:a.nullContext||{},null!=l?l.uri:l,"spotify:artist:0LyfQWJT6nXafLPZqxe9Of",{name:"compare",hash:{operator:"!="},fn:a.program(5,t,0),inverse:a.noop,data:t}))?r:""},5:function(a,l,n,e,t){var r,i=null!=l?l:a.nullContext||{},u=n.helperMissing,s="function",o=a.escapeExpression;return'<a title="'+o(typeof(r=null!=(r=n.name||(null!=l?l.name:l))?r:u)===s?r.call(i,{name:"name",hash:{},data:t}):r)+'" href="'+o(typeof(r=null!=(r=n.uri||(null!=l?l.uri:l))?r:u)===s?r.call(i,{name:"uri",hash:{},data:t}):r)+'" data-uri="'+o(typeof(r=null!=(r=n.uri||(null!=l?l.uri:l))?r:u)===s?r.call(i,{name:"uri",hash:{},data:t}):r)+'" data-log-click="artist-name" data-interaction-target="'+o(typeof(r=null!=(r=n.index||t&&t.index)?r:u)===s?r.call(i,{name:"index",hash:{},data:t}):r)+'" class="tl-cell__content" dir="auto">'+o(typeof(r=null!=(r=n.name||(null!=l?l.name:l))?r:u)===s?r.call(i,{name:"name",hash:{},data:t}):r)+"</a>"},compiler:[7,">= 4.0.0"],main:function(a,l,n,e,t){var r;return'<td class="tl-cell tl-artists" data-log-context="artist-cell" data-interaction-context="artists">\n  '+(null!=(r=(n.slice||l&&l.slice||n.helperMissing).call(null!=l?l:a.nullContext||{},null!=(r=null!=l?l.track:l)?r.artists:r,", ",{name:"slice",hash:{},fn:a.program(1,t,0),inverse:a.noop,data:t}))?r:"")+"\n</td>\n"},useData:!0});

},{"hbsfy/runtime":383}],124:[function(require,module,exports){
var HandlebarsCompiler=require("hbsfy/runtime");module.exports=HandlebarsCompiler.template({1:function(n,a,l,t,o){return"undo-ban"},3:function(n,a,l,t,o){return"contextmenu"},5:function(n,a,l,t,o){var e;return"    "+(null!=(e=(l.compare||a&&a.compare||l.helperMissing).call(null!=a?a:n.nullContext||{},null!=(e=null!=a?a.track:a)?e.thumb:e,"down",{name:"compare",hash:{},fn:n.program(6,o,0),inverse:n.program(8,o,0),data:o}))?e:"")+"\n"},6:function(n,a,l,t,o){return"spoticon-block-active-16"},8:function(n,a,l,t,o){return"spoticon-block-16"},10:function(n,a,l,t,o){var e;return"    "+(null!=(e=(l.compare||a&&a.compare||l.helperMissing).call(null!=a?a:n.nullContext||{},null!=(e=null!=a?a.track:a)?e.thumb:e,"down",{name:"compare",hash:{},fn:n.program(11,o,0),inverse:n.program(13,o,0),data:o}))?e:"")+"\n"},11:function(n,a,l,t,o){return"spoticon-ban-active-16"},13:function(n,a,l,t,o){return"spoticon-ban-16"},15:function(n,a,l,t,o){return"allows-undo"},17:function(n,a,l,t,o){var e,r=null!=a?a:n.nullContext||{},c=l.helperMissing,u=n.escapeExpression;return'    data-tooltip-ban="'+u((l.loc||a&&a.loc||c).call(r,"nft.ban_song_label",{name:"loc",hash:{},data:o}))+'"\n    data-tooltip-undo="'+u((l.loc||a&&a.loc||c).call(r,"nft.undo_ban_song_label",{name:"loc",hash:{},data:o}))+'"\n'+(null!=(e=(l.compare||a&&a.compare||c).call(r,null!=(e=null!=a?a.track:a)?e.thumb:e,"down",{name:"compare",hash:{},fn:n.program(18,o,0),inverse:n.program(20,o,0),data:o}))?e:"")},18:function(n,a,l,t,o){var e=null!=a?a:n.nullContext||{},r=l.helperMissing,c=n.escapeExpression;return'      data-tooltip="'+c((l.loc||a&&a.loc||r).call(e,"nft.undo_ban_song_label",{name:"loc",hash:{},data:o}))+'"\n      aria-label="'+c((l.loc||a&&a.loc||r).call(e,"nft.undo_ban_song_label",{name:"loc",hash:{},data:o}))+'"\n'},20:function(n,a,l,t,o){var e=null!=a?a:n.nullContext||{},r=l.helperMissing,c=n.escapeExpression;return'      data-tooltip="'+c((l.loc||a&&a.loc||r).call(e,"nft.ban_song_label",{name:"loc",hash:{},data:o}))+'"\n      aria-label="'+c((l.loc||a&&a.loc||r).call(e,"nft.ban_song_label",{name:"loc",hash:{},data:o}))+'"\n'},22:function(n,a,l,t,o){var e;return null!=(e=l.if.call(null!=a?a:n.nullContext||{},null!=a?a.formatListFeedbackEnabled:a,{name:"if",hash:{},fn:n.program(23,o,0),inverse:n.program(28,o,0),data:o}))?e:""},23:function(n,a,l,t,o){var e,r=null!=a?a:n.nullContext||{},c=l.helperMissing,u=n.escapeExpression;return'      data-tooltip-ban="'+u((l.loc||a&&a.loc||c).call(r,"format_list.ban_label",{name:"loc",hash:{},data:o}))+'"\n      data-tooltip-undo="'+u((l.loc||a&&a.loc||c).call(r,"format_list.undo_ban_label",{name:"loc",hash:{},data:o}))+'"\n'+(null!=(e=(l.compare||a&&a.compare||c).call(r,null!=(e=null!=a?a.track:a)?e.thumb:e,"down",{name:"compare",hash:{},fn:n.program(24,o,0),inverse:n.program(26,o,0),data:o}))?e:"")},24:function(n,a,l,t,o){var e=null!=a?a:n.nullContext||{},r=l.helperMissing,c=n.escapeExpression;return'        data-tooltip="'+c((l.loc||a&&a.loc||r).call(e,"format_list.undo_ban_label",{name:"loc",hash:{},data:o}))+'"\n        aria-label="'+c((l.loc||a&&a.loc||r).call(e,"format_list.undo_ban_label",{name:"loc",hash:{},data:o}))+'"\n'},26:function(n,a,l,t,o){var e=null!=a?a:n.nullContext||{},r=l.helperMissing,c=n.escapeExpression;return'        data-tooltip="'+c((l.loc||a&&a.loc||r).call(e,"format_list.ban_label",{name:"loc",hash:{},data:o}))+'"\n        aria-label="'+c((l.loc||a&&a.loc||r).call(e,"format_list.ban_label",{name:"loc",hash:{},data:o}))+'"\n'},28:function(n,a,l,t,o){var e=null!=a?a:n.nullContext||{},r=l.helperMissing,c=n.escapeExpression;return'      data-tooltip="'+c((l.loc||a&&a.loc||r).call(e,"ban_label",{name:"loc",hash:{},data:o}))+'"\n      aria-label="'+c((l.loc||a&&a.loc||r).call(e,"ban_label",{name:"loc",hash:{},data:o}))+'"\n'},30:function(n,a,l,t,o){return'      "undo-ban"\n'},32:function(n,a,l,t,o){return'      "show-ban-options"\n    '},compiler:[7,">= 4.0.0"],main:function(n,a,l,t,o){var e,r,c,u=null!=a?a:n.nullContext||{},i=l.helperMissing,s=l.blockHelperMissing,p=n.escapeExpression,m='<button\n  type="button"\n  data-button="'+(null!=(e=(l.compare||a&&a.compare||i).call(u,null!=(e=null!=a?a.track:a)?e.thumb:e,"down",{name:"compare",hash:{},fn:n.program(1,o,0),inverse:n.program(3,o,0),data:o}))?e:"")+'"\n  class="button button-icon-only\n';return r=null!=(r=l.nft||(null!=a?a.nft:a))?r:i,c={name:"nft",hash:{},fn:n.program(5,o,0),inverse:n.program(10,o,0),data:o},e="function"==typeof r?r.call(u,c):r,l.nft||(e=s.call(a,e,c)),null!=e&&(m+=e),m+="    "+(null!=(e=l.if.call(u,null!=a?a.formatListFeedbackEnabled:a,{name:"if",hash:{},fn:n.program(15,o,0),inverse:n.noop,data:o}))?e:"")+'\n  "\n  data-log-click="contextmenu-button"\n  data-uri=\'spotify:special:'+p(n.lambda(null!=(e=null!=a?a.track:a)?e.uri:e,a))+":"+p("function"==typeof(r=null!=(r=l.entity_uri||(null!=a?a.entity_uri:a))?r:i)?r.call(u,{name:"entity_uri",hash:{},data:o}):r)+"'\n",r=null!=(r=l.nft||(null!=a?a.nft:a))?r:i,c={name:"nft",hash:{},fn:n.program(17,o,0),inverse:n.program(22,o,0),data:o},e="function"==typeof r?r.call(u,c):r,l.nft||(e=s.call(a,e,c)),null!=e&&(m+=e),m+'  data-interaction-target="ban-button"\n  data-interaction-intent=\n'+(null!=(e=(l.compare||a&&a.compare||i).call(u,null!=(e=null!=a?a.track:a)?e.thumb:e,"down",{name:"compare",hash:{},fn:n.program(30,o,0),inverse:n.program(32,o,0),data:o}))?e:"")+"></button>\n"},useData:!0});

},{"hbsfy/runtime":383}],125:[function(require,module,exports){
var HandlebarsCompiler=require("hbsfy/runtime");module.exports=HandlebarsCompiler.template({compiler:[7,">= 4.0.0"],main:function(e,d,a,l,t){var n,r=null!=d?d:e.nullContext||{},u=a.helperMissing,i=e.escapeExpression;return'<td class="tl-cell tl-date-added" data-dateadded="'+i("function"==typeof(n=null!=(n=a.dateAddedNumber||(null!=d?d.dateAddedNumber:d))?n:u)?n.call(r,{name:"dateAddedNumber",hash:{},data:t}):n)+'"><div class="tl-cell__fixed-height">'+i("function"==typeof(n=null!=(n=a.dateAdded||(null!=d?d.dateAdded:d))?n:u)?n.call(r,{name:"dateAdded",hash:{},data:t}):n)+"</div></td>\n"},useData:!0});

},{"hbsfy/runtime":383}],126:[function(require,module,exports){
var HandlebarsCompiler=require("hbsfy/runtime"),partial$0=require("./thumbs-down.hbs");HandlebarsCompiler.registerPartial("./thumbs-down.hbs",partial$0);var partial$1=require("./thumbs-up.hbs");HandlebarsCompiler.registerPartial("./thumbs-up.hbs",partial$1);var partial$2=require("./heart.hbs");HandlebarsCompiler.registerPartial("./heart.hbs",partial$2);var partial$3=require("./ban.hbs");HandlebarsCompiler.registerPartial("./ban.hbs",partial$3),module.exports=HandlebarsCompiler.template({1:function(a,r,e,t,n){var l;return"    thumbs-"+a.escapeExpression(a.lambda(null!=(l=null!=r?r.track:r)?l.thumb:l,r))+"\n"},3:function(a,r,e,t,n){return"    thumbs-none\n  "},5:function(a,r,e,t,n){var l;return(null!=(l=a.invokePartial(t["./thumbs-down.hbs"],r,{name:"./thumbs-down.hbs",data:n,indent:"    ",helpers:e,partials:t,decorators:a.decorators}))?l:"")+(null!=(l=a.invokePartial(t["./thumbs-up.hbs"],r,{name:"./thumbs-up.hbs",data:n,indent:"    ",helpers:e,partials:t,decorators:a.decorators}))?l:"")},7:function(a,r,e,t,n){var l;return(null!=(l=a.invokePartial(t["./heart.hbs"],r,{name:"./heart.hbs",data:n,indent:"    ",helpers:e,partials:t,decorators:a.decorators}))?l:"")+(null!=(l=a.invokePartial(t["./ban.hbs"],r,{name:"./ban.hbs",data:n,indent:"    ",helpers:e,partials:t,decorators:a.decorators}))?l:"")},compiler:[7,">= 4.0.0"],main:function(a,r,e,t,n){var l,s=null!=r?r:a.nullContext||{};return'<td class="tl-cell tl-feedback\n'+(null!=(l=e.if.call(s,null!=(l=null!=r?r.track:r)?l.thumb:l,{name:"if",hash:{},fn:a.program(1,n,0),inverse:a.program(3,n,0),data:n}))?l:"")+'" data-button="feedback"\n>\n'+(null!=(l=(e.compare||r&&r.compare||e.helperMissing).call(s,null!=r?r.isClusterStationUri:r,!1,{name:"compare",hash:{},fn:a.program(5,n,0),inverse:a.program(7,n,0),data:n}))?l:"")+"</td>\n"},usePartial:!0,useData:!0});

},{"./ban.hbs":124,"./heart.hbs":140,"./thumbs-down.hbs":149,"./thumbs-up.hbs":150,"hbsfy/runtime":383}],127:[function(require,module,exports){
var HandlebarsCompiler=require("hbsfy/runtime");module.exports=HandlebarsCompiler.template({1:function(a,e,n,r,l){var o;return null!=(o=(n.compare||e&&e.compare||n.helperMissing).call(null!=e?e:a.nullContext||{},null!=e?e.sortDirection:e,"asc",{name:"compare",hash:{},fn:a.program(2,l,0),inverse:a.program(4,l,0),data:l}))?o:""},2:function(a,e,n,r,l){return"    tl-sort-asc\n"},4:function(a,e,n,r,l){return"    tl-sort-desc\n"},6:function(a,e,n,r,l){return'data-sort="addedBy(name)"'},compiler:[7,">= 4.0.0"],main:function(a,e,n,r,l){var o,t=null!=e?e:a.nullContext||{},s=n.helperMissing;return'<th class="tl-added-by\n'+(null!=(o=(n.compare||e&&e.compare||s).call(t,"addedBy(name)",null!=e?e.sortQuery:e,{name:"compare",hash:{},fn:a.program(1,l,0),inverse:a.noop,data:l}))?o:"")+'" '+(null!=(o=n.if.call(t,null!=e?e.sortable:e,{name:"if",hash:{},fn:a.program(6,l,0),inverse:a.noop,data:l}))?o:"")+">"+a.escapeExpression((n.loc||e&&e.loc||s).call(t,"User",{name:"loc",hash:{},data:l}))+"</th>\n"},useData:!0});

},{"hbsfy/runtime":383}],128:[function(require,module,exports){
var HandlebarsCompiler=require("hbsfy/runtime");module.exports=HandlebarsCompiler.template({1:function(a,n,r,e,l){var t;return null!=(t=(r.compare||n&&n.compare||r.helperMissing).call(null!=n?n:a.nullContext||{},null!=n?n.sortDirection:n,"asc",{name:"compare",hash:{},fn:a.program(2,l,0),inverse:a.program(4,l,0),data:l}))?t:""},2:function(a,n,r,e,l){return"    tl-sort-asc\n"},4:function(a,n,r,e,l){return"    tl-sort-desc\n"},6:function(a,n,r,e,l){return'data-sort="track(album(name),disc,number)" data-interaction-target="header-album" data-interaction-intent="sort-by-album"'},compiler:[7,">= 4.0.0"],main:function(a,n,r,e,l){var t,o=null!=n?n:a.nullContext||{},s=r.helperMissing;return'<th class="tl-albums\n'+(null!=(t=(r.compare||n&&n.compare||s).call(o,"track(album(name),disc,number)",null!=n?n.sortQuery:n,{name:"compare",hash:{},fn:a.program(1,l,0),inverse:a.noop,data:l}))?t:"")+'" '+(null!=(t=r.if.call(o,null!=n?n.sortable:n,{name:"if",hash:{},fn:a.program(6,l,0),inverse:a.noop,data:l}))?t:"")+">"+a.escapeExpression((r.loc||n&&n.loc||s).call(o,"Album",{name:"loc",hash:{},data:l}))+"</th>\n"},useData:!0});

},{"hbsfy/runtime":383}],129:[function(require,module,exports){
var HandlebarsCompiler=require("hbsfy/runtime");module.exports=HandlebarsCompiler.template({1:function(a,r,n,t,e){var l;return null!=(l=(n.compare||r&&r.compare||n.helperMissing).call(null!=r?r:a.nullContext||{},null!=r?r.sortDirection:r,"asc",{name:"compare",hash:{},fn:a.program(2,e,0),inverse:a.program(4,e,0),data:e}))?l:""},2:function(a,r,n,t,e){return"    tl-sort-asc\n"},4:function(a,r,n,t,e){return"    tl-sort-desc\n"},6:function(a,r,n,t,e){return'data-sort="track(artists[0:1](name),album(name),disc,number)" data-interaction-target="header-artist" data-interaction-intent="sort-by-artist"'},compiler:[7,">= 4.0.0"],main:function(a,r,n,t,e){var l,s=null!=r?r:a.nullContext||{},o=n.helperMissing;return'<th class="tl-artists\n'+(null!=(l=(n.compare||r&&r.compare||o).call(s,"track(artists[0:1](name),album(name),disc,number)",null!=r?r.sortQuery:r,{name:"compare",hash:{},fn:a.program(1,e,0),inverse:a.noop,data:e}))?l:"")+'" '+(null!=(l=n.if.call(s,null!=r?r.sortable:r,{name:"if",hash:{},fn:a.program(6,e,0),inverse:a.noop,data:e}))?l:"")+">"+a.escapeExpression((n.loc||r&&r.loc||o).call(s,"Artist",{name:"loc",hash:{},data:e}))+"</th>\n"},useData:!0});

},{"hbsfy/runtime":383}],130:[function(require,module,exports){
var HandlebarsCompiler=require("hbsfy/runtime");module.exports=HandlebarsCompiler.template({1:function(e,a,n,r,t){var l;return null!=(l=(n.compare||a&&a.compare||n.helperMissing).call(null!=a?a:e.nullContext||{},null!=a?a.sortDirection:a,"asc",{name:"compare",hash:{},fn:e.program(2,t,0),inverse:e.program(4,t,0),data:t}))?l:""},2:function(e,a,n,r,t){return"    tl-sort-asc\n"},4:function(e,a,n,r,t){return"    tl-sort-desc\n"},6:function(e,a,n,r,t){return'data-sort="timeSinceAdded,track(album(name),disc,number)" data-interaction-target="header-date-added" data-interaction-intent="sort-by-date-added"'},compiler:[7,">= 4.0.0"],main:function(e,a,n,r,t){var l,o=null!=a?a:e.nullContext||{};return'<th class="tl-date-added\n'+(null!=(l=(n.compare||a&&a.compare||n.helperMissing).call(o,"timeSinceAdded,track(album(name),disc,number)",null!=a?a.sortQuery:a,{name:"compare",hash:{},fn:e.program(1,t,0),inverse:e.noop,data:t}))?l:"")+'" '+(null!=(l=n.if.call(o,null!=a?a.sortable:a,{name:"if",hash:{},fn:e.program(6,t,0),inverse:e.noop,data:t}))?l:"")+"></th>\n"},useData:!0});

},{"hbsfy/runtime":383}],131:[function(require,module,exports){
var HandlebarsCompiler=require("hbsfy/runtime");module.exports=HandlebarsCompiler.template({1:function(e,l,r,a,n){return"data-sort-previous"},compiler:[7,">= 4.0.0"],main:function(e,l,r,a,n){var t;return'<th class="tl-explicit" '+(null!=(t=r.if.call(null!=l?l:e.nullContext||{},null!=l?l.sortable:l,{name:"if",hash:{},fn:e.program(1,n,0),inverse:e.noop,data:n}))?t:"")+"></th>\n"},useData:!0});

},{"hbsfy/runtime":383}],132:[function(require,module,exports){
var HandlebarsCompiler=require("hbsfy/runtime");module.exports=HandlebarsCompiler.template({compiler:[7,">= 4.0.0"],main:function(e,r,a,t,l){return'<th class="tl-feedback"></th>\n'},useData:!0});

},{"hbsfy/runtime":383}],133:[function(require,module,exports){
var HandlebarsCompiler=require("hbsfy/runtime");module.exports=HandlebarsCompiler.template({1:function(l,a,e,r,n){return"data-sort-previous"},compiler:[7,">= 4.0.0"],main:function(l,a,e,r,n){var t;return'<th class="tl-local" '+(null!=(t=e.if.call(null!=a?a:l.nullContext||{},null!=a?a.sortable:a,{name:"if",hash:{},fn:l.program(1,n,0),inverse:l.noop,data:n}))?t:"")+"></th>"},useData:!0});

},{"hbsfy/runtime":383}],134:[function(require,module,exports){
var HandlebarsCompiler=require("hbsfy/runtime");module.exports=HandlebarsCompiler.template({1:function(r,e,a,l,n){return"data-sort-previous"},compiler:[7,">= 4.0.0"],main:function(r,e,a,l,n){var t;return'<th class="tl-more" '+(null!=(t=a.if.call(null!=e?e:r.nullContext||{},null!=e?e.sortable:e,{name:"if",hash:{},fn:r.program(1,n,0),inverse:r.noop,data:n}))?t:"")+"></th>\r"},useData:!0});

},{"hbsfy/runtime":383}],135:[function(require,module,exports){
var HandlebarsCompiler=require("hbsfy/runtime");module.exports=HandlebarsCompiler.template({1:function(a,n,e,r,t){var l;return null!=(l=(e.compare||n&&n.compare||e.helperMissing).call(null!=n?n:a.nullContext||{},null!=n?n.sortDirection:n,"asc",{name:"compare",hash:{},fn:a.program(2,t,0),inverse:a.program(4,t,0),data:t}))?l:""},2:function(a,n,e,r,t){return"    tl-sort-asc\n"},4:function(a,n,e,r,t){return"    tl-sort-desc\n"},6:function(a,n,e,r,t){return'data-sort="track(name)" data-interaction-target="header-name" data-interaction-intent="sort-by-name"'},compiler:[7,">= 4.0.0"],main:function(a,n,e,r,t){var l,o=null!=n?n:a.nullContext||{},s=e.helperMissing;return'<th class="tl-name\n'+(null!=(l=(e.compare||n&&n.compare||s).call(o,"track(name)",null!=n?n.sortQuery:n,{name:"compare",hash:{},fn:a.program(1,t,0),inverse:a.noop,data:t}))?l:"")+'" '+(null!=(l=e.if.call(o,null!=n?n.sortable:n,{name:"if",hash:{},fn:a.program(6,t,0),inverse:a.noop,data:t}))?l:"")+">"+a.escapeExpression((e.loc||n&&n.loc||s).call(o,"Title",{name:"loc",hash:{},data:t}))+"</th>\n"},useData:!0});

},{"hbsfy/runtime":383}],136:[function(require,module,exports){
var HandlebarsCompiler=require("hbsfy/runtime");module.exports=HandlebarsCompiler.template({compiler:[7,">= 4.0.0"],main:function(e,r,a,l,t){return'<th class="tl-play"></th>\n'},useData:!0});

},{"hbsfy/runtime":383}],137:[function(require,module,exports){
var HandlebarsCompiler=require("hbsfy/runtime");module.exports=HandlebarsCompiler.template({1:function(e,r,a,l,n){return"data-sort-previous"},compiler:[7,">= 4.0.0"],main:function(e,r,a,l,n){var t;return'<th class="tl-premium" '+(null!=(t=a.if.call(null!=r?r:e.nullContext||{},null!=r?r.sortable:r,{name:"if",hash:{},fn:e.program(1,n,0),inverse:e.noop,data:n}))?t:"")+"></th>\n"},useData:!0});

},{"hbsfy/runtime":383}],138:[function(require,module,exports){
var HandlebarsCompiler=require("hbsfy/runtime");module.exports=HandlebarsCompiler.template({compiler:[7,">= 4.0.0"],main:function(e,r,a,t,l){return'<th class="tl-save"></th>\n'},useData:!0});

},{"hbsfy/runtime":383}],139:[function(require,module,exports){
var HandlebarsCompiler=require("hbsfy/runtime");module.exports=HandlebarsCompiler.template({1:function(r,n,a,t,e){var l;return null!=(l=(a.compare||n&&n.compare||a.helperMissing).call(null!=n?n:r.nullContext||{},null!=n?n.sortDirection:n,"asc",{name:"compare",hash:{},fn:r.program(2,e,0),inverse:r.program(4,e,0),data:e}))?l:""},2:function(r,n,a,t,e){return"    tl-sort-asc\n"},4:function(r,n,a,t,e){return"    tl-sort-desc\n"},6:function(r,n,a,t,e){return'data-sort="track(duration)" data-interaction-target="header-duration" data-interaction-intent="sort-by-duration"'},compiler:[7,">= 4.0.0"],main:function(r,n,a,t,e){var l,o=null!=n?n:r.nullContext||{};return'<th class="tl-time\n'+(null!=(l=(a.compare||n&&n.compare||a.helperMissing).call(o,"track(duration)",null!=n?n.sortQuery:n,{name:"compare",hash:{},fn:r.program(1,e,0),inverse:r.noop,data:e}))?l:"")+'" '+(null!=(l=a.if.call(o,null!=n?n.sortable:n,{name:"if",hash:{},fn:r.program(6,e,0),inverse:r.noop,data:e}))?l:"")+"></th>\n"},useData:!0});

},{"hbsfy/runtime":383}],140:[function(require,module,exports){
var HandlebarsCompiler=require("hbsfy/runtime");module.exports=HandlebarsCompiler.template({1:function(a,n,t,l,e){return"undo-heart"},3:function(a,n,t,l,e){return"heart"},5:function(a,n,t,l,e){return"spoticon-heart-active-16"},7:function(a,n,t,l,e){return"spoticon-heart-16"},9:function(a,n,t,l,e){var o=null!=n?n:a.nullContext||{},r=t.helperMissing,c=a.escapeExpression;return'    data-tooltip="'+c((t.loc||n&&n.loc||r).call(o,"undo_heart_label",{name:"loc",hash:{},data:e}))+'"\n    aria-label="'+c((t.loc||n&&n.loc||r).call(o,"undo_heart_label",{name:"loc",hash:{},data:e}))+'"\n    data-interaction-intent="undo-heart"\n'},11:function(a,n,t,l,e){var o=null!=n?n:a.nullContext||{},r=t.helperMissing,c=a.escapeExpression;return'    data-tooltip="'+c((t.loc||n&&n.loc||r).call(o,"heart_label",{name:"loc",hash:{},data:e}))+'"\n    aria-label="'+c((t.loc||n&&n.loc||r).call(o,"heart_label",{name:"loc",hash:{},data:e}))+'"\n    data-interaction-intent="heart"\n'},compiler:[7,">= 4.0.0"],main:function(a,n,t,l,e){var o,r=null!=n?n:a.nullContext||{},c=t.helperMissing,u=a.escapeExpression;return'<button\n  type="button"\n  data-button="'+(null!=(o=(t.compare||n&&n.compare||c).call(r,null!=(o=null!=n?n.track:n)?o.thumb:o,"up",{name:"compare",hash:{},fn:a.program(1,e,0),inverse:a.program(3,e,0),data:e}))?o:"")+'"\n  class="button button-icon-only\n    '+(null!=(o=(t.compare||n&&n.compare||c).call(r,null!=(o=null!=n?n.track:n)?o.thumb:o,"up",{name:"compare",hash:{},fn:a.program(5,e,0),inverse:a.program(7,e,0),data:e}))?o:"")+'\n    allows-undo\n  "\n  data-tooltip-heart="'+u((t.loc||n&&n.loc||c).call(r,"heart_label",{name:"loc",hash:{},data:e}))+'"\n  data-tooltip-undo="'+u((t.loc||n&&n.loc||c).call(r,"undo_heart_label",{name:"loc",hash:{},data:e}))+'"\n  data-intent-heart="heart"\n  data-intent-undo="undo-heart"\n'+(null!=(o=(t.compare||n&&n.compare||c).call(r,null!=(o=null!=n?n.track:n)?o.thumb:o,"up",{name:"compare",hash:{},fn:a.program(9,e,0),inverse:a.program(11,e,0),data:e}))?o:"")+'  data-interaction-target="heart-button"\n  data-log-click="heart-button"\n  data-log-data=\'{ "target_uri": "'+u(a.lambda(null!=(o=null!=n?n.track:n)?o.uri:o,n))+"\" }'></button>\n"},useData:!0});

},{"hbsfy/runtime":383}],141:[function(require,module,exports){
var HandlebarsCompiler=require("hbsfy/runtime");module.exports=HandlebarsCompiler.template({1:function(l,a,n,e,t){return'  <span class="tl-item-local spoticon-localfile-16" data-tooltip="'+l.escapeExpression((n.loc||a&&a.loc||n.helperMissing).call(null!=a?a:l.nullContext||{},"LocalFile",{name:"loc",hash:{},data:t}))+'"></span>\n'},compiler:[7,">= 4.0.0"],main:function(l,a,n,e,t){var o;return'<td class="tl-cell tl-local">\n'+(null!=(o=n.if.call(null!=a?a:l.nullContext||{},null!=(o=null!=a?a.track:a)?o.local:o,{name:"if",hash:{},fn:l.program(1,t,0),inverse:l.noop,data:t}))?o:"")+"</td>\n"},useData:!0});

},{"hbsfy/runtime":383}],142:[function(require,module,exports){
var HandlebarsCompiler=require("hbsfy/runtime");module.exports=HandlebarsCompiler.template({compiler:[7,">= 4.0.0"],main:function(t,n,a,e,l){var o,i=null!=n?n:t.nullContext||{},u=a.helperMissing,r=t.escapeExpression;return'<td class="tl-cell tl-more">\n  <div class="tl-cell__fixed-height">\n    <button\n      type="button"\n      data-button="contextmenu"\n      class="button button-icon-only button-more"\n      data-tooltip="'+r((a.loc||n&&n.loc||u).call(i,"More",{name:"loc",hash:{},data:l}))+'"\n      data-log-click="more-button"\n      data-log-data=\'{ "index": '+r("function"==typeof(o=null!=(o=a.index||l&&l.index)?o:u)?o.call(i,{name:"index",hash:{},data:l}):o)+', "target_uri": "'+r("function"==typeof(o=null!=(o=a.uri||(null!=n?n.uri:n))?o:u)?o.call(i,{name:"uri",hash:{},data:l}):o)+'" }\'\n      data-interaction-target="context-menu-button"\n      data-interaction-intent="show-options"></button>\n  </div>\n</td>\n'},useData:!0});

},{"hbsfy/runtime":383}],143:[function(require,module,exports){
var HandlebarsCompiler=require("hbsfy/runtime");module.exports=HandlebarsCompiler.template({1:function(n,l,a,t,e){var r;return null!=(r=a.if.call(null!=l?l:n.nullContext||{},null!=(r=null!=l?l.track:l)?r.premium:r,{name:"if",hash:{},fn:n.program(2,e,0),inverse:n.program(4,e,0),data:e}))?r:""},2:function(n,l,a,t,e){return'    <td class="tl-cell tl-name" colspan="1" data-log-context="name-cell" data-ta-id="name-cell">\n'},4:function(n,l,a,t,e){return'    <td class="tl-cell tl-name" colspan="2" data-log-context="name-cell" data-ta-id="name-cell">\n'},6:function(n,l,a,t,e){var r;return null!=(r=a.if.call(null!=l?l:n.nullContext||{},null!=(r=null!=l?l.track:l)?r.premium:r,{name:"if",hash:{},fn:n.program(4,e,0),inverse:n.program(7,e,0),data:e}))?r:""},7:function(n,l,a,t,e){return'    <td class="tl-cell tl-name" colspan="3" data-log-context="name-cell" data-ta-id="name-cell">\n'},9:function(n,l,a,t,e){return'    <span class="tl-status-indicator tl-status-indicator--in-progress"></span>\n'},11:function(n,l,a,t,e){var r;return null!=(r=a.if.call(null!=l?l:n.nullContext||{},null!=l?l.new:l,{name:"if",hash:{},fn:n.program(12,e,0),inverse:n.noop,data:e}))?r:""},12:function(n,l,a,t,e){return'      <span class="tl-status-indicator tl-status-indicator--new"></span>\n'},14:function(n,l,a,t,e){var r;return null!=(r=a.if.call(null!=l?l:n.nullContext||{},null!=l?l.isLongDescriptionExpanded:l,{name:"if",hash:{},fn:n.program(15,e,0),inverse:n.program(17,e,0),data:e}))?r:""},15:function(n,l,a,t,e){var r;return'    <div class="tl-name__description tl-name__description--scrollable">\n      <span dir="auto">'+n.escapeExpression(n.lambda(null!=(r=null!=l?l.track:l)?r.description:r,l))+"</span>\n    </div>\n"},17:function(n,l,a,t,e){var r;return'    <div class="tl-name__description tl-name__description--clamped">\n       <span dir="auto">'+n.escapeExpression(n.lambda(null!=(r=null!=l?l.track:l)?r.description:r,l))+"</span>\n    </div>\n"},19:function(n,l,a,t,e){return'</td><td class="tl-cell tl-premium"><span class="label" data-log-click="premium">PREMIUM</span>'},21:function(n,l,a,t,e){return'</td><td class="tl-cell tl-explicit"><span class="label" data-log-click="explicit">EXPLICIT</span>'},compiler:[7,">= 4.0.0"],main:function(n,l,a,t,e){var r,i=null!=l?l:n.nullContext||{},s=n.lambda,c=a.blockHelperMissing;return(null!=(r=a.if.call(i,null!=(r=null!=l?l.track:l)?r.explicit:r,{name:"if",hash:{},fn:n.program(1,e,0),inverse:n.program(6,e,0),data:e}))?r:"")+'<div class="tl-highlight tl-cell__fixed-height" data-log-click="name">\n'+(null!=(r=a.if.call(i,null!=l?l.inProgress:l,{name:"if",hash:{},fn:n.program(9,e,0),inverse:n.program(11,e,0),data:e}))?r:"")+'  <span class="tl-name__title tl-cell__content" dir="auto">\n  '+n.escapeExpression(s(null!=(r=null!=l?l.track:l)?r.name:r,l))+"\n  </span>\n</div>\n"+(null!=(r=a.if.call(i,null!=(r=null!=l?l.track:l)?r.description:r,{name:"if",hash:{},fn:n.program(14,e,0),inverse:n.noop,data:e}))?r:"")+(null!=(r=c.call(l,s(null!=(r=null!=l?l.track:l)?r.premium:r,l),{name:"track.premium",hash:{},fn:n.program(19,e,0),inverse:n.noop,data:e}))?r:"")+"\n"+(null!=(r=c.call(l,s(null!=(r=null!=l?l.track:l)?r.explicit:r,l),{name:"track.explicit",hash:{},fn:n.program(21,e,0),inverse:n.noop,data:e}))?r:"")+"\n</td>\n"},useData:!0});

},{"hbsfy/runtime":383}],144:[function(require,module,exports){
var HandlebarsCompiler=require("hbsfy/runtime");module.exports=HandlebarsCompiler.template({compiler:[7,">= 4.0.0"],main:function(t,n,a,l,e){return'<td class="tl-cell tl-play">\n  <div class="tl-cell__fixed-height allow-overflow">\n  <button\n    type="button"\n    data-button="play"\n    class="button button-icon-with-stroke button-play"\n    data-ta-id="play-button"\n    data-interaction-target="play-pause-button"\n    data-interaction-intent="play"\n    data-log-click="play-button"></button>\n  </div>\n</td>\n'},useData:!0});

},{"hbsfy/runtime":383}],145:[function(require,module,exports){
var HandlebarsCompiler=require("hbsfy/runtime");module.exports=HandlebarsCompiler.template({1:function(n,l,a,e,r){var t;return n.escapeExpression("function"==typeof(t=null!=(t=a.name||(null!=l?l.name:l))?t:a.helperMissing)?t.call(null!=l?l:n.nullContext||{},{name:"name",hash:{},data:r}):t)},3:function(n,l,a,e,r){var t;return n.escapeExpression("function"==typeof(t=null!=(t=a.index||(null!=l?l.index:l))?t:a.helperMissing)?t.call(null!=l?l:n.nullContext||{},{name:"index",hash:{},data:r}):t)},5:function(n,l,a,e,r){var t;return n.escapeExpression("function"==typeof(t=null!=(t=a.index||r&&r.index)?t:a.helperMissing)?t.call(null!=l?l:n.nullContext||{},{name:"index",hash:{},data:r}):t)},7:function(n,l,a,e,r){var t;return n.escapeExpression("function"==typeof(t=null!=(t=a.contextIndex||(null!=l?l.contextIndex:l))?t:a.helperMissing)?t.call(null!=l?l:n.nullContext||{},{name:"contextIndex",hash:{},data:r}):t)},9:function(n,l,a,e,r){var t;return null!=(t=a.if.call(null!=l?l:n.nullContext||{},null!=l?l.index:l,{name:"if",hash:{},fn:n.program(3,r,0),inverse:n.program(5,r,0),data:r}))?t:""},11:function(n,l,a,e,r){var t;return'data-uid="'+n.escapeExpression("function"==typeof(t=null!=(t=a.uid||(null!=l?l.uid:l))?t:a.helperMissing)?t.call(null!=l?l:n.nullContext||{},{name:"uid",hash:{},data:r}):t)+'"'},13:function(n,l,a,e,r){var t;return null!=(t=a.if.call(null!=l?l:n.nullContext||{},null!=(t=null!=l?l.track:l)?t.offlineProgress:t,{name:"if",hash:{},fn:n.program(14,r,0),inverse:n.program(19,r,0),data:r}))?t:""},14:function(n,l,a,e,r){var t;return null!=(t=(a.compare||l&&l.compare||a.helperMissing).call(null!=l?l:n.nullContext||{},null!=(t=null!=l?l.track:l)?t.offlineProgress:t,1,{name:"compare",hash:{},fn:n.program(15,r,0),inverse:n.program(17,r,0),data:r}))?t:""},15:function(n,l,a,e,r){return"            offline-downloaded\n"},17:function(n,l,a,e,r){return"            offline-downloading\n"},19:function(n,l,a,e,r){return"          offline-waiting\n"},21:function(n,l,a,e,r){return"playing"},23:function(n,l,a,e,r){return"selected"},25:function(n,l,a,e,r){return"added"},27:function(n,l,a,e,r){return"unavailable"},29:function(n,l,a,e,r){return"local"},31:function(n,l,a,e,r){return"locally-playable"},33:function(n,l,a,e,r){var t;return"thumbs-"+n.escapeExpression(n.lambda(null!=(t=null!=l?l.track:l)?t.thumb:t,l))},35:function(n,l,a,e,r){return"thumbs-none"},37:function(n,l,a,e,r){return"tl-row--episode"},compiler:[7,">= 4.0.0"],main:function(n,l,a,e,r){var t,u,i=n.lambda,o=n.escapeExpression,s=null!=l?l:n.nullContext||{},c=a.helperMissing;return'<tr tabindex="0"\n    aria-label="'+o(i(null!=(t=null!=l?l.track:l)?t.name:t,l))+" "+o((a.loc||l&&l.loc||c).call(s,"By",{name:"loc",hash:{},data:r}))+" "+(null!=(t=(a.slice||l&&l.slice||c).call(s,null!=(t=null!=l?l.track:l)?t.artists:t,", ",{name:"slice",hash:{},fn:n.program(1,r,0),inverse:n.noop,data:r}))?t:"")+". "+o((a.loc||l&&l.loc||c).call(s,"PressEnterToPlay",{name:"loc",hash:{},data:r}))+'."\n    data-list-item="true"\n    data-uri="'+o(i(null!=(t=null!=l?l.track:l)?t.uri:t,l))+'"\n    data-index="'+(null!=(t=a.if.call(s,null!=l?l.index:l,{name:"if",hash:{},fn:n.program(3,r,0),inverse:n.program(5,r,0),data:r}))?t:"")+'"\n    data-context-index="'+(null!=(t=a.if.call(s,null!=l?l.contextIndex:l,{name:"if",hash:{},fn:n.program(7,r,0),inverse:n.program(9,r,0),data:r}))?t:"")+'"\n    '+(null!=(t=a.if.call(s,null!=l?l.uid:l,{name:"if",hash:{},fn:n.program(11,r,0),inverse:n.noop,data:r}))?t:"")+'\n    data-scroll-page-item="'+o("function"==typeof(u=null!=(u=a.scrollPageItem||(null!=l?l.scrollPageItem:l))?u:c)?u.call(s,{name:"scrollPageItem",hash:{},data:r}):u)+'" draggable="true"\n    data-interaction-context="'+(null!=(t=a.if.call(s,null!=l?l.index:l,{name:"if",hash:{},fn:n.program(3,r,0),inverse:n.program(5,r,0),data:r}))?t:"")+'"\n    data-ta-id="tracklist-row"\n    data-log-data=\'{\n      "index": '+(null!=(t=a.if.call(s,null!=l?l.index:l,{name:"if",hash:{},fn:n.program(3,r,0),inverse:n.program(5,r,0),data:r}))?t:"")+',\n      "target_uri": "'+o(i(null!=(t=null!=l?l.track:l)?t.uri:t,l))+'",\n      "name": "'+o(i(null!=(t=null!=l?l.track:l)?t.name:t,l))+'"\n    }\'\n    data-contextmenu-spy\n    class="tl-row\n'+(null!=(t=a.if.call(s,null!=(t=null!=l?l.track:l)?t.shouldBeOffline:t,{name:"if",hash:{},fn:n.program(13,r,0),inverse:n.noop,data:r}))?t:"")+"      "+(null!=(t=a.if.call(s,null!=(t=null!=l?l.track:l)?t.playing:t,{name:"if",hash:{},fn:n.program(21,r,0),inverse:n.noop,data:r}))?t:"")+"\n      "+(null!=(t=a.if.call(s,null!=(t=null!=l?l.track:l)?t.selected:t,{name:"if",hash:{},fn:n.program(23,r,0),inverse:n.noop,data:r}))?t:"")+"\n      "+(null!=(t=a.if.call(s,null!=(t=null!=l?l.track:l)?t.added:t,{name:"if",hash:{},fn:n.program(25,r,0),inverse:n.noop,data:r}))?t:"")+"\n      "+(null!=(t=a.if.call(s,null!=(t=null!=l?l.track:l)?t.unavailable:t,{name:"if",hash:{},fn:n.program(27,r,0),inverse:n.noop,data:r}))?t:"")+"\n      "+(null!=(t=a.if.call(s,null!=(t=null!=l?l.track:l)?t.local:t,{name:"if",hash:{},fn:n.program(29,r,0),inverse:n.noop,data:r}))?t:"")+"\n      "+(null!=(t=a.if.call(s,null!=(t=null!=l?l.track:l)?t.locallyPlayable:t,{name:"if",hash:{},fn:n.program(31,r,0),inverse:n.noop,data:r}))?t:"")+"\n      "+(null!=(t=a.if.call(s,null!=(t=null!=l?l.track:l)?t.thumb:t,{name:"if",hash:{},fn:n.program(33,r,0),inverse:n.program(35,r,0),data:r}))?t:"")+"\n      "+(null!=(t=a.if.call(s,null!=(t=null!=l?l.track:l)?t.isEpisode:t,{name:"if",hash:{},fn:n.program(37,r,0),inverse:n.noop,data:r}))?t:"")+'\n    "\n    data-contextmenu>\n'},useData:!0});

},{"hbsfy/runtime":383}],146:[function(require,module,exports){
var HandlebarsCompiler=require("hbsfy/runtime");module.exports=HandlebarsCompiler.template({1:function(n,a,t,l,o){var e;return null!=(e=(t.type||a&&a.type||t.helperMissing).call(null!=a?a:n.nullContext||{},null!=(e=null!=a?a.track:a)?e.uri:e,"track",{name:"type",hash:{},fn:n.program(2,o,0),inverse:n.program(8,o,0),data:o}))?e:""},2:function(n,a,t,l,o){var e,r=null!=a?a:n.nullContext||{},u=t.helperMissing,c=n.escapeExpression;return'      <button type="button" data-button="add"\n        class="\n        button\n        button-icon-only\n        button-add\n        "\n'+(null!=(e=(t.compare||a&&a.compare||u).call(r,null!=(e=null!=a?a.track:a)?e.thumb:e,"down",{name:"compare",hash:{},fn:n.program(3,o,0),inverse:n.noop,data:o}))?e:"")+'        data-tooltip="'+c((t.loc||a&&a.loc||u).call(r,"SaveYourMusic",{name:"loc",hash:{},data:o}))+'"\n        data-tooltip-add="'+c((t.loc||a&&a.loc||u).call(r,"SaveToYourFavoriteSongs",{name:"loc",hash:{},data:o}))+'"\n        data-tooltip-remove="'+c((t.loc||a&&a.loc||u).call(r,"RemoveFromYourFavoriteSongs",{name:"loc",hash:{},data:o}))+'"\n        data-log-click="save-button"\n        data-interaction-target="save-remove-button"\n        data-interaction-intent="save"></button>\n'},3:function(n,a,t,l,o){var e;return null!=(e=t.if.call(null!=a?a:n.nullContext||{},null!=(e=null!=a?a.track:a)?e.added:e,{name:"if",hash:{},fn:n.program(4,o,0),inverse:n.program(6,o,0),data:o}))?e:""},4:function(n,a,t,l,o){return""},6:function(n,a,t,l,o){return"                disabled\n"},8:function(n,a,t,l,o){var e,r=null!=a?a:n.nullContext||{},u=t.helperMissing,c=n.escapeExpression;return'      <button type="button" data-button="add"\n        class="\n        button\n        button-icon-only\n        button-add\n        "\n'+(null!=(e=(t.compare||a&&a.compare||u).call(r,null!=(e=null!=a?a.track:a)?e.thumb:e,"down",{name:"compare",hash:{},fn:n.program(3,o,0),inverse:n.noop,data:o}))?e:"")+'        data-tooltip="'+c((t.loc||a&&a.loc||u).call(r,"SaveYourMusic",{name:"loc",hash:{},data:o}))+'"\n        data-tooltip-add="'+c((t.loc||a&&a.loc||u).call(r,"SaveYourMusic",{name:"loc",hash:{},data:o}))+'"\n        data-tooltip-remove="'+c((t.loc||a&&a.loc||u).call(r,"RemoveYourMusic",{name:"loc",hash:{},data:o}))+'"\n        data-log-click="save-button"\n        data-interaction-target="save-remove-button"\n        data-interaction-intent="save"></button>\n'},10:function(n,a,t,l,o){var e,r=null!=a?a:n.nullContext||{},u=t.helperMissing,c=n.escapeExpression;return'    <button type="button" data-button="add"\n      class="\n      button\n      button-icon-only\n      button-add\n      "\n'+(null!=(e=(t.compare||a&&a.compare||u).call(r,null!=(e=null!=a?a.track:a)?e.thumb:e,"down",{name:"compare",hash:{},fn:n.program(11,o,0),inverse:n.noop,data:o}))?e:"")+'      data-tooltip="'+c((t.loc||a&&a.loc||u).call(r,"SaveYourMusic",{name:"loc",hash:{},data:o}))+'"\n      data-tooltip-add="'+c((t.loc||a&&a.loc||u).call(r,"SaveYourMusic",{name:"loc",hash:{},data:o}))+'"\n      data-tooltip-remove="'+c((t.loc||a&&a.loc||u).call(r,"RemoveYourMusic",{name:"loc",hash:{},data:o}))+'"\n      data-log-click="save-button"\n      data-interaction-target="save-remove-button"\n      data-interaction-intent="save"></button>\n'},11:function(n,a,t,l,o){var e;return null!=(e=t.if.call(null!=a?a:n.nullContext||{},null!=(e=null!=a?a.track:a)?e.added:e,{name:"if",hash:{},fn:n.program(4,o,0),inverse:n.program(12,o,0),data:o}))?e:""},12:function(n,a,t,l,o){return"              disabled\n"},compiler:[7,">= 4.0.0"],main:function(n,a,t,l,o){var e,r,u,c='<td class="tl-cell tl-save">\n';return r=null!=(r=t.nft||(null!=a?a.nft:a))?r:t.helperMissing,u={name:"nft",hash:{},fn:n.program(1,o,0),inverse:n.program(10,o,0),data:o},e="function"==typeof r?r.call(null!=a?a:n.nullContext||{},u):r,t.nft||(e=t.blockHelperMissing.call(a,e,u)),null!=e&&(c+=e),c+"</td>\n"},useData:!0});

},{"hbsfy/runtime":383}],147:[function(require,module,exports){
var HandlebarsCompiler=require("hbsfy/runtime");module.exports=HandlebarsCompiler.template({1:function(n,a,l,e,t){var r,o=null!=a?a:n.nullContext||{},u=l.helperMissing,i=n.escapeExpression;return'data-insert="'+i("function"==typeof(r=null!=(r=l.insertTracks||(null!=a?a.insertTracks:a))?r:u)?r.call(o,{name:"insertTracks",hash:{},data:t}):r)+'"\ndata-remove="'+i("function"==typeof(r=null!=(r=l.removeTracks||(null!=a?a.removeTracks:a))?r:u)?r.call(o,{name:"removeTracks",hash:{},data:t}):r)+'"\n'},3:function(n,a,l,e,t){return'data-context="true"\n'},5:function(n,a,l,e,t){return'data-list-quick-jump="true"\n'},compiler:[7,">= 4.0.0"],main:function(n,a,l,e,t){var r,o,u,i=null!=a?a:n.nullContext||{},s=l.helperMissing,c=l.blockHelperMissing,p='data-uri="'+n.escapeExpression("function"==typeof(o=null!=(o=l.uri||(null!=a?a.uri:a))?o:s)?o.call(i,{name:"uri",hash:{},data:t}):o)+'"\ndata-list="true"\n';return o=null!=(o=l.allows||(null!=a?a.allows:a))?o:s,u={name:"allows",hash:{},fn:n.program(1,t,0),inverse:n.noop,data:t},r="function"==typeof o?o.call(i,u):o,l.allows||(r=c.call(a,r,u)),null!=r&&(p+=r),o=null!=(o=l.noContext||(null!=a?a.noContext:a))?o:s,u={name:"noContext",hash:{},fn:n.noop,inverse:n.program(3,t,0),data:t},r="function"==typeof o?o.call(i,u):o,l.noContext||(r=c.call(a,r,u)),null!=r&&(p+=r),p+(null!=(r=l.if.call(i,null!=a?a.quickJump:a,{name:"if",hash:{},fn:n.program(5,t,0),inverse:n.noop,data:t}))?r:"")+'data-interaction-context="tracklist"\ndata-ta-id="tracklist"\n'},useData:!0});

},{"hbsfy/runtime":383}],148:[function(require,module,exports){
var HandlebarsCompiler=require("hbsfy/runtime");module.exports=HandlebarsCompiler.template({compiler:[7,">= 4.0.0"],main:function(e,r,a,t,n){return'data-list-items="true"\ndata-scroll-container\n'},useData:!0});

},{"hbsfy/runtime":383}],149:[function(require,module,exports){
var HandlebarsCompiler=require("hbsfy/runtime");module.exports=HandlebarsCompiler.template({1:function(n,l,a,t,o){var e=null!=l?l:n.nullContext||{},r=a.helperMissing,s=n.escapeExpression;return'    data-tooltip="'+s((a.loc||l&&l.loc||r).call(e,"nft.ban_song_label",{name:"loc",hash:{},data:o}))+'"\n    aria-label="'+s((a.loc||l&&l.loc||r).call(e,"nft.ban_song_label",{name:"loc",hash:{},data:o}))+'"\n'},3:function(n,l,a,t,o){var e=null!=l?l:n.nullContext||{},r=a.helperMissing,s=n.escapeExpression;return'    data-tooltip="'+s((a.loc||l&&l.loc||r).call(e,"ban_song_label",{name:"loc",hash:{},data:o}))+'"\n    aria-label="'+s((a.loc||l&&l.loc||r).call(e,"ban_song_label",{name:"loc",hash:{},data:o}))+'"\n'},compiler:[7,">= 4.0.0"],main:function(n,l,a,t,o){var e,r,s,u='<button\n  type="button"\n  data-button="thumbs-down"\n  class="button button-icon-only button-thumbs-down"\n  data-log-click="thumbs-down-button"\n';return r=null!=(r=a.nft||(null!=l?l.nft:l))?r:a.helperMissing,s={name:"nft",hash:{},fn:n.program(1,o,0),inverse:n.program(3,o,0),data:o},e="function"==typeof r?r.call(null!=l?l:n.nullContext||{},s):r,a.nft||(e=a.blockHelperMissing.call(l,e,s)),null!=e&&(u+=e),u+'  data-log-data=\'{ "target_uri": "'+n.escapeExpression(n.lambda(null!=(e=null!=l?l.track:l)?e.uri:e,l))+"\" }'></button>\n"},useData:!0});

},{"hbsfy/runtime":383}],150:[function(require,module,exports){
var HandlebarsCompiler=require("hbsfy/runtime");module.exports=HandlebarsCompiler.template({compiler:[7,">= 4.0.0"],main:function(t,n,a,u,e){var o;return'<button\n  type="button"\n  data-button="thumbs-up"\n  class="button button-icon-only button-thumbs-up"\n  data-log-click="thumbs-up-button"\n  data-log-data=\'{ "target_uri": "'+t.escapeExpression(t.lambda(null!=(o=null!=n?n.track:n)?o.uri:o,n))+"\" }'></button>\n"},useData:!0});

},{"hbsfy/runtime":383}],151:[function(require,module,exports){
var HandlebarsCompiler=require("hbsfy/runtime");module.exports=HandlebarsCompiler.template({compiler:[7,">= 4.0.0"],main:function(l,a,e,n,t){var i;return'<td class="tl-cell tl-time" data-log-context="time-cell">\n  <div class="tl-cell__fixed-height">\n    <span data-log-click="duration">'+l.escapeExpression((e.duration||a&&a.duration||e.helperMissing).call(null!=a?a:l.nullContext||{},null!=(i=null!=a?a.track:a)?i.duration:i,{name:"duration",hash:{},data:t}))+"</span>\n  </div>\n</td>\n"},useData:!0});

},{"hbsfy/runtime":383}],152:[function(require,module,exports){
var HandlebarsCompiler=require("hbsfy/runtime");module.exports=HandlebarsCompiler.template({1:function(n,t,a,l,o){return'      <span class="spoticon-video-16"></span>\n'},3:function(n,t,a,l,o){return'      <span class="spoticon-track-16"></span>\n'},compiler:[7,">= 4.0.0"],main:function(n,t,a,l,o){var e;return'<td class="tl-cell tl-type">\n  <button\n    type="button"\n    data-button="play"\n    class="button button-icon-with-stroke button-play"\n    data-log-click="play-button"></button>\n\n  <div class="tl-type__icon">\n'+(null!=(e=a.if.call(null!=t?t:n.nullContext||{},null!=(e=null!=t?t.track:t)?e.isVideo:e,{name:"if",hash:{},fn:n.program(1,o,0),inverse:n.program(3,o,0),data:o}))?e:"")+"  </div>\n</td>\n"},useData:!0});

},{"hbsfy/runtime":383}],153:[function(require,module,exports){
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=spFetch;var _getToken=require("./get-token"),_getWebgateHeaders=require("./get-webgate-headers");function spFetch(e,t={headers:new Headers}){return(0,_getToken.getToken)().then(({accessToken:r,tokenType:a})=>{const n=`${a} ${r}`;let s=[];return 0===("string"==typeof e?e:e.url).indexOf("https://spclient")&&(s=(0,_getWebgateHeaders.getWebgateHeaders)()),t.headers instanceof Headers?(t.headers.append("Authorization",n),s.forEach(function(e){t.headers.append(e[0],e[1])})):(t.headers.Authorization=n,s.forEach(function(e){t.headers[e[0]]=e[1]})),fetch(e,t)})}

},{"./get-token":154,"./get-webgate-headers":155}],154:[function(require,module,exports){
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.getToken=getToken;var _cosmosApi=require("../cosmos-api"),_cosmosApi2=_interopRequireDefault(_cosmosApi),_debug=require("../debug"),_debug2=_interopRequireDefault(_debug);function _interopRequireDefault(e){return e&&e.__esModule?e:{default:e}}const debug=(0,_debug2.default)("http-requests:get-token");function getToken(){return new Promise((e,o)=>{_cosmosApi2.default.resolver.get("sp://webgate/v1/token",(t,r)=>{if(t)return debug("Error retrieving token from keymaster:",t),void o(t);const s=r.getJSONBody();if(s&&s.accessToken&&s.tokenType)return debug("Retrieved access token, valid until: %s",new Date(s.expiresAtTime)),void e({accessToken:s.accessToken,tokenType:s.tokenType});const n="Error: missing accessToken or tokenType";debug(n,s),o(new Error(n))})})}

},{"../cosmos-api":45,"../debug":52}],155:[function(require,module,exports){
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports._setHeaders=_setHeaders,exports.getWebgateHeaders=getWebgateHeaders;const SPOTIFY_APP_VERSION_KEY="Spotify-App-Version",APP_PLATFORM_KEY="App-Platform";let SPOTIFY_APP_VERSION="undefined"!=typeof window&&window.__spotify&&window.__spotify.client_version||"";const RAW_PLATFORM="undefined"!=typeof window&&window.navigator&&window.navigator.platform||"";let APP_PLATFORM="";function getSpotifyAppVersion(){if(!SPOTIFY_APP_VERSION)throw new Error("Missing Spotify App Version! Something is wrong: talk to #desktop-squad.");return[SPOTIFY_APP_VERSION_KEY,SPOTIFY_APP_VERSION]}function getAppPlatform(){if(!APP_PLATFORM)throw new Error("Missing App Platform! Something is wrong: talk to #desktop-squad.");return[APP_PLATFORM_KEY,APP_PLATFORM]}-1!==RAW_PLATFORM.indexOf("Mac")?APP_PLATFORM="OSX":-1!==RAW_PLATFORM.indexOf("Win")?APP_PLATFORM="Win32":-1!==RAW_PLATFORM.indexOf("Linux")&&(APP_PLATFORM="Linux");const DEFAULT_HEADER_VALUE="default",DEFAULT_HEADERS={};function _setHeaders(e=DEFAULT_HEADERS){SPOTIFY_APP_VERSION=e[SPOTIFY_APP_VERSION_KEY],APP_PLATFORM=e[APP_PLATFORM_KEY]}function getWebgateHeaders(){return[getSpotifyAppVersion(),getAppPlatform()]}DEFAULT_HEADERS[SPOTIFY_APP_VERSION_KEY]="default",DEFAULT_HEADERS[APP_PLATFORM_KEY]="default";

},{}],156:[function(require,module,exports){
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.httpMockHelper=exports.addWebgateHeaders=exports.addToken=exports.spFetch=void 0;var _fetch=require("./fetch.js"),_fetch2=_interopRequireDefault(_fetch),_xhr=require("./xhr.js"),_mockHelper=require("./util/mock-helper.js"),httpMockHelper=_interopRequireWildcard(_mockHelper);function _interopRequireWildcard(e){if(e&&e.__esModule)return e;var r={};if(null!=e)for(var t in e)Object.prototype.hasOwnProperty.call(e,t)&&(r[t]=e[t]);return r.default=e,r}function _interopRequireDefault(e){return e&&e.__esModule?e:{default:e}}exports.spFetch=_fetch2.default,exports.addToken=_xhr.addToken,exports.addWebgateHeaders=_xhr.addWebgateHeaders,exports.httpMockHelper=httpMockHelper;

},{"./fetch.js":153,"./util/mock-helper.js":157,"./xhr.js":158}],157:[function(require,module,exports){
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.mockTokenRequest=mockTokenRequest,exports.restoreTokenRequest=restoreTokenRequest;var _getToken=require("../get-token"),getTokenSingleton=_interopRequireWildcard(_getToken),_getWebgateHeaders=require("../get-webgate-headers");function _interopRequireWildcard(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var o in e)Object.prototype.hasOwnProperty.call(e,o)&&(t[o]=e[o]);return t.default=e,t}const originalGetToken=getTokenSingleton.getToken,proxiedGetToken=function(){return Promise.resolve({accessToken:"at",tokenType:"tt"})};function mockTokenRequest(e=proxiedGetToken){return(0,_getWebgateHeaders._setHeaders)(),getTokenSingleton.getToken=e,getTokenSingleton.restore=restoreTokenRequest,getTokenSingleton}function restoreTokenRequest(){getTokenSingleton.get=originalGetToken}

},{"../get-token":154,"../get-webgate-headers":155}],158:[function(require,module,exports){
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.addToken=addToken,exports.addWebgateHeaders=addWebgateHeaders;var _getToken=require("./get-token"),_getWebgateHeaders=require("./get-webgate-headers");function addToken(e){if(!e||!e.setRequestHeader)throw new Error("Expected argument to be an XMLHttpRequest");return(0,_getToken.getToken)().then(({accessToken:t,tokenType:r})=>(e.setRequestHeader("Authorization",`${r} ${t}`),e))}function addWebgateHeaders(e){if(!e||!e.setRequestHeader)throw new Error("Expected argument to be an XMLHttpRequest");return(0,_getWebgateHeaders.getWebgateHeaders)().forEach(t=>{e.setRequestHeader(t[0],t[1])}),e}

},{"./get-token":154,"./get-webgate-headers":155}],159:[function(require,module,exports){
"use strict";const base="spotify:internal:filterlist",regExp=/^spotify:internal:filterlist:([^:]*):(.*)$/;exports.create=function(t,e){const r=t.replace(/^spotify:/,""),n=encodeURIComponent(e);return[base,n,r].join(":")},exports.getQuery=function(t){const e=t.match(regExp);return e?decodeURIComponent(e[1]):""},exports.getOriginUri=function(t){const e=t.match(regExp);return e?`spotify:${e[2]}`:""},exports.parse=function(t){const e=t.match(regExp);return e?{query:decodeURIComponent(e[1]),originUri:`spotify:${e[2]}`}:null},exports.isValid=function(t){return regExp.test(t)},exports.regExp=regExp;

},{}],160:[function(require,module,exports){
"use strict";const Range=require("../range2");function getInsertOperations(e,t){return[{type:"insert",index:t,values:e}]}function getRemoveOperations(e){const t=Range.fromIndices(e);let n=0;const r=[];for(let e,s=0;t[s];s++)e=t[s],r.push({type:"remove",index:e.start-n,length:e.length}),n+=e.length;return r}function getMoveOperations(e,t){let n=0,r=t;const s=Range.fromIndices(e);let o,a,i;for(o=0;s[o];o++)if((a=s[o]).start<=t&&a.end>=t){i=a;break}const g=[];for(o=0;s[o];o++){const e=(a=s[o]).length;let p,c=a.start-n;if(i)if(a.end<i.start)c=a.start-n,p=i.start-e,n+=e;else{if(a===i){r=Math.max(r,a.end);continue}c=a.start,p=r,r=Math.max(r,p+e)}else a.end<t?(c=a.start-n,p=r-e,n+=e):(c=a.start,p=r,r=Math.max(r,p+e));g.push({type:"move",from:c,length:e,to:p})}return g}exports.getInsertOperations=getInsertOperations,exports.getRemoveOperations=getRemoveOperations,exports.getMoveOperations=getMoveOperations;

},{"../range2":229}],161:[function(require,module,exports){
(function (global){
"use strict";const live=require("../../live"),cosmos=require("../util/cosmos"),Collection=require("./collection"),liburi=require("spotify-liburi"),endpoints={isInCollection:"sp://core-collection/v1/contains",updateIsInCollection:"sp://core-collection/v1/items",broadcast:"sp://messages/v1/collectionstate",pubsub:"hm://collection/collection/@/json"},onCollectionPublish=function(o,e){o?global.console&&console.error(o):live(e.body.items.filter(({type:o=""})=>"ALBUM"===o.toUpperCase()).map(({identifier:o,removed:e})=>({uri:liburi.albumURI(o).toURI(),added:!e})))};let albumCollection,broadcastSubscription,collectionSubscription;const regExp=exports.matches=/^spotify:album:[^:]+$/;let registered=!1;exports.register=function(){registered||(registered=!0,albumCollection=new Collection(endpoints),live.subscribe(regExp,"publish",albumCollection.onPublish),live.subscribe(regExp,"wait",albumCollection.onWait),broadcastSubscription=cosmos.subscribe({url:endpoints.broadcast},Collection.onBroadcast),collectionSubscription=cosmos.subscribe({url:endpoints.pubsub},onCollectionPublish))},exports.unregister=function(){registered&&(registered=!1,live.unsubscribe(regExp,"publish",albumCollection.onPublish),live.unsubscribe(regExp,"wait",albumCollection.onWait),albumCollection=null,broadcastSubscription&&(broadcastSubscription.cancel(),broadcastSubscription=null),collectionSubscription&&(collectionSubscription.cancel(),collectionSubscription=null))},exports._endpoints=endpoints;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../live":192,"../util/cosmos":188,"./collection":163,"spotify-liburi":475}],162:[function(require,module,exports){
"use strict";const profile=require("./profile"),regExp=exports.matches=/^spotify:artist:/;let registered;exports.register=function(){registered||(registered=!0,profile.register(regExp))},exports.unregister=function(){registered&&(registered=!1,profile.unregister(regExp))};

},{"./profile":167}],163:[function(require,module,exports){
(function (global){
"use strict";const prime=require("../../../libs/prime"),defer=require("../../../libs/prime/defer"),live=require("../../live"),contains=require("mout/array/contains"),cosmos=require("../util/cosmos"),INSUFFICIENT_STORAGE=507,Collection=prime({constructor:function(o){this.endpoints=o,this.onPublish=this.onPublish.bind(this),this.waitQueue=[],this.onWait=this.onWait.bind(this),this.fetch=this.fetch.bind(this)},onPublish:function(o,t){if("added"in t){const e=this.endpoints,i=!!t.added;o.update({added:i});const s=i?"post":"delete";this._publish(s,[o],function(t,s){t?(o.update({added:!i}),t.response&&507===t.response.getStatusCode()&&cosmos.post({url:"sp://messages/v1/container/user-message",body:{id:"collection-limit-exceeded"}})):(cosmos.post({url:e.broadcast,body:{uri:o.uri,isInCollection:i,added:i}}),s&&s.items&&s.items.forEach(function(o){o.added=o.isInCollection,cosmos.post({url:e.broadcast,body:o})}))})}},onWait:function(o,t){contains(t,"added")&&this.fetch(o)},fetch:function(o){const t=this.waitQueue;t.push(o),1===t.length&&defer.immediate(this._fetchBatch,this)},_fetchBatch:function(){const o=this.waitQueue;0!==o.length&&(this.waitQueue=[],this._contains(o,function(t,e){t&&(!t.response||t.response&&404!==t.response.getStatusCode())?global.console&&console.error(t):o.forEach(function(o,i){let s=!1;t||(s=e[i]),o.update({added:s})})}))},_contains:function(o,t){const e=this.endpoints.isInCollection,i=this._getRequestBody(o);cosmos.post({url:e,body:i},function(o,e){t(o,e&&e.body&&e.body.found)})},_publish:function(o,t,e){const i=this.endpoints.updateIsInCollection,s=this._getRequestBody(t);cosmos[o]({url:i,body:s},function(o,t){e(o,t&&t.body)})},_getRequestBody:function(o){return{items:o.map(function(o){return o.uri}),source:global.__spotify&&global.__spotify.app_uri||null}}});Collection.onBroadcast=function(o,t){if(o)return void(global.console&&console.error(o));let e;"added"in t.body?e=t.body.added:"isInCollection"in t.body&&(e=t.body.isInCollection),live(t.body.uri).update({added:e})},module.exports=Collection;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../../libs/prime":227,"../../../libs/prime/defer":225,"../../live":192,"../util/cosmos":188,"mout/array/contains":410}],164:[function(require,module,exports){
"use strict";const album=require("./album"),artist=require("./artist"),playlist=require("./playlist"),track=require("./track"),user=require("./user"),local=require("./local"),show=require("./show");exports.register=function(){album.register(),artist.register(),playlist.register(),track.register(),user.register(),local.register(),show.register()},exports.unregister=function(){album.unregister(),artist.unregister(),playlist.unregister(),track.unregister(),user.unregister(),local.unregister(),show.unregister()};

},{"./album":161,"./artist":162,"./local":165,"./playlist":166,"./show":168,"./track":169,"./user":170}],165:[function(require,module,exports){
"use strict";const live=require("../../live"),contains=require("mout/array/contains"),onWait=function(e,t){contains(t,"added")&&e.update({added:!1})},regExp=exports.matches=/^spotify:local:[^:]*:[^:]*:[^:]*:\d*$|^spotify:local:[^:]*:[^:]*$|^spotify:local:[^:]*$/;let registered=!1;exports.register=function(){registered||(registered=!0,live.subscribe(regExp,"wait",onWait))},exports.unregister=function(){registered&&(registered=!1,live.unsubscribe(regExp,"wait",onWait))};

},{"../../live":192,"mout/array/contains":410}],166:[function(require,module,exports){
(function (global){
"use strict";var _playlistUtils=require("../../../libs/playlist-utils"),_playlistUtils2=_interopRequireDefault(_playlistUtils);function _interopRequireDefault(e){return e&&e.__esModule?e:{default:e}}const contains=require("mout/array/contains"),live=require("../../live"),cosmos=require("../util/cosmos"),endpoints={broadcast:"sp://messages/v1/followstate"};function onPublish(e,o){if("added"in o){e.update({added:o.added}),null!==e.get("followersCount")&&e.update({followersCount:e.get("followersCount")+(o.added?1:-1)}),(o.added?_playlistUtils2.default.followPlaylist:_playlistUtils2.default.removePlaylist)(e.uri,t=>{t&&(e.update({added:!o.added}),null!==e.get("followersCount")&&e.update({followersCount:e.get("followersCount")+(o.added?-1:1)}))})}}function onBroadcast(e,o){if(e)return void(global.console&&console.error(e));let t;"added"in o.body?t=o.body.added:"isFollowing"in o.body&&(t=o.body.isFollowing),void 0!==t&&live(o.body.uri).update({added:t})}function fetchAdded(e){cosmos.get({url:`sp://core-playlist/v1/playlist/${encodeURIComponent(e.uri)}/metadata`,body:{policy:{followed:!0}}},function(o,t){o?global.console&&console.error(o):e.update({added:t.body.metadata.followed})})}function fetchFollowersCount(e){cosmos.get({url:`sp://core-playlist/v1/playlist/${encodeURIComponent(e.uri)}/metadata`,body:{policy:{followers:!0}}},function(o,t){o?global.console&&console.error(o):e.update({followersCount:t.body.metadata.followers})})}const onWait=function(e,o){const t=contains(o,"added"),l=contains(o,"followersCount");if(t){const o=e.get("subscribed");void 0!==o?e.update({added:o}):fetchAdded(e)}l&&fetchFollowersCount(e)},regExp=exports.matches=/^spotify:(user:[^:]+:)?playlist:[^:]+$/;let broadcastSubscription,registered;exports.register=function(){registered||(registered=!0,live.subscribe(regExp,"publish",onPublish),live.subscribe(regExp,"wait",onWait),broadcastSubscription=cosmos.subscribe({url:endpoints.broadcast},onBroadcast))},exports.unregister=function(){registered&&(registered=!1,live.unsubscribe(regExp,"publish",onPublish),live.unsubscribe(regExp,"wait",onWait),broadcastSubscription.cancel(),broadcastSubscription=null)};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../../libs/playlist-utils":221,"../../live":192,"../util/cosmos":188,"mout/array/contains":410}],167:[function(require,module,exports){
(function (global){
"use strict";const intersection=require("mout/array/intersection"),live=require("../../live"),cosmos=require("../util/cosmos");let requestsInProgress={};const endpoints={isFollowing:"hm://socialgraph/v2/is_following?format=json",followCounts:"hm://socialgraph/v2/counts?format=json",updateIsFollowing:"hm://socialgraph/v2/following?format=json",broadcast:"sp://messages/v1/followstate"};function onUpdate(o,e){if("added"in e&&!("followersCount"in e)){const n=o.get("followersCount");if(void 0!==n){const t=n+(e.added?1:-1);o.update({followersCount:t})}}}function onPublish(o,e){if("added"in e){if(requestsInProgress[o.uri])return;requestsInProgress[o.uri]=!0,o.update({added:e.added}),updateBackend(o,!!e.added,function(n){delete requestsInProgress[o.uri],n?o.update({added:!e.added}):(o.update({added:e.added}),broadcast(o))})}}function onBroadcast(o,e){if(o)return void(global.console&&console.error(o));const n=e.body,t={};"added"in n?t.added=n.added:"isFollowing"in n&&(t.added=n.isFollowing),"followersCount"in n&&(t.followersCount=n.followersCount),"followingCount"in n&&(t.followingCount=n.followingCount),live(n.uri).update(t)}const followProperties=["added","followersCount","followingCount"];function onWait(o,e){intersection(e,followProperties).length&&getRequestData(o,function(e,n){e?global.console&&console.error(e):(updateIsFollowing(o,n),updateCounts(o,n))})}function updateIsFollowing(o,e,n){const t={url:endpoints.isFollowing,body:e};cosmos.get(t,function(e,t){if(e)global.console&&console.error(e),n&&n(e);else{const e=t.body[0].is_following;o.update({added:e}),n&&n()}})}function updateCounts(o,e,n){const t={url:endpoints.followCounts,body:e};cosmos.get(t,function(e,t){if(e)global.console&&console.error(e),n&&n(e);else{const e=t.body[0];o.update({followersCount:e.followers_count,followingCount:e.following_count}),n&&n()}})}function getRequestData(o,e){live("spotify:client").query("currentUser(uri)",function(n,t){n?e(n):e(null,{source_uri:decodeURIComponent(t.currentUser.uri),target_uris:[decodeURIComponent(o.uri)]})})}function updateBackend(o,e,n){getRequestData(o,function(o,t){if(o)n(o);else{cosmos[e?"post":"delete"]({url:endpoints.updateIsFollowing,body:t},function(o){n(o||null)})}})}function broadcast(o){const e=o.get("added");cosmos.post({url:endpoints.broadcast,body:{uri:o.uri,isFollowing:e,added:e,followersCount:o.get("followersCount"),followingCount:o.get("followingCount")}})}let broadcastSubscription;exports.register=function(o){live.subscribe(o,"wait",onWait),live.subscribe(o,"update",onUpdate),live.subscribe(o,"publish",onPublish),requestsInProgress={},broadcastSubscription||(broadcastSubscription=cosmos.subscribe({url:endpoints.broadcast},onBroadcast))},exports.unregister=function(o){live.unsubscribe(o,"wait",onWait),live.unsubscribe(o,"update",onUpdate),live.unsubscribe(o,"publish",onPublish),broadcastSubscription&&(broadcastSubscription.cancel(),broadcastSubscription=null)};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../live":192,"../util/cosmos":188,"mout/array/intersection":417}],168:[function(require,module,exports){
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.register=register,exports.unregister=unregister;var _live=require("../../live"),_live2=_interopRequireDefault(_live),_collection=require("./collection"),_collection2=_interopRequireDefault(_collection);function _interopRequireDefault(e){return e&&e.__esModule?e:{default:e}}const regExp=/^spotify:show:[^:]+$/;let showCollection,registered=!1;function register(){registered||(registered=!0,showCollection=new _collection2.default({isInCollection:"sp://core-collection/v1/contains",updateIsInCollection:"sp://core-collection/v1/items",broadcast:"sp://messages/v1/collectionstate",pubsub:"hm://collection/collection/@/json"}),_live2.default.subscribe(regExp,"publish",showCollection.onPublish),_live2.default.subscribe(regExp,"wait",showCollection.onWait))}function unregister(){registered&&(registered=!1,_live2.default.unsubscribe(regExp,"publish",showCollection.onPublish),_live2.default.unsubscribe(regExp,"wait",showCollection.onWait))}

},{"../../live":192,"./collection":163}],169:[function(require,module,exports){
(function (global){
"use strict";const live=require("../../live"),cosmos=require("../util/cosmos"),Collection=require("./collection"),liburi=require("spotify-liburi"),endpoints={isInCollection:"sp://core-collection/v1/contains",updateIsInCollection:"sp://core-collection/v1/items",broadcast:"sp://messages/v1/collectionstate",pubsub:"hm://collection/collection/@/json"},onCollectionPublish=function(o,e){o?global.console&&console.error(o):live(e.body.items.filter(({type:o=""})=>"TRACK"===o.toUpperCase()).map(({identifier:o,removed:e})=>({uri:liburi.trackURI(o).toURI(),added:!e})))};let trackCollection,broadcastSubscription,collectionSubscription;const regExp=exports.matches=/^spotify:track:[^:]+$/;let registered=!1;exports.register=function(){registered||(registered=!0,trackCollection=new Collection(endpoints),live.subscribe(regExp,"publish",trackCollection.onPublish),live.subscribe(regExp,"wait",trackCollection.onWait),broadcastSubscription=cosmos.subscribe({url:endpoints.broadcast},Collection.onBroadcast),collectionSubscription=cosmos.subscribe({url:endpoints.pubsub},onCollectionPublish))},exports.unregister=function(){registered&&(registered=!1,live.unsubscribe(regExp,"publish",trackCollection.onPublish),live.unsubscribe(regExp,"wait",trackCollection.onWait),trackCollection=null,broadcastSubscription&&(broadcastSubscription.cancel(),broadcastSubscription=null),collectionSubscription&&(collectionSubscription.cancel(),collectionSubscription=null))},exports._endpoints=endpoints;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../live":192,"../util/cosmos":188,"./collection":163,"spotify-liburi":475}],170:[function(require,module,exports){
"use strict";const profile=require("./profile"),regExp=exports.matches=/^spotify:user:[^:]+$/;let registered;exports.register=function(){registered||(registered=!0,profile.register(regExp))},exports.unregister=function(){registered&&(registered=!1,profile.unregister(regExp))};

},{"./profile":167}],171:[function(require,module,exports){
(function (global){
"use strict";var _getLocationHref=require("./util/get-location-href"),_getLocationHref2=_interopRequireDefault(_getLocationHref);function _interopRequireDefault(e){return e&&e.__esModule?e:{default:e}}const live=require("../live"),AppState=require("../navigation/app-state");function onMessage(e){e.data&&e.data.name&&("set_active"===e.data.name?live("spotify:application").update({active:e.data.active}):"set_arguments"===e.data.name?live("spotify:application").update({arguments:e.data.arguments.join(":")}):"set_state"===e.data.name&&live("spotify:application").update({state:AppState.unserialize(e.data.state)}))}function onRegister(e){e.update({version:global.__spotify&&global.__spotify.app_version||"0.0.0"});const t=new URL((0,_getLocationHref2.default)());if(t.hostname.length>0){const a=/^([a-zA-Z-]+)\.app\.spotify\.com$/,i=t.hostname.match(a);2===i.length&&e.update({appURI:`spotify:app:${i[1]}`,arguments:t.searchParams.get("param")||"",active:!0})}}let registered;exports.matches=/^spotify:application$/,exports.register=function(){registered||(registered=!0,global.addEventListener("message",onMessage),onRegister(live("spotify:application")))},exports.unregister=function(){registered&&(registered=!1,global.removeEventListener("message",onMessage))};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../live":192,"../navigation/app-state":210,"./util/get-location-href":189}],172:[function(require,module,exports){
(function (global){
"use strict";const live=require("../live"),bridge=require("./util/bridge").request,liburi=require("spotify-liburi"),BACKOFF=100;function updateCurrentUser(e){const t=global.__spotify&&global.__spotify.username,i=liburi.profileURI(t).toURI();bridge("user_metadata",[i],function(o,s){if(o)return t&&e.update({currentUser:{uri:i,username:t}}),void(global.console&&console.error(o));e.update({currentUser:{uri:i,name:s.name,username:s.username}})})}function updateSessionData(e){bridge("session_query",[],function(t,i){t?global.console&&console.error(t):(void 0===i.employee&&(global.__spotify&&global.__spotify.product_state&&global.__spotify.product_state.employee?i.employee="1"===global.__spotify.product_state.employee:i.employee=!1),e.update({session:i}),bridgeWaitSession(e))})}let registered;function bridgeWaitSession(e){bridge("session_event_wait",[],function(t,i){if(registered){if(t)return setTimeout(function(){bridgeWaitSession(e)},BACKOFF),void(global.console&&console.error(t));"change"===i.type&&e.get("session").update(i.data),bridgeWaitSession(e)}})}function showContextMenu(e,t){global===window&&window.top&&window.top.postMessage&&window.top.postMessage({type:"client_show_context_ui",data:t},"*")}function onWait(e,t){t.indexOf("currentUser")>-1&&updateCurrentUser(e),t.indexOf("session")>-1&&updateSessionData(e)}function onInit(e){const t=global.__spotify||{},i=live(t.container_features||{});if(i.on("wait",function(e){const t={};for(let i=0;i<e.length;i++){t[e[i]]=!1}i.update(t)}),e.update({containerFeatures:i}),global.__spotify&&global.__spotify.username){const t=global.__spotify.username;e.update({currentUser:{uri:liburi.profileURI(t).toURI(),username:t}})}updateCurrentUser(e)}const regExp=exports.matches=/^spotify:client$/;exports.register=function(){registered||(registered=!0,live.subscribe(regExp,"wait",onWait),live.subscribe(regExp,"init",onInit),live.subscribe(regExp,"show-context-menu",showContextMenu))},exports.unregister=function(){registered&&(registered=!1,live.unsubscribe(regExp,"wait",onWait),live.unsubscribe(regExp,"init",onInit),live.unsubscribe(regExp,"show-context-menu",showContextMenu))};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../live":192,"./util/bridge":187,"spotify-liburi":475}],173:[function(require,module,exports){
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.play=play;const cosmos=require("../util/cosmos"),liburi=require("spotify-liburi");function play(e,r,i){const s=liburi.from(e),t={url:`sp://core-collection/unstable/@/list/tracks/${{[liburi.Type.COLLECTION_ALBUM]:"album",[liburi.Type.COLLECTION_ARTIST]:"artist"}[s.type]}/${s.getBase62Id()}/play?sort=${{[liburi.Type.COLLECTION_ALBUM]:"discNumber,trackNumber",[liburi.Type.COLLECTION_ARTIST]:"addTime DESC,discNumber,trackNumber"}[s.type]}`};r&&(t.body=r),cosmos.post(t,i)}

},{"../util/cosmos":188,"spotify-liburi":475}],174:[function(require,module,exports){
(function (global){
"use strict";var _liveWrappedUri=require("../../live-wrapped-uri"),_liveWrappedUri2=_interopRequireDefault(_liveWrappedUri),_cosmosPlayer=require("./cosmos-player"),_cosmosPlayer2=_interopRequireDefault(_cosmosPlayer),_playerApi=require("./player-api"),_playerApi2=_interopRequireDefault(_playerApi),_playlistResolver=require("./playlist-resolver"),playlistResolver=_interopRequireWildcard(_playlistResolver),_collectionResolver=require("./collection-resolver"),collectionResolver=_interopRequireWildcard(_collectionResolver),_data=require("./data"),_data2=_interopRequireDefault(_data);function _interopRequireWildcard(e){if(e&&e.__esModule)return e;var r={};if(null!=e)for(var t in e)Object.prototype.hasOwnProperty.call(e,t)&&(r[t]=e[t]);return r.default=e,r}function _interopRequireDefault(e){return e&&e.__esModule?e:{default:e}}function playTrackUris(e,r,t){_playerApi2.default.play(e,r,t)}function playFromResolver(e,r,t){_playerApi2.default.playFromResolver(e,r,t)}function playContext(e,r,t){_playerApi2.default.playContext(e,r,t)}function updateContext(e,r){_playerApi2.default.updateContext(e,r)}function playFromPlaylistResolver(e,r,t){const i={};r.uids?i.track_uid=r.uids[0]:r.uid&&(i.track_uid=r.uid),r.uris?i.track_uri=r.uris[0]:r.trackUri&&(i.track_uri=r.trackUri);const o={};Object.keys(i).length&&(o.skip_to_index=i);const l={prepare_play_options:o,play_origin:{view_uri:_liveWrappedUri2.default.getOriginUri(r.context)||r.context,feature_identifier:r.source,referrer_identifier:r.referrerId,feature_version:r.referrerVersion}};playlistResolver.play(e,l,t)}function playFromCollectionResolver(e,r,t){const i={view_uri:_liveWrappedUri2.default.getOriginUri(r.context)||r.context,feature_identifier:r.source,referrer_identifier:r.referrerId,feature_version:r.referrerVersion},o={};null!==r.index&&(o.skip_to={track_index:r.index});const l={prepare_play_options:o,play_origin:i};collectionResolver.play(e,l,t)}function playTrack(e,r,t){r.context=e,r.track=e,r.index=0,playTrackUris([{uri:e}],r,t)}function playRows(e,r,t){const{index:i,range:o}=r;if(null===i&&o)_data2.default.getFirstPlayableRow(e,o,(i,o)=>{if(i)global.console&&console.error(i),t&&t(i);else{const i=_data2.default.getTracksFromRows(e);r.index=o,playTrackUris(i,r,t)}});else{playTrackUris(_data2.default.getTracksFromRows(e),r,t)}}function playFromArtist(e,r,t){playFromResolver(e,r,t)}function updateWithRows(e,r,t){const i=_data2.default.getTracksFromRows(e);delete r.index,_playerApi2.default.update(i,r,t)}function pause(e){_playerApi2.default.pause(e)}function resume(e){_playerApi2.default.resume(e)}function skipPrev(e){_cosmosPlayer2.default.skipPrev(e)}function skipNext(e){_cosmosPlayer2.default.skipNext(e)}exports.playTrack=playTrack,exports.playRows=playRows,exports.playFromResolver=playFromResolver,exports.playContext=playContext,exports.playFromArtist=playFromArtist,exports.updateContext=updateContext,exports.updateWithRows=updateWithRows,exports.pause=pause,exports.resume=resume,exports.skipPrev=skipPrev,exports.skipNext=skipNext,exports.playFromPlaylistResolver=playFromPlaylistResolver,exports.playFromCollectionResolver=playFromCollectionResolver;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../live-wrapped-uri":191,"./collection-resolver":173,"./cosmos-player":175,"./data":176,"./player-api":178,"./playlist-resolver":179}],175:[function(require,module,exports){
"use strict";const cosmos=require("../util/cosmos"),PLAYER_URI="sp://player/v2/main",ACTIONS={PLAY:"play",PAUSE:"pause",RESUME:"resume",UPDATE:"update",SKIP_PREV:"skip_prev",SKIP_NEXT:"skip_next"};function pause(s){cosmos.post({url:PLAYER_URI,body:{action:ACTIONS.PAUSE}},s)}function resume(s){cosmos.post({url:PLAYER_URI,body:{action:ACTIONS.RESUME}},s)}function skipPrev(s){cosmos.post({url:PLAYER_URI,body:{action:ACTIONS.SKIP_PREV}},s)}function skipNext(s){cosmos.post({url:PLAYER_URI,body:{action:ACTIONS.SKIP_NEXT}},s)}function getState(s){cosmos.get({url:PLAYER_URI},function(e,o){e?s(e):s(null,o.body)})}function subscribe(s){let e=cosmos.subscribe({url:PLAYER_URI},function(e,o){e?s(e):s(null,o.body)});return{unsubscribe:function(){e&&(e.cancel(),e=null)}}}exports.pause=pause,exports.resume=resume,exports.skipPrev=skipPrev,exports.skipNext=skipNext,exports.getState=getState,exports.subscribe=subscribe;

},{"../util/cosmos":188}],176:[function(require,module,exports){
(function (global){
"use strict";const live=require("../../live"),Range=require("../../range2"),playerApi=require("./player-api"),PLAY_OPTIONS_DEFAULTS={page:null,uid:null,trackUri:null,index:null,source:"unknown",reason:"unknown"};function getFirstPlayableRow(e,r,t){let i=r.start;isRowPlayable(e.get(i),function a(n,l){l?t(null,i):i===r.end-1?t(null,r.start):isRowPlayable(e.get(++i),a)})}function isRowPlayable(e,r){e?e.query("track(playable)",function(e,t){e?r(e):r(null,t.track.playable)},live.ASAP):r(null,!1)}function getPlayOptions(e,r){getReferrer(e,function(t,i,a,n){t?r(t):(Object.keys(PLAY_OPTIONS_DEFAULTS).forEach(function(r){void 0===e[r]&&(e[r]=PLAY_OPTIONS_DEFAULTS[r])}),e.range&&(e.range=new Range(e.range[0],e.range[1])),e.viewUri=i,e.referrerId=a,e.referrerVersion=getReferrerVersion(),e.featureId=n,r(null,e))})}function getTracksFromRows(e){return e.map((r,t)=>{const i=r&&r.get("track");if(i){const r=i.serialize(1),a={};return r.manifestId&&(a["media.manifest_id"]=r.manifestId),r.mediaTypeEnum&&(a["media.type"]=2===r.mediaTypeEnum?"video":"audio"),{uri:r.uri,uid:e.keys[t],metadata:a}}return null})}function getPlayerState(e){playerApi.getState(e)}function subscribeForPlayerState(e){return playerApi.subscribe(e)}function getReferrer(e,r){const t=live("spotify:player").get("referrer"),i=live("spotify:player").get("referrerBaseUri");t?(i||console.warn(`referrer field is set on the player model (${t}), but referrerBaseUri isn't`),r(null,t,i||"","")):e.viewUri&&e.referrerId?r(null,e.viewUri,e.referrerId,e.featureId):live("spotify:application").get("appURI","arguments",function(t,i,a){if(t)r(t);else{const t=e.viewUri||(a?`${i}:${a}`:i);r(null,t,i,"")}})}function getReferrerVersion(){return global.__spotify.app_version}exports.getReferrer=getReferrer,exports.getReferrerVersion=getReferrerVersion,exports.getFirstPlayableRow=getFirstPlayableRow,exports.isRowPlayable=isRowPlayable,exports.getPlayOptions=getPlayOptions,exports.getTracksFromRows=getTracksFromRows,exports.getPlayerState=getPlayerState,exports.subscribeForPlayerState=subscribeForPlayerState;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../live":192,"../../range2":229,"./player-api":178}],177:[function(require,module,exports){
(function (global){
"use strict";var _messageProxy=require("../../../libs/message-proxy");const live=require("../../live"),URI=require("spotify-liburi"),CancellationTokenSource=require("../../../libs/cancellation-token-source").default,playerApi=require("./player-api"),playbackControl=require("./control"),dataUtils=require("./data"),updatesUtils=require("./updates"),sortUriUtils=require("../../live-sort-uri"),filterUriUtils=require("../../live-filter-uri"),createStationPlayContext=require("../station/create-play-context"),createStationPlayOptions=require("../station/create-play-options"),isStationUri=require("../station").isStationUri,TYPE_TRACK="track",TYPE_ROWS="rows",TYPE_CP_RESOLVER_PLAYLIST="context-player-resolver-playlist",TYPE_CP_RESOLVER_COLLECTION="context-player-resolver-collection",TYPE_CP_CONTEXT="context-player-context",TYPE_CONTEXT_OBJECT="context-object",TYPE_STATION_CONTEXT="context-station-context",TYPE_CP_ARTIST_CONTEXT="context-player-artist",TYPE_CP_ALBUM_CONTEXT="context-player-album",TYPE_CONTEXT_EPISODE="context-episode",TYPE_CONTEXT_SHOW="context-show",cancellationTokenSource=new CancellationTokenSource,contextDataStore={};function onWait(e){updateState(e)}function onSync(e){updateState(e)}function onPlayerStateUpdate(e,t){if(e)return void(global.console&&console.error(e));const i=live("spotify:player");i.get("pending")||i.update(t)}function onUpdate(e){const t=e.get("index")&&e.get("index").get("track");null!==t&&updatesUtils.setPlayingIndex(t),updatesUtils.clean(e)}function onPlay(e,t){const i=t.context;if(!i)return;"number"!=typeof t.index&&delete t.index,cancellationTokenSource.cancel();const o=cancellationTokenSource.token();e.update(playerApi.addContext({isPlaying:!0,isPaused:!1,index:void 0===t.index?null:{page:0,track:t.index},track:void 0===t.trackUri?null:{uri:t.trackUri},contextUpdatedCrossFrame:!1},i)),dataUtils.getPlayOptions(t,function(t,i){t||!i.context?updateState(e):/^spotify:internal:/.test(i.context)?playWithOptions(e,o,i):live("spotify:list-variant").get("implemented")?live(i.context).query("listVariant(currentUri, sortUri)",function(t,a){t?updateState(e):o.isCanceled()||(i.context=a.listVariant.currentUri,playWithOptions(e,o,i))}):playWithOptions(e,o,i)})}function onPause(e){!1!==e.get("isPlaying")&&!0!==e.get("isPaused")&&(e.update({isPaused:!0}),playbackControl.pause(function(t){t&&e.update({isPaused:!1})}))}function onResume(e){!0===e.get("isPlaying")&&!1===e.get("isPaused")||(e.update({isPaused:!1}),playbackControl.resume(function(t){t&&e.update({isPaused:!0})}))}function onSkipPrev(){playbackControl.skipPrev()}function onSkipNext(){playbackControl.skipNext()}function onUpdateShowContext(e,t){const i=t.context;if(!i)return;cancellationTokenSource.cancel();const o=cancellationTokenSource.token();e.update(playerApi.addContext({},i));live(i).query("show(name, uri), rows(track(uri, name, mediaTypeEnum))",(t,a)=>{if(!o.isCanceled())if(t)updateState(e);else{const t={uri:a.show.uri,pages:[{tracks:a.rows.map(({track:e})=>({uri:e.uri,uid:e.uri,metadata:{title:e.name,album_title:a.show.name,"media.type":1===e.mediaTypeEnum?"audio":"video","media.manifest_id":live(e.uri).get("manifestId")||""}}))}],metadata:{"zelda.context_uri":i}};playbackControl.updateContext(t,t=>{t&&updateState(e)})}},3e3)}function playWithOptions(e,t,i){const o=i.context,a=getPlaybackResolverType(o);if(a===TYPE_TRACK)playbackControl.playTrack(o,i,function(t){t&&updateState(e)});else if(a===TYPE_CP_ALBUM_CONTEXT)playbackControl.playFromResolver(o,i,function(t){t&&updateState(e)});else if(a===TYPE_ROWS){sortUriUtils.isValid(o)?getSortedRows(o,function(o,a){o?updateState(e):t.isCanceled()||playRows(e,a,i)}):live(o).query("rows(track(uri))",function(a){a||t.isCanceled()||playRows(e,live(o).get("rows"),i)})}else if(a===TYPE_CP_RESOLVER_PLAYLIST)playbackControl.playFromPlaylistResolver(o,i,function(t){t&&updateState(e)});else if(a===TYPE_CP_RESOLVER_COLLECTION)playbackControl.playFromCollectionResolver(o,i,function(t){t&&updateState(e)});else if(a===TYPE_CONTEXT_OBJECT){const t=contextDataStore[o];playbackControl.playContext(t,i,function(t){t&&updateState(e)})}else if(a===TYPE_CP_CONTEXT){const t={url:`context://${o}`,entity_uri:o};playbackControl.playContext(t,i,function(t){t&&updateState(e)})}else if(a===TYPE_STATION_CONTEXT){const t=live(o);t.query("rows",function(a){a||(playbackControl.playContext(createStationPlayContext(t),createStationPlayOptions(t,i),function(t){t&&updateState(e)}),(0,_messageProxy.messageProxy)({method:"POST",uri:"station-create",target:"top",body:{stationUri:o}}))})}else if(a===TYPE_CP_ARTIST_CONTEXT)playbackControl.playFromArtist(o,i,function(t){t&&updateState(e)});else if(a===TYPE_CONTEXT_EPISODE){const t=3e3;live(o).query("name, mediaTypeEnum, show(name)",function(t,a){if(t)updateState(e);else{const t={uri:o,pages:[{tracks:[{uri:o,metadata:{title:a.name,album_title:a.show.name,"media.type":1===a.mediaTypeEnum?"audio":"video","media.manifest_id":live(o).get("manifestId")||""}}]}],restrictions:{disallow_toggling_repeat_context_reasons:["disallow-video"],disallow_toggling_repeat_track_reasons:["disallow-video"],disallow_toggling_shuffle_reasons:["disallow-video"]}};i.player_options_override||(i.player_options_override={}),i.player_options_override.repeating_context=!1,i.player_options_override.repeating_track=!1,playbackControl.playContext(t,i,function(t){t&&updateState(e)})}},t)}else if(a===TYPE_CONTEXT_SHOW){const t=3e3;live(o).query("show(name, uri), rows(track(uri, name, mediaTypeEnum))",(t,a)=>{if(t)updateState(e);else{const t={uri:a.show.uri,pages:[{tracks:a.rows.map(({track:e})=>({uri:e.uri,uid:e.uri,metadata:{title:e.name,album_title:a.show.name,"media.type":1===e.mediaTypeEnum?"audio":"video","media.manifest_id":live(e.uri).get("manifestId")||""}}))}],restrictions:{disallow_toggling_repeat_context_reasons:["disallow-show"],disallow_toggling_repeat_track_reasons:["disallow-show"],disallow_toggling_shuffle_reasons:["disallow-show"]},metadata:{"zelda.context_uri":o}};i.player_options_override||(i.player_options_override={}),i.player_options_override.repeating_context=!1,i.player_options_override.repeating_track=!1,i.player_options_override.shuffling_context=!1,playbackControl.playContext(t,i,t=>{t&&updateState(e)})}},t)}}function playRows(e,t,i){playbackControl.playRows(t,i,function(o){o&&updateState(e),updatesUtils.listen(t,i,function(i){playbackControl.updateWithRows(t,i,function(t){t&&updateState(e)})})})}function getPlaybackResolverType(e){const t=URI.from(e).type,i=t===URI.Type.TRACK,o=t===URI.Type.LOCAL,a=t===URI.Type.PLAYLIST||t===URI.Type.PLAYLIST_V2,r=t===URI.Type.COLLECTION_ALBUM,n=t===URI.Type.COLLECTION_ARTIST,s=t===URI.Type.FOLDER,l=t===URI.Type.ARTIST,p=t===URI.Type.ALBUM,u=sortUriUtils.isValid(e),c=filterUriUtils.isValid(e),d=isStationUri(e),_=t===URI.Type.EPISODE,y=t===URI.Type.SHOW;if(i||o)return TYPE_TRACK;if(a)return TYPE_CP_RESOLVER_PLAYLIST;if(r||n)return TYPE_CP_RESOLVER_COLLECTION;if(s)return TYPE_CP_CONTEXT;if(d)return TYPE_STATION_CONTEXT;let T;if(u)return T=sortUriUtils.parse(e).originUri,filterUriUtils.isValid(T)&&(T=filterUriUtils.parse(T).originUri),URI.isPlaylistV1OrV2(T)?TYPE_CP_RESOLVER_PLAYLIST:URI.isShow(T)?TYPE_CONTEXT_SHOW:TYPE_ROWS;if(c)return T=filterUriUtils.parse(e).originUri,URI.isPlaylistV1OrV2(T)?TYPE_CP_RESOLVER_PLAYLIST:TYPE_ROWS;if(_)return TYPE_CONTEXT_EPISODE;if(y)return TYPE_CONTEXT_SHOW;if(contextDataStore[e])return TYPE_CONTEXT_OBJECT;const E=live(e).get("rows");return E&&E.length?TYPE_ROWS:l?TYPE_CP_ARTIST_CONTEXT:p?TYPE_CP_ALBUM_CONTEXT:null}function getSortedRows(e,t){const i=sortUriUtils.getOriginUri(e);live(i).get("rows",function(i,o){i?t(i):o.get(0,o.length,function(o){o?t(i):live(e).get("rows",function(e,i){e?t(e):t(null,i)})})})}function updateState(e){dataUtils.getPlayerState(function(t,i){t?global.console&&console.error(t):e.update(i)})}const regExp=exports.matches=/^spotify:player$/;let registered,playerSubscription,cancelPlayerErrorSubscription;exports.register=function(){registered||(registered=!0,live.subscribe(regExp,"play",onPlay),live.subscribe(regExp,"pause",onPause),live.subscribe(regExp,"resume",onResume),live.subscribe(regExp,"skip-previous",onSkipPrev),live.subscribe(regExp,"skip-next",onSkipNext),live.subscribe(regExp,"update-show-context",onUpdateShowContext),live.subscribe(regExp,"update",onUpdate),live.subscribe(regExp,"wait",onWait),live.subscribe(regExp,"sync-position",onSync),playerSubscription=dataUtils.subscribeForPlayerState(onPlayerStateUpdate),cancelPlayerErrorSubscription=playerApi.onError(function(e,t){if(e)return void console.error(e);switch(t.getJSONBody().error){case"one_track_unplayable":case"one_track_unplayable_auto_stopped":case"all_tracks_unplayable_auto_stopped":exports._syncPlayerModelState()}}))},exports._syncPlayerModelState=function(){updateState(live("spotify:player"))},exports.unregister=function(){registered&&(registered=!1,live.unsubscribe(regExp,"play",onPlay),live.unsubscribe(regExp,"pause",onPause),live.unsubscribe(regExp,"resume",onResume),live.unsubscribe(regExp,"skip-previous",onSkipPrev),live.unsubscribe(regExp,"skip-next",onSkipNext),live.unsubscribe(regExp,"update-show-context",onUpdateShowContext),live.unsubscribe(regExp,"update",onUpdate),live.unsubscribe(regExp,"wait",onWait),live.unsubscribe(regExp,"sync-position",onSync),playerSubscription.unsubscribe(),cancelPlayerErrorSubscription&&cancelPlayerErrorSubscription(),playerSubscription=null)},exports.setContextData=function(e,t){contextDataStore[e]=t};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../../libs/cancellation-token-source":42,"../../../libs/message-proxy":208,"../../live":192,"../../live-filter-uri":159,"../../live-sort-uri":190,"../station":181,"../station/create-play-context":182,"../station/create-play-options":183,"./control":174,"./data":176,"./player-api":178,"./updates":180,"spotify-liburi":475}],178:[function(require,module,exports){
(function (global){
"use strict";var _data=require("./data"),_data2=_interopRequireDefault(_data),_cosmos=require("../util/cosmos"),_cosmos2=_interopRequireDefault(_cosmos),_liveSortUri=require("../../live-sort-uri"),_liveSortUri2=_interopRequireDefault(_liveSortUri),_liveFilterUri=require("../../live-filter-uri"),_liveFilterUri2=_interopRequireDefault(_liveFilterUri),_player=require("../../player"),_player2=_interopRequireDefault(_player),_cosmosApi=require("../../cosmos-api"),_cosmosApi2=_interopRequireDefault(_cosmosApi);function _interopRequireDefault(e){return e&&e.__esModule?e:{default:e}}function getPlayer(e,t){const r=e||{};_data2.default.getReferrer(r,(e,r,i,n)=>{if(e)return void t(e);let o=n;const a=_data2.default.getReferrerVersion();if(!o){const e=global.__spotify&&global.__spotify.app_manifest;e&&(o=e.BundleIdentifier||null)}const u={station:"radio",stations:"radio","radio-hub":"radio","daily-mix-hub":"radio"};o&&u[o]&&(o=u[o]);const l=i?{referrerIdentifier:i}:null,s=new _player2.default.Player(_cosmosApi2.default.resolver,r,o,a,l);t(s)})}function play(e,t,r){getPlayer(t,function(i){const n={pages:[{tracks:e}],metadata:{"zelda.context_uri":t.context},entity_uri:getOriginUri(t.context)},o={};"number"==typeof t.index?o.skip_to_index={page:0,track:t.index}:(t.uid||t.uri)&&(o.skip_to={},t.uid?o.skip_to.track_uid=t.uid:t.uri&&(o.skip_to.track_uri=t.uri)),i.play(n,o,r)})}function playContext(e,t,r){t.uid||t.uri||t.page?(t.skip_to={},t.uid?t.skip_to.track_uid=t.uid:t.uri&&(t.skip_to.track_uri=t.uri),t.page&&(t.skip_to.page_index=t.page)):t.range?t.skip_to_index={page:0,track:t.range.start}:"number"==typeof t.index&&(t.skip_to_index={page:0,track:t.index}),getPlayer(t,function(i){i.play(e,t||{},r)})}function updateContext(e,t){getPlayer(null,function(r){r.update(e,t)})}function update(e,t,r){getPlayer(t,function(i){const n={pages:[{tracks:e}],metadata:{"zelda.context_uri":t.context},entity_uri:getOriginUri(t.context)};i.update(n,r)})}function playFromResolver(e,t,r){getPlayer(t,i=>{_cosmos2.default.sanitizeURL(e,(e,n)=>{if(e)return void(r&&r(e));const o={uri:n,url:`context://${encodeURI(n)}`};let a=null;"number"==typeof t.index?a={skip_to_index:{page:0,track:t.index}}:t.trackUri&&(a={skip_to_index:{track_uri:t.trackUri}}),"number"==typeof t.seekTo&&(a.seek_to=t.seekTo),i.play(o,a,r)})})}let cancelSubscribe,onErrorSubscription;function subscribe(e,t={}){let r;return cancelSubscribe=!1,getPlayer(null,i=>{cancelSubscribe||(r=i.subscribe((t,r)=>{t?e(t):e(null,addContext(r.getJSONBody()))},t))}),{unsubscribe:()=>{cancelSubscribe=!0,r&&(r.cancel(),r=null)}}}function onError(e){return getPlayer(null,t=>{onErrorSubscription=t.onError(e)}),()=>{onErrorSubscription&&(onErrorSubscription.cancel(),onErrorSubscription=null)}}function getState(e){getPlayer(null,t=>{t.getState((t,r)=>{t?e(t,null):e(null,addContext(r.getJSONBody()))})})}function pause(e){getPlayer(null,t=>{t.pause(e)})}function resume(e){getPlayer(null,t=>{t.resume(e)})}function addContext(e,t){const r=t||e.context_metadata["zelda.context_uri"]||e.context_uri||e.track&&e.track.uri||null,i=getOriginUri(r);return delete e.context_uri,r?(e.variant={uri:r},e.context={uri:i}):(e.variant=null,e.context=null),e.track=e.track||null,e.index=e.index||null,e.track?(e.uid=e.track.uid,delete e.track.uid):e.uid=null,removeUnderscores(e)}function getOriginUri(e){if(!e)return e;const t=_liveSortUri2.default.parse(e);let r=e;t&&(r=t.originUri);const i=_liveFilterUri2.default.parse(r);return i&&(r=i.originUri),r}function removeUnderscores(e){let t;for(const r in e)e.hasOwnProperty(r)&&(t=r.replace(/_(.)/g,(e,t)=>t.toUpperCase()),e[r]instanceof Object?e[t]=removeUnderscores(e[r]):e[t]=e[r],t!==r&&delete e[r]);return e}exports.play=play,exports.playFromResolver=playFromResolver,exports.playContext=playContext,exports.pause=pause,exports.resume=resume,exports.update=update,exports.subscribe=subscribe,exports.onError=onError,exports.getState=getState,exports.addContext=addContext,exports.updateContext=updateContext;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../cosmos-api":45,"../../live-filter-uri":159,"../../live-sort-uri":190,"../../player":216,"../util/cosmos":188,"./data":176}],179:[function(require,module,exports){
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.play=play;const playlistUtils=require("../../../libs/playlist-utils").default,isPlaylist2Shows=require("../../../libs/playlist-utils").default.isPlaylist2Shows,live=require("../../../libs/live"),wrappedUri=require("../../../libs/live-wrapped-uri");function play(e,i,l){checkIfPlaylistsToShowsContext(e).then(s=>{playlistUtils.playlistRequest(e,{method:"POST",includeEpisodes:s,type:"play",body:i},l)})}function checkIfPlaylistsToShowsContext(e){return new Promise(i=>{const l=wrappedUri.parse(e),s=l?l.originUri:e;live(s).get("formatListType",(e,l)=>{i(isPlaylist2Shows(l))},live.ASAP)})}

},{"../../../libs/live":192,"../../../libs/live-wrapped-uri":191,"../../../libs/playlist-utils":221}],180:[function(require,module,exports){
"use strict";let lastRowsList,lastRowsListUri,lastRowsListHandler,lastRowsListReferrer,playerRowKey,playerKeys;function listen(e,s,t){lastRowsList&&removeRowsListener(),lastRowsList=e,lastRowsListUri=s.context,lastRowsListReferrer=s.referrerId,lastRowsListHandler=function(){s.index=getPlayingAndUpdateIndicesInList(e).update,t(s)},e.on("update",lastRowsListHandler)}function clean(e){if(!lastRowsListHandler)return;const s=e.get("variant");if((s&&s.uri)!==lastRowsListUri)removeRowsListener();else{const s=e.get("playOrigin");(s&&s.get("referrerIdentifier"))===lastRowsListReferrer||e.get("contextUpdatedCrossFrame")||removeRowsListener()}}function setPlayingIndex(e,s){if(!lastRowsList&&!s)return;if(e<0)return;const t=s||lastRowsList;playerRowKey=t.keys[e]||null,playerKeys=t.keys.slice()}function removeRowsListener(){lastRowsList&&lastRowsList.off("update",lastRowsListHandler),lastRowsList=null,lastRowsListUri="",lastRowsListHandler=null,lastRowsListReferrer=""}function getPlayingAndUpdateIndicesInList(e){if(!playerRowKey)return{update:-1,playing:-1};const s=e.keys.indexOf(playerRowKey);let t=s;if(-1===s){for(let s=playerKeys.indexOf(playerRowKey),i=playerKeys.length;s<i;s++)if((t=e.keys.indexOf(playerKeys[s]))>-1){t--;break}}return{update:t,playing:s}}function isPlayingFromRowsContext(e){return e?lastRowsListUri===e:!!lastRowsList}exports.setPlayingIndex=setPlayingIndex,exports.listen=listen,exports.clean=clean,exports.getPlayingAndUpdateIndicesInList=getPlayingAndUpdateIndicesInList,exports.isPlayingFromRowsContext=isPlayingFromRowsContext;

},{}],181:[function(require,module,exports){
"use strict";var _messageProxy=require("../../libs/message-proxy");const live=require("../live"),trackToRow=require("./station/track-to-row"),contains=require("mout/array/contains"),spotifyURI=require("spotify-liburi"),thumbActions=require("./station/thumb-actions"),URI=exports.URI="spotify:station:",idRegexStr="[a-zA-Z0-9]{22}",dailyMixPrefix=exports.dailyMixPrefix="spotify:dailymix",dailyMixRegexStr=`${dailyMixPrefix}:[^:]*`,regExp=exports.matches=new RegExp(`^(?:${URI}(.*)|(?:${dailyMixRegexStr}))`),isStationUri=exports.isStationUri=regExp.test.bind(regExp),clusterRegExp=new RegExp(`^${URI}((user:[^:]+:cluster:${idRegexStr}))`),isClusterStationUri=exports.isClusterStationUri=regExp.test.bind(clusterRegExp),dailyMixRegExp=new RegExp(`^${dailyMixRegexStr}`),isDailyMixUri=exports.isDailyMixUri=(t=>dailyMixRegExp.test(t));exports.isOrdinaryRadioUri=(t=>isStationUri(t)&&!(isClusterStationUri(t)||isDailyMixUri(t)));const DEFAULT_FETCH_COUNT=15,PLAYLIST="playlist",TRACK="track",ALBUM="album",ARTIST="artist",GENRE="genre",CLUSTER="cluster",DAILY_MIX="dailymix",UNKNOWN="unknown";let metadataUpdateUnsubscribe,registered=!1,trackingRows=[],trackingMetadata=[];function getBaseSeedFromUri(t){const e=t.uri.replace(/^spotify:station:/,"spotify:");return decodeURIComponent(e)}function getType(t){const e=spotifyURI.from(t);if(!e)return UNKNOWN;const i=e.type;return spotifyURI.isPlaylistV1OrV2(e)?PLAYLIST:i===spotifyURI.Type.ARTIST?ARTIST:i===spotifyURI.Type.ALBUM?ALBUM:i===spotifyURI.Type.TRACK?TRACK:0===t.indexOf("spotify:genre:")?GENRE:t.indexOf(":cluster:")>0?CLUSTER:t.startsWith(dailyMixPrefix)?DAILY_MIX:UNKNOWN}function onThumbUp(t,e){(0,_messageProxy.messageProxy)({method:"POST",uri:"station-thumb",body:{stationUri:t.get("uri"),trackUri:e,thumb:thumbActions.UP}})}function onThumbDown(t,e){(0,_messageProxy.messageProxy)({method:"POST",uri:"station-thumb",body:{stationUri:t.get("uri"),trackUri:e,thumb:thumbActions.DOWN}})}function onHeart(t,e){isStationUri(t.get("uri"))&&(0,_messageProxy.messageProxy)({method:"POST",uri:"station-heart",body:{stationUri:t.get("uri"),trackUri:e}})}function onUndoHeart(t,e){isStationUri(t.get("uri"))&&(0,_messageProxy.messageProxy)({method:"POST",uri:"station-undo-feedback",body:{stationUri:t.get("uri"),trackUri:e,thumbAction:thumbActions.UNDO_HEART}})}function requestStationData(t,e,i,r){const s=!!i&&(r||t.get("fetchCount"));(0,_messageProxy.messageProxy)({method:"GET",uri:"station",target:"top",body:{stationUri:t.get("uri"),metadata:e,trackCount:s}},function(e,i){if(e)return void(0,_messageProxy.messageProxy)({method:"POST",uri:"station-error",body:{stationUri:t.get("uri"),message:e}});const r=i.stationUri,s=i.station;if(s.hasOwnProperty("tracks")){if(-1!==trackingRows.indexOf(r)){const t=(new Date).getTime();s.rows=s.tracks.map(trackToRow.bind(null,t))}delete s.tracks}live(r).update(s)})}function onRowsWait(t,e){if(e&&e.length>0){let i=0,r=0;e.forEach(function(t){t.end>r&&(r=t.end)}),requestStationData(t,[],!0,i=r-t.get("rows").length)}}function onUpdateMetadata(t){const e=t.stationUri,i=t.metadata;if(-1!==trackingMetadata.indexOf(e)){if(i.hasOwnProperty("tracks")){if(-1!==trackingRows.indexOf(e)){const t=(new Date).getTime();i.rows=i.tracks.map(trackToRow.bind(null,t))}delete i.tracks}live(e).update(i)}}function onInit(t){const e=getBaseSeedFromUri(t);e&&(t.update({baseSeed:e,type:getType(e),fetchCount:DEFAULT_FETCH_COUNT}),t.on("update",function e(i){i.hasOwnProperty("rows")&&(t.get("rows").on("wait",onRowsWait.bind(null,t)),t.off("update",e))}),trackingMetadata.push(t.get("uri")))}function onPublish(t,e){if(e.hasOwnProperty("added")){const i=e.added;"boolean"==typeof i?(t.update({added:i}),(0,_messageProxy.messageProxy)({method:"POST",uri:"station-add",body:{stationUri:t.get("uri"),add:i}})):console.error("Added can only be a boolean")}}function onWait(t,e){let i,r=-1;const s=["added","name","subtitles","relatedArtists","image","nextPageUrl"];e.forEach(function(t,e){"rows"===t&&(r=e),!i&&contains(s,t)&&(i=!0)}),-1!==r?(trackingRows.push(t.get("uri")),e.splice(r,1),requestStationData(t,e,!0)):i&&requestStationData(t,e)}exports.register=function(){registered||(registered=!0,live.subscribe(regExp,"wait",onWait),live.subscribe(regExp,"init",onInit),live.subscribe(regExp,"thumb-up",onThumbUp),live.subscribe(regExp,"thumb-down",onThumbDown),live.subscribe(regExp,"heart",onHeart),live.subscribe(regExp,"undo-heart",onUndoHeart),live.subscribe(regExp,"publish",onPublish),metadataUpdateUnsubscribe=(0,_messageProxy.messageProxy)({method:"SUB",uri:"station-metadata"},onUpdateMetadata))},exports.unregister=function(){registered&&(registered=!1,live.unsubscribe(regExp,"wait",onWait),live.unsubscribe(regExp,"init",onInit),live.unsubscribe(regExp,"thumb-up",onThumbUp),live.unsubscribe(regExp,"thumb-down",onThumbDown),live.unsubscribe(regExp,"heart",onHeart),live.unsubscribe(regExp,"publish",onPublish),metadataUpdateUnsubscribe(),trackingRows=[],trackingMetadata=[])};

},{"../../libs/message-proxy":208,"../live":192,"./station/thumb-actions":185,"./station/track-to-row":186,"mout/array/contains":410,"spotify-liburi":475}],182:[function(require,module,exports){
"use strict";const rowToPlayerTrack=require("./row-to-player-track"),PLAYER_RESTRICTIONS={disallow_toggling_repeat_context_reasons:["disallow-radio"],disallow_toggling_repeat_track_reasons:["disallow-radio"],disallow_toggling_shuffle_reasons:["disallow-radio"]};function createPlayerTracks(e){const r=e.get("rows");return r?r.values.map(rowToPlayerTrack):[]}module.exports=function(e){return{entity_uri:e.get("uri"),pages:[{tracks:createPlayerTracks(e),next_page_url:e.get("nextPageUrl")}],metadata:{context_description:e.get("name")},restrictions:PLAYER_RESTRICTIONS}};

},{"./row-to-player-track":184}],183:[function(require,module,exports){
"use strict";const PLAYER_OPTIONS={shuffling_context:!1,repeating_context:!1,repeating_track:!1};function getLastIndex(e){const t=e.get("rows"),n=e.get("currentTrackUid");if(!t||!n)return 0;let r;return t.values.some(function(e,t){return e.get("uid")===n&&(r=t,!0)})?r:0}module.exports=function(e,t){let n;const r={skip_to_index:{page:0,track:n=t&&(t.index||0===t.index)?t.index:getLastIndex(e)},player_options_override:PLAYER_OPTIONS};return t&&t.uid&&(r.uid=t.uid),r};

},{}],184:[function(require,module,exports){
"use strict";module.exports=function(t){return{uid:t.get("uid"),uri:t.get("track").get("uri"),album_uri:t.get("track").get("albumUri"),artist_uri:t.get("track").get("artistUri"),metadata:{image_url:t.get("track").get("image"),"radio.thumb":t.get("track").get("thumb")}}};

},{}],185:[function(require,module,exports){
"use strict";module.exports={UP:"ups",DOWN:"downs",UNDO_HEART:"undo-heart",UNDO_BAN_ARTIST:"undo-ban-artist",UNDO_BAN_TRACK:"undo-ban-track"};

},{}],186:[function(require,module,exports){
"use strict";function transformArtists(t){const r=[];for(let i=0;;i++){const a=i>0?`:${i}`:"",u=t[`artist_uri${a}`],e=t[`artist_name${a}`];if(!u||!e)break;r.push({uri:u,name:e})}return r}module.exports=function(t,r,i){const a=r.metadata||{},u=r.album_uri||a.album_uri;let e=r.uid;if(!r.uid){e=t+r.uri.replace("spotify:track:","")+i}return{uid:e,uri:e,track:{uri:r.uri,name:a.title,image:a.image_url,albumUri:u,artists:transformArtists(r.metadata),album:{name:a.album_title,uri:u},thumb:a["radio.thumb"]||""}}};

},{}],187:[function(require,module,exports){
"use strict";const bridge=require("../../bridge");module.exports={request:bridge.request};

},{"../../bridge":41}],188:[function(require,module,exports){
(function (global){
"use strict";const cosmos=require("../../cosmos-api").default;function DELETE(e,t){return e.method=exports.cosmos.Action.DELETE,request(e,t)}function GET(e,t){return e.method=exports.cosmos.Action.GET,request(e,t)}function SUB(e,t){return e.method=exports.cosmos.Action.SUB,request(e,t)}function POST(e,t){return e.method=exports.cosmos.Action.POST,request(e,t)}function PUT(e,t){return e.method=exports.cosmos.Action.PUT,request(e,t)}function HEAD(e,t){return e.method=exports.cosmos.Action.HEAD,request(e,t)}function request(e,t){const o=e.method;let s,n;return delete e.method,sanitizeURL(e.url,function(r,c){if(r)t&&t(r);else if(!n){const n=new exports.cosmos.Request(o||exports.cosmos.Action.GET,c,e.headers,e.body);s=exports.cosmos.resolver.resolve(n,function(e,o){if(t)if(t&&e)t(e);else try{t(null,{body:JSON.parse(o.getBody()||"{}"),headers:o.getHeaders(),status:o.getStatusCode()})}catch(e){e.response=o,t(e)}})}}),{cancel:function(){return s&&s.cancel?(s.cancel(),s=null):n||(n=!0),null}}}function sanitizeURL(e,t){e.indexOf("@")>-1?t(null,e.replace("@",encodeURIComponent(global.__spotify.username))):t(null,e)}exports.request=request,exports.get=GET,exports.post=POST,exports.subscribe=SUB,exports.delete=DELETE,exports.put=PUT,exports.head=HEAD,exports.cosmos=cosmos,exports.sanitizeURL=sanitizeURL;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../cosmos-api":45}],189:[function(require,module,exports){
(function (global){
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=(()=>global.location.href);

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],190:[function(require,module,exports){
"use strict";const base="spotify:internal:sortlist",regExp=/^spotify:internal:sortlist:(asc|desc):([^:]*):(.*)$/;exports.create=function(t,e,r){const n=t.replace(/^spotify:/,""),o=encodeURIComponent(r).replace(/%20/g,"");return[base,e,o,n].join(":")},exports.getDirection=function(t){const e=t.match(regExp);return e?e[1]:""},exports.getQuery=function(t){const e=t.match(regExp);return e?decodeURIComponent(e[2]):""},exports.getOriginUri=function(t){const e=t.match(regExp);return e?`spotify:${e[3]}`:""},exports.parse=function(t){const e=t.match(regExp);return e?{direction:e[1],query:decodeURIComponent(e[2]),originUri:`spotify:${e[3]}`}:null},exports.isValid=function(t){return regExp.test(t)},exports.regExp=regExp;

},{}],191:[function(require,module,exports){
"use strict";const sortUriUtils=require("../live-sort-uri"),filterUriUtils=require("../live-filter-uri");exports.create=function(r){let i=r.originUri;return r.filter&&(i=filterUriUtils.create(i,r.filter.query)),r.sort&&(i=sortUriUtils.create(i,r.sort.direction,r.sort.query)),i},exports.getOriginUri=function(r){const i=exports.parse(r);return i&&i.originUri||""},exports.parse=function(r){const i=sortUriUtils.parse(r),t=filterUriUtils.parse(i&&i.originUri||r);return i||t?{originUri:t&&t.originUri||i&&i.originUri,sort:i,filter:t}:null},exports.isValid=function(r){return!!exports.parse(r)};

},{"../live-filter-uri":159,"../live-sort-uri":190}],192:[function(require,module,exports){
(function (global){
"use strict";const prime=require("../../libs/prime"),defer=require("../../libs/prime/defer"),Emitter=require("../../libs/prime/emitter"),isPlainObject=require("mout/lang/isPlainObject"),isRegExp=require("mout/lang/isRegExp"),isNumber=function(e){return"number"==typeof e},isString=function(e){return"string"==typeof e},escapeRegExp=require("mout/string/escapeRegExp"),_difference=require("mout/array/difference"),filter=require("mout/array/filter"),combine=require("mout/array/combine"),map=require("mout/array/map"),deepMixIn=require("mout/object/deepMixIn"),pick=require("mout/object/pick");function parallel(e,t){const i=[];let n=e.length;n?e.forEach((e,r)=>{e((e,s)=>{i[r]=s,(0==--n||e)&&t(e,i)})}):t(null,i)}const OrderedSet=require("./util/ordered-set"),Range=require("../range2"),parse=require("./util/parser"),throttle=require("./util/throttle"),debug=require("../debug")("live"),isLiveList=function(e){return e instanceof LiveList},isLiveObject=function(e){return e instanceof LiveObject},simpleClone=function(e){return Object.assign({},e)},difference=function(e,t){return 0===e.length?[]:_difference.call(this,e,t)},values=function(e,t){const i=[];let n;for(let r=0,s=t.length;r<s;r++)(n=t[r])in e?i.push(e[n]):i.length++;return i},rdifference=function(e,t){if(!e.length)return[];let i=[];for(let n=0,r=e.length;n<r;n++){const r=e[n];i=i.concat(r.subtract(t))}return i=new Range(0,0).merge(i),i=filter(i,function(e){return!!e.length})},rcombine=function(e,t){let i=t;for(let t=0,n=e.length;t<n;t++){i=e[t].merge(i)}return i};let IDX=0;const slice_=Array.prototype.slice,transform=function(e,t){return isPlainObject(e)?"operations"in e?(new LiveList).update(e.operations):live(e.uri)._update(e,t):Array.isArray(e)?(new LiveList)._update([{type:"insert",index:0,length:e.length,values:e}],t):e};function createTimedCallback(e,t){let i;const n=setTimeout(function(){i=!0,e(new Error(`Timeout Expired: ${t} milliseconds`))},t);return function(){i||(clearTimeout(n),e.apply(this,arguments))}}const LiveList=prime({mixin:Emitter,constructor:function(e){this._data=new OrderedSet(e),this._mergeThrottled=throttle(this._merge,this),this._waiting=[];let t="";live.debug&&setInterval(()=>{const e=this._waiting.toString();t!==e&&(t=e,this._waiting.length?debug(this,"waiting for",this._waiting):debug(this,"all done"))},2e3)},get index(){return this._data.index},get length(){return this._data.length},get keys(){return this._data.keys},get values(){return this._data.values},indexOf:function(e){return this._data.indexOf(e)},indexOfMany:function(e){return this._data.indexOfMany(e)},valueOf:function(e){return this._data.valueOf(e)},hasKey:function(e){return this._data.hasKey(e)},forEach:function(e,t){return this._data.forEach(e,t),this},map:function(e,t){return this._data.map(e,t)},_merge:function(){const e=this._data,t=this._publish,i=this._before;if(t){if(delete this._publish,this._listeners&&this._listeners.publish){const i=e.diff(t);i.length&&this.emit("publish",i,EMIT_SYNC)}}else if(i&&(delete this._before,this._listeners&&this._listeners.update)){const t=i.diff(e);t.length&&this.emit("update",t,EMIT_SYNC)}return this},_update:function(e,t){let i,n;if(t===PUBLISH){if(this._before)return this;i=this._publish||(this._publish=this._data.clone())}else t===UPDATE&&(this._publish&&delete this._publish,this._before||(this._before=this._data.clone()),i=this._data);for(let r=0,s=e.length;r<s;r++){const s=[],l=(n=e[r]).keys||[];switch(n.type){case"length":i.length=n.length;break;case"sort":i.sort(n.compareFunction);break;case"move":i.move(n.from,n.to,n.length);break;case"remove":i.remove(n.index,n.length);break;case"insert":for(let e=0,i=n.values.length;e<i;e++)n.keys&&n.keys[e]||(l[e]=(IDX++).toString(36)),s[e]=transform(n.values[e],t);i.insert(n.index,l,s);break;default:console.error("Invalid operation type",n.type)}}return t===UPDATE&&(this._waiting=rdifference(this._waiting,this.index)),this._mergeThrottled(),this},publish:function(e){return this._update(e,PUBLISH)},update:function(e){return this._update(e,UPDATE)},serialize:function(e){if(0===e)return[];const t=[],i=void 0===e?void 0:e-1;for(let e=0;e<this.length;e++){const n=this.values[e];let r=n;n&&n.serialize&&(r=n.serialize(i)),t.push(r)}return t},_getDataFromMask:function(e){const t=[];if(e.length>0)for(let i=0,n=this.length;i<n;i++){const n=this.get(i);let r;n&&n._getDataFromMask&&(r=n._getDataFromMask(e)),t.push(r)}return t},_query:function(e,t,i){const n=()=>{queryList(this,e,(n,r,s)=>{n?t(n):s?t(null,r):this._query(e,t,i)})};i===ASYNC?defer.immediate(n):n()},query:function(e,t,i,n,r){let s=t,l=i,u=n,a=r;return"function"==typeof s&&(a=u,u=l,l=s,s=[]),l?(u?isNumber(u)&&(a=u,u=ASYNC):u=ASYNC,a&&(l=createTimedCallback(l,a)),this._query(parse(e,s),l,u),this):this._getDataFromMask(parse(e,s).mask)},_wait:function(e){this._required||(this._required=[],defer.immediate(function(){const e=this.missing(this._required),t=rdifference(e,this._waiting);this._waiting=rcombine(this._waiting,t),delete this._required,t.length&&this.emit("wait",t,EMIT_SYNC)},this)),this._required=rcombine(this._required,e)},missing:function(e){return rdifference(e,this.index)},_get:function(e,t){if(this.missing(e).length){this._wait(e);const i=function(){this.missing(e).length||(this.off("update",i),t.call(this))};this.on("update",i)}else t.call(this,null,!0)},has:function(e,t){let i;return(i=new Range(e,void 0!==t?t:e+1)).contained(this.index)},get:function(e,t){if(1===arguments.length){if(isNumber(e))return this.values[e];if(isString(e))return this.valueOf(e)}const i=slice_.call(arguments);let n,r,s;for(let e=0,t=i.length;e<t;e++){if("function"==typeof i[e]){const s=i.splice(e,3);if(t=i.length,n=s[0],s[1]){if(s[1]!==SYNC&&s[1]!==ASYNC&&s[1]!==ASAP){r=ASYNC,n=createTimedCallback(n,s[1]);break}r=s[1],s[2]&&r!==SYNC&&(n=createTimedCallback(n,s[2]))}else r=ASYNC;break}}let l=!1,u=!1;if(e instanceof Range)s=i,l=!n&&s.length>1;else if(Array.isArray(e))l=!0,s=e;else{const i=!isNaN(t);s=i?[new Range(e,t)]:[new Range(e,e+1)],u=!i}const a=()=>map(s,e=>this.values.slice(e.start,e.end)),o=()=>{l?n.call(this,null,a()):u?n.call(this,null,this.values[e]):n.apply(this,[null].concat(a()))};return n?(r===SYNC?o():r!==ASYNC||this.missing(s).length?this._get(s,o):defer.immediate(function(){this._get(s,o)},this),this):l?a():a()[0]}}),LiveObject=prime({mixin:Emitter,constructor:function(e){this.uri=e,this._data={uri:e},this._mergeThrottled=throttle(this._merge,this),this.index=[],this._waiting=[],this.emit("init",EMIT_SYNC);let t="";live.debug&&setInterval(()=>{const e=this._waiting.toString();t!==e&&(t=e,this._waiting.length?debug(this,this._waiting):debug(this,"all done"))},2e3)},emit:function(){const e=this.uri;if(e){const t=emitters.keys,i=emitters.values;let n,r;for(let s=0,l=t.length;s<l;s++)if(n=t[s],e.match(n)){if(!r){r=new Array(arguments.length);for(let e=0;e<arguments.length;++e)r[e]=arguments[e];r.splice(1,0,this)}const e=i[s];e.emit.apply(e,r)}}Emitter.prototype.emit.apply(this,arguments)},_merge:function(){const e=this._data,t=this._before,i=this._publish;let n,r;if(i&&(delete this._publish,this.uri||this._listeners&&this._listeners.publish)){const t={};for(r in i)i.hasOwnProperty(r)&&(n=i[r],e[r]!==n&&(t[r]=n));Object.keys(t).length&&this.emit("publish",t,EMIT_SYNC)}if(t){delete this._before;const i={};if(this.uri||this._listeners&&this._listeners.update){for(r in e)e.hasOwnProperty(r)&&(n=e[r],r in t&&t[r]===n||(i[r]=n));for(r in t)t.hasOwnProperty(r)&&(n=t[r],r in e||(i[r]=void 0));Object.keys(i).length&&this.emit("update",i,EMIT_SYNC)}}return this},_update:function(e,t){let i,n;t===PUBLISH?i=this._publish||(this._publish=simpleClone(this._data)):t===UPDATE&&(this._before||(this._before=simpleClone(this._data)),i=this._data);for(const r in e){if(!e.hasOwnProperty(r))continue;n=e[r];const s=r in i?i[r]:void 0;if(isLiveList(s)){if(Array.isArray(n)){s._update([{type:"remove",index:0,length:s.length},{type:"insert",index:0,values:n}],t);continue}if(isPlainObject(n)&&"operations"in n){s._update(n.operations,t);continue}}t===UPDATE&&void 0===n?delete i[r]:i[r]=transform(n,t)}return t===UPDATE&&(this.index=Object.keys(i),this._waiting=difference(this._waiting,this.index)),this._mergeThrottled(),this},delete:function(e){const t={};return t[e]=void 0,this.update(t)},update:function(e){return this._update(e,UPDATE)},publish:function(e){return this._update(e,PUBLISH)},serialize:function(e){if(0===e)return{};const t={},i=this._data,n=void 0===e?void 0:e-1;for(const e in i){if(!i.hasOwnProperty(e))continue;const r=i[e];if(void 0===r)continue;let s=r;r&&r.serialize&&(s=r.serialize(n)),t[e]=s}return t},_getDataFromMask:function(e){const t={};for(let i=0,n=e.length;i<n;i++){const n=e[i],r=n.mask,s=n.key,l=this.get(s);let u=l;if(isLiveObject(l)&&(u={}),isLiveList(l)&&(u=[]),r)if(isLiveObject(l)){const e=l._getDataFromMask(r);deepMixIn(u,e)}else isLiveList(l)&&(u=l._getDataFromMask(r));t[s]=u}return t},_query:function(e,t,i){const n=()=>{queryObject(this,e,(n,r,s)=>{n?t.call(this,n):s?t.call(this,null,r):this._query(e,t,i)})};i===ASYNC?defer.immediate(n):n()},query:function(e,t,i,n,r){let s=t,l=i,u=n,a=r;return"function"==typeof s&&(a=u,u=l,l=s,s=[]),l?(u?isNumber(u)&&(a=u,u=ASYNC):u=ASYNC,a&&(l=createTimedCallback(l,a)),this._query(parse(e,s),l,u),this):this._getDataFromMask(parse(e,s).mask)},_wait:function(e){this._required||(this._required=[],defer.immediate(function(){const e=this.missing(this._required),t=difference(e,this._waiting);this._waiting=combine(this._waiting,t),delete this._required,t.length&&this.emit("wait",t,EMIT_SYNC)},this)),this._required=combine(this._required,e)},missing:function(e){return difference(e,this.index)},has:function(e){return this.index.indexOf(e)>-1},_get:function(e,t){if(this.missing(e).length){this._wait(e);const i=function(){this.missing(e).length||(this.off("update",i),t.call(this))};this.on("update",i)}else t.call(this,null,!0)},get:function(e){const t=this._data;if(1===arguments.length&&isString(e))return t[e];const i=slice_.call(arguments);let n,r,s;for(let e=0,t=i.length;e<t;e++){if("function"==typeof i[e]){const s=i.splice(e,3);if(t=i.length,n=s[0],s[1]){if(s[1]!==SYNC&&s[1]!==ASYNC&&s[1]!==ASAP){r=ASYNC,n=createTimedCallback(n,s[1]);break}r=s[1],s[2]&&r!==SYNC&&(n=createTimedCallback(n,s[2]))}else r=ASYNC;break}}let l=!1;Array.isArray(e)?(s=e,l=!0):s=i;const u=()=>{const e=values(t,s);l?n.call(this,null,e):(e.unshift(null),n.apply(this,e))};return n?(r===SYNC?u():r!==ASYNC||this.missing(s).length?this._get(s,u):defer.immediate(()=>{this._get(s,u)}),this):values(t,s)}}),queryAny=function(e,t,i){return isPlainObject(e)||isLiveObject(e)?queryObject(e,t,i):Array.isArray(e)||isLiveList(e)?queryList(e,t,i):i(null,e,!0)},queryObject=function(e,t,i){const n={};let r=!0;t||i(null,n,r);const s=map(t.mask,"key"),l=function(e){parallel(e.map(function(e,i){return function(l){queryAny(e,t.mask[i],function(e,t,u){e?l(e):(u||(r=!1),n[s[i]]?deepMixIn(n[s[i]],t):n[s[i]]=t,l())})}}),function(e){i(e,n,r)})};if(isLiveObject(e))e._get(s,function(t,n){if(t)i(t);else{n||(r=!1);const t=map(s,function(t){return e._data[t]});l(t)}});else{const t=pick(e,s);l(t)}},satisfies=function(e,t,i){if(!t)return!!e;if(isRegExp(i))return i.test(e);if("="===t)return e===i;if("!="===t)return e!==i;if(isNumber(i)){if(">"===t)return e>i;if(">="===t)return e>=i;if("<"===t)return e<i;if("<="===t)return e<=i}if(isString(i)){const n=escapeRegExp(i);if("^="===t)return new RegExp(`^${n}`).test(e);if("$="===t)return new RegExp(`${n}$`).test(e);if("~="===t)return new RegExp(`(^|\\s)${n}(\\s|$)`).test(e);if("|="===t)return new RegExp(`^${n}(-|$)`).test(e);if(" *="===t)return-1!==e.toString().indexOf(i)}return!1},filterArray=function(e,t,i,n,r){let s=!0;const l=[];let u=e.length,a=!1;function o(e){if(e)return void(a||(a=!0,r(e)));if(a||--u>0)return;const t=[];for(let e=0;e<l.length;e++)e in l&&t.push(l[e]);r(null,t,s)}for(let r=0;r<e.length;r++){const u=e[r];isLiveObject(u)?u._get([t],function(e,a){if(e)return void o(e);a||(s=!1);let c=u._data[t];satisfies(c,i,n)&&(l[r]=u),o()}):(isPlainObject(u)&&satisfies(u[t],i,n)&&(l[r]=u),o())}},defaultFilters=[[{left:0,op:":"}]];function runSeriallyOnArray(e,t,i,n){t>=e.length?n():i(e[t],function(r){r?n(r):runSeriallyOnArray(e,t+1,i,n)})}const queryList=function(e,t,i){let n=!0;t.filters||(t.filters=defaultFilters),runSeriallyOnArray(t.filters,0,function(t,i){let r=[];parallel(t.map(function(t){return function(i){!function(t,i){let s=t.left,l=t.right,u=t.op;if("left"in t&&!("right"in t)&&isNumber(s)&&(u?":"===u&&(l=e.length):l=s+1,u=":"),"right"in t&&!("left"in t)&&isNumber(l)&&":"===u&&(s=0),isNumber(s)&&isNumber(l)&&":"===u)if(Array.isArray(e)){const t=slice_.call(e,s,l);r=r.concat(t),i()}else e._get([new Range(s,l)],function(t,u){if(t)i(t);else{for(let t=s;t<l;t++)r.push(e.values[t]);u||(n=!1),i()}});else{const t=function(e){filterArray(e,s,u,l,function(e,t,s){e?i(e):(s||(n=!1),r=r.concat(t),i())})};Array.isArray(e)?t(e):e._get([new Range(0,e.length)],function(r,s){if(r)i(r);else{const i=[];for(let t=0;t<e.length;t++)i.push(e.values[t]);s||(n=!1),t(i)}})}}(t,i)}}),function(t){t?i(t):(e=r,i())})},function(r){if(r)i(r);else{const r=[];parallel(e.map(function(e,i){return function(s){queryAny(e,t,function(e,t,l){l||(n=!1),r[i]?deepMixIn(r[i],t):r[i]=t,s(e)})}}),function(e){i(e,r,n)})}})};let cache={};const live=function(e){return Array.isArray(e)?(new LiveList).update([{type:"insert",index:0,length:e.length,values:e}]):isNumber(e)?new LiveList(e):isString(e)?cache[e]||(cache[e]=new LiveObject(e)):isPlainObject(e)?live(e.uri).update(e):isLiveList(e)||isLiveObject(e)?e:new LiveObject};global.localStorage&&global.localStorage.debug&&(global.localStorage.debug.indexOf("live")>-1||global.localStorage.debug.indexOf("*")>-1)&&(live.debug=!0);const emitters={keys:[],values:[]};live.subscribe=function(e,t,i){let n=e;e.matches&&(n=n.matches);const r=n.toString(),s=emitters.keys,l=emitters.values;let u;for(let e=0,t=s.length;e<t;e++){if(s[e].toString()===r&&(u=l[e]))break}return u||(s.push(e),l.push(u=new Emitter)),u.on(t,i),this},live.unsubscribe=function(e,t,i){let n=e;n.matches&&(n=n.matches);const r=e.toString(),s=emitters.keys,l=emitters.values;let u;for(let e=0,t=s.length;e<t;e++){if(s[e].toString()===r&&(u=l[e]))break}return u&&u.off(t,i),this},live.delete=function(e){return delete cache[e],this},live.purge=function(){return cache={},this},live.has=function(e){return!!cache[e]};const EMIT_SYNC=live.EMIT_SYNC=Emitter.EMIT_SYNC,ASYNC=live.ASYNC="ASYNC",SYNC=live.SYNC="SYNC",ASAP=live.ASAP="ASAP",PUBLISH=3,UPDATE=4;live.Object=LiveObject,live.List=LiveList,module.exports=live;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../libs/prime":227,"../../libs/prime/defer":225,"../../libs/prime/emitter":226,"../debug":52,"../range2":229,"./util/ordered-set":194,"./util/parser":195,"./util/throttle":196,"mout/array/combine":409,"mout/array/difference":411,"mout/array/filter":414,"mout/array/map":418,"mout/lang/isPlainObject":436,"mout/lang/isRegExp":437,"mout/object/deepMixIn":442,"mout/object/pick":450,"mout/string/escapeRegExp":452}],193:[function(require,module,exports){
"use strict";const splice_=Array.prototype.splice,slice_=Array.prototype.slice,annotate=function(t,e){const o=t.length,n=e.length,r=[],f={},l={};for(let s=0;s<o;s++){const c=t[s];for(let i=0;i<n;i++){if(l[i])continue;if(c!==e[i])continue;const h=s,a=i;let u=0;do{f[s++]=l[i++]=!0,u++}while(s<o&&i<n&&t[s]===e[i]&&!l[i]);const m={type:"move",from:h,to:a,length:u};r.push(m),s--;break}}const s=[];for(let e=0;e<o;){if(f[e]){e++;continue}const n=e;let r=0;for(;e<o&&!f[e++];)r++;const l={type:"remove",index:n,length:r,values:slice_.call(t,n,n+r)};s.push(l)}const c=[];for(let t=0;t<n;){if(l[t]){t++;continue}const o=t;let r=0;for(;t<n&&!l[t++];)r++;const f=slice_.call(e,o,o+r);c.push({type:"insert",index:o,length:r,values:f})}return[s,r,c]},reduceMoves=function(t){for(let e=0;e<t.length;e++)if(t[e].length>Math.abs(t[e].to-t[e].from)){const o=t[e].to,n=t[e].length;t[e].length=Math.abs(t[e].to-t[e].from),t[e].from=o,t[e].to=o+n}},offset=function(t,e,o){const n=o.length,r=t.length,f=e.length;let l=0;for(let o=0;o<r;o++){const n=t[o];n.index-=l,l+=n.length;for(let t=0;t<f;t++){const o=e[t];o.from>=n.index&&(o.from-=n.length)}}for(let t=n;t--;){const n=o[t],r=n.length;for(let t=f;t--;){const o=e[t];o.to>=n.index&&(o.to-=r)}}for(let t=f;t-- >1;){const o=e[t];if(o.to!==o.from)for(let n=t;n--;){const t=e[n];t.to>=o.to&&(t.to-=o.length),t.to>=o.from&&(t.to+=o.length)}}const s=[];for(let t=0;t<f;t++){const o=e[t];if(o.to!==o.from){s.push(o);for(let n=t+1;n<f;n++){const t=e[n];t.from>=o.from&&(t.from-=o.length),t.from>=o.to&&(t.from+=o.length)}}}return reduceMoves(s),t.concat(s,o)},insert=function(t,e,o){for(let n=0;n<o.length;n++)if(n in o){const r=e+n;t.length<r&&(t.length=r),t.splice(r,0,o[n])}return o},remove=function(t,e,o){return splice_.call(t,e,o)},move=function(t,e,o,n){const r=remove(t,e,n);return insert(t,o,r),r},patch=function(t,e){for(let o=0;o<e.length;o++){const n=e[o];switch(n.type){case"move":move(t,n.from,n.to,n.length);break;case"remove":remove(t,n.index,n.length);break;case"insert":insert(t,n.index,n.values);break;default:console.error("Unexpected operation type",n.type)}}return t},diff=function(t,e){const o=annotate(t,e);return offset.apply(this,o)};diff.annotate=annotate,diff.offset=offset,diff.remove=remove,diff.insert=insert,diff.move=move,diff.patch=patch,module.exports=diff;

},{}],194:[function(require,module,exports){
"use strict";const prime=require("../../../libs/prime"),forEach=require("mout/array/forEach"),Range=require("../../range2"),diff=require("./diff"),OrderedSet=prime({constructor:function(e=0){this.index=[],this.keys=new Array(e),this.values=new Array(e),this.objectStorage={}},get length(){return this.keys.length},set length(e){this.keys.length=e,this.values.length=e},forEach:function(e,t){const i=this.index;for(let s=0;s<i.length;s++){const n=i[s];for(let i=n.start;i<n.end&&!1!==e.call(t,this.values[i],i,this.keys[i],this);i++);}return this},map:function(e,t){const i=new Array(this.length);return this.forEach(function(s,n,r){i[n]=e.call(t,s,n,r,this)},this),i},copy:function(e){this.index=e.index.slice(),this.keys=e.keys.slice(),this.values=e.values.slice();const t=this.keys.length;this.objectStorage={};for(let e=0;e<t;e++)this.objectStorage[this.keys[e]]=this.values[e];return this},clone:function(){return(new OrderedSet).copy(this)},indexOf:function(e){let t=-1;return this.forEach(function(i,s,n){e===n&&(t=s)}),t},indexOfMany:function(e){const t={},i=[];for(let i=0;i<e.length;i++)t[e[i]]=-1;this.forEach(function(e,i,s){s in t&&(t[s]=i)});for(let s=0;s<e.length;s++)i[s]=t[e[s]];return i},valueOf:function(e){return this.objectStorage[e]||null},hasKey:function(e){return this.objectStorage.hasOwnProperty(e)},sort:function(e){const t=this.keys,i=this.values,s=diff(i.slice(),i.sort(e));return forEach(s,function(e){diff.move(t,e.from,e.to,e.length)}),this},move:function(e,t,i){let s=i,n=t;return e>this.length?[]:(e+s>this.length&&(s=e-this.length),n>this.length&&(n=this.length),e===n?[]:(diff.move(this.keys,e,n,s),diff.move(this.values,e,n,s),this))},insert:function(e,t,i){if(t.length!==i.length)throw new Error("length mismatch");const s=new Range(e,e+t.length);this.index=s.insert(this.index),diff.insert(this.keys,e,t),diff.insert(this.values,e,i);for(let e=0,s=t.length;e<s;e++)this.objectStorage[t[e]]=i[e];return this},remove:function(e,t){let i=t;if(e>=this.length)return[];e+i>this.length&&(i=this.length);const s=new Range(e,e+i);this.index=s.extract(this.index);for(let t=0;t<i;t++)delete this.objectStorage[this.keys[t+e]];return diff.remove(this.keys,e,i),diff.remove(this.values,e,i),this},diff:function(e){const t=diff.annotate(this.keys,e.keys);return forEach(t[0],function(e){e.keys=e.values,e.values=this.values.slice(e.index,e.index+e.length)},this),forEach(t[1],function(e){e.keys=e.values,e.values=this.values.slice(e.from,e.from+e.length)},this),forEach(t[2],function(t){t.keys=t.values,t.values=e.values.slice(t.index,t.index+t.length)}),diff.offset.apply(diff,t)},patch:function(e){return forEach(e,function(e){switch(e.type){case"move":this.move(e.from,e.to,e.length);break;case"remove":this.remove(e.index,e.length);break;case"insert":this.insert(e.index,e.keys,e.values);break;default:console.error("Invalid patch operation type",e.type)}},this),this}});module.exports=OrderedSet;

},{"../../../libs/prime":227,"../../range2":229,"./diff":193,"mout/array/forEach":415}],195:[function(require,module,exports){
"use strict";const normalize=function(e){return""===e||isNaN(e)?"true"===e||"false"!==e&&("null"===e?null:"undefined"!==e?e:void 0):+e};function escapeForRegExp(e){return e.replace(/[-[\]{}()*+?.,\\^$|#\s]/g,"\\$&")}const COMMA=",",BMASK="(",EMASK=")",BFILTER="[",EFILTER="]",EQUALS="=",WHITESPACE="\\s",operators=["=","!=",">=","<=",">","<","^=","$=","~=","|=","*="],keyBlacklist=",()"+escapeForRegExp("[")+escapeForRegExp("]")+"=\\s",keyBlacklistCharacterClass=`[^${keyBlacklist}]`,KEY_CHARACTER_REG_EXP=new RegExp(keyBlacklistCharacterClass),EXACT_KEY_REG_EXP=new RegExp(`^${keyBlacklistCharacterClass}+$`),OPERATORS_REG_EXP=new RegExp(operators.map(escapeForRegExp).join("|")),REPLACE_REG_EXP=/\$([\d]+)/,RANGE_FILTER_REG_EXP=/^(\d*):(\d*)$/,parse=function(e,t=[]){let r={mask:[]};const E=[r];let s,n="",a="",i="",l="",o="";for(let c=0;c<e.length+1;c++){const R=e.charAt(c);if(s){if(a=a.trim(),","===R||"]"===R){const e=a.match(RANGE_FILTER_REG_EXP),E=a.match(OPERATORS_REG_EXP),n=a.match(EXACT_KEY_REG_EXP);if(e)i=e[1],o=":",l=e[2];else if(E)i=a.substring(0,E.index),o=E[0],l=a.substring(E.index+o.length);else{if(!n)throw new SyntaxError(`syntax error: \`${a}\` contains characters not valid in a filter`);i=n[0]}a="";const c={};if(i){const e=i.match(REPLACE_REG_EXP);i=e?t[+e[1]]:normalize(i),c.left=i}if(o&&(c.op=o),l){const e=l.match(REPLACE_REG_EXP);l=e?t[+e[1]]:normalize(l),c.right=l}if(("left"in c||"right"in c)&&s.push(c),l="",i="",o="","]"===R){if(s.length){(r.filters||(r.filters=[])).push(s)}s=null}continue}a+=R}else{if(R&&KEY_CHARACTER_REG_EXP.test(R))n+=R;else if(!n||R&&","!==R&&"("!==R&&"["!==R&&")"!==R){if(R&&n)throw new SyntaxError(`syntax error: \`${R}\` is not a valid character in a key`)}else{const e=n.match(REPLACE_REG_EXP);E[0].mask.push(r={key:e?t[+e[1]]:normalize(n)}),n=""}"("===R?(r.mask=[],E.unshift(r)):")"===R&&E.shift(),"["===R&&(s=[])}}if(1!==E.length)throw new SyntaxError("syntax error");return E[0]};module.exports=parse;

},{}],196:[function(require,module,exports){
"use strict";const defer=require("../../../libs/prime/defer"),isInteger=function(t){return"number"==typeof t&&t%1==0},slice=Array.prototype.slice,_throttle=function(t,e,r){let n,o,i;return function(){return o=arguments,n||(n=!0,i=e(function(e){n=!1,t.apply(r,slice.call(o).concat(e))})),i}},throttle=function(t,e,r){return"number"==typeof(n=e)&&n%1==0?throttle.timeout(t,e,r):throttle.immediate(t,e);var n};throttle.timeout=function(t,e,r){return _throttle(t,function(t){return defer.timeout(t,e,r)},r)},throttle.immediate=function(t,e){return _throttle(t,function(t){return defer.immediate(t,e)},e)},module.exports=throttle;

},{"../../../libs/prime/defer":225}],197:[function(require,module,exports){
(function (global){
"use strict";let namespace,windowSpace=global;function getNamespace(){return namespace||(namespace=`${windowSpace.__spotify.app_uri.split(":")[2]}:${encodeURIComponent(windowSpace.__spotify.username)}:`),namespace}function set(e,a){const t=getNamespace()+e;try{windowSpace.localStorage.setItem(t,a)}catch(e){if("QuotaExceededError"!==e.name)throw e}}function get(e){return windowSpace.localStorage.getItem(getNamespace()+e)}function remove(e){return windowSpace.localStorage.removeItem(getNamespace()+e)}function clear(){namespace=getNamespace(),Object.keys(windowSpace.localStorage).forEach(e=>{e.startsWith(namespace)&&delete windowSpace.localStorage[e]})}function _setNamespace(e){namespace=e}function useTopLocalStorage(e){windowSpace=e?window.top:window,namespace=null}const storage={set:set,get:get,remove:remove,clear:clear,_setNamespace:_setNamespace,useTopLocalStorage:useTopLocalStorage};module.exports=storage;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],198:[function(require,module,exports){
"use strict";const languages=require("./languages.json");function lookup(e,u){const n=languages[e];return n&&n[u]?n[u]:e}module.exports=lookup,module.exports.all=function(){return Object.keys(languages)};

},{"./languages.json":199}],199:[function(require,module,exports){
module.exports={
  "ar": {
    "smartling": "ar"
  },
  "cs": {
    "smartling": "cs-CZ"
  },
  "de": {
    "smartling": "de-DE"
  },
  "el": {
    "smartling": "el-GR"
  },
  "en": {
    "smartling": "en-GB"
  },
  "es": {
    "smartling": "es-ES"
  },
  "es-419": {
    "moment": "es",
    "smartling": "es-LA"
  },
  "fi": {
    "smartling": "fi-FI"
  },
  "fr": {
    "smartling": "fr-FR"
  },
  "fr-CA": {
    "smartling": "fr-CA",
    "moment": "fr-ca"
  },
  "hu": {
    "smartling": "hu-HU"
  },
  "id": {
    "smartling": "id-ID"
  },
  "it": {
    "smartling": "it-IT"
  },
  "ja": {
    "smartling": "ja-JP"
  },
  "nl": {
    "smartling": "nl-NL"
  },
  "pl": {
    "smartling": "pl-PL"
  },
  "pt-BR": {
    "moment": "pt-br",
    "smartling": "pt-BR",
    "intl": "pt-PT"
  },
  "sv": {
    "smartling": "sv-SE"
  },
  "th": {
    "smartling": "th-TH"
  },
  "tr": {
    "smartling": "tr-TR"
  },
  "vi": {
    "smartling": "vi-VN"
  },
  "zh-Hant": {
    "moment": "zh-tw",
    "smartling": "zh-TW"
  },
  "ms": {
    "moment": "ms-my",
    "smartling": "ms-MY",
    "intl": "ms-MY"
  }
}

},{}],200:[function(require,module,exports){
"use strict";const schemer=require("./schemer"),cosmos=require("../../cosmos-api").default,debug=require("../../debug");let id=0;module.exports=function(e,s){const o=schemer(e,Object.assign({},{message_name:e.name,message_version:e.schema_version},s));o.fields=o.fields.map(function(e){return"string"==typeof e?e:null===e?"":JSON.stringify(e)});const r=e.name+e.schema_version,n=debug(`logger:${r}`),i=++id;n("REQ %s#%s %s",r,i,JSON.stringify(o)),cosmos.resolver.post({url:"sp://logging/v3/log",body:o},function(e,s){e?console.error(e,o):n("RES %s#%s %d",r,i,s.getStatusCode())})};

},{"../../cosmos-api":45,"../../debug":52,"./schemer":201}],201:[function(require,module,exports){
(function (Buffer){
"use strict";var _avroJs=require("avro-js"),_avroJs2=_interopRequireDefault(_avroJs);function _interopRequireDefault(e){return e&&e.__esModule?e:{default:e}}const debug=require("../../debug")("logger:");function convertType(e,r){if(Array.isArray(e.type)){const n=r[e.name];if(null===n)return;r[e.name]={};const s=e.type.filter(e=>"null"!==e)[0];"object"==typeof s?(r[e.name]={[s.type]:n},convertType(s,r[e.name])):r[e.name][s]="bytes"===s?new Buffer(n):n}else"bytes"===e.type&&(r[e.name]=new Buffer(r[e.name]))}module.exports=function(e,r){debug(e.name);const n=r.message_name,s=r.message_version,o=Object.assign({},r);if(s!==e.schema_version)throw new Error(`Invalid message version: received Message with message_version ${s} but the Schema requires version ${e.schema_version}`);const t=e.fields.map(e=>{const r=o[e.name];return void 0===r?e.default:(convertType(e,o),r)}).slice(2);return _avroJs2.default.parse(e).isValid(o,{errorHook(e,r){throw new Error(`Logger: Invalid data: ${e.join(",")}: ${r}`)}}),{message:n,version:s,fields:t}};

}).call(this,require("buffer").Buffer)
},{"../../debug":52,"avro-js":352,"buffer":359}],202:[function(require,module,exports){
"use strict";const schema=require("../schemas/AddToPlaylist3.json"),log=require("../lib/log");module.exports={schema:schema,log:log.bind(null,schema)};

},{"../lib/log":200,"../schemas/AddToPlaylist3.json":205}],203:[function(require,module,exports){
"use strict";const schema=require("../schemas/UIInteraction5.json"),log=require("../lib/log");module.exports={schema:schema,log:log.bind(null,schema)};

},{"../lib/log":200,"../schemas/UIInteraction5.json":206}],204:[function(require,module,exports){
"use strict";const schema=require("../schemas/UserDragAndDropInteraction1.json"),log=require("../lib/log");module.exports={schema:schema,log:log.bind(null,schema)};

},{"../lib/log":200,"../schemas/UserDragAndDropInteraction1.json":207}],205:[function(require,module,exports){
module.exports={
  "namespace": "com.spotify.Message",
  "type": "record",
  "name": "AddToPlaylist",
  "fields": [
    {
      "type": "string",
      "name": "message_name"
    },
    {
      "type": "int",
      "name": "message_version"
    },
    {
      "default": null,
      "doc": "Create playlist, save to collection, save to existing playlist etc.",
      "type": [
        "null",
        "string"
      ],
      "name": "intent"
    },
    {
      "default": null,
      "doc": "URI of item that was added and only the first if multiple.",
      "type": [
        "null",
        "string"
      ],
      "name": "item_uri"
    },
    {
      "default": null,
      "doc": "Number of items added.",
      "type": [
        "null",
        "string"
      ],
      "name": "number_items"
    },
    {
      "default": null,
      "doc": "What section the item where added from.",
      "type": [
        "null",
        "string"
      ],
      "name": "section"
    },
    {
      "default": null,
      "doc": "The view uri which led to add to playlist.",
      "type": [
        "null",
        "string"
      ],
      "name": "source"
    },
    {
      "default": null,
      "doc": "The action which led to add to playlist.",
      "type": [
        "null",
        "string"
      ],
      "name": "source_action"
    },
    {
      "default": null,
      "doc": "The position of playlist added to or null.",
      "type": [
        "null",
        "int"
      ],
      "name": "playlist_index"
    },
    {
      "default": null,
      "doc": "The uri of playlist added to or null.",
      "type": [
        "null",
        "string"
      ],
      "name": "playlist_uri"
    },
    {
      "default": null,
      "doc": "The total number of items displayed.",
      "type": [
        "null",
        "int"
      ],
      "name": "total_number_playlists"
    },
    {
      "default": null,
      "doc": "Unix timestamp",
      "type": [
        "null",
        "long"
      ],
      "name": "time"
    }
  ],
  "doc": "User interacted with add to playlist.",
  "schema_version": 3
}
},{}],206:[function(require,module,exports){
module.exports={
  "type": "record",
  "name": "UIInteraction",
  "namespace": "com.spotify.Message",
  "doc": "A UI interaction log",
  "fields": [
    {
      "name": "message_name",
      "type": "string"
    },
    {
      "name": "message_version",
      "type": "int"
    },
    {
      "name": "request_id",
      "type": [
        "null",
        "string"
      ],
      "doc": "Request ID from Spaces Log",
      "default": null
    },
    {
      "name": "feature_id",
      "type": [
        "null",
        "string"
      ],
      "doc": "A name for a feature (e.g., browse-new-releases, collection, etc.)",
      "default": null
    },
    {
      "name": "pageuri",
      "type": [
        "null",
        "string"
      ],
      "doc": "Uri of the page within the feature (e.g., spotify:hub:music, etc.)",
      "default": null
    },
    {
      "name": "section_id",
      "type": [
        "null",
        "string"
      ],
      "doc": "Section or block of the page (e.g., Early Morning)",
      "default": null
    },
    {
      "name": "item_index",
      "type": [
        "null",
        "int"
      ],
      "doc": "Index of item in block",
      "default": null
    },
    {
      "name": "target_uri",
      "type": [
        "null",
        "string"
      ],
      "doc": "Destination of interaction",
      "default": null
    },
    {
      "name": "interaction_type",
      "type": [
        "null",
        "string"
      ],
      "doc": "Type of interaction (e.g., hit, swipe, hold, hover, etc.)",
      "default": null
    },
    {
      "name": "user_intent",
      "type": [
        "null",
        "string"
      ],
      "doc": "Grouping of interactions based on user intent (e.g., play, navigate-forward, navigate-back)",
      "default": null
    },
    {
      "name": "timestamp",
      "type": [
        "null",
        "double"
      ],
      "doc": "Unix timestamp of event",
      "default": null
    }
  ],
  "schema_version": 5
}
},{}],207:[function(require,module,exports){
module.exports={
  "type": "record",
  "name": "UserDragAndDropInteraction",
  "namespace": "com.spotify.Message",
  "doc": "Logged whenever a user drags and drops (currently desktop only) an item in the client. Only completed drag and drops are logged and not canceled/failed ones.",
  "fields": [
    {
      "name": "message_name",
      "type": "string"
    },
    {
      "name": "message_version",
      "type": "int"
    },
    {
      "name": "item_type",
      "type": [
        "null",
        "string"
      ],
      "doc": "Type of item, eg \"track\".",
      "default": null
    },
    {
      "name": "item_uri",
      "type": [
        "null",
        "string"
      ],
      "doc": "Uri of item that was dropped and only the first if multiple.",
      "default": null
    },
    {
      "name": "number_items",
      "type": [
        "null",
        "long"
      ],
      "doc": "Number of items dropped.",
      "default": null
    },
    {
      "name": "source_view_uri",
      "type": [
        "null",
        "string"
      ],
      "doc": "View uri from where the drag started, eg \"spotify:app:playlist\".",
      "default": null
    },
    {
      "name": "source_uri",
      "type": [
        "null",
        "string"
      ],
      "doc": "Uri of the context from where the drag started, eg: \"spotify:user:spotify:playlist:1m6DKwKNM1YLcm3OX6RzJg\".",
      "default": null
    },
    {
      "name": "source_index",
      "type": [
        "null",
        "long"
      ],
      "doc": "Index of the item from where the drag started.",
      "default": null
    },
    {
      "name": "source_component",
      "type": [
        "null",
        "string"
      ],
      "doc": "Id of the component from where the drag started, eg: \"header/title\" if the user dragged a playlist via the playlist title in the header.",
      "default": null
    },
    {
      "name": "target_view_uri",
      "type": [
        "null",
        "string"
      ],
      "doc": "View uri where the drop ended, eg \"spotify:app:zlink\".",
      "default": null
    },
    {
      "name": "target_uri",
      "type": [
        "null",
        "string"
      ],
      "doc": "Uri of the context where the drop ended, \"spotify:user:spotify:rootlist\".",
      "default": null
    },
    {
      "name": "target_index",
      "type": [
        "null",
        "long"
      ],
      "doc": "Index where dropped.",
      "default": null
    },
    {
      "name": "target_component",
      "type": [
        "null",
        "string"
      ],
      "doc": "Id of the component where the drop ended, eg: \"player/queue\" if dropped on the Queue button in the player component.",
      "default": null
    },
    {
      "name": "ms_duration",
      "type": [
        "null",
        "long"
      ],
      "doc": "The duration in milliseconds from the start of the drag until the end of the drop.",
      "default": null
    }
  ],
  "schema_version": 1
}
},{}],208:[function(require,module,exports){
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.messageProxy=messageProxy;var _debug=require("../debug"),_debug2=_interopRequireDefault(_debug),_uris=require("./uris.json"),_uris2=_interopRequireDefault(_uris);function _interopRequireDefault(e){return e&&e.__esModule?e:{default:e}}const METHODS=["POST","SUB","GET","REPLY"],BASE_URI="message-proxy",debug=(0,_debug2.default)("message-proxy");function messageProxy(e,r){if("undefined"==typeof window||!window.top||!window.top.postMessage)return!1;const t=e.uri;if(!e)throw new Error("Need a request object.");if(-1===METHODS.indexOf(e.method))throw new Error("Need a valid method:",METHODS);if(!r&&"POST"===!e.method)throw new Error("Callback needed");if(!_uris2.default.hasOwnProperty(t))throw new Error("Uri need to be one of these: ",Object.keys(_uris2.default));const o={},s=_uris2.default[t][e.method]||[];if("GET"===e.method){s.forEach(r=>{if(!e.body.hasOwnProperty(r))throw new Error(`Uri 'GET' request body missing\n                        a required key: ${r}`);o[r]=e.body[r]});const n=e=>{isEventValid(e,`${BASE_URI}-${t}-reply`)&&(debug("getListener",t,e.data),e.data.error?r(e.data.error):(delete e.data.uri,r(null,e.data)),window.removeEventListener("message",n))};return window.addEventListener("message",n),o.uri=`${BASE_URI}-${t}-get`,debug("get",t,o),postMessageToFrame(e.target,o)||(window.removeEventListener("message",n),r("No frame found to post to.")),!0}if("REPLY"===e.method){const e=e=>{isEventValid(e,`${BASE_URI}-${t}-get`)&&(debug("reply listener",t,e.data),delete e.data.uri,r(e.data,function(r,o){const n={};r?n.error=r:s.forEach(e=>{if(!o.hasOwnProperty(e))throw new Error(`Reply data missing\n                              a required key: ${e}`);n[e]=o[e]}),n.uri=`${BASE_URI}-${t}-reply`,debug("reply post",t,n),e.source.postMessage(n,e.origin)}))};return window.addEventListener("message",e,!1),()=>{window.removeEventListener("message",e)}}if("POST"===e.method){s.forEach(r=>{if(!e.body.hasOwnProperty(r))throw new Error(`Uri 'POST' request body missing\n                        a required key: ${r}`);o[r]=e.body[r]}),o.uri=`${BASE_URI}-${t}`,debug("post",t,o);const n=postMessageToFrame(e.target,o);return r&&r(n?null:"No frame found to post to."),!0}const n=e=>{isEventValid(e,`${BASE_URI}-${t}`)&&(debug("subscription event",t,e.data),r(e.data))};return debug("subscription",t),window.addEventListener("message",n,!1),()=>{window.removeEventListener("message",n)}}const originRegex=new RegExp("^https?://[a-zA-Z-]*.app.spotify.com");function isEventValid(e,r){return!!originRegex.test(e.origin)&&e.data.uri===r}function postMessageToFrame(e,r){if(("top"===e||!e)&&(debug("postMessageToFrame target=top data=%o",r),window.top.postMessage(r,"*"),"top"===e))return!0;let t,o;if(window===window.top)t=window.top.frames;else{const e=Array.prototype.slice.call(window.top.frames,0,window.top.frames.length),r=Array.prototype.slice.call(window.frames,0,window.frames.length);t=e.concat(r)}const s=t.length;for(let n=0;n<s;n++)e&&e!==t[n].frameElement.src||(debug("postMessageToFrame target=%o data=%o",t[n].frameElement.target,r),t[n].postMessage(r,"*"),o=!0);return debug("postMessageToFrame framesLength=%o frameFound=%o",s,o),o}

},{"../debug":52,"./uris.json":209}],209:[function(require,module,exports){
module.exports={
  "unit-test": {
    "GET": ["key1"],
    "POST": ["key2"],
    "REPLY": ["key3"]
  },
  "client-state": {
    "SUB": [],
    "POST": ["state"],
    "GET": [],
    "REPLY": ["state"]
  },
  "history": {
    "GET": ["count"],
    "REPLY": ["history"]
  },
  "hpto": {
    "REPLY": ["ad"],
    "GET": []
  },
  "hpto-refresh": {
    "SUB": [],
    "POST": []
  },
  "station": {
    "GET": ["stationUri", "metadata", "trackCount"],
    "REPLY": ["stationUri", "station"]
  },
  "station-add": {
    "POST": ["stationUri", "add"]
  },
  "station-autoplay": {
    "POST": ["contextUri", "playerPlaybackId", "prevTracks"],
    "SUB": []
  },
  "station-create": {
    "POST": ["stationUri"],
    "SUB": []
  },
  "station-error": {
    "POST": ["stationUri", "message"],
    "SUB": []
  },
  "station-metadata": {
    "POST": ["stationUri", "metadata"]
  },
  "station-last-played": {
    "POST": ["stationUri"]
  },
  "station-thumb": {
    "POST": ["stationUri", "trackUri", "thumb"]
  },
  "station-heart": {
    "POST": ["stationUri", "trackUri"]
  },
  "station-undo-feedback": {
    "POST": ["stationUri", "trackUri", "thumbAction"]
  },
  "stations-all": {
    "GET": [],
    "REPLY": ["user_stations", "genre_stations", "recommended_stations"]
  },
  "stations-saved": {
    "GET": [],
    "REPLY": ["saved_stations"]
  },
  "format-list-heart": {
    "POST": ["entityUri", "trackUri"]
  },
  "format-list-undo-feedback": {
    "POST": ["entityUri", "trackUri"]
  }
}

},{}],210:[function(require,module,exports){
"use strict";var _pageIdentifiers=require("./page-identifiers.js"),_pageIdentifiers2=require("./page-identifiers.json"),_pageIdentifiers3=_interopRequireDefault(_pageIdentifiers2);function _interopRequireDefault(t){return t&&t.__esModule?t:{default:t}}const UUID=require("uuid-js");function AppState(t){this._uri=void 0,void 0!==t&&this.setURI(t),this._uuid=UUID.create().toString(),this._isInitialState=!1}AppState.unserialize=function(t){const e=JSON.parse(t),i=new AppState;return i.setURI(e.uri),i},AppState.prototype.equals=function(t){return"string"==typeof this._uri&&t instanceof AppState&&this._uri===t._uri},AppState.prototype.equalsApp=function(t){const e=this.getAppId();return t&&e&&t.getAppId()===e||!1},AppState.prototype.getAppId=function(){const t=this.getURI().split(":");if(!(t.length<3)&&"app"===t[1]&&""!==t[2])return t[2]},AppState.prototype.getAppURI=function(){return this.getURI().split(":").slice(0,3).join(":")},AppState.prototype.getArgs=function(){return this.getURI().split(":").slice(3).map(function(t){return decodeURIComponent(t)})},AppState.prototype.getURI=function(){if(void 0===this._uri)throw new Error("URI not set");return this._uri},AppState.prototype.serialize=function(){return JSON.stringify({uri:this.getURI()})},AppState.prototype.setArgs=function(t){if(!Array.isArray(t))throw new TypeError("Args must be array");this._uri=this.getAppURI().split(":").concat(t.map(function(t){return encodeURIComponent(t)})).join(":")},AppState.prototype.setURI=function(t){if("string"!=typeof t)throw new TypeError("URI must be string");this._uri=t},AppState.prototype.setIsInitialState=function(t){this._isInitialState=t},AppState.prototype.getIsInitialState=function(){return this._isInitialState},AppState.prototype.getUUID=function(){return this._uuid},AppState.prototype.getPageID=function(){return(0,_pageIdentifiers.getPageIdFromUri)(this.getAppId(),this.getURI())},AppState.prototype.isPageCovered=function(){return this.getPageID()!==_pageIdentifiers3.default.unknownUncovered},module.exports=AppState;

},{"./page-identifiers.js":214,"./page-identifiers.json":213,"uuid-js":480}],211:[function(require,module,exports){
"use strict";module.exports={AppState:require("./app-state"),Navigator:require("./navigator")};

},{"./app-state":210,"./navigator":212}],212:[function(require,module,exports){
(function (global){
"use strict";const inherit=require("spotify-inheritance/inherit"),EventEmitter=require("spotify-eventemitter"),AppState=require("./app-state");function Navigator(){this._global=global.top||global,EventEmitter.call(this),this._messageHandler=this._messageHandler.bind(this)}inherit(Navigator,EventEmitter),Navigator.prototype.EVENTS=Navigator.EVENTS={REQUEST_STATE:"navigation_request_state"},Navigator.prototype.METHOD=Navigator.METHOD={OPEN:"open",TOGGLE:"toggle"},Navigator.prototype._messageHandler=function(t){if(!t.data.type)return;const e=t.data.type;if(e===Navigator.EVENTS.REQUEST_STATE){const a={state:AppState.unserialize(t.data.state),method:t.data.method};t.data.extra&&(a.extra=JSON.parse(t.data.extra)),this.emitSync(e,a)}},Navigator.prototype.attachListener=function(){this._global.addEventListener("message",this._messageHandler)},Navigator.prototype.detachListener=function(){this._global.removeEventListener("message",this._messageHandler)},Navigator.prototype.openURI=function(t,e={}){this.requestOpenState(new AppState(t),e)},Navigator.prototype.toggleURI=function(t){this.requestToggleState(new AppState(t))},Navigator.prototype.requestOpenState=function(t,e={}){this.requestState(t,this.METHOD.OPEN,e)},Navigator.prototype.requestToggleState=function(t){this.requestState(t,this.METHOD.TOGGLE)},Navigator.prototype.requestState=function(t,e,a=null){if(!t)throw new TypeError("AppState not set");if(!e)throw new TypeError("Method not set");const i={type:this.EVENTS.REQUEST_STATE,method:e,state:t.serialize()};a&&(i.extra=JSON.stringify(a)),this._global.postMessage(i,"*")},module.exports=Navigator;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./app-state":210,"spotify-eventemitter":472,"spotify-inheritance/inherit":473}],213:[function(require,module,exports){
module.exports={
  "album": "album",
  "artist": "artist",
  "artistAbout": "artist/about",
  "artistAlbums": "artist/albums",
  "artistBio": "artist/bio",
  "artistConcerts": "artist/concerts",
  "artistGallery": "artist/gallery",
  "artistPlaylists": "artist/playlists",
  "artistRelated": "artist/related",
  "artistWorks": "artist/works",
  "browse": "browse",
  "browseCharts": "browse/charts",
  "browseDiscover": "browse/discover",
  "browseGenres": "browse/genres",
  "browseNewReleases": "browse/newreleases",
  "browsePodcasts": "browse/podcasts",
  "browseVideos": "browse/videos",
  "charts": "charts",
  "chartsChart": "charts/chart",
  "chartsRegional": "charts/regional",
  "chartsSocial": "charts/social",
  "chartsViral": "charts/viral",
  "collection": "collection",
  "collectionAlbums": "collection/albums",
  "collectionAlbumsAlbum": "collection/albums/album",
  "collectionArtists": "collection/artists",
  "collectionArtistsArtist": "collection/artists/artist",
  "collectionPlaylists": "collection/playlists",
  "collectionRadio": "collection/radio",
  "collectionRecentlyPlayed": "collection/recently-played",
  "collectionShows": "collection/shows",
  "collectionSongs": "collection/songs",
  "concert": "concert",
  "concerts": "concerts",
  "concertsCitysearch": "concerts/citysearch",
  "concertsConcert": "concerts/concert",
  "debug": "debug",
  "experimentalFeatures": "experiments",
  "lyrics": "lyrics",
  "home": "home",
  "moments": "moments",
  "momentsCategory": "moments/category",
  "music": "music",
  "musicCategory": "music/category",
  "now": "now",
  "nowplaying": "nowplaying",
  "nowplayingDevicepicker": "connect/devicepicker",
  "nowplayingHistory": "nowplaying/history",
  "nowplayingQueue": "nowplaying/queue",
  "party": "party",
  "partyAddFriends": "party/add-friends",
  "partyEnableBluetooth": "party/enable-bluetooth",
  "partyEnableNearby": "party/enable-nearby",
  "partyPreset": "party/preset",
  "partyQueue": "party/queue",
  "playlist": "playlist",
  "playlistFolder": "playlist/folder",
  "profile": "profile",
  "profileActivity": "profile/activity",
  "profileArtists": "profile/artists",
  "profileFollowers": "profile/followers",
  "profileFollowing": "profile/following",
  "profilePlaylists": "profile/playlists",
  "radio": "radio",
  "radioDailyMixes": "radio/daily-mixes",
  "radioStation": "radio/station",
  "running": "running",
  "runningCategory": "running/category",
  "runningSetup": "running/setup",
  "search": "search",
  "searchAlbums": "search/albums",
  "searchArtists": "search/artists",
  "searchGenres": "search/genres",
  "searchPlaylists": "search/playlists",
  "searchProfiles": "search/profiles",
  "searchRadio": "search/radio",
  "searchShows": "search/shows",
  "searchSongs": "search/songs",
  "searchVideos": "search/videos",
  "settings": "settings",
  "show": "show",
  "shows": "shows",
  "showsAudio": "shows/audio",
  "showsCategory": "shows/category",
  "showsNetwork": "shows/network",
  "showsVideo": "shows/video",
  "song": "song",
  "unknown": "unknown",
  "unknownUncovered": "unknown/uncovered",
  "work": "work"
}

},{}],214:[function(require,module,exports){
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.getPageIdFromUri=getPageIdFromUri,exports.getPageIdFromAppArguments=getPageIdFromAppArguments;var _pageIdentifiers=require("./page-identifiers.json"),_pageIdentifiers2=_interopRequireDefault(_pageIdentifiers),_spotifyLiburi=require("spotify-liburi"),_spotifyLiburi2=_interopRequireDefault(_spotifyLiburi);function _interopRequireDefault(e){return e&&e.__esModule?e:{default:e}}const extractArg=e=>r=>r.length>e&&r[e]||null,extractHubArg=e=>"charts"===extractArg(0)(e)?`charts-${extractArg(1)(e)}`:"genre",PAGE_LOGGER_MAP={album:"album","app-manager":"debug",artist:"artist","artist-concerts":"concerts","artist-creator-about":"artistAbout","artist-overview":"artist","artist-related":"artistRelated","artist-works":"artistWorks",boilerplate:"debug",browse:"browse","browse-charts":"charts","browse-discover":"browseDiscover","browse-genres":"browseGenres","browse-home":"browse","browse-podcasts":"browsePodcasts","browse-releases":"browseNewReleases","browse-videos":"browseVideos",chart:"chartsChart",charts:"charts",collection:"collection","collection-album":"collectionAlbumsAlbum","collection-albums":"collectionAlbums","collection-artist":"collectionArtistsArtist","collection-artists":"collectionArtists","collection-podcasts":"collectionShows","collection-songs":"collectionSongs","collection-videos":"collectionShows",concert:"concert",concerts:"concerts","daily-mix-hub":"radioDailyMixes",diag:"debug",discover:"browseDiscover",experiments:"experimentalFeatures","friends-mix":"friendsMix",genre:"browseGenres","glue-grid-demo":"debug","glue-header-demo":"debug","glue-reference":"debug",home:"home","hub-charts-regional":"chartsRegional","hub-charts-viral":"chartsViral","hub-genre":"browseGenres",lyrics:"lyrics",playlist:"playlist","playlist-folder":"playlistFolder","profile-followers":"profileFollowers","profile-following":"profileFollowing","profile-overview":"profile","profile-public-playlists":"profilePlaylists","profile-recently-played-artists":"profileArtists",profile:"profile",queue:"nowplayingQueue","queue-history":"nowplayingHistory","queue-queue":"nowplayingQueue",radio:"radio","radio-hub":"radio","recently-played":"collectionRecentlyPlayed","search-albums":"searchAlbums","search-artists":"searchArtists","search-genres":"searchGenres","search-playlists":"searchPlaylists","search-profiles":"searchProfiles","search-tracks":"searchSongs","search-shows":"searchShows",search:"search",settings:"settings",show:"show",song:"song",station:"radioStation",stations:"collectionRadio","video-debug":"debug",work:"work"},EXTRACT_SECTION={browse:extractArg(0),artist:extractArg(1),profile:extractArg(1),queue:extractArg(0),search:extractArg(1),hub:extractHubArg,collection:extractArg(0)};function getPageIdFromUri(e,r){if(e in EXTRACT_SECTION){const t=_spotifyLiburi2.default.from(r);return getPageIdFromAppIdAndSection(e,EXTRACT_SECTION[e](t.args))}return getPageIdFromAppIdAndSection(e)}function getPageIdFromAppArguments(e,r){if(e in EXTRACT_SECTION){return getPageIdFromAppIdAndSection(e,EXTRACT_SECTION[e](r))}return getPageIdFromAppIdAndSection(e)}function getPageIdFromAppIdAndSection(e,r){let t=e;r&&(t=`${t}-${r}`);const o=PAGE_LOGGER_MAP[t];return _pageIdentifiers2.default[o]||_pageIdentifiers2.default.unknownUncovered}

},{"./page-identifiers.json":213,"spotify-liburi":475}],215:[function(require,module,exports){
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.PLATFORM_WINDOWS=exports.PLATFORM_MAC=exports.PLATFORM_UNKNOWN=void 0,exports._setGetTopLevelWindowFunction=_setGetTopLevelWindowFunction,exports._resetGetTopLevelWindowFunction=_resetGetTopLevelWindowFunction,exports.isMac=isMac,exports.isWindows=isWindows,exports.getPlatform=getPlatform,exports.subscribeToPlatform=subscribeToPlatform,exports.removeAllSubscriptions=removeAllSubscriptions;var _cosmosApi=require("../cosmos-api"),_cosmosApi2=_interopRequireDefault(_cosmosApi);function _interopRequireDefault(o){return o&&o.__esModule?o:{default:o}}const PLATFORM_UNKNOWN=exports.PLATFORM_UNKNOWN=Symbol("PLATFORM_UNKNOWN"),PLATFORM_MAC=exports.PLATFORM_MAC=Symbol("PLATFORM_MAC"),PLATFORM_WINDOWS=exports.PLATFORM_WINDOWS=Symbol("PLATFORM_WINDOWS");let getTopLevelWindow=()=>window.top;const originalGetTopLevelWindow=getTopLevelWindow;function _setGetTopLevelWindowFunction(o){getTopLevelWindow=o}function _resetGetTopLevelWindowFunction(){getTopLevelWindow=originalGetTopLevelWindow}const subscriptions=[];let cosmosSubscription=null;function createCosmosSubscription(){if(cosmosSubscription)return;let o=getPlatform();cosmosSubscription=_cosmosApi2.default.resolver.subscribe("sp://messages/v1/container/control",(e,t)=>{if(e)return void console.error(e);const s=t.getJSONBody();if(s){let e;switch(s.type){case"set_platform_emulation_auto":e=getPlatform();break;case"set_platform_emulation_macos":e=PLATFORM_MAC;break;case"set_platform_emulation_windows":e=PLATFORM_WINDOWS;break;case"set_platform_emulation_linux":e=PLATFORM_UNKNOWN;break;default:return}subscriptions.forEach(t=>{t(e,o)}),o=e,getTopLevelWindow()===window&&setGlobalBasedOnPlatform(o)}})}function setGlobalBasedOnPlatform(o){switch(o){case PLATFORM_MAC:window.osLibCurrentPlatformId="mac";break;case PLATFORM_WINDOWS:window.osLibCurrentPlatformId="win";break;default:window.osLibCurrentPlatformId="unknown"}}function getPlatformFromGlobal(){switch(getTopLevelWindow().osLibCurrentPlatformId){case"mac":return PLATFORM_MAC;case"win":return PLATFORM_WINDOWS;default:return PLATFORM_UNKNOWN}}function isMac(){return window.navigator.platform.startsWith("Mac")}function isWindows(){return window.navigator.platform.startsWith("Win")}function getPlatform(){return getTopLevelWindow()!==window?getPlatformFromGlobal():isMac()?PLATFORM_MAC:isWindows()?PLATFORM_WINDOWS:PLATFORM_UNKNOWN}function subscribeToPlatform(o){subscriptions.push(o);const e=getPlatform();o(e,e),getTopLevelWindow()===window&&setGlobalBasedOnPlatform(e),createCosmosSubscription()}function removeAllSubscriptions(){subscriptions.length=0,cosmosSubscription&&(cosmosSubscription.cancel(),cosmosSubscription=null)}

},{"../cosmos-api":45}],216:[function(require,module,exports){
"use strict";const player=require("./player"),play=require("./play"),playHistory=require("./play_history");exports.Play=play.Play,exports.Player=player.Player,exports.PlayHistory=playHistory.PlayHistory;

},{"./play":217,"./play_history":218,"./player":219}],217:[function(require,module,exports){
"use strict";const cosmos=require("../cosmos-api"),nodefn=require("when/node");function Play(e,t,n,o,s,i){if(!(this instanceof Play))return new Play(e,t,n,o,s,i);if(!(e&&t&&n&&o&&s))throw new TypeError("Missing parameters for Play");this._resolver=e,this._createSessionPromise=t,this._player=n,this._getTime=o,this._context=s,this._optOptions=i}Play.prototype._sessionUrl=function(){return this._createSessionPromise.then(function(e){return e.getJSONBody().session})},Play.prototype._createPlayRequest=function(e){const t={logging_params:{command_initiated_time:this._getTime()}};return new cosmos.Request(cosmos.Action.POST,`${e}/play`,null,t)},Play.prototype._createUpdateRequest=function(e,t){return t.logging_params={command_initiated_time:this._getTime()},new cosmos.Request(cosmos.Action.POST,`${e}/update`,null,t)},Play.prototype.play=function(e=(()=>{})){const t=this;this._createSessionPromise?this._sessionUrl().then(function(e){return nodefn.call(t._resolver.resolve.bind(t._resolver),t._createPlayRequest(e))}).done(function(){e(null)},function(n){if(n.response&&404===n.response.getStatusCode())t._createSessionPromise=null,t.play(e);else{const t=new Error(`Failed to prepare player session: ${n.message}`);t.cause=function(){return n},e(t)}}):this._player.play(this._context,this._optOptions,e)},Play.prototype._update=function(e,t=(()=>{})){const n=this;this._createSessionPromise?this._sessionUrl().then(function(t){return nodefn.call(n._resolver.resolve.bind(n._resolver),n._createUpdateRequest(t,e))}).done(function(){t(null)},function(e){const n=new Error(`Failed to update player session: ${e.message}`);n.cause=function(){return e},t(n)}):t(new Error("Cannot update invalidated Play"))},Play.prototype.updateContext=function(e,t){this._update({context:e},t)},Play.prototype.updatePage=function(e,t){this._update({page:e},t)},Play.prototype.updateTrack=function(e,t){this._update({track:e},t)},Play.prototype.updateViewUri=function(e,t){this._update({view_uri:e},t)},Play.prototype.invalidate=function(e=(()=>{})){if(!this._createSessionPromise)return;const t=this;this._sessionUrl().done(function(n){const o=new cosmos.Request(cosmos.Action.DELETE,n,null,null);t._resolver.resolve(o,function(){e(null)})},function(){e(null)}),this._createSessionPromise=null},exports.Play=Play;

},{"../cosmos-api":45,"when/node":499}],218:[function(require,module,exports){
"use strict";const cosmos=require("../cosmos-api"),PLAY_HISTORY_URI="sp://play-history/v1";function PlayHistory(s){if(!(this instanceof PlayHistory))return new PlayHistory(s);if(!s)throw new TypeError("Missing resolver for PlayHistory");this._resolver=s}PlayHistory.prototype.get=function(s){const o=new cosmos.Request(cosmos.Action.GET,PLAY_HISTORY_URI);return this._resolver.resolve(o,s)},PlayHistory.prototype.subscribe=function(s){const o=new cosmos.Request(cosmos.Action.SUB,PLAY_HISTORY_URI);return this._resolver.resolve(o,s)},exports.PlayHistory=PlayHistory;

},{"../cosmos-api":45}],219:[function(require,module,exports){
"use strict";const cosmos=require("../cosmos-api"),nodefn=require("when/node"),play=require("./play"),PLAYER_URI="sp://player/v2/",DEFAULT_PLAYER_ID="main";function Player(e,t,r,o,n){if(!(this instanceof Player))return new Player(e,t,r,o);if(!(e&&t&&r&&o))throw new TypeError("Missing parameters for Player");this._getTime=n&&n.getTime||function(){return(new Date).getTime()},this._id=n&&n.playerId||DEFAULT_PLAYER_ID,this._referrerIdentifier=n&&n.referrerIdentifier,this._resolver=e,this._viewUri=t,this._featureId=r,this._featureVersion=o}Player.Actions={PROBE_PLAY:"probe_play",PLAY:"play",SESSION:"session",STOP:"stop",UPDATE:"update",PAUSE:"pause",RESUME:"resume",SKIP_NEXT:"skip_next",SKIP_PREV:"skip_prev",SHUFFLE:"set_shuffling_context",REPEAT_CONTEXT:"set_repeating_context",REPEAT_TRACK:"set_repeating_track",SEEK_TO:"seek_to"},Player.prototype._playOrPrepareOrProbe=function(e,t,r,o){if(!t)throw new TypeError("Invalid `context` object");r instanceof Function&&!o&&(o=r,r=null);const n={};return n.context=t,n.play_origin=this._makePlayOrigin(),n.options=r,this._sendRequestWithParams(e,n,o)},Player.prototype.addToQueue=function(e,t){if(!e)throw new TypeError("Invalid `track` object");return this._sendRequestWithParams("add_to_queue",{track:e},t)},Player.prototype.probePlay=function(e,t,r){return this._playOrPrepareOrProbe(Player.Actions.PROBE_PLAY,e,t,r)},Player.prototype.play=function(e,t,r){return this._playOrPrepareOrProbe(Player.Actions.PLAY,e,t,r)},Player.prototype.preparePlay=function(e,t){const r=nodefn.call(this._playOrPrepareOrProbe.bind(this),Player.Actions.SESSION,e,t);return new play.Play(this._resolver,r,this,this._getTime,e,t)},Player.prototype.stop=function(e){return this._sendRequestWithAction(Player.Actions.STOP,e)},Player.prototype.update=function(e,t){if(!e)throw new TypeError("Invalid `context` object");const r={context:e};return this._sendRequestWithParams(Player.Actions.UPDATE,r,t)},Player.prototype.resume=function(e){return this._sendRequestWithAction(Player.Actions.RESUME,e)},Player.prototype.pause=function(e){return this._sendRequestWithAction(Player.Actions.PAUSE,e)},Player.prototype.skipToPrevTrack=function(e,t){1===arguments.length&&"function"==typeof e&&(t=e,e=null);const r={};return e&&(r.options=e),this._sendRequestWithParams(Player.Actions.SKIP_PREV,r,t)},Player.prototype.skipToNextTrack=function(e,t){1===arguments.length&&"function"==typeof e&&(t=e,e=null);const r={};return e&&(r.options=e),this._sendRequestWithParams(Player.Actions.SKIP_NEXT,r,t)},Player.prototype.skipToSpecificPrevTrack=function(e,t){return this._sendRequestWithParams(Player.Actions.SKIP_PREV,{track:e},t)},Player.prototype.skipToSpecificNextTrack=function(e,t){return this._sendRequestWithParams(Player.Actions.SKIP_NEXT,{track:e},t)},Player.prototype.skipToPrev=Player.prototype.skipToPrevTrack,Player.prototype.skipToNext=Player.prototype.skipToNextTrack,Player.prototype.setShufflingContext=function(e,t){return this._sendRequestWithParam(Player.Actions.SHUFFLE,e,t)},Player.prototype.setRepeatingContext=function(e,t){return this._sendRequestWithParam(Player.Actions.REPEAT_CONTEXT,e,t)},Player.prototype.setRepeatingTrack=function(e,t){return this._sendRequestWithParam(Player.Actions.REPEAT_TRACK,e,t)},Player.prototype.seekTo=function(e,t){return this._sendRequestWithParam(Player.Actions.SEEK_TO,e,t)},Player.prototype.save=function(e){const t=`${this.getPlayerEndpointUri()}/snapshot`,r=new cosmos.Request(cosmos.Action.GET,t);return this._resolver.resolve(r,e)},Player.prototype.restore=function(e,t){const r=`${this.getPlayerEndpointUri()}/snapshot`,o=new cosmos.Request(cosmos.Action.PUT,r,null,e);return this._resolver.resolve(o,t)},Player.prototype.getQueue=function(e){const t=`${this.getPlayerEndpointUri()}/queue`,r=new cosmos.Request(cosmos.Action.GET,t);return this._resolver.resolve(r,e)},Player.prototype.setQueue=function(e,t){const r=`${this.getPlayerEndpointUri()}/queue`,o=new cosmos.Request(cosmos.Action.PUT,r,null,e);return this._resolver.resolve(o,t)},Player.prototype.subscribeToQueue=function(e){const t=new cosmos.Request(cosmos.Action.SUB,`${this.getPlayerEndpointUri()}/queue`);return this._resolver.resolve(t,e)},Player.prototype.getState=function(e,t){const r=new cosmos.Request(cosmos.Action.GET,this.getPlayerEndpointUriWithParams(t));return this._resolver.resolve(r,e)},Player.prototype.subscribe=function(e,t){const r=new cosmos.Request(cosmos.Action.SUB,this.getPlayerEndpointUriWithParams(t));return this._resolver.resolve(r,e)},Player.prototype.onError=function(e){const t=new cosmos.Request(cosmos.Action.SUB,`${this.getPlayerEndpointUri()}/error`);return this._resolver.resolve(t,e)},Player.prototype._makePlayOrigin=function(){return{view_uri:this._viewUri,feature_identifier:this._featureId,feature_version:this._featureVersion,referrer_identifier:this._referrerIdentifier}},Player.prototype.getPlayerEndpointUri=function(){return PLAYER_URI+this._id},Player.prototype.getPlayerEndpointUriWithParams=function(e={}){const t=Object.keys(e).reduce(function(t,r){return t.push(`${r}=${encodeURIComponent(e[r])}`),t},[]);return t.length>0?`${this.getPlayerEndpointUri()}?${t.join("&")}`:this.getPlayerEndpointUri()},Player.prototype._sendRequestWithAction=function(e,t){return this._sendRequestWithParams(e,null,t)},Player.prototype._sendRequestWithParam=function(e,t,r){const o={value:t};return this._sendRequestWithParams(e,o,r)},Player.prototype._sendRequestWithParams=function(e,t,r){const o=`${this.getPlayerEndpointUri()}/${e}`,n=t||{};n.logging_params={command_initiated_time:this._getTime()};const s=new cosmos.Request(cosmos.Action.POST,o,null,n);return this._resolver.resolve(s,r)},exports.Player=Player;

},{"../cosmos-api":45,"./play":217,"when/node":499}],220:[function(require,module,exports){
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.getMadeForAttributionEnabled=exports.splitFeedbackUri=exports.makeFeedbackUri=void 0,exports.fetchMadeFors=fetchMadeFors,exports.fetchMadeFor=fetchMadeFor,exports.buildMadeFor=buildMadeFor,exports.originalPlaylistUri=originalPlaylistUri,exports.allowsFeedback=allowsFeedback,exports.getFeedback=getFeedback;var _spotifyLiburi=require("spotify-liburi"),_spotifyLiburi2=_interopRequireDefault(_spotifyLiburi),_bridge=require("../bridge"),_bridge2=_interopRequireDefault(_bridge),_liveWrappedUri=require("../live-wrapped-uri"),_liveWrappedUri2=_interopRequireDefault(_liveWrappedUri);function _interopRequireDefault(e){return e&&e.__esModule?e:{default:e}}function fetchMadeFors(e,r){const i=e.map(e=>fetchMadeFor(e,r));return Promise.all(i)}function fetchMadeFor(e,r){if(!e)return Promise.resolve(null);const i=e.username;if(!i)return Promise.resolve(null);let t=e.name;return t?Promise.resolve(buildMadeFor(t,i,r)):new Promise(e=>{const o=_spotifyLiburi2.default.profileURI(i).toURI();_bridge2.default.request("user_metadata",[o],(o,a)=>{t=o?i:a.name||i,e(buildMadeFor(t,i,r))})})}function buildMadeFor(e,r,i){const t=r===i;return{isCurrentUser:t,name:e,shortName:e.split(" ").shift(),username:r,renderAsYou:t&&r===e&&/^\d+$/.test(r),uri:_spotifyLiburi2.default.profileURI(r).toURI()}}function originalPlaylistUri(e){return _liveWrappedUri2.default.getOriginUri(e)||e}function allowsFeedback(e){return!!e&&"1"===e["like-feedback-available"]}function getFeedback(e){return e?"1"===e["like-feedback-selected"]?"up":"1"===e["dislike-feedback-selected"]?"down":null:null}const makeFeedbackUri=exports.makeFeedbackUri=((e,r)=>`spotify:internal:${e}:feedback:${r}`),splitFeedbackUri=exports.splitFeedbackUri=(e=>e.split("spotify:internal:").pop().split(":feedback:")),getMadeForAttributionEnabled=exports.getMadeForAttributionEnabled=(()=>window.top.initialState.madeForAttributionEnabled);

},{"../bridge":41,"../live-wrapped-uri":191,"spotify-liburi":475}],221:[function(require,module,exports){
(function (global){
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.addAlbumToPlaylist=addAlbumToPlaylist,exports.addStationToPlaylist=addStationToPlaylist,exports.addStuffToPlaylist=addStuffToPlaylist,exports.getRefreshedPlaylistData=getRefreshedPlaylistData,exports.createRefreshedPlaylist=createRefreshedPlaylist,exports.shouldPlaylistBeOffline=shouldPlaylistBeOffline,exports.getPlaylist2ShowsCell=getPlaylist2ShowsCell,exports.isPlaylist2Shows=isPlaylist2Shows,exports.resyncPlaylist=resyncPlaylist;var _spotifyLiburi=require("spotify-liburi"),_spotifyLiburi2=_interopRequireDefault(_spotifyLiburi),_bridge=require("../../libs/bridge"),_bridge2=_interopRequireDefault(_bridge),_live=require("../../libs/live"),_live2=_interopRequireDefault(_live),_playlistActions=require("./playlist-actions"),_playlistData=require("./playlist-data"),_offlineStatus=require("./offline-status"),OfflineStatus=_interopRequireWildcard(_offlineStatus),_formatLists=require("./format-lists"),formatListUtils=_interopRequireWildcard(_formatLists);function _interopRequireWildcard(t){if(t&&t.__esModule)return t;var l={};if(null!=t)for(var e in t)Object.prototype.hasOwnProperty.call(t,e)&&(l[e]=t[e]);return l.default=t,l}function _interopRequireDefault(t){return t&&t.__esModule?t:{default:t}}function addAlbumToPlaylist(t,l,e){const a=[l.toString(),0,-1];return _bridge2.default.request("album_tracks_snapshot",a,(l,a)=>{l?e(l):(0,_playlistActions.addTracksToPlaylist)(t,a.array,e)})}function addStationToPlaylist(t,l,e){(0,_live2.default)(l.toString()).query("rows(track(uri))",(l,a)=>{if(l)return void e(l);const s=a.rows.map(t=>t.track.uri);(0,_playlistActions.addTracksToPlaylist)(t,s,e)})}function addStuffToPlaylist(t,l,e){if(l[0].type===_spotifyLiburi2.default.Type.ALBUM)addAlbumToPlaylist(t,l[0],e),l.length>1&&console.warn("Passed more than a single album to addStuffToPlaylist(). Adding only one.");else if(l[0].type===_spotifyLiburi2.default.Type.STATION||l[0].type===_spotifyLiburi2.default.Type.DAILY_MIX)addStationToPlaylist(t,l[0],e);else{const a=l.map(t=>t.toString());(0,_playlistActions.addTracksToPlaylist)(t,a,e)}}function fetchPlaylistName(t,l){(0,_playlistData.fetchPlaylistMetadata)(t,{name:!0},(t,e)=>{e&&e.name?l(t,e.name):l(t)})}function getRefreshedPlaylistData(t,l){fetchPlaylistName(t,async(e,a)=>{if(e)return void l(e);const s=await(0,_playlistData.fetchPlaylistV1UriFromPlaylist)(t.toString()),i=(0,_playlistActions.refreshedPlaylistName)(a);_bridge2.default.cosmosJSON({method:"POST",uri:"hm://playlistfreshener/freshen",body:{playlistURI:s,type:"W2V_freshener"}},(t,e)=>{if(t)return void l(t);const a=e.recommendedTracks.map(t=>`spotify:track:${t.id}`);l(null,{name:i,tracks:a})})})}function createRefreshedPlaylist(t,l){getRefreshedPlaylistData(t,(t,{name:e,tracks:a}={})=>{t?l(t):(0,_playlistActions.createNewPlaylist)(e,(t,e)=>{t?l(t):(0,_playlistActions.addTracksToPlaylist)(e,a,t=>{l(t,e)})})})}function shouldPlaylistBeOffline(t,l){(0,_playlistData.fetchPlaylistMetadata)(t,{offline:!0},(t,e)=>{if(e&&e.offline){const a=OfflineStatus.shouldBeOffline(e.offline);l(t,a)}else l(t,e)})}function getPlaylist2ShowsCell(){return(global.initialState||global.top&&global.top.initialState||{}).playlist2ShowsCell||null}function isPlaylist2Shows(t){if(!("Enabled"===getPlaylist2ShowsCell()))return!1;return["format-shows","format-shows-shuffle"].includes(t)}function resyncPlaylist(t,l){const e={method:"POST",uri:`sp://core-playlist/v1/playlist/${t}/resync`};return _bridge2.default.cosmos(e,(t,e)=>{if(l)if(t)l(t);else if(200!==e.status&&204!==e.status){const t=new Error(`Cosmos Request Error. Status: ${e.status}`);t.status=e.status,l(t)}else l(null,e)})}const playlistUtils={OfflineStatus:OfflineStatus,addTracksToPlaylist:_playlistActions.addTracksToPlaylist,getCollaborativeStatus:_playlistData.getCollaborativeStatus,createNewPlaylist:_playlistActions.createNewPlaylist,createNewPlaylistBefore:_playlistActions.createNewPlaylistBefore,createNewPlaylistAfter:_playlistActions.createNewPlaylistAfter,setPlaylistCollaborative:_playlistActions.setPlaylistCollaborative,setPlaylistPublished:_playlistActions.setPlaylistPublished,logAddToPlaylist:_playlistActions.logAddToPlaylist,setPlaylistName:_playlistActions.setPlaylistName,removePlaylist:_playlistActions.removePlaylist,removePlaylistFolderRecursively:_playlistActions.removePlaylistFolderRecursively,followPlaylist:_playlistActions.followPlaylist,offlineSyncPlaylist:_playlistActions.offlineSyncPlaylist,fetchPlaylistMetadata:_playlistData.fetchPlaylistMetadata,subscribeToMetadata:_playlistData.subscribeToMetadata,fetchPlaylistV1UriFromPlaylist:_playlistData.fetchPlaylistV1UriFromPlaylist,getPlaylistV2UriFromPlaylist:_playlistData.getPlaylistV2UriFromPlaylist,fetchIsPlaylistOwnedByCurrentUser:_playlistData.fetchIsPlaylistOwnedByCurrentUser,playlistRequest:_playlistData.playlistRequest,getAvailablePlaylistName:_playlistData.getAvailablePlaylistName,formatListUtils:formatListUtils,isPlaylist2Shows:isPlaylist2Shows,getPlaylist2ShowsCell:getPlaylist2ShowsCell,addStuffToPlaylist:addStuffToPlaylist,resyncPlaylist:resyncPlaylist,createRefreshedPlaylist:createRefreshedPlaylist,shouldPlaylistBeOffline:shouldPlaylistBeOffline};exports.default=playlistUtils;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../libs/bridge":41,"../../libs/live":192,"./format-lists":220,"./offline-status":222,"./playlist-actions":223,"./playlist-data":224,"spotify-liburi":475}],222:[function(require,module,exports){
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.YES=exports.DOWNLOADING=exports.WAITING_SYNC_NOT_ALLOWED=exports.WAITING_NO_CONNECTION=exports.WAITING_OFFLINE_MODE=exports.WAITING=exports.NO=void 0,exports.isDownloading=isDownloading,exports.shouldBeOffline=shouldBeOffline,exports.progressFromStatus=progressFromStatus,exports.getLabelForStatus=getLabelForStatus,exports.sendUserMessageForStatus=sendUserMessageForStatus;var _bridge=require("../../libs/bridge"),_bridge2=_interopRequireDefault(_bridge);function _interopRequireDefault(e){return e&&e.__esModule?e:{default:e}}const NO=exports.NO="no",WAITING=exports.WAITING="waiting",WAITING_OFFLINE_MODE=exports.WAITING_OFFLINE_MODE="waitingOfflineMode",WAITING_NO_CONNECTION=exports.WAITING_NO_CONNECTION="waitingNoConnection",WAITING_SYNC_NOT_ALLOWED=exports.WAITING_SYNC_NOT_ALLOWED="waitingSyncNotAllowed",DOWNLOADING=exports.DOWNLOADING="downloading",YES=exports.YES="yes";function isDownloading(e){return e===DOWNLOADING}function shouldBeOffline(e){switch(e){case WAITING:case WAITING_OFFLINE_MODE:case WAITING_NO_CONNECTION:case DOWNLOADING:case WAITING_SYNC_NOT_ALLOWED:case YES:return!0;case NO:default:return!1}}function progressFromStatus(e){switch(e){case WAITING:case WAITING_OFFLINE_MODE:case WAITING_NO_CONNECTION:case WAITING_SYNC_NOT_ALLOWED:case NO:return 0;case YES:return 1;case DOWNLOADING:default:return}}function getLabelForStatus(e,s){switch(e){case DOWNLOADING:return"Downloading";case WAITING_OFFLINE_MODE:case WAITING_NO_CONNECTION:case WAITING_SYNC_NOT_ALLOWED:return"WaitingForConnection";case WAITING:return"WaitingForDownload";case YES:return s?"DownloadedSongs":"Downloaded";case NO:default:return s?"DownloadSongs":"Download"}}function sendUserMessageForStatus(e){switch(e){case WAITING_OFFLINE_MODE:return _bridge2.default.cosmosJSON({method:"POST",uri:"sp://messages/v1/container/user-message",body:{id:"cant-offline-sync-playlist-in-offline-mode"}}),!0;default:return!1}}

},{"../../libs/bridge":41}],223:[function(require,module,exports){
(function (global){
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.DUPLICATE_ACTIONS=void 0,exports.addTracksToPlaylist=addTracksToPlaylist,exports.setPlaylistPublished=setPlaylistPublished,exports.createNewPlaylist=createNewPlaylist,exports.createNewPlaylistBefore=createNewPlaylistBefore,exports.createNewPlaylistAfter=createNewPlaylistAfter,exports.setPlaylistName=setPlaylistName,exports.setPlaylistCollaborative=setPlaylistCollaborative,exports.followPlaylist=followPlaylist,exports.removePlaylist=removePlaylist,exports.removePlaylistFolderRecursively=removePlaylistFolderRecursively,exports.logAddToPlaylist=logAddToPlaylist,exports.refreshedPlaylistName=refreshedPlaylistName,exports.offlineSyncPlaylist=offlineSyncPlaylist;var _cosmosApi=require("../cosmos-api"),_cosmosApi2=_interopRequireDefault(_cosmosApi),_AddToPlaylist=require("../../libs/logger/messages/AddToPlaylist3"),_AddToPlaylist2=_interopRequireDefault(_AddToPlaylist),_live=require("../../libs/live"),_live2=_interopRequireDefault(_live),_bridge=require("../../libs/bridge"),_bridge2=_interopRequireDefault(_bridge),_playlistData=require("./playlist-data");function _interopRequireDefault(e){return e&&e.__esModule?e:{default:e}}const DUPLICATE_ACTIONS=exports.DUPLICATE_ACTIONS={ADD_ALL:"add_all",ADD_UNIQUE:"add_unique",CANCEL:"cancel"};function getDuplicates(e,t,l){_cosmosApi2.default.resolver.post({url:`sp://core-playlist/v1/playlist/${encodeURIComponent(e)}/contains`,body:{items:t}},function(e,o){if(e)return void l([]);const s=o.getJSONBody().found,i=[],r=[];t.forEach((e,l)=>{s[l]?i.push(t[l]):r.push(t[l])}),l(i,r)})}function maybeFilterDuplicates(e,t,l){getDuplicates(e,t,function(o,s){o.length?_cosmosApi2.default.resolver.post({url:"sp://messages/v1/avoidduplicates",body:{action:"confirm",source:global.__spotify.app_uri,playlistUri:e,numItems:t.length,numDuplicates:o.length}},function(e){if(e)return void l(t);const o=_cosmosApi2.default.resolver.subscribe({url:"sp://messages/v1/avoidduplicates"},function(e,i){if(o.cancel(),e)l(t);else switch(i.getJSONBody().action){case DUPLICATE_ACTIONS.ADD_ALL:l(t);break;case DUPLICATE_ACTIONS.ADD_UNIQUE:l(s);break;case DUPLICATE_ACTIONS.CANCEL:l([]);break;default:throw new Error("Invalid DUPLICATE_ACTION.")}})}):l(t)})}function addTracksToPlaylist(e,t,l){maybeFilterDuplicates(e,t,function(t){t.length?_cosmosApi2.default.resolver.post({url:`sp://core-playlist/v1/playlist/${encodeURIComponent(e)}`,body:{operation:"add",uris:t,after:"end"}},function(e,t){e&&t&&t.getJSONBody()&&/exceed the maximum playlist size/i.test(t.getJSONBody().error)&&_cosmosApi2.default.resolver.post({url:"sp://messages/v1/container/user-message",body:{id:"playlist-limit-exceeded"}}),e?l(e):l()}):l()})}function setPlaylistPublished(e,t,l){_bridge2.default.cosmosJSON({method:"POST",uri:"sp://core-playlist/v1/rootlist",body:{operation:"set",attributes:{published:t},rows:[e.toString()]}},l)}function createNewPlaylist(e,t){_bridge2.default.cosmosJSON({method:"POST",uri:"sp://core-playlist/v1/rootlist",body:{operation:"create",playlist:!0,before:"start",name:e}},(e,l)=>t(e,l&&l.uri))}function createNewPlaylistBefore(e,t,l){_bridge2.default.cosmosJSON({method:"POST",uri:"sp://core-playlist/v1/rootlist",body:{operation:"create",playlist:!0,before:t,name:e}},(e,t)=>l(e,t&&t.uri))}function createNewPlaylistAfter(e,t,l){_bridge2.default.cosmosJSON({method:"POST",uri:"sp://core-playlist/v1/rootlist",body:{operation:"create",playlist:!0,after:t,name:e}},(e,t)=>l(e,t&&t.uri))}function setPlaylistName(e,t,l){_bridge2.default.cosmosJSON({method:"POST",uri:`sp://core-playlist/v1/playlist/${encodeURIComponent(e)}`,body:{operation:"set",attributes:{name:t}}},(o,s)=>{o||(0,_live2.default)(e).update({name:t}),l(o,s)})}function setPlaylistCollaborative(e,t,l){_bridge2.default.cosmosJSON({method:"POST",uri:`sp://core-playlist/v1/playlist/${encodeURIComponent(e)}`,body:{operation:"set",attributes:{collaborative:t}}},(o,s)=>{o?l(o,s):t?(0,_playlistData.getCollaborativeStatus)(e,(t,o)=>{t||null===o.published?l(t||new Error("`published` property unexpectedly missing"),s):o.published?exports.setPlaylistPublished(e,!1,l):l(null,s)}):l(null,s)})}function broadcastFollowState(e,t){_bridge2.default.cosmosJSON({method:"POST",uri:"sp://messages/v1/followstate",body:{uri:e.toString(),isFollowing:t}})}function followPlaylist(e,t){_bridge2.default.cosmosJSON({method:"POST",uri:"sp://core-playlist/v1/rootlist",body:{operation:"add",before:"start",uris:[e.toString()]}},(l,o)=>{l||broadcastFollowState(e.toString(),!0),t(l,o)})}function removePlaylist(e,t){_bridge2.default.cosmosJSON({method:"POST",uri:"sp://core-playlist/v1/rootlist",body:{operation:"remove",rows:[e.toString()]}},(l,o)=>{l||broadcastFollowState(e.toString(),!1),t(l,o)})}function removePlaylistFolderRecursively(e,t){_bridge2.default.cosmosJSON({method:"POST",uri:"sp://core-playlist/v1/rootlist",body:{operation:"remove",contents:!0,rows:[e.toString()]}},t)}function logAddToPlaylist(e){let t;t=e.isNew?"create-new-playlist":e.isInFolder?"add-to-playlist-in-folder":"add-to-playlist",_AddToPlaylist2.default.log({intent:t,item_uri:e.uris[0].toURI(),number_items:e.uris.length.toString(),section:"all-playlists",source:e.appUri,source_action:"add-to-playlist",playlist_index:e.playlistIndex,playlist_uri:e.playlistUri,total_number_playlists:e.numberOfVisibleItems,time:Math.round(Date.now()/1e3)})}function refreshedPlaylistName(e){if(!e)return"Similar Playlist";const t=e.match(new RegExp("(.*)\\((\\d+)\\)$"));return t?`${t[1].trim()} (${l=t[2],parseInt(l,10)+1})`:`${e} (2)`;var l}function offlineSyncPlaylist(e,t,l){_bridge2.default.cosmos({method:t?"POST":"DELETE",uri:`sp://offline/v1/resources?uri=${e}`},l)}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../libs/bridge":41,"../../libs/live":192,"../../libs/logger/messages/AddToPlaylist3":202,"../cosmos-api":45,"./playlist-data":224}],224:[function(require,module,exports){
(function (global){
"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var _extends=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var i=arguments[t];for(var r in i)Object.prototype.hasOwnProperty.call(i,r)&&(e[r]=i[r])}return e};exports.fetchPlaylistMetadata=fetchPlaylistMetadata,exports.subscribeToMetadata=subscribeToMetadata,exports.getCollaborativeStatus=getCollaborativeStatus,exports.fetchPlaylistOwner=fetchPlaylistOwner,exports.fetchIsPlaylistOwnedByCurrentUser=fetchIsPlaylistOwnedByCurrentUser,exports.fetchPlaylistV1UriFromPlaylist=fetchPlaylistV1UriFromPlaylist,exports.getPlaylistV2UriFromPlaylist=getPlaylistV2UriFromPlaylist,exports.getCorePlaylistUrl=getCorePlaylistUrl,exports.fetchIsFormatShows=fetchIsFormatShows,exports.playlistRequest=playlistRequest,exports.getAvailablePlaylistName=getAvailablePlaylistName;var _spotifyLiburi=require("spotify-liburi"),_spotifyLiburi2=_interopRequireDefault(_spotifyLiburi),_bridge=require("../../libs/bridge"),_bridge2=_interopRequireDefault(_bridge),_liveWrappedUri=require("../../libs/live-wrapped-uri"),_liveWrappedUri2=_interopRequireDefault(_liveWrappedUri),_coreSortParams=require("../../libs/core-sort-params"),_coreSortParams2=_interopRequireDefault(_coreSortParams),_abba=require("../../libs/abba"),_abba2=_interopRequireDefault(_abba);function _interopRequireDefault(e){return e&&e.__esModule?e:{default:e}}function fetchPlaylistMetadata(e,t,i){const r=_spotifyLiburi2.default.from(e).toURI(),s=encodeURIComponent(r);_bridge2.default.cosmosJSON({method:"GET",uri:`sp://core-playlist/v1/playlist/${s}/metadata`,body:{policy:t}},(e,{error:t=null,metadata:r}={})=>i(e||t,r))}function subscribeToMetadata(e,t,i){const r=_spotifyLiburi2.default.from(e).toURI(),s=encodeURIComponent(r);return _bridge2.default.cosmosJSON({method:"SUB",uri:`sp://core-playlist/v1/playlist/${s}/metadata`,body:{policy:t}},(e,t)=>i(e,t&&t.metadata))}function getCollaborativeStatus(e,t){fetchPlaylistMetadata(e.toString(),{collaborative:!0,published:!0},t)}function isLocalFilesUri(e){return/:internal:local-files.*/.test(e)}async function fetchPlaylistOwner(e){const t=_spotifyLiburi2.default.from(e);if(t.type===_spotifyLiburi2.default.Type.PLAYLIST)return t.username;if(t.type===_spotifyLiburi2.default.Type.PLAYLIST_V2)return await new Promise((t,i)=>fetchPlaylistMetadata(e,{owner:{username:!0}},(r,{owner:{username:s}={}}={})=>{r?i(r):s?t(s):i(new Error(`No owner username found for ${e}`))}));throw new Error(`The uri ${e} is not any kind of playlist uri`)}async function fetchIsPlaylistOwnedByCurrentUser(e){return await fetchPlaylistOwner(e)===global.__spotify.username}async function fetchPlaylistV1UriFromPlaylist(e){const{type:t,id:i}=_spotifyLiburi2.default.from(e);if(t===_spotifyLiburi2.default.Type.PLAYLIST_V2){const t=await exports.fetchPlaylistOwner(e);return _spotifyLiburi2.default.playlistURI(t,i).toURI()}if(t===_spotifyLiburi2.default.Type.PLAYLIST)return e;throw new Error(`The uri ${e} is not any kind of playlist uri`)}function getPlaylistV2UriFromPlaylist(e){const{type:t,id:i}=_spotifyLiburi2.default.from(e);if(t===_spotifyLiburi2.default.Type.PLAYLIST)return _spotifyLiburi2.default.playlistV2URI(i).toURI();if(t===_spotifyLiburi2.default.Type.PLAYLIST_V2)return e;throw new Error(`The uri ${e} is not any kind of playlist uri`)}function getCorePlaylistUrl(e,{type:t,start:i,length:r,includeEpisodes:s,version:o="v1"}={},a,l){const{originUri:n=e,sort:u,filter:p}=_liveWrappedUri2.default.parse(e)||{};let y=p?p.query.split(","):[],f=!0,d=!0;isLocalFilesUri(e)||(f=!y.includes("playable eq true")&&!l,d="Enabled"===a,y=y.filter(e=>!e.startsWith("playable")&&!e.startsWith("isPremiumOnly")&&!e.startsWith("availability")));const c=_spotifyLiburi2.default.from(n).toURI();let b=isLocalFilesUri(e)?"sp://local-files/v2":`sp://core-playlist/${o}/playlist/${encodeURIComponent(c)}`;t&&(b+=`/${isLocalFilesUri(e)&&"rows"===t?"tracks":t}`);const m=[];if(u&&"metadata"!==t){const e="desc"===u.direction?"DESC":"ASC";m.push(`sort=${encodeURIComponent((0,_coreSortParams2.default)(u.query,e))}`)}return"number"==typeof i&&m.push(`start=${i}`),"number"==typeof r&&m.push(`length=${r}`),!0===s&&m.push("includeEpisodes=true"),f||m.push("showUnavailable=false"),d||m.push("alwaysShowWindowed=false"),y.length&&m.push(`filter=${y.map(encodeURIComponent).join(",")}`),"play"===t&&m.push(`uri=${encodeURIComponent(e)}`),m.length&&(b+=`?${m.join("&")}`),b}function fetchIsFormatShows(e,{includeEpisodes:t=!0}={}){return isLocalFilesUri(e)?Promise.resolve(!1):new Promise((i,r)=>{_bridge2.default.cosmosJSON({method:"GET",uri:exports.getCorePlaylistUrl(e,{type:"metadata",version:"v1",includeEpisodes:t}),body:{policy:{formatListType:!0}}},(e,t)=>{e?r(e):i(t.metadata&&/^format-shows/.test(t.metadata.formatListType))})})}function playlistRequest(e,{method:t="GET",policy:i={},body:r={},type:s,start:o,length:a,includeEpisodes:l,version:n}={},u){let p;return Promise.all([_abba2.default.fetch("windowed-playlist-show-tracklist"),exports.fetchIsFormatShows(e,{includeEpisodes:l})]).then(([y,f])=>{let d;p=_bridge2.default.cosmos({method:t,uri:exports.getCorePlaylistUrl(e,{type:s,start:o,length:a,includeEpisodes:l,version:n},y,f),body:JSON.stringify(_extends({},r,{policy:_extends({},r.policy||{},i)}))},(e,i)=>{if(e)u(e,i);else if(i&&!i.body&&i.status>=400)u(new Error(`${i.uri} responded with status ${i.status}`),i);else try{if("SUB"===t){if(i.body===d)return;d=i.body}u(null,JSON.parse(i.body))}catch(e){e.message=`Failed to parse cosmos response: ${e.message}`,u(e,i)}})}).catch(u),{cancel(){p&&p()}}}function getAvailablePlaylistName(e,t){_bridge2.default.cosmosJSON({method:"GET",uri:`sp://core-playlist/v1/rootlist?filter=${encodeURIComponent(`name startsWith ${encodeURIComponent(e)}`)}`,body:{policy:{playlist:{name:!0}}}},(i,r)=>{if(i)return void t(i);const s=r.rows.map(({name:t})=>t.substr(e.length).trim()||"1").filter(e=>/\d+/.test(e)).map(Number).sort((e,t)=>e-t).pop();t(null,`${e}${s?` ${s+1}`:""}`)})}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../libs/abba":39,"../../libs/bridge":41,"../../libs/core-sort-params":44,"../../libs/live-wrapped-uri":191,"spotify-liburi":475}],225:[function(require,module,exports){
(function (process,global){
"use strict";const now=require("mout/time/now"),forEach=require("mout/array/forEach"),indexOf=require("mout/array/indexOf"),callbacks={timeout:{},frame:[],immediate:[]},iterate=function(e){const t=now();forEach(e.splice(0),function(e){e.callback.call(e.context,t)})},push=function(e,t,a,i){e.length||i(function(){iterate(e)});const c={callback:t,context:a};return e.push(c),function(){const t=indexOf(e,c);t>-1&&e.splice(t,1)}},defer={};let clear;global.process&&process.nextTick?defer.immediate=function(e,t){return push(callbacks.immediate,e,t,process.nextTick)}:global.setImmediate?defer.immediate=function(e,t){return push(callbacks.immediate,e,t,setImmediate)}:global.postMessage&&global.addEventListener?(addEventListener("message",function(e){e.source===global&&"@deferred"===e.data&&(e.stopPropagation(),iterate(callbacks.immediate))},!0),defer.immediate=function(e,t){return push(callbacks.immediate,e,t,function(){postMessage("@deferred","*")})}):defer.immediate=function(e,t){return push(callbacks.immediate,e,t,function(e){setTimeout(e,0)})},defer.timeout=function(e,t,a){const i=callbacks.timeout;return clear||(clear=defer.immediate(function(){clear=null,callbacks.timeout={}})),push(i[t]||(i[t]=[]),e,a,function(e){setTimeout(e,t)})},module.exports=defer;

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"_process":458,"mout/array/forEach":415,"mout/array/indexOf":416,"mout/time/now":456}],226:[function(require,module,exports){
"use strict";const indexOf=require("mout/array/indexOf"),forEach=require("mout/array/forEach"),prime=require("./index"),defer=require("./defer"),slice=Array.prototype.slice;let resetCount=0;const Emitter=prime({constructor:function(e){this._stoppable=e},on:function(e,t){const i=this._listeners||(this._listeners={}),s=i[e]||(i[e]=[]);return-1===indexOf(s,t)&&s.push(t),this},off:function(e,t){const i=this._listeners;if(i){const s=i[e];if(s){const r=indexOf(s,t);r>-1&&s.splice(r,1),s.length||delete i[e];for(const e in i)if(i.hasOwnProperty(e))return this;delete this._listeners}}return this},emit:function(e){const t=slice.call(arguments,1),i=()=>{const i=this._listeners;if(i){const s=i[e];s&&forEach(s.slice(0),e=>{const i=e.apply(this,t);if(this._stoppable)return i})}if(this._promiseWaiters&&this._promiseWaiters[e]){const i=this._promiseWaiters[e].slice();this._promiseWaiters[e]=[],i.forEach(e=>e(...t))}};if(t[t.length-1]===Emitter.EMIT_SYNC)t.pop(),i();else{const e=resetCount;defer.immediate(()=>{e===resetCount&&i()})}return this},reset:function(){resetCount++,this._listeners={}},whenNextEvent:function(e){return new Promise(t=>{this._promiseWaiters=this._promiseWaiters||{},this._promiseWaiters[e]=[...this._promiseWaiters[e]||[],t]})}});Emitter.EMIT_SYNC={},module.exports=Emitter;

},{"./defer":225,"./index":227,"mout/array/forEach":415,"mout/array/indexOf":416}],227:[function(require,module,exports){
"use strict";const hasOwn=require("mout/object/hasOwn"),mixIn=require("mout/object/mixIn"),create=require("mout/lang/createObject"),kindOf=require("mout/lang/kindOf");let hasDescriptors=!0;try{Object.defineProperty({},"~",{}),Object.getOwnPropertyDescriptor({},"~")}catch(t){hasDescriptors=!1}const hasEnumBug=!{valueOf:0}.propertyIsEnumerable("valueOf"),buggy=["toString","valueOf"],verbs=/^constructor|inherits|mixin$/,implement=function(t){const e=this.prototype;for(const r in t)if(!r.match(verbs)){if(hasDescriptors){const n=Object.getOwnPropertyDescriptor(t,r);if(n){Object.defineProperty(e,r,n);continue}}e[r]=t[r]}return hasEnumBug&&buggy.forEach(r=>{const n=t[r];n!==Object.prototype[r]&&(e[r]=n)}),this},prime=function(t){let e=t;"Function"===kindOf(e)&&(e={constructor:t});const r=e.inherits;let n;if(n=hasOwn(e,"constructor")?e.constructor:r?function(){return r.apply(this,arguments)}:function(){},r){mixIn(n,r);const t=r.prototype,e=n.prototype=create(t);n.parent=t,e.constructor=n}n.implement||(n.implement=implement);let o=e.mixin;if(o){"Array"!==kindOf(o)&&(o=[o]);for(let t=0;t<o.length;t++)n.implement(create(o[t].prototype))}return n.implement(e)};module.exports=prime;

},{"mout/lang/createObject":428,"mout/lang/kindOf":438,"mout/object/hasOwn":447,"mout/object/mixIn":449}],228:[function(require,module,exports){
"use strict";const indexOf=require("mout/array/indexOf"),prime=require("./index"),Map=prime({constructor:function(){this.length=0,this._values=[],this._keys=[]},set:function(t,s){const e=indexOf(this._keys,t);return-1===e?(this._keys.push(t),this._values.push(s),this.length++):this._values[e]=s,this},get:function(t){const s=indexOf(this._keys,t);return-1===s?null:this._values[s]},count:function(){return this.length},forEach:function(t,s){for(let e=0,n=this.length;e<n&&!1!==t.call(s,this._values[e],this._keys[e],this);e++);return this},map:function(t,s){const e=new Map;return this.forEach(function(n,i){e.set(i,t.call(s,n,i,this))},this),e},filter:function(t,s){const e=new Map;return this.forEach(function(n,i){t.call(s,n,i,this)&&e.set(i,n)},this),e},every:function(t,s){let e=!0;return this.forEach(function(n,i){t.call(s,n,i,this)||(e=!1)},this),e},some:function(t,s){let e=!1;return this.forEach(function(n,i){t.call(s,n,i,this)&&(e=!0)},this),e},indexOf:function(t){const s=indexOf(this._values,t);return s>-1?this._keys[s]:null},remove:function(t){const s=indexOf(this._values,t);return-1!==s?(this._values.splice(s,1),this.length--,this._keys.splice(s,1)[0]):null},unset:function(t){const s=indexOf(this._keys,t);return-1!==s?(this._keys.splice(s,1),this.length--,this._values.splice(s,1)[0]):null},keys:function(){return this._keys.slice()},values:function(){return this._values.slice()}}),map=function(){return new Map};map.prototype=Map.prototype,module.exports=map;

},{"./index":227,"mout/array/indexOf":416}],229:[function(require,module,exports){
"use strict";const prime=require("../../libs/prime"),map=require("mout/array/map"),push_=Array.prototype.push,slice_=Array.prototype.slice,Range=prime({constructor:function(t,n){this.update(t,n)},update:function(t,n){if(null!==t&&(this.start=t),null!==n&&(this.end=n),null===this.start||null===this.end||this.start>this.end)throw new Error(`invalid range: [${this.start}, ${this.end}]`);return this.length=this.end-this.start,this},copy:function(){return new Range(this.start,this.end)},above:function(t){return!!t&&this.start>=t.end},below:function(t){return!!t&&this.end<=t.start},adjacent:function(t){return!!t&&(this.end===t.start||this.start===t.end)},intersects:function(t){return!!t&&(!this.above(t)&&!this.below(t))},contains:function(t){return!!t&&(this.start<=t.start&&this.end>=t.end)},contained:function(t){let n;if(!(n=t instanceof Range?arguments:t))return!1;for(let t=0;void 0!==n[t];t++){const e=n[t];if(e.start<=this.start&&e.end>=this.end)return!0}return!1},fits:function(t,n){return!t&&!n||(t?n?this.start>=t.end&&this.end<=n.start:this.start>=t.end:this.end<=n.start)},between:function(t,n){return t||n?t?n?this.end>t.end&&this.start<n.start?new Range(Math.max(t.end,this.start),Math.min(n.start,this.end)):null:this.end<=t.end?null:new Range(Math.max(t.end,this.start),this.end):this.start>=n.start?null:new Range(this.start,Math.min(this.end,n.start)):this.copy()},intersection:function(t){const n=[];let e;e=t instanceof Range?arguments:t;for(let t=0;t<e.length;t++){const s=e[t];if(this.below(s))break;s.intersects(this)&&n.push(new Range(Math.max(this.start,s.start),Math.min(this.end,s.end)))}return n},subtract:function(t){const n=[];let e;e=t instanceof Range?arguments:t;for(let t=-1;t<e.length;t++){const s=e[t],r=e[t+1],i=this.between(s,r);i&&n.push(i)}return n},extract:function(t){const n=t instanceof Range?slice_.call(arguments):t.slice();for(let t=0;t<n.length;t++){const e=n[t-1],s=n[t];let r=null;if(this.below(s))r=new Range(s.start-this.length,s.end-this.length);else if(this.intersects(s)){const e=s.subtract(this);2===e.length?r=new Range(e[0].start,e[1].end-this.length):1===e.length?s.end>this.end?r=new Range(e[0].start-this.length,e[0].end-this.length):this.start>s.start&&(r=new Range(e[0].start,e[0].end)):n.splice(t--,1)}else n.splice(t,1,s.copy());r&&(e&&e.end===r.start?n.splice(t---1,2,new Range(e.start,r.end)):n.splice(t,1,r))}return n},insert:function(t){const n=t instanceof Range?slice_.call(arguments):t.slice();for(let t=0;t<n.length;t++){const e=n[t];this.start>=e.end?n.splice(t,1,e.copy()):this.start>e.start&&this.start<e.end?n.splice(t,1,new Range(e.start,this.start),new Range(this.start,e.end)):n.splice(t,1,new Range(e.start+this.length,e.end+this.length))}return this.merge(n)},merge:function(t){let n,e,s;if(!(n=map(n=t instanceof Range?arguments:t,function(t){return t.copy()})).length)return[this.copy()];for(e=-1,s=n.length;e<s;e++){const t=n[e],s=n[e+1],r=this.between(t,s);r&&(!t&&s?r.end===s.start?s.update(r.start,s.end):(e++,n.unshift(r)):t&&s?t.end===r.start&&r.end===s.start?(t.update(t.start,s.end),n.splice(1+e--,1)):t.end===r.start?t.update(t.start,r.end):r.end===s.start?s.update(r.start,s.end):n.splice(e+1,0,r):t&&!s&&(t.end===r.start?t.update(t.start,r.end):(e++,n.push(r))))}return n},remove:function(t){let n;n=t instanceof Range?arguments:t;const e=[];for(let t=0;t<n.length;t++){const s=n[t].subtract(this);s.length&&push_.apply(e,s)}return e},toIndices:function(){const t=[];for(let n=this.start;n<this.end;n++)t.push(n);return t},toString:function(){return`${[this.start,this.end]}`}});Range.fromString=function(t){const n=t.split(",");return new Range(+n[0],+n[1])},Range.fromIndices=function(t){t.sort(function(t,n){return t>n?1:-1});const n=[];let e,s;for(let r=0;r<t.length;r++){for(s=e=t[r];t[r+1]-t[r]==1;)s=t[r+1],r++;n.push(new Range(e,s+1))}return n},module.exports=Range;

},{"../../libs/prime":227,"mout/array/map":418}],230:[function(require,module,exports){
(function (global){
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.install=install;var _ravenJs=require("raven-js"),_ravenJs2=_interopRequireDefault(_ravenJs),_abba=require("../abba"),_abba2=_interopRequireDefault(_abba),_productState=require("../client-state/src/product-state"),_messageProxy=require("../message-proxy"),_debug=require("../debug"),_debug2=_interopRequireDefault(_debug);function _interopRequireDefault(e){return e&&e.__esModule?e:{default:e}}const debug=(0,_debug2.default)("sentry"),dsn="https://29161b091d014a3e9abe8f73f325d46b@sentry.io/57674",SAMPLE_RATE_ABBA="sentry-desktop-sample-rate-v2",SAMPLE_RATE_FLAG="sentry-sample-rate",errorsDuringInstall=[];function install(){function e(e){return errorsDuringInstall.push(e.error),!1}return window.addEventListener("error",e),Promise.all([_getAbbaSampleRate(),_getSessionId()]).then(t=>{let r=.1*parseFloat(t[0]);const a=t[1];(0,_productState.hasFlag)(SAMPLE_RATE_FLAG)&&(r=global.__spotify.product_state[SAMPLE_RATE_FLAG]);let n="production";(0,_productState.hasValue)("ta-environment",1)?n="ta":global.__spotify&&global.__spotify.developer_mode&&(n="development");const o={sampleRate:r,environment:n,autoBreadcrumbs:{console:!1},release:_getGlobal("client_version","0.0.0"),tags:{locale:_getGlobal("locale","en"),gitRevision:_getGlobal("app_manifest",{}).GitRevision,uuid:a}};debug("config",o),_ravenJs2.default.config(dsn,o).install(),errorsDuringInstall.forEach(e=>{debug("reporting queued error",e),_ravenJs2.default.captureException(e)}),window.removeEventListener("error",e),window.addEventListener("unhandledrejection",e=>{_ravenJs2.default.captureException(e.reason)})})}function _getGlobal(e,t){return global.__spotify&&global.__spotify.hasOwnProperty(e)?global.__spotify[e]:t}function _getAbbaSampleRate(){return _abba2.default.fetch([SAMPLE_RATE_ABBA]).then(e=>e[SAMPLE_RATE_ABBA]||0).catch(()=>"spotify:app:login"===_getGlobal("app_uri")?.5:0)}function _getSessionId(){return new Promise(e=>{(0,_messageProxy.messageProxy)({method:"GET",uri:"client-state",target:"top"},(t,r)=>{e(t?0:r.state.session_uuid)})})}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../abba":39,"../client-state/src/product-state":43,"../debug":52,"../message-proxy":208,"raven-js":462}],231:[function(require,module,exports){
"use strict";const $=require("./base"),trim=require("mout/string/trim"),forEach=require("mout/array/forEach"),filter=require("mout/array/filter"),indexOf=require("mout/array/indexOf");$.implement({setAttribute:function(t,e){return this.forEach(function(s){s.setAttribute(t,e)})},getAttribute:function(t){const e=this[0].getAttributeNode(t);return e&&e.specified?e.value:null},hasAttribute:function(t){const e=this[0];if(e.hasAttribute)return e.hasAttribute(t);const s=e.getAttributeNode(t);return!(!s||!s.specified)},removeAttribute:function(t){return this.forEach(function(e){const s=e.getAttributeNode(t);s&&e.removeAttributeNode(s)})}});const accessors={};forEach(["type","value","name","href","title","id"],function(t){accessors[t]=function(e){return void 0!==e?this.forEach(function(s){s[t]=e}):this[0][t]}}),forEach(["checked","disabled","selected"],function(t){accessors[t]=function(e){return void 0!==e?this.forEach(function(s){s[t]=!!e}):!!this[0][t]}});const classes=function(t){const e=trim(t).replace(/\s+/g," ").split(" "),s={};return filter(e,function(t){return""!==t&&!s[t]&&(s[t]=t)}).sort()};accessors.className=function(t){return void 0!==t?this.forEach(function(e){e.className=classes(t).join(" ")}):classes(this[0].className).join(" ")},$.implement({attribute:function(t,e){const s=accessors[t];let n;return s&&(n=s.call(this,e)),e&&(n=this.setAttribute(t,e)),null===e&&(n=this.removeAttribute(t)),void 0===e&&(n=this.getAttribute(t)),n}}),$.implement(accessors),$.implement({check:function(){return this.checked(!0)},uncheck:function(){return this.checked(!1)},disable:function(){return this.disabled(!0)},enable:function(){return this.disabled(!1)},select:function(){return this.selected(!0)},deselect:function(){return this.selected(!1)}}),$.implement({classNames:function(){return classes(this[0].className)},hasClass:function(t){return indexOf(this.classNames(),t)>-1},addClass:function(t){return this.forEach(function(e){const s=e.className,n=classes(`${s} ${t}`).join(" ");s!==n&&(e.className=n)})},removeClass:function(t){return this.forEach(function(e){const s=classes(e.className);forEach(classes(t),function(t){const e=indexOf(s,t);e>-1&&s.splice(e,1)}),e.className=s.join(" ")})},toggleClass:function(t,e){const s=void 0!==e?e:!this.hasClass(t);return s?this.addClass(t):this.removeClass(t),!!s}}),$.prototype.toString=function(){const t=this.tag(),e=this.id(),s=this.classNames();let n=t;return e&&(n+=`#${e}`),s.length&&(n+=`.${s.join(".")}`),n};const textProperty=null===document.createElement("div").textContent?"innerText":"textContent";$.implement({tag:function(){return this[0].tagName.toLowerCase()},html:function(t){return void 0!==t?this.forEach(function(e){e.innerHTML=t}):this[0].innerHTML},text:function(t){return void 0!==t?this.forEach(function(e){e[textProperty]=t}):this[0][textProperty]},data:function(t,e){switch(e){case void 0:return this.getAttribute(`data-${t}`);case null:return this.removeAttribute(`data-${t}`);default:return this.setAttribute(`data-${t}`,e)}}}),module.exports=$;

},{"./base":232,"mout/array/filter":414,"mout/array/forEach":415,"mout/array/indexOf":416,"mout/string/trim":455}],232:[function(require,module,exports){
(function (global){
"use strict";const prime=require("../../libs/prime"),forEach=require("mout/array/forEach"),map=require("mout/array/map"),filter=require("mout/array/filter"),every=require("mout/array/every"),some=require("mout/array/some"),doc=global.document||{};let index=0;const __dc=doc.__counter,counter=doc.__counter=(__dc?parseInt(__dc,36)+1:0).toString(36),key=`uid:${counter}`,uniqueID=function(e){return e===window?"window":e===document?"document":e===document.documentElement?"html":e[key]||(e[key]=(index++).toString(36))},instances=new WeakMap,$=prime({constructor:function e(t,n){if(!t)return this&&this.constructor===e?new Elements:null;let r,i;if(t.constructor!==Elements){if(r=new Elements,"string"==typeof t)return r.search?(r[r.length++]=n||document,r.search(t)):null;if(t.nodeType||t===window)r[r.length++]=t;else if(t.length){const o={};for(let u=0,c=t.length;u<c;u++){const c=e(t[u],n);if(c&&c.length)for(let e=0,t=c.length;e<t;e++){const t=c[e];o[i=uniqueID(t)]||(r[r.length++]=t,o[i]=!0)}}}}else r=t;if(!r.length)return null;if(1===r.length){const e=instances.get(r[0]);if(e)return e;instances.set(r[0],r)}return r}}),Elements=prime({inherits:$,constructor:function(){this.length=0},unlink:function(){return this.map(function(e){return instances.delete(e),e})},forEach:function(e,t){return forEach(this,e,t),this},map:function(e,t){return map(this,e,t)},filter:function(e,t){return filter(this,e,t)},every:function(e,t){return every(this,e,t)},some:function(e,t){return some(this,e,t)}});module.exports=$;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../libs/prime":227,"mout/array/every":413,"mout/array/filter":414,"mout/array/forEach":415,"mout/array/map":418,"mout/array/some":421}],233:[function(require,module,exports){
"use strict";const Map=require("../../libs/prime/map"),$=require("./events");require("./traversal"),$.implement({delegate:function(e,t,n){return this.forEach(function(r){const o=$(r),i=o._delegation||(o._delegation={}),s=i[e]||(i[e]={}),c=s[t]||(s[t]=new Map);if(c.get(n))return;const a=function(e){const r=$(e.target||e.srcElement),i=r.matches(t)?r:r.parent(t);let s;return i&&(s=n.call(o,e,i)),s};c.set(n,a),o.on(e,a)})},undelegate:function(e,t,n){return this.forEach(function(r){const o=$(r),i=o._delegation;if(!i)return;const s=i[e];if(!s)return;const c=s[t];if(!c)return;const a=c.get(n);if(a){o.off(e,a),c.remove(a),c.count()||delete s[t];let n=!0,r=!0;for(const e in s)if(s.hasOwnProperty(e)){n=!1;break}n&&delete i[e];for(const e in i)if(i.hasOwnProperty(e)){r=!1;break}r&&delete o._delegation}})}}),module.exports=$;

},{"../../libs/prime/map":228,"./events":234,"./traversal":237}],234:[function(require,module,exports){
"use strict";const Emitter=require("../../libs/prime/emitter"),$=require("./base");$.implement({on:function(t,e,n){return this.forEach(function(r){const i=$(r),o=t+(n?":capture":"");Emitter.prototype.on.call(i,o,e);const s=i._domListeners||(i._domListeners={});if(!s[o]){const e=function(t){Emitter.prototype.emit.call(i,o,t||window.event,Emitter.EMIT_SYNC)};r.addEventListener(t,e,n||!1),s[o]=e}})},off:function(t,e,n){return this.forEach(function(r){const i=$(r),o=t+(n?":capture":""),s=i._domListeners,c=i._listeners;if(s&&c){const n=s[o];if(n&&(Emitter.prototype.off.call(i,o,e),!i._listeners||!i._listeners[t])){r.removeEventListener(t,n,!1),delete s[t];for(const t in s)if(s.hasOwnProperty(t))return;delete i._domListeners}}})},emit:function(){const t=arguments;return this.forEach(function(e){Emitter.prototype.emit.apply($(e),t)})}}),module.exports=$;

},{"../../libs/prime/emitter":226,"./base":232}],235:[function(require,module,exports){
"use strict";const $=require("./base");require("./attributes"),require("./events"),require("./insertion"),require("./traversal"),require("./delegation"),module.exports=$;

},{"./attributes":231,"./base":232,"./delegation":233,"./events":234,"./insertion":236,"./traversal":237}],236:[function(require,module,exports){
"use strict";const $=require("./base");$.implement({appendChild:function(t){return this[0].appendChild($(t)[0]),this},insertBefore:function(t,e){return this[0].insertBefore($(t)[0],$(e)[0]),this},removeChild:function(t){return this[0].removeChild($(t)[0]),this},replaceChild:function(t,e){return this[0].replaceChild($(t)[0],$(e)[0]),this}}),$.implement({before:function(t){const e=$(t)[0],n=e.parentNode;return n&&this.forEach(function(t){n.insertBefore(t,e)}),this},after:function(t){const e=$(t)[0],n=e.parentNode;return n&&this.forEach(function(t){n.insertBefore(t,e.nextSibling)}),this},bottom:function(t){const e=$(t)[0];return this.forEach(function(t){e.appendChild(t)})},top:function(t){const e=$(t)[0];return this.forEach(function(t){e.insertBefore(t,e.firstChild)})}}),$.implement({insert:$.prototype.bottom,remove:function(){return this.forEach(function(t){const e=t.parentNode;e&&e.removeChild(t)})},replace:function(t){const e=$(t)[0];return e.parentNode.replaceChild(this[0],e),this}}),module.exports=$;

},{"./base":232}],237:[function(require,module,exports){
"use strict";var _slick=require("slick"),_slick2=_interopRequireDefault(_slick);function _interopRequireDefault(t){return t&&t.__esModule?t:{default:t}}const map=require("mout/array/map"),$=require("./base"),gen=function(t,n){return map(_slick2.default.parse(n||"*"),function(n){return`${t} ${n}`}).join(", ")},push_=Array.prototype.push;$.implement({search:function(t){if(1===this.length)return $(_slick2.default.search(t,this[0],new $));let n=[];for(let e=0;e<this.length;e++){const i=this[e];push_.apply(n,_slick2.default.search(t,i))}return(n=$(n))&&n.sort()},find:function(t){if(1===this.length)return $(_slick2.default.find(t,this[0]));for(let n=0;n<this.length;n++){const e=this[n],i=_slick2.default.find(t,e);if(i)return $(i)}return null},sort:function(){return _slick2.default.sort(this)},matches:function(t){return _slick2.default.matches(this[0],t)},contains:function(t){return _slick2.default.contains(this[0],t)},nextSiblings:function(t){return this.search(gen("~",t))},nextSibling:function(t){return this.find(gen("+",t))},previousSiblings:function(t){return this.search(gen("!~",t))},previousSibling:function(t){return this.find(gen("!+",t))},children:function(t){return this.search(gen(">",t))},firstChild:function(t){return this.find(gen("^",t))},lastChild:function(t){return this.find(gen("!^",t))},parent:function(t){const n=[];for(let e=0;e<this.length;e++){let i=this[e].parentNode;for(;i&&i!==document;){if(!t||_slick2.default.matches(i,t)){n.push(i);break}i=i.parentNode}}return $(n)},parents:function(t){const n=[];for(let e=0;e<this.length;e++){let i=this[e];for(;i&&i!==document;)t&&!_slick2.default.matches(i,t)||n.push(i),i=i.parentNode}return $(n)}}),module.exports=$;

},{"./base":232,"mout/array/map":418,"slick":468}],238:[function(require,module,exports){
"use strict";const $=require("../spotify-elements"),live=require("../live"),liburi=require("spotify-liburi"),center=require("./center"),IS_ADDED_PROPERTY="added",BUTTON_SELECTOR="[data-button=add]",JUSTCHANGED_CLASSNAME="just-changed",ADDED_CLASSNAME="added",INTERACTION_INTENT_ATTR="data-interaction-intent",INTERACTION_INTENT_SAVE="save",INTERACTION_INTENT_ADD="add",INTERACTION_INTENT_REMOVE="remove",INTERACTION_INTENT_FOLLOW="follow",INTERACTION_INTENT_UNFOLLOW="unfollow",INTERACTION_TARGET_ATTR="data-interaction-target",TOGGLE_FOLLOW_STATE_BUTTON="toggle-follow-state-button",SAVE_REMOVE_BUTTON="save-remove-button",changeHandlers={};let isAttached=!1;function getAddedClass(t){const e=t[0].closest("data-class-added");return e?e.getAttribute("data-class-added"):ADDED_CLASSNAME}function getURIFromNode(t){const e=t[0].closest("[data-uri]");return e?e.getAttribute("data-uri"):null}const eventHandlers={click:function(t,e){const a=$(e[0].closest("[data-uri]"));if(!a)return;let o=a.data("uri");if(!o)return;const n=liburi.from(o);n&&(n.type===liburi.Type.COLLECTION_ALBUM?o=liburi.albumURI(n.id).toURI():n.type===liburi.Type.COLLECTION_ARTIST&&(o=liburi.artistURI(n.id).toURI()));const s=getAddedClass(e),d={added:!a.hasClass(s)};e.addClass("just-changed"),e.on("mouseout",function t(a){a.target===e[0]&&(e.off("mouseout",t),e.removeClass("just-changed"))},!0),live(o).publish(d)},changeHandler:function(t,e,a,o){if("added"===e){0===t.setStateForURI(o,a)&&(live(o).off("update",changeHandlers[o]),delete changeHandlers[o])}}},actions={setStateForURI:function(t,e){let a=0;const o=$(document).search(BUTTON_SELECTOR);if(!o)return a;for(let n=0,s=o.length;n<s;n++){const s=$(o[n]);t===getURIFromNode(s)&&(a++,actions.setStateForButtonNode(s,e))}return a},setStateForButtonNode:function(t,e){const a=$(t[0].closest("[data-uri]"));if(!a)return;const o=getAddedClass(t);actions.setVisualState(e,a,t,o)},setVisualState:function(t,e,a,o){if(t){e.hasClass(o)||e.addClass(o);const t=a.data("tooltip-remove");t&&(a.setAttribute("data-tooltip",t),a.setAttribute("aria-label",t)),a.setAttribute("data-log-click","remove-button");const n=a.getAttribute(INTERACTION_TARGET_ATTR)===TOGGLE_FOLLOW_STATE_BUTTON?"unfollow":"remove";a.setAttribute(INTERACTION_INTENT_ATTR,n)}else{e.hasClass(o)&&e.removeClass(o);const t=a.data("tooltip-add");switch(t&&(a.setAttribute("data-tooltip",t),a.setAttribute("aria-label",t)),a.getAttribute(INTERACTION_TARGET_ATTR)){case SAVE_REMOVE_BUTTON:a.setAttribute(INTERACTION_INTENT_ATTR,"save");break;case TOGGLE_FOLLOW_STATE_BUTTON:a.setAttribute(INTERACTION_INTENT_ATTR,"follow");break;default:a.setAttribute(INTERACTION_INTENT_ATTR,"add")}a.setAttribute("data-log-click","add-button")}},addListenerForNode:function(t){const e=getURIFromNode(t);if(changeHandlers[e])return void live(e).get("added",function(e,a){if(e)throw e;actions.setStateForButtonNode(t,a)},live.ASAP);changeHandlers[e]=function(t){for(const a in t){if(!t.hasOwnProperty(a))continue;const o=t[a];eventHandlers.changeHandler(actions,a,o,e)}};const a=live(e);a.get("added",function(o,n){if(o)throw o;actions.setStateForButtonNode(t,n),a.on("update",changeHandlers[e])},live.ASAP)}},update=exports.update=function(t,e){if(isAttached)if(t&&$(t).matches(BUTTON_SELECTOR))actions.addListenerForNode($(t));else{const a=($(e)||$(t)||$(document)).search(BUTTON_SELECTOR);if(!a)return;for(let t=0,e=a.length;t<e;t++)actions.addListenerForNode($(a[t]))}},handleScrollShow=function(t){update(t.pageNode,t.nodes)};exports._classNames={ADDED:ADDED_CLASSNAME,JUSTCHANGED:"just-changed"},exports.attach=function(){isAttached||(isAttached=!0,$(document).delegate("click",BUTTON_SELECTOR,eventHandlers.click),center.on("scroll-show-before",handleScrollShow))},exports.detach=function(){isAttached&&(isAttached=!1,$(document).undelegate("click",BUTTON_SELECTOR,eventHandlers.click),center.off("scroll-show-before",handleScrollShow))};

},{"../live":192,"../spotify-elements":235,"./center":246,"spotify-liburi":475}],239:[function(require,module,exports){
"use strict";const $=require("../spotify-elements"),Navigator=require("../navigation/navigator"),SELECTOR="a, button",nav=new Navigator,handleAnchorClick=function(t,e){const n=e[0],a=n.getAttribute("href")||n.getAttribute("data-button-link");a&&"#"!==a[0]&&(t.preventDefault(),nav.openURI(a))};let isAttached=!1;exports.attach=function(){isAttached||(isAttached=!0,$(document).delegate("click",SELECTOR,handleAnchorClick))},exports.detach=function(){isAttached&&(isAttached=!1,$(document).undelegate("click",SELECTOR,handleAnchorClick))},exports.update=function(){};

},{"../navigation/navigator":212,"../spotify-elements":235}],240:[function(require,module,exports){
"use strict";const modules=[require("./touch"),require("./pressed"),require("./loading"),require("./remove")];exports.attach=function(){modules.forEach(function(e){e.attach()})},exports.detach=function(){modules.forEach(function(e){e.detach()})},exports.update=function(){modules.forEach(function(e){e.update()})};

},{"./loading":241,"./pressed":242,"./remove":243,"./touch":244}],241:[function(require,module,exports){
"use strict";const CARD=".card",IMAGE_LOADING_TRANSITION=1e3;let currentCards=[];function addCardImage(t){let e;const r=t.querySelector("[data-image-url]");if(r&&(e=r.getAttribute("data-image-url")),e){const r=function(e){return()=>{t.classList.add("image-loaded"),clearTimeout(e)}},a=function(){t.classList.add("image-error")},d=setTimeout(function(){t.classList.add("image-delayed")},IMAGE_LOADING_TRANSITION),c=new Image;c.addEventListener("load",r(d)),c.addEventListener("error",a),c.src=e}}let isAttached=!1;exports.attach=function(){isAttached||(isAttached=!0)},exports.detach=function(){isAttached&&(isAttached=!1,currentCards=[])},exports.update=function(){if(!isAttached)return;currentCards=currentCards.filter(function(t){return t.closest("body")}),document.querySelectorAll(CARD).forEach(t=>{-1!==currentCards.indexOf(t)||(currentCards.push(t),addCardImage(t))})},exports._reset=function(){currentCards=[]};

},{}],242:[function(require,module,exports){
"use strict";const $=require("../../spotify-elements"),CARD="[data-card-pressed-container]",TRIGGER="[data-card-trigger-pressed-state]",doc=$(document);let pressedElement;function handleMouseDown(e,s){"button"!==e.target.nodeName.toLowerCase()&&2!==e.button&&(s[0].closest(CARD).classList.add("pressed"),pressedElement=s[0])}function handleMouseUp(e,s){s[0].closest(CARD).classList.remove("pressed"),pressedElement===s[0]&&(pressedElement=null)}function handleDragEnd(e,s){s[0].closest(CARD).classList.remove("pressed"),pressedElement===s[0]&&(pressedElement=null)}function handleDocumentMouseUp(){pressedElement&&(pressedElement.closest(CARD).classList.remove("pressed"),pressedElement=null)}let isAttached=!1;exports.attach=function(){isAttached||(isAttached=!0,doc.delegate("mousedown",TRIGGER,handleMouseDown),doc.delegate("mouseup",TRIGGER,handleMouseUp),doc.delegate("dragend",TRIGGER,handleDragEnd),doc.on("mouseup",handleDocumentMouseUp))},exports.detach=function(){isAttached&&(isAttached=!1,doc.undelegate("mousedown",TRIGGER,handleMouseDown),doc.undelegate("mouseup",TRIGGER,handleMouseUp),doc.undelegate("dragend",TRIGGER,handleDragEnd),doc.off("mouseup",handleDocumentMouseUp))},exports.update=function(){};

},{"../../spotify-elements":235}],243:[function(require,module,exports){
"use strict";const center=require("../center"),BUTTON="[data-card-remove-button]";function handleClick(t){const e=t.target;if(!e.matches(BUTTON))return;const c=e.closest("[data-uri]");if(!c)return;const n=c.getAttribute("data-uri");center.emit("card-remove",{uri:n,element:e}),t.preventDefault(),t.stopPropagation()}let isAttached=!1;exports.attach=function(){isAttached||(isAttached=!0,document.addEventListener("click",handleClick,!0))},exports.detach=function(){isAttached&&(isAttached=!1,document.removeEventListener("click",handleClick,!0))},exports.update=function(){};

},{"../center":246}],244:[function(require,module,exports){
"use strict";const $=require("../../spotify-elements"),CARD=".card",IMAGE_HIT_AREA=".card-image-hit-area",doc=$(document);let hoverActive=!1,touchArray=[];const addEvent=function(e){touchArray.push(e)};function getCards(){return doc.search(CARD)}function isCard(e){return"function"==typeof e.closest&&!!e.closest(CARD)}function handleEvent(e){const t=e.target;if(isCard(t))switch(e.type){case"touchstart":addEvent(e),hoverActive&&disableHover();break;case"touchmove":addEvent(e);break;case"touchend":t&&1===touchArray.length&&"touchstart"===touchArray[0].type&&(e.preventDefault(),t.click()),touchArray=[];break;case"contextmenu":addEvent(e);break;case"mousemove":hoverActive||enableHover()}}function disableHover(){const e=getCards();e&&(e.forEach(function(e){const t=$(e).find(IMAGE_HIT_AREA);t&&t.addClass("no-hover")}),hoverActive=!1)}function enableHover(){const e=getCards();e&&(e.forEach(function(e){const t=$(e).find(IMAGE_HIT_AREA);t&&t.removeClass("no-hover")}),hoverActive=!0)}let isAttached=!1;exports.attach=function(){isAttached||(isAttached=!0,doc.on("touchstart",handleEvent),doc.on("touchmove",handleEvent),doc.on("touchend",handleEvent),doc.on("mousemove",handleEvent),doc.on("contextmenu",handleEvent))},exports.detach=function(){isAttached&&(isAttached=!1,doc.off("touchstart",handleEvent),doc.off("touchmove",handleEvent),doc.off("touchend",handleEvent),doc.off("mousemove",handleEvent),doc.off("contextmenu",handleEvent))},exports.update=function(){},exports._reset=function(){hoverActive=!0};

},{"../../spotify-elements":235}],245:[function(require,module,exports){
(function (global){
"use strict";const $=require("../spotify-elements"),doc=$(document),win=$(window),carouselPosition=function(t){return t.style.left||"0"},getCarouselObjectsWidth=function(t){const e=t.children;return e?{itemWidth:parseFloat(global.getComputedStyle(e[0]).width),carouselInnerWidth:parseFloat(global.getComputedStyle(t).width),carouselTotalWidth:t.scrollWidth}:null},calculateMinLeftPixels=function(t){let e=0;const a=getCarouselObjectsWidth(t);if(!a)return e;const n=Math.round(a.carouselInnerWidth/a.itemWidth),l=Math.round(a.carouselTotalWidth/a.itemWidth),o=Math.ceil(l/n);return e=-a.carouselInnerWidth*(o-1)},getNewPageInPercent=function(t,e,a){const n=e.clientWidth,l=calculateMinLeftPixels(e),o=t.endsWith("%"),i=parseInt(t,10);let c;return o?c=a?i+100:i-100:(c=Math.abs(i/n),0!==i||a?i===l&&a?c=-100*(c-1):(c=a?Math.floor(c):Math.ceil(c),c*=-100):c=-100),c},updateButtonStates=function(t,e){const a=$(`[data-carousel=${t}][data-button=carousel-next]`),n=$(`[data-carousel=${t}][data-button=carousel-previous]`),l=$(`[data-carousel=${t}][data-carousel-main]`),o=$(l).search("[data-carousel-inner]")[0];let i;i="number"==typeof e?e:o.style.left?parseInt(o.style.left,10):0;const c=o.clientWidth-i/100*o.clientWidth+10>o.scrollWidth;o.clientWidth===o.scrollWidth&&(o.style.left="0%"),i>=0?n.setAttribute("disabled","disabled"):n.removeAttribute("disabled"),c?a.setAttribute("disabled","disabled"):a.removeAttribute("disabled")},handleButtonClick=function(t,e){if(t.hasAttribute("disabled"))return;const a=t.data("carousel"),n=$(`[data-carousel=${a}][data-carousel-main] [data-carousel-inner]`)[0],l=carouselPosition(n);let o;if(l){o=getNewPageInPercent(l,n,e)}else o=e?0:-100;updateButtonStates(a,o),n.style.left=`${o}%`},handleClickPrevious=function(t,e){handleButtonClick(e,!0)},handleClickNext=function(t,e){handleButtonClick(e,!1)},updateAllButtons=function(t){if(t&&t.ownerDocument&&!t.ownerDocument.body.contains(t))return;const e=($(t)||doc).search("[data-carousel-main]");e&&e.forEach(function(t){updateButtonStates($(t).data("carousel"))})};let isAttached=!1;exports.update=function(t){isAttached&&updateAllButtons(t)},exports.attach=function(){isAttached||(isAttached=!0,doc.delegate("click","[data-button=carousel-next]",handleClickNext),doc.delegate("click","[data-button=carousel-previous]",handleClickPrevious),win.on("resize",updateAllButtons))},exports.detach=function(){isAttached&&(isAttached=!1,doc.undelegate("click","[data-button=carousel-next]",handleClickNext),doc.undelegate("click","[data-button=carousel-previous]",handleClickPrevious),win.off("resize",updateAllButtons))};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../spotify-elements":235}],246:[function(require,module,exports){
"use strict";const Emitter=require("../../libs/prime/emitter");module.exports=new Emitter;

},{"../../libs/prime/emitter":226}],247:[function(require,module,exports){
(function (global){
"use strict";const $=require("../spotify-elements"),live=require("../live"),selection=require("./selection"),wrappedUriUtils=require("../live-wrapped-uri"),cosmos=require("../cosmos-api").default,liburi=require("spotify-liburi");let getMetadataForUris;const CONTEXTMENU=["a[data-uri]","[data-contextmenu]"].join(","),makeContextMenuData=function(t,e,n,i,o){const a=[];return t.forEach(t=>{if(void 0!==t){const n=t.keys||[],i=t.indices||[];let o=e||i[0];o=void 0===o?null:o;const s=t.uri,r={uri:s,keys:n,indices:i,primaryIndex:o},u=t.origin;if(u){if(null!==o){const t=live(s).get("rows"),e=live(u.uri).get("rows");if(t&&e){const n=t.keys[o];u.primaryIndex=e.indexOf(n)}}r.origin=u}a.push(r)}}),{contexts:a,x:i,y:o,uris:n}},handleContextMenuActiveClass=function(t){const e=t.parents("[data-contextmenu-spy]"),n=$([t,e]);n.addClass("contextmenu-active"),setTimeout(()=>{const t=cosmos.resolver.subscribe({url:"sp://messages/v1/context_menu_state"},function(e,i){e||"hide"!==i.getJSONBody().state||(n.removeClass("contextmenu-active"),t.cancel())})},0)},showContextMenu=function(t){const e=global.__spotify.app_uri,n="collection"===liburi.from(e).id;if(t.appURI=e,t.entityURI=live("spotify:application").get("state")?live("spotify:application").get("state").getURI():null,getMetadataForUris)getMetadataForUris(t.uris,e=>{t.metadata=e,live("spotify:client").emit("show-context-menu",t)});else{t.metadata=[],t.uris.forEach(e=>{const i=!!n||live(e).get("added");void 0!==i&&t.metadata.push({uri:e,added:i})}),live("spotify:client").emit("show-context-menu",t)}},handleContextMenuEvent=function(t,e){t.preventDefault(),t.stopPropagation();const n=t.clientX,i=t.clientY;if(handleContextMenuActiveClass(e),"a"===e[0].tagName.toLowerCase()){const t=e.data("uri");t&&showContextMenu({uris:[t],x:n,y:i})}else{const t=e.parent("[data-list]"),o=+e.data("index");let a=!1;const s=selection.getIndicesPerList();if(t&&!(a=selection.isNodeSelected(e))){selection.clear();const e=t.getAttribute("data-uri");e&&selection.add(e,o)}const r=a&&-1!==o?selection.getUris():[e.data("uri")];showContextMenu(makeContextMenuData(s,o,r,n,i))}},handleContextMenuButton=function(t,e){let n,i=e.data("uri")||(n=e.parent("[data-uri]"))&&n.data("uri");if(!i)return;i=wrappedUriUtils.getOriginUri(i)||i;const o=(n=e.parent("[data-list][data-uri]"))&&n.data("uri"),a=(n=e.parent("[data-index]"))&&+n.data("index"),s=$(e[0].closest('[data-button="contextmenu"]')),r=(s||n||e)[0].getBoundingClientRect();let u=r.left+r.width/2,c=r.top+r.height;c>window.innerHeight&&(c=window.innerHeight-1),u>window.innerWidth&&(u=window.innerWidth-1);const d=null===a||void 0===a?null:[a];let l;if(o){if(l={uri:o},d){l.indices=d;const t=live(o).get("rows");l.keys=t?d.map(function(e){return t.keys[e]}):[]}const t=wrappedUriUtils.getOriginUri(o);if(t&&(l.origin={uri:t},d)){const e=live(o).get("rows"),n=live(t).get("rows");if(e&&n){const t=d.map(function(t){const i=e.keys[t];return n.indexOf(i)}),i=d.map(function(t){return e.keys[t]});l.origin.indices=t,l.origin.keys=i}}}showContextMenu(makeContextMenuData([l],a,[i],u,c)),handleContextMenuActiveClass(s)};let isAttached=!1;exports.attach=function(){isAttached||(isAttached=!0,$(document).delegate("contextmenu",CONTEXTMENU,handleContextMenuEvent),$(document).delegate("click","[data-button=contextmenu]",handleContextMenuButton))},exports.detach=function(){isAttached&&(isAttached=!1,$(document).undelegate("contextmenu",CONTEXTMENU,handleContextMenuEvent),$(document).undelegate("click","[data-button=contextmenu]",handleContextMenuButton))},exports.update=function(){},exports.setMetadataRequestFunction=((t=null)=>{getMetadataForUris=t});

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../cosmos-api":45,"../live":192,"../live-wrapped-uri":191,"../spotify-elements":235,"./selection":306,"spotify-liburi":475}],248:[function(require,module,exports){
"use strict";const hooks=require("../util/hooks"),QUEUE_URI="spotify:internal:queue:future";function onListDropValidation(t,o,i,a,n){const e=i.getAttribute("data-uri");e&&e===QUEUE_URI&&(-1!==n||(t.valid=!1))}function attach(){hooks.add("list-drop-validation",onListDropValidation)}function detach(){hooks.remove("list-drop-validation",onListDropValidation)}exports.attach=attach,exports.detach=detach;

},{"../util/hooks":257}],249:[function(require,module,exports){
"use strict";const $=require("../../../spotify-elements"),liburi=require("spotify-liburi"),live=require("../../../live"),intersection=require("mout/array/intersection"),hooks=require("../util/hooks"),eventModel=require("../util/eventmodel"),selection=require("../../selection"),SELECTOR_LIST="[data-list]",SELECTOR_LIST_ITEM="[data-list-item]",SELECTOR_DRAGGABLE="a, [draggable]",ATTR_TARGET="data-drop-target";let dragFolderElement=null;function onDragStart(t,e){if(e.closest("[data-glue-draggable]"))return;dragFolderElement=null;const i=selection.getUris();if(i.length>1)return;const o=i[0],n=o&&liburi.fromString(o);if(n&&n.type===liburi.Type.FOLDER){const t=selection.getNodes();for(let e=0,i=t.length;e<i;e++){const i=t[e];if(i.getAttribute("data-uri")===o){dragFolderElement=i;break}}}}function onDragEnd(){dragFolderElement=null}function onSetDragData(t,e,i){if("spotify:rootlist"!==i){let i=0;for(let t=0,o=e.length;t<o&&liburi.isPlaylistV1OrV2(e[t]);t++){live(e[t]).get("added")&&i++}i===e.length&&t.dataTransfer.setData("text/x-spotify-only-followed-playlists","")}}function onListDropValidation(t,e,i,o){if("spotify:rootlist"===i.getAttribute("data-uri")){if(hasOnlyFollowedPlaylists(e))return void(t.valid=!1);if(isInsideDraggedFolder(e,o))return void(t.valid=!1);if(isInFolderBottomHalf(e)&&("drop"!==e.type||!isMatchingTarget(e,i)))return void(t.valid=!1)}}function onTargetValidation(t,e,i){const o=i.closest(SELECTOR_LIST);if(o){if("spotify:rootlist"===o.getAttribute("data-uri")){if(hasOnlyFollowedPlaylists(e))return void(t.valid=!1);if("dragleave"!==e.type&&isMatchingTarget(e,o)){const i=getFolderNode(e);if(i)return void(isBelowMiddleOfNode(e.clientY,i)?t.valid=!0:t.valid=!1)}}}}function onGetMoveIndices(t,e,i){if("spotify:rootlist"===t){const t=i[0],o=e.get(t),n=o&&o.get("playlist"),r=n&&n.uri;if((r&&liburi.fromString(r).type)===liburi.Type.FOLDER){if(1===i.length){const o=getFolderLength(e,r,t);for(let e=1;e<=o;e++)i.push(t+e)}if(1===i.length)return void(i.length=0);const o=e.get(i[i.length-1]),n=o&&o.get("playlist");if((n&&n.uri)!==`${r}:end`)return void(i.length=0)}}}function hasOnlyFollowedPlaylists(t){return t.dataTransfer.types.indexOf("text/x-spotify-only-followed-playlists")>-1}function isInsideDraggedFolder(t,e){if(dragFolderElement){const i="below"===e?getLastRowNode():getRowNode(t);if(i){let o=+i.getAttribute("data-index");if("inside"===e&&(isBelowMiddleOfNode(t.clientY,i)||o--),isIndexInsideDraggedFolder(o))return!0}}return!1}function isInFolderBottomHalf(t){const e=getFolderNode(t);return!!e&&isBelowMiddleOfNode(t.clientY,e)}function isBelowMiddleOfNode(t,e){const i=e.getBoundingClientRect();return t>=i.top+i.height/2}function isIndexInsideDraggedFolder(t){if(!dragFolderElement)return!1;const e=live("spotify:rootlist").get("rows");if(!e)return!1;const i=dragFolderElement.getAttribute("data-uri");if(!i)return!1;const o=+dragFolderElement.getAttribute("data-index"),n=o+getFolderLength(e,i,o);return o>-1&&n>o&&t>=o&&t<=n}function isMatchingTarget(t,e){const i=t.dataTransfer.types,o=e.getAttribute(ATTR_TARGET);if(o){if(intersection(o.split("|"),i).length>0)return!0}return!1}function getFolderNode(t){const e=getRowNode(t);if(e){const t=e.getAttribute("data-uri"),i=liburi.from(t);if(i&&i.type===liburi.Type.FOLDER)return e}return null}function getRowNode(t){return t.target.closest(SELECTOR_LIST_ITEM)}function getLastRowNode(){const t=$(SELECTOR_LIST),e=t&&t[t.length-1];if(e){const t=$(e).search(SELECTOR_LIST_ITEM),i=t&&t[t.length-1];if(i)return i}return null}function getFolderLength(t,e,i){let o=t.get(i),n=o&&o.get("playlist"),r=n&&n.uri;if(r!==e)return 0;const l=`${e}:end`;let a=0;for(let e=i+1,d=t.length;e<d&&(a++,(r=(n=(o=t.get(e))&&o.get("playlist"))&&n.uri)!==l);e++);return a}function attach(){eventModel.delegate("dragstart",SELECTOR_DRAGGABLE,onDragStart),eventModel.delegate("dragend","body",onDragEnd),hooks.add("set-drag-data",onSetDragData),hooks.add("list-drop-validation",onListDropValidation),hooks.add("target-validation",onTargetValidation),hooks.add("get-move-indices",onGetMoveIndices)}function detach(){eventModel.undelegate("dragstart",SELECTOR_DRAGGABLE,onDragStart),eventModel.undelegate("dragend","body",onDragEnd),hooks.remove("set-drag-data",onSetDragData),hooks.remove("list-drop-validation",onListDropValidation),hooks.remove("target-validation",onTargetValidation),hooks.remove("get-move-indices",onGetMoveIndices)}exports.attach=attach,exports.detach=detach;

},{"../../../live":192,"../../../spotify-elements":235,"../../selection":306,"../util/eventmodel":256,"../util/hooks":257,"mout/array/intersection":417,"spotify-liburi":475}],250:[function(require,module,exports){
"use strict";const liburi=require("spotify-liburi"),sortUriUtils=require("../../../live-sort-uri"),hooks=require("../util/hooks"),eventModel=require("../util/eventmodel"),selection=require("../../selection"),SELECTOR_DRAGGABLE="a, [draggable]";let dragSelectionState=null;function onDragStart(t,i){i.closest("[data-glue-draggable]")||(dragSelectionState=selection.getIndicesPerList())}function onDragEnd(){dragSelectionState=null}function onListDropValidation(t,i,e){const a=e.getAttribute("data-uri");a&&sortUriUtils.isValid(a)&&"drop"!==i.type&&(t.valid=!1)}function onListTargetValidation(t,i){const e=i.getAttribute("data-uri");e&&sortUriUtils.isValid(e)&&(dragSelectionState?1===dragSelectionState.length&&dragSelectionState[0].uri!==e&&(t.valid=!0):t.valid=!0)}function onIsListOfTracks(t,i,e){if(sortUriUtils.isValid(e)){const i=sortUriUtils.getOriginUri(e);liburi.isPlaylistV1OrV2(i)&&(t.valid=!0)}}function attach(){eventModel.delegate("dragstart",SELECTOR_DRAGGABLE,onDragStart),eventModel.delegate("dragend","body",onDragEnd),hooks.add("list-drop-validation",onListDropValidation),hooks.add("list-target-validation",onListTargetValidation),hooks.add("is-list-of-tracks",onIsListOfTracks)}function detach(){eventModel.undelegate("dragstart",SELECTOR_DRAGGABLE,onDragStart),eventModel.undelegate("dragend","body",onDragEnd),hooks.remove("list-drop-validation",onListDropValidation),hooks.remove("list-target-validation",onListTargetValidation),hooks.remove("is-list-of-tracks",onIsListOfTracks)}exports.attach=attach,exports.detach=detach;

},{"../../../live-sort-uri":190,"../../selection":306,"../util/eventmodel":256,"../util/hooks":257,"spotify-liburi":475}],251:[function(require,module,exports){
(function (global){
"use strict";const liburi=require("spotify-liburi"),selection=require("../selection"),hooks=require("./util/hooks"),eventModel=require("./util/eventmodel"),itemText=require("./util/itemtext"),getLogContext=require("../util/get-log-context"),SELECTOR_DRAGGABLE="a, [draggable]";function onDragStart(t,e){if(e.closest("[data-glue-draggable]"))return;if(selection.isNodeSelected(e)){const r=selection.getUris();if(r.length>0){const i=selection.getIndicesPerList(),n=1===i.length?i[0]&&i[0].uri:null;setEventData(t,r,null,n||null,getLogContext(e))}}else{let r=e.getAttribute("data-uri");if(!r){const t=liburi.from(e.getAttribute("href"));r=t?t.toURI():""}const i=itemText.getForElement(e);r&&setEventData(t,[r],[i],null,getLogContext(e))}}function setEventData(t,e,r,i,n){const a=getUrlsPerMimeType(e),o=getUrlsForUris(e),s=o.join("\n"),l=getLinkHTML(e,o,r);t.dataTransfer.setData("text/uri-list",s);for(const e in a){if(!a.hasOwnProperty(e))continue;const r=a[e];t.dataTransfer.setData(e,r.join("\n"))}t.dataTransfer.setData("text/plain",s),t.dataTransfer.setData("text/html",l),i&&(t.dataTransfer.setData("text/x-spotify-data-context",i),t.dataTransfer.setData(`text/x-spotify-data-context-${i}`,"")),n&&t.dataTransfer.setData("text/x-spotify-data-log-context",n),t.dataTransfer.setData("text/x-spotify-data-app-uri",global.__spotify&&global.__spotify.app_uri||null),hooks.run("set-drag-data",t,e,i)}function getUrlsPerMimeType(t){const e={};for(let r=0,i=t.length;r<i;r++){const i=t[r],n=getMimeType(i);(e[n]||(e[n]=[])).push(getShareLink(i))}return e}function getUrlsForUris(t){const e=new Array(t.length);for(let r=0,i=t.length;r<i;r++)e[r]=getShareLink(t[r]);return e}function getShareLink(t){const e=liburi.from(t);return e?e.toOpenURL():t}function getMimeType(t){const e="text/x-spotify-",r=liburi.from(t);if(r){const t=r.type;if(t===liburi.Type.TRACK||t===liburi.Type.LOCAL)return`${e}tracks`;if(t===liburi.Type.ALBUM||t===liburi.Type.LOCAL_ALBUM)return`${e}albums`;if(t===liburi.Type.ARTIST||t===liburi.Type.LOCAL_ARTIST)return`${e}artists`;if(t===liburi.Type.USER||t===liburi.Type.PROFILE)return`${e}users`;if(t===liburi.Type.PLAYLIST||t===liburi.Type.PLAYLIST_V2)return`${e}playlists`;if(t===liburi.Type.FOLDER)return`${e}folders`;if(t===liburi.Type.STATION&&!(r.args.length>2&&"cluster"===r.args[2]))return`${e}stations`;if(t===liburi.Type.EPISODE)return`${e}episodes`}return`${e}unknown`}function getLinkHTML(t,e,r){let i="";for(let n=0,a=t.length;n<a;n++){const a=r&&r[n]||itemText.getForUri(t[n]);i+=`<a href="${e[n]}">${a}</a>`,n<t.length-1&&(i+="<br>")}return i}function attach(){eventModel.delegate("dragstart",SELECTOR_DRAGGABLE,onDragStart)}function detach(){eventModel.undelegate("dragstart",SELECTOR_DRAGGABLE,onDragStart)}exports.attach=attach,exports.detach=detach;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../selection":306,"../util/get-log-context":320,"./util/eventmodel":256,"./util/hooks":257,"./util/itemtext":258,"spotify-liburi":475}],252:[function(require,module,exports){
"use strict";const liburi=require("spotify-liburi"),defer=require("../../../libs/prime/defer"),selection=require("../selection"),eventModel=require("./util/eventmodel"),itemText=require("./util/itemtext"),i18n=require("../i18n/index"),SELECTOR_DRAGGABLE="a, [draggable]",DRAGIMAGE_POS_X=-10,DRAGIMAGE_POS_Y=-5;let dragImageElement=null,dragImageShelter=null;function onDragStart(e,t){if(t.closest("[data-glue-draggable]"))return;let r="";if(selection.isNodeSelected(t)){const e=selection.getUris();r=1===e.length?itemText.getForUri(e[0]):getLocalizedTypeFromUris(e)}else r=itemText.getForElement(t);const a=getDragImage(r);e.dataTransfer.setDragImage(a,DRAGIMAGE_POS_X,DRAGIMAGE_POS_Y),removeDragImage()}function getDragImage(e){return dragImageElement||((dragImageElement=document.createElement("div")).className="dnd-image"),dragImageShelter||((dragImageShelter=document.createElement("div")).className="dnd-image-shelter"),dragImageElement.textContent=e,document.body.appendChild(dragImageElement),document.body.appendChild(dragImageShelter),dragImageElement}function removeDragImage(){defer.immediate(function(){dragImageElement&&dragImageElement.parentNode&&dragImageElement.parentNode.removeChild(dragImageElement),dragImageShelter&&dragImageShelter.parentNode&&dragImageShelter.parentNode.removeChild(dragImageShelter)})}function getLocalizedTypeFromUris(e){let t="item";const r=liburi.from(e[0]),a=r&&r.type;if(a){t=a;for(let r=0,n=e.length;r<n;r++){const n=liburi.from(e[r]);if(!n||n.type!==a){t="item";break}}}"profile"===t&&(t="user");const n=`${t}s`;let g=i18n.get(`drag_tooltip_many_${n}`,e.length);return g===`drag_tooltip_many_${n}`&&"items"!==n&&(g=i18n.get("drag_tooltip_many_items",e.length)),g||n}function attach(){eventModel.delegate("dragstart",SELECTOR_DRAGGABLE,onDragStart)}function detach(){eventModel.undelegate("dragstart",SELECTOR_DRAGGABLE,onDragStart)}exports.attach=attach,exports.detach=detach;

},{"../../../libs/prime/defer":225,"../i18n/index":262,"../selection":306,"./util/eventmodel":256,"./util/itemtext":258,"spotify-liburi":475}],253:[function(require,module,exports){
"use strict";const dragDataModule=require("./dragdata"),dragImageModule=require("./dragimage"),targetModule=require("./target"),listModule=require("./list"),sortlistModule=require("./custom/sortlist"),rootlistModule=require("./custom/rootlist"),queueModule=require("./custom/queue");function attach(){dragDataModule.attach(),dragImageModule.attach(),targetModule.attach(),listModule.attach(),queueModule.attach(),sortlistModule.attach(),rootlistModule.attach()}function detach(){dragDataModule.detach(),dragImageModule.detach(),targetModule.detach(),listModule.detach(),queueModule.detach(),sortlistModule.detach(),rootlistModule.detach()}exports.attach=attach,exports.detach=detach,exports.update=function(){};

},{"./custom/queue":248,"./custom/rootlist":249,"./custom/sortlist":250,"./dragdata":251,"./dragimage":252,"./list":254,"./target":255}],254:[function(require,module,exports){
"use strict";const $=require("../../spotify-elements"),intersection=require("mout/array/intersection"),Range=require("../../range2"),live=require("../../live"),liburi=require("spotify-liburi"),listOperations=require("../../../libs/live-list-operations"),hooks=require("./util/hooks"),eventModel=require("./util/eventmodel"),selection=require("../selection"),SELECTOR_DROP_TARGET="[data-drop-target]",SELECTOR_LIST="[data-list]",SELECTOR_LIST_ITEM="[data-list-item]",SELECTOR_LIST_TARGET="[data-drop-target], body",SELECTOR_DRAGGABLE="a, [draggable]",ATTR_TARGET="data-drop-target";let dropIndicator=null,draggedLinkContext=null;const disabledLists={},cachedSelectionState=function(){let t={lastTime:0,lastValue:null};return{get:function(){const e=Date.now();return e-t.lastTime>500&&(t={lastValue:selection.getIndicesPerList(),lastTime:e}),t.lastValue},clear:function(){t.lastTime=0}}}();function onDragStart(t,e){if(e.closest("[data-glue-draggable]"))return;draggedLinkContext=null,cachedSelectionState.clear();const n=getMatchingTarget(t);if(n){if($(n).matches(SELECTOR_LIST)){const o=n.getAttribute("data-uri");if("a"===e.tagName.toLowerCase()&&(draggedLinkContext=o),disabledLists[o])return void t.preventDefault();const i=getRowNode(t);if(i){const e=getTargetIndex(t.clientY,i);-1!==e&&t.dataTransfer.setData("text/x-spotify-data-log-source-index",e)}}}}function onDragOver(t,e){let n=!1,o=null;const i=e===document.body;let r=null;if(r=i?getListTargetFromBody(t):getMatchingListTarget(t)){const e=i?"below":"inside";let a=-1;(o="below"===e?getLastRowFromLastList():getRowNode(t))&&(a=getTargetIndex(t.clientY,o)),validateListDrop(t,r,r.getAttribute("data-uri"),e,a)&&(i?n=!0:o&&(n=!0))}if(n)t.preventDefault(),i?showDropIndicatorBelowList(r):o&&showDropIndicatorForRow(o,t.clientY);else{hideDropIndicator();const n={valid:!1};if(r&&hooks.run("list-target-validation",n,r),n.valid)t.preventDefault();else if(!i&&r){const n={valid:!1};hooks.run("target-validation",n,t,e),n.valid||(t.dataTransfer.dropEffect="none")}}}function onDragLeave(){hideDropIndicator()}function onDragEnd(){hideDropIndicator(),draggedLinkContext=null}function onDrop(t,e){hideDropIndicator();const n=e===document.body;let o=null;if(o=n?getListTargetFromBody(t):getMatchingListTarget(t)){const e=n?"below":"inside";let i=-1;const r="below"===e?getLastRowFromLastList():getRowNode(t);r&&(i=getTargetIndex(t.clientY,r));const a=o.getAttribute("data-uri");validateListDrop(t,o,a,e,i)&&a&&(performListChangesForEvent(t,o,a,e),t.handled=!0)}}function showDropIndicatorBelowList(t){const e=t.getBoundingClientRect();showDropIndicator(e.left,e.bottom,e.width)}function showDropIndicatorForRow(t,e){const n=isBelowMiddleOfNode(e,t),o=t.getBoundingClientRect();showDropIndicator(o.left,o.top+(n?o.height:0),o.width)}function showDropIndicator(t,e,n){const o=window.pageXOffset+t,i=window.pageYOffset+e,r=n;dropIndicator||((dropIndicator=document.createElement("div")).className="tr-drag-indicator"),dropIndicator.style.left=`${o}px`,dropIndicator.style.width=`${r}px`,dropIndicator.style.top=`${i}px`,dropIndicator.parentNode||document.body.appendChild(dropIndicator)}function hideDropIndicator(){dropIndicator&&dropIndicator.parentNode&&dropIndicator.parentNode.removeChild(dropIndicator)}function performListChangesForEvent(t,e,n,o){const i=live(n).get("rows");if(!i)return;let r=0;if("below"===o){const e=getLastRowFromLastList();e&&(r=getTargetIndex(t.clientY,e))}else{const e=getRowNode(t);if(!e)return;r=getTargetIndex(t.clientY,e)}const a=t.dataTransfer.getData("text/x-spotify-data-context");a&&a===n?performMoveChanges(n,i,r):performInsertChanges(t,e,n,i,r),t.data={targetIndex:r}}function performMoveChanges(t,e,n){const o=getMoveIndices(t,e);if(0===o.length)return;const i=listOperations.getMoveOperations(o,n);0!==i.length&&(e.publish(i),temporarilyDisableList(t,e))}function performInsertChanges(t,e,n,o,i){getInsertValues(t,e,o,n,function(t,e){if(t)return;if(0===e.length)return;const r=[{type:"insert",index:i,values:e}];o.publish(r),temporarilyDisableList(n,o)})}function validateListDrop(t,e,n,o,i){const r=t.dataTransfer.types,a=`text/x-spotify-data-context-${n}`.toLowerCase();if(r.includes(a)&&!validatePotentialOperations(t,e,o))return!1;const s=e.getAttribute("data-uri");if(s&&draggedLinkContext===s)return!1;const l={valid:!0};return hooks.run("list-drop-validation",l,t,e,o,i),!!l.valid}function validatePotentialOperations(t,e,n){const o=cachedSelectionState.get();if(1===o.length){if(e.getAttribute("data-uri")!==o[0].uri)return!0;const i=Range.fromIndices(o[0].indicesWithHidden);if(1===i.length){const e=i[0];e.update(e.start,e.end+1);const o="below"===n?getLastRowFromLastList():getRowNode(t);if(o){const n=getTargetIndex(t.clientY,o);if(n>-1){if(new Range(n,n+1).contained(e))return!1}}}}return!0}function getMatchingTarget(t){let e=t.target;for(;e;){if(isMatchingTarget(t,e))return e;e=e.parentElement}return null}function getMatchingListTarget(t){let e=t.target;for(;e;){if($(e).matches(SELECTOR_LIST)&&isMatchingTarget(t,e))return e;e=e.parentElement}return null}function getListTargetFromBody(t){const e=getLastListNode();if(e){if(t.target.contains(e)&&isMatchingTarget(t,e)&&isBelowNode(t.clientX,t.clientY,e))return e}return null}function getRowNode(t){return t.target.closest(SELECTOR_LIST_ITEM)}function getLastRowFromLastList(){const t=getLastListNode();if(t){const e=$(t).search(SELECTOR_LIST_ITEM),n=e&&e[e.length-1];if(n)return n}return null}function getLastListNode(){const t=document.querySelectorAll(SELECTOR_LIST);return t&&t[t.length-1]||null}function getTargetIndex(t,e){let n=e.getAttribute("data-index");return null===n?n=-1:(n=parseInt(n,10),isNaN(n)?n=-1:isBelowMiddleOfNode(t,e)&&n++),n}function getMoveIndices(t,e){const n=selection.getIndicesPerList();if(1!==n.length)return[];const o=n[0].indices.slice();return 0===o.length?[]:(hooks.run("get-move-indices",t,e,o),o.sort(function(t,e){return t-e}),o)}function getInsertValues(t,e,n,o,i){const r=t.dataTransfer.types,a=e.getAttribute(ATTR_TARGET);if(!a)return void i(null,[]);const s=intersection(a.split("|"),r);0!==s.length?getRowsFromData(getDataFromTypes(t,s),isListOfTracks(n,o),function(t,e){t?i(t):i(null,e)}):i(null,[])}function getDataFromTypes(t,e){const n={};for(let o=0,i=e.length;o<i;o++){const i=e[o],r=n[i]=[],a=0===i.indexOf("text/x-spotify"),s=t.dataTransfer.getData(i),l=a?s.split("\n"):[s];for(let t=0,e=l.length;t<e;t++){const e=l[t];if(a){const t=liburi.from(e);t&&r.push(t.toURI())}else r.push(e)}}return n}function getRowsFromData(t,e,n){const o=[];if(t["text/x-spotify-tracks"]&&o.push(getRowObjects("track",t["text/x-spotify-tracks"])),t["text/x-spotify-albums"]){const n=t["text/x-spotify-albums"];e?o.push(fetchListTrackRows(n)):o.push(getRowObjects("album",n))}if(t["text/x-spotify-playlists"]){const n=t["text/x-spotify-playlists"];e?o.push(fetchListTrackRows(n)):o.push(getRowObjects("playlist",n))}t["text/x-spotify-artists"]&&o.push(getRowObjects("artist",t["text/x-spotify-artists"])),t["text/x-spotify-users"]&&o.push(getRowObjects("user",t["text/x-spotify-users"])),Promise.all(o).then(function(t){let e=[];e=e.concat.apply(e,t),n(null,e)},function(t){n(t)})}function fetchListTrackRows(t){const e=t.map(function(t){return new Promise(function(e,n){live(t).query("rows(track(uri))",function(t,o){if(t)return void n(t);const i=o.rows.map(function(t){return live(t)});e(i)},live.ASAP)})});return Promise.all(e).then(function(t){let e=[];return e=e.concat.apply(e,t)})}function getRowObjects(t,e){return e.map(function(e){const n={};return n[t]={uri:e},live(n)})}function isListOfTracks(t,e){if(liburi.isPlaylistV1OrV2(e))return!0;const n={valid:!1};if(hooks.run("is-list-of-tracks",n,t,e),!n.valid){const e=t.get(0);if(e&&e.get("track"))return!0}return!!n.valid}function isBelowNode(t,e,n){const o=n.getBoundingClientRect(),i=e>=o.bottom,r=t>=o.left&&t<=o.right;return i&&r}function isBelowMiddleOfNode(t,e){const n=e.getBoundingClientRect();return t>=n.top+n.height/2}function isMatchingTarget(t,e){const n=t.dataTransfer.types,o=e.getAttribute(ATTR_TARGET);if(o){if(intersection(o.split("|"),n).length>0)return!0}return!1}function temporarilyDisableList(t,e){disabledLists[t]=!0;const n=function(o){return()=>{clearTimeout(o),e.off("update",n),setTimeout(function(){delete disabledLists[t]},100)}},o=setTimeout(()=>{n(o)},500);e.on("update",n(o))}function attach(){eventModel.delegate("dragstart",SELECTOR_DRAGGABLE,onDragStart),eventModel.delegate("dragover",SELECTOR_LIST_TARGET,onDragOver),eventModel.delegate("dragleave",SELECTOR_LIST_TARGET,onDragLeave),eventModel.delegate("dragend","body",onDragEnd),eventModel.delegate("drop",SELECTOR_LIST_TARGET,onDrop)}function detach(){eventModel.undelegate("dragstart",SELECTOR_DRAGGABLE,onDragStart),eventModel.undelegate("dragover",SELECTOR_LIST_TARGET,onDragOver),eventModel.undelegate("dragleave",SELECTOR_LIST_TARGET,onDragLeave),eventModel.undelegate("dragend","body",onDragEnd),eventModel.undelegate("drop",SELECTOR_LIST_TARGET,onDrop)}exports.attach=attach,exports.detach=detach;

},{"../../../libs/live-list-operations":160,"../../live":192,"../../range2":229,"../../spotify-elements":235,"../selection":306,"./util/eventmodel":256,"./util/hooks":257,"mout/array/intersection":417,"spotify-liburi":475}],255:[function(require,module,exports){
(function (global){
"use strict";const $=require("../../spotify-elements"),liburi=require("spotify-liburi"),defer=require("../../../libs/prime/defer"),center=require("../center"),eventModel=require("./util/eventmodel"),hooks=require("./util/hooks"),getLogContext=require("../util/get-log-context"),UserDragAndDropInteraction1=require("../../logger/messages/UserDragAndDropInteraction1"),SELECTOR_DROP_TARGET="[data-drop-target]",SELECTOR_DRAGGABLE="a, [draggable]",ATTR_TARGET="data-drop-target",ATTR_TARGET_INCLUDE_TEXT="data-drop-target-include-text",ATTR_NO_CLASSNAME="data-drop-no-classname",CLASSNAME_ACTIVE="drop-target-active",TEXT_PLAIN="text/plain";let longHoldTimerId=0,longHoldTimerDuration=1e3,draggedElement=null,lastEnteredElement=null;function onDragStart(e,t){t.closest("[data-glue-draggable]")||(draggedElement=t,lastEnteredElement=null)}function onDragEnd(){draggedElement=null,lastEnteredElement=null,stopLongHoldTimer(),removeAnyActiveClass()}function onDragEnter(e,t){validateTarget(e,t)&&setEnter(e,t)}function onDragLeave(e,t){validateTarget(e,t)&&setLeave(e,t)}function onDragOver(e,t){validateTarget(e,t)?(e.preventDefault(),e.dataTransfer.dropEffect="copy",setEnter(e,t)):setLeave(e,t)}function onDrop(e,t){if(stopLongHoldTimer(),removeAnyActiveClass(),validateTarget(e,t)){const n=getMimeTypesForTarget(e,t),r=getDropData(e,n),a=e.dataTransfer.getData("text/x-spotify-data-context")||null,o=e.dataTransfer.getData("text/x-spotify-data-log-context")||null,l=e.dataTransfer.getData("text/x-spotify-data-app-uri")||null;let d=parseInt(e.dataTransfer.getData("text/x-spotify-data-log-source-index"),0);isNaN(d)&&(d=null);const i=t.closest("[data-uri]"),g=i&&i.getAttribute("data-uri")||null,s=getLogContext(t),T=global.__spotify&&global.__spotify.app_uri||null;defer.immediate(function(){center.emit("drop",{handled:e.handled,node:t,sourceUri:a,targetUri:g,data:r});const n=r[Object.keys(r)[0]][0],i=liburi.from(n).type,u=Object.keys(r).reduce(function(e,t){return e+r[t].length},0),E=e.data&&e.data.targetIndex||null;UserDragAndDropInteraction1.log({item_type:i,item_uri:n,number_items:u,source_view_uri:l,source_uri:a,source_index:d,source_component:o,target_view_uri:T,target_uri:g,target_index:E,target_component:s})})}e.preventDefault(),lastEnteredElement=null}function setEnter(e,t){if(t===lastEnteredElement)return;lastEnteredElement=t,t.hasAttribute(ATTR_NO_CLASSNAME)||$(t).addClass(CLASSNAME_ACTIVE);const n=getMimeTypesForTarget(e,t);center.emit("dragenter",{node:t,types:n}),startLongHoldTimer(t,n)}function setLeave(e,t){if(t!==lastEnteredElement)return;lastEnteredElement=null,t.hasAttribute(ATTR_NO_CLASSNAME)||$(t).removeClass(CLASSNAME_ACTIVE);const n=getMimeTypesForTarget(e,t);center.emit("dragleave",{node:t,types:n}),stopLongHoldTimer()}function validateTarget(e,t){if(t===draggedElement)return!1;if(getMimeTypesForTarget(e,t).length){const n={valid:!0};if(hooks.run("target-validation",n,e,t),n.valid)return!0}return!1}function getDropData(e,t){const n={};for(let r=0,a=t.length;r<a;r++){const a=n[t[r]]=[],o=e.dataTransfer.getData(t[r]),l=0===t[r].indexOf("text/x-spotify"),d=l?o.split("\n"):[o];for(let e=0,t=d.length;e<t;e++){let t=d[e];if(l){const e=liburi.from(t);e&&(t=e.toURI())}t&&a.push(t)}}return t.indexOf("text/x-spotify-data-context")>-1&&(n["text/x-spotify-data-context"]=[e.dataTransfer.getData("text/x-spotify-data-context")]),n}function startLongHoldTimer(e,t){longHoldTimerId||(longHoldTimerId=setTimeout(function(){center.emit("dragover-long",{node:e,types:t})},longHoldTimerDuration))}function stopLongHoldTimer(){clearTimeout(longHoldTimerId),longHoldTimerId=0}function removeAnyActiveClass(){const e=$(`.${CLASSNAME_ACTIVE}`);e&&e.removeClass(CLASSNAME_ACTIVE)}function getMimeTypesForTarget(e,t){const n=[],r=e.dataTransfer.types;let a=t.getAttribute(ATTR_TARGET);const o=t.hasAttribute(ATTR_TARGET_INCLUDE_TEXT);if(a){a=a.split("|");for(let e=0,t=r.length;e<t;e++){const t=r[e];a.indexOf(t)>-1&&n.push(t)}o&&n.length&&-1===n.indexOf(TEXT_PLAIN)&&n.push(TEXT_PLAIN)}return n}function attach(){eventModel.delegate("dragstart",SELECTOR_DRAGGABLE,onDragStart),eventModel.delegate("dragenter",SELECTOR_DROP_TARGET,onDragEnter),eventModel.delegate("dragleave",SELECTOR_DROP_TARGET,onDragLeave),eventModel.delegate("dragover",SELECTOR_DROP_TARGET,onDragOver),eventModel.delegate("dragend","body",onDragEnd),eventModel.delegate("drop",SELECTOR_DROP_TARGET,onDrop)}function detach(){eventModel.undelegate("dragstart",SELECTOR_DRAGGABLE,onDragStart),eventModel.undelegate("dragenter",SELECTOR_DROP_TARGET,onDragEnter),eventModel.undelegate("dragleave",SELECTOR_DROP_TARGET,onDragLeave),eventModel.undelegate("dragover",SELECTOR_DROP_TARGET,onDragOver),eventModel.undelegate("dragend","body",onDragEnd),eventModel.undelegate("drop",SELECTOR_DROP_TARGET,onDrop)}exports.attach=attach,exports.detach=detach;const originalDuration=longHoldTimerDuration;exports.setLongHoldDuration=function(e){longHoldTimerDuration=e},exports.resetLongHoldDuration=function(){longHoldTimerDuration=originalDuration};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../../libs/prime/defer":225,"../../logger/messages/UserDragAndDropInteraction1":204,"../../spotify-elements":235,"../center":246,"../util/get-log-context":320,"./util/eventmodel":256,"./util/hooks":257,"spotify-liburi":475}],256:[function(require,module,exports){
"use strict";const $=require("../../../spotify-elements"),attached={},delegations={};let movementHandlerCount=0,hasEntered=!1,lastEnteredElement=null,lastEnterTarget=null,lastEnterEvent=null,wasLastEventEnter=!1;function resetState(){hasEntered=!1,lastEnteredElement=null,lastEnterTarget=null,lastEnterEvent=null,wasLastEventEnter=!1}function onEvent(e){const t=getPrimaryHandler(e.type);t?t(e):handleDelegationsForEvent(e)}function onPrimaryDragEnter(e){wasLastEventEnter=!0,hasEntered?lastEnteredElement!==e.target&&(lastEnterEvent=e):(hasEntered=!0,lastEnteredElement=e.target,handleDelegationsForEvent(e))}function onPrimaryDragLeave(e){wasLastEventEnter=!1,lastEnteredElement=null,handleDelegationsForEvent(e),hasEntered&&(lastEnterEvent?(lastEnteredElement=lastEnterEvent.target,handleDelegationsForEvent(lastEnterEvent),lastEnterEvent=null):hasEntered=!1)}function onPrimaryDrop(e){resetState(),handleDelegationsForEvent(e)}function onPrimaryDragEnd(e){resetState(),handleDelegationsForEvent(e)}function onDragEnter(e,t,n){t!==lastEnterTarget&&(lastEnterTarget=t,callUserHandler(e,t,n))}function onDragLeave(e,t,n,a){let r=!1;const l=lastEnterEvent&&lastEnterEvent.target;if(l){const e=t===l,n=!e&&t.contains(l),s=$(l).matches(a);e||n&&!s||(r=!0)}wasLastEventEnter||(r=!0),r&&(lastEnterTarget=null,callUserHandler(e,t,n))}function handleDelegationsForEvent(e){const t=e.type,n=delegations[t];n&&n.length>0&&n.forEach(function(n){const a=n.selector,r=e.target!==document&&e.target.closest(a);if(r){(getHandler(t)||callUserHandler)(e,r,n.handler,a)}})}function callUserHandler(e,t,n){n.call(exports,e,t)}function getPrimaryHandler(e){switch(e){case"dragenter":return onPrimaryDragEnter;case"dragleave":return onPrimaryDragLeave;case"dragend":return onPrimaryDragEnd;case"drop":return onPrimaryDrop}return null}function getHandler(e){switch(e){case"dragenter":return onDragEnter;case"dragleave":return onDragLeave}return null}function isMovementType(e){switch(e){case"dragenter":case"dragleave":case"dragend":case"drop":return!0}return!1}function attach(e){attached[e]||(attached[e]=!0,document.addEventListener(e,onEvent,!1))}function detach(e){attached[e]&&(attached[e]=!1,document.removeEventListener(e,onEvent,!1))}function delegate(e,t,n){isMovementType(e)?1===++movementHandlerCount&&(attach("dragenter"),attach("dragleave"),attach("dragend"),attach("drop")):attached[e]||attach(e),delegations[e]||(delegations[e]=[]),delegations[e].push({selector:t,handler:n})}function undelegate(e,t,n){isMovementType(e)&&0===(movementHandlerCount=Math.max(0,movementHandlerCount-1))&&(detach("dragenter"),detach("dragleave"),detach("dragend"),detach("drop"));const a=delegations[e];if(a){for(let e=0,r=a.length;e<r;e++){const r=a[e];if(r.selector===t&&r.handler===n){a.splice(e,1);break}}isMovementType||0!==a.length||detach(e)}}exports.delegate=delegate,exports.undelegate=undelegate;

},{"../../../spotify-elements":235}],257:[function(require,module,exports){
"use strict";const hooks={};function add(o,s){hooks[o]||(hooks[o]=[]),hooks[o].push(s)}function remove(o,s){if(hooks[o]){const e=hooks[o].indexOf(s);e>-1&&hooks[o].splice(e,1)}}function run(o){const s=hooks[o];if(s&&s.length>0){const o=Array.prototype.slice.call(arguments,1);for(let e=0,n=s.length;e<n;e++)s[e].apply(null,o)}}exports.add=add,exports.remove=remove,exports.run=run;

},{}],258:[function(require,module,exports){
"use strict";const live=require("../../../live"),liburi=require("spotify-liburi");function getForUri(e){const t=liburi.from(e);if(!t)return"";const r=t.type;return r===liburi.Type.TRACK||r===liburi.Type.LOCAL?getForTrack(e):r===liburi.Type.ARTIST||r===liburi.Type.LOCAL_ARTIST?getForArtist(e):r===liburi.Type.ALBUM||r===liburi.Type.LOCAL_ALBUM?getForAlbum(e):r===liburi.Type.PLAYLIST||r===liburi.Type.PLAYLIST_V2?getForPlaylist(e):r===liburi.Type.USER||r===liburi.Type.PROFILE?getForUser(e):r===liburi.Type.FOLDER?getForFolder(e):r===liburi.Type.STATION?getForStation(e):r===liburi.Type.EPISODE?getForEpisode(e):r===liburi.Type.SHOW?getForShow(e):""}function getForTrack(e){const t=live(e),r=t.get("name");if(!r)return"";const i=t.get("artists");if(!i||0===i.length)return r;const n=i.get(0,i.length).map(function(e){return e.get("name")}).join(", ");return n?separateDragTextItems(r,n):r}function getForArtist(e){return live(e).get("name")||""}function getForAlbum(e){const t=live(e),r=t.get("name");if(!r)return"";const i=t.get("artists");if(!i||0===i.length)return r;const n=i.get(0).get("name");return n?separateDragTextItems(n,r):r}function getForPlaylist(e){const t=live(e),r=t.get("name");if(!r)return"";const i=t.get("owner"),n=i&&(i.get("name")||i.get("username"));return n?separateDragTextItems(r,n):r}function getForUser(e){const t=live(e).get("name");if(t)return t;const r=liburi.fromString(e);return r&&r.username||""}function getForFolder(e){return live(e).get("name")}function getForStation(e){return live(e).get("name")}function getForEpisode(e){return live(e).get("name")}function getForShow(e){return live(e).get("name")}function separateDragTextItems(e,t){return`${e} – ${t}`}function getForElement(e){let t=e.getAttribute("data-drag-text");if(t)return t;let r=e.getAttribute("data-uri");if(!r){const t=liburi.from(e.getAttribute("href"));r=t?t.toURI():""}return r&&(t=getForUri(r))?t:(t=e.getAttribute("title"))||e.textContent}exports.getForUri=getForUri,exports.getForElement=getForElement;

},{"../../../live":192,"spotify-liburi":475}],259:[function(require,module,exports){
"use strict";var _liveWrappedUri=require("../live-wrapped-uri"),_liveWrappedUri2=_interopRequireDefault(_liveWrappedUri),_formatLists=require("../playlist-utils/format-lists");function _interopRequireDefault(t){return t&&t.__esModule?t:{default:t}}const $=require("../spotify-elements"),live=require("../live"),dom=require("./util/dom"),center=require("./center"),SELECTOR_FEEDBACK_BUTTON="[data-button=feedback]",SELECTOR_HEART_BUTTON="[data-button=heart]",SELECTOR_BAN_BUTTON="[data-button=contextmenu]",SELECTOR_UNDO_HEART_BUTTON="[data-button=undo-heart]",SELECTOR_UNDO_BAN_BUTTON="[data-button=undo-ban]",HEART_CLASSNAME="spoticon-heart-16",BAN_CLASSNAME="spoticon-ban-16",ACTIVE_HEART_CLASSNAME="spoticon-heart-active-16",ACTIVE_BAN_CLASSNAME="spoticon-ban-active-16";let isAttached=!1;function handleFeedbackClick(t,e){const a=dom.getAttributeFromNodeOrParent(t.target,"data-button"),o=dom.getAttributeFromNodeOrParent(e[0],"data-uri");let n=dom.getContextFromNodeOrParent(e[0]);_liveWrappedUri2.default.parse(n)&&(n=_liveWrappedUri2.default.parse(n).originUri),o&&n&&("heart"===a?live(n).emit("heart",o):"undo-heart"!==a&&"undo-ban"!==a||live(n).emit(a,o))}function updateFeedbackUI(t,e){const a=t.querySelector(SELECTOR_HEART_BUTTON)||t.querySelector(SELECTOR_UNDO_HEART_BUTTON),o=t.querySelector(SELECTOR_BAN_BUTTON)||t.querySelector(SELECTOR_UNDO_BAN_BUTTON),n=t.parentNode.classList.contains("tl-row")?t.parentNode:null,r="up"===e,i="down"===e,s=!r&&!i;t&&(t.classList.toggle("thumbs-up",r),t.classList.toggle("thumbs-none",s),t.classList.toggle("thumbs-down",i)),a&&updateHeartUI(a,e),o&&updateBanUI(o,e),n?(n.classList.toggle("thumbs-up",r),n.classList.toggle("thumbs-none",s),n.classList.toggle("thumbs-down",i)):a&&a.classList.toggle("active",r)}function updateHeartUI(t,e){if("up"===e){t.classList.remove(HEART_CLASSNAME),t.classList.add(ACTIVE_HEART_CLASSNAME),t.setAttribute("data-button","undo-heart");const e=t.getAttribute("data-tooltip-undo");t.setAttribute("data-tooltip",e),t.setAttribute("aria-label",e),t.setAttribute("data-interaction-intent","undo-heart")}else if(null===e){t.classList.add(HEART_CLASSNAME),t.classList.remove(ACTIVE_HEART_CLASSNAME),t.setAttribute("data-button","heart");const e=t.getAttribute("data-tooltip-heart");t.setAttribute("data-tooltip",e),t.setAttribute("aria-label",e),t.setAttribute("data-interaction-intent","heart")}}function updateBanUI(t,e){if("down"===e){t.classList.remove(BAN_CLASSNAME),t.classList.add(ACTIVE_BAN_CLASSNAME),t.setAttribute("data-button","undo-ban");const e=t.getAttribute("data-tooltip-undo");t.setAttribute("data-tooltip",e),t.setAttribute("aria-label",e),t.setAttribute("data-interaction-intent","undo-ban")}else if(null===e){t.classList.add(BAN_CLASSNAME),t.classList.remove(ACTIVE_BAN_CLASSNAME),t.setAttribute("data-button","contextmenu");const e=t.getAttribute("data-tooltip-ban");t.setAttribute("data-tooltip",e),t.setAttribute("aria-label",e),t.setAttribute("data-interaction-intent","show-ban-options")}}function getURIFromNode(t){const e=t[0].closest("[data-uri]");return e?e.getAttribute("data-uri"):null}const changeHandlers={},eventHandlers={changeHandler:function(t,e,a,o){if("thumb"===e){0===t.setStateForURI(o,a)&&(live(o).off("update",changeHandlers[o]),delete changeHandlers[o])}}},actions={addListenerForNode:function(t,e){const a=getURIFromNode(t);let o;if(e&&e[0]&&(o=dom.getContextFromNodeOrParent(e[0])),!a||!o)return;_liveWrappedUri2.default.parse(o)&&(o=_liveWrappedUri2.default.parse(o).originUri);const n=(0,_formatLists.makeFeedbackUri)(o,a);if(changeHandlers[n])return void live(n).get("thumb",function(e,a){if(e)throw e;actions.setStateForFeedbackNode(t,a)},live.ASAP);changeHandlers[n]=function(t){for(const e in t){if(!t.hasOwnProperty(e))continue;const a=t[e];eventHandlers.changeHandler(actions,e,a,n)}};const r=live(n);r.get("thumb",function(e,a){if(e)throw e;actions.setStateForFeedbackNode(t,a),r.on("update",changeHandlers[n])},live.ASAP)},setStateForURI:function(t,e){let a=0;const o=(0,_formatLists.splitFeedbackUri)(t)[1],n=$(document).search("[data-button=feedback]");if(!n)return a;for(let t=0,r=n.length;t<r;t++){const r=$(n[t]);o===getURIFromNode(r)&&(a++,actions.setStateForFeedbackNode(r,e))}return a},setStateForFeedbackNode:function(t,e){const a=$(t[0].closest('[data-button="feedback"]'))||$(t[0].querySelector('[data-button="feedback"]'));a&&updateFeedbackUI(a[0],e)}},update=exports.update=function(t,e){if(!isAttached)return;const a=$(e)||$(t)||$(document).search("[data-button=feedback]");if(!a)return;const o=t||$(document).search("[data-context]");for(let t=0,e=a.length;t<e;t++)actions.addListenerForNode($(a[t]),$(o))},handleScrollShow=function(t){update(t.pageNode,t.nodes)};exports.attach=function(){if(isAttached)return;isAttached=!0,$(document).delegate("click","[data-button=feedback]",handleFeedbackClick),center.on("scroll-show-before",handleScrollShow)},exports.detach=function(){if(!isAttached)return;isAttached=!1,$(document).undelegate("click","[data-button=feedback]",handleFeedbackClick),center.off("scroll-show-before",handleScrollShow)};

},{"../live":192,"../live-wrapped-uri":191,"../playlist-utils/format-lists":220,"../spotify-elements":235,"./center":246,"./util/dom":319}],260:[function(require,module,exports){
"use strict";const $=require("../spotify-elements"),live=require("../live"),center=require("./center"),stickyEvents=require("./sticky"),cosmos=require("./util/cosmos"),merge=require("mout/object/merge"),deepEquals=require("mout/lang/deepEquals"),getOriginUri=require("../live-wrapped-uri").getOriginUri,appUtil=require("./util/app"),SCROLL_PADDING=8,STRING_FILTER_KEY="list-filter-string-",SESSION_STORAGE="spotify:session-storage";let states,lastEmittedStates,controlMessageSubscription,isAttached=!1;function update(t){if(!isAttached)return;const e=$(t)||$(document),a=e.matches("[data-filter]")?[e[0]]:e.search("[data-filter]");a&&a.forEach(function(t){const e=getURI(t);if(e){if(!states[e]){const a=$(t).find("input[type=text]")[0].value;a&&updateState(e,{activated:!0,enteredString:a})}handleStale(e)}})}function handleStale(t){render(t);const e=getState(t);if(!deepEquals(e,lastEmittedStates[t])){lastEmittedStates[t]=e;const a=e.activated?e.enteredString:"";emitFilterRequest(t,a),persistFilterOnSessionStorage(t,a)}}function render(t){const e=$(document).search("[data-uri] [data-filter]");e&&e.filter(function(e){return getURI(e)===t}).forEach(function(e){const a=getState(t),n=$(e).find("input[type=text]")[0],i=$(e).find(".h-search-wrapper")[0];a.activated?($(i).hasClass("focus")||($(i).addClass("focus"),e.setAttribute("data-sticky",""),stickyEvents.update()),n.value!==a.enteredString&&(n.value=a.enteredString)):(n.blur(),$(i).hasClass("focus")&&($(i).removeClass("focus"),e.removeAttribute("data-sticky"),stickyEvents.update()),n.value="")})}function focusAndSelectInput(t){document.activeElement!==t&&(t.focus(),t.select())}function scrollIntoView(t){const e=t.getBoundingClientRect(),a=e.top-SCROLL_PADDING;(a<0||e.bottom>window.innerHeight)&&window.scrollTo(0,window.pageYOffset+a)}function emitFilterRequest(t,e){center.emit("filter-request",t,e)}function persistFilterOnSessionStorage(t,e){const a=getOriginUri(t)||t,n={};n[STRING_FILTER_KEY+a]=e,live(SESSION_STORAGE).publish(n)}function handleCancelClick(t){clear(getURI(t.target))}function handleInputInput(t){updateState(getURI(t.target),{enteredString:t.target.value})}function handleInputKeyup(t){27===t.keyCode&&clear(getURI(t.target))}function handleInputFocus(t){updateState(getURI(t.target),{activated:!0})}function handleInputFocusOut(t){""===getState(getURI(t.target)).enteredString&&updateState(getURI(t.target),{activated:!1})}function clear(t){updateState(t,{activated:!1,enteredString:""})}function getState(t){return states[t]||{activated:!1,enteredString:""}}function updateState(t,e){states[t]=merge(getState(t),e),handleStale(t)}function getURI(t){let e=t.getAttribute("data-uri");if(!e){const a=$(t).parents("[data-uri]");a&&(e=a[0].getAttribute("data-uri"))}return(e=getOriginUri(e)||e)||null}const attach=function(){isAttached||(isAttached=!0,states={},lastEmittedStates={},controlMessageSubscription=cosmos.subscribe({url:"sp://messages/v1/container/control"},function(t,e){if(!appUtil.isActive())return;e&&e.body&&"filter"===e.body.type&&$("[data-filter]").forEach(function(t,e){updateState(getURI(t),{activated:!0});const a=$(t).find("input[type=text]")[0];a&&(0===e&&scrollIntoView(a),focusAndSelectInput(a))})}),center.on("filter-reset",clear),$(document).delegate("click","[data-filter] .h-search-close",handleCancelClick),$(document).delegate("click","[data-filter-reset]",handleCancelClick),$(document).delegate("input","[data-filter] input",handleInputInput),$(document).delegate("keyup","[data-filter] input",handleInputKeyup),$(document).delegate("focusin","[data-filter] input",handleInputFocus),$(document).delegate("focusout","[data-filter] input",handleInputFocusOut))},detach=function(){isAttached&&(states=null,controlMessageSubscription.cancel(),center.off("filter-reset",clear),$(document).undelegate("click","[data-filter] .h-search-close",handleCancelClick),$(document).undelegate("click","[data-filter-reset]",handleCancelClick),$(document).undelegate("input","[data-filter] input",handleInputInput),$(document).undelegate("keyup","[data-filter] input",handleInputKeyup),$(document).undelegate("focusin","[data-filter] input",handleInputFocus),$(document).undelegate("focusout","[data-filter] input",handleInputFocusOut),isAttached=!1)},broadcast=function(t){if(void 0===t)throw new Error("broadcast requires enabled argument");cosmos.post({url:"sp://messages/v1/container/control",body:{type:"update_menu_state",enable_filter_item:t}})};module.exports={attach:attach,detach:detach,update:update,broadcast:broadcast};

},{"../live":192,"../live-wrapped-uri":191,"../spotify-elements":235,"./center":246,"./sticky":312,"./util/app":317,"./util/cosmos":318,"mout/lang/deepEquals":430,"mout/object/merge":448}],261:[function(require,module,exports){
(function (global){
"use strict";var _glue=require("../glue"),_glue2=_interopRequireDefault(_glue),_frameUpdater=require("../frame-updater"),_cancellationTokenSource=require("../cancellation-token-source"),_cancellationTokenSource2=_interopRequireDefault(_cancellationTokenSource);function _interopRequireDefault(e){return e&&e.__esModule?e:{default:e}}let isAttached=!1,isFontLoaded=!1,topBarHeight=0,headerHeight=0,lastHeaderHeight=0,stickyHeight=0,currentScrollY=0,lastScrollY=0,lastScrollYDiffs=[0,0,0,0,0],lastLoadedImageNode=null,scrollListenerId=0,needsTitleSizeUpdate=!0,lastUpdatedTitleNode=null,lastUpdatedTitleContent="",fontPromise=null,cancellationTokenSource=null,frameRequestIds=[],lastHeaderNode=null,scrollNode=null,lastDescriptionNode=null,lastDescriptionMouseEnterHandler=null,lastDescriptionMouseLeaveHandler=null,fullDescriptionNode=null;function updateHeaderAlphaMask(){const e=document.querySelector("[data-glue-page-header-content]");if(e){const t=currentScrollY+topBarHeight,a=t+24;e.style.webkitMaskImage=`linear-gradient(to bottom, transparent ${t}px, black ${a}px)`}}function updateHeaderBackgroundPosition(){const e=document.querySelector("[data-glue-page-header-background]");if(e){const t=currentScrollY>headerHeight-stickyHeight;e.style.position=t?"fixed":"",e.style.top=t?`-${headerHeight-stickyHeight}px`:"",e.style._bottom=t?"auto":"",e.style.bottom=e.style._bottom,e.style.height=t?`${headerHeight}px`:""}const t=document.querySelector("[data-glue-page-header-background-image]");if(t){const e=t.style.transform||"";t.style.transform=`${e.replace(/translateY\(.*?\)/,"")} translateY(${Math.min(currentScrollY,headerHeight-stickyHeight)}px)`.trim()}}function updateHeaderBackgroundScrollOverlay(){const e=document.querySelector("[data-glue-page-header-background-scroll-overlay]");if(e){const t=.4;e.style.opacity=Math.round(Math.min(1,currentScrollY/(headerHeight-stickyHeight))*t*1e3)/1e3}}function updateHeaderBackgroundScrollOverlayEllipse(){const e=Math.min(1,currentScrollY/(headerHeight-stickyHeight)),t=document.querySelector("[data-glue-page-header-background-scroll-overlay-ellipse]");t&&(t.style.opacity=Math.round(1e3*Math.min(1,2*e))/1e3);const a=document.querySelector("[data-glue-page-header-background-scroll-overlay-ellipse-backdrop]");a&&(a.style.opacity=Math.round(1e3*e)/1e3)}function updateHeaderImageScaling(){const e=document.querySelector("[data-glue-page-header-background-image]");if(e){const t=document.querySelector("[data-glue-page-header-background-image-loader]");if(!!t&&t.classList.contains("glue-page-header__background-image-loader--is-loaded")){const t=1.07,a=1,o=Math.min(1,currentScrollY/(headerHeight-stickyHeight)),r=Math.round(1e3*(t-o*(t-a)))/1e3,l=e.style.transform||"";e.style.transform=`${l.replace(/scale\(.*?\)/,"")} scale(${r})`.trim()}}}function addDescriptionHandlers(){const e=document.querySelector("[data-glue-page-header]"),t=document.querySelector("[data-glue-page-header-description]");e&&t&&(lastDescriptionMouseEnterHandler=(t=>{if(t.target.scrollHeight!==t.target.clientHeight){const a=t.target.getBoundingClientRect();(fullDescriptionNode=t.target.cloneNode(!0)).addEventListener("mouseleave",lastDescriptionMouseLeaveHandler),fullDescriptionNode.classList.add("glue-page-header__full-description-overlay"),fullDescriptionNode.style.top=`${a.top}px`,fullDescriptionNode.style.left=`${a.left}px`,fullDescriptionNode.style.width=`${a.width}px`,e.appendChild(fullDescriptionNode)}}),lastDescriptionMouseLeaveHandler=(e=>{fullDescriptionNode&&e.relatedTarget!==fullDescriptionNode&&!fullDescriptionNode.contains(e.relatedTarget)&&(fullDescriptionNode.parentNode.removeChild(fullDescriptionNode),fullDescriptionNode.removeEventListener("mouseleave",lastDescriptionMouseLeaveHandler),fullDescriptionNode=null)}),(lastDescriptionNode=t).addEventListener("mouseenter",lastDescriptionMouseEnterHandler),lastDescriptionNode.addEventListener("mouseleave",lastDescriptionMouseLeaveHandler))}function removeDescriptionHandlers(){fullDescriptionNode&&(fullDescriptionNode.removeEventListener("mouseleave",lastDescriptionMouseLeaveHandler),fullDescriptionNode.parentNode.removeChild(fullDescriptionNode),fullDescriptionNode=null),lastDescriptionMouseEnterHandler&&(lastDescriptionNode.removeEventListener("mouseenter",lastDescriptionMouseEnterHandler),lastDescriptionMouseEnterHandler=null),lastDescriptionMouseLeaveHandler&&(lastDescriptionNode.removeEventListener("mouseleave",lastDescriptionMouseLeaveHandler),lastDescriptionMouseLeaveHandler=null),lastDescriptionNode=null}function handleResize(){needsTitleSizeUpdate=!0,exports._ensureFontIsLoaded(e=>{e?console.error(e):(exports._updateTitleTypeSize(),exports._updateHeaderSizes(),exports._updateHeader())})}exports._updateHeader=function(){const e=document.querySelector("[data-glue-page-header]");(e!==lastHeaderNode||currentScrollY<headerHeight||lastScrollY<headerHeight||headerHeight!==lastHeaderHeight)&&(lastHeaderNode=e,lastHeaderHeight=headerHeight,removeDescriptionHandlers(),addDescriptionHandlers(),updateHeaderBackgroundPosition(),updateHeaderAlphaMask(),updateHeaderBackgroundScrollOverlay(),updateHeaderBackgroundScrollOverlayEllipse(),updateHeaderImageScaling())},exports._updateHeaderSizes=function(){const e=document.querySelector("[data-glue-page-header]");if(e){const t=scrollNode===document?document.body:scrollNode;topBarHeight=parseInt(t.getAttribute("data-top-bar-height"),10)||0,headerHeight=e.offsetHeight,stickyHeight=parseInt(e.getAttribute("data-glue-page-header-sticky-height"),10)||0}else topBarHeight=0,headerHeight=0,stickyHeight=0},exports._updateTitleTypeSize=function(){const e=document.querySelector("[data-glue-page-header-content] [data-glue-page-header-title]");if(e){const t=e!==lastUpdatedTitleNode,a=e.textContent!==lastUpdatedTitleContent;e&&(needsTitleSizeUpdate||t||a)&&(needsTitleSizeUpdate=!1,lastUpdatedTitleNode=e,lastUpdatedTitleContent=e.textContent,_glue2.default.responsiveTitleType.setSizeForTitle(e,{useLargeTitle:e.hasAttribute("data-glue-page-header-use-large-title")}),exports._updateHeaderSizes())}},exports._updateScrollClassNames=function(){const e=document.querySelector("[data-glue-page-header]");if(e){!e._hasBeenSeen?(e._hasBeenSeen=!0,e.classList.add("glue-page-header--with-no-animations")):frameRequestIds.push((0,_frameUpdater.requestFrame)(null,()=>{e.classList.remove("glue-page-header--with-no-animations")})),lastScrollYDiffs.push(Math.abs(currentScrollY-lastScrollY)),lastScrollYDiffs.shift();const t=30,a=lastScrollYDiffs.reduce((e,a)=>e||a>t,!1);a?e.classList.add("glue-page-header--with-fast-scrolling"):e.classList.remove("glue-page-header--with-fast-scrolling"),global.onPageHeaderToggleFastScrolling&&global.onPageHeaderToggleFastScrolling(a)}},exports._updateHeaderImageLoading=function(){const e=document.querySelector("[data-glue-page-header-background-image]");if(e){if(e===lastLoadedImageNode)return;const t=e.getAttribute("data-glue-page-header-background-image-url");if(lastLoadedImageNode=e,t){const e=new window.Image;e.onload=(()=>{const e=document.querySelector("[data-glue-page-header-background-image-loader]");e.classList.contains("glue-page-header__background-image-loader--is-loaded")||(e.classList.add("glue-page-header__background-image-loader--is-loaded"),e.classList.add("glue-page-header__background-image-loader--with-loading-animation"),updateHeaderImageScaling(),e.addEventListener("transitionend",function t(){e.removeEventListener("transitionend",t),e.classList.remove("glue-page-header__background-image-loader--with-loading-animation")}))}),e.src=t}}},exports._updateScrollValue=function(){currentScrollY=scrollNode===document?window.scrollY:scrollNode.scrollTop},exports._updateLastScrollValue=function(){lastScrollY=currentScrollY},exports._ensureFontIsLoaded=function(e){if(isFontLoaded)return void e(null);fontPromise||(fontPromise=_glue2.default.responsiveTitleType.loadFont());const t=cancellationTokenSource.token();fontPromise.then(()=>{t.isCanceled()?e(t.operationCanceledError()):(isFontLoaded=!0,e(null))},a=>{e(t.errorIfCanceled()||a)})},exports.attach=function(){isAttached||(isAttached=!0,cancellationTokenSource=new _cancellationTokenSource2.default,scrollNode||(scrollNode=document),exports._ensureFontIsLoaded(e=>e&&console.error(e)),exports._updateHeaderSizes(),scrollListenerId=(0,_frameUpdater.addDebouncedScrollListener)(scrollNode,()=>{exports._updateScrollValue()},()=>{exports._updateScrollClassNames(),exports._updateHeader(),exports._updateLastScrollValue()}),window.addEventListener("resize",handleResize))},exports.detach=function(){isAttached&&(cancellationTokenSource.cancel(),cancellationTokenSource=null,frameRequestIds.forEach(e=>{(0,_frameUpdater.cancelFrame)(e)}),frameRequestIds=[],removeDescriptionHandlers(),isAttached=!1,isFontLoaded=!1,fontPromise=null,headerHeight=0,stickyHeight=0,currentScrollY=0,lastScrollY=0,lastScrollYDiffs=[0,0,0,0,0],needsTitleSizeUpdate=!0,lastUpdatedTitleNode=null,lastUpdatedTitleContent="",scrollNode=null,lastDescriptionNode=null,lastDescriptionMouseEnterHandler=null,lastDescriptionMouseLeaveHandler=null,fullDescriptionNode=null,(0,_frameUpdater.removeDebouncedScrollListener)(scrollListenerId),window.removeEventListener("resize",handleResize))},exports.update=function(){isAttached&&(frameRequestIds.push((0,_frameUpdater.requestFrame)(()=>{exports._updateScrollValue()},()=>{exports._updateScrollClassNames(),exports._updateHeaderImageLoading()})),exports._ensureFontIsLoaded(e=>{e?console.error(e):frameRequestIds.push((0,_frameUpdater.requestFrame)(()=>{exports._updateHeaderSizes()},()=>{exports._updateTitleTypeSize(),exports._updateHeader()}))}))},exports.setScrollNode=function(e){scrollNode=e};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../cancellation-token-source":42,"../frame-updater":59,"../glue":83}],262:[function(require,module,exports){
"use strict";const i18n=require("../../../libs/spotify-i18n")({ar:require("./json/ar.json"),cs:require("./json/cs.json"),de:require("./json/de.json"),el:require("./json/el.json"),en:require("./json/en.json"),es:require("./json/es.json"),"es-419":require("./json/es-419.json"),fi:require("./json/fi.json"),fr:require("./json/fr.json"),"fr-CA":require("./json/fr-CA.json"),hu:require("./json/hu.json"),id:require("./json/id.json"),it:require("./json/it.json"),ja:require("./json/ja.json"),nl:require("./json/nl.json"),pl:require("./json/pl.json"),"pt-BR":require("./json/pt-BR.json"),sv:require("./json/sv.json"),th:require("./json/th.json"),tr:require("./json/tr.json"),vi:require("./json/vi.json"),"zh-Hant":require("./json/zh-Hant.json"),ms:require("./json/ms.json")});module.exports=i18n;

},{"../../../libs/spotify-i18n":341,"./json/ar.json":263,"./json/cs.json":264,"./json/de.json":265,"./json/el.json":266,"./json/en.json":267,"./json/es-419.json":268,"./json/es.json":269,"./json/fi.json":270,"./json/fr-CA.json":271,"./json/fr.json":272,"./json/hu.json":273,"./json/id.json":274,"./json/it.json":275,"./json/ja.json":276,"./json/ms.json":277,"./json/nl.json":278,"./json/pl.json":279,"./json/pt-BR.json":280,"./json/sv.json":281,"./json/th.json":282,"./json/tr.json":283,"./json/vi.json":284,"./json/zh-Hant.json":285}],263:[function(require,module,exports){
module.exports={
  "drag_tooltip_many_items": {
    "one": "1 ملف",
    "other": "{0} ملفات"
  },
  "drag_tooltip_many_tracks": {
    "one": "مقطع واحد",
    "other": "{0} مقاطع"
  },
  "drag_tooltip_many_artists": {
    "one": "1 فنان",
    "other": "{0} فنانين"
  },
  "drag_tooltip_many_albums": {
    "one": "1 ألبوم",
    "other": "{0} ألبومات"
  },
  "drag_tooltip_many_playlists": {
    "one": "1 قائمة أغاني",
    "other": "{0} قوائم أغاني"
  },
  "drag_tooltip_many_users": {
    "one": "1 مستخدم",
    "other": "{0} مستخدمين"
  }
}
},{}],264:[function(require,module,exports){
module.exports={
  "drag_tooltip_many_items": {
    "one": "1 položka",
    "other": "Počet položek: {0}"
  },
  "drag_tooltip_many_tracks": {
    "one": "1 skladba",
    "other": "Počet skladeb: {0}"
  },
  "drag_tooltip_many_artists": {
    "one": "1 umělec",
    "other": "Počet umělců: {0}"
  },
  "drag_tooltip_many_albums": {
    "one": "1 album",
    "other": "Počet alb: {0}"
  },
  "drag_tooltip_many_playlists": {
    "one": "1 playlist",
    "other": "{0} playlistů"
  },
  "drag_tooltip_many_users": {
    "one": "1 uživatel",
    "other": "Počet uživatelů: {0}"
  }
}
},{}],265:[function(require,module,exports){
module.exports={
  "drag_tooltip_many_items": {
    "one": "1 Element",
    "other": "{0} Elemente"
  },
  "drag_tooltip_many_tracks": {
    "one": "1 Titel",
    "other": "{0} Titel"
  },
  "drag_tooltip_many_artists": {
    "one": "1 Künstler",
    "other": "{0} Künstler"
  },
  "drag_tooltip_many_albums": {
    "one": "1 Album",
    "other": "{0} Alben"
  },
  "drag_tooltip_many_playlists": {
    "one": "1 Playlist",
    "other": "{0} Playlists"
  },
  "drag_tooltip_many_users": {
    "one": "1 User",
    "other": "{0} User"
  }
}
},{}],266:[function(require,module,exports){
module.exports={
  "drag_tooltip_many_items": {
    "one": "1 στοιχείο",
    "other": "{0} στοιχεία"
  },
  "drag_tooltip_many_tracks": {
    "one": "1 κομμάτι",
    "other": "{0} κομμάτια"
  },
  "drag_tooltip_many_artists": {
    "one": "1 καλλιτέχνης",
    "other": "{0} καλλιτέχνες"
  },
  "drag_tooltip_many_albums": {
    "one": "1 άλμπουμ",
    "other": "{0} άλμπουμ"
  },
  "drag_tooltip_many_playlists": {
    "one": "1 playlist",
    "other": "{0} λίστες"
  },
  "drag_tooltip_many_users": {
    "one": "1 χρήστης",
    "other": "{0} χρήστες"
  }
}
},{}],267:[function(require,module,exports){
module.exports={
  "drag_tooltip_many_items": {
    "one": "1 item",
    "other": "{0} items"
  },
  "drag_tooltip_many_tracks": {
    "one": "1 track",
    "other": "{0} tracks"
  },
  "drag_tooltip_many_artists": {
    "one": "1 artist",
    "other": "{0} artists"
  },
  "drag_tooltip_many_albums": {
    "one": "1 album",
    "other": "{0} albums"
  },
  "drag_tooltip_many_playlists": {
    "one": "1 playlist",
    "other": "{0} playlists"
  },
  "drag_tooltip_many_users": {
    "one": "1 user",
    "other": "{0} users"
  }
}
},{}],268:[function(require,module,exports){
module.exports={
  "drag_tooltip_many_items": {
    "one": "1 elemento",
    "other": "{0} elementos"
  },
  "drag_tooltip_many_tracks": {
    "one": "1 canción",
    "other": "{0} canciones"
  },
  "drag_tooltip_many_artists": {
    "one": "1 artista",
    "other": "{0} artistas"
  },
  "drag_tooltip_many_albums": {
    "one": "1 álbum",
    "other": "{0} álbumes"
  },
  "drag_tooltip_many_playlists": {
    "one": "1 playlist",
    "other": "Playlists de {0}"
  },
  "drag_tooltip_many_users": {
    "one": "1 usuario",
    "other": "{0} usuarios"
  }
}
},{}],269:[function(require,module,exports){
module.exports={
  "drag_tooltip_many_items": {
    "one": "1 elemento",
    "other": "{0} elementos"
  },
  "drag_tooltip_many_tracks": {
    "one": "1 canción",
    "other": "{0} canciones"
  },
  "drag_tooltip_many_artists": {
    "one": "1 artista",
    "other": "{0} artistas"
  },
  "drag_tooltip_many_albums": {
    "one": "1 álbum",
    "other": "{0} álbumes"
  },
  "drag_tooltip_many_playlists": {
    "one": "1 playlist",
    "other": "{0} playlists"
  },
  "drag_tooltip_many_users": {
    "one": "1 usuario",
    "other": "{0} usuarios"
  }
}
},{}],270:[function(require,module,exports){
module.exports={
  "drag_tooltip_many_items": {
    "one": "1 kohde",
    "other": "{0} kohdetta"
  },
  "drag_tooltip_many_tracks": {
    "one": "1 kappale",
    "other": "{0} kappaletta"
  },
  "drag_tooltip_many_artists": {
    "one": "1 artisti",
    "other": "{0} artistia"
  },
  "drag_tooltip_many_albums": {
    "one": "1 albumi",
    "other": "{0} albumia"
  },
  "drag_tooltip_many_playlists": {
    "one": "1 soittolista",
    "other": "{0} soittolistaa"
  },
  "drag_tooltip_many_users": {
    "one": "1 käyttäjä",
    "other": "{0} käyttäjää"
  }
}
},{}],271:[function(require,module,exports){
module.exports={
  "drag_tooltip_many_items": {
    "one": "1 article",
    "other": "{0} articles"
  },
  "drag_tooltip_many_tracks": {
    "one": "1 chanson",
    "other": "{0} chansons"
  },
  "drag_tooltip_many_artists": {
    "one": "1 artiste",
    "other": "{0} artistes"
  },
  "drag_tooltip_many_albums": {
    "one": "1 album",
    "other": "{0} albums"
  },
  "drag_tooltip_many_playlists": {
    "one": "1 liste de lecture",
    "other": "{0} listes de lecture"
  },
  "drag_tooltip_many_users": {
    "one": "1 utilisateur",
    "other": "{0} utilisateur"
  }
}
},{}],272:[function(require,module,exports){
module.exports={
  "drag_tooltip_many_items": {
    "one": "1 élément",
    "other": "{0} éléments"
  },
  "drag_tooltip_many_tracks": {
    "one": "1 titre",
    "other": "{0} titres"
  },
  "drag_tooltip_many_artists": {
    "one": "1 artiste",
    "other": "{0} artistes"
  },
  "drag_tooltip_many_albums": {
    "one": "1 album",
    "other": "{0} albums"
  },
  "drag_tooltip_many_playlists": {
    "one": "1 playlist",
    "other": "{0} playlists"
  },
  "drag_tooltip_many_users": {
    "one": "1 utilisateur",
    "other": "{0} utilisateurs"
  }
}
},{}],273:[function(require,module,exports){
module.exports={
  "drag_tooltip_many_items": {
    "one": "1 elem",
    "other": "{0} elem"
  },
  "drag_tooltip_many_tracks": {
    "one": "1 dal",
    "other": " {0} dal"
  },
  "drag_tooltip_many_artists": {
    "one": "1 előadó",
    "other": "{0} előadó"
  },
  "drag_tooltip_many_albums": {
    "one": "1 album",
    "other": "{0} album"
  },
  "drag_tooltip_many_playlists": {
    "one": "1 műsorlista",
    "other": "{0} lejátszási lista"
  },
  "drag_tooltip_many_users": {
    "one": "1 felhasználó",
    "other": "{0} felhasználó"
  }
}
},{}],274:[function(require,module,exports){
module.exports={
  "drag_tooltip_many_items": {
    "one": "1 item",
    "other": "{0} item"
  },
  "drag_tooltip_many_tracks": {
    "one": "1 lagu",
    "other": "{0} lagu"
  },
  "drag_tooltip_many_artists": {
    "one": "1 artis",
    "other": "{0} artis"
  },
  "drag_tooltip_many_albums": {
    "one": "1 album",
    "other": "{0} album"
  },
  "drag_tooltip_many_playlists": {
    "one": "1 playlist",
    "other": "{0} playlist"
  },
  "drag_tooltip_many_users": {
    "one": "1 pengguna",
    "other": "{0} pengguna"
  }
}
},{}],275:[function(require,module,exports){
module.exports={
  "drag_tooltip_many_items": {
    "one": "1 elemento",
    "other": "{0} elementi"
  },
  "drag_tooltip_many_tracks": {
    "one": "1 brano",
    "other": "{0} brani"
  },
  "drag_tooltip_many_artists": {
    "one": "1 artista",
    "other": "{0} artisti"
  },
  "drag_tooltip_many_albums": {
    "one": "1 album",
    "other": "{0} album"
  },
  "drag_tooltip_many_playlists": {
    "one": "1 playlist",
    "other": "{0} playlist"
  },
  "drag_tooltip_many_users": {
    "one": "1 utente",
    "other": "{0} utenti"
  }
}
},{}],276:[function(require,module,exports){
module.exports={
  "drag_tooltip_many_items": {
    "one": "1個のアイテム",
    "other": "{0}個のアイテム"
  },
  "drag_tooltip_many_tracks": {
    "one": "1曲",
    "other": "{0}曲"
  },
  "drag_tooltip_many_artists": {
    "one": "1人のアーティスト",
    "other": "{0}人のアーティスト"
  },
  "drag_tooltip_many_albums": {
    "one": "1枚のアルバム",
    "other": "{0}枚のアルバム"
  },
  "drag_tooltip_many_playlists": {
    "one": "1つのプレイリスト",
    "other": "{0}個のプレイリスト"
  },
  "drag_tooltip_many_users": {
    "one": "1人のユーザー",
    "other": "{0}人のユーザー"
  }
}
},{}],277:[function(require,module,exports){
module.exports={
  "drag_tooltip_many_items": {
    "one": "1 item",
    "other": "{0} item"
  },
  "drag_tooltip_many_tracks": {
    "one": "1 lagu",
    "other": "{0} lagu"
  },
  "drag_tooltip_many_artists": {
    "one": "1 artis",
    "other": "{0} artis"
  },
  "drag_tooltip_many_albums": {
    "one": "1 album",
    "other": "{0} album"
  },
  "drag_tooltip_many_playlists": {
    "one": "1 senarai main",
    "other": "{0} senarai main"
  },
  "drag_tooltip_many_users": {
    "one": "1 pengguna",
    "other": "{0} pengguna"
  }
}
},{}],278:[function(require,module,exports){
module.exports={
  "drag_tooltip_many_items": {
    "one": "1 item",
    "other": "{0} items"
  },
  "drag_tooltip_many_tracks": {
    "one": "1 nummer",
    "other": "{0} nummers"
  },
  "drag_tooltip_many_artists": {
    "one": "1 artist",
    "other": "{0} artiesten"
  },
  "drag_tooltip_many_albums": {
    "one": "1 album",
    "other": "{0} albums"
  },
  "drag_tooltip_many_playlists": {
    "one": "1 afspeellijst",
    "other": "{0} afspeellijsten"
  },
  "drag_tooltip_many_users": {
    "one": "1 gebruiker",
    "other": "{0} gebruikers"
  }
}
},{}],279:[function(require,module,exports){
module.exports={
  "drag_tooltip_many_items": {
    "one": "1 element",
    "other": "Elementy: {0}"
  },
  "drag_tooltip_many_tracks": {
    "one": "1utwór",
    "other": "Liczba utworów: {0}"
  },
  "drag_tooltip_many_artists": {
    "one": "1 wykonawca",
    "other": "Wykonawcy: {0}"
  },
  "drag_tooltip_many_albums": {
    "one": "1 album",
    "other": "Albumy: {0}"
  },
  "drag_tooltip_many_playlists": {
    "one": "1 playlista",
    "other": "{0} playlisty"
  },
  "drag_tooltip_many_users": {
    "one": "1 użytkownik",
    "other": "Użytkownicy: {0}"
  }
}
},{}],280:[function(require,module,exports){
module.exports={
  "drag_tooltip_many_items": {
    "one": "1 item",
    "other": "{0} itens"
  },
  "drag_tooltip_many_tracks": {
    "one": "1 faixa",
    "other": "{0} faixas"
  },
  "drag_tooltip_many_artists": {
    "one": "1 artista",
    "other": "{0} artistas"
  },
  "drag_tooltip_many_albums": {
    "one": "1 álbum",
    "other": "{0} álbuns"
  },
  "drag_tooltip_many_playlists": {
    "one": "1 playlist",
    "other": "{0} playlists"
  },
  "drag_tooltip_many_users": {
    "one": "1 usuário",
    "other": "{0} usuários"
  }
}
},{}],281:[function(require,module,exports){
module.exports={
  "drag_tooltip_many_items": {
    "one": "1 objekt",
    "other": "{0} objekt"
  },
  "drag_tooltip_many_tracks": {
    "one": "Ett spår",
    "other": "{0} spår"
  },
  "drag_tooltip_many_artists": {
    "one": "1 artist",
    "other": "{0} artister"
  },
  "drag_tooltip_many_albums": {
    "one": "1 album",
    "other": "{0} album"
  },
  "drag_tooltip_many_playlists": {
    "one": "1 spellista",
    "other": "{0} spellistor"
  },
  "drag_tooltip_many_users": {
    "one": "1 användare",
    "other": "{0} användare"
  }
}
},{}],282:[function(require,module,exports){
module.exports={
  "drag_tooltip_many_items": {
    "one": "1 รายการ",
    "other": "{0} รายการ"
  },
  "drag_tooltip_many_tracks": {
    "one": "1 แทร็ก",
    "other": "{0} แทร็ก"
  },
  "drag_tooltip_many_artists": {
    "one": "ศิลปิน 1 ราย",
    "other": "ศิลปิน {0} ราย"
  },
  "drag_tooltip_many_albums": {
    "one": "1 อัลบั้ม",
    "other": "{0} อัลบั้ม"
  },
  "drag_tooltip_many_playlists": {
    "one": "1 เพลย์ลิสต์",
    "other": "{0} เพลย์ลิสต์"
  },
  "drag_tooltip_many_users": {
    "one": "ผู้ใช้ 1 คน",
    "other": "ผู้ใช้ {0} คน"
  }
}
},{}],283:[function(require,module,exports){
module.exports={
  "drag_tooltip_many_items": {
    "one": "1 Öge",
    "other": "{0} öge"
  },
  "drag_tooltip_many_tracks": {
    "one": "1 parça",
    "other": "{0} parça"
  },
  "drag_tooltip_many_artists": {
    "one": "1 sanatçı",
    "other": "{0} sanatçı"
  },
  "drag_tooltip_many_albums": {
    "one": "1 albüm",
    "other": "{0} albüm"
  },
  "drag_tooltip_many_playlists": {
    "one": "1 çalma listesi",
    "other": "{0} çalma listesi"
  },
  "drag_tooltip_many_users": {
    "one": "1 kullanıcı",
    "other": "{0} kullanıcı"
  }
}
},{}],284:[function(require,module,exports){
module.exports={
  "drag_tooltip_many_items": {
    "one": "1 mục",
    "other": "{0} mục"
  },
  "drag_tooltip_many_tracks": {
    "one": "1 bản nhạc",
    "other": "{0} bản nhạc"
  },
  "drag_tooltip_many_artists": {
    "one": "1 nghệ sĩ",
    "other": "{0} nghệ sĩ"
  },
  "drag_tooltip_many_albums": {
    "one": "1 album",
    "other": "{0} album"
  },
  "drag_tooltip_many_playlists": {
    "one": "1 playlist",
    "other": "{0} playlist"
  },
  "drag_tooltip_many_users": {
    "one": "1 người dùng",
    "other": "{0} người dùng"
  }
}
},{}],285:[function(require,module,exports){
module.exports={
  "drag_tooltip_many_items": {
    "one": "1 個項目",
    "other": "{0} 個項目"
  },
  "drag_tooltip_many_tracks": {
    "one": "1 首歌曲",
    "other": "{0} 首歌曲"
  },
  "drag_tooltip_many_artists": {
    "one": "1 位藝人",
    "other": "{0} 位藝人"
  },
  "drag_tooltip_many_albums": {
    "one": "1 張專輯",
    "other": "{0} 張專輯"
  },
  "drag_tooltip_many_playlists": {
    "one": "1 個播放清單",
    "other": "{0} 個播放清單"
  },
  "drag_tooltip_many_users": {
    "one": "1 位使用者",
    "other": "{0} 位使用者"
  }
}
},{}],286:[function(require,module,exports){
"use strict";const modules=[require("./lang"),require("./anchor"),require("./player"),require("./dragndrop"),require("./add"),require("./selection"),require("./contextmenu"),require("./sticky"),require("./navbar"),require("./offline"),require("./filter"),require("./tooltip"),require("./list"),require("./menu"),require("./scroll"),require("./carousel"),require("./scrollbar"),require("./header"),require("./slider"),require("./select"),require("./sort"),require("./thumbs"),require("./feedback"),require("./nft-feedback"),require("./list-quick-jump"),require("./cards"),require("./rtl")],events={};let isAttached=!1;events.update=function(e){isAttached&&modules.forEach(function(r){r.update(e)})},events.attach=function(){isAttached||(isAttached=!0,modules.forEach(function(e){e.attach()}))},events.detach=function(){isAttached&&(isAttached=!1,modules.forEach(function(e){e.detach()}))},module.exports=events;

},{"./add":238,"./anchor":239,"./cards":240,"./carousel":245,"./contextmenu":247,"./dragndrop":253,"./feedback":259,"./filter":260,"./header":261,"./lang":287,"./list":289,"./list-quick-jump":288,"./menu":290,"./navbar":291,"./nft-feedback":292,"./offline":293,"./player":295,"./rtl":300,"./scroll":301,"./scrollbar":302,"./select":303,"./selection":306,"./slider":310,"./sort":311,"./sticky":312,"./thumbs":313,"./tooltip":314}],287:[function(require,module,exports){
"use strict";let isAttached=!1;exports.update=(()=>{}),exports.attach=(()=>{if(isAttached)return;isAttached=!0;const t=window.__spotify&&window.__spotify.locale;t&&document.documentElement.setAttribute("lang",t)}),exports.detach=(()=>{isAttached&&(isAttached=!1,document.documentElement.removeAttribute("lang"))});

},{}],288:[function(require,module,exports){
"use strict";const center=require("./center"),cosmos=require("./util/cosmos"),SPACE_KEYCODE=32,BACKSPACE_KEYCODE=8,DELETE_KEYCODE=46;exports.attach=function(){document.addEventListener("keypress",onKeyPress,!1),document.addEventListener("keydown",onKeyDown,!1)},exports.detach=function(){document.removeEventListener("keypress",onKeyPress,!1),document.removeEventListener("keydown",onKeyDown,!1)},exports.update=function(){};const selector=":not([data-sticky-active]) > [data-list-quick-jump]",SEARCH_STRING_CONCATENATION_TIMEOUT=1e3,searchStringsByUri={},searchTimeoutsByUri={};function onKeyPress(e){shouldEventBeIgnored(e)||processEvent(e)}function onKeyDown(e){if(shouldEventBeIgnored(e))return;e.keyCode===BACKSPACE_KEYCODE&&processEvent(e)}function processEvent(e){const t=e.keyCode===BACKSPACE_KEYCODE,r=e.keyCode===SPACE_KEYCODE?" ":String.fromCharCode(e.keyCode).trim();if(!r&&!t)return;const s=getListNode(e.target);if(!s)return;const n=getUri(s);if(!n)return;if(t&&!searchStringsByUri[n])return;n in searchStringsByUri||(searchStringsByUri[n]=""),t?searchStringsByUri[n]=searchStringsByUri[n].slice(0,-1):r&&(searchStringsByUri[n]+=r),center.emit("list-quick-jump-request",n,searchStringsByUri[n]||null),searchTimeoutsByUri[n]&&clearTimeout(searchTimeoutsByUri[n]),e.keyCode===SPACE_KEYCODE&&e.preventDefault();const o=[{keyCode:SPACE_KEYCODE},{keyCode:BACKSPACE_KEYCODE},{keyCode:DELETE_KEYCODE}];cosmos.post({url:"sp://messages/v1/ignoreshortcuts",body:{action:"ignore",shortcuts:o}}),searchTimeoutsByUri[n]=setTimeout(function(){cosmos.post({url:"sp://messages/v1/ignoreshortcuts",body:{action:"unignore",shortcuts:o}}),delete searchStringsByUri[n],delete searchTimeoutsByUri[n],center.emit("list-quick-jump-request",n,null)},SEARCH_STRING_CONCATENATION_TIMEOUT)}function shouldEventBeIgnored(e){return e.metaKey||e.ctrlKey||e.target.matches("input, textarea, [contenteditable]")}function getListNode(e){let t=e.closest(selector);if(!t){const e=document.querySelectorAll(selector);e&&1===e.length&&(t=e[0])}return t}function getUri(e){const t=e.closest("[data-uri]");return t&&t.getAttribute("data-uri")}

},{"./center":246,"./util/cosmos":318}],289:[function(require,module,exports){
(function (global){
"use strict";const $=require("../spotify-elements"),live=require("../live"),center=require("./center"),selection=require("./selection"),cosmos=require("./util/cosmos"),appUtil=require("./util/app"),ROW_SELECTOR="[data-list-item]",UNAVAILABLE_CLASS_NAME="unavailable",OFFLINE_DOWNLOADED_CLASS_NAME="offline-downloaded",OFFLINE_DOWNLOADING_CLASS_NAME="offline-downloading",OFFLINE_WAITING_CLASS_NAME="offline-waiting",storedTrackURIsForUnplayable={},storedTrackURIsForOffline={};function updatePlayabilityForRows(e,o){const t=$(document).search(`${ROW_SELECTOR}[data-uri="${e}"]`);t&&updatePlayabilityForElements(t,o)}function updatePlayabilityForElements(e,o){o?e.removeClass(UNAVAILABLE_CLASS_NAME):e.addClass(UNAVAILABLE_CLASS_NAME)}function updateOfflineForRows(e,o,t){const n=$(document).search(`${ROW_SELECTOR}[data-uri="${e}"]`);n&&updateOfflineForElements(n,o,t)}function updateOfflineForElements(e,o,t){o?1===t?(e.addClass(OFFLINE_DOWNLOADED_CLASS_NAME),e.removeClass(OFFLINE_DOWNLOADING_CLASS_NAME),e.removeClass(OFFLINE_WAITING_CLASS_NAME)):0===t?(e.addClass(OFFLINE_WAITING_CLASS_NAME),e.removeClass(OFFLINE_DOWNLOADED_CLASS_NAME),e.removeClass(OFFLINE_DOWNLOADING_CLASS_NAME)):(e.addClass(OFFLINE_DOWNLOADING_CLASS_NAME),e.removeClass(OFFLINE_DOWNLOADED_CLASS_NAME),e.removeClass(OFFLINE_WAITING_CLASS_NAME)):(e.removeClass(OFFLINE_DOWNLOADED_CLASS_NAME),e.removeClass(OFFLINE_DOWNLOADING_CLASS_NAME),e.removeClass(OFFLINE_WAITING_CLASS_NAME))}function updateUnplayableRows(e,o){const t=o||($(e)||$(document)).search(ROW_SELECTOR);t&&t.forEach(function(e){const o=$(e).data("uri"),t=live(o),n=t.get("playable");void 0!==n&&updatePlayabilityForElements($(e),n),o in storedTrackURIsForUnplayable||(storedTrackURIsForUnplayable[o]=!0,t.on("update",function(e){"playable"in e&&updatePlayabilityForRows(o,e.playable)}))})}function updateOfflineSyncing(e,o){const t=o||($(e)||$(document)).search(ROW_SELECTOR);t&&t.forEach(function(e){const o=$(e).data("uri"),t=live(o);t.query("shouldBeOffline, offlineProgress",function(n,s){if(n)throw n;updateOfflineForElements($(e),s.shouldBeOffline,s.offlineProgress),o in storedTrackURIsForOffline||(storedTrackURIsForOffline[o]=!0,t.on("update",function(e){("shouldBeOffline"in e||"offlineProgress"in e)&&updateOfflineForRows(o,t.get("shouldBeOffline"),t.get("offlineProgress"))}))},live.ASAP)})}const ignoredShortcuts={};function handleKeyDown(e){if(!e.target.closest(ROW_SELECTOR)||ignoredShortcuts[JSON.stringify({keyCode:e.keyCode})])return;let o=!1;const t=/Win/.test(global.window.navigator.userAgent),n=8===e.keyCode,s=46===e.keyCode;(o=t?s:n||s)&&removeCurrentlySelectedListItems()}function removeCurrentlySelectedListItems(){const e=selection.getIndicesPerList();if(e.length>0){let o=null;e.forEach(function(e){let t=e;t.origin&&(t=t.origin);const n=live(t.uri),s=t.indices.sort(function(e,o){return e-o});n.query("allows(removeTracks)",function(e,t){if(e)throw e;t.allows.removeTracks&&n.get("rows",function(e,t){if(e)throw e;const n=s.map(function(e,o){return{type:"remove",index:e-o,length:1}});t.publish(n),null===o&&(o=s[0])})})})}}function handleScrollShow(e){updateUnplayableRows(e.container,e.nodes),updateOfflineSyncing(e.container,e.nodes)}exports._classNames={UNAVAILABLE:UNAVAILABLE_CLASS_NAME,OFFLINE_WAITING:OFFLINE_WAITING_CLASS_NAME,OFFLINE_DOWNLOADING:OFFLINE_DOWNLOADING_CLASS_NAME,OFFLINE_DOWNLOADED:OFFLINE_DOWNLOADED_CLASS_NAME};let isAttached=!1;exports.update=function(e){isAttached&&(updateUnplayableRows(e),updateOfflineSyncing(e))};const doc=$(document);let deleteSubscription,ignoredShortcutsSubscription;exports.attach=function(){isAttached||(isAttached=!0,doc.on("keydown",handleKeyDown),center.on("scroll-show-before",handleScrollShow),deleteSubscription=cosmos.subscribe({url:"sp://messages/v1/container/control"},function(e,o){if(e)throw e;const t=o.body;t&&"delete"===t.type&&appUtil.isActiveAndFocused()&&removeCurrentlySelectedListItems()}),ignoredShortcutsSubscription=cosmos.subscribe({url:"sp://messages/v1/ignoreshortcuts"},function(e,o){"ignore"===o.body.action?o.body.shortcuts.forEach(function(e){ignoredShortcuts[JSON.stringify(e)]=1}):"unignore"===o.body.action&&o.body.shortcuts.forEach(function(e){delete ignoredShortcuts[JSON.stringify(e)]})}))},exports.detach=function(){isAttached&&(isAttached=!1,doc.off("keydown",handleKeyDown),center.off("scroll-show-before",handleScrollShow),deleteSubscription&&(deleteSubscription.cancel(),deleteSubscription=null),ignoredShortcutsSubscription&&(ignoredShortcutsSubscription.cancel(),ignoredShortcutsSubscription=null))};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../live":192,"../spotify-elements":235,"./center":246,"./selection":306,"./util/app":317,"./util/cosmos":318}],290:[function(require,module,exports){
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.attach=attach,exports.detach=detach,exports.update=update;var _throttle=require("./util/throttle"),_throttle2=_interopRequireDefault(_throttle),_center=require("./center"),_center2=_interopRequireDefault(_center),_navigation=require("../navigation"),_navigation2=_interopRequireDefault(_navigation),_appState=require("../navigation/app-state"),_appState2=_interopRequireDefault(_appState);function _interopRequireDefault(e){return e&&e.__esModule?e:{default:e}}const SELECTOR_MENU="[data-menu]",SELECTOR_MENU_ITEM="[data-menu-item]",SELECTOR_MENU_ITEM_DISABLED="[data-menu-item-disabled]",SELECTOR_MENU_ITEM_ENABLED="[data-menu-item]:not([data-menu-item-disabled])",SELECTOR_SUBMENU='[data-submenu="true"]',ATTRIBUTE_MENU="data-menu",ATTRIBUTE_MENU_ITEM="data-menu-item",navigator=new _navigation2.default.Navigator;let isAttached=!1;const state={menu:null};function onMouseMove(e){if(e.target.matches(SELECTOR_MENU))return;const t=e.target.closest(SELECTOR_MENU_ITEM);if(!t)return;const n=getStateForMenu(t.closest(SELECTOR_MENU));let o=getStateForActiveMenu();t!==o.selectedNode&&(t.matches(SELECTOR_MENU_ITEM_DISABLED)?deselectItemInMenu(o):(selectItemInMenu(o,n,t),o=getStateForActiveMenu()),t.matches(SELECTOR_SUBMENU)?n.menu||openSubMenu(n,t):o.menu&&closeSubMenuOf(o))}const onMouseMoveThrottled=(0,_throttle2.default)(onMouseMove);function onFocus(e){const t=e.target.closest(SELECTOR_MENU);t&&!state.menu&&(state.menu={node:t,selectedNode:null,menu:null,active:!0,parent:null},t.addEventListener("mousemove",onMouseMoveThrottled),t.addEventListener("mouseleave",onMouseLeave),t.addEventListener("touchstart",onMouseMove,!0))}function onBlur(e){const{target:t,relatedTarget:n}=e;state.menu&&(t===state.menu.node?n&&t.contains(n)||hideMenu():state.menu.node.contains(t)&&!state.menu.node.contains(n)&&hideMenu())}function onKeyDown(e){if(!state.menu)return;const t=e.keyCode,n=27===t,o=38===t,u=40===t,s=37===t,i=39===t;if(13===t){const e=getStateForActiveMenu().selectedNode,t=e&&e.querySelector("a[href]");return t&&navigator.requestOpenState(new _appState2.default(t.getAttribute("href"))),void emitActivateItemEvent(e)}if(n)hideMenu();else if(o||u){const e=getStateForActiveMenu();if(e.node){const t=u?getMenuItemBelow(e):getMenuItemAbove(e);t&&selectItemInMenu(e,e,t)}}else if(i){const e=getStateForActiveMenu();if(e.selectedNode&&e.selectedNode.matches(SELECTOR_SUBMENU)){e.menu||openSubMenu(e,e.selectedNode);const t=e.menu.node,n=t.firstElementChild||t.firstChild;selectItemInMenu(e,e.menu,n)}}else if(s){const e=getStateForActiveMenu();e.parent&&closeSubMenuOf(e.parent)}else;}function onMouseLeave(e){if(!e.relatedTarget||!e.relatedTarget.closest(SELECTOR_MENU)){const e=getStateForActiveMenu();deselectItemInMenu(e),e.menu&&closeSubMenuOf(e)}}function onItemClick(e){emitActivateItemEvent(getStateForMenu(e.target.closest(SELECTOR_MENU)).selectedNode)}function onItemTouchStart(e){e.preventDefault(),onItemClick(e)}function emitActivateItemEvent(e){_center2.default.emit("menu-activate-item",{menu:{id:state.menu.node.getAttribute(ATTRIBUTE_MENU)||"",element:state.menu.node},item:{id:e.getAttribute(ATTRIBUTE_MENU_ITEM)||"",element:e}})}function selectItemInMenu(e,t,n){const o=e.menu===t,u=isSecondContainedInFirst(t,e);o?removeItemListeners(e.selectedNode):deselectItemInMenu(e),u&&deselectItemInMenu(t),e.active=!1,t.selectedNode!==n&&(n.classList.add("selected"),n.focus(),addItemListeners(n),t.selectedNode=n),t.active=!0}function deselectItemInMenu(e){if(e.selectedNode){const t=e.selectedNode;t.classList.remove("selected"),removeItemListeners(t),e.selectedNode=null}}function addItemListeners(e){e.addEventListener("click",onItemClick),e.addEventListener("touchstart",onItemTouchStart)}function removeItemListeners(e){e.removeEventListener("click",onItemClick),e.removeEventListener("touchstart",onItemTouchStart)}function openSubMenu(e,t){const n=t.querySelector(SELECTOR_MENU);n&&(e.menu={parent:e,node:n,selectedNode:null,menu:null,active:!1},n.classList.add("open"))}function closeSubMenuOf(e){e.menu.menu&&closeSubMenuOf(e.menu),e.selectedNode.focus(),e.menu.active&&(e.menu.active=!1,e.active=!0),deselectItemInMenu(e.menu),e.menu.node.classList.remove("open"),e.menu=null}function hideMenu(){if(state.menu){const e=state.menu.node;e.removeEventListener("mousemove",onMouseMoveThrottled),e.removeEventListener("mouseleave",onMouseLeave),e.removeEventListener("touchstart",onMouseMove,!0);let t=state.menu;for(;t;)deselectItemInMenu(t),t.node.classList.remove("open"),t=t.menu;delete state.menu,_center2.default.emit("menu-hide",{menu:{id:e.getAttribute(ATTRIBUTE_MENU)||"",element:e}})}}function isSecondContainedInFirst(e,t){let n=e.menu;for(;n&&n!==t;)n=n.menu;return!!n}function getStateForMenu(e){let t=state.menu;for(;t&&t.node!==e;)t=t.menu;return t}function getStateForActiveMenu(){let e=state.menu;for(;e&&!e.active;)e=e.menu;return e}function getMenuItemBelow(e){if(!e.selectedNode)return e.node.querySelector(SELECTOR_MENU_ITEM_ENABLED);let t=e.selectedNode.nextElementSibling;for(;t;){const e=t.matches(SELECTOR_MENU_ITEM),n=t.matches(SELECTOR_MENU_ITEM_DISABLED);if(e&&!n)break;t=t.nextElementSibling}return t}function getMenuItemAbove(e){if(!e.selectedNode){const t=e.node.querySelectorAll(SELECTOR_MENU_ITEM_ENABLED);return t[t.length-1]||null}let t=e.selectedNode.previousElementSibling;for(;t;){const e=t.matches(SELECTOR_MENU_ITEM),n=t.matches(SELECTOR_MENU_ITEM_DISABLED);if(e&&!n)break;t=t.previousElementSibling}return t}function attach(){isAttached||(isAttached=!0,document.addEventListener("keydown",onKeyDown),document.addEventListener("focus",onFocus,!0),document.addEventListener("blur",onBlur,!0))}function detach(){isAttached&&(isAttached=!1,state.menu=null,document.removeEventListener("keydown",onKeyDown),document.removeEventListener("focus",onFocus,!0),document.removeEventListener("blur",onBlur,!0))}function update(){}

},{"../navigation":211,"../navigation/app-state":210,"./center":246,"./util/throttle":321}],291:[function(require,module,exports){
(function (global){
"use strict";const $=require("../spotify-elements"),live=require("../live"),center=require("./center"),NAVBAR_ATTR_NAME="data-navbar",ITEM_ID_ATTR_NAME="data-navbar-item-id",ITEM_MATCHER_ATTR_NAME="data-navbar-item-matcher",VIEW_ID_ATTR_NAME="data-navbar-view-id",ACTIVE_ID_ATTR_NAME="data-navbar-active-id",HISTORY_POS_ATTR_NAME="data-navbar-history-position",CLASSNAME_ACTIVE="active",OVERFLOW_MENU_ID="navbar-overflow-menu",STICKY_WRAPPER_ATTR_NAME="data-sticky-fixed-wrapper",APPLICATION_MODEL_URI="spotify:application",storedMatchers={};let navbarOverflowItems,isShowingNavbarOverflow,shouldShowNavbarOverflow;const getSelector=function(e,t,n){return t&&n?`[${e}${t}"${n}"`+"]":`[${e}]`},updateOverflowMenu=function(){const e=document.querySelector("[data-navbar-item-id=navbar-overflow-menu]");if(e){if(navbarOverflowItems&&navbarOverflowItems.length||(shouldShowNavbarOverflow=!1),shouldShowNavbarOverflow){isShowingNavbarOverflow=!0;const t=navbarOverflowItems.map(function(e){const t=e.querySelector("a[href]");return{name:e.firstElementChild&&e.firstElementChild.textContent||"",id:e.getAttribute(ITEM_ID_ATTR_NAME),url:t&&t.getAttribute("href"),active:e.classList.contains("active")}}),n=e.getBoundingClientRect(),o="rtl"===document.documentElement.getAttribute("dir");global.top.postMessage({type:"show-navbar-overflow",items:t,right:o?null:n.right,left:o?n.left:null,top:n.bottom},"*")}!shouldShowNavbarOverflow&&isShowingNavbarOverflow&&(isShowingNavbarOverflow=!1,global.top.postMessage({type:"hide-navbar-overflow"},"*"))}},getTabsForId=function(e){if(!e)return[];const t=document.querySelectorAll(getSelector(ITEM_ID_ATTR_NAME,"=",e));return Array.prototype.slice.call(t)},getView=function(e){return document.querySelector(getSelector(VIEW_ID_ATTR_NAME,"=",e))},getNavbar=function(e){const t=e||document.documentElement,n=getSelector("data-navbar");return t.matches(n)?t:t.querySelector(n)},getActiveTab=function(){const e=getNavbar();if(!e)return null;const t=e.getAttribute(ACTIVE_ID_ATTR_NAME);return getTabsForId(t)[0]},getTabs=function(){const e=document.querySelectorAll(getSelector(ITEM_ID_ATTR_NAME));return Array.prototype.slice.call(e)},setActiveTabs=function(e,t){const n=getNavbar();if(!n)return;n.setAttribute(ACTIVE_ID_ATTR_NAME,e),t.forEach(function(e){e.classList.add("active")});const o=getTabs();o.length&&o.forEach(function(t){t.getAttribute(ITEM_ID_ATTR_NAME)!==e&&t.classList.remove("active")})},getViews=function(){const e=document.querySelectorAll(getSelector(VIEW_ID_ATTR_NAME));return Array.prototype.slice.call(e)},hide=function(e){e.style.display="none"},show=function(e){e.style.display="block"},setActiveView=function(e,t){if(!t)return;const n=getViews();for(let e=0,o=n.length;e<o;e++)n[e]!==t[0]&&(n[e].style.display="none");show(t)},setActive=function(e,t,n){const o=getActiveTab();(o&&o.getAttribute(ITEM_ID_ATTR_NAME))!==e&&(setActiveTabs(e,t),setActiveView(0,n),center.emit("navbar-change",{id:e}))},activateItem=function(e){updateScrollPosition();const t=getView(e),n=getTabsForId(e);setActive(e,n,t)},handleClick=function(e,t){const n=t.getAttribute(ITEM_ID_ATTR_NAME);if(n===OVERFLOW_MENU_ID)return shouldShowNavbarOverflow=!0,void updateOverflowMenu();activateItem(n),e.preventDefault()},hideOverflow=function(){isShowingNavbarOverflow&&(shouldShowNavbarOverflow=!1,updateOverflowMenu())},onMessage=function(e){e.data&&"navbar-overflow-click"===e.data.name&&activateItem(e.data.itemId),e.data&&"hide-navbar-overflow"===e.data.name&&hideOverflow()},getFirstTabId=function(){const e=document.querySelector(getSelector(ITEM_ID_ATTR_NAME));return e?e.getAttribute(ITEM_ID_ATTR_NAME)===OVERFLOW_MENU_ID?null:e.getAttribute(ITEM_ID_ATTR_NAME):null},setActiveForMatchingId=function(e){let t,n,o=0;for(;o<e.length&&(!t||!t.length);)e[o]&&(n=e[o],t=getTabsForId(n)),o++;const r=n;if(!t||!t.length)return;const i=getView(r);setActive(r,t,i)},fixAppURI=function(e){return e.split(":").slice(0,3).join(":")},getIdFromMatchers=function(e){for(const t in storedMatchers)if(storedMatchers.hasOwnProperty(t)){if(new RegExp(t).test(e))return storedMatchers[t]}return null},updateForNode=function(e){const t=getNavbar(e);t&&live("spotify:application").query("appURI, arguments",function(e,n){if(e)throw e;let o=fixAppURI(n.appURI);n.arguments&&(o+=`:${n.arguments}`);const r=getIdFromMatchers(o);if(r)setActiveForMatchingId([r]);else{const e=+t.getAttribute(HISTORY_POS_ATTR_NAME)||0,r=n.arguments.split(":")[e],i=getFirstTabId();setActiveForMatchingId([o,r,i])}})};function updateForOverflow(e){const t=getNavbar(e);if(!t)return;let n=e.querySelectorAll("[data-navbar] > [data-navbar-item-id]:not(.overflow-menu-button)");if(!n)return;n=Array.prototype.slice.call(n);const o=t.querySelector(".overflow-menu-button");if(n.length<2)return t.style.visibility="visible",void(o&&(o.style.display="none"));const r=getWidth(t);if(!r)return;o&&(o.style.display="inline"),n.forEach(function(e){e.style.display="block",e.classList.remove("last-visible")});const i=measureNavbar(n,o);let a=r,l=getFirstOverflownIndex(a,i.itemWidths);const c=n.length!==l;c&&(a-=i.overflowMenuButtonWidth,l=getFirstOverflownIndex(a,i.itemWidths)),navbarOverflowItems||(navbarOverflowItems=[]),navbarOverflowItems.length=0,n.forEach(function(e,t){const o=t>=l;o&&navbarOverflowItems.push(e);const r=!c&&t===n.length-1;e.style.display=o?"none":"block",e.classList.toggle("last-visible",r)}),o&&(o.style.display=c?"inline":"none"),updateOverflowMenu(),t.style.visibility="visible"}function updateScrollPosition(){const e=window.pageYOffset,t=Array.prototype.slice.call(document.querySelectorAll(`[${STICKY_WRAPPER_ATTR_NAME}]`));if(0===t.length)return;const n=t.reduce(function(e,t){const n=t.getBoundingClientRect().top;return n<e?n:e},0),o=parseInt(document.body.getAttribute("data-top-bar-height"),10)||0;n<0&&window.scrollTo(0,e+n+1-o)}function handleResize(){updateForOverflow(document.body)}function measureNavbar(e,t){const n=e[0],o=e[1],r="rtl"===document.documentElement.getAttribute("dir"),i=Math.floor((r?o:n).getBoundingClientRect().right),a=(Math.floor((r?n:o).getBoundingClientRect().left)-i)/2;let l=[];e&&(l=e.map(function(e,t,n){const o=0===t?0:a,r=t===n.length-1?0:a;return getWidth(e)+o+r}));let c=0;return t&&(c=getWidth(t)+a),{itemWidths:l,overflowMenuButtonWidth:c}}function getWidth(e){return e&&e.offsetWidth||0}function getFirstOverflownIndex(e,t){let n=0,o=0;for(;void 0!==t[n]&&o<e;)o+=t[n],n++;return o<e?n:n-1}const getMatchers=function(e){let t=e.querySelectorAll(getSelector(ITEM_MATCHER_ATTR_NAME));t.length&&(t=Array.prototype.slice.call(t)).forEach(function(e){const t=e.getAttribute(ITEM_MATCHER_ATTR_NAME),n=e.getAttribute(ITEM_ID_ATTR_NAME);storedMatchers[t]=n})},onApplicationChange=function(e){("arguments"in e||"active"in e)&&updateForNode(document.documentElement)};let isAttached=!1;exports.update=function(e){isAttached&&(updateForNode(e||document.documentElement),getMatchers(e||document.documentElement),updateForOverflow(e||document.documentElement))},exports.attach=function(){isAttached||(isAttached=!0,$(document).delegate("click",getSelector(ITEM_ID_ATTR_NAME),handleClick),window.addEventListener("message",onMessage),live("spotify:application").on("update",onApplicationChange),window.addEventListener("resize",handleResize),center.on("navbar-hide",hideOverflow))},exports.detach=function(){isAttached&&(isAttached=!1,navbarOverflowItems=null,isShowingNavbarOverflow=!1,shouldShowNavbarOverflow=!1,$(document).undelegate("click",getSelector(ITEM_ID_ATTR_NAME),handleClick),window.removeEventListener("message",onMessage),live("spotify:application").off("update",onApplicationChange),window.removeEventListener("resize",handleResize),center.off("navbar-hide",hideOverflow))};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../live":192,"../spotify-elements":235,"./center":246}],292:[function(require,module,exports){
"use strict";var _liveWrappedUri=require("../live-wrapped-uri"),_liveWrappedUri2=_interopRequireDefault(_liveWrappedUri),_station=require("../live-models/station");function _interopRequireDefault(e){return e&&e.__esModule?e:{default:e}}const dom=require("./util/dom"),$=require("../spotify-elements"),live=require("../live"),SELECTOR_NFT_FEEDBACK_BUTTON=".nft-enabled .feedback-enabled [data-button=add]";let isAttached=!1;function handleFeedbackClick(e,t){const i=t[0],r=dom.getAttributeFromNodeOrParent(i,"data-uri");let a=dom.getContextFromNodeOrParent(i);if(_liveWrappedUri2.default.parse(a)&&(a=_liveWrappedUri2.default.parse(a).originUri),!r||!a)return;const d=i.getAttribute("data-interaction-intent");if((0,_station.isOrdinaryRadioUri)(a))"save"===d&&live(a).emit("thumb-up",r);else switch(d){case"save":live(a).emit("heart",r);break;case"remove":live(a).emit("undo-heart",r)}}exports.update=(()=>{}),exports.attach=(()=>{if(isAttached)return;isAttached=!0,$(document).delegate("click",SELECTOR_NFT_FEEDBACK_BUTTON,handleFeedbackClick)}),exports.detach=(()=>{if(!isAttached)return;isAttached=!1,$(document).undelegate("click",SELECTOR_NFT_FEEDBACK_BUTTON,handleFeedbackClick)});

},{"../live":192,"../live-models/station":181,"../live-wrapped-uri":191,"../spotify-elements":235,"./util/dom":319}],293:[function(require,module,exports){
"use strict";const $=require("../spotify-elements"),live=require("../live");let sessionModel;function onSessionUpdate(e){"online"in e&&(e.online?$(document.body).removeClass("offline"):$(document.body).addClass("offline"))}function updateWithSessionValue(){live("spotify:client").query("session(online)",function(e,s){if(e)throw e;onSessionUpdate({online:s.session.online})})}let isAttached=!1;exports.update=function(){isAttached&&updateWithSessionValue()},exports.attach=function(){isAttached||(isAttached=!0,sessionModel||live("spotify:client").get("session",function(e,s){if(e)throw e;(sessionModel=s).on("update",onSessionUpdate)}))},exports.detach=function(){isAttached&&(isAttached=!1,sessionModel&&(sessionModel.off("update",onSessionUpdate),sessionModel=null))};

},{"../live":192,"../spotify-elements":235}],294:[function(require,module,exports){
"use strict";var _extends=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var o=arguments[t];for(var l in o)Object.prototype.hasOwnProperty.call(o,l)&&(e[l]=o[l])}return e};const $=require("../../spotify-elements"),utils=require("./utils"),SELECTOR_LIST_ROW="[data-context] [data-list-item]",SELECTOR_PLAY_BUTTON="[data-button=play]",SELECTOR_PLAY_CONTEXT_BUTTON="[data-button=play-context]";let lastEventTypes=[];const methods={getPlayerVariantUri:utils.createEmptyMethod("getPlayerVariantUri"),handlePlayButton:utils.createEmptyMethod("handlePlayButton"),handlePlayFromRow:utils.createEmptyMethod("handlePlayFromRow")};function handlePlayButtonClick(e,t){const o=t[0],l=utils.getUriFromButton(o);if(!l)return;const n=methods.getPlayerVariantUri(),s="queue"!==methods.getPlayerTrackProvider()&&utils.compareContexts(n,l),a=utils.getAttributeValueFromNode(o,"data-play-source");methods.handlePlayButton(o,{isPlayingContext:s,contextUri:l,source:a,reason:"playbtn"})}function handleListRow(e){const t=e[0],o=$(t.closest("[data-context]"));if(o&&!t.classList.contains("thumbs-down")){const e=utils.getAttributeValueFromNode(t,"data-play-source");methods.handlePlayFromRow(t,{contextUri:o.data("uri"),source:e,reason:"clickrow"})}}function handleRowDoubleClick(e,t){utils.isInteractiveElement(e.target)||handleListRow(t)}function handleRowKeyDown(e,t){if(13===e.keyCode){if(utils.isFormOrLinkElement(e.target))return;e.preventDefault(),e.stopPropagation(),handleListRow(t)}}function handleContextMenu(e){lastEventTypes.push(e.type)}function handleRowTouchStart(e){lastEventTypes.push(e.type)}function handleRowTouchMove(e){lastEventTypes.push(e.type)}function handleRowTouchEnd(e,t){1===lastEventTypes.length&&"touchstart"===lastEventTypes[0]&&(utils.isInteractiveElement(e.target)||(e.preventDefault(),handleListRow(t))),lastEventTypes=[]}const defaultSelectors={selectorPlayButton:"[data-button=play]",selectorListRow:SELECTOR_LIST_ROW,selectorPlayContextButton:"[data-button=play-context]"};let selectors=defaultSelectors;exports.attach=function(){const e=$(document);e.delegate("keydown",selectors.selectorListRow,handleRowKeyDown),e.delegate("click",selectors.selectorPlayButton,handlePlayButtonClick),e.delegate("click",selectors.selectorPlayContextButton,handlePlayButtonClick),e.delegate("dblclick",selectors.selectorListRow,handleRowDoubleClick),e.delegate("touchstart",selectors.selectorListRow,handleRowTouchStart),e.delegate("touchend",selectors.selectorListRow,handleRowTouchEnd),e.delegate("touchmove",selectors.selectorListRow,handleRowTouchMove),e.delegate("contextmenu",selectors.selectorListRow,handleContextMenu)},exports.detach=function(){const e=$(document);e.undelegate("keydown",selectors.selectorListRow,handleRowKeyDown),e.undelegate("click",selectors.selectorPlayButton,handlePlayButtonClick),e.undelegate("click",selectors.selectorPlayContextButton,handlePlayButtonClick),e.undelegate("dblclick",selectors.selectorListRow,handleRowDoubleClick),e.undelegate("touchstart",selectors.selectorListRow,handleRowTouchStart),e.undelegate("touchend",selectors.selectorListRow,handleRowTouchEnd),e.undelegate("touchmove",selectors.selectorListRow,handleRowTouchMove),e.undelegate("contextmenu",selectors.selectorListRow,handleContextMenu)},exports.setSelectors=function(e={}){exports.detach(),selectors=_extends({},defaultSelectors,e),exports.attach()},exports.setMethods=function(e){for(const t in e)e.hasOwnProperty(t)&&(methods[t]=e[t])};

},{"../../spotify-elements":235,"./utils":297}],295:[function(require,module,exports){
"use strict";const playerWithIndices=require("./withIndices"),playerWithUids=require("./withUids"),actions=require("./actions");let playerModule=playerWithIndices;exports.setMode=function(e){switch(e){case"indices":playerModule=playerWithIndices;break;case"uids":playerModule=playerWithUids}},exports.setSelectors=actions.setSelectors,exports.attach=function(){playerModule.attach()},exports.detach=function(){playerModule.detach()},exports.update=function(e){playerModule.update(e)};

},{"./actions":294,"./withIndices":298,"./withUids":299}],296:[function(require,module,exports){
"use strict";const difference=require("mout/array/difference"),$=require("../../spotify-elements"),live=require("../../live"),center=require("../center"),utils=require("./utils"),CURRENT="current",PAUSED="paused",PLAYING="playing",LOG_PLAY_BUTTON="play-button",LOG_PAUSE_BUTTON="pause-button",LOG_INTENT_PLAY="play",LOG_INTENT_PAUSE="pause",SELECTOR_PLAY_BUTTON="[data-button=play]",SELECTOR_PLAY_CONTEXT_BUTTON="[data-button=play-context]",SELECTOR_ALL_PLAY_BUTTONS=`${SELECTOR_PLAY_BUTTON},[data-button=play-context]`,INTERACTION_INTENT_ATTR="data-interaction-intent",SELECTOR_PLAYABLE_ROW="[data-context-index]",methods={getPlayerVariantUri:utils.createEmptyMethod("getPlayerVariantUri"),getPlayerIsPlaying:utils.createEmptyMethod("getPlayerIsPlaying"),getPlayingNodes:utils.createEmptyMethod("getPlayingNodes"),subscribeToPlayerChange:utils.createEmptyMethod("subscribeToPlayerChange")};let playableChangeHandlers={},playerSubscription=null;function updateDOM(e){const t=e||document;updateButtonsBasedOnPlayable(t);const a=getPlayingNodes(t),n=getCurrentNodes(t);if(n){let e=n;a&&(e=difference(n,a)),e.forEach(removePlayingStateFromNode)}if(a){let e=a;n&&(e=difference(a,n)),e.forEach(addPlayingStateToNode),difference(a,e).forEach(updatePlayingStateForNode)}}function updateButtonsBasedOnPlayable(e){const t=$(e).search("[data-button=play-context]");t&&t.forEach(updateButtonBasedOnPlayable)}function updateButtonBasedOnPlayable(e){if($(e).parent("[data-list-item]"))return;const t=utils.getUriFromButton(e),a=live(t).get("playable");void 0!==a&&(a?e.removeAttribute("disabled"):e.setAttribute("disabled","disabled"),playableChangeHandlers[t]||(playableChangeHandlers[t]=function(e){e.hasOwnProperty("playable")&&updateButtonsBasedOnPlayable(document.body)},live(t).on("update",playableChangeHandlers[t])))}function getCurrentNodes(e){return $(e).search("[data-playback-active=true]")}function getPlayingNodes(e){let t=[];if("queue"!==methods.getPlayerTrackProvider()){const a=methods.getPlayerVariantUri(),n=utils.getContextSelectorsWithVariants(a),r=$(e).search(n.join(", "));r&&(t=Array.prototype.slice.call(r))}return methods.getPlayingNodes(e,t)}function removePlayingStateFromNode(e){const t=[CURRENT,PAUSED,PLAYING].join(" "),a=$(e);if(a.removeClass(t).removeAttribute("data-playback-active"),a.matches(SELECTOR_ALL_PLAY_BUTTONS)&&(a.attribute("data-log-click",LOG_PLAY_BUTTON),a.attribute(INTERACTION_INTENT_ATTR,LOG_INTENT_PLAY)),a.matches(SELECTOR_PLAYABLE_ROW)){const e=a[0].querySelector(SELECTOR_PLAY_BUTTON);e&&e.setAttribute(INTERACTION_INTENT_ATTR,LOG_INTENT_PLAY)}}function addPlayingStateToNode(e){const t=methods.getPlayerIsPlaying(),a=[CURRENT,t?PLAYING:PAUSED].join(" "),n=$(e);if(n.addClass(a).data("playback-active",!0),n.matches(SELECTOR_ALL_PLAY_BUTTONS)&&(n.attribute("data-log-click",t?LOG_PAUSE_BUTTON:LOG_PLAY_BUTTON),n.attribute(INTERACTION_INTENT_ATTR,t?LOG_INTENT_PAUSE:LOG_INTENT_PLAY)),n.matches(SELECTOR_PLAYABLE_ROW)){const e=n[0].querySelector(SELECTOR_PLAY_BUTTON);e&&e.setAttribute(INTERACTION_INTENT_ATTR,t?LOG_INTENT_PAUSE:LOG_INTENT_PLAY)}}function updatePlayingStateForNode(e){const t=methods.getPlayerIsPlaying(),a=t?PAUSED:PLAYING,n=t?PLAYING:PAUSED,r=$(e);if(r.hasClass(a)&&r.removeClass(a),r.hasClass(n)||r.addClass(n),r.matches(SELECTOR_ALL_PLAY_BUTTONS)&&(r.attribute("data-log-click",t?LOG_PAUSE_BUTTON:LOG_PLAY_BUTTON),r.attribute(INTERACTION_INTENT_ATTR,t?LOG_INTENT_PAUSE:LOG_INTENT_PLAY)),e.matches(SELECTOR_PLAYABLE_ROW)){const a=e.querySelector(SELECTOR_PLAY_BUTTON);a&&a.setAttribute(INTERACTION_INTENT_ATTR,t?LOG_INTENT_PAUSE:LOG_INTENT_PLAY)}}function handleScrollShowAfter(e){const t=$(e.container);let a=null;updateDOM((a=t.matches("[data-context]")?t:t.parent("[data-context]"))&&a[0].parentElement||document)}exports.attach=function(){playerSubscription=methods.subscribeToPlayerChange(function(){updateDOM()}),center.on("scroll-show-after",handleScrollShowAfter)},exports.detach=function(){playerSubscription&&(playerSubscription.cancel(),playerSubscription=null);for(const e in playableChangeHandlers)playableChangeHandlers.hasOwnProperty(e)&&live(e).off("update",playableChangeHandlers[e]);playableChangeHandlers={},center.off("scroll-show-after",handleScrollShowAfter)},exports.update=updateDOM,exports.setMethods=function(e){for(const t in e)e.hasOwnProperty(t)&&(methods[t]=e[t])};

},{"../../live":192,"../../spotify-elements":235,"../center":246,"./utils":297,"mout/array/difference":411}],297:[function(require,module,exports){
(function (global){
"use strict";const liburi=require("spotify-liburi"),getOriginUri=require("../../live-wrapped-uri").getOriginUri;function getUriFromButton(t){const e=t.closest("[data-context]");return e&&e.getAttribute("data-uri")||""}function getAttributeValueFromNode(t,e){const r=`[${e}]`,o=t.closest(r);return o&&o.getAttribute(e)||""}function isFormOrLinkElement(t){const e=t.tagName.toLowerCase();return["input","textarea","button","select","optgroup","option","a"].indexOf(e)>-1}function isInteractiveElement(t){const e=t.tagName.toLowerCase();return"a"===e||"button"===e}function getContextSelector(t,e){return`[data-context][data-uri${t}${e}]`}function getContextSelectorsWithVariants(t){const e=getOriginUri(t)||t,r=normalizeUri(e),o=normalizeUri(e.replace(/^spotify:/,":")),n=[getContextSelector("=",e)];return n.push(getContextSelector("^=","spotify:internal:filterlist:")+getContextSelector("$=",e.replace(/^spotify:/,":"))),n.push(getContextSelector("^=","spotify:internal:sortlist:")+getContextSelector("$=",e.replace(/^spotify:/,":"))),e!==r&&(n.push(getContextSelector("=",r)),n.push(getContextSelector("^=","spotify:internal:filterlist:")+getContextSelector("$=",o)),n.push(getContextSelector("^=","spotify:internal:sortlist:")+getContextSelector("$=",o))),n}function compareContexts(t,e){if(!t||!e)return!1;return normalizeUri(getOriginUri(t)||t)===normalizeUri(getOriginUri(e)||e)}function normalizeUri(t){const e=liburi.from(t);let r=e?e.toString():t;return r=(r=r.replace(/^spotify:app:internal:/,"spotify:internal:")).replace(/:internal:filterlist:[^:]+/,function(t){return t.replace(/\+/g,"%20")})}function createEmptyMethod(t){return function(){global.console&&console.warn(`spotify-events/player: \`${t}\` is not implemented.`)}}exports.getUriFromButton=getUriFromButton,exports.getAttributeValueFromNode=getAttributeValueFromNode,exports.isFormOrLinkElement=isFormOrLinkElement,exports.isInteractiveElement=isInteractiveElement,exports.getContextSelector=getContextSelector,exports.getContextSelectorsWithVariants=getContextSelectorsWithVariants,exports.compareContexts=compareContexts,exports.normalizeUri=normalizeUri,exports.createEmptyMethod=createEmptyMethod;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../live-wrapped-uri":191,"spotify-liburi":475}],298:[function(require,module,exports){
"use strict";const live=require("../../live"),Range=require("../../range2"),$=require("../../spotify-elements"),playerActions=require("./actions"),playerUpdates=require("./updates"),utils=require("./utils");let isAttached=!1;function getPlayerTrackProvider(){const e=live("spotify:player").get("track");return e&&e.get("provider")||""}function getPlayerVariantUri(){const e=live("spotify:player").get("variant");return e?e.uri:""}function getPlayerIndex(){const e=live("spotify:player").get("index");return e?e.get("track"):-1}function getPlayerTrackUri(){const e=live("spotify:player").get("track");return e&&e.uri||""}function getPlayerUid(){return live("spotify:player").get("uid")}function getPlayerIsPlaying(){const e=live("spotify:player").get("isPlaying"),t=live("spotify:player").get("isPaused");return e&&!t}function subscribeToPlayerChange(e){live("spotify:player").on("update",e);let t=!0;return{cancel:function(){t&&(live("spotify:player").off("update",e),t=!1)}}}function handlePlayButton(e,t){const r=$(e),a=getPlayerIndex(),n=getPlayerTrackUri(),i=getPlayerUid();let o,s,l,c;const u=r.data("range");if(u){o=Range.fromString(u);const e=live(t.contextUri).get("rows");if(e){const t=o.toIndices();l=t.map(function(t){return e.keys[t]}),c=t.map(function(t){return e.get(t).get("track").uri})}s=null}else{let e=null;if(e=r.matches("[data-context-index]")?r:r.parent("[data-context-index]")){s=parseInt(e.data("context-index"),10);const r=live(t.contextUri).get("rows");r&&(l=[r.keys[s]],c=[r.get(s).get("track").uri])}else s=null}let y=!1;if(t.isPlayingContext)if(o)y=o.contains(new Range(a,a+1));else if(null!==s){const e=c&&c[0],t=l&&l[0];y=e===n&&(s===a||t===i)}else y=!0;if(y)getPlayerIsPlaying()?live("spotify:player").emit("pause"):live("spotify:player").emit("resume");else{const e={context:t.contextUri,index:s,source:t.source,reason:t.reason};o&&(e.range=[o.start,o.end]),l&&(e.uids=l),c&&(e.uris=c),live("spotify:player").emit("play",e)}}function handlePlayFromRow(e,t){let r=parseInt(e.getAttribute("data-context-index"),10);isNaN(r)&&(r=-1);const a=e.getAttribute("data-uid")||"",n=e.getAttribute("data-uri")||"",i={context:t.contextUri,index:r,source:t.source,reason:t.reason};a&&(i.uids=[a]),n&&(i.uris=[n]),live("spotify:player").emit("play",i)}function getPlayingNodes(e,t){const r=getPlayerIndex(),a=getPlayerTrackUri(),n=getPlayerVariantUri(),i=filterRanges(r,t),o=utils.getContextSelectorsWithVariants(n),s=getContextNodesForRows(e,o,r,a)||[],l=getContextNodesForRanges(e,o,r)||[];let c=[];if(t.length){const e=$(t).search("[data-button=play-context]");e&&(c=e.filter(e=>{const r=e.closest("[data-context]");return t.indexOf(r)>=0}))}const u=$([i,s,l,c]);return u?Array.prototype.slice.call(u):[]}function getContextNodesForRows(e,t,r,a){const n=`[data-uri="${a}"]`,i=`[data-context-index=${r}]${n}`,o=t.map(e=>`${e} ${i}`),s=$(e).find(o);if(s)return s;const l=t.map(e=>`${e} ${n}`);return $(e).find(l)}function getContextNodesForRanges(e,t,r){const a=t.map(function(e){return`${`${e} [data-range]`}, ${e+"[data-range]"}`});let n=$(e).search(a.join(", "));return filterRanges(r,n=n?Array.prototype.slice.call(n):[])}function filterRanges(e,t){const r=new Range(e,e+1);return t.filter(function(e){let t=$(e).data("range");return!t||!!r&&(t=Range.fromString(t)).contains(r)})}exports.attach=function(){isAttached||(isAttached=!0,playerActions.setMethods({getPlayerTrackProvider:getPlayerTrackProvider,getPlayerVariantUri:getPlayerVariantUri,handlePlayButton:handlePlayButton,handlePlayFromRow:handlePlayFromRow}),playerUpdates.setMethods({getPlayerTrackProvider:getPlayerTrackProvider,getPlayerVariantUri:getPlayerVariantUri,getPlayerIsPlaying:getPlayerIsPlaying,getPlayingNodes:getPlayingNodes,subscribeToPlayerChange:subscribeToPlayerChange}),playerActions.attach(),playerUpdates.attach())},exports.detach=function(){isAttached&&(isAttached=!1,playerActions.detach(),playerUpdates.detach())},exports.update=function(e){isAttached&&playerUpdates.update(e)};

},{"../../live":192,"../../range2":229,"../../spotify-elements":235,"./actions":294,"./updates":296,"./utils":297}],299:[function(require,module,exports){
"use strict";const live=require("../../live"),$=require("../../spotify-elements"),playerActions=require("./actions"),playerUpdates=require("./updates"),utils=require("./utils");let isAttached=!1;function getPlayerTrackProvider(){const e=live("spotify:player").get("track");return e&&e.get("provider")||""}function getPlayerVariantUri(){const e=live("spotify:player").get("variant");return e?e.uri:""}function getPlayerPageIndex(){const e=live("spotify:player").get("index"),t=e&&e.get("page");return"number"==typeof t?t:-1}function getPlayerTrackUid(){return live("spotify:player").get("uid")||""}function getPlayerTrackUri(){const e=live("spotify:player").get("track");return e&&e.uri||""}function getPlayerIsPlaying(){const e=live("spotify:player").get("isPlaying"),t=live("spotify:player").get("isPaused");return e&&!t}function getPlayerIsPlayingFromOpen(){const e=live("spotify:player").get("playOrigin"),t=e&&e.get("externalReferrer");return t&&0===t.indexOf("https://open.spotify.com/")}function subscribeToPlayerChange(e){live("spotify:player").on("update",e);let t=!0;return{cancel:function(){t&&(live("spotify:player").off("update",e),t=!1)}}}function handlePlayButton(e,t){let r=t.isPlayingContext;const a=utils.getAttributeValueFromNode(e,"data-uid"),i=utils.getAttributeValueFromNode(e,"data-track-uri"),n=parseInt(utils.getAttributeValueFromNode(e,"data-context-page"),10);if(r&&(r=verifyIsPlayingIndex(a,i,n)),r)getPlayerIsPlaying()?live("spotify:player").emit("pause"):live("spotify:player").emit("resume");else{const e={context:t.contextUri,source:t.source,reason:t.reason};a&&(e.uid=a),i&&(e.trackUri=i),isNaN(n)||(e.page=n),live("spotify:player").emit("play",e)}}function verifyIsPlayingIndex(e,t,r){if(e){return getPlayerTrackUid()===e}if(t){return getPlayerTrackUri()===t}if(!isNaN(r)){return getPlayerPageIndex()===r}return!0}function handlePlayFromRow(e,t){const r={context:t.contextUri,source:t.source,reason:t.reason},a=e.getAttribute("data-uid");a&&(r.uid=a);const i=parseInt(utils.getAttributeValueFromNode(e,"data-context-page"),10);isNaN(i)||(r.page=i),live("spotify:player").emit("play",r)}function getPlayingNodes(e,t){const r=getPlayerPageIndex(),a=getPlayerTrackUid(),i=getPlayerTrackUri(),n=getPlayerVariantUri(),o=filterPages(r,t),l=getContextNodesForRows(e,utils.getContextSelectorsWithVariants(n),a,i)||[],s=getContextNodesForPages(e,utils.getContextSelectorsWithVariants(n),r)||[];let c=[];if(t.length){const e=$(t).search("[data-button=play-context]");e&&(c=e.filter(e=>{const r=e.closest("[data-context]");return t.indexOf(r)>=0}))}const u=$([o,l,s,c]);return u?Array.prototype.slice.call(u):[]}function getContextNodesForRows(e,t,r,a){const i=getPlayerIsPlayingFromOpen(),n=t.map(function(e){let t=`${e} `;return i&&(t+=`[data-uri=${a}]`),i||(t+=`[data-uid=${r}]`),t}).join(", ");let o=$(e).search(n);if(o){if(o=Array.prototype.slice.call(o),i){const e=$(o[0]).data("uid");o=o.filter(function(t){return e===$(t).data("uid")})}}else o=[];return o}function getContextNodesForPages(e,t,r){const a=t.map(function(e){return`${`${e} [data-context-page]`}, ${e+"[data-context-page]"}`});let i=$(e).search(a.join(", "));return filterPages(r,i=i?Array.prototype.slice.call(i):[])}function filterPages(e,t){return t.filter(function(t){const r=parseInt(t.getAttribute("data-context-page"),10);return!!isNaN(r)||!isNaN(e)&&e===r})}exports.attach=function(){isAttached||(isAttached=!0,playerActions.setMethods({getPlayerTrackProvider:getPlayerTrackProvider,getPlayerVariantUri:getPlayerVariantUri,handlePlayButton:handlePlayButton,handlePlayFromRow:handlePlayFromRow}),playerUpdates.setMethods({getPlayerTrackProvider:getPlayerTrackProvider,getPlayerVariantUri:getPlayerVariantUri,getPlayerIsPlaying:getPlayerIsPlaying,getPlayingNodes:getPlayingNodes,subscribeToPlayerChange:subscribeToPlayerChange}),playerActions.attach(),playerUpdates.attach())},exports.detach=function(){isAttached&&(isAttached=!1,playerActions.detach(),playerUpdates.detach())},exports.update=function(e){isAttached&&playerUpdates.update(e)};

},{"../../live":192,"../../spotify-elements":235,"./actions":294,"./updates":296,"./utils":297}],300:[function(require,module,exports){
"use strict";function updateInput(t){t.hasAttribute("data-rtl-dir-flip")&&(""===t.value?t.removeAttribute("dir"):t.setAttribute("dir","auto"))}function handleGlobalChangeEvent(t){updateInput(t.target)}let isAttached=!1;exports.update=(t=>{(t||document).querySelectorAll("input, textarea").forEach(updateInput)}),exports.attach=(()=>{isAttached||(isAttached=!0,document.addEventListener("input",handleGlobalChangeEvent))}),exports.detach=(()=>{isAttached&&(isAttached=!1,document.removeEventListener("input",handleGlobalChangeEvent))});

},{}],301:[function(require,module,exports){
"use strict";const Range=require("../range2"),contains=require("mout/array/contains"),$=require("../spotify-elements"),SYNC=require("../../libs/prime/emitter").EMIT_SYNC,attentionHighlight=require("../../libs/glue").attentionHighlight,throttle=require("./util/throttle"),ListManager=require("./util/ListManager.js"),center=require("./center"),doc=$(document),win=$(window);let scrollContainers=[],listManagers=[],scrollHandlers=[];const pendingScrollContainers=[],pendingHiddenIndices=[];let cleanupHandlers=[];const getBounds=function(e,t){let n=e;n!==window&&n!==document.body||(n=document.body);const o=n===document.body?0:n.getBoundingClientRect().top,i=n===document.body?document.documentElement.clientHeight:n.clientHeight,r=t.getBoundingClientRect().top,c=t.offsetHeight;return{view:{top:o,height:i,bottom:o+i},container:{top:r,height:c,bottom:r+c}}},getRange=function(e,t,n,o=0){const i=getBounds(e,t),r=-(i.container.top-i.view.top);let c=Math.floor((r-o)/n);const s=Math.ceil((r+i.view.height+o)/n);return c<0&&(c=0),!(s<=c)&&new Range(c,s)},init=function(e,t,n,o,i){const r=e[0],c=t[0];let s=-1;t.addClass("scroll-container-enabled");const l=(e,n)=>{if($(e)===t){const e=c.querySelector(`[data-index='${n}']`);if(!e)return void(s=n);s=-1;let t=document.querySelector("[data-table-row-attention-highlight]");t||((t=document.createElement("div")).className="tl-attention-highlight",t.setAttribute("data-table-row-attention-highlight",""),document.body.appendChild(t));const o=window.pageYOffset,i=e.getBoundingClientRect(),r=document.body.offsetWidth;t.classList.add("visible"),t.style.top=`${i.top+o}px`,t.style.left=`${i.left}px`,t.style.right=`${r-i.right}px`,setTimeout(()=>{t.classList.remove("visible")},attentionHighlight.HIDE_DELAY)}},a=new ListManager(c,{height:o,length:n,tag:i,debug:!1,request:function(e,t){center.emit("scroll-request",c,e,t,SYNC)}});listManagers.push(a);const d=pendingScrollContainers.indexOf(t);d>-1&&(a.reset(n,pendingHiddenIndices[d]),pendingScrollContainers.splice(d,1),pendingHiddenIndices.splice(d,1)),a.on("before-show",function(e,n){center.emit("scroll-show-before",{pageNode:t,container:t,range:e,nodes:n},SYNC)}),a.on("after-show",function(e,n){center.emit("scroll-show-after",{pageNode:t,container:t,range:e,nodes:n},SYNC)}),a.on("index-change",function(e){center.emit("scroll-index-change",{pageNode:t,container:t,ranges:e},SYNC)});let h=!1;const u=function(e,n,o,i){if($(e)===t){"number"==typeof i&&i>0?a.resetFrom(i,n,o):a.reset(n,o),t._scrollEvent()}},g=function(){const e=getBounds(r,c);let n=getRange(r,c,o);if(n){a.on("after-show",function e(){a.off("after-show",e),s>-1&&s>=n.start&&s<n.end&&l(t,s)});const e=2;n=new Range(n.start-e,n.end+e),a.show(new Range(n.start,n.end))}h||e.container.bottom<2e3&&(h=!0,center.emit("scroll-request-more",c,function(e,t){if(e)throw e;h=!1,u(c,t)}))};scrollHandlers.push(g),t._scrollEvent=throttle(g),center.on("scroll-reset",u),t._scrollResetEvent=u;const f=function(e,n,o={}){if(r!==window)throw new Error("Can't scroll to index if view is not `window`");if($(e)===t){const e=getBounds(r,c),t=o.centerRowIfScrollIsNeeded?(e.view.height-a.height)/2:0,i=a.height*n,s=e.container.top+i;let l=s+window.pageYOffset,d=(doc.search("[data-sticky-active]")||[]).map(function(e){return e.offsetHeight}).reduce(function(e,t){return e+t},0);if(document.querySelector("[data-top-bar-height]")&&(d+=parseInt(document.querySelector("[data-top-bar-height]").getAttribute("data-top-bar-height"),10)),s<=d)l-=t+d;else{if(!(s+a.height>e.view.height))return;l+=t+a.height-e.view.height}r.scrollTo(0,l)}},p=()=>{const e=document.querySelector("[data-table-row-attention-highlight]");e&&e.parentNode.removeChild(e)};center.on("scroll-to-index",f),center.on("attention-highlight-index",l),center.on("hide-attention-highlight",p),e.on("scroll",g),win.on("resize",g),g(),cleanupHandlers.push({container:t,clean:function(){center.off("scroll-reset",u),center.off("scroll-to-index",f),center.off("attention-highlight-index",l),center.off("hide-attention-highlight",p),e.off("scroll",g),win.off("resize",g),delete t._scrollEvent,delete t._scrollResetEvent,s=-1,t.removeClass("scroll-container-enabled")}})};function onScrollSetHidden(e){const t=e.indices,n=$(e.itemContainer),o=scrollContainers.indexOf(n);if(o>-1){const e=listManagers[o];e&&e.reset(e.length,t);const n=scrollHandlers[o];n&&n()}else pendingScrollContainers.push(n),pendingHiddenIndices.push(t)}let isAttached=!1;exports.update=function(e){if(!isAttached)return;const t=$(e)||doc;let n=doc.search("[data-scroll-container]");const o=[],i=[];scrollContainers=scrollContainers.filter(function(e,t){if(!contains(n,e[0])){for(let t=0;t<cleanupHandlers.length;t++)if(cleanupHandlers[t].container===e){cleanupHandlers[t].clean(),cleanupHandlers.splice(t,1);break}return!1}return i.push(listManagers[t]),o.push(scrollHandlers[t]),!0}),listManagers=i,scrollHandlers=o,t!==doc&&(n=t.search("[data-scroll-container]")),n&&n.forEach(function(e){const t=$(e);if(t._scrollEvent||e.children.length)return;scrollContainers.push(t);const n=t.parent("[data-scroll-view]")||win;center.emit("scroll-request",t[0],new Range(0,3),function(e,o,i){if(e)throw e;let r=o;if(contains(doc.search("[data-scroll-container]"),t[0])){(r=$(r)).insert(t);const e=r[1],o=e.offsetHeight,c=$(e).tag();r.remove(),init(n,t,i,o,c)}},SYNC)})},exports.attach=function(){isAttached||(isAttached=!0,center.on("scroll-set-hidden",onScrollSetHidden))},exports.detach=function(){isAttached&&(isAttached=!1,center.off("scroll-set-hidden",onScrollSetHidden),scrollContainers=[],cleanupHandlers.forEach(function({clean:e}){e()}),cleanupHandlers=[])};

},{"../../libs/glue":83,"../../libs/prime/emitter":226,"../range2":229,"../spotify-elements":235,"./center":246,"./util/ListManager.js":315,"./util/throttle":321,"mout/array/contains":410}],302:[function(require,module,exports){
"use strict";var _cosmosApi=require("../cosmos-api"),_cosmosApi2=_interopRequireDefault(_cosmosApi),_os=require("../os");function _interopRequireDefault(e){return e&&e.__esModule?e:{default:e}}let controlMessageSubscription,isAttached=!1,currentStyle="always-visible",fixAttemptCounter=0;const platformToClassNamePlatform={[_os.PLATFORM_UNKNOWN]:"linux",[_os.PLATFORM_MAC]:"mac",[_os.PLATFORM_WINDOWS]:"windows"};let previousPlatformId=platformToClassNamePlatform[_os.PLATFORM_UNKNOWN],currentPlatformId=platformToClassNamePlatform[_os.PLATFORM_UNKNOWN];function refreshStyle(){"always-visible"===currentStyle||"mac"!==currentPlatformId?(document.body.classList.remove(`scrollbar-style-visible-${previousPlatformId}`),document.body.classList.remove("scrollbar-style-when-scrolling-mac"),document.body.classList.add(`scrollbar-style-visible-${currentPlatformId}`)):(document.body.classList.remove(`scrollbar-style-visible-${currentPlatformId}`),document.body.classList.remove(`scrollbar-style-visible-${previousPlatformId}`),document.body.classList.add("scrollbar-style-when-scrolling-mac"))}function performScrollBarFix(){const e=[],o=["scroll","auto","overlay"];[...document.querySelectorAll("*")].forEach(t=>{const r=window.getComputedStyle(t),s=r.overflowX,l=r.overflowY;o.includes(s)&&e.push({node:t,property:"overflow-x"}),o.includes(l)&&e.push({node:t,property:"overflow-y"})});const t=document.createElement("style");t.innerHTML="\n    html::-webkit-scrollbar,\n    body::-webkit-scrollbar {\n      background-color: rgba(1, 2, 3, 0) !important;\n    }\n  ".trimRight();const r=`data-scrollbar-fix-${++fixAttemptCounter}-id`;let s=0;e.forEach(({node:e,property:o})=>{if(e!==document.body){const l=++s;e.setAttribute(r,l),t.innerHTML+=`\n    [${r}="${l}"] { ${o}: hidden !important; }`}}),document.head.appendChild(t),setTimeout(()=>{document.head.removeChild(t),e.forEach(({node:e})=>{e.removeAttribute(r)})},0)}exports.performScrollBarFix=performScrollBarFix,exports.update=function(){},exports.attach=function(){if(isAttached)return;isAttached=!0;const e=window.__spotify&&window.__spotify.scroller_style;currentStyle="overlay"===e?"overlay":"always-visible",(0,_os.subscribeToPlatform)((e,o)=>{currentPlatformId=platformToClassNamePlatform[e],previousPlatformId=platformToClassNamePlatform[o],refreshStyle()}),window.addEventListener("message",e=>{"set_active"===e.data.name&&e.data.active&&performScrollBarFix()}),controlMessageSubscription=_cosmosApi2.default.resolver.subscribe({url:"sp://messages/v1/container/control"},(e,o)=>{if(e)controlMessageSubscription.cancel();else{const e=o.getJSONBody();if(e){let o=!1;switch(e.type){case"set_scroller_style_always_visible":currentStyle="always-visible",o=!0;break;case"set_scroller_style_overlay":currentStyle="overlay",o=!0}o&&refreshStyle(),o&&(performScrollBarFix(),setTimeout(performScrollBarFix,1e3))}}})},exports.detach=function(){isAttached&&(isAttached=!1,fixAttemptCounter=0,controlMessageSubscription&&(controlMessageSubscription.cancel(),controlMessageSubscription=null))};

},{"../cosmos-api":45,"../os":215}],303:[function(require,module,exports){
"use strict";const $=require("../spotify-elements"),center=require("./center"),live=require("../live"),ATTR_SELECT="select",ATTR_PROPERTY="select-property",SELECTOR_SELECT=`[data-${ATTR_SELECT}]`,storedNodes=[];function handleChange(e,t){const n=t.data(ATTR_PROPERTY),c=t[0];n?publish(c,n):emitUpdate(c,selectedValue(c))}function selectedValue(e){return e.options[e.selectedIndex].value}function onSelectSet(e){if(!e.id)return;const t=$(`[data-${ATTR_SELECT}=${e.id}]`);if(!t)return;const n=t[0],c=e.selected,i=t.data(ATTR_PROPERTY);i?publish(n,i,c):setState(n,c)}function publish(e,t,n){const c=getUriFromNode(e);if(!c)return;const i=live(c);if(void 0===i.get(t))return;const o=void 0===n?selectedValue(e):n,s={};s[t]=o,i.publish(s)}function updateNode(e){if(storedNodes.indexOf(e)>-1)return;storedNodes.push(e);const t=$(e).data(ATTR_PROPERTY);if(!t)return;const n=getUriFromNode(e);if(!n)return;const c=live(n);c.get(t,function(n,i){if(n)throw n;setState(e,i),c.on("update",function(n){t in n&&setState(e,n[t])})})}function setState(e,t){updateNodeWithValue(e,t),emitUpdate(e,t)}function updateNodeWithValue(e,t){const n=$(e).find(`option[value="${t}"]`);n&&!n.attribute("selected")&&n.select()}function emitUpdate(e,t){const n=$(e).data(ATTR_SELECT)||null;center.emit("select-change",{element:e,id:n,selected:t})}function getUriFromNode(e){const t=e.closest("[data-uri]");return t?t.getAttribute("data-uri"):null}let isAttached=!1;exports.update=function(e){if(!isAttached)return;const t=$(e||document).search(SELECTOR_SELECT);t&&t.forEach(updateNode)},exports.attach=function(){if(isAttached)return;isAttached=!0,$(document).delegate("change",SELECTOR_SELECT,handleChange),center.on("select-set",onSelectSet)},exports.detach=function(){if(!isAttached)return;isAttached=!1,$(document).undelegate("change",SELECTOR_SELECT,handleChange),center.off("select-set",onSelectSet)};

},{"../live":192,"../spotify-elements":235,"./center":246}],304:[function(require,module,exports){
"use strict";const $=require("../../spotify-elements"),live=require("../../live"),containers=[];function reset(){containers.length=0}function update(){const t=$(document).search(":not(.sticky-clone) > [data-list]");t&&t.forEach(function(t){containers.includes(t)||(containers.push(t),containers.sort((t,e)=>{let n;return n=t===e?0:t.compareDocumentPosition(e)&Node.DOCUMENT_POSITION_PRECEDING?1:-1}))})}function getContainerLength(t){const e=$(containers[t]);if(!e)return 0;const n=e.data("uri");if(!n)return 0;const r=live(n).get("rows");return r?r.length:0}function getContainerIndex(t){for(let e=0,n=containers.length;e<n;e++){if(getUri(e)===t)return e}return-1}function getUri(t){const e=containers[t];return e&&e.getAttribute("data-uri")||null}function getUris(){const t=[];for(let e=0,n=containers.length;e<n;e++)t.push(getUri(e));return t}function getLiveList(t){const e=getUri(t);return live(e).get("rows")||null}exports.elements=containers,exports.reset=reset,exports.update=update,exports.getContainerLength=getContainerLength,exports.getContainerIndex=getContainerIndex,exports.getUri=getUri,exports.getUris=getUris,exports.getLiveList=getLiveList;

},{"../../live":192,"../../spotify-elements":235}],305:[function(require,module,exports){
(function (global){
"use strict";const $=require("../../spotify-elements"),intersection=require("mout/array/intersection"),live=require("../../live"),liburi=require("spotify-liburi"),center=require("../center"),selection=require("./index"),model=require("./model"),rows=require("./rows"),containers=require("./containers"),positions=require("./positions"),Position=require("../util/Position"),cosmos=require("../util/cosmos");let focusEventValid=!1,mouseDownTarget=null;const listListeners={},listListenerUris=[],SELECTABLE="[data-list-item]",CLIPBOARD_ENDPOINT="sp://desktop/v1/clipboard";function isOnDocument(e){return e.target===document.documentElement}function getNodeFromEvent(e){return e.target!==document&&e.target.closest(SELECTABLE)}function isFilterTarget(e){return e!==document&&!!e.closest("[data-filter]")}function handleMouseDown(e,t){if(isOnDocument(e))return;focusEventValid=!1;const n=getNodeFromEvent(e);if(t){if(e.target!==mouseDownTarget)return void(mouseDownTarget=null);mouseDownTarget=null}else mouseDownTarget=e.target;n?handleRowMouseDown(e,n,t):handleOutsideMouseDown(e)}function handleRowMouseDown(e,t,n){const o=1===getButtonFromEvent(e),i=positions.getFromNode(t);if(!i)return;const s=model.isSelected(i);let l=isMac()?e.metaKey:e.ctrlKey,r=e.shiftKey||l,d=!e.shiftKey;if(isMultiSelectEnabled()||(l=r=!1,d=!0),r&&d&&s&&o){if(!n)return;handleDeselectOnSingleMultiSelect(i)}else if(d){if(o&&s&&!n)return;if(r&&!n)return;handleSingleSelect(i,e,n)}else{if(n)return;handleShiftMultiSelect(i)}rows.update()}function handleOutsideMouseDown(e){const t=e.target!==document&&!!e.target.closest("[data-sort]"),n=isFilterTarget(e.target),o=model.hasSelection();t||n||!o||(model.clear(),rows.update())}function handleFocus(e){if(!focusEventValid)return;const t=getNodeFromEvent(e);t?handleRowFocus(e,t):handleOutsideFocus(e),focusEventValid=!1}function handleRowFocus(e,t){const n=positions.getFromNode(t);n&&!model.isSelected(n)&&(model.clear(),model.add(n),model.setFocus(n),model.setOrigin(n),rows.update())}function handleOutsideFocus(e){isFilterTarget(e.target)||(model.clear(),rows.update())}function handleMouseUp(e){isOnDocument(e)||handleMouseDown(e,!0)}function handleDeselectOnSingleMultiSelect(e){const t=model.getOrigin(),n=model.getFocus();let o=positions.getDirection(t,n);o||(o=1);const i=e.isSame(t),s=e.isSame(n);let l,r;(i||s)&&(l=getClosestSelected(e,"up"),r=getClosestSelected(e,"down")),i&&model.setOrigin(1===o?r||l:l||r),e.isSame(n)&&model.setFocus(1===o?l||r:r||l),model.remove(e)}function handleShiftMultiSelect(e){let t=model.getOrigin();const n=model.getFocus();t&&n&&!t.isSame(n)&&model.remove(t,n),t||(t=new Position(0,0),model.setOrigin(t)),model.add(t,e),model.setFocus(e)}function handleSingleSelect(e,t){const n=model.getOrigin(),o=getButtonFromEvent(t),i=1===o,s=2===o,l=model.isSelected(e);let r=isMac()?t.metaKey:t.ctrlKey,d=t.shiftKey||r;let c;if(isMultiSelectEnabled()||(r=d=!1),(!d&&i||!l&&s)&&model.clear(),model.add(e),model.setFocus(e,{isTouch:isTouchEvent(t)}),n&&!n.isSame(e)){const t=positions.getClosest(e,"down");if(!(c=t&&model.isSelected(t))){const t=positions.getClosest(e,"up");c=t&&model.isSelected(t)}}c||model.setOrigin(e)}function handleKeyDown(e){if(isFilterTarget(e.target))return;focusEventValid=!0;const t=38===e.keyCode,n=40===e.keyCode;if(!isKeyboardNavEnabled())return;if(!t&&!n)return;const o=model.getOrigin(),i=model.getFocus();let s=i;do{s=s&&positions.getClosest(s,n?"down":"up")}while(s&&model.isPositionHidden(s));if((t||n)&&!e.metaKey&&!e.ctrlKey&&s){if(e.shiftKey&&isMultiSelectEnabled()&&o&&i){const e=n?1:-1,t=positions.getDirection(o,i);0===t||e===t?(model.add(s),scrollIntoView(s)):model.remove(i)}else model.clear(),model.add(s),model.setOrigin(s),scrollIntoView(s),e.preventDefault();model.setFocus(s)}rows.update()}function handleScrollShowAfter(e){const t=e.pageNode&&e.pageNode[0];rows.update(t)}function handleSetHidden(e){model.setHiddenIndices(e.indices,e.uri)}function handleAddByUri(e,t,n){const o=$(`[data-uri=${e}]`),i=intersection(containers.elements,o);let s=t;if(!i||i.length<1)return;const l=$(i[0]);let r=l&&containers.elements.indexOf(l[0]);if(l&&l.matches("[data-context]")){const e=positions.getPositionFromGlobalIndex(s);r=e.containerIndex,s=e.index}else if(-1===r)return void console.warn("No container matching this uri was found or selection doesn't know about the container. Possibly you need to run events.update.");isMultiSelectEnabled()||model.clear();const d=new Position(r,s);model.getOrigin()||model.setOrigin(d),model.setFocus(d),model.add(d),rows.update(),!0!==n&&scrollIntoView(d)}function handleSelectAll(){if(!isMultiSelectEnabled())return;model.clear();const e=new Position(0,0);model.setOrigin(e);const t=positions.getLastPositionForSelectAll();model.setFocus(t),model.add(e,t),rows.update()}function handleCopy(){cosmos.put({url:CLIPBOARD_ENDPOINT,body:handleGetUris().map(e=>{const t=liburi.from(e);return t&&t.toOpenURL()}).filter(Boolean).join("\n")})}function handleCopyAdvanced(){cosmos.put({url:CLIPBOARD_ENDPOINT,body:handleGetUris().filter(Boolean).join("\n")})}function handleCut(){handleCopy(),cosmos.post({url:"sp://messages/v1/container/control",body:{type:"delete"}})}function handleGetUris(){const e=model.selections,t=[];let n;const o=e=>!!n[e];for(let i=0;i<e.length;i++){if(!(n=e[i]))continue;let s;const l=containers.getLiveList(i);if(!l)continue;const r=l.keys.filter(o);for(let e=0,n=r.length;e<n;e++){const n=l.valueOf(r[e]);n&&((s=n.get("track"))||(s=n.get("playlist")),s||(s=n.get("album")),s||(s=n.get("artist")),s||(s=n.get("user")),s||(s=n),t.push(s.get("uri")))}}return t}function getButtonFromEvent(e){if(isTouchEvent(e))return 1;switch(e.button){case 0:return 1;case 2:return 2;case 1:return 3;default:return 0}}function isMac(){if(!global.window)return!1;if(!global.window.navigator)return!1;return(global.window.navigator.userAgent||"").indexOf("Mac")>-1}function isMultiSelectEnabled(){return null===$("body").data("multi-select-disabled")&&(!!global.window&&!!global.window._getSpotifyModule)}function isKeyboardNavEnabled(){return null===$("body").data("keyboard-select-disabled")}function isTouchEvent(e){return!!e.changedTouches}function getClosestSelected(e,t){let n=e;for(;n;)if((n=positions.getClosest(n,t))&&model.isSelected(n))return n;return null}function scrollIntoView(e){const t=containers.elements[e.containerIndex],n=t&&t.querySelector("[data-scroll-container]");if(n)center.emit("scroll-to-index",n,e.index);else{const t=positions.getNodeFromPosition(e);if(!t)return;const n=t.getBoundingClientRect().top;(n<0||n>=window.innerHeight)&&t.scrollIntoView(n<0)}}function updateListListeners(){const e=containers.getUris();for(let t=0,n=e.length;t<n;t++){const n=e[t];if(n&&-1===listListenerUris.indexOf(n)){const e=live(n).get("rows");if(e){const t=createListListener(n);e.on("update",t),listListeners[n]=t,listListenerUris.push(n)}}}}function createListListener(e){return function(t){const n=containers.getUris().indexOf(e);if(n>-1){for(let e=0,o=t.length;e<o;e++){if("remove"===t[e].type){model.updateContainer(n);break}}rows.update()}}}function resetListListeners(){for(let e=0,t=listListenerUris.length;e<t;e++){const n=listListenerUris[e],o=listListeners[n],i=live(n).get("rows");i&&o&&(i.off("update",o),delete listListeners[n],listListenerUris.splice(e,1),e--,t--)}}function handleListSwap(e){const t=live(e.before).get("rows");if(!t)return;const n=selection.getIndicesPerList().filter(function(t){return t.uri===e.before})[0];let o=[];n&&(o=n.indices.map(function(e){return t.keys[e]})),center.on("scroll-reset",function t(){center.off("scroll-reset",t),live(e.after).get("rows",function(t,n){o.forEach(function(t){const o=n.keys.indexOf(t);-1!==o&&handleAddByUri(e.after,o,!0)})},live.ASAP)})}exports.handleMouseDown=handleMouseDown,exports.handleMouseUp=handleMouseUp,exports.handleKeyDown=handleKeyDown,exports.handleFocus=handleFocus,exports.handleScrollShowAfter=handleScrollShowAfter,exports.handleSetHidden=handleSetHidden,exports.handleAddByUri=handleAddByUri,exports.handleSelectAll=handleSelectAll,exports.handleCopy=handleCopy,exports.handleCopyAdvanced=handleCopyAdvanced,exports.handleCut=handleCut,exports.handleGetUris=handleGetUris,exports.updateListListeners=updateListListeners,exports.resetListListeners=resetListListeners,exports.handleListSwap=handleListSwap;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../live":192,"../../spotify-elements":235,"../center":246,"../util/Position":316,"../util/cosmos":318,"./containers":304,"./index":306,"./model":307,"./positions":308,"./rows":309,"mout/array/intersection":417,"spotify-liburi":475}],306:[function(require,module,exports){
"use strict";const $=require("../../spotify-elements"),live=require("../../live"),getOriginUri=require("../../live-wrapped-uri").getOriginUri,center=require("../center"),controller=require("./controller"),containers=require("./containers"),model=require("./model"),rows=require("./rows"),positions=require("./positions"),Position=require("../util/Position"),appUtil=require("../util/app"),cosmos=require("../util/cosmos");let controlMessageSubscription;exports.attach=function(){const e=$(document);e.on("mousedown",controller.handleMouseDown),e.on("touchstart",controller.handleMouseDown),e.on("mouseup",controller.handleMouseUp),e.on("touchend",controller.handleMouseUp),e.on("keydown",controller.handleKeyDown),e.on("focus",controller.handleFocus,!0),center.on("scroll-show-after",controller.handleScrollShowAfter),center.on("selection-set-hidden",controller.handleSetHidden),center.on("list-swap",controller.handleListSwap),controlMessageSubscription=cosmos.subscribe({url:"sp://messages/v1/container/control"},function(e,o){if(e)throw e;const n=o.body;n&&appUtil.isActiveAndFocused()&&("select_all"===n.type?controller.handleSelectAll():"copy"===n.type?controller.handleCopy():"copy_advanced"===n.type?controller.handleCopyAdvanced():"cut"===n.type&&controller.handleCut())})},exports.detach=function(){const e=$(document);e.off("mousedown",controller.handleMouseDown),e.off("touchstart",controller.handleMouseDown),e.off("mouseup",controller.handleMouseUp),e.off("touchend",controller.handleMouseUp),e.off("keydown",controller.handleKeyDown),e.off("focus",controller.handleFocus,!0),center.off("scroll-show-after",controller.handleScrollShowAfter),center.off("selection-set-hidden",controller.handleSetHidden),center.off("list-swap",controller.handleListSwap),controlMessageSubscription&&(controlMessageSubscription.cancel(),controlMessageSubscription=null)},exports.update=function(){containers.update(),controller.updateListListeners()},exports.add=function(e,o){controller.handleAddByUri(e,o)},exports.hasHoles=function(){return model.hasHoles()},exports.isNodeSelected=function(e){const o="innerHTML"in e?e:e[0];if(!o)return!1;const n=positions.getFromNode(o);return!!n&&model.isSelected(n)},exports.reset=function(){controller.resetListListeners(),model.reset(),rows.update(),containers.reset()},exports.clear=function(){model.clear(),rows.update()},exports.setOrigin=function(e,o){model.setOrigin(new Position(e,o))},exports.setFocus=function(e,o){model.setFocus(new Position(e,o))},exports.getOrigin=function(){const e=model.getOrigin();return e?{containerIndex:e.containerIndex,index:e.index}:null},exports.getFocus=function(){const e=model.getFocus();return e?{containerIndex:e.containerIndex,index:e.index}:null},exports.getIndicesPerList=function(){const e=model.selections,o=[];let n;const t=e=>n.keys[e];for(let r=0;r<e.length;r++){const s=e[r];if(s&&Object.keys(s).length){const e=containers.getUri(r);if(!e)continue;if(!(n=containers.getLiveList(r)))continue;const s=model.getIndicesForContainer(r);if(!s)continue;const i=s.map(t),l=model.getIndicesWithHiddenForContainer(r),c={containerIndex:r,uri:e,indices:s,keys:i,indicesWithHidden:l,keysWithHidden:l.map(t)},d=getOriginUri(e);if(d){const o=live(e).get("rows"),n=live(d).get("rows");let t,r;if(o&&n){let e;const i={};t=new Array(s.length),r=new Array(s.length);const l=n.keys;for(let e=0;e<l.length;e++)i[l[e]]=e;for(let l=0;l<s.length;l++)e=o.keys[s[l]],t[l]=i[e],r[l]=n.keys[t[l]]}c.origin={uri:d,indices:t||[],keys:r||[]}}o.push(c)}}return o},exports.getIndicesGlobal=function(){const e=model.selections,o=containers.elements,n=[],t=[];if(0===o.length)return null;const r=o[0].closest("[data-context]"),s=r&&r.getAttribute("data-uri");if(!s)return null;let i;const l=e=>!!i[e];for(let r=0;r<e.length;r++){i=e[r];const s=containers.getLiveList(r);if(s&&i){const e=s.keys.filter(l);for(let i=0,l=e.length;i<l;i++){const l=s.keys.indexOf(e[i]);n.push(positions.getGlobalIndexFromPosition(new Position(r,l))),t.push($(o[r]))}}}return{uri:s,indices:n,containers:t}},exports.getUris=function(){return controller.handleGetUris()},exports.getNodes=function(){return rows.getSelectedRows()};

},{"../../live":192,"../../live-wrapped-uri":191,"../../spotify-elements":235,"../center":246,"../util/Position":316,"../util/app":317,"../util/cosmos":318,"./containers":304,"./controller":305,"./model":307,"./positions":308,"./rows":309}],307:[function(require,module,exports){
"use strict";const live=require("../../live"),Range=require("../../range2"),containers=require("./containers"),positions=require("./positions"),Position=require("../util/Position"),selections=[];let hiddenKeysPerContainer={},originContainerIndex=null,originKey=null,focusContainerIndex=null,focusKey=null,focusIsTouch=!1;function getOrigin(){if(null===originContainerIndex)return null;if(null===originKey)return null;const e=containers.getLiveList(originContainerIndex);if(e){const n=e.keys.indexOf(originKey);return-1===n?null:new Position(originContainerIndex,n)}return null}function getFocus(){if(null===focusContainerIndex)return null;if(null===focusKey)return null;const e=containers.getLiveList(focusContainerIndex);if(e){const n=e.keys.indexOf(focusKey);return new Position(focusContainerIndex,n)}return null}function setOrigin(e){if(e){const n=containers.getLiveList(e.containerIndex);if(n)return originContainerIndex=e.containerIndex,void(originKey=n.keys[e.index]||null)}originContainerIndex=null,originKey=null}function setFocus(e,n){if(focusIsTouch=!(!n||!n.isTouch),e){const n=containers.getLiveList(e.containerIndex);if(n)return focusContainerIndex=e.containerIndex,void(focusKey=n.keys[e.index])}focusContainerIndex=null,focusKey=null}function wasFocusTriggeredByTouch(){return focusIsTouch}function setHiddenIndices(e,n){const t=live(n).get("rows");if(t){const i=t.keys,o={};for(let n=0,t=e.length;n<t;n++){const t=i[e[n]];t&&(o[t]=!0)}const s=containers.getContainerIndex(n);hiddenKeysPerContainer[s]=o,updateContainer(s)}}function isPositionHidden(e){const n=getIds(e,e)[0][0],t=hiddenKeysPerContainer[e.containerIndex];return t&&t[n]}function add(e,n){let t=n||e,i=e;if(-1===positions.getDirection(i,t)){const e=i;i=t,t=e}const o=getIds(i,t);for(let e=0,n=o.length;e<n;e++){const n=i.containerIndex+e,t=selections[n]||(selections[n]=Object.create(null)),s=o[e],r=hiddenKeysPerContainer[n];for(let e=0;e<s.length;e++){const n=s[e];r&&r[n]||(t[n]=!0)}}}function remove(e,n){let t=n||e,i=e;if(-1===positions.getDirection(i,t)){const e=i;i=t,t=e}const o=getIds(i,t);for(let e=0,n=o.length;e<n;e++){const n=i.containerIndex+e,t=selections[n]||(selections[n]=Object.create(null)),s=o[e];for(let e=0;e<s.length;e++){delete t[s[e]]}}}function clear(){selections.length=0,setOrigin(null),setFocus(null)}function reset(){clear(),hiddenKeysPerContainer={}}function updateContainer(e){const n=selections[e];if(!n)return;const t=containers.getLiveList(e);if(t)for(const i in n){let o=!t.hasKey(i);if(!o){const n=hiddenKeysPerContainer[e];o=!!n&&n[i]}o&&delete n[i]}}function getIds(e,n){const t=[],i=e.containerIndex,o=n.containerIndex;for(let s=i;s<=o;s++){const r=s===i?e.index:0;let c;if(s===o)c=n.index;else{const e=containers.getContainerLength(s);e>0&&(c=e-1)}if(void 0===c)t.push([]);else{const e=[];t.push(e);const n=containers.getUri(s),i=live(n).get("rows");if(i){const n=i.keys;for(let t=r;t<c+1;t++)e.push(n[t])}}}return t}function isSelected(e){const n=selections[e.containerIndex];if(!n)return!1;const t=containers.getLiveList(e.containerIndex);if(t){return!!n[t.keys[e.index]]}return!1}function hasHoles(){let e=0;for(let n=0;n<selections.length;n++){const t=selections[n],i=containers.getLiveList(n),o=Object.keys(t);if(o.length>0&&(e++,i)){const n=[];for(let e=0,t=o.length;e<t;e++)n.push(i.indexOf(o[e]));let t;n.sort(function(e,n){return e-n});for(let i=0,o=n.length;i<o;i++){const o=n[i];if(i>0&&o>t+1){e++;break}t=o}}if(e>1)return!0}return!1}function hasSelection(){for(let e=0,n=selections.length;e<n;e++)if(selections[e]&&Object.keys(selections[e]).length>0)return!0;return!1}function getIndicesForContainer(e){const n=selections[e];if(!n)return null;let t=[];const i=containers.getLiveList(e),o=i.keys.filter(function(e){return!!n[e]});return i&&o.length&&(t=o.length>1?i.indexOfMany(o):[i.indexOf(o[0])]),t.length?t:null}function getIndicesWithHiddenForContainer(e){let n=getIndicesForContainer(e);if(!n)return null;const t=hiddenKeysPerContainer[e];if(!t)return n;const i=Range.fromIndices(n);if(1===i.length)return n;const o=containers.getLiveList(e);if(!o)return n;const s=Object.keys(t);let r=[];s.length&&(r=s.length>1?o.indexOfMany(s):[o.indexOf(s[0])]),r=r.filter(function(e){return e>-1});const c=Range.fromIndices(r),l=c.map(function(e){return e.start}),u=c.map(function(e){return e.end});for(let e=0,t=i.length;e<t;e++){const t=i[e],o=i[e+1],s=l.indexOf(t.end);if(s>-1){const e=u[s];if(!o||e===o.start){const e=c[s].toIndices();e.length>0&&(n=n.concat(e))}}}return n.sort(function(e,n){return e-n}),n.length?n:null}exports.selections=selections,exports.getOrigin=getOrigin,exports.getFocus=getFocus,exports.setOrigin=setOrigin,exports.setFocus=setFocus,exports.wasFocusTriggeredByTouch=wasFocusTriggeredByTouch,exports.setHiddenIndices=setHiddenIndices,exports.isPositionHidden=isPositionHidden,exports.add=add,exports.remove=remove,exports.clear=clear,exports.reset=reset,exports.updateContainer=updateContainer,exports.isSelected=isSelected,exports.hasHoles=hasHoles,exports.hasSelection=hasSelection,exports.getIndicesForContainer=getIndicesForContainer,exports.getIndicesWithHiddenForContainer=getIndicesWithHiddenForContainer;

},{"../../live":192,"../../range2":229,"../util/Position":316,"./containers":304,"./positions":308}],308:[function(require,module,exports){
"use strict";const $=require("../../spotify-elements"),containers=require("./containers"),Position=require("../util/Position");function getClosest(t,e){const n="down"===e;let o=t.containerIndex;const i=t.index;let r=containers.getContainerLength(o),s=n?i+1:i-1;return s<r&&s>=0?new Position(o,s):(o=n?o+1:o-1,(r=containers.getContainerLength(o))?new Position(o,s=n?0:r-1):null)}function getFromNode(t){if(!t.parentNode)return null;if(!t.hasAttribute("data-index"))return null;const e=containers.elements;if(0===e.length)return null;for(let n=0,o=e.length;n<o;n++)if(e[n]&&containsNode(e[n],t)){const e=+t.getAttribute("data-index");return new Position(n,e)}return null}function containsNode(t,e){let n=e;for(;n&&n.parentNode!==t;)n=n.parentNode;return!!n}function getNodeFromPosition(t){const e=containers.elements[t.containerIndex];if(!e)return null;const n=$(e).find(`[data-index=${t.index}]`);return n?n[0]:null}function getDirection(t,e){return t&&e?t.containerIndex!==e.containerIndex?t.containerIndex<e.containerIndex?1:-1:t.index===e.index?0:t.index<e.index?1:-1:0}function getPositionFromGlobalIndex(t){let e,n=t,o=0,i=0;for(let r=0,s=containers.elements.length;r<s&&!((i+=e=containers.getContainerLength(r))>t);r++)o=r+1,n-=e;return new Position(o,n)}function getGlobalIndexFromPosition(t){let e=t.index;for(let n=t.containerIndex-1;n>=0;n--)e+=containers.getContainerLength(n);return e}function getLastPosition(){const t=containers.elements.length-1,e=containers.getContainerLength(t)-1;return new Position(t,e)}function getLastPositionForSelectAll(){let t;containers.elements.forEach(function(e,n){"false"!==e.getAttribute("data-list-may-select-all")&&(t=n)});const e=containers.getContainerLength(t)-1;return new Position(t,e)}exports.getClosest=getClosest,exports.getFromNode=getFromNode,exports.getNodeFromPosition=getNodeFromPosition,exports.getDirection=getDirection,exports.getPositionFromGlobalIndex=getPositionFromGlobalIndex,exports.getGlobalIndexFromPosition=getGlobalIndexFromPosition,exports.getLastPosition=getLastPosition,exports.getLastPositionForSelectAll=getLastPositionForSelectAll;

},{"../../spotify-elements":235,"../util/Position":316,"./containers":304}],309:[function(require,module,exports){
"use strict";const $=require("../../spotify-elements"),difference=require("mout/array/difference"),model=require("./model"),containers=require("./containers"),positions=require("./positions"),SELECTOR_ROW="[data-list-item]",CLASSNAME_SELECTED="selected",CLASSNAME_FOCUSED="selection-focus",CLASSNAME_FOCUSED_TOUCH="selection-focus-touch";let focusTimeout;function update(e){const t=getSelectedRows(e),o=getRowsToSelect(e),n=difference(t,o),s=difference(o,t);t.forEach(function(e){$(e).removeClass(CLASSNAME_FOCUSED),$(e).removeClass(CLASSNAME_FOCUSED_TOUCH)}),n.forEach(function(e){$(e).removeClass(CLASSNAME_SELECTED)}),s.forEach(function(e){$(e).addClass(CLASSNAME_SELECTED)});const c=model.getFocus();if(c){const e=positions.getNodeFromPosition(c);e&&(clearTimeout(focusTimeout),focusTimeout=setTimeout(function(){const t=document.activeElement&&$(document.activeElement).matches("input, textarea"),o=document.activeElement&&$(document.activeElement).matches("button");!isElementInViewport(e)||t||o||e.focus()},0),$(e).addClass(CLASSNAME_FOCUSED),model.wasFocusTriggeredByTouch()&&$(e).addClass(CLASSNAME_FOCUSED_TOUCH))}}function getSelectedRows(e){const t=[];return(e?[e]:containers.elements).forEach(function(e){const o=$(e).search(`${SELECTOR_ROW}.${CLASSNAME_SELECTED}`);o&&Array.prototype.push.apply(t,o)}),t}function getRowsToSelect(e){const t=[],o=containers.elements;return model.selections.forEach(function(n,s){if(!n)return;const c=containers.getLiveList(s);if(!c)return;let i=o[s];if(e&&!o[s].contains(e)&&(i=null),!i)return;const r=$(i).search(SELECTOR_ROW);if(!r)return;const u=r.filter(function(e){const t=+e.getAttribute("data-index"),o=c.keys[t];return!!n[o]});Array.prototype.push.apply(t,u)}),t}function isElementInViewport(e){const t=e.getBoundingClientRect();return t.top>=0&&t.bottom<=document.documentElement.clientHeight}exports.update=update,exports.getSelectedRows=getSelectedRows;

},{"../../spotify-elements":235,"./containers":304,"./model":307,"./positions":308,"mout/array/difference":411}],310:[function(require,module,exports){
"use strict";const $=require("../spotify-elements"),center=require("./center"),live=require("../live"),ATTR_SLIDER="slider",ATTR_PROPERTY="slider-property",SELECTOR_SLIDER=`[data-${ATTR_SLIDER}]`,CLASSNAME_ENABLED="enabled",CLASSNAME_DISABLED="disabled",ATTR_ALLOWED="slider-allowed-property",TA_ID_SLIDER_STATE="data-ta-slider-state",SPACE_KEY_CODE=32,storedNodes=[];function handleClick(e,t){const n=t.data(ATTR_PROPERTY);t.data(ATTR_ALLOWED)&&!live(t.data("uri")).get(t.data(ATTR_ALLOWED))||(n?toggleModelPropertyAndPublish(t[0],n):emitChangeEvent(t[0],!t.hasClass(CLASSNAME_ENABLED)))}function handleKeyUp(e,t){e.keyCode===SPACE_KEY_CODE&&handleClick(e,t)}function onSliderSet(e){if(!e.id)return;const t=$(`[data-${ATTR_SLIDER}=${e.id}]`);if(!t)return;const n=t[0],d=!!e.enabled,i=t.data(ATTR_PROPERTY);i?toggleModelPropertyAndPublish(n,i,d):setState(n,d)}function toggleModelPropertyAndPublish(e,t,n){const d=getUriFromNode(e);if(!d)return;const i=live(d),a=i.get(t);if(void 0===a)return;const r=void 0===n?!a:n,o={};o[t]=r,i.publish(o)}function updateNode(e){if(storedNodes.indexOf(e)>-1)return;storedNodes.push(e);const t=$(e),n=t.data(ATTR_PROPERTY),d=t.data(ATTR_ALLOWED);if(!n)return;const i=getUriFromNode(e);if(!i)return;const a=live(i);a.get(n,function(t,i){if(t)throw t;setState(e,!!i),emitChangeEvent(e,!!i),a.on("update",function(t){n in t&&(setState(e,!!t[n]),emitChangeEvent(e,!!t[n])),d&&d in t&&disableNode(e,!t[d])})})}function setState(e,t){const n=$(e);t?(n.addClass(CLASSNAME_ENABLED),n.setAttribute("aria-checked","true"),n.setAttribute(TA_ID_SLIDER_STATE,"enabled")):(n.removeClass(CLASSNAME_ENABLED),n.setAttribute("aria-checked","false"),n.setAttribute(TA_ID_SLIDER_STATE,"disabled"))}function disableNode(e,t){const n=$(e);t?n.addClass(CLASSNAME_DISABLED):n.removeClass(CLASSNAME_DISABLED)}function emitChangeEvent(e,t){const n=$(e).data(ATTR_SLIDER)||null;center.emit("slider-change",{element:e,id:n,enabled:t})}function getUriFromNode(e){const t=e.closest("[data-uri]");return t?t.getAttribute("data-uri"):null}let isAttached=!1;exports.update=function(e){if(!isAttached)return;const t=$(e||document).search(SELECTOR_SLIDER);t&&t.forEach(updateNode)},exports.attach=function(){if(isAttached)return;isAttached=!0;const e=$(document);e.delegate("click",SELECTOR_SLIDER,handleClick),e.delegate("keyup",SELECTOR_SLIDER,handleKeyUp),center.on("slider-set",onSliderSet)},exports.detach=function(){if(!isAttached)return;isAttached=!1;const e=$(document);e.undelegate("click",SELECTOR_SLIDER,handleClick),e.undelegate("keyup",SELECTOR_SLIDER,handleKeyUp),center.off("slider-set",onSliderSet)};

},{"../live":192,"../spotify-elements":235,"./center":246}],311:[function(require,module,exports){
"use strict";const live=require("../live"),center=require("./center"),sortUriUtils=require("../live-sort-uri"),UIInteraction5=require("../logger/messages/UIInteraction5"),$=require("../spotify-elements"),ASC="tl-sort-asc",DESC="tl-sort-desc",setClassNames=function(t,e,r){const i=t.data("uri"),s=void 0!==e?e:sortUriUtils.getQuery(i),a=void 0!==r?r:sortUriUtils.getDirection(i),o=t.search("[data-sort]");if(o)for(let t=0;t<o.length;t++){const e=$(o[t]);e.removeClass(`${ASC} ${DESC}`),e.data("sort")===s&&e.addClass("asc"===a?ASC:DESC)}},handleSort=function(t,e){const r=e.parent("[data-list]");if(!r)return;const i=r.data("uri");if(!i)return;const s=sortUriUtils.getQuery(i),a=sortUriUtils.getDirection(i);let o=e.data("sort");let n=s===o?"asc"===a?"desc":"asc":"asc";const c=s===o&&"desc"===a,l=sortUriUtils.getOriginUri(i)||i;let d;c?(d=l,o=null,n=null):d=sortUriUtils.create(l,n,o),live(d).get("rows",function(){}),setClassNames(r,o,n),center.emit("sort-header-click",{uri:l,requested:{query:o||null,direction:n||null},current:{query:s||null,direction:a||null}}),center.emit("list-swap",{before:i,after:d}),UIInteraction5.log({pageuri:live("spotify:application").get("appURI")||"unknown",feature_id:"zlink",section_id:"sort-header",target_uri:d,interaction_type:"hit",user_intent:"sort",timestamp:Math.round(Date.now()/1e3)})},handlePreviousProxyClick=function(t,e){handleSort(0,e.previousSibling())};let isAttached=!1;exports.update=function(t){if(!isAttached)return;const e=$(t)||$(document),r=e.matches("[data-list]")?[e]:e.search("[data-list]");if(r)for(let t=0;t<r.length;t++){const e=$(r[t]);e.search("[data-sort]")&&setClassNames(e)}},exports.attach=function(){isAttached||(isAttached=!0,$(document).delegate("click","[data-sort]",handleSort),$(document).delegate("click","[data-sort-previous]",handlePreviousProxyClick))},exports.detach=function(){isAttached&&(isAttached=!1,$(document).undelegate("click","[data-sort]",handleSort),$(document).undelegate("click","[data-sort-previous]",handlePreviousProxyClick))};

},{"../live":192,"../live-sort-uri":190,"../logger/messages/UIInteraction5":203,"../spotify-elements":235,"./center":246}],312:[function(require,module,exports){
(function (global){
"use strict";var _frameUpdater=require("../frame-updater");const center=require("./center"),sort=require("./sort"),DEFAULT_STICKY_CLASS_NAME="sticky-top";let timestamp,isAttached=!1,scrollListenerId=0,nodesGBCR=null,rootGBCR=null,lastTotalStickyHeight=0,isDragScrolling=!1,dragScrollingSpeed=0,scrollTopOffset=0,currentScrollX=0,currentScrollY=0,rects=null,scrollNode=null;const getStickyClassName=function(e){const t=document.documentElement;let o,n;for(n=e;n!==t;n=n.parentNode)if(o=n.getAttribute("data-class-sticky"))return o;return"sticky-top"},getRects=function(e){const t=timestamp+e,o=document.querySelectorAll("[data-sticky]");if(t>(timestamp=Date.now())&&nodesGBCR&&o.length===nodesGBCR.length){let e=!0;for(let t=0;t<o.length;t++)e=e&&o[t]===nodesGBCR[t].node;if(e)return{nodes:nodesGBCR,root:rootGBCR}}return rootGBCR=scrollNode===document?document.documentElement.getBoundingClientRect():{top:(rootGBCR=scrollNode.getBoundingClientRect()).top-currentScrollY,right:rootGBCR.right,bottom:rootGBCR.bottom,left:rootGBCR.left,width:rootGBCR.width,height:rootGBCR.height},{nodes:nodesGBCR=Array.prototype.map.call(document.querySelectorAll("[data-sticky]"),function(e){const t=e.parentNode.getBoundingClientRect(),o=e.getBoundingClientRect();return{stickyClassName:getStickyClassName(e),node:e,rect:{top:t.top,height:o.height,left:t.left,right:t.right}}}),root:rootGBCR}},removeClone=function(e){const t=e.stickyClone;t.parentNode&&t.parentNode.removeChild(t),e.stickyListSwapListener&&center.off("list-swap",e.stickyListSwapListener),e.style.removeProperty("visibility"),delete e.stickyClone,delete e.stickyListSwapListener},resetSticky=function(e){"thead"===e.nodeName.toLowerCase()&&e.stickyClone&&removeClone(e),e.classList.remove(getStickyClassName(e));const t=e.closest("[data-glue-page-header]");t&&(t.classList.remove("glue-page-header--with-active-sticky-header"),global.onPageHeaderToggleStickyMode&&global.onPageHeaderToggleStickyMode(!1)),e.removeAttribute("data-sticky-active",""),e.style.right="",e.style.left="",e.style.position="",e.style.top=""},resetOldStickies=function(){const e=document.querySelectorAll("[data-sticky-active]:not([data-sticky])");for(let t=0,o=e.length;t<o;t++)e[t].isStickyClone||resetSticky(e[t])},readValuesWithTTL=function(e){const t=(scrollNode===document?document.body:scrollNode).getAttribute("data-top-bar-height");scrollTopOffset=parseInt(t,10)||0,currentScrollY=scrollNode===document?window.scrollY:scrollNode.scrollTop,rects=getRects(e)},createClone=function(e){const t=document.createElement("div"),o=e.cloneNode(!0),n=e.parentNode.cloneNode(!1);n.appendChild(o).removeAttribute("data-sticky"),t.appendChild(n),t.className="sticky-clone",t.isStickyClone=!0;const r=function(t){const n=o.parentNode;n&&n.getAttribute("data-uri")&&(n.setAttribute("data-uri",t.after),sort.update(e.parentNode))};return center.on("list-swap",r),e.parentNode.parentNode.appendChild(t),e.style.visibility="hidden",e.stickyListSwapListener=r,e.stickyClone=t,t},updateStickies=function(){const e=currentScrollY+scrollTopOffset,t=rects.root.width;let o=rects.root.top,n=scrollTopOffset;const r=rects.nodes;resetOldStickies(),0===r.length&&global.onPageHeaderToggleStickyMode&&global.onPageHeaderToggleStickyMode(!1),r.forEach(function(l,s){const i=l.node,c=l.rect,a=i.stickyClone,d=l.stickyClassName;let g=a||i;if(c.top-o<e){const l=r[s-1];if(l){const t=l.node,r=l.rect;if(t.hasAttribute("data-sticky-single")&&t.classList.contains(d)){const l=Math.abs(c.top-rects.root.top-(e+n));if(l<r.height){const e=n-r.height-l;t.style.top=`${e}px`,o-=l,n-=l}else resetSticky(t),o-=r.height,n-=r.height}}const a=c.left-rects.root.left,u=c.right-rects.root.left;if(g.classList.contains(d))g.style.right=`${t-u}px`,g.style.left=`${a}px`,g.style.top=`${n}px`;else{"thead"!==i.nodeName.toLowerCase()||i.stickyClone||(g=createClone(i)),g.classList.add(d);const e=g.closest("[data-glue-page-header]");e&&(e.classList.add("glue-page-header--with-active-sticky-header"),global.onPageHeaderToggleStickyMode&&global.onPageHeaderToggleStickyMode(!0)),g.setAttribute("data-sticky-active",""),g.setAttribute("data-ta-id","sticky-node"),g.style.right=`${t-u}px`,g.style.left=`${a}px`,g.style.position="fixed",g.style.top=`${n}px`}n+=c.height,o+=c.height}else g.classList.contains(d)&&resetSticky(i)}),lastTotalStickyHeight=n},handleResize=function(){readValuesWithTTL(0),updateStickies()},dragScrollingTick=function(){isDragScrolling&&currentScrollY>0&&((0,_frameUpdater.requestFrame)(()=>{currentScrollX=window.scrollX,currentScrollY=window.scrollY},()=>{dragScrollingTick()}),window.scrollTo(currentScrollX,currentScrollY-dragScrollingSpeed))},onPointerDragMove=function(e){const t=e.clientY-lastTotalStickyHeight;if(t>0&&t<20){const e=(20-Math.max(0,t))/20;dragScrollingSpeed=20*e,isDragScrolling||(isDragScrolling=!0,dragScrollingTick())}else isDragScrolling=!1},onPointerDragEnd=function(){isDragScrolling=!1,document.removeEventListener("dragover",onPointerDragMove),document.removeEventListener("dragend",onPointerDragEnd),document.removeEventListener("mouseup",onPointerDragEnd)},handleMouseDown=function(){document.addEventListener("dragover",onPointerDragMove),document.addEventListener("dragend",onPointerDragEnd),document.addEventListener("mouseup",onPointerDragEnd)};exports.DEFAULT_STICKY_CLASS_NAME="sticky-top",exports.attach=function(){isAttached||(isAttached=!0,scrollNode||(scrollNode=document),scrollListenerId=(0,_frameUpdater.addDebouncedScrollListener)(scrollNode,()=>{readValuesWithTTL(4e3)},()=>{updateStickies()}),window.addEventListener("resize",handleResize),document.addEventListener("mousedown",handleMouseDown),global.top&&global.top.document&&global.top.document.addEventListener("mousedown",handleMouseDown))},exports.detach=function(){isAttached&&(isAttached=!1,(0,_frameUpdater.removeDebouncedScrollListener)(scrollListenerId),window.removeEventListener("resize",handleResize),document.removeEventListener("mousedown",handleMouseDown),global.top&&global.top.document&&global.top.document.removeEventListener("mousedown",handleMouseDown),nodesGBCR=null,rootGBCR=null,lastTotalStickyHeight=0,isDragScrolling=!1,dragScrollingSpeed=0,scrollNode=null)},exports.update=function(){isAttached&&(nodesGBCR=null,rootGBCR=null,readValuesWithTTL(4e3),updateStickies())},exports.setScrollNode=function(e){scrollNode=e},exports._getStickyClassName=getStickyClassName;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../frame-updater":59,"./center":246,"./sort":311}],313:[function(require,module,exports){
"use strict";const $=require("../spotify-elements"),live=require("../live"),dom=require("./util/dom"),SELECTOR_THUMBS_DOWN_BUTTON="[data-button=thumbs-down]",SELECTOR_THUMBS_UP_BUTTON="[data-button=thumbs-up]";function handleThumbsButtonClick(t,e){const u=dom.getAttributeFromNodeOrParent(e[0],"data-button"),n=dom.getAttributeFromNodeOrParent(e[0],"data-uri"),o=dom.getContextFromNodeOrParent(e[0]);n&&o&&("thumbs-down"===u?live(o).emit("thumb-down",n):"thumbs-up"===u&&live(o).emit("thumb-up",n))}let isAttached=!1;exports.attach=function(){if(isAttached)return;isAttached=!0;const t=$(document);t.delegate("click","[data-button=thumbs-down]",handleThumbsButtonClick),t.delegate("click","[data-button=thumbs-up]",handleThumbsButtonClick)},exports.detach=function(){if(!isAttached)return;isAttached=!1;const t=$(document);t.undelegate("click","[data-button=thumbs-down]",handleThumbsButtonClick),t.undelegate("click","[data-button=thumbs-up]",handleThumbsButtonClick)},exports.update=function(){};

},{"../live":192,"../spotify-elements":235,"./util/dom":319}],314:[function(require,module,exports){
"use strict";const $=require("../spotify-elements"),tooltipMargin=8,tooltipArrowSize=5,tooltipNode=document.createElement("div");tooltipNode.id="tooltip";const tooltipTextNode=document.createElement("span");tooltipTextNode.setAttribute("dir","auto");const tooltipArrowTop=document.createElement("div");tooltipArrowTop.className="tooltip-arrow-top";const tooltipArrowBottom=document.createElement("div");tooltipArrowBottom.className="tooltip-arrow-bottom",tooltipNode.appendChild(tooltipArrowTop),tooltipNode.appendChild(tooltipArrowBottom),tooltipNode.appendChild(tooltipTextNode);let attachedNode=null,tooltipContainer=null,tooltipArrow=null;const addTooltipToDOM=function(t){(tooltipContainer=t).appendChild(tooltipNode)},removeTooltipFromDOM=function(){attachedNode=null,tooltipNode.parentNode&&tooltipContainer.removeChild(tooltipNode),tooltipContainer=null},getTooltipContainer=function(t){const o=t.getAttribute("data-tooltip-container");let e;return o&&(e=document.querySelector(o)),e||document.body},setText=function(t){tooltipTextNode.innerHTML=t},showTooltip=function(t,o){const e=o[0];let i=0,l=0;const d=o.data("tooltip")||o.getAttribute("title");if(!d)return;attachedNode=o,o.tooltipCheck||(o.removeAttribute("title"),o.setAttribute("data-tooltip",d),o.tooltipCheck=!0);const p=getTooltipContainer(o);tooltipContainer&&p===tooltipContainer||addTooltipToDOM(p),setText(d);const n=tooltipNode.clientHeight,a=tooltipNode.offsetWidth,r=window.pageYOffset,s=e.getBoundingClientRect(),c=e.offsetHeight,u=e.offsetWidth,h=parseInt(s.top,10)+r,m=parseInt(s.left,10)+u/2,N=h+c,T=document.documentElement.clientWidth,w=document.documentElement.clientHeight;N+n+8-r>w?(i=h-n-8,tooltipArrowTop.classList.remove("visible"),tooltipArrowBottom.classList.add("visible"),tooltipArrow=tooltipArrowBottom):((i=h+c+8)-r>w&&(i=w-n),tooltipArrowTop.classList.add("visible"),tooltipArrowBottom.classList.remove("visible"),tooltipArrow=tooltipArrowTop),(l=m-a/2)+a>=T-8?l=T-8-a:l<8&&(l=8),tooltipNode.style.top=`${i}px`,tooltipNode.style.left=`${l}px`,tooltipArrow.style.left=`${m-l-5}px`,o.hasAttribute("data-tooltip-instant")?tooltipNode.classList.add("instant"):tooltipNode.classList.remove("instant"),tooltipNode.classList.add("visible")},hideTooltip=function(){attachedNode&&(attachedNode=null,setText(""),tooltipNode.classList.remove("visible"),tooltipNode.style.left=0,tooltipNode.style.top=0,tooltipArrow&&(tooltipArrow.style.left=0))};let isAttached=!1;exports.attach=function(){if(isAttached)return;isAttached=!0;const t=$(document);t.delegate("mouseover","[data-tooltip]",showTooltip),t.delegate("mouseout","[data-tooltip]",hideTooltip),t.on("keydown",hideTooltip),t.on("mousedown",hideTooltip)},exports.detach=function(){if(!isAttached)return;isAttached=!1,attachedNode=null,tooltipNode.parentNode&&tooltipContainer.removeChild(tooltipNode),tooltipContainer=null;const t=$(document);t.undelegate("mouseover","[data-tooltip]",showTooltip),t.undelegate("mouseout","[data-tooltip]",hideTooltip),t.off("keydown",hideTooltip),t.off("mousedown",hideTooltip)},exports.update=function(){isAttached&&attachedNode&&(attachedNode.data("tooltip")?showTooltip(0,attachedNode):hideTooltip())},exports._setText=setText,exports._getTooltipNode=(()=>tooltipNode);

},{"../spotify-elements":235}],315:[function(require,module,exports){
"use strict";const prime=require("../../../libs/prime"),Emitter=require("../../../libs/prime/emitter"),Range=require("../../range2"),SYNC=Emitter.EMIT_SYNC;module.exports=prime({mixin:Emitter,constructor:function(t,e){this.container=t,this.height=e.height||0,this.length=e.length||0,this.tag=e.tag||"li",this.request=e.request,this._id=0,this.reset()},resetFrom:function(t,e,i){const n=this._range;t<n.end&&(this.reset(e,i),this.show(n))},reset:function(t,e){const i=this.tag;void 0!==t&&(this.length=t);const n=this.length*this.height;if(e)throw new TypeError("Hidden indices are not supported anymore!");this.container.innerHTML=`<${i} style="height:${n}px"></${i}>`+`<${i} style="height:0px"></${i}>`,this._range=new Range(0,0),this._waitingRange=new Range(0,0),this.emit("index-change",[],SYNC)},show:function(t){const e=this.length,i=this._range,n=this._waitingRange,s=new Range(Math.max(0,t.start),Math.min(e,t.end));s.start===i.start&&s.end===i.end||s.start===n.start&&s.end===n.end||this._drawRange(s)},_drawRange:function(t){const e=this.container,i=this._range,n=this.height,s=this.length,h=++this._id;this._waitingRange=t,this.request(t,(r,a)=>{let g,o=0;if(h!==this._id)return;this._range=t,this._waitingRange=new Range(0,0);const c=e.firstChild,l=e.lastChild;c.style.height=`${t.start*n}px`,l.style.height=`${(s-t.end)*n}px`,i.subtract(t).forEach(function(t){const n=t.length;for(g=0;g<n;g++)e.removeChild(e.children[t.start-i.start-o+1]);o+=n}),t.subtract(i).forEach(n=>{const s=n.length,h=n.start-t.start,r=a.slice(h,h+s);let o;for(this.emit("before-show",n,r,SYNC),o=n.below(i)?c.nextSibling:l,g=0;g<s;g++)e.insertBefore(r[g],o);this.emit("after-show",n,r,SYNC)}),this.emit("index-change",[t],SYNC)})}});

},{"../../../libs/prime":227,"../../../libs/prime/emitter":226,"../../range2":229}],316:[function(require,module,exports){
"use strict";const Position=function(n,i){this.containerIndex=n,this.index=i};Position.prototype.isSame=function(n){return this.containerIndex===n.containerIndex&&this.index===n.index},module.exports=Position;

},{}],317:[function(require,module,exports){
"use strict";const live=require("../../live");function checkIfActive(){return live("spotify:application").get("active")||!1}function checkIfFocused(){const e=window.top.document.activeElement,c=e&&e.contentWindow;return c?c===window:window.top===window}exports.isActive=function(){return checkIfActive()},exports.isActiveAndFocused=function(){return checkIfActive()&&checkIfFocused()};

},{"../../live":192}],318:[function(require,module,exports){
"use strict";const live=require("../../live"),cosmos=require("../../cosmos-api").default,liburi=require("spotify-liburi"),ASAP=live.ASAP;function DELETE(e,t){return e.method=exports.cosmos.Action.DELETE,request(e,t)}function GET(e,t){return e.method=exports.cosmos.Action.GET,request(e,t)}function SUB(e,t){return e.method=exports.cosmos.Action.SUB,request(e,t)}function POST(e,t){return e.method=exports.cosmos.Action.POST,request(e,t)}function PUT(e,t){return e.method=exports.cosmos.Action.PUT,request(e,t)}function HEAD(e,t){return e.method=exports.cosmos.Action.HEAD,request(e,t)}function request(e,t){const o=e.method;let s,r;return delete e.method,sanitizeURL(e.url,function(n,u){if(n)return void t(n);if(r)return;const i=new exports.cosmos.Request(o||exports.cosmos.Action.GET,u,e.headers,e.body);s=exports.cosmos.resolver.resolve(i,function(e,o){if(t)if(e)t(e);else try{t(null,{body:JSON.parse(o.getBody()||"{}"),headers:o.getHeaders(),status:o.getStatusCode()})}catch(e){e.response=o,t(e)}})}),{cancel:function(){return s&&s.cancel?(s.cancel(),s=null):r||(r=!0),null}}}function sanitizeURL(e,t){e.indexOf("@")>-1?live("spotify:client").query("currentUser(username)",function(o,s){o?t(o):t(null,e.replace("@",liburi.getCanonicalUsername(s.currentUser.username)))},ASAP):t(null,e)}exports.request=request,exports.get=GET,exports.post=POST,exports.subscribe=SUB,exports.delete=DELETE,exports.put=PUT,exports.head=HEAD,exports.cosmos=cosmos,exports.sanitizeURL=sanitizeURL;

},{"../../cosmos-api":45,"../../live":192,"spotify-liburi":475}],319:[function(require,module,exports){
"use strict";function getContextFromNodeOrParent(t){const e=t.closest("[data-context]");return e&&e.getAttribute("data-uri")||""}function getAttributeFromNodeOrParent(t,e){const r=`[${e}]`,o=t.closest(r);return o&&o.getAttribute(e)||""}exports.getContextFromNodeOrParent=getContextFromNodeOrParent,exports.getAttributeFromNodeOrParent=getAttributeFromNodeOrParent;

},{}],320:[function(require,module,exports){
"use strict";module.exports=function(t){let e=t;const o=[];for(;e;)e.matches&&e.matches("[data-log-context]")&&o.unshift(e.getAttribute("data-log-context")),e=e.parentNode;return o.join("/")||null};

},{}],321:[function(require,module,exports){
"use strict";const rAF=window.requestAnimationFrame||function(t){setTimeout(t,16)};function throttle(t,n){let e,o=!1;return function(){e=arguments,o||(o=!0,rAF(function(){o=!1,t.apply(n,e)}))}}module.exports=throttle;

},{}],322:[function(require,module,exports){
"use strict";const operators={"==":function(n,r){return n==r},"===":function(n,r){return n===r},"!=":function(n,r){return n!=r},"<":function(n,r){return n<r},">":function(n,r){return n>r},"<=":function(n,r){return n<=r},">=":function(n,r){return n>=r},typeof:function(n,r){return typeof n==r}};function compare(n,r,t){const e=arguments[arguments.length-1],o=t!==e&&t?"==":e.hash.operator||"===";return operators[o](n,r)?e.fn(this):e.inverse(this)}compare.displayName="compare",module.exports=compare;

},{}],323:[function(require,module,exports){
"use strict";const duration=function(t){if(isNaN(t))return t;const o=Math.round(t/1e3);let r=Math.floor(o/3600),n=Math.floor(o%3600/60),a=Math.round(o%3600%60);return r?(r+=":",n<10&&(n=`0${n}`)):r="",a<10&&(a=`0${a}`),`${r+n}:${a}`};duration.displayName="duration",module.exports=duration;

},{}],324:[function(require,module,exports){
"use strict";const nameListTooltip=require("./name-list-tooltip"),facepile=function(e,t){if(!e)return"";const i=e.length,o=Math.min(3,i);let l="";for(let i=0;i<o;i++){const o=e[i];l+=t.fn(o)}return i>o&&(l+=t.inverse({badgeCount:i-o,badgeTooltip:nameListTooltip(e.slice(o),i-o)})),l};facepile.displayName="facepile",module.exports=facepile;

},{"./name-list-tooltip":331}],325:[function(require,module,exports){
(function (global){
"use strict";const getHTTPLink=require("../util/link"),isDesktop=!!global._getSpotifyModule,href=function(e){return isDesktop?e:getHTTPLink(e,"https://play.spotify.com")};href.displayName="href",module.exports=href;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../util/link":339}],326:[function(require,module,exports){
"use strict";const loc=require("./loc"),humanizeDuration=function(o){if(isNaN(o))return o;const t=Math.round(o/1e3),r=Math.floor(t/3600),n=Math.floor(t%3600/60),u=Math.round(t%3600%60);let e="";return r&&(e+=loc("HoursShort",r,{})),n&&(e+=" ",e+=loc("MinutesShort",n,{})),(!r&&!n||0===r&&n<10)&&(e+=" ",e+=loc("SecondsShort",u,{})),e.trim()};humanizeDuration.displayName="humanizeDuration",module.exports=humanizeDuration;

},{"./loc":330}],327:[function(require,module,exports){
"use strict";exports.compare=require("./compare"),exports.duration=require("./duration"),exports.facepile=require("./facepile"),exports.href=require("./href"),exports.humanizeDuration=require("./humanize-duration"),exports.list=require("./list"),exports.loc=require("./loc"),exports.nameListTooltip=require("./name-list-tooltip"),exports.nft=require("./nft"),exports.numeral=require("./numeral"),exports.share=require("./share"),exports.slice=require("./slice"),exports.type=require("./type"),exports.userReaction=require("./user-reaction"),exports.json=require("./json");

},{"./compare":322,"./duration":323,"./facepile":324,"./href":325,"./humanize-duration":326,"./json":328,"./list":329,"./loc":330,"./name-list-tooltip":331,"./nft":332,"./numeral":333,"./share":334,"./slice":335,"./type":336,"./user-reaction":337}],328:[function(require,module,exports){
"use strict";const json=function(s){return JSON.stringify(s)};json.displayName="json",module.exports=json;

},{}],329:[function(require,module,exports){
"use strict";const map=require("mout/array/map"),Handlebars=require("handlebars/dist/cjs/handlebars.runtime").default,lists={},list=function(e){if(!e)return"";const s=Array.prototype.slice.call(arguments),t=s.pop(),a=s[1];return"reset"===e?(delete lists[a],""):(a&&void 0===lists[a]&&(lists[a]=-1),map(e,function(e,s){const r=Handlebars.createFrame(t.data||{});return r.index=a?++lists[a]:s,r.number=r.index+1,r.localIndex=s,r.localNumber=s+1,t.fn(e,{data:r})}).join(t.hash&&t.hash.join||""))};list.displayName="list",module.exports=list;

},{"handlebars/dist/cjs/handlebars.runtime":364,"mout/array/map":418}],330:[function(require,module,exports){
"use strict";var _mixIn=require("mout/object/mixIn"),_mixIn2=_interopRequireDefault(_mixIn),_locales=require("../../locales"),_locales2=_interopRequireDefault(_locales);function _interopRequireDefault(e){return e&&e.__esModule?e:{default:e}}const slice_=Array.prototype.slice;let locale="en",numberFormat=new Intl.NumberFormat(locale),pluralRules=new Intl.PluralRules(locale);const storage={},loc=function(e){let l=slice_.call(arguments,1),t={};const o=l[l.length-1];"object"==typeof o&&"hash"in o&&(t=l.pop());const r=t.hash,a="object"==typeof storage[e]?storage[e][pluralRules.select(l[0])]||storage[e].other:storage[e];return a?(Array.isArray(l[0])&&(l=l[0]),a.replace(/\{([\w-]+)\}/g,function(e,t){const o=+t;let a;return"number"==typeof(a=isNaN(o)?r[t]:l[o])&&(a=numberFormat.format(a)),null!==a?a:""})):""};loc.displayName="loc",loc.register=function(e){return(0,_mixIn2.default)(storage,e),this},loc.setLocale=function(e){locale=e,numberFormat=new Intl.NumberFormat((0,_locales2.default)(locale,"intl")),pluralRules=new Intl.PluralRules((0,_locales2.default)(locale,"intl"))},module.exports=loc;

},{"../../locales":198,"mout/object/mixIn":449}],331:[function(require,module,exports){
"use strict";const loc=require("./loc"),nameListTooltip=function(o,t){if(0===t)return;const n=o.length,e=o.map(function(o){return o.name});if(t-n>0){const o=loc("AndMore",t-n);e.push(o)}return e.join("<br>\n").replace(/'/g,"&#39;")};nameListTooltip.displayName="nameListTooltip",module.exports=nameListTooltip;

},{"./loc":330}],332:[function(require,module,exports){
"use strict";function nft(){const t=arguments[arguments.length-1];return!!top.initialState&&top.initialState.useNftUi?t.fn(this):t.inverse(this)}nft.displayName="nft",module.exports=nft;

},{}],333:[function(require,module,exports){
"use strict";const isNumber=require("mout/lang/isNumber"),numeralHelper=function(e,r){const u=r&&r.hash&&r.hash.format,l=numeralHelper._numeral;return isNumber(e)?l(e).format(u):e};numeralHelper.displayName="numeral",module.exports=numeralHelper,module.exports.setLocale=function(e){numeralHelper._numeral=require("../../spotify-numeral")(e)};

},{"../../spotify-numeral":344,"mout/lang/isNumber":434}],334:[function(require,module,exports){
"use strict";const getHTTPLink=require("../util/link"),share=function(e){return getHTTPLink(e,"https://open.spotify.com")};share.displayName="share",module.exports=share;

},{"../util/link":339}],335:[function(require,module,exports){
"use strict";const kindOf=require("mout/lang/kindOf"),map=require("mout/array/map"),forEach=require("mout/array/forEach"),Handlebars=require("handlebars/dist/cjs/handlebars.runtime").default,slice_=Array.prototype.slice,slice=function(e){let r,a,l,n,i=e;return i?(forEach(slice_.call(arguments,1),function(e){switch(kindOf(e)){case"String":r=e;break;case"Number":null===a?a=e:null===l&&(l=e);break;case"Object":n=e}}),null!==a&&(i=i.slice(a,null!==l?l:i.length)),map(i,function(e,r){const a=Handlebars.createFrame(n.data||{});return a.index=r,n.fn(e,{data:a})}).filter(e=>""!==e).join(r||"")):""};slice.displayName="slice",module.exports=slice;

},{"handlebars/dist/cjs/handlebars.runtime":364,"mout/array/forEach":415,"mout/array/map":418,"mout/lang/kindOf":438}],336:[function(require,module,exports){
"use strict";const getType=require("../util/type"),type=function(e){if(arguments.length<=2)return getType(e);const t=arguments[arguments.length-1];let n=!1;const r=getType(e);for(let e=1;e<arguments.length-1;e++)if(r===arguments[e]){n=!0;break}return n?t.fn(this):t.inverse(this)};type.displayName="type",module.exports=type;

},{"../util/type":340}],337:[function(require,module,exports){
"use strict";const loc=require("./loc"),userReaction=function(e,t,n){if(!t)return"";const r=`${n}Reaction${t>1?"Multi":"Single"}`;if(t>1)return loc(r,t);if(!e.length)return"";const o=e[0].name;return loc(r,o)};userReaction.displayName="userReaction",module.exports=userReaction;

},{"./loc":330}],338:[function(require,module,exports){
"use strict";const kindOf=require("mout/lang/kindOf"),Handlebars=require("handlebars/dist/cjs/handlebars.runtime").default;exports.runtime=Handlebars,exports.register=function(e){let r={};"Function"===kindOf(e)?r[e.displayName]=e:r=e;for(const e in r)r.hasOwnProperty(e)&&Handlebars.registerHelper(e,r[e]);return this};

},{"handlebars/dist/cjs/handlebars.runtime":364,"mout/lang/kindOf":438}],339:[function(require,module,exports){
"use strict";module.exports=function(t,s){const e=(t||"").match(/^spotify:(.+)$/);if(!e)return t||"";let i=e.pop().replace(/:$/,"").split(/:/);const n=i.shift();return"search"===n&&(i=[i.join(":")]),i.unshift(s,n),i.join("/")};

},{}],340:[function(require,module,exports){
"use strict";module.exports=function(e){if(!e||!e.split)return null;const t=e.split(":");switch(t[1]){case"album":if(4===t.length)return"disc";if(3===t.length)return"album";break;case"artist":if(3===t.length)return"artist";break;case"dailymix":return"dailymix";case"track":if(3===t.length)return"track";break;case"playlist":if(3===t.length)return"playlist";break;case"genre":if(3===t.length)return"genre";break;case"show":if(3===t.length)return"show";break;case"station":if(t.length>3)return"station";break;case"episode":if(3===t.length)return"episode";break;case"local":if(6===t.length)return"track";if(4===t.length)return"album";if(3===t.length)return"artist";break;case"user":if(t.length>3&&"collection"===t[3]&&"album"===t[4])return"collection-album";if(t.length>3&&"collection"===t[3]&&"artist"===t[4])return"collection-artist";if(t.length>3&&"collection"===t[3])return"collection";if(5===t.length&&"folder"===t[3])return"playlist-folder";if(5===t.length&&"cluster"===t[3])return"cluster";if(t.length>3&&t.length<=5&&"facebook"!==t[2])return"playlist";if(3===t.length)return"user";break;case"internal":return t[2];case"app":return t.slice(1).join("-")}return null};

},{}],341:[function(require,module,exports){
"use strict";var _strings=require("../glue/strings"),_strings2=_interopRequireDefault(_strings),_interpolateString=require("./src/interpolate-string"),_interpolateString2=_interopRequireDefault(_interpolateString),_locales=require("../locales"),_locales2=_interopRequireDefault(_locales),_escapeHtml=require("escape-html"),_escapeHtml2=_interopRequireDefault(_escapeHtml);function _interopRequireDefault(e){return e&&e.__esModule?e:{default:e}}module.exports=function(e){if(!e||"object"!=typeof e)throw new Error("`appStringsByLocale` must be a plain object. See spotify-i18n/README.md");function t(){const t="undefined"!=typeof window&&window&&window.__spotify&&window.__spotify.locale;return t in e?t:"en"}const n={};function r(e,r,...i){const l=t(),o=e[l][r],u="object"!=typeof o?o:o[function(e,t){return(n[e]||(n[e]=new Intl.PluralRules((0,_locales2.default)(e,"intl")))).select(t)}(l,i[0])]||o.other;return void 0===u?(0,_escapeHtml2.default)(r):(0,_interpolateString2.default)(u,i,l)}return{locale:t,get:r.bind(null,e),getGlueString:r.bind(null,_strings2.default),glueStrings:function(){return _strings2.default[t()]},appStrings:function(){return e[t()]}}};

},{"../glue/strings":87,"../locales":198,"./src/interpolate-string":342,"escape-html":363}],342:[function(require,module,exports){
"use strict";function interpolateString(e,t=[],r){const n=new Intl.NumberFormat(r||"en");return e.replace(/\{(\d+?)\}/g,function(e,r){const o=t[r];return void 0===o?e:"number"==typeof o?n.format(o):o})}Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=interpolateString;

},{}],343:[function(require,module,exports){
"use strict";const moment=require("moment"),locales=require("../locales");module.exports=function(e){const r={ar:require("moment/locale/ar"),cs:require("moment/locale/cs"),de:require("moment/locale/de"),el:require("moment/locale/el"),es:require("moment/locale/es"),fi:require("moment/locale/fi"),fr:require("moment/locale/fr"),"fr-ca":require("moment/locale/fr-ca"),hu:require("moment/locale/hu"),id:require("moment/locale/id"),it:require("moment/locale/it"),ja:require("moment/locale/ja"),nl:require("moment/locale/nl"),pl:require("moment/locale/pl"),"pt-br":require("moment/locale/pt-br"),sv:require("moment/locale/sv"),th:require("moment/locale/th"),tr:require("moment/locale/tr"),vi:require("moment/locale/vi"),"zh-tw":require("moment/locale/zh-tw"),"ms-my":require("moment/locale/ms-my")},l=locales(e,"moment");return l&&r[l]?moment.locale(l):moment.locale("en"),moment};

},{"../locales":198,"moment":408,"moment/locale/ar":387,"moment/locale/cs":388,"moment/locale/de":389,"moment/locale/el":390,"moment/locale/es":391,"moment/locale/fi":392,"moment/locale/fr":394,"moment/locale/fr-ca":393,"moment/locale/hu":395,"moment/locale/id":396,"moment/locale/it":397,"moment/locale/ja":398,"moment/locale/ms-my":399,"moment/locale/nl":400,"moment/locale/pl":401,"moment/locale/pt-br":402,"moment/locale/sv":403,"moment/locale/th":404,"moment/locale/tr":405,"moment/locale/vi":406,"moment/locale/zh-tw":407}],344:[function(require,module,exports){
"use strict";var _locales=require("../locales"),_locales2=_interopRequireDefault(_locales);function _interopRequireDefault(e){return e&&e.__esModule?e:{default:e}}function getOrdinalFunction(e){switch(e){case"ar":case"cs":case"de":case"el":case"fi":case"hu":case"ja":case"pl":case"sv":case"ms":return e=>`${e}.`;case"it":case"pt-BR":return e=>`${e}º`;case"fr":case"fr-CA":return e=>`${e}${1===e?"er":"e"}`;case"es":case"es-419":return(e,r=e%10)=>`${e}${1===r||3===r?"er":2===r?"do":7===r||0===r?"mo":8===r?"vo":9===r?"no":"to"}`;case"id":return e=>`${e}`;case"nl":return(e,r=e%100)=>`${e}${0!==e&&r<=1||8===r||r>=20?"ste":"de"}`;case"tr":return e=>{if(0===e)return`${e}'ıncı`;const r={1:"'inci",5:"'inci",8:"'inci",70:"'inci",80:"'inci",2:"'nci",7:"'nci",20:"'nci",50:"'nci",3:"'üncü",4:"'üncü",100:"'üncü",6:"'ncı",9:"'uncu",10:"'uncu",30:"'uncu",60:"'ıncı",90:"'ıncı"},n=e%10;return`${e}${r[n]||r[e%100-n]||r[e>=100?100:null]}`};case"zh-Hant":return e=>`第${e}`;case"en":return(e,r=e%10)=>`${e}${1==~~(e%100/10)?"th":1===r?"st":2===r?"nd":3===r?"rd":"th"}`;case"th":return e=>`${e}`;case"vi":return e=>1===e?"thứ nhất":`thứ ${e}`;default:return console.warn(`No explicit ordinal formatter specified for "${e}" locale – please add to spotify-numeral`),e=>`${e}.`}}module.exports=function(e){const r=getOrdinalFunction(e),n=new Intl.NumberFormat((0,_locales2.default)(e,"intl"));return e=>({format:t=>((e,t="0,0")=>{if("0,0"===t)return n.format(e);if("0o"===t)return r(e);throw new Error(`Unsupported format ${t}`)})(e,t)})};

},{"../locales":198}],345:[function(require,module,exports){
"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var _range=require("mout/array/range"),_range2=_interopRequireDefault(_range);function _interopRequireDefault(e){return e&&e.__esModule?e:{default:e}}const ROW_LOADING_STATE={PENDING:{},ISSUED:{}},tardy=function(e){const n={extraOptionArgument:null},t=(e,n)=>(0,_range2.default)(e,e+n-1),r=function(){const e=n.pendingRangeRequests;return n.pendingRangeRequests=[],e.forEach(function(e){const{offset:r,length:a,callback:o}=e;if(o)return function(e,r){const a=t(e,r);for(let e=0;e<a.length;e++){const t=a[e];if(!n.cache[t]&&!n.isOverflow[t])return!1}return!0}(r,a)?e.callback(null,((e,t)=>n.cache.slice(e,e+t))(r,a)):n.pendingRangeRequests.push(e)})},a=function(){let a=Number.POSITIVE_INFINITY,o=Number.NEGATIVE_INFINITY;if((0,_range2.default)(0,n.loadingStateOfIndex.length-1).forEach(function(e){return n.loadingStateOfIndex[e]===ROW_LOADING_STATE.PENDING&&(e<a&&(a=e),e>o&&(o=e),n.loadingStateOfIndex[e]=ROW_LOADING_STATE.ISSUED)}),a===Number.POSITIVE_INFINITY)return clearInterval(n.workerHandle),void(n.workerHandle=null);const u=n.cache,c=a,l=o-a+1;return e(c,l,n.extraOptionArgument,function(e,a){if(e)return void n.pendingRangeRequests.forEach(n=>n.callback(e));const o=l-a.length;if(o>0){const e=__range__(c+l-o,c+l-1,!0);for(let t=0;t<e.length;t++){const r=e[t];n.isOverflow[r]=!0}}u.isEvicted||function(e,a){t(e,a.length).forEach((e,t)=>n.cache[e]=a[t]),r()}(c,a)})},o=function(e,o,u){return n.workerHandle||(n.workerHandle=setInterval(a,200)),t(e,o).forEach(function(e){let t;return n.loadingStateOfIndex[e]||(t=n.loadingStateOfIndex[e]=ROW_LOADING_STATE.PENDING),t}),n.pendingRangeRequests.push({offset:e,length:o,callback:u}),r()};return o.reset=function(){return n.cache&&(n.cache.isEvicted=!0),n.cache=[],n.pendingRangeRequests=[],n.loadingStateOfIndex=[],n.isOverflow=[]},o.setExtraOptionArgument=(e=>n.extraOptionArgument=e),o.reset(),o};function __range__(e,n,t){const r=[],a=e<n;let o;o=t?a?n+1:n-1:n;for(let n=e;a?n<o:n>o;a?n++:n--)r.push(n);return r}exports.default=tardy;

},{"mout/array/range":419}],346:[function(require,module,exports){
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=require("./lib").default;

},{"./lib":350}],347:[function(require,module,exports){
"use strict";var _events=require("events");const debounce=require("mout/function/debounce"),deepClone=e=>JSON.parse(JSON.stringify(e)),MAGIC_TRACK_NUMBER=500,failDependency=e=>{throw new Error(`List was created without option ${e}! Unable to create list.`)},getRow=e=>{const t=deepClone(e);return t.index=`${t.index}`,t.localNumber=`${t.localNumber}`,t},list=e=>{const t=e.live||failDependency("live"),n=e.center||failDependency("center"),r=e.events||failDependency("events"),s=e.eventsSort||failDependency("eventsSort"),o=e.eventsSelection||failDependency("eventsSelection"),i=e.domFacade||failDependency("domFacade"),a=e.domReady||failDependency("domReady"),l=e.createRowElement||failDependency("createRowElement"),d=e.storage||failDependency("storage"),c=e.sortMap||failDependency("data-sort-map"),u=!!Object.keys(e).includes("sortable")&&e.sortable,g=e.targetNode||failDependency("targetNode"),p=e.listTemplate||failDependency("listTemplate"),m=e.filterEmptyTemplate||(()=>"<span></span>"),f=e.rowTemplate||failDependency("rowTemplate"),y=e.listURI||failDependency("listURI"),h=e.getSongsDataRange||failDependency("getSongsDataRange"),v=e.getAllSongURIs||failDependency("getAllSongURIs"),R=e.removeDataRow||failDependency("removeDataRow"),x=e.confirmRemoveDataRows||failDependency("confirmRemoveDataRows"),D={hasLoadedOnce:!1,lastVisibleRange:null,onErrorHandler:null,onReadyHandlers:[],extraOptionArgument:null,uriListLength:0},O={},A=i.createElement("div"),L=i.createElement("div");i.appendChild(g,A),i.appendChild(g,L),A.innerHTML=p({uri:y,sortable:u}),L.style.display="none";const w=g.querySelector("[data-list-items]"),b=e=>{if(!D.onErrorHandler)throw new Error("An error occured, but no handler has been registered on the virtual-songs-list controller.");return D.onErrorHandler(e)},E=()=>{D.hasLoadedOnce&&(D.isDestroyed||v(D.extraOptionArgument,(e,r)=>{if(e)return void b(e);L.style.display=0===r.length?"block":"none",D.isFiltering?O.emitter.emit("is-empty",!1):O.emitter.emit("is-empty",0===r.length),h.reset();const s=()=>{t(y).get("rows").update([{type:"remove",index:0,length:t(y).get("rows").length},{type:"insert",index:0,values:r.map(e=>({track:{uri:e}})),keys:r}]),n.emit("scroll-reset",w,r.length)};if(D.lastVisibleRange){const e=D.lastVisibleRange,t=e.offset,n=e.length;h(t,n,s)}else s()}))},C=`extraOptionArgument:${e.listURI}`;return e.sortable||d.set(C,null),d.get(C,(e,t)=>{if(e)throw e;try{D.extraOptionArgument=JSON.parse(t),h.setExtraOptionArgument(D.extraOptionArgument)}catch(e){}const n=c.jsonToCore(D.extraOptionArgument);if(n){const e=c.coreToLive(n.property),t=i.documentQuerySelector(`[data-sort="${e}"]`);if(!t)return void console.warn("Failed to convert property to node ",n.property,e);if("descending"===n.order)return void setTimeout(()=>i.addClass("tl-sort-desc",t),0);if("ascending"===n.order)return void setTimeout(()=>i.addClass("tl-sort-asc",t),0)}}),n.on("filter-request",D.filterRequestListener=((t,n)=>{t===e.listURI&&(D.isFiltering=!!n,L.innerHTML=m({uri:t,filterRequestValue:n}),D.extraOptionArgument=Object.assign(D.extraOptionArgument||{},{filter:n}),h.setExtraOptionArgument(D.extraOptionArgument),E())})),n.on("scroll-request",D.scrollRequestListener=((e,{start:n,length:r},s)=>{if(e!==w)return;const o=e=>h(n,r,(o,i)=>{if(D.isDestroyed)return;if(o)return void b(o);i.forEach((e,t)=>{e.localNumber=(e.index=t+n)+1}),t(y).get("rows").update([{type:"remove",index:n,length:r},{type:"insert",index:n,values:i.slice(0),keys:i.map(({track:e})=>e.uri)}]);const a=i.length;for(;i.length<r;)i.push({});const d=i.map(e=>{const t=getRow(e);return l(f(t))});s(null,d,e);const c=D.uriListLength>3&&r>3&&a===r||D.uriListLength<=3&&r<=3&&D.uriListLength===a;D.isDisplayable=c,c&&(D.onReadyHandlers.forEach(e=>e()),D.hasLoadedOnce=!0);const u=Math.min(r+500,e-n-1);h(n,u,()=>{const e=Math.max(n-500,0);return h(e,n-e)})});D.uriListLength>0?o(D.uriListLength):v(D.extraOptionArgument,(e,n)=>{D.isDestroyed||(e?b(e):(D.uriListLength=n.length,D.isFiltering?O.emitter.emit("is-empty",!1):O.emitter.emit("is-empty",0===n.length),0===n.length&&D.onReadyHandlers.forEach(e=>e()),t({uri:y,allows:{removeTracks:!0},rows:[]}),t(y).get("rows").update([{type:"insert",index:0,values:n.map(e=>({track:{uri:e}})),keys:n}]),o(n.length)))})})),a(()=>{const o=t(y);return void 0===o.get("rows")&&o.update({rows:[]}),n.on("scroll-index-change",D.scrollIndexChangeListener=(({ranges:e})=>{if(0===e.length)return;const t=e[0];D.lastVisibleRange={offset:t.start,length:t.length}})),t(y).get("rows").on("publish",e=>{e.forEach(e=>{"remove"===e.type&&(e.keys.length>1?x(e.keys.length,()=>{e.keys.forEach(e=>R(e))}):e.keys.forEach(e=>R(e)))})}),i.addDocumentClickListener(t=>{if(D.isDestroyed)return;const n=i.getParent("[data-uri]",t);if(!n)return;const r=i.getAttribute("data-uri",n);if(y!==r)return;const s=i.getAttribute("data-sort",t);if(!s)return;let o=!1,a=c.liveToCore(s);const l=i.querySelector(".tl-sort-asc, .tl-sort-desc",n);if(l){const e=i.getAttribute("data-sort",l);o=c.liveToCore(e)===a}else o=!1;let u;i.getChildren(i.getParent(null,t)).forEach(e=>{i.removeClass("tl-sort-asc",e),i.removeClass("tl-sort-desc",e)});const g=D.extraOptionArgument&&D.extraOptionArgument.sorting&&D.extraOptionArgument.sorting[0][1];"ascending"===g&&o?(u="descending",i.addClass("tl-sort-desc",t)):"descending"===g&&o?(u=null,a=null):(u="ascending",i.addClass("tl-sort-asc",t)),D.extraOptionArgument=Object.assign(D.extraOptionArgument||{},{sorting:[[a,u]]}),d.set(`extraOptionArgument:${e.listURI}`,JSON.stringify(D.extraOptionArgument)),h.setExtraOptionArgument(D.extraOptionArgument),E()}),r.attach(),s.detach(),r.update()}),O.refresh=debounce(E,300),O.onError=(e=>{D.onErrorHandler=e}),O.onReady=(e=>D.onReadyHandlers.push(e)),O.emitter=new _events.EventEmitter,O.destroy=(()=>(D.isDestroyed=!0,n.off("scroll-index-change",D.scrollIndexChangeListener),n.off("scroll-request",D.scrollRequestListener),n.off("filter-request",D.filterRequestListener),delete O.emitter,A.remove(),L.remove())),O.scrollTo=(e=>{const t=()=>(o.clear(),o.add(y,e),n.emit("scroll-to-index",w,e));return D.hasLoadedOnce?t():O.onReady(t)}),O};exports.list=list;

},{"events":358,"mout/function/debounce":423}],348:[function(require,module,exports){
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=(e=>t=>{const r=e.document.createElement("tbody");return r.innerHTML=t,r.children[0]});

},{}],349:[function(require,module,exports){
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=(e=>({addClass:(e,t)=>t.classList.add(e),removeClass:(e,t)=>t.classList.remove(e),documentQuerySelector:t=>e.document.querySelector(t),addDocumentClickListener:t=>e.document.addEventListener("click",e=>t(e.target)),getAttribute:(e,t)=>t.getAttribute(e),getParent:(e,t)=>e?t.closest(e):t.parentNode,getChildren:e=>Array.prototype.slice.call(e.children),querySelector:(e,t)=>t.querySelector(e),createElement:t=>e.document.createElement(t),appendChild:(e,t)=>e.appendChild(t)}));

},{}],350:[function(require,module,exports){
"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var _domready=require("domready"),_domready2=_interopRequireDefault(_domready),_live=require("../../live"),_live2=_interopRequireDefault(_live),_spotifyEvents=require("../../spotify-events"),_spotifyEvents2=_interopRequireDefault(_spotifyEvents),_center=require("../../spotify-events/center"),_center2=_interopRequireDefault(_center),_sort=require("../../spotify-events/sort"),_sort2=_interopRequireDefault(_sort),_selection=require("../../spotify-events/selection"),_selection2=_interopRequireDefault(_selection),_localStorage=require("../../local-storage"),_localStorage2=_interopRequireDefault(_localStorage),_player=require("../../../libs/live-models/player"),_player2=_interopRequireDefault(_player),_application=require("../../../libs/live-models/application"),_application2=_interopRequireDefault(_application),_client=require("../../../libs/live-models/client"),_client2=_interopRequireDefault(_client),_add=require("../../../libs/live-models/add"),_add2=_interopRequireDefault(_add),_controller=require("./controller"),_controller2=_interopRequireDefault(_controller),_createRowElement=require("./create-row-element"),_createRowElement2=_interopRequireDefault(_createRowElement),_domFacade=require("./dom-facade"),_domFacade2=_interopRequireDefault(_domFacade),_sortMap=require("./sort-map"),sortMap=_interopRequireWildcard(_sortMap);function _interopRequireWildcard(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&(t[r]=e[r]);return t.default=e,t}function _interopRequireDefault(e){return e&&e.__esModule?e:{default:e}}const tardy=require("../../tardy").default;_player2.default.register(),_application2.default.register(),_client2.default.register(),_add2.default.register();const storageWrap={get:function(e,t){try{t(null,_localStorage2.default.get(e))}catch(e){t(e)}},set:_localStorage2.default.set},wrapper=function(e){const t=Object.assign(e,{live:_live2.default,createRowElement:(0,_createRowElement2.default)(window),domReady:_domready2.default,center:_center2.default,events:_spotifyEvents2.default,eventsSort:_sort2.default,eventsSelection:_selection2.default,domFacade:(0,_domFacade2.default)(window),getSongsDataRange:tardy(e.getSongsDataRange),removeDataRow:e.removeDataRow,confirmRemoveDataRows:e.confirmRemoveDataRows,storage:storageWrap,sortMap:sortMap});return _controller2.default.list(t)};exports.default=wrapper;

},{"../../../libs/live-models/add":164,"../../../libs/live-models/application":171,"../../../libs/live-models/client":172,"../../../libs/live-models/player":177,"../../live":192,"../../local-storage":197,"../../spotify-events":286,"../../spotify-events/center":246,"../../spotify-events/selection":306,"../../spotify-events/sort":311,"../../tardy":345,"./controller":347,"./create-row-element":348,"./dom-facade":349,"./sort-map":351,"domready":362}],351:[function(require,module,exports){
"use strict";function liveToCore(r){const o=r.match(/^track\((\w+)/);return o?o[1]:r.split(",").shift()}function coreToLive(r){return{name:"track(name)",artists:"track(artists[0:1](name),album(name),disc,number)",album:"track(album(name),disc,number)",duration:"track(duration)"}[r]||r}function jsonToCore(r){return!!(r&&r.sorting&&r.sorting[0]&&r.sorting[0][0]&&r.sorting[0][1])&&{property:r.sorting[0][0],order:r.sorting[0][1]}}Object.defineProperty(exports,"__esModule",{value:!0}),exports.liveToCore=liveToCore,exports.coreToLive=coreToLive,exports.jsonToCore=jsonToCore;

},{}],352:[function(require,module,exports){
(function (Buffer){
/* jshint browserify: true */

/**
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  "License"); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 *
 */

'use strict';

/**
 * Shim entry point used when `avro` is `require`d from browserify.
 *
 * It doesn't expose any of the filesystem methods and patches a few others.
 *
 */

var Tap = require('../../lib/utils').Tap,
    schemas = require('../../lib/schemas'),
    deprecated = require('../deprecated/validator');


function parse(schema, opts) {
  var obj;
  if (typeof schema == 'string') {
    try {
      obj = JSON.parse(schema);
    } catch (err) {
      // Pass. No file reading from the browser.
    }
  }
  if (obj === undefined) {
    obj = schema;
  }
  return schemas.createType(obj, opts);
}

// No utf8 and binary functions on browserify's `Buffer`, we must patch in the
// generic slice and write equivalents.

Tap.prototype.readString = function () {
  var len = this.readLong();
  var pos = this.pos;
  var buf = this.buf;
  this.pos += len;
  if (this.pos > buf.length) {
    return;
  }
  return this.buf.slice(pos, pos + len).toString();
};

Tap.prototype.writeString = function (s) {
  var len = Buffer.byteLength(s);
  this.writeLong(len);
  var pos = this.pos;
  this.pos += len;
  if (this.pos > this.buf.length) {
    return;
  }
  this.buf.write(s, pos);
};

Tap.prototype.writeBinary = function (s, len) {
  var pos = this.pos;
  this.pos += len;
  if (this.pos > this.buf.length) {
    return;
  }
  this.buf.write(s, pos, len, 'binary');
};


module.exports = {
  parse: parse,
  types: schemas.types,
  Validator: deprecated.Validator,
  ProtocolValidator: deprecated.ProtocolValidator
};

}).call(this,require("buffer").Buffer)
},{"../../lib/schemas":355,"../../lib/utils":356,"../deprecated/validator":354,"buffer":359}],353:[function(require,module,exports){
/* jshint browserify: true */

/**
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  "License"); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 *
 */

'use strict';

/**
 * Shim to disable schema fingerprint computation.
 *
 */

function createHash() {
  throw new Error('fingerprinting not supported in the browser');
}


module.exports = {
  createHash: createHash
};

},{}],354:[function(require,module,exports){
// Licensed to the Apache Software Foundation (ASF) under one or more
// contributor license agreements.  See the NOTICE file distributed with
// this work for additional information regarding copyright ownership.
// The ASF licenses this file to You under the Apache License, Version 2.0
// (the "License"); you may not use this file except in compliance with
// the License.  You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

var _ = require("underscore"),
    util = require('util');

var WARNING = 'Validator API is deprecated. Please use the type API instead.';
Validator = util.deprecate(Validator, WARNING);
ProtocolValidator = util.deprecate(ProtocolValidator, WARNING);

var AvroSpec = {
  PrimitiveTypes: ['null', 'boolean', 'int', 'long', 'float', 'double', 'bytes', 'string'],
  ComplexTypes: ['record', 'enum', 'array', 'map', 'union', 'fixed']
};
AvroSpec.Types = AvroSpec.PrimitiveTypes.concat(AvroSpec.ComplexTypes);

var InvalidSchemaError = function(msg) { return new Error('InvalidSchemaError: ' + msg); };
var InvalidProtocolError = function(msg) { return new Error('InvalidProtocolError: ' + msg); };
var ValidationError = function(msg) { return new Error('ValidationError: ' + msg); };
var ProtocolValidationError = function(msg) { return new Error('ProtocolValidationError: ' + msg); };


function Record(name, namespace, fields) {
  function validateArgs(name, namespace, fields) {
    if (!_.isString(name)) {
      throw new InvalidSchemaError('Record name must be string');
    }

    if (!_.isNull(namespace) && !_.isUndefined(namespace) && !_.isString(namespace)) {
      throw new InvalidSchemaError('Record namespace must be string or null');
    }

    if (!_.isArray(fields)) {
      throw new InvalidSchemaError('Record name must be string');
    }
  }

  validateArgs(name, namespace, fields);

  this.name = name;
  this.namespace = namespace;
  this.fields = fields;
}

function makeFullyQualifiedTypeName(schema, namespace) {
  var typeName = null;
  if (_.isString(schema)) {
    typeName = schema;
  } else if (_.isObject(schema)) {
    if (_.isString(schema.namespace)) {
      namespace = schema.namespace;
    }
    if (_.isString(schema.name)) {
      typeName = schema.name;
    } else if (_.isString(schema.type)) {
      typeName = schema.type;
    }
  } else {
    throw new InvalidSchemaError('unable to determine fully qualified type name from schema ' + JSON.stringify(schema) + ' in namespace ' + namespace);
  }

  if (!_.isString(typeName)) {
    throw new InvalidSchemaError('unable to determine type name from schema ' + JSON.stringify(schema) + ' in namespace ' + namespace);
  }

  if (typeName.indexOf('.') !== -1) {
    return typeName;
  } else if (_.contains(AvroSpec.PrimitiveTypes, typeName)) {
    return typeName;
  } else if (_.isString(namespace)) {
    return namespace + '.' + typeName;
  } else {
    return typeName;
  }
}

function Union(typeSchemas, namespace) {
  this.branchNames = function() {
    return _.map(typeSchemas, function(typeSchema) { return makeFullyQualifiedTypeName(typeSchema, namespace); });
  };

  function validateArgs(typeSchemas) {
    if (!_.isArray(typeSchemas) || _.isEmpty(typeSchemas)) {
      throw new InvalidSchemaError('Union must have at least 1 branch');
    }
  }

  validateArgs(typeSchemas);

  this.typeSchemas = typeSchemas;
  this.namespace = namespace;
}

function Enum(symbols) {

  function validateArgs(symbols) {
    if (!_.isArray(symbols)) {
      throw new InvalidSchemaError('Enum must have array of symbols, got ' + JSON.stringify(symbols));
    }
    if (!_.all(symbols, function(symbol) { return _.isString(symbol); })) {
      throw new InvalidSchemaError('Enum symbols must be strings, got ' + JSON.stringify(symbols));
    }
  }

  validateArgs(symbols);

  this.symbols = symbols;
}

function AvroArray(itemSchema) {

  function validateArgs(itemSchema) {
    if (_.isNull(itemSchema) || _.isUndefined(itemSchema)) {
      throw new InvalidSchemaError('Array "items" schema should not be null or undefined');
    }
  }

  validateArgs(itemSchema);

  this.itemSchema = itemSchema;
}

function Map(valueSchema) {

  function validateArgs(valueSchema) {
    if (_.isNull(valueSchema) || _.isUndefined(valueSchema)) {
      throw new InvalidSchemaError('Map "values" schema should not be null or undefined');
    }
  }

  validateArgs(valueSchema);

  this.valueSchema = valueSchema;
}

function Field(name, schema) {
  function validateArgs(name, schema) {
    if (!_.isString(name)) {
      throw new InvalidSchemaError('Field name must be string');
    }
  }

  this.name = name;
  this.schema = schema;
}

function Primitive(type) {
  function validateArgs(type) {
    if (!_.isString(type)) {
      throw new InvalidSchemaError('Primitive type name must be a string');
    }

    if (!_.contains(AvroSpec.PrimitiveTypes, type)) {
      throw new InvalidSchemaError('Primitive type must be one of: ' + JSON.stringify(AvroSpec.PrimitiveTypes) + '; got ' + type);
    }
  }

  validateArgs(type);

  this.type = type;
}

function Validator(schema, namespace, namedTypes) {
  this.validate = function(obj) {
    return _validate(this.schema, obj);
  };

  var _validate = function(schema, obj) {
    if (schema instanceof Record) {
      return _validateRecord(schema, obj);
    } else if (schema instanceof Union) {
      return _validateUnion(schema, obj);
    } else if (schema instanceof Enum) {
      return _validateEnum(schema, obj);
    } else if (schema instanceof AvroArray) {
      return _validateArray(schema, obj);
    } else if (schema instanceof Map) {
      return _validateMap(schema, obj);
    } else if (schema instanceof Primitive) {
      return _validatePrimitive(schema, obj);
    } else {
      throw new InvalidSchemaError('validation not yet implemented: ' + JSON.stringify(schema));
    }
  };

  var _validateRecord = function(schema, obj) {
    if (!_.isObject(obj) || _.isArray(obj)) {
      throw new ValidationError('Expected record Javascript type to be non-array object, got ' + JSON.stringify(obj));
    }

    var schemaFieldNames = _.pluck(schema.fields, 'name').sort();
    var objFieldNames = _.keys(obj).sort();
    if (!_.isEqual(schemaFieldNames, objFieldNames)) {
      throw new ValidationError('Expected record fields ' + JSON.stringify(schemaFieldNames) + '; got ' + JSON.stringify(objFieldNames));
    }

    return _.all(schema.fields, function(field) {
      return _validate(field.schema, obj[field.name]);
    });
  };

  var _validateUnion = function(schema, obj) {
    if (_.isObject(obj)) {
      if (_.isArray(obj)) {
        throw new ValidationError('Expected union Javascript type to be non-array object (or null), got ' + JSON.stringify(obj));
      } else if (_.size(obj) !== 1) {
        throw new ValidationError('Expected union Javascript object to be object with exactly 1 key (or null), got ' + JSON.stringify(obj));
      } else {
        var unionBranch = _.keys(obj)[0];
        if (unionBranch === "") {
          throw new ValidationError('Expected union Javascript object to contain non-empty string branch, got ' + JSON.stringify(obj));
        }
        if (_.contains(schema.branchNames(), unionBranch)) {
          return true;
        } else {
          throw new ValidationError('Expected union branch to be one of ' + JSON.stringify(schema.branchNames()) + '; got ' + JSON.stringify(unionBranch));
        }
      }
    } else if (_.isNull(obj)) {
      if (_.contains(schema.branchNames(), 'null')) {
        return true;
      } else {
        throw new ValidationError('Expected union branch to be one of ' + JSON.stringify(schema.branchNames()) + '; got ' + JSON.stringify(obj));
      }
    } else {
      throw new ValidationError('Expected union Javascript object to be non-array object of size 1 or null, got ' + JSON.stringify(obj));
    }
  };

  var _validateEnum = function(schema, obj) {
    if (_.isString(obj)) {
      if (_.contains(schema.symbols, obj)) {
        return true;
      } else {
        throw new ValidationError('Expected enum value to be one of ' + JSON.stringify(schema.symbols) + '; got ' + JSON.stringify(obj));
      }
    } else {
      throw new ValidationError('Expected enum Javascript object to be string, got ' + JSON.stringify(obj));
    }
  };

  var _validateArray = function(schema, obj) {
    if (_.isArray(obj)) {
      return _.all(obj, function(member) { return _validate(schema.itemSchema, member); });
    } else {
      throw new ValidationError('Expected array Javascript object to be array, got ' + JSON.stringify(obj));
    }
  };

  var _validateMap = function(schema, obj) {
    if (_.isObject(obj) && !_.isArray(obj)) {
      return _.all(obj, function(value) { return _validate(schema.valueSchema, value); });
    } else if (_.isArray(obj)) {
      throw new ValidationError('Expected map Javascript object to be non-array object, got array ' + JSON.stringify(obj));
    } else {
      throw new ValidationError('Expected map Javascript object to be non-array object, got ' + JSON.stringify(obj));
    }
  };

  var _validatePrimitive = function(schema, obj) {
    switch (schema.type) {
      case 'null':
        if (_.isNull(obj) || _.isUndefined(obj)) {
          return true;
        } else {
          throw new ValidationError('Expected Javascript null or undefined for Avro null, got ' + JSON.stringify(obj));
        }
        break;
      case 'boolean':
        if (_.isBoolean(obj)) {
          return true;
        } else {
          throw new ValidationError('Expected Javascript boolean for Avro boolean, got ' + JSON.stringify(obj));
        }
        break;
      case 'int':
        if (_.isNumber(obj) && Math.floor(obj) === obj && Math.abs(obj) <= Math.pow(2, 31)) {
          return true;
        } else {
          throw new ValidationError('Expected Javascript int32 number for Avro int, got ' + JSON.stringify(obj));
        }
        break;
      case 'long':
        if (_.isNumber(obj) && Math.floor(obj) === obj && Math.abs(obj) <= Math.pow(2, 63)) {
          return true;
        } else {
          throw new ValidationError('Expected Javascript int64 number for Avro long, got ' + JSON.stringify(obj));
        }
        break;
      case 'float':
        if (_.isNumber(obj)) { // TODO: handle NaN?
          return true;
        } else {
          throw new ValidationError('Expected Javascript float number for Avro float, got ' + JSON.stringify(obj));
        }
        break;
      case 'double':
        if (_.isNumber(obj)) { // TODO: handle NaN?
          return true;
        } else {
          throw new ValidationError('Expected Javascript double number for Avro double, got ' + JSON.stringify(obj));
        }
        break;
      case 'bytes':
        throw new InvalidSchemaError('not yet implemented: ' + schema.type);
      case 'string':
        if (_.isString(obj)) { // TODO: handle NaN?
          return true;
        } else {
          throw new ValidationError('Expected Javascript string for Avro string, got ' + JSON.stringify(obj));
        }
        break;
      default:
        throw new InvalidSchemaError('unrecognized primitive type: ' + schema.type);
    }
  };

  // TODO: namespace handling is rudimentary. multiple namespaces within a certain nested schema definition
  // are probably buggy.
  var _namedTypes = namedTypes || {};
  var _saveNamedType = function(fullyQualifiedTypeName, schema) {
    if (_.has(_namedTypes, fullyQualifiedTypeName)) {
      if (!_.isEqual(_namedTypes[fullyQualifiedTypeName], schema)) {
        throw new InvalidSchemaError('conflicting definitions for type ' + fullyQualifiedTypeName + ': ' + JSON.stringify(_namedTypes[fullyQualifiedTypeName]) + ' and ' + JSON.stringify(schema));
      }
    } else {
      _namedTypes[fullyQualifiedTypeName] = schema;
    }
  };

  var _lookupTypeByFullyQualifiedName = function(fullyQualifiedTypeName) {
    if (_.has(_namedTypes, fullyQualifiedTypeName)) {
      return _namedTypes[fullyQualifiedTypeName];
    } else {
      return null;
    }
  };

  var _parseNamedType = function(schema, namespace) {
    if (_.contains(AvroSpec.PrimitiveTypes, schema)) {
      return new Primitive(schema);
    } else if (!_.isNull(_lookupTypeByFullyQualifiedName(makeFullyQualifiedTypeName(schema, namespace)))) {
      return _lookupTypeByFullyQualifiedName(makeFullyQualifiedTypeName(schema, namespace));
    } else {
      throw new InvalidSchemaError('unknown type name: ' + JSON.stringify(schema) + '; known type names are ' + JSON.stringify(_.keys(_namedTypes)));
    }
  };

  var _parseSchema = function(schema, parentSchema, namespace) {
    if (_.isNull(schema) || _.isUndefined(schema)) {
      throw new InvalidSchemaError('schema is null, in parentSchema: ' + JSON.stringify(parentSchema));
    } else if (_.isString(schema)) {
      return _parseNamedType(schema, namespace);
    } else if (_.isObject(schema) && !_.isArray(schema)) {
      if (schema.type === 'record') {
        var newRecord = new Record(schema.name, schema.namespace, _.map(schema.fields, function(field) {
          return new Field(field.name, _parseSchema(field.type, schema, schema.namespace || namespace));
        }));
        _saveNamedType(makeFullyQualifiedTypeName(schema, namespace), newRecord);
        return newRecord;
      } else if (schema.type === 'enum') {
        if (_.has(schema, 'symbols')) {
          var newEnum = new Enum(schema.symbols);
          _saveNamedType(makeFullyQualifiedTypeName(schema, namespace), newEnum);
          return newEnum;
        } else {
          throw new InvalidSchemaError('enum must specify symbols, got ' + JSON.stringify(schema));
        }
      } else if (schema.type === 'array') {
        if (_.has(schema, 'items')) {
          return new AvroArray(_parseSchema(schema.items, schema, namespace));
        } else {
          throw new InvalidSchemaError('array must specify "items" schema, got ' + JSON.stringify(schema));
        }
      } else if (schema.type === 'map') {
        if (_.has(schema, 'values')) {
          return new Map(_parseSchema(schema.values, schema, namespace));
        } else {
          throw new InvalidSchemaError('map must specify "values" schema, got ' + JSON.stringify(schema));
        }
      } else if (_.has(schema, 'type') && _.contains(AvroSpec.PrimitiveTypes, schema.type)) {
        return _parseNamedType(schema.type, namespace);
      } else {
        throw new InvalidSchemaError('not yet implemented: ' + schema.type);
      }
    } else if (_.isArray(schema)) {
      if (_.isEmpty(schema)) {
        throw new InvalidSchemaError('unions must have at least 1 branch');
      }
      var branchTypes = _.map(schema, function(branchType) { return _parseSchema(branchType, schema, namespace); });
      return new Union(branchTypes, namespace);
    } else {
      throw new InvalidSchemaError('unexpected Javascript type for schema: ' + (typeof schema));
    }
  };

  this.rawSchema = schema;
  this.schema = _parseSchema(schema, null, namespace);
}

Validator.validate = function(schema, obj) {
  return (new Validator(schema)).validate(obj);
}

function ProtocolValidator(protocol) {
  this.validate = function(typeName, obj) {
    var fullyQualifiedTypeName = makeFullyQualifiedTypeName(typeName, protocol.namespace);
    if (!_.has(_typeSchemaValidators, fullyQualifiedTypeName)) {
      throw new ProtocolValidationError('Protocol does not contain definition for type ' + JSON.stringify(fullyQualifiedTypeName) + ' (fully qualified from input "' + typeName + '"); known types are ' + JSON.stringify(_.keys(_typeSchemaValidators)));
    }
    return _typeSchemaValidators[fullyQualifiedTypeName].validate(obj);
  };

  var _typeSchemaValidators = {};
  var _initSchemaValidators = function(protocol) {
    var namedTypes = {};
    if (!_.has(protocol, 'protocol') || !_.isString(protocol.protocol)) {
      throw new InvalidProtocolError('Protocol must contain a "protocol" attribute with a string value');
    }
    if (_.isArray(protocol.types)) {
      _.each(protocol.types, function(typeSchema) {
        var schemaValidator = new Validator(typeSchema, protocol.namespace, namedTypes);
        var fullyQualifiedTypeName = makeFullyQualifiedTypeName(typeSchema, protocol.namespace);
        _typeSchemaValidators[fullyQualifiedTypeName] = schemaValidator;
      });
    }
  };

  _initSchemaValidators(protocol);
}

ProtocolValidator.validate = function(protocol, typeName, obj) {
  return (new ProtocolValidator(protocol)).validate(typeName, obj);
};

if (typeof exports !== 'undefined') {
  exports['Validator'] = Validator;
  exports['ProtocolValidator'] = ProtocolValidator;
}

},{"underscore":476,"util":479}],355:[function(require,module,exports){
(function (Buffer){
/* jshint node: true */

/**
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  "License"); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 *
 */

'use strict';

var utils = require('./utils'),
    buffer = require('buffer'), // For `SlowBuffer`.
    util = require('util');

// Convenience imports.
var Tap = utils.Tap;
var f = util.format;

// All Avro types.
var TYPES = {
  'array': ArrayType,
  'boolean': BooleanType,
  'bytes': BytesType,
  'double': DoubleType,
  'enum': EnumType,
  'error': RecordType,
  'fixed': FixedType,
  'float': FloatType,
  'int': IntType,
  'long': LongType,
  'map': MapType,
  'null': NullType,
  'record': RecordType,
  'request': RecordType,
  'string': StringType,
  'union': UnionType
};

// Valid (field, type, and symbol) name regex.
var NAME_PATTERN = /^[A-Za-z_][A-Za-z0-9_]*$/;

// Random generator.
var RANDOM = new utils.Lcg();

// Encoding tap (shared for performance).
var TAP = new Tap(new buffer.SlowBuffer(1024));

// Path prefix for validity checks (shared for performance).
var PATH = [];

// Currently active logical type, used for name redirection.
var LOGICAL_TYPE = null;


/**
 * Schema parsing entry point.
 *
 * It isn't exposed directly but called from `parse` inside `index.js` (node)
 * or `avro.js` (browserify) which each add convenience functionality.
 *
 */
function createType(attrs, opts) {
  if (attrs instanceof Type) {
    return attrs;
  }

  opts = getOpts(attrs, opts);

  var type;
  if (typeof attrs == 'string') { // Type reference.
    if (opts.namespace && !~attrs.indexOf('.') && !isPrimitive(attrs)) {
      attrs = opts.namespace + '.' + attrs;
    }
    type = opts.registry[attrs];
    if (type) {
      // Type was already defined, return it.
      return type;
    }
    if (isPrimitive(attrs)) {
      // Reference to a primitive type. These are also defined names by default
      // so we create the appropriate type and it to the registry for future
      // reference.
      return opts.registry[attrs] = createType({type: attrs}, opts);
    }
    throw new Error(f('undefined type name: %s', attrs));
  }

  if (opts.typeHook && (type = opts.typeHook(attrs, opts))) {
    if (!(type instanceof Type)) {
      throw new Error(f('invalid typehook return value: %j', type));
    }
    return type;
  }

  if (attrs.logicalType && !LOGICAL_TYPE) {
    var DerivedType = opts.logicalTypes[attrs.logicalType];
    if (DerivedType) {
      var registry = {};
      Object.keys(opts.registry).forEach(function (key) {
        registry[key] = opts.registry[key];
      });
      try {
        return new DerivedType(attrs, opts);
      } catch (err) {
        if (opts.assertLogicalTypes) {
          throw err;
        }
        LOGICAL_TYPE = null;
        opts.registry = registry; // In case any names were registered.
      }
    }
  }

  if (attrs instanceof Array) { // Union.
    type = new UnionType(attrs, opts);
  } else { // New type definition.
    type = (function (typeName) {
      var Type = TYPES[typeName];
      if (Type === undefined) {
        throw new Error(f('unknown type: %j', typeName));
      }
      return new Type(attrs, opts);
    })(attrs.type);
  }
  return type;
}

/**
 * "Abstract" base Avro type class.
 *
 * This class' constructor will register any named types to support
 * recursive schemas.
 *
 * All type values are represented in memory similarly to their JSON
 * representation, except for `bytes` and `fixed` which are represented as
 * `Buffer`s. See individual subclasses for details.
 *
 */
function Type(registry) {
  var name = this._name;
  var type = LOGICAL_TYPE || this;
  LOGICAL_TYPE = null;

  if (registry === undefined || name === undefined) {
    return;
  }

  var prev = registry[name];
  if (prev !== undefined) {
    throw new Error(f('duplicate type name: %s', name));
  }
  registry[name] = type;
}

Type.__reset = function (size) { TAP.buf = new buffer.SlowBuffer(size); };

Type.prototype.createResolver = function (type, opts) {
  if (!(type instanceof Type)) {
    // More explicit error message than the "incompatible type" thrown
    // otherwise (especially because of the overridden `toJSON` method).
    throw new Error(f('not a type: %j', type));
  }

  if (type instanceof LogicalType && !(this instanceof LogicalType)) {
    // Trying to read a logical type as a built-in: unwrap the logical type.
    return this.createResolver(type._underlyingType, opts);
  }

  opts = opts || {};
  opts.registry = opts.registry || {};

  var resolver, key;
  if (this instanceof RecordType && type instanceof RecordType) {
    key = this._name + ':' + type._name; // ':' is illegal in Avro type names.
    resolver = opts.registry[key];
    if (resolver) {
      return resolver;
    }
  }

  resolver = new Resolver(this);
  if (key) { // Register resolver early for recursive schemas.
    opts.registry[key] = resolver;
  }

  if (type instanceof UnionType) {
    var resolvers = type._types.map(function (t) {
      return this.createResolver(t, opts);
    }, this);
    resolver._read = function (tap) {
      var index = tap.readLong();
      var resolver = resolvers[index];
      if (resolver === undefined) {
        throw new Error(f('invalid union index: %s', index));
      }
      return resolvers[index]._read(tap);
    };
  } else {
    this._updateResolver(resolver, type, opts);
  }

  if (!resolver._read) {
    throw new Error(f('cannot read %s as %s', type, this));
  }
  return resolver;
};

Type.prototype.decode = function (buf, pos, resolver) {
  var tap = new Tap(buf);
  tap.pos = pos | 0;
  var val = readValue(this, tap, resolver);
  if (!tap.isValid()) {
    return {value: undefined, offset: -1};
  }
  return {value: val, offset: tap.pos};
};

Type.prototype.encode = function (val, buf, pos) {
  var tap = new Tap(buf);
  tap.pos = pos | 0;
  this._write(tap, val);
  if (!tap.isValid()) {
    // Don't throw as there is no way to predict this. We also return the
    // number of missing bytes to ease resizing.
    return buf.length - tap.pos;
  }
  return tap.pos;
};

Type.prototype.fromBuffer = function (buf, resolver, noCheck) {
  var tap = new Tap(buf);
  var val = readValue(this, tap, resolver, noCheck);
  if (!tap.isValid()) {
    throw new Error('truncated buffer');
  }
  if (!noCheck && tap.pos < buf.length) {
    throw new Error('trailing data');
  }
  return val;
};

Type.prototype.toBuffer = function (val) {
  TAP.pos = 0;
  this._write(TAP, val);
  if (!TAP.isValid()) {
    Type.__reset(2 * TAP.pos);
    TAP.pos = 0;
    this._write(TAP, val);
  }
  var buf = new Buffer(TAP.pos);
  TAP.buf.copy(buf, 0, 0, TAP.pos);
  return buf;
};

Type.prototype.fromString = function (str) {
  return this._copy(JSON.parse(str), {coerce: 2});
};

Type.prototype.toString = function (val) {
  if (val === undefined) {
    // Consistent behavior with standard `toString` expectations.
    return this.getSchema(true);
  }
  return JSON.stringify(this._copy(val, {coerce: 3}));
};

Type.prototype.clone = function (val, opts) {
  if (opts) {
    opts = {
      coerce: !!opts.coerceBuffers | 0, // Coerce JSON to Buffer.
      fieldHook: opts.fieldHook,
      wrap: !!opts.wrapUnions | 0 // Wrap first match into union.
    };
  }
  return this._copy(val, opts);
};

Type.prototype.isValid = function (val, opts) {
  while (PATH.length) {
    // In case the previous `isValid` call didn't complete successfully (e.g.
    // if an exception was thrown, but then caught in client code), `PATH`
    // might be non-empty, we must manually clear it.
    PATH.pop();
  }
  return this._check(val, opts && opts.errorHook);
};

Type.prototype.compareBuffers = function (buf1, buf2) {
  return this._match(new Tap(buf1), new Tap(buf2));
};

Type.prototype.getName = function (noRef) {
  return noRef ? getTypeName(this) : this._name;
};

Type.prototype.getSchema = function (noDeref) {
  return stringify(this, noDeref);
};

Type.prototype.getFingerprint = function (algorithm) {
  return utils.getHash(this.getSchema(), algorithm);
};

Type.prototype.inspect = function () {
  if (this instanceof PrimitiveType) {
    return f('<%s>', this.constructor.name);
  } else {
    var obj = JSON.parse(this.getSchema(true)); // Slow, only for debugging.
    if (typeof obj == 'object') {
      obj.type = undefined; // Would be redundant with constructor name.
    }
    return f('<%s %j>', this.constructor.name, obj);
  }
};

Type.prototype._check = utils.abstractFunction;
Type.prototype._copy = utils.abstractFunction;
Type.prototype._match = utils.abstractFunction;
Type.prototype._read = utils.abstractFunction;
Type.prototype._skip = utils.abstractFunction;
Type.prototype._updateResolver = utils.abstractFunction;
Type.prototype._write = utils.abstractFunction;
Type.prototype.compare = utils.abstractFunction;
Type.prototype.random = utils.abstractFunction;

// Implementations.

/**
 * Base primitive Avro type.
 *
 * Most of the primitive types share the same cloning and resolution
 * mechanisms, provided by this class. This class also lets us conveniently
 * check whether a type is a primitive using `instanceof`.
 *
 */
function PrimitiveType() { Type.call(this); }
util.inherits(PrimitiveType, Type);
PrimitiveType.prototype._updateResolver = function (resolver, type) {
  if (type.constructor === this.constructor) {
    resolver._read = this._read;
  }
};
PrimitiveType.prototype._copy = function (val) {
  this._check(val, throwInvalidError);
  return val;
};
PrimitiveType.prototype.compare = utils.compare;

/**
 * Nulls.
 *
 */
function NullType() { PrimitiveType.call(this); }
util.inherits(NullType, PrimitiveType);
NullType.prototype._check = function (val, cb) {
  var b = val === null;
  if (!b && cb) {
    cb(PATH.slice(), val, this);
  }
  return b;
};
NullType.prototype._read = function () { return null; };
NullType.prototype._skip = function () {};
NullType.prototype._write = function (tap, val) {
  if (val !== null) {
    throwInvalidError(null, val, this);
  }
};
NullType.prototype._match = function () { return 0; };
NullType.prototype.compare = NullType.prototype._match;
NullType.prototype.random = NullType.prototype._read;
NullType.prototype.toJSON = function () { return 'null'; };

/**
 * Booleans.
 *
 */
function BooleanType() { PrimitiveType.call(this); }
util.inherits(BooleanType, PrimitiveType);
BooleanType.prototype._check = function (val, cb) {
  var b = typeof val == 'boolean';
  if (!b && cb) {
    cb(PATH.slice(), val, this);
  }
  return b;
};
BooleanType.prototype._read = function (tap) { return tap.readBoolean(); };
BooleanType.prototype._skip = function (tap) { tap.skipBoolean(); };
BooleanType.prototype._write = function (tap, val) {
  if (typeof val != 'boolean') {
    throwInvalidError(null, val, this);
  }
  tap.writeBoolean(val);
};
BooleanType.prototype._match = function (tap1, tap2) {
  return tap1.matchBoolean(tap2);
};
BooleanType.prototype.random = function () { return RANDOM.nextBoolean(); };
BooleanType.prototype.toJSON = function () { return 'boolean'; };

/**
 * Integers.
 *
 */
function IntType() { PrimitiveType.call(this); }
util.inherits(IntType, PrimitiveType);
IntType.prototype._check = function (val, cb) {
  var b = val === (val | 0);
  if (!b && cb) {
    cb(PATH.slice(), val, this);
  }
  return b;
};
IntType.prototype._read = function (tap) { return tap.readInt(); };
IntType.prototype._skip = function (tap) { tap.skipInt(); };
IntType.prototype._write = function (tap, val) {
  if (val !== (val | 0)) {
    throwInvalidError(null, val, this);
  }
  tap.writeInt(val);
};
IntType.prototype._match = function (tap1, tap2) {
  return tap1.matchInt(tap2);
};
IntType.prototype.random = function () { return RANDOM.nextInt(1000) | 0; };
IntType.prototype.toJSON = function () { return 'int'; };

/**
 * Longs.
 *
 * We can't capture all the range unfortunately since JavaScript represents all
 * numbers internally as `double`s, so the default implementation plays safe
 * and throws rather than potentially silently change the data. See `using` or
 * `AbstractLongType` below for a way to implement a custom long type.
 *
 */
function LongType() { PrimitiveType.call(this); }
util.inherits(LongType, PrimitiveType);
LongType.prototype._check = function (val, cb) {
  var b = typeof val == 'number' && val % 1 === 0 && isSafeLong(val);
  if (!b && cb) {
    cb(PATH.slice(), val, this);
  }
  return b;
};
LongType.prototype._read = function (tap) {
  var n = tap.readLong();
  if (!isSafeLong(n)) {
    throw new Error('potential precision loss');
  }
  return n;
};
LongType.prototype._skip = function (tap) { tap.skipLong(); };
LongType.prototype._write = function (tap, val) {
  if (typeof val != 'number' || val % 1 || !isSafeLong(val)) {
    throwInvalidError(null, val, this);
  }
  tap.writeLong(val);
};
LongType.prototype._match = function (tap1, tap2) {
  return tap1.matchLong(tap2);
};
LongType.prototype._updateResolver = function (resolver, type) {
  if (type instanceof LongType || type instanceof IntType) {
    resolver._read = type._read;
  }
};
LongType.prototype.random = function () { return RANDOM.nextInt(); };
LongType.prototype.toJSON = function () { return 'long'; };
LongType.using = function (methods, noUnpack) {
  methods = methods || {}; // Will give a more helpful error message.
  // We map some of the methods to a different name to be able to intercept
  // their input and output (otherwise we wouldn't be able to perform any
  // unpacking logic, and the type wouldn't work when nested).
  var mapping = {
    toBuffer: '_toBuffer',
    fromBuffer: '_fromBuffer',
    fromJSON: '_fromJSON',
    toJSON: '_toJSON',
    isValid: '_isValid',
    compare: 'compare'
  };
  var type = new AbstractLongType(noUnpack);
  Object.keys(mapping).forEach(function (name) {
    if (methods[name] === undefined) {
      throw new Error(f('missing method implementation: %s', name));
    }
    type[mapping[name]] = methods[name];
  });
  return type;
};

/**
 * Floats.
 *
 */
function FloatType() { PrimitiveType.call(this); }
util.inherits(FloatType, PrimitiveType);
FloatType.prototype._check = function (val, cb) {
  var b = typeof val == 'number';
  if (!b && cb) {
    cb(PATH.slice(), val, this);
  }
  return b;
};
FloatType.prototype._read = function (tap) { return tap.readFloat(); };
FloatType.prototype._skip = function (tap) { tap.skipFloat(); };
FloatType.prototype._write = function (tap, val) {
  if (typeof val != 'number') {
    throwInvalidError(null, val, this);
  }
  tap.writeFloat(val);
};
FloatType.prototype._match = function (tap1, tap2) {
  return tap1.matchFloat(tap2);
};
FloatType.prototype._updateResolver = function (resolver, type) {
  if (
    type instanceof FloatType ||
    type instanceof LongType ||
    type instanceof IntType
  ) {
    resolver._read = type._read;
  }
};
FloatType.prototype.random = function () { return RANDOM.nextFloat(1e3); };
FloatType.prototype.toJSON = function () { return 'float'; };

/**
 * Doubles.
 *
 */
function DoubleType() { PrimitiveType.call(this); }
util.inherits(DoubleType, PrimitiveType);
DoubleType.prototype._check = function (val, cb) {
  var b = typeof val == 'number';
  if (!b && cb) {
    cb(PATH.slice(), val, this);
  }
  return b;
};
DoubleType.prototype._read = function (tap) { return tap.readDouble(); };
DoubleType.prototype._skip = function (tap) { tap.skipDouble(); };
DoubleType.prototype._write = function (tap, val) {
  if (typeof val != 'number') {
    throwInvalidError(null, val, this);
  }
  tap.writeDouble(val);
};
DoubleType.prototype._match = function (tap1, tap2) {
  return tap1.matchDouble(tap2);
};
DoubleType.prototype._updateResolver = function (resolver, type) {
  if (
    type instanceof DoubleType ||
    type instanceof FloatType ||
    type instanceof LongType ||
    type instanceof IntType
  ) {
    resolver._read = type._read;
  }
};
DoubleType.prototype.random = function () { return RANDOM.nextFloat(); };
DoubleType.prototype.toJSON = function () { return 'double'; };

/**
 * Strings.
 *
 */
function StringType() { PrimitiveType.call(this); }
util.inherits(StringType, PrimitiveType);
StringType.prototype._check = function (val, cb) {
  var b = typeof val == 'string';
  if (!b && cb) {
    cb(PATH.slice(), val, this);
  }
  return b;
};
StringType.prototype._read = function (tap) { return tap.readString(); };
StringType.prototype._skip = function (tap) { tap.skipString(); };
StringType.prototype._write = function (tap, val) {
  if (typeof val != 'string') {
    throwInvalidError(null, val, this);
  }
  tap.writeString(val);
};
StringType.prototype._match = function (tap1, tap2) {
  return tap1.matchString(tap2);
};
StringType.prototype._updateResolver = function (resolver, type) {
  if (type instanceof StringType || type instanceof BytesType) {
    resolver._read = this._read;
  }
};
StringType.prototype.random = function () {
  return RANDOM.nextString(RANDOM.nextInt(32));
};
StringType.prototype.toJSON = function () { return 'string'; };

/**
 * Bytes.
 *
 * These are represented in memory as `Buffer`s rather than binary-encoded
 * strings. This is more efficient (when decoding/encoding from bytes, the
 * common use-case), idiomatic, and convenient.
 *
 * Note the coercion in `_copy`.
 *
 */
function BytesType() { PrimitiveType.call(this); }
util.inherits(BytesType, PrimitiveType);
BytesType.prototype._check = function (val, cb) {
  var b = Buffer.isBuffer(val);
  if (!b && cb) {
    cb(PATH.slice(), val, this);
  }
  return b;
};
BytesType.prototype._read = function (tap) { return tap.readBytes(); };
BytesType.prototype._skip = function (tap) { tap.skipBytes(); };
BytesType.prototype._write = function (tap, val) {
  if (!Buffer.isBuffer(val)) {
    throwInvalidError(null, val, this);
  }
  tap.writeBytes(val);
};
BytesType.prototype._match = function (tap1, tap2) {
  return tap1.matchBytes(tap2);
};
BytesType.prototype._updateResolver = StringType.prototype._updateResolver;
BytesType.prototype._copy = function (obj, opts) {
  var buf;
  switch ((opts && opts.coerce) | 0) {
    case 3: // Coerce buffers to strings.
      this._check(obj, throwInvalidError);
      return obj.toString('binary');
    case 2: // Coerce strings to buffers.
      if (typeof obj != 'string') {
        throw new Error(f('cannot coerce to buffer: %j', obj));
      }
      buf = new Buffer(obj, 'binary');
      this._check(buf, throwInvalidError);
      return buf;
    case 1: // Coerce buffer JSON representation to buffers.
      if (!obj || obj.type !== 'Buffer' || !(obj.data instanceof Array)) {
        throw new Error(f('cannot coerce to buffer: %j', obj));
      }
      buf = new Buffer(obj.data);
      this._check(buf, throwInvalidError);
      return buf;
    default: // Copy buffer.
      this._check(obj, throwInvalidError);
      return new Buffer(obj);
  }
};
BytesType.prototype.compare = Buffer.compare;
BytesType.prototype.random = function () {
  return RANDOM.nextBuffer(RANDOM.nextInt(32));
};
BytesType.prototype.toJSON = function () { return 'bytes'; };

/**
 * Avro unions.
 *
 * Unions are represented in memory similarly to their JSON representation
 * (i.e. inside an object with single key the name of the contained type).
 *
 * This is not ideal, but is the most efficient way to unambiguously support
 * all unions. Here are a few reasons why the wrapping object is necessary:
 *
 * + Unions with multiple number types would have undefined behavior, unless
 *   numbers are wrapped (either everywhere, leading to large performance and
 *   convenience costs; or only when necessary inside unions, making it hard to
 *   understand when numbers are wrapped or not).
 * + Fixed types would have to be wrapped to be distinguished from bytes.
 * + Using record's constructor names would work (after a slight change to use
 *   the fully qualified name), but would mean that generic objects could no
 *   longer be valid records (making it inconvenient to do simple things like
 *   creating new records).
 *
 * Lore: In the past (until d304cab), there used to be an "unwrapped union
 * type" which directly exposed its values, without the wrapping object
 * (similarly to Avro's python implementation). It was removed to keep all
 * representations consistent and make this library simpler to understand
 * (conversions, e.g. for schema evolution, between representations were
 * particularly confusing). Encoding was also much slower (worst case
 * complexity linear in the number of types in the union).
 *
 */
function UnionType(attrs, opts) {
  if (!(attrs instanceof Array)) {
    throw new Error(f('non-array union schema: %j', attrs));
  }
  if (!attrs.length) {
    throw new Error('empty union');
  }

  opts = getOpts(attrs, opts);
  Type.call(this);
  this._types = attrs.map(function (obj) { return createType(obj, opts); });

  this._indices = {};
  this._types.forEach(function (type, i) {
    if (type instanceof UnionType) {
      throw new Error('unions cannot be directly nested');
    }
    var name = type._name || getTypeName(type);
    if (this._indices[name] !== undefined) {
      throw new Error(f('duplicate union name: %j', name));
    }
    this._indices[name] = i;
  }, this);

  this._constructors = this._types.map(function (type) {
    // jshint -W054
    var name = type._name || getTypeName(type);
    if (name === 'null') {
      return null;
    }
    var body;
    if (~name.indexOf('.')) { // Qualified name.
      body = 'this[\'' + name + '\'] = val;';
    } else {
      body = 'this.' + name + ' = val;';
    }
    return new Function('val', body);
  });
}
util.inherits(UnionType, Type);

UnionType.prototype._check = function (val, cb) {
  var b = false;
  if (val === null) {
    // Shortcut type lookup in this case.
    b = this._indices['null'] !== undefined;
  } else if (typeof val == 'object') {
    var keys = Object.keys(val);
    if (keys.length === 1) {
      // We require a single key here to ensure that writes are correct and
      // efficient as soon as a record passes this check.
      var name = keys[0];
      var index = this._indices[name];
      if (index !== undefined) {
        PATH.push(name);
        b = this._types[index]._check(val[name], cb);
        PATH.pop();
        return b;
      }
    }
  }
  if (!b && cb) {
    cb(PATH.slice(), val, this);
  }
  return b;
};

UnionType.prototype._read = function (tap) {
  var index = tap.readLong();
  var Class = this._constructors[index];
  if (Class) {
    return new Class(this._types[index]._read(tap));
  } else if (Class === null) {
    return null;
  } else {
    throw new Error(f('invalid union index: %s', index));
  }
};

UnionType.prototype._skip = function (tap) {
  this._types[tap.readLong()]._skip(tap);
};

UnionType.prototype._write = function (tap, val) {
  var index, keys, name;
  if (val === null) {
    index = this._indices['null'];
    if (index === undefined) {
      throwInvalidError(null, val, this);
    }
    tap.writeLong(index);
  } else {
    keys = Object.keys(val);
    if (keys.length === 1) {
      name = keys[0];
      index = this._indices[name];
    }
    if (index === undefined) {
      throwInvalidError(null, val, this);
    }
    tap.writeLong(index);
    this._types[index]._write(tap, val[name]);
  }
};

UnionType.prototype._match = function (tap1, tap2) {
  var n1 = tap1.readLong();
  var n2 = tap2.readLong();
  if (n1 === n2) {
    return this._types[n1]._match(tap1, tap2);
  } else {
    return n1 < n2 ? -1 : 1;
  }
};

UnionType.prototype._updateResolver = function (resolver, type, opts) {
  // jshint -W083
  // (The loop exits after the first function is created.)
  var i, l, typeResolver, Class;
  for (i = 0, l = this._types.length; i < l; i++) {
    try {
      typeResolver = this._types[i].createResolver(type, opts);
    } catch (err) {
      continue;
    }
    Class = this._constructors[i];
    if (Class) {
      resolver._read = function (tap) {
        return new Class(typeResolver._read(tap));
      };
    } else {
      resolver._read = function () { return null; };
    }
    return;
  }
};

UnionType.prototype._copy = function (val, opts) {
  var wrap = opts && opts.wrap | 0;
  if (wrap === 2) {
    // Promote into first type (used for schema defaults).
    if (val === null && this._constructors[0] === null) {
      return null;
    }
    return new this._constructors[0](this._types[0]._copy(val, opts));
  }
  if (val === null && this._indices['null'] !== undefined) {
    return null;
  }

  var i, l, obj;
  if (typeof val == 'object') {
    var keys = Object.keys(val);
    if (keys.length === 1) {
      var name = keys[0];
      i = this._indices[name];
      if (i === undefined) {
        // We are a bit more flexible than in `_check` here since we have
        // to deal with other serializers being less strict, so we fall
        // back to looking up unqualified names.
        var j, type;
        for (j = 0, l = this._types.length; j < l; j++) {
          type = this._types[j];
          if (type._name && name === unqualify(type._name)) {
            i = j;
            break;
          }
        }
      }
      if (i !== undefined) {
        obj = this._types[i]._copy(val[name], opts);
      }
    }
  }
  if (wrap === 1 && obj === undefined) {
    // Try promoting into first match (convenience, slow).
    i = 0;
    l = this._types.length;
    while (i < l && obj === undefined) {
      try {
        obj = this._types[i]._copy(val, opts);
      } catch (err) {
        i++;
      }
    }
  }
  if (obj !== undefined) {
    return new this._constructors[i](obj);
  }
  throwInvalidError(null, val, this);
};

UnionType.prototype.compare = function (val1, val2) {
  var name1 = val1 === null ? 'null' : Object.keys(val1)[0];
  var name2 = val2 === null ? 'null' : Object.keys(val2)[0];
  var index = this._indices[name1];
  if (name1 === name2) {
    return name1 === 'null' ?
      0 :
      this._types[index].compare(val1[name1], val2[name1]);
  } else {
    return utils.compare(index, this._indices[name2]);
  }
};

UnionType.prototype.getTypes = function () { return this._types.slice(); };

UnionType.prototype.random = function () {
  var index = RANDOM.nextInt(this._types.length);
  var Class = this._constructors[index];
  if (!Class) {
    return null;
  }
  return new Class(this._types[index].random());
};

UnionType.prototype.toJSON = function () { return this._types; };

/**
 * Avro enum type.
 *
 * Represented as strings (with allowed values from the set of symbols). Using
 * integers would be a reasonable option, but the performance boost is arguably
 * offset by the legibility cost and the extra deviation from the JSON encoding
 * convention.
 *
 * An integer representation can still be used (e.g. for compatibility with
 * TypeScript `enum`s) by overriding the `EnumType` with a `LongType` (e.g. via
 * `parse`'s registry).
 *
 */
function EnumType(attrs, opts) {
  if (!(attrs.symbols instanceof Array) || !attrs.symbols.length) {
    throw new Error(f('invalid %j enum symbols: %j', attrs.name, attrs));
  }

  opts = getOpts(attrs, opts);
  var resolutions = resolveNames(attrs, opts.namespace);
  this._name = resolutions.name;
  this._symbols = attrs.symbols;
  this._aliases = resolutions.aliases;
  Type.call(this, opts.registry);

  this._indices = {};
  this._symbols.forEach(function (symbol, i) {
    if (!NAME_PATTERN.test(symbol)) {
      throw new Error(f('invalid %s symbol: %j', this, symbol));
    }
    if (this._indices[symbol] !== undefined) {
      throw new Error(f('duplicate %s symbol: %j', this, symbol));
    }
    this._indices[symbol] = i;
  }, this);
}
util.inherits(EnumType, Type);

EnumType.prototype._check = function (val, cb) {
  var b = this._indices[val] !== undefined;
  if (!b && cb) {
    cb(PATH.slice(), val, this);
  }
  return b;
};

EnumType.prototype._read = function (tap) {
  var index = tap.readLong();
  var symbol = this._symbols[index];
  if (symbol === undefined) {
    throw new Error(f('invalid %s enum index: %s', this._name, index));
  }
  return symbol;
};

EnumType.prototype._skip = function (tap) { tap.skipLong(); };

EnumType.prototype._write = function (tap, val) {
  var index = this._indices[val];
  if (index === undefined) {
    throwInvalidError(null, val, this);
  }
  tap.writeLong(index);
};

EnumType.prototype._match = function (tap1, tap2) {
  return tap1.matchLong(tap2);
};

EnumType.prototype.compare = function (val1, val2) {
  return utils.compare(this._indices[val1], this._indices[val2]);
};

EnumType.prototype._updateResolver = function (resolver, type) {
  var symbols = this._symbols;
  if (
    type instanceof EnumType &&
    ~getAliases(this).indexOf(type._name) &&
    type._symbols.every(function (s) { return ~symbols.indexOf(s); })
  ) {
    resolver._symbols = type._symbols;
    resolver._read = type._read;
  }
};

EnumType.prototype._copy = function (val) {
  this._check(val, throwInvalidError);
  return val;
};

EnumType.prototype.getAliases = function () { return this._aliases; };

EnumType.prototype.getSymbols = function () { return this._symbols.slice(); };

EnumType.prototype.random = function () {
  return RANDOM.choice(this._symbols);
};

EnumType.prototype.toJSON = function () {
  return {name: this._name, type: 'enum', symbols: this._symbols};
};

/**
 * Avro fixed type.
 *
 * Represented simply as a `Buffer`.
 *
 */
function FixedType(attrs, opts) {
  if (attrs.size !== (attrs.size | 0) || attrs.size < 1) {
    throw new Error(f('invalid %j fixed size: %j', attrs.name, attrs.size));
  }

  opts = getOpts(attrs, opts);
  var resolutions = resolveNames(attrs, opts.namespace);
  this._name = resolutions.name;
  this._size = attrs.size | 0;
  this._aliases = resolutions.aliases;
  Type.call(this, opts.registry);
}
util.inherits(FixedType, Type);

FixedType.prototype._check = function (val, cb) {
  var b = Buffer.isBuffer(val) && val.length === this._size;
  if (!b && cb) {
    cb(PATH.slice(), val, this);
  }
  return b;
};

FixedType.prototype._read = function (tap) {
  return tap.readFixed(this._size);
};

FixedType.prototype._skip = function (tap) {
  tap.skipFixed(this._size);
};

FixedType.prototype._write = function (tap, val) {
  if (!Buffer.isBuffer(val) || val.length !== this._size) {
    throwInvalidError(null, val, this);
  }
  tap.writeFixed(val, this._size);
};

FixedType.prototype._match = function (tap1, tap2) {
  return tap1.matchFixed(tap2, this._size);
};

FixedType.prototype.compare = Buffer.compare;

FixedType.prototype._updateResolver = function (resolver, type) {
  if (
    type instanceof FixedType &&
    this._size === type._size &&
    ~getAliases(this).indexOf(type._name)
  ) {
    resolver._size = this._size;
    resolver._read = this._read;
  }
};

FixedType.prototype._copy = BytesType.prototype._copy;

FixedType.prototype.getAliases = function () { return this._aliases; };

FixedType.prototype.getSize = function () { return this._size; };

FixedType.prototype.random = function () {
  return RANDOM.nextBuffer(this._size);
};

FixedType.prototype.toJSON = function () {
  return {name: this._name, type: 'fixed', size: this._size};
};

/**
 * Avro map.
 *
 * Represented as vanilla objects.
 *
 */
function MapType(attrs, opts) {
  if (!attrs.values) {
    throw new Error(f('missing map values: %j', attrs));
  }

  opts = getOpts(attrs, opts);
  Type.call(this);
  this._values = createType(attrs.values, opts);
}
util.inherits(MapType, Type);

MapType.prototype.getValuesType = function () { return this._values; };

MapType.prototype._check = function (val, cb) {
  if (!val || typeof val != 'object' || val instanceof Array) {
    if (cb) {
      cb(PATH.slice(), val, this);
    }
    return false;
  }

  var keys = Object.keys(val);
  var b = true;
  var i, l, j, key;
  if (cb) {
    // Slow path.
    j = PATH.length;
    PATH.push('');
    for (i = 0, l = keys.length; i < l; i++) {
      key = PATH[j] = keys[i];
      if (!this._values._check(val[key], cb)) {
        b = false;
      }
    }
    PATH.pop();
  } else {
    for (i = 0, l = keys.length; i < l; i++) {
      if (!this._values._check(val[keys[i]], cb)) {
        return false;
      }
    }
  }
  return b;
};

MapType.prototype._read = function (tap) {
  var values = this._values;
  var val = {};
  var n;
  while ((n = readArraySize(tap))) {
    while (n--) {
      var key = tap.readString();
      val[key] = values._read(tap);
    }
  }
  return val;
};

MapType.prototype._skip = function (tap) {
  var values = this._values;
  var len, n;
  while ((n = tap.readLong())) {
    if (n < 0) {
      len = tap.readLong();
      tap.pos += len;
    } else {
      while (n--) {
        tap.skipString();
        values._skip(tap);
      }
    }
  }
};

MapType.prototype._write = function (tap, val) {
  if (!val || typeof val != 'object' || val instanceof Array) {
    throwInvalidError(null, val, this);
  }

  var values = this._values;
  var keys = Object.keys(val);
  var n = keys.length;
  var i, key;
  if (n) {
    tap.writeLong(n);
    for (i = 0; i < n; i++) {
      key = keys[i];
      tap.writeString(key);
      values._write(tap, val[key]);
    }
  }
  tap.writeLong(0);
};

MapType.prototype._match = function () {
  throw new Error('maps cannot be compared');
};

MapType.prototype._updateResolver = function (resolver, type, opts) {
  if (type instanceof MapType) {
    resolver._values = this._values.createResolver(type._values, opts);
    resolver._read = this._read;
  }
};

MapType.prototype._copy = function (val, opts) {
  if (val && typeof val == 'object' && !(val instanceof Array)) {
    var values = this._values;
    var keys = Object.keys(val);
    var i, l, key;
    var copy = {};
    for (i = 0, l = keys.length; i < l; i++) {
      key = keys[i];
      copy[key] = values._copy(val[key], opts);
    }
    return copy;
  }
  throwInvalidError(null, val, this);
};

MapType.prototype.compare = MapType.prototype._match;

MapType.prototype.random = function () {
  var val = {};
  var i, l;
  for (i = 0, l = RANDOM.nextInt(10); i < l; i++) {
    val[RANDOM.nextString(RANDOM.nextInt(20))] = this._values.random();
  }
  return val;
};

MapType.prototype.toJSON = function () {
  return {type: 'map', values: this._values};
};

/**
 * Avro array.
 *
 * Represented as vanilla arrays.
 *
 */
function ArrayType(attrs, opts) {
  if (!attrs.items) {
    throw new Error(f('missing array items: %j', attrs));
  }

  opts = getOpts(attrs, opts);

  this._items = createType(attrs.items, opts);
  Type.call(this);
}
util.inherits(ArrayType, Type);

ArrayType.prototype._check = function (val, cb) {
  if (!(val instanceof Array)) {
    if (cb) {
      cb(PATH.slice(), val, this);
    }
    return false;
  }

  var b = true;
  var i, l, j;
  if (cb) {
    // Slow path.
    j = PATH.length;
    PATH.push('');
    for (i = 0, l = val.length; i < l; i++) {
      PATH[j] = '' + i;
      if (!this._items._check(val[i], cb)) {
        b = false;
      }
    }
    PATH.pop();
  } else {
    for (i = 0, l = val.length; i < l; i++) {
      if (!this._items._check(val[i], cb)) {
        return false;
      }
    }
  }
  return b;
};

ArrayType.prototype._read = function (tap) {
  var items = this._items;
  var val = [];
  var n;
  while ((n = tap.readLong())) {
    if (n < 0) {
      n = -n;
      tap.skipLong(); // Skip size.
    }
    while (n--) {
      val.push(items._read(tap));
    }
  }
  return val;
};

ArrayType.prototype._skip = function (tap) {
  var len, n;
  while ((n = tap.readLong())) {
    if (n < 0) {
      len = tap.readLong();
      tap.pos += len;
    } else {
      while (n--) {
        this._items._skip(tap);
      }
    }
  }
};

ArrayType.prototype._write = function (tap, val) {
  if (!(val instanceof Array)) {
    throwInvalidError(null, val, this);
  }

  var n = val.length;
  var i;
  if (n) {
    tap.writeLong(n);
    for (i = 0; i < n; i++) {
      this._items._write(tap, val[i]);
    }
  }
  tap.writeLong(0);
};

ArrayType.prototype._match = function (tap1, tap2) {
  var n1 = tap1.readLong();
  var n2 = tap2.readLong();
  var f;
  while (n1 && n2) {
    f = this._items._match(tap1, tap2);
    if (f) {
      return f;
    }
    if (!--n1) {
      n1 = readArraySize(tap1);
    }
    if (!--n2) {
      n2 = readArraySize(tap2);
    }
  }
  return utils.compare(n1, n2);
};

ArrayType.prototype._updateResolver = function (resolver, type, opts) {
  if (type instanceof ArrayType) {
    resolver._items = this._items.createResolver(type._items, opts);
    resolver._read = this._read;
  }
};

ArrayType.prototype._copy = function (val, opts) {
  if (!(val instanceof Array)) {
    throwInvalidError(null, val, this);
  }
  var items = [];
  var i, l;
  for (i = 0, l = val.length; i < l; i++) {
    items.push(this._items._copy(val[i], opts));
  }
  return items;
};

ArrayType.prototype.compare = function (val1, val2) {
  var n1 = val1.length;
  var n2 = val2.length;
  var i, l, f;
  for (i = 0, l = Math.min(n1, n2); i < l; i++) {
    if ((f = this._items.compare(val1[i], val2[i]))) {
      return f;
    }
  }
  return utils.compare(n1, n2);
};

ArrayType.prototype.getItemsType = function () { return this._items; };

ArrayType.prototype.random = function () {
  var arr = [];
  var i, l;
  for (i = 0, l = RANDOM.nextInt(10); i < l; i++) {
    arr.push(this._items.random());
  }
  return arr;
};

ArrayType.prototype.toJSON = function () {
  return {type: 'array', items: this._items};
};

/**
 * Avro record.
 *
 * Values are represented as instances of a programmatically generated
 * constructor (similar to a "specific record"), available via the
 * `getRecordConstructor` method. This "specific record class" gives
 * significant speedups over using generics objects.
 *
 * Note that vanilla objects are still accepted as valid as long as their
 * fields match (this makes it much more convenient to do simple things like
 * update nested records).
 *
 */
function RecordType(attrs, opts) {
  opts = getOpts(attrs, opts);

  var resolutions = resolveNames(attrs, opts.namespace);
  this._name = resolutions.name;
  this._aliases = resolutions.aliases;
  this._type = attrs.type;
  // Requests shouldn't be registered since their name is only a placeholder.
  Type.call(this, this._type === 'request' ? undefined : opts.registry);

  if (!(attrs.fields instanceof Array)) {
    throw new Error(f('non-array %s fields', this._name));
  }
  this._fields = attrs.fields.map(function (f) {
    return new Field(f, opts);
  });
  if (utils.hasDuplicates(attrs.fields, function (f) { return f.name; })) {
    throw new Error(f('duplicate %s field name', this._name));
  }

  var isError = attrs.type === 'error';
  this._constructor = this._createConstructor(isError);
  this._read = this._createReader();
  this._skip = this._createSkipper();
  this._write = this._createWriter();
  this._check = this._createChecker();
}
util.inherits(RecordType, Type);

RecordType.prototype._createConstructor = function (isError) {
  // jshint -W054
  var outerArgs = [];
  var innerArgs = [];
  var ds = []; // Defaults.
  var innerBody = isError ? '  Error.call(this);\n' : '';
  // Not calling `Error.captureStackTrace` because this wouldn't be compatible
  // with browsers other than Chrome.
  var i, l, field, name, getDefault;
  for (i = 0, l = this._fields.length; i < l; i++) {
    field = this._fields[i];
    getDefault = field.getDefault;
    name = field._name;
    innerArgs.push('v' + i);
    innerBody += '  ';
    if (getDefault() === undefined) {
      innerBody += 'this.' + name + ' = v' + i + ';\n';
    } else {
      innerBody += 'if (v' + i + ' === undefined) { ';
      innerBody += 'this.' + name + ' = d' + ds.length + '(); ';
      innerBody += '} else { this.' + name + ' = v' + i + '; }\n';
      outerArgs.push('d' + ds.length);
      ds.push(getDefault);
    }
  }
  var outerBody = 'return function ' + unqualify(this._name) + '(';
  outerBody += innerArgs.join() + ') {\n' + innerBody + '};';
  var Record = new Function(outerArgs.join(), outerBody).apply(undefined, ds);

  var self = this;
  Record.getType = function () { return self; };
  Record.prototype = {
    constructor: Record,
    $clone: function (opts) { return self.clone(this, opts); },
    $compare: function (val) { return self.compare(this, val); },
    $getType: Record.getType,
    $isValid: function (opts) { return self.isValid(this, opts); },
    $toBuffer: function () { return self.toBuffer(this); },
    $toString: function (noCheck) { return self.toString(this, noCheck); }
  };
  // The names of these properties added to the prototype are prefixed with `$`
  // because it is an invalid property name in Avro but not in JavaScript.
  // (This way we are guaranteed not to be stepped over!)
  if (isError) {
    util.inherits(Record, Error);
    // Not setting the name on the prototype to be consistent with how object
    // fields are mapped to (only if defined in the schema as a field).
  }

  return Record;
};

RecordType.prototype._createChecker = function () {
  // jshint -W054
  var names = ['t', 'P'];
  var values = [this, PATH];
  var body = 'return function check' + unqualify(this._name) + '(val, cb) {\n';
  body += '  if (val === null || typeof val != \'object\') {\n';
  body += '    if (cb) { cb(P.slice(), val, t); }\n';
  body += '    return false;\n';
  body += '  }\n';
  if (!this._fields.length) {
    // Special case, empty record. We handle this directly.
    body += '  return true;\n';
  } else {
    for (i = 0, l = this._fields.length; i < l; i++) {
      field = this._fields[i];
      names.push('t' + i);
      values.push(field._type);
      if (field.getDefault() !== undefined) {
        body += '  var v' + i + ' = val.' + field._name + ';\n';
      }
    }
    body += '  if (cb) {\n';
    body += '    var b = 1;\n';
    body += '    var j = P.length;\n';
    body += '    P.push(\'\');\n';
    var i, l, field;
    for (i = 0, l = this._fields.length; i < l; i++) {
      field = this._fields[i];
      body += '    P[j] = \'' + field._name + '\';\n';
      if (field.getDefault() === undefined) {
        body += '    b &= t' + i + '._check(val.' + field._name + ', cb);\n';
      } else {
        body += '    b &= v' + i + ' === undefined || ';
        body += 't' + i + '._check(v' + i + ', cb);\n';
      }
    }
    body += '    P.pop();\n';
    body += '    return !!b;\n';
    body += '  } else {\n    return (\n      ';
    body += this._fields.map(function (field, i) {
      if (field.getDefault() === undefined) {
        return 't' + i + '._check(val.' + field._name + ')';
      } else {
        return '(v' + i + ' === undefined || t' + i + '._check(v' + i + '))';
      }
    }).join(' &&\n      ');
    body += '\n    );\n  }\n';
  }
  body += '};';
  return new Function(names.join(), body).apply(undefined, values);
};

RecordType.prototype._createReader = function () {
  // jshint -W054
  var uname = unqualify(this._name);
  var names = [];
  var values = [this._constructor];
  var i, l;
  for (i = 0, l = this._fields.length; i < l; i++) {
    names.push('t' + i);
    values.push(this._fields[i]._type);
  }
  var body = 'return function read' + uname + '(tap) {\n';
  body += '  return new ' + uname + '(';
  body += names.map(function (t) { return t + '._read(tap)'; }).join();
  body += ');\n};';
  names.unshift(uname);
  // We can do this since the JS spec guarantees that function arguments are
  // evaluated from left to right.
  return new Function(names.join(), body).apply(undefined, values);
};

RecordType.prototype._createSkipper = function () {
  // jshint -W054
  var args = [];
  var body = 'return function skip' + unqualify(this._name) + '(tap) {\n';
  var values = [];
  var i, l;
  for (i = 0, l = this._fields.length; i < l; i++) {
    args.push('t' + i);
    values.push(this._fields[i]._type);
    body += '  t' + i + '._skip(tap);\n';
  }
  body += '}';
  return new Function(args.join(), body).apply(undefined, values);
};

RecordType.prototype._createWriter = function () {
  // jshint -W054
  // We still do default handling here, in case a normal JS object is passed.
  var args = [];
  var body = 'return function write' + unqualify(this._name) + '(tap, val) {\n';
  var values = [];
  var i, l, field, value;
  for (i = 0, l = this._fields.length; i < l; i++) {
    field = this._fields[i];
    args.push('t' + i);
    values.push(field._type);
    body += '  ';
    if (field.getDefault() === undefined) {
      body += 't' + i + '._write(tap, val.' + field._name + ');\n';
    } else {
      value = field._type.toBuffer(field.getDefault()).toString('binary');
      // Convert the default value to a binary string ahead of time. We aren't
      // converting it to a buffer to avoid retaining too much memory. If we
      // had our own buffer pool, this could be an idea in the future.
      args.push('d' + i);
      values.push(value);
      body += 'var v' + i + ' = val.' + field._name + '; ';
      body += 'if (v' + i + ' === undefined) { ';
      body += 'tap.writeBinary(d' + i + ', ' + value.length + ');';
      body += ' } else { t' + i + '._write(tap, v' + i + '); }\n';
    }
  }
  body += '}';
  return new Function(args.join(), body).apply(undefined, values);
};

RecordType.prototype._updateResolver = function (resolver, type, opts) {
  // jshint -W054
  if (!~getAliases(this).indexOf(type._name)) {
    throw new Error(f('no alias for %s in %s', type._name, this._name));
  }

  var rFields = this._fields;
  var wFields = type._fields;
  var wFieldsMap = utils.toMap(wFields, function (f) { return f._name; });

  var innerArgs = []; // Arguments for reader constructor.
  var resolvers = {}; // Resolvers keyed by writer field name.
  var i, j, field, name, names, matches;
  for (i = 0; i < rFields.length; i++) {
    field = rFields[i];
    names = getAliases(field);
    matches = [];
    for (j = 0; j < names.length; j++) {
      name = names[j];
      if (wFieldsMap[name]) {
        matches.push(name);
      }
    }
    if (matches.length > 1) {
      throw new Error(f('multiple matches for %s', field.name));
    }
    if (!matches.length) {
      if (field.getDefault() === undefined) {
        throw new Error(f('no match for default-less %s', field.name));
      }
      innerArgs.push('undefined');
    } else {
      name = matches[0];
      resolvers[name] = {
        resolver: field._type.createResolver(wFieldsMap[name]._type, opts),
        name: field._name // Reader field name.
      };
      innerArgs.push(field._name);
    }
  }

  // See if we can add a bypass for unused fields at the end of the record.
  var lazyIndex = -1;
  i = wFields.length;
  while (i && resolvers[wFields[--i]._name] === undefined) {
    lazyIndex = i;
  }

  var uname = unqualify(this._name);
  var args = [uname];
  var values = [this._constructor];
  var body = '  return function read' + uname + '(tap,lazy) {\n';
  for (i = 0; i < wFields.length; i++) {
    if (i === lazyIndex) {
      body += '  if (!lazy) {\n';
    }
    field = type._fields[i];
    name = field._name;
    body += (~lazyIndex && i >= lazyIndex) ? '    ' : '  ';
    if (resolvers[name] === undefined) {
      args.push('t' + i);
      values.push(field._type);
      body += 't' + i + '._skip(tap);\n';
    } else {
      args.push('t' + i);
      values.push(resolvers[name].resolver);
      body += 'var ' + resolvers[name].name + ' = ';
      body += 't' + i + '._read(tap);\n';
    }
  }
  if (~lazyIndex) {
    body += '  }\n';
  }
  body +=  '  return new ' + uname + '(' + innerArgs.join() + ');\n};';

  resolver._read = new Function(args.join(), body).apply(undefined, values);
};

RecordType.prototype._match = function (tap1, tap2) {
  var fields = this._fields;
  var i, l, field, order, type;
  for (i = 0, l = fields.length; i < l; i++) {
    field = fields[i];
    order = field._order;
    type = field._type;
    if (order) {
      order *= type._match(tap1, tap2);
      if (order) {
        return order;
      }
    } else {
      type._skip(tap1);
      type._skip(tap2);
    }
  }
  return 0;
};

RecordType.prototype._copy = function (val, opts) {
  // jshint -W058
  var hook = opts && opts.fieldHook;
  var values = [undefined];
  var i, l, field, value;
  for (i = 0, l = this._fields.length; i < l; i++) {
    field = this._fields[i];
    value = field._type._copy(val[field._name], opts);
    if (hook) {
      value = hook(field, value, this);
    }
    values.push(value);
  }
  return new (this._constructor.bind.apply(this._constructor, values));
};

RecordType.prototype.compare = function (val1, val2) {
  var fields = this._fields;
  var i, l, field, name, order, type;
  for (i = 0, l = fields.length; i < l; i++) {
    field = fields[i];
    name = field._name;
    order = field._order;
    type = field._type;
    if (order) {
      order *= type.compare(val1[name], val2[name]);
      if (order) {
        return order;
      }
    }
  }
  return 0;
};

RecordType.prototype.random = function () {
  // jshint -W058
  var fields = this._fields.map(function (f) { return f._type.random(); });
  fields.unshift(undefined);
  return new (this._constructor.bind.apply(this._constructor, fields));
};

RecordType.prototype.getAliases = function () { return this._aliases; };

RecordType.prototype.getFields = function () { return this._fields.slice(); };

RecordType.prototype.getRecordConstructor = function () {
  return this._constructor;
};

RecordType.prototype.toJSON = function () {
  return {name: this._name, type: 'record', fields: this._fields};
};

/**
 * Derived type abstract class.
 *
 */
function LogicalType(attrs, opts, Types) {
  Type.call(this);
  LOGICAL_TYPE = this;
  this._underlyingType = createType(attrs, opts);

  // Convenience type check.
  if (Types && !~Types.indexOf(this._underlyingType.constructor)) {
    var lType = attrs.logicalType;
    var uType = this._underlyingType;
    throw new Error(f('invalid underlying type for %s: %s', lType, uType));
  }
}
util.inherits(LogicalType, Type);

LogicalType.prototype.getUnderlyingType = function () {
  return this._underlyingType;
};

LogicalType.prototype._read = function (tap) {
  return this._fromValue(this._underlyingType._read(tap));
};

LogicalType.prototype._write = function (tap, any) {
  this._underlyingType._write(tap, this._toValue(any));
};

LogicalType.prototype._check = function (any, cb) {
  try {
    var val = this._toValue(any);
  } catch (err) {
    if (cb) {
      cb(PATH.slice(), any, this);
    }
    return false;
  }
  return this._underlyingType._check(val, cb);
};

LogicalType.prototype._copy = function (any, opts) {
  var type = this._underlyingType;
  switch (opts && opts.coerce) {
    case 3: // To string.
      return type._copy(this._toValue(any), opts);
    case 2: // From string.
      return this._fromValue(type._copy(any, opts));
    default: // Normal copy.
      return this._fromValue(type._copy(this._toValue(any), opts));
  }
};

LogicalType.prototype._updateResolver = function (resolver, type, opts) {
  var _fromValue = this._resolve(type, opts);
  if (_fromValue) {
    resolver._read = function (tap) { return _fromValue(type._read(tap)); };
  }
};

LogicalType.prototype.random = function () {
  return this._fromValue(this._underlyingType.random());
};

LogicalType.prototype.compare = function (obj1, obj2) {
  var val1 = this._toValue(obj1);
  var val2 = this._toValue(obj2);
  return this._underlyingType.compare(val1, val2);
};

LogicalType.prototype.toJSON = function () {
  return this._underlyingType.toJSON();
};

// Methods to be implemented.
LogicalType.prototype._fromValue = utils.abstractFunction;
LogicalType.prototype._toValue = utils.abstractFunction;
LogicalType.prototype._resolve = utils.abstractFunction;


// General helpers.

/**
 * Customizable long.
 *
 * This allows support of arbitrarily large long (e.g. larger than
 * `Number.MAX_SAFE_INTEGER`). See `LongType.using` method above.
 *
 */
function AbstractLongType(noUnpack) {
  LongType.call(this);
  this._noUnpack = !!noUnpack;
}
util.inherits(AbstractLongType, LongType);

AbstractLongType.prototype._check = function (val, cb) {
  var b = this._isValid(val);
  if (!b && cb) {
    cb(PATH.slice(), val, this);
  }
  return b;
};

AbstractLongType.prototype._read = function (tap) {
  var buf, pos;
  if (this._noUnpack) {
    pos = tap.pos;
    tap.skipLong();
    buf = tap.buf.slice(pos, tap.pos);
  } else {
    buf = tap.unpackLongBytes(tap);
  }
  if (tap.isValid()) {
    return this._fromBuffer(buf);
  }
};

AbstractLongType.prototype._write = function (tap, val) {
  if (!this._isValid(val)) {
    throwInvalidError(null, val, this);
  }
  var buf = this._toBuffer(val);
  if (this._noUnpack) {
    tap.writeFixed(buf);
  } else {
    tap.packLongBytes(buf);
  }
};

AbstractLongType.prototype._copy = function (val, opts) {
  switch (opts && opts.coerce) {
    case 3: // To string.
      return this._toJSON(val);
    case 2: // From string.
      return this._fromJSON(val);
    default: // Normal copy.
      // Slow but guarantees most consistent results. Faster alternatives would
      // require assumptions on the long class used (e.g. immutability).
      return this._fromJSON(JSON.parse(JSON.stringify(this._toJSON(val))));
  }
};

AbstractLongType.prototype.random = function () {
  return this._fromJSON(LongType.prototype.random());
};

// Methods to be implemented by the user.
AbstractLongType.prototype._fromBuffer = utils.abstractFunction;
AbstractLongType.prototype._toBuffer = utils.abstractFunction;
AbstractLongType.prototype._fromJSON = utils.abstractFunction;
AbstractLongType.prototype._toJSON = utils.abstractFunction;
AbstractLongType.prototype._isValid = utils.abstractFunction;
AbstractLongType.prototype.compare = utils.abstractFunction;

/**
 * Field.
 *
 * @param attrs {Object} The field's schema.
 * @para opts {Object} Schema parsing options (the same as `Type`s').
 *
 */
function Field(attrs, opts) {
  var name = attrs.name;
  if (typeof name != 'string' || !NAME_PATTERN.test(name)) {
    throw new Error(f('invalid field name: %s', name));
  }

  this._name = name;
  this._type = createType(attrs.type, opts);
  this._aliases = attrs.aliases || [];

  this._order = (function (order) {
    switch (order) {
      case 'ascending':
        return 1;
      case 'descending':
        return -1;
      case 'ignore':
        return 0;
      default:
        throw new Error(f('invalid order: %j', order));
    }
  })(attrs.order === undefined ? 'ascending' : attrs.order);

  var value = attrs['default'];
  if (value !== undefined) {
    // We need to convert defaults back to a valid format (unions are
    // disallowed in default definitions, only the first type of each union is
    // allowed instead).
    // http://apache-avro.679487.n3.nabble.com/field-union-default-in-Java-td1175327.html
    var type = this._type;
    var val = type._copy(value, {coerce: 2, wrap: 2});
    // The clone call above will throw an error if the default is invalid.
    if (type instanceof PrimitiveType && !(type instanceof BytesType)) {
      // These are immutable.
      this.getDefault = function () { return val; };
    } else {
      this.getDefault = function () { return type._copy(val); };
    }
  }
}

Field.prototype.getAliases = function () { return this._aliases; };

Field.prototype.getDefault = function () {}; // Undefined default.

Field.prototype.getName = function () { return this._name; };

Field.prototype.getOrder = function () {
  return ['descending', 'ignore', 'ascending'][this._order + 1];
};

Field.prototype.getType = function () { return this._type; };

Field.prototype.inspect = function () { return f('<Field %j>', this._name); };

/**
 * Resolver to read a writer's schema as a new schema.
 *
 * @param readerType {Type} The type to convert to.
 *
 */
function Resolver(readerType) {
  // Add all fields here so that all resolvers share the same hidden class.
  this._readerType = readerType;
  this._items = null;
  this._read = null;
  this._size = 0;
  this._symbols = null;
  this._values = null;
}

Resolver.prototype.inspect = function () { return '<Resolver>'; };

/**
 * Read a value from a tap.
 *
 * @param type {Type} The type to decode.
 * @param tap {Tap} The tap to read from. No checks are performed here.
 * @param resolver {Resolver} Optional resolver. It must match the input type.
 * @param lazy {Boolean} Skip trailing fields when using a resolver.
 *
 */
function readValue(type, tap, resolver, lazy) {
  if (resolver) {
    if (resolver._readerType !== type) {
      throw new Error('invalid resolver');
    }
    return resolver._read(tap, lazy);
  } else {
    return type._read(tap);
  }
}

/**
 * Create default parsing options.
 *
 * @param attrs {Object} Schema to populate options with.
 * @param opts {Object} Base options.
 *
 */
function getOpts(attrs, opts) {
  if (attrs === null) {
    // Let's be helpful for this common error.
    throw new Error('invalid type: null (did you mean "null"?)');
  }
  opts = opts || {};
  opts.registry = opts.registry || {};
  opts.namespace = attrs.namespace || opts.namespace;
  opts.logicalTypes = opts.logicalTypes || {};
  return opts;
}

/**
 * Resolve a schema's name and aliases.
 *
 * @param attrs {Object} True schema (can't be a string).
 * @param namespace {String} Optional parent namespace.
 * @param key {String} Key where the name should be looked up (defaults to
 * `name`).
 *
 */
function resolveNames(attrs, namespace, key) {
  namespace = attrs.namespace || namespace;
  key = key || 'name';

  var name = attrs[key];
  if (!name) {
    throw new Error(f('missing %s property in schema: %j', key, attrs));
  }
  return {
    name: qualify(name),
    aliases: attrs.aliases ? attrs.aliases.map(qualify) : []
  };

  function qualify(name) {
    if (!~name.indexOf('.') && namespace) {
      name = namespace + '.' + name;
    }
    var tail = unqualify(name);
    if (isPrimitive(tail)) {
      // Primitive types cannot be defined in any namespace.
      throw new Error(f('cannot rename primitive type: %j', tail));
    }
    name.split('.').forEach(function (part) {
      if (!NAME_PATTERN.test(part)) {
        throw new Error(f('invalid name: %j', name));
      }
    });
    return name;
  }
}

/**
 * Remove namespace from a name.
 *
 * @param name {String} Full or short name.
 *
 */
function unqualify(name) {
  var parts = name.split('.');
  return parts[parts.length - 1];
}

/**
 * Get all aliases for a type (including its name).
 *
 * @param obj {Type|Object} Typically a type or a field. Its aliases property
 * must exist and be an array.
 *
 */
function getAliases(obj) {
  var names = [obj._name];
  var aliases = obj._aliases;
  var i, l;
  for (i = 0, l = aliases.length; i < l; i++) {
    names.push(aliases[i]);
  }
  return names;
}

/**
 * Get a type's "type" (as a string, e.g. `'record'`, `'string'`).
 *
 * @param type {Type} Any type.
 *
 */
function getTypeName(type) {
  var obj = type.toJSON();
  return typeof obj == 'string' ? obj : obj.type;
}

/**
 * Check whether a type's name is a primitive.
 *
 * @param name {String} Type name (e.g. `'string'`, `'array'`).
 *
 */
function isPrimitive(name) {
  var type = TYPES[name];
  return type !== undefined && type.prototype instanceof PrimitiveType;
}

/**
 * Get the number of elements in an array block.
 *
 * @param tap {Tap} A tap positioned at the beginning of an array block.
 *
 */
function readArraySize(tap) {
  var n = tap.readLong();
  if (n < 0) {
    n = -n;
    tap.skipLong(); // Skip size.
  }
  return n;
}

/**
 * Correctly stringify an object which contains types.
 *
 * @param obj {Object} The object to stringify. Typically, a type itself or an
 * object containing types. Any types inside will be expanded only once then
 * referenced by name.
 * @param noDeref {Boolean} Always reference types by name when possible,
 * rather than expand it the first time it is encountered.
 *
 */
function stringify(obj, noDeref) {
  // Since JS objects are unordered, this implementation (unfortunately)
  // relies on engines returning properties in the same order that they are
  // inserted in. This is not in the JS spec, but can be "somewhat" safely
  // assumed (more here: http://stackoverflow.com/q/5525795/1062617).
  return (function (registry) {
    return JSON.stringify(obj, function (key, value) {
      if (value instanceof Field) {
        return {name: value._name, type: value._type};
      } else if (value && value.name) {
        var name = value.name;
        if (noDeref || registry[name]) {
          return name;
        }
        registry[name] = true;
      }
      return value;
    });
  })({});
}

/**
 * Check whether a long can be represented without precision loss.
 *
 * @param n {Number} The number.
 *
 * Two things to note:
 *
 * + We are not using the `Number` constants for compatibility with older
 *   browsers.
 * + We must remove one from each bound because of rounding errors.
 *
 */
function isSafeLong(n) {
  return n >= -9007199254740990 && n <= 9007199254740990;
}

/**
 * Throw a somewhat helpful error on invalid object.
 *
 * @param path {Array} Passed from hook, but unused (because empty where this
 * function is used, since we aren't keeping track of it for effiency).
 * @param val {...} The object to reject.
 * @param type {Type} The type to check against.
 *
 * This method is mostly used from `_write` to signal an invalid object for a
 * given type. Note that this provides less information than calling `isValid`
 * with a hook since the path is not propagated (for efficiency reasons).
 *
 */
function throwInvalidError(path, val, type) {
  throw new Error(f('invalid %s: %j', type, val));
}


module.exports = {
  createType: createType,
  resolveNames: resolveNames, // Protocols use the same name resolution logic.
  stringify: stringify,
  types: (function () {
    // Export the base types along with all concrete implementations.
    var obj = {Type: Type, LogicalType: LogicalType};
    var types = Object.keys(TYPES);
    var i, l, Class;
    for (i = 0, l = types.length; i < l; i++) {
      Class = TYPES[types[i]];
      obj[Class.name] = Class;
    }
    return obj;
  })()
};

}).call(this,require("buffer").Buffer)
},{"./utils":356,"buffer":359,"util":479}],356:[function(require,module,exports){
(function (Buffer){
/* jshint node: true */

/**
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  "License"); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 *
 */

'use strict';

var crypto = require('crypto');


/**
 * Uppercase the first letter of a string.
 *
 * @param s {String} The string.
 *
 */
function capitalize(s) { return s.charAt(0).toUpperCase() + s.slice(1); }

/**
 * Compare two numbers.
 *
 * @param n1 {Number} The first one.
 * @param n2 {Number} The second one.
 *
 */
function compare(n1, n2) { return n1 === n2 ? 0 : (n1 < n2 ? -1 : 1); }

/**
 * Compute a string's hash.
 *
 * @param str {String} The string to hash.
 * @param algorithm {String} The algorithm used. Defaults to MD5.
 *
 */
function getHash(str, algorithm) {
  algorithm = algorithm || 'md5';
  var hash = crypto.createHash(algorithm);
  hash.end(str);
  return hash.read();
}

/**
 * Find index of value in array.
 *
 * @param arr {Array} Can also be a false-ish value.
 * @param v {Object} Value to find.
 *
 * Returns -1 if not found, -2 if found multiple times.
 *
 */
function singleIndexOf(arr, v) {
  var pos = -1;
  var i, l;
  if (!arr) {
    return -1;
  }
  for (i = 0, l = arr.length; i < l; i++) {
    if (arr[i] === v) {
      if (pos >= 0) {
        return -2;
      }
      pos = i;
    }
  }
  return pos;
}

/**
 * Convert array to map.
 *
 * @param arr {Array} Elements.
 * @param fn {Function} Function returning an element's key.
 *
 */
function toMap(arr, fn) {
  var obj = {};
  var i, elem;
  for (i = 0; i < arr.length; i++) {
    elem = arr[i];
    obj[fn(elem)] = elem;
  }
  return obj;
}

/**
 * Check whether an array has duplicates.
 *
 * @param arr {Array} The array.
 * @param fn {Function} Optional function to apply to each element.
 *
 */
function hasDuplicates(arr, fn) {
  var obj = {};
  var i, l, elem;
  for (i = 0, l = arr.length; i < l; i++) {
    elem = arr[i];
    if (fn) {
      elem = fn(elem);
    }
    if (obj[elem]) {
      return true;
    }
    obj[elem] = true;
  }
  return false;
}

/**
 * "Abstract" function to help with "subclassing".
 *
 */
function abstractFunction() { throw new Error('abstract'); }

/**
 * Generator of random things.
 *
 * Inspired by: http://stackoverflow.com/a/424445/1062617
 *
 */
function Lcg(seed) {
  var a = 1103515245;
  var c = 12345;
  var m = Math.pow(2, 31);
  var state = Math.floor(seed || Math.random() * (m - 1));

  this._max = m;
  this._nextInt = function () { return state = (a * state + c) % m; };
}

Lcg.prototype.nextBoolean = function () {
  // jshint -W018
  return !!(this._nextInt() % 2);
};

Lcg.prototype.nextInt = function (start, end) {
  if (end === undefined) {
    end = start;
    start = 0;
  }
  end = end === undefined ? this._max : end;
  return start + Math.floor(this.nextFloat() * (end - start));
};

Lcg.prototype.nextFloat = function (start, end) {
  if (end === undefined) {
    end = start;
    start = 0;
  }
  end = end === undefined ? 1 : end;
  return start + (end - start) * this._nextInt() / this._max;
};

Lcg.prototype.nextString = function(len, flags) {
  len |= 0;
  flags = flags || 'aA';
  var mask = '';
  if (flags.indexOf('a') > -1) {
    mask += 'abcdefghijklmnopqrstuvwxyz';
  }
  if (flags.indexOf('A') > -1) {
    mask += 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
  }
  if (flags.indexOf('#') > -1) {
    mask += '0123456789';
  }
  if (flags.indexOf('!') > -1) {
    mask += '~`!@#$%^&*()_+-={}[]:";\'<>?,./|\\';
  }
  var result = [];
  for (var i = 0; i < len; i++) {
    result.push(this.choice(mask));
  }
  return result.join('');
};

Lcg.prototype.nextBuffer = function (len) {
  var arr = [];
  var i;
  for (i = 0; i < len; i++) {
    arr.push(this.nextInt(256));
  }
  return new Buffer(arr);
};

Lcg.prototype.choice = function (arr) {
  var len = arr.length;
  if (!len) {
    throw new Error('choosing from empty array');
  }
  return arr[this.nextInt(len)];
};

/**
 * Ordered queue which returns items consecutively.
 *
 * This is actually a heap by index, with the added requirements that elements
 * can only be retrieved consecutively.
 *
 */
function OrderedQueue() {
  this._index = 0;
  this._items = [];
}

OrderedQueue.prototype.push = function (item) {
  var items = this._items;
  var i = items.length | 0;
  var j;
  items.push(item);
  while (i > 0 && items[i].index < items[j = ((i - 1) >> 1)].index) {
    item = items[i];
    items[i] = items[j];
    items[j] = item;
    i = j;
  }
};

OrderedQueue.prototype.pop = function () {
  var items = this._items;
  var len = (items.length - 1) | 0;
  var first = items[0];
  if (!first || first.index > this._index) {
    return null;
  }
  this._index++;
  if (!len) {
    items.pop();
    return first;
  }
  items[0] = items.pop();
  var mid = len >> 1;
  var i = 0;
  var i1, i2, j, item, c, c1, c2;
  while (i < mid) {
    item = items[i];
    i1 = (i << 1) + 1;
    i2 = (i + 1) << 1;
    c1 = items[i1];
    c2 = items[i2];
    if (!c2 || c1.index <= c2.index) {
      c = c1;
      j = i1;
    } else {
      c = c2;
      j = i2;
    }
    if (c.index >= item.index) {
      break;
    }
    items[j] = item;
    items[i] = c;
    i = j;
  }
  return first;
};

/**
 * A tap is a buffer which remembers what has been already read.
 *
 * It is optimized for performance, at the cost of failing silently when
 * overflowing the buffer. This is a purposeful trade-off given the expected
 * rarity of this case and the large performance hit necessary to enforce
 * validity. See `isValid` below for more information.
 *
 */
function Tap(buf, pos) {
  this.buf = buf;
  this.pos = pos | 0;
}

/**
 * Check that the tap is in a valid state.
 *
 * For efficiency reasons, none of the methods below will fail if an overflow
 * occurs (either read, skip, or write). For this reason, it is up to the
 * caller to always check that the read, skip, or write was valid by calling
 * this method.
 *
 */
Tap.prototype.isValid = function () { return this.pos <= this.buf.length; };

/**
 * Returns the contents of the tap up to the current position.
 *
 */
Tap.prototype.getValue = function () { return this.buf.slice(0, this.pos); };

// Read, skip, write methods.
//
// These should fail silently when the buffer overflows. Note this is only
// required to be true when the functions are decoding valid objects. For
// example errors will still be thrown if a bad count is read, leading to a
// negative position offset (which will typically cause a failure in
// `readFixed`).

Tap.prototype.readBoolean = function () { return !!this.buf[this.pos++]; };

Tap.prototype.skipBoolean = function () { this.pos++; };

Tap.prototype.writeBoolean = function (b) { this.buf[this.pos++] = !!b; };

Tap.prototype.readInt = Tap.prototype.readLong = function () {
  var n = 0;
  var k = 0;
  var buf = this.buf;
  var b, h, f, fk;

  do {
    b = buf[this.pos++];
    h = b & 0x80;
    n |= (b & 0x7f) << k;
    k += 7;
  } while (h && k < 28);

  if (h) {
    // Switch to float arithmetic, otherwise we might overflow.
    f = n;
    fk = 268435456; // 2 ** 28.
    do {
      b = buf[this.pos++];
      f += (b & 0x7f) * fk;
      fk *= 128;
    } while (b & 0x80);
    return (f % 2 ? -(f + 1) : f) / 2;
  }

  return (n >> 1) ^ -(n & 1);
};

Tap.prototype.skipInt = Tap.prototype.skipLong = function () {
  var buf = this.buf;
  while (buf[this.pos++] & 0x80) {}
};

Tap.prototype.writeInt = Tap.prototype.writeLong = function (n) {
  var buf = this.buf;
  var f, m;

  if (n >= -1073741824 && n < 1073741824) {
    // Won't overflow, we can use integer arithmetic.
    m = n >= 0 ? n << 1 : (~n << 1) | 1;
    do {
      buf[this.pos] = m & 0x7f;
      m >>= 7;
    } while (m && (buf[this.pos++] |= 0x80));
  } else {
    // We have to use slower floating arithmetic.
    f = n >= 0 ? n * 2 : (-n * 2) - 1;
    do {
      buf[this.pos] = f & 0x7f;
      f /= 128;
    } while (f >= 1 && (buf[this.pos++] |= 0x80));
  }
  this.pos++;
};

Tap.prototype.readFloat = function () {
  var buf = this.buf;
  var pos = this.pos;
  this.pos += 4;
  if (this.pos > buf.length) {
    return;
  }
  return this.buf.readFloatLE(pos);
};

Tap.prototype.skipFloat = function () { this.pos += 4; };

Tap.prototype.writeFloat = function (f) {
  var buf = this.buf;
  var pos = this.pos;
  this.pos += 4;
  if (this.pos > buf.length) {
    return;
  }
  return this.buf.writeFloatLE(f, pos);
};

Tap.prototype.readDouble = function () {
  var buf = this.buf;
  var pos = this.pos;
  this.pos += 8;
  if (this.pos > buf.length) {
    return;
  }
  return this.buf.readDoubleLE(pos);
};

Tap.prototype.skipDouble = function () { this.pos += 8; };

Tap.prototype.writeDouble = function (d) {
  var buf = this.buf;
  var pos = this.pos;
  this.pos += 8;
  if (this.pos > buf.length) {
    return;
  }
  return this.buf.writeDoubleLE(d, pos);
};

Tap.prototype.readFixed = function (len) {
  var pos = this.pos;
  this.pos += len;
  if (this.pos > this.buf.length) {
    return;
  }
  var fixed = new Buffer(len);
  this.buf.copy(fixed, 0, pos, pos + len);
  return fixed;
};

Tap.prototype.skipFixed = function (len) { this.pos += len; };

Tap.prototype.writeFixed = function (buf, len) {
  len = len || buf.length;
  var pos = this.pos;
  this.pos += len;
  if (this.pos > this.buf.length) {
    return;
  }
  buf.copy(this.buf, pos, 0, len);
};

Tap.prototype.readBytes = function () {
  return this.readFixed(this.readLong());
};

Tap.prototype.skipBytes = function () {
  var len = this.readLong();
  this.pos += len;
};

Tap.prototype.writeBytes = function (buf) {
  var len = buf.length;
  this.writeLong(len);
  this.writeFixed(buf, len);
};

Tap.prototype.readString = function () {
  var len = this.readLong();
  var pos = this.pos;
  var buf = this.buf;
  this.pos += len;
  if (this.pos > buf.length) {
    return;
  }
  return this.buf.utf8Slice(pos, pos + len);
};

Tap.prototype.skipString = function () {
  var len = this.readLong();
  this.pos += len;
};

Tap.prototype.writeString = function (s) {
  var len = Buffer.byteLength(s);
  this.writeLong(len);
  var pos = this.pos;
  this.pos += len;
  if (this.pos > this.buf.length) {
    return;
  }
  this.buf.utf8Write(s, pos, len);
};

// Helper used to speed up writing defaults.

Tap.prototype.writeBinary = function (str, len) {
  var pos = this.pos;
  this.pos += len;
  if (this.pos > this.buf.length) {
    return;
  }
  this.buf.binaryWrite(str, pos, len);
};

// Binary comparison methods.
//
// These are not guaranteed to consume the objects they are comparing when
// returning a non-zero result (allowing for performance benefits), so no other
// operations should be done on either tap after a compare returns a non-zero
// value. Also, these methods do not have the same silent failure requirement
// as read, skip, and write since they are assumed to be called on valid
// buffers.

Tap.prototype.matchBoolean = function (tap) {
  return this.buf[this.pos++] - tap.buf[tap.pos++];
};

Tap.prototype.matchInt = Tap.prototype.matchLong = function (tap) {
  var n1 = this.readLong();
  var n2 = tap.readLong();
  return n1 === n2 ? 0 : (n1 < n2 ? -1 : 1);
};

Tap.prototype.matchFloat = function (tap) {
  var n1 = this.readFloat();
  var n2 = tap.readFloat();
  return n1 === n2 ? 0 : (n1 < n2 ? -1 : 1);
};

Tap.prototype.matchDouble = function (tap) {
  var n1 = this.readDouble();
  var n2 = tap.readDouble();
  return n1 === n2 ? 0 : (n1 < n2 ? -1 : 1);
};

Tap.prototype.matchFixed = function (tap, len) {
  return this.readFixed(len).compare(tap.readFixed(len));
};

Tap.prototype.matchBytes = Tap.prototype.matchString = function (tap) {
  var l1 = this.readLong();
  var p1 = this.pos;
  this.pos += l1;
  var l2 = tap.readLong();
  var p2 = tap.pos;
  tap.pos += l2;
  var b1 = this.buf.slice(p1, this.pos);
  var b2 = tap.buf.slice(p2, tap.pos);
  return b1.compare(b2);
};

// Functions for supporting custom long classes.
//
// The two following methods allow the long implementations to not have to
// worry about Avro's zigzag encoding, we directly expose longs as unpacked.

Tap.prototype.unpackLongBytes = function () {
  var res = new Buffer(8);
  var n = 0;
  var i = 0; // Byte index in target buffer.
  var j = 6; // Bit offset in current target buffer byte.
  var buf = this.buf;
  var b, neg;

  b = buf[this.pos++];
  neg = b & 1;
  res.fill(0);

  n |= (b & 0x7f) >> 1;
  while (b & 0x80) {
    b = buf[this.pos++];
    n |= (b & 0x7f) << j;
    j += 7;
    if (j >= 8) {
      // Flush byte.
      j -= 8;
      res[i++] = n;
      n >>= 8;
    }
  }
  res[i] = n;

  if (neg) {
    invert(res, 8);
  }

  return res;
};

Tap.prototype.packLongBytes = function (buf) {
  var neg = (buf[7] & 0x80) >> 7;
  var res = this.buf;
  var j = 1;
  var k = 0;
  var m = 3;
  var n;

  if (neg) {
    invert(buf, 8);
    n = 1;
  } else {
    n = 0;
  }

  var parts = [
    buf.readUIntLE(0, 3),
    buf.readUIntLE(3, 3),
    buf.readUIntLE(6, 2)
  ];
  // Not reading more than 24 bits because we need to be able to combine the
  // "carry" bits from the previous part and JavaScript only supports bitwise
  // operations on 32 bit integers.
  while (m && !parts[--m]) {} // Skip trailing 0s.

  // Leading parts (if any), we never bail early here since we need the
  // continuation bit to be set.
  while (k < m) {
    n |= parts[k++] << j;
    j += 24;
    while (j > 7) {
      res[this.pos++] = (n & 0x7f) | 0x80;
      n >>= 7;
      j -= 7;
    }
  }

  // Final part, similar to normal packing aside from the initial offset.
  n |= parts[m] << j;
  do {
    res[this.pos] = n & 0x7f;
    n >>= 7;
  } while (n && (res[this.pos++] |= 0x80));
  this.pos++;

  // Restore original buffer (could make this optional?).
  if (neg) {
    invert(buf, 8);
  }
};

// Helpers.

/**
 * Invert all bits in a buffer.
 *
 * @param buf {Buffer} Non-empty buffer to invert.
 * @param len {Number} Buffer length (must be positive).
 *
 */
function invert(buf, len) {
  while (len--) {
    buf[len] = ~buf[len];
  }
}


module.exports = {
  abstractFunction: abstractFunction,
  capitalize: capitalize,
  compare: compare,
  getHash: getHash,
  toMap: toMap,
  singleIndexOf: singleIndexOf,
  hasDuplicates: hasDuplicates,
  Lcg: Lcg,
  OrderedQueue: OrderedQueue,
  Tap: Tap
};

}).call(this,require("buffer").Buffer)
},{"buffer":359,"crypto":353}],357:[function(require,module,exports){
'use strict'

exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function placeHoldersCount (b64) {
  var len = b64.length
  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // the number of equal signs (place holders)
  // if there are two placeholders, than the two characters before it
  // represent one byte
  // if there is only one, then the three characters before it represent 2 bytes
  // this is just a cheap hack to not do indexOf twice
  return b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0
}

function byteLength (b64) {
  // base64 is 4/3 + up to two characters of the original data
  return b64.length * 3 / 4 - placeHoldersCount(b64)
}

function toByteArray (b64) {
  var i, j, l, tmp, placeHolders, arr
  var len = b64.length
  placeHolders = placeHoldersCount(b64)

  arr = new Arr(len * 3 / 4 - placeHolders)

  // if there are placeholders, only get up to the last complete 4 chars
  l = placeHolders > 0 ? len - 4 : len

  var L = 0

  for (i = 0, j = 0; i < l; i += 4, j += 3) {
    tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)]
    arr[L++] = (tmp >> 16) & 0xFF
    arr[L++] = (tmp >> 8) & 0xFF
    arr[L++] = tmp & 0xFF
  }

  if (placeHolders === 2) {
    tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[L++] = tmp & 0xFF
  } else if (placeHolders === 1) {
    tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[L++] = (tmp >> 8) & 0xFF
    arr[L++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var output = ''
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    output += lookup[tmp >> 2]
    output += lookup[(tmp << 4) & 0x3F]
    output += '=='
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + (uint8[len - 1])
    output += lookup[tmp >> 10]
    output += lookup[(tmp >> 4) & 0x3F]
    output += lookup[(tmp << 2) & 0x3F]
    output += '='
  }

  parts.push(output)

  return parts.join('')
}

},{}],358:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var objectCreate = Object.create || objectCreatePolyfill
var objectKeys = Object.keys || objectKeysPolyfill
var bind = Function.prototype.bind || functionBindPolyfill

function EventEmitter() {
  if (!this._events || !Object.prototype.hasOwnProperty.call(this, '_events')) {
    this._events = objectCreate(null);
    this._eventsCount = 0;
  }

  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
var defaultMaxListeners = 10;

var hasDefineProperty;
try {
  var o = {};
  if (Object.defineProperty) Object.defineProperty(o, 'x', { value: 0 });
  hasDefineProperty = o.x === 0;
} catch (err) { hasDefineProperty = false }
if (hasDefineProperty) {
  Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
    enumerable: true,
    get: function() {
      return defaultMaxListeners;
    },
    set: function(arg) {
      // check whether the input is a positive number (whose value is zero or
      // greater and not a NaN).
      if (typeof arg !== 'number' || arg < 0 || arg !== arg)
        throw new TypeError('"defaultMaxListeners" must be a positive number');
      defaultMaxListeners = arg;
    }
  });
} else {
  EventEmitter.defaultMaxListeners = defaultMaxListeners;
}

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || isNaN(n))
    throw new TypeError('"n" argument must be a positive number');
  this._maxListeners = n;
  return this;
};

function $getMaxListeners(that) {
  if (that._maxListeners === undefined)
    return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}

EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return $getMaxListeners(this);
};

// These standalone emit* functions are used to optimize calling of event
// handlers for fast cases because emit() itself often has a variable number of
// arguments and can be deoptimized because of that. These functions always have
// the same number of arguments and thus do not get deoptimized, so the code
// inside them can execute faster.
function emitNone(handler, isFn, self) {
  if (isFn)
    handler.call(self);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].call(self);
  }
}
function emitOne(handler, isFn, self, arg1) {
  if (isFn)
    handler.call(self, arg1);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].call(self, arg1);
  }
}
function emitTwo(handler, isFn, self, arg1, arg2) {
  if (isFn)
    handler.call(self, arg1, arg2);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].call(self, arg1, arg2);
  }
}
function emitThree(handler, isFn, self, arg1, arg2, arg3) {
  if (isFn)
    handler.call(self, arg1, arg2, arg3);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].call(self, arg1, arg2, arg3);
  }
}

function emitMany(handler, isFn, self, args) {
  if (isFn)
    handler.apply(self, args);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].apply(self, args);
  }
}

EventEmitter.prototype.emit = function emit(type) {
  var er, handler, len, args, i, events;
  var doError = (type === 'error');

  events = this._events;
  if (events)
    doError = (doError && events.error == null);
  else if (!doError)
    return false;

  // If there is no 'error' event listener then throw.
  if (doError) {
    if (arguments.length > 1)
      er = arguments[1];
    if (er instanceof Error) {
      throw er; // Unhandled 'error' event
    } else {
      // At least give some kind of context to the user
      var err = new Error('Unhandled "error" event. (' + er + ')');
      err.context = er;
      throw err;
    }
    return false;
  }

  handler = events[type];

  if (!handler)
    return false;

  var isFn = typeof handler === 'function';
  len = arguments.length;
  switch (len) {
      // fast cases
    case 1:
      emitNone(handler, isFn, this);
      break;
    case 2:
      emitOne(handler, isFn, this, arguments[1]);
      break;
    case 3:
      emitTwo(handler, isFn, this, arguments[1], arguments[2]);
      break;
    case 4:
      emitThree(handler, isFn, this, arguments[1], arguments[2], arguments[3]);
      break;
      // slower
    default:
      args = new Array(len - 1);
      for (i = 1; i < len; i++)
        args[i - 1] = arguments[i];
      emitMany(handler, isFn, this, args);
  }

  return true;
};

function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;

  if (typeof listener !== 'function')
    throw new TypeError('"listener" argument must be a function');

  events = target._events;
  if (!events) {
    events = target._events = objectCreate(null);
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (events.newListener) {
      target.emit('newListener', type,
          listener.listener ? listener.listener : listener);

      // Re-assign `events` because a newListener handler could have caused the
      // this._events to be assigned to a new object
      events = target._events;
    }
    existing = events[type];
  }

  if (!existing) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] =
          prepend ? [listener, existing] : [existing, listener];
    } else {
      // If we've already got an array, just append.
      if (prepend) {
        existing.unshift(listener);
      } else {
        existing.push(listener);
      }
    }

    // Check for listener leak
    if (!existing.warned) {
      m = $getMaxListeners(target);
      if (m && m > 0 && existing.length > m) {
        existing.warned = true;
        var w = new Error('Possible EventEmitter memory leak detected. ' +
            existing.length + ' "' + String(type) + '" listeners ' +
            'added. Use emitter.setMaxListeners() to ' +
            'increase limit.');
        w.name = 'MaxListenersExceededWarning';
        w.emitter = target;
        w.type = type;
        w.count = existing.length;
        if (typeof console === 'object' && console.warn) {
          console.warn('%s: %s', w.name, w.message);
        }
      }
    }
  }

  return target;
}

EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.prependListener =
    function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };

function onceWrapper() {
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    switch (arguments.length) {
      case 0:
        return this.listener.call(this.target);
      case 1:
        return this.listener.call(this.target, arguments[0]);
      case 2:
        return this.listener.call(this.target, arguments[0], arguments[1]);
      case 3:
        return this.listener.call(this.target, arguments[0], arguments[1],
            arguments[2]);
      default:
        var args = new Array(arguments.length);
        for (var i = 0; i < args.length; ++i)
          args[i] = arguments[i];
        this.listener.apply(this.target, args);
    }
  }
}

function _onceWrap(target, type, listener) {
  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };
  var wrapped = bind.call(onceWrapper, state);
  wrapped.listener = listener;
  state.wrapFn = wrapped;
  return wrapped;
}

EventEmitter.prototype.once = function once(type, listener) {
  if (typeof listener !== 'function')
    throw new TypeError('"listener" argument must be a function');
  this.on(type, _onceWrap(this, type, listener));
  return this;
};

EventEmitter.prototype.prependOnceListener =
    function prependOnceListener(type, listener) {
      if (typeof listener !== 'function')
        throw new TypeError('"listener" argument must be a function');
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };

// Emits a 'removeListener' event if and only if the listener was removed.
EventEmitter.prototype.removeListener =
    function removeListener(type, listener) {
      var list, events, position, i, originalListener;

      if (typeof listener !== 'function')
        throw new TypeError('"listener" argument must be a function');

      events = this._events;
      if (!events)
        return this;

      list = events[type];
      if (!list)
        return this;

      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = objectCreate(null);
        else {
          delete events[type];
          if (events.removeListener)
            this.emit('removeListener', type, list.listener || listener);
        }
      } else if (typeof list !== 'function') {
        position = -1;

        for (i = list.length - 1; i >= 0; i--) {
          if (list[i] === listener || list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }

        if (position < 0)
          return this;

        if (position === 0)
          list.shift();
        else
          spliceOne(list, position);

        if (list.length === 1)
          events[type] = list[0];

        if (events.removeListener)
          this.emit('removeListener', type, originalListener || listener);
      }

      return this;
    };

EventEmitter.prototype.removeAllListeners =
    function removeAllListeners(type) {
      var listeners, events, i;

      events = this._events;
      if (!events)
        return this;

      // not listening for removeListener, no need to emit
      if (!events.removeListener) {
        if (arguments.length === 0) {
          this._events = objectCreate(null);
          this._eventsCount = 0;
        } else if (events[type]) {
          if (--this._eventsCount === 0)
            this._events = objectCreate(null);
          else
            delete events[type];
        }
        return this;
      }

      // emit removeListener for all listeners on all events
      if (arguments.length === 0) {
        var keys = objectKeys(events);
        var key;
        for (i = 0; i < keys.length; ++i) {
          key = keys[i];
          if (key === 'removeListener') continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners('removeListener');
        this._events = objectCreate(null);
        this._eventsCount = 0;
        return this;
      }

      listeners = events[type];

      if (typeof listeners === 'function') {
        this.removeListener(type, listeners);
      } else if (listeners) {
        // LIFO order
        for (i = listeners.length - 1; i >= 0; i--) {
          this.removeListener(type, listeners[i]);
        }
      }

      return this;
    };

EventEmitter.prototype.listeners = function listeners(type) {
  var evlistener;
  var ret;
  var events = this._events;

  if (!events)
    ret = [];
  else {
    evlistener = events[type];
    if (!evlistener)
      ret = [];
    else if (typeof evlistener === 'function')
      ret = [evlistener.listener || evlistener];
    else
      ret = unwrapListeners(evlistener);
  }

  return ret;
};

EventEmitter.listenerCount = function(emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};

EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
  var events = this._events;

  if (events) {
    var evlistener = events[type];

    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener) {
      return evlistener.length;
    }
  }

  return 0;
}

EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];
};

// About 1.5x faster than the two-arg version of Array#splice().
function spliceOne(list, index) {
  for (var i = index, k = i + 1, n = list.length; k < n; i += 1, k += 1)
    list[i] = list[k];
  list.pop();
}

function arrayClone(arr, n) {
  var copy = new Array(n);
  for (var i = 0; i < n; ++i)
    copy[i] = arr[i];
  return copy;
}

function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }
  return ret;
}

function objectCreatePolyfill(proto) {
  var F = function() {};
  F.prototype = proto;
  return new F;
}
function objectKeysPolyfill(obj) {
  var keys = [];
  for (var k in obj) if (Object.prototype.hasOwnProperty.call(obj, k)) {
    keys.push(k);
  }
  return k;
}
function functionBindPolyfill(context) {
  var fn = this;
  return function () {
    return fn.apply(context, arguments);
  };
}

},{}],359:[function(require,module,exports){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */

'use strict'

var base64 = require('base64-js')
var ieee754 = require('ieee754')

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

var K_MAX_LENGTH = 0x7fffffff
exports.kMaxLength = K_MAX_LENGTH

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */
Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport()

if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&
    typeof console.error === 'function') {
  console.error(
    'This browser lacks typed array (Uint8Array) support which is required by ' +
    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'
  )
}

function typedArraySupport () {
  // Can typed array instances can be augmented?
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}
    return arr.foo() === 42
  } catch (e) {
    return false
  }
}

Object.defineProperty(Buffer.prototype, 'parent', {
  get: function () {
    if (!(this instanceof Buffer)) {
      return undefined
    }
    return this.buffer
  }
})

Object.defineProperty(Buffer.prototype, 'offset', {
  get: function () {
    if (!(this instanceof Buffer)) {
      return undefined
    }
    return this.byteOffset
  }
})

function createBuffer (length) {
  if (length > K_MAX_LENGTH) {
    throw new RangeError('Invalid typed array length')
  }
  // Return an augmented `Uint8Array` instance
  var buf = new Uint8Array(length)
  buf.__proto__ = Buffer.prototype
  return buf
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error(
        'If encoding is specified then the first argument must be a string'
      )
    }
    return allocUnsafe(arg)
  }
  return from(arg, encodingOrOffset, length)
}

// Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
if (typeof Symbol !== 'undefined' && Symbol.species &&
    Buffer[Symbol.species] === Buffer) {
  Object.defineProperty(Buffer, Symbol.species, {
    value: null,
    configurable: true,
    enumerable: false,
    writable: false
  })
}

Buffer.poolSize = 8192 // not used by this implementation

function from (value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number')
  }

  if (isArrayBuffer(value) || (value && isArrayBuffer(value.buffer))) {
    return fromArrayBuffer(value, encodingOrOffset, length)
  }

  if (typeof value === 'string') {
    return fromString(value, encodingOrOffset)
  }

  return fromObject(value)
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(value, encodingOrOffset, length)
}

// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148
Buffer.prototype.__proto__ = Uint8Array.prototype
Buffer.__proto__ = Uint8Array

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be of type number')
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative')
  }
}

function alloc (size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(size).fill(fill, encoding)
      : createBuffer(size).fill(fill)
  }
  return createBuffer(size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(size, fill, encoding)
}

function allocUnsafe (size) {
  assertSize(size)
  return createBuffer(size < 0 ? 0 : checked(size) | 0)
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(size)
}

function fromString (string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('Unknown encoding: ' + encoding)
  }

  var length = byteLength(string, encoding) | 0
  var buf = createBuffer(length)

  var actual = buf.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    buf = buf.slice(0, actual)
  }

  return buf
}

function fromArrayLike (array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  var buf = createBuffer(length)
  for (var i = 0; i < length; i += 1) {
    buf[i] = array[i] & 255
  }
  return buf
}

function fromArrayBuffer (array, byteOffset, length) {
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('"offset" is outside of buffer bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('"length" is outside of buffer bounds')
  }

  var buf
  if (byteOffset === undefined && length === undefined) {
    buf = new Uint8Array(array)
  } else if (length === undefined) {
    buf = new Uint8Array(array, byteOffset)
  } else {
    buf = new Uint8Array(array, byteOffset, length)
  }

  // Return an augmented `Uint8Array` instance
  buf.__proto__ = Buffer.prototype
  return buf
}

function fromObject (obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    var buf = createBuffer(len)

    if (buf.length === 0) {
      return buf
    }

    obj.copy(buf, 0, 0, len)
    return buf
  }

  if (obj) {
    if (ArrayBuffer.isView(obj) || 'length' in obj) {
      if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
        return createBuffer(0)
      }
      return fromArrayLike(obj)
    }

    if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
      return fromArrayLike(obj.data)
    }
  }

  throw new TypeError('The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object.')
}

function checked (length) {
  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= K_MAX_LENGTH) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return b != null && b._isBuffer === true
}

Buffer.compare = function compare (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!Array.isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (ArrayBuffer.isView(buf)) {
      buf = Buffer.from(buf)
    }
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (ArrayBuffer.isView(string) || isArrayBuffer(string)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    string = '' + string
  }

  var len = string.length
  if (len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) return utf8ToBytes(string).length // assume utf8
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.toLocaleString = Buffer.prototype.toString

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max) str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('Argument must be a Buffer')
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset  // Coerce to Number.
  if (numberIsNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  var strLen = string.length

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (numberIsNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset >>> 0
    if (isFinite(length)) {
      length = length >>> 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
      : (firstByte > 0xBF) ? 2
      : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf = this.subarray(start, end)
  // Return an augmented `Uint8Array` instance
  newBuf.__proto__ = Buffer.prototype
  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset + 3] = (value >>> 24)
  this[offset + 2] = (value >>> 16)
  this[offset + 1] = (value >>> 8)
  this[offset] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  this[offset + 2] = (value >>> 16)
  this[offset + 3] = (value >>> 24)
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start

  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {
    // Use built-in when available, missing from IE11
    this.copyWithin(targetStart, start, end)
  } else if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (var i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, end),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if ((encoding === 'utf8' && code < 128) ||
          encoding === 'latin1') {
        // Fast path: If `val` fits into a single byte, use that numeric value.
        val = code
      }
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : new Buffer(val, encoding)
    var len = bytes.length
    if (len === 0) {
      throw new TypeError('The value "' + val +
        '" is invalid for argument "value"')
    }
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node takes equal signs as end of the Base64 encoding
  str = str.split('=')[0]
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = str.trim().replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

// ArrayBuffers from another context (i.e. an iframe) do not pass the `instanceof` check
// but they should be treated as valid. See: https://github.com/feross/buffer/issues/166
function isArrayBuffer (obj) {
  return obj instanceof ArrayBuffer ||
    (obj != null && obj.constructor != null && obj.constructor.name === 'ArrayBuffer' &&
      typeof obj.byteLength === 'number')
}

function numberIsNaN (obj) {
  return obj !== obj // eslint-disable-line no-self-compare
}

},{"base64-js":357,"ieee754":384}],360:[function(require,module,exports){
(function (process){
/**
 * This is the web browser implementation of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = require('./debug');
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = 'undefined' != typeof chrome
               && 'undefined' != typeof chrome.storage
                  ? chrome.storage.local
                  : localstorage();

/**
 * Colors.
 */

exports.colors = [
  '#0000CC', '#0000FF', '#0033CC', '#0033FF', '#0066CC', '#0066FF', '#0099CC',
  '#0099FF', '#00CC00', '#00CC33', '#00CC66', '#00CC99', '#00CCCC', '#00CCFF',
  '#3300CC', '#3300FF', '#3333CC', '#3333FF', '#3366CC', '#3366FF', '#3399CC',
  '#3399FF', '#33CC00', '#33CC33', '#33CC66', '#33CC99', '#33CCCC', '#33CCFF',
  '#6600CC', '#6600FF', '#6633CC', '#6633FF', '#66CC00', '#66CC33', '#9900CC',
  '#9900FF', '#9933CC', '#9933FF', '#99CC00', '#99CC33', '#CC0000', '#CC0033',
  '#CC0066', '#CC0099', '#CC00CC', '#CC00FF', '#CC3300', '#CC3333', '#CC3366',
  '#CC3399', '#CC33CC', '#CC33FF', '#CC6600', '#CC6633', '#CC9900', '#CC9933',
  '#CCCC00', '#CCCC33', '#FF0000', '#FF0033', '#FF0066', '#FF0099', '#FF00CC',
  '#FF00FF', '#FF3300', '#FF3333', '#FF3366', '#FF3399', '#FF33CC', '#FF33FF',
  '#FF6600', '#FF6633', '#FF9900', '#FF9933', '#FFCC00', '#FFCC33'
];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

function useColors() {
  // NB: In an Electron preload script, document will be defined but not fully
  // initialized. Since we know we're in Chrome, we'll just detect this case
  // explicitly
  if (typeof window !== 'undefined' && window.process && window.process.type === 'renderer') {
    return true;
  }

  // Internet Explorer and Edge do not support colors.
  if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
    return false;
  }

  // is webkit? http://stackoverflow.com/a/16459606/376773
  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
  return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||
    // is firebug? http://stackoverflow.com/a/398120/376773
    (typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||
    // is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||
    // double check webkit in userAgent just in case we are in a worker
    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
}

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

exports.formatters.j = function(v) {
  try {
    return JSON.stringify(v);
  } catch (err) {
    return '[UnexpectedJSONParseError]: ' + err.message;
  }
};


/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs(args) {
  var useColors = this.useColors;

  args[0] = (useColors ? '%c' : '')
    + this.namespace
    + (useColors ? ' %c' : ' ')
    + args[0]
    + (useColors ? '%c ' : ' ')
    + '+' + exports.humanize(this.diff);

  if (!useColors) return;

  var c = 'color: ' + this.color;
  args.splice(1, 0, c, 'color: inherit')

  // the final "%c" is somewhat tricky, because there could be other
  // arguments passed either before or after the %c, so we need to
  // figure out the correct index to insert the CSS into
  var index = 0;
  var lastC = 0;
  args[0].replace(/%[a-zA-Z%]/g, function(match) {
    if ('%%' === match) return;
    index++;
    if ('%c' === match) {
      // we only are interested in the *last* %c
      // (the user may have provided their own)
      lastC = index;
    }
  });

  args.splice(lastC, 0, c);
}

/**
 * Invokes `console.log()` when available.
 * No-op when `console.log` is not a "function".
 *
 * @api public
 */

function log() {
  // this hackery is required for IE8/9, where
  // the `console.log` function doesn't have 'apply'
  return 'object' === typeof console
    && console.log
    && Function.prototype.apply.call(console.log, console, arguments);
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */

function save(namespaces) {
  try {
    if (null == namespaces) {
      exports.storage.removeItem('debug');
    } else {
      exports.storage.debug = namespaces;
    }
  } catch(e) {}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
  var r;
  try {
    r = exports.storage.debug;
  } catch(e) {}

  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG
  if (!r && typeof process !== 'undefined' && 'env' in process) {
    r = process.env.DEBUG;
  }

  return r;
}

/**
 * Enable namespaces listed in `localStorage.debug` initially.
 */

exports.enable(load());

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage() {
  try {
    return window.localStorage;
  } catch (e) {}
}

}).call(this,require('_process'))
},{"./debug":361,"_process":458}],361:[function(require,module,exports){

/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = createDebug.debug = createDebug['default'] = createDebug;
exports.coerce = coerce;
exports.disable = disable;
exports.enable = enable;
exports.enabled = enabled;
exports.humanize = require('ms');

/**
 * Active `debug` instances.
 */
exports.instances = [];

/**
 * The currently active debug mode names, and names to skip.
 */

exports.names = [];
exports.skips = [];

/**
 * Map of special "%n" handling functions, for the debug "format" argument.
 *
 * Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
 */

exports.formatters = {};

/**
 * Select a color.
 * @param {String} namespace
 * @return {Number}
 * @api private
 */

function selectColor(namespace) {
  var hash = 0, i;

  for (i in namespace) {
    hash  = ((hash << 5) - hash) + namespace.charCodeAt(i);
    hash |= 0; // Convert to 32bit integer
  }

  return exports.colors[Math.abs(hash) % exports.colors.length];
}

/**
 * Create a debugger with the given `namespace`.
 *
 * @param {String} namespace
 * @return {Function}
 * @api public
 */

function createDebug(namespace) {

  var prevTime;

  function debug() {
    // disabled?
    if (!debug.enabled) return;

    var self = debug;

    // set `diff` timestamp
    var curr = +new Date();
    var ms = curr - (prevTime || curr);
    self.diff = ms;
    self.prev = prevTime;
    self.curr = curr;
    prevTime = curr;

    // turn the `arguments` into a proper Array
    var args = new Array(arguments.length);
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }

    args[0] = exports.coerce(args[0]);

    if ('string' !== typeof args[0]) {
      // anything else let's inspect with %O
      args.unshift('%O');
    }

    // apply any `formatters` transformations
    var index = 0;
    args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {
      // if we encounter an escaped % then don't increase the array index
      if (match === '%%') return match;
      index++;
      var formatter = exports.formatters[format];
      if ('function' === typeof formatter) {
        var val = args[index];
        match = formatter.call(self, val);

        // now we need to remove `args[index]` since it's inlined in the `format`
        args.splice(index, 1);
        index--;
      }
      return match;
    });

    // apply env-specific formatting (colors, etc.)
    exports.formatArgs.call(self, args);

    var logFn = debug.log || exports.log || console.log.bind(console);
    logFn.apply(self, args);
  }

  debug.namespace = namespace;
  debug.enabled = exports.enabled(namespace);
  debug.useColors = exports.useColors();
  debug.color = selectColor(namespace);
  debug.destroy = destroy;

  // env-specific initialization logic for debug instances
  if ('function' === typeof exports.init) {
    exports.init(debug);
  }

  exports.instances.push(debug);

  return debug;
}

function destroy () {
  var index = exports.instances.indexOf(this);
  if (index !== -1) {
    exports.instances.splice(index, 1);
    return true;
  } else {
    return false;
  }
}

/**
 * Enables a debug mode by namespaces. This can include modes
 * separated by a colon and wildcards.
 *
 * @param {String} namespaces
 * @api public
 */

function enable(namespaces) {
  exports.save(namespaces);

  exports.names = [];
  exports.skips = [];

  var i;
  var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
  var len = split.length;

  for (i = 0; i < len; i++) {
    if (!split[i]) continue; // ignore empty strings
    namespaces = split[i].replace(/\*/g, '.*?');
    if (namespaces[0] === '-') {
      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
    } else {
      exports.names.push(new RegExp('^' + namespaces + '$'));
    }
  }

  for (i = 0; i < exports.instances.length; i++) {
    var instance = exports.instances[i];
    instance.enabled = exports.enabled(instance.namespace);
  }
}

/**
 * Disable debug output.
 *
 * @api public
 */

function disable() {
  exports.enable('');
}

/**
 * Returns true if the given mode name is enabled, false otherwise.
 *
 * @param {String} name
 * @return {Boolean}
 * @api public
 */

function enabled(name) {
  if (name[name.length - 1] === '*') {
    return true;
  }
  var i, len;
  for (i = 0, len = exports.skips.length; i < len; i++) {
    if (exports.skips[i].test(name)) {
      return false;
    }
  }
  for (i = 0, len = exports.names.length; i < len; i++) {
    if (exports.names[i].test(name)) {
      return true;
    }
  }
  return false;
}

/**
 * Coerce `val`.
 *
 * @param {Mixed} val
 * @return {Mixed}
 * @api private
 */

function coerce(val) {
  if (val instanceof Error) return val.stack || val.message;
  return val;
}

},{"ms":457}],362:[function(require,module,exports){
/*!
  * domready (c) Dustin Diaz 2014 - License MIT
  */
!function (name, definition) {

  if (typeof module != 'undefined') module.exports = definition()
  else if (typeof define == 'function' && typeof define.amd == 'object') define(definition)
  else this[name] = definition()

}('domready', function () {

  var fns = [], listener
    , doc = document
    , hack = doc.documentElement.doScroll
    , domContentLoaded = 'DOMContentLoaded'
    , loaded = (hack ? /^loaded|^c/ : /^loaded|^i|^c/).test(doc.readyState)


  if (!loaded)
  doc.addEventListener(domContentLoaded, listener = function () {
    doc.removeEventListener(domContentLoaded, listener)
    loaded = 1
    while (listener = fns.shift()) listener()
  })

  return function (fn) {
    loaded ? setTimeout(fn, 0) : fns.push(fn)
  }

});

},{}],363:[function(require,module,exports){
/*!
 * escape-html
 * Copyright(c) 2012-2013 TJ Holowaychuk
 * Copyright(c) 2015 Andreas Lubbe
 * Copyright(c) 2015 Tiancheng "Timothy" Gu
 * MIT Licensed
 */

'use strict';

/**
 * Module variables.
 * @private
 */

var matchHtmlRegExp = /["'&<>]/;

/**
 * Module exports.
 * @public
 */

module.exports = escapeHtml;

/**
 * Escape special characters in the given string of html.
 *
 * @param  {string} string The string to escape for inserting into HTML
 * @return {string}
 * @public
 */

function escapeHtml(string) {
  var str = '' + string;
  var match = matchHtmlRegExp.exec(str);

  if (!match) {
    return str;
  }

  var escape;
  var html = '';
  var index = 0;
  var lastIndex = 0;

  for (index = match.index; index < str.length; index++) {
    switch (str.charCodeAt(index)) {
      case 34: // "
        escape = '&quot;';
        break;
      case 38: // &
        escape = '&amp;';
        break;
      case 39: // '
        escape = '&#39;';
        break;
      case 60: // <
        escape = '&lt;';
        break;
      case 62: // >
        escape = '&gt;';
        break;
      default:
        continue;
    }

    if (lastIndex !== index) {
      html += str.substring(lastIndex, index);
    }

    lastIndex = index + 1;
    html += escape;
  }

  return lastIndex !== index
    ? html + str.substring(lastIndex, index)
    : html;
}

},{}],364:[function(require,module,exports){
'use strict';

exports.__esModule = true;
// istanbul ignore next

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

// istanbul ignore next

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

var _handlebarsBase = require('./handlebars/base');

var base = _interopRequireWildcard(_handlebarsBase);

// Each of these augment the Handlebars object. No need to setup here.
// (This is done to easily share code between commonjs and browse envs)

var _handlebarsSafeString = require('./handlebars/safe-string');

var _handlebarsSafeString2 = _interopRequireDefault(_handlebarsSafeString);

var _handlebarsException = require('./handlebars/exception');

var _handlebarsException2 = _interopRequireDefault(_handlebarsException);

var _handlebarsUtils = require('./handlebars/utils');

var Utils = _interopRequireWildcard(_handlebarsUtils);

var _handlebarsRuntime = require('./handlebars/runtime');

var runtime = _interopRequireWildcard(_handlebarsRuntime);

var _handlebarsNoConflict = require('./handlebars/no-conflict');

var _handlebarsNoConflict2 = _interopRequireDefault(_handlebarsNoConflict);

// For compatibility and usage outside of module systems, make the Handlebars object a namespace
function create() {
  var hb = new base.HandlebarsEnvironment();

  Utils.extend(hb, base);
  hb.SafeString = _handlebarsSafeString2['default'];
  hb.Exception = _handlebarsException2['default'];
  hb.Utils = Utils;
  hb.escapeExpression = Utils.escapeExpression;

  hb.VM = runtime;
  hb.template = function (spec) {
    return runtime.template(spec, hb);
  };

  return hb;
}

var inst = create();
inst.create = create;

_handlebarsNoConflict2['default'](inst);

inst['default'] = inst;

exports['default'] = inst;
module.exports = exports['default'];


},{"./handlebars/base":365,"./handlebars/exception":368,"./handlebars/no-conflict":378,"./handlebars/runtime":379,"./handlebars/safe-string":380,"./handlebars/utils":381}],365:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports.HandlebarsEnvironment = HandlebarsEnvironment;
// istanbul ignore next

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _utils = require('./utils');

var _exception = require('./exception');

var _exception2 = _interopRequireDefault(_exception);

var _helpers = require('./helpers');

var _decorators = require('./decorators');

var _logger = require('./logger');

var _logger2 = _interopRequireDefault(_logger);

var VERSION = '4.0.11';
exports.VERSION = VERSION;
var COMPILER_REVISION = 7;

exports.COMPILER_REVISION = COMPILER_REVISION;
var REVISION_CHANGES = {
  1: '<= 1.0.rc.2', // 1.0.rc.2 is actually rev2 but doesn't report it
  2: '== 1.0.0-rc.3',
  3: '== 1.0.0-rc.4',
  4: '== 1.x.x',
  5: '== 2.0.0-alpha.x',
  6: '>= 2.0.0-beta.1',
  7: '>= 4.0.0'
};

exports.REVISION_CHANGES = REVISION_CHANGES;
var objectType = '[object Object]';

function HandlebarsEnvironment(helpers, partials, decorators) {
  this.helpers = helpers || {};
  this.partials = partials || {};
  this.decorators = decorators || {};

  _helpers.registerDefaultHelpers(this);
  _decorators.registerDefaultDecorators(this);
}

HandlebarsEnvironment.prototype = {
  constructor: HandlebarsEnvironment,

  logger: _logger2['default'],
  log: _logger2['default'].log,

  registerHelper: function registerHelper(name, fn) {
    if (_utils.toString.call(name) === objectType) {
      if (fn) {
        throw new _exception2['default']('Arg not supported with multiple helpers');
      }
      _utils.extend(this.helpers, name);
    } else {
      this.helpers[name] = fn;
    }
  },
  unregisterHelper: function unregisterHelper(name) {
    delete this.helpers[name];
  },

  registerPartial: function registerPartial(name, partial) {
    if (_utils.toString.call(name) === objectType) {
      _utils.extend(this.partials, name);
    } else {
      if (typeof partial === 'undefined') {
        throw new _exception2['default']('Attempting to register a partial called "' + name + '" as undefined');
      }
      this.partials[name] = partial;
    }
  },
  unregisterPartial: function unregisterPartial(name) {
    delete this.partials[name];
  },

  registerDecorator: function registerDecorator(name, fn) {
    if (_utils.toString.call(name) === objectType) {
      if (fn) {
        throw new _exception2['default']('Arg not supported with multiple decorators');
      }
      _utils.extend(this.decorators, name);
    } else {
      this.decorators[name] = fn;
    }
  },
  unregisterDecorator: function unregisterDecorator(name) {
    delete this.decorators[name];
  }
};

var log = _logger2['default'].log;

exports.log = log;
exports.createFrame = _utils.createFrame;
exports.logger = _logger2['default'];


},{"./decorators":366,"./exception":368,"./helpers":369,"./logger":377,"./utils":381}],366:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports.registerDefaultDecorators = registerDefaultDecorators;
// istanbul ignore next

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _decoratorsInline = require('./decorators/inline');

var _decoratorsInline2 = _interopRequireDefault(_decoratorsInline);

function registerDefaultDecorators(instance) {
  _decoratorsInline2['default'](instance);
}


},{"./decorators/inline":367}],367:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _utils = require('../utils');

exports['default'] = function (instance) {
  instance.registerDecorator('inline', function (fn, props, container, options) {
    var ret = fn;
    if (!props.partials) {
      props.partials = {};
      ret = function (context, options) {
        // Create a new partials stack frame prior to exec.
        var original = container.partials;
        container.partials = _utils.extend({}, original, props.partials);
        var ret = fn(context, options);
        container.partials = original;
        return ret;
      };
    }

    props.partials[options.args[0]] = options.fn;

    return ret;
  });
};

module.exports = exports['default'];


},{"../utils":381}],368:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var errorProps = ['description', 'fileName', 'lineNumber', 'message', 'name', 'number', 'stack'];

function Exception(message, node) {
  var loc = node && node.loc,
      line = undefined,
      column = undefined;
  if (loc) {
    line = loc.start.line;
    column = loc.start.column;

    message += ' - ' + line + ':' + column;
  }

  var tmp = Error.prototype.constructor.call(this, message);

  // Unfortunately errors are not enumerable in Chrome (at least), so `for prop in tmp` doesn't work.
  for (var idx = 0; idx < errorProps.length; idx++) {
    this[errorProps[idx]] = tmp[errorProps[idx]];
  }

  /* istanbul ignore else */
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, Exception);
  }

  try {
    if (loc) {
      this.lineNumber = line;

      // Work around issue under safari where we can't directly set the column value
      /* istanbul ignore next */
      if (Object.defineProperty) {
        Object.defineProperty(this, 'column', {
          value: column,
          enumerable: true
        });
      } else {
        this.column = column;
      }
    }
  } catch (nop) {
    /* Ignore if the browser is very particular */
  }
}

Exception.prototype = new Error();

exports['default'] = Exception;
module.exports = exports['default'];


},{}],369:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports.registerDefaultHelpers = registerDefaultHelpers;
// istanbul ignore next

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _helpersBlockHelperMissing = require('./helpers/block-helper-missing');

var _helpersBlockHelperMissing2 = _interopRequireDefault(_helpersBlockHelperMissing);

var _helpersEach = require('./helpers/each');

var _helpersEach2 = _interopRequireDefault(_helpersEach);

var _helpersHelperMissing = require('./helpers/helper-missing');

var _helpersHelperMissing2 = _interopRequireDefault(_helpersHelperMissing);

var _helpersIf = require('./helpers/if');

var _helpersIf2 = _interopRequireDefault(_helpersIf);

var _helpersLog = require('./helpers/log');

var _helpersLog2 = _interopRequireDefault(_helpersLog);

var _helpersLookup = require('./helpers/lookup');

var _helpersLookup2 = _interopRequireDefault(_helpersLookup);

var _helpersWith = require('./helpers/with');

var _helpersWith2 = _interopRequireDefault(_helpersWith);

function registerDefaultHelpers(instance) {
  _helpersBlockHelperMissing2['default'](instance);
  _helpersEach2['default'](instance);
  _helpersHelperMissing2['default'](instance);
  _helpersIf2['default'](instance);
  _helpersLog2['default'](instance);
  _helpersLookup2['default'](instance);
  _helpersWith2['default'](instance);
}


},{"./helpers/block-helper-missing":370,"./helpers/each":371,"./helpers/helper-missing":372,"./helpers/if":373,"./helpers/log":374,"./helpers/lookup":375,"./helpers/with":376}],370:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _utils = require('../utils');

exports['default'] = function (instance) {
  instance.registerHelper('blockHelperMissing', function (context, options) {
    var inverse = options.inverse,
        fn = options.fn;

    if (context === true) {
      return fn(this);
    } else if (context === false || context == null) {
      return inverse(this);
    } else if (_utils.isArray(context)) {
      if (context.length > 0) {
        if (options.ids) {
          options.ids = [options.name];
        }

        return instance.helpers.each(context, options);
      } else {
        return inverse(this);
      }
    } else {
      if (options.data && options.ids) {
        var data = _utils.createFrame(options.data);
        data.contextPath = _utils.appendContextPath(options.data.contextPath, options.name);
        options = { data: data };
      }

      return fn(context, options);
    }
  });
};

module.exports = exports['default'];


},{"../utils":381}],371:[function(require,module,exports){
'use strict';

exports.__esModule = true;
// istanbul ignore next

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _utils = require('../utils');

var _exception = require('../exception');

var _exception2 = _interopRequireDefault(_exception);

exports['default'] = function (instance) {
  instance.registerHelper('each', function (context, options) {
    if (!options) {
      throw new _exception2['default']('Must pass iterator to #each');
    }

    var fn = options.fn,
        inverse = options.inverse,
        i = 0,
        ret = '',
        data = undefined,
        contextPath = undefined;

    if (options.data && options.ids) {
      contextPath = _utils.appendContextPath(options.data.contextPath, options.ids[0]) + '.';
    }

    if (_utils.isFunction(context)) {
      context = context.call(this);
    }

    if (options.data) {
      data = _utils.createFrame(options.data);
    }

    function execIteration(field, index, last) {
      if (data) {
        data.key = field;
        data.index = index;
        data.first = index === 0;
        data.last = !!last;

        if (contextPath) {
          data.contextPath = contextPath + field;
        }
      }

      ret = ret + fn(context[field], {
        data: data,
        blockParams: _utils.blockParams([context[field], field], [contextPath + field, null])
      });
    }

    if (context && typeof context === 'object') {
      if (_utils.isArray(context)) {
        for (var j = context.length; i < j; i++) {
          if (i in context) {
            execIteration(i, i, i === context.length - 1);
          }
        }
      } else {
        var priorKey = undefined;

        for (var key in context) {
          if (context.hasOwnProperty(key)) {
            // We're running the iterations one step out of sync so we can detect
            // the last iteration without have to scan the object twice and create
            // an itermediate keys array.
            if (priorKey !== undefined) {
              execIteration(priorKey, i - 1);
            }
            priorKey = key;
            i++;
          }
        }
        if (priorKey !== undefined) {
          execIteration(priorKey, i - 1, true);
        }
      }
    }

    if (i === 0) {
      ret = inverse(this);
    }

    return ret;
  });
};

module.exports = exports['default'];


},{"../exception":368,"../utils":381}],372:[function(require,module,exports){
'use strict';

exports.__esModule = true;
// istanbul ignore next

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _exception = require('../exception');

var _exception2 = _interopRequireDefault(_exception);

exports['default'] = function (instance) {
  instance.registerHelper('helperMissing', function () /* [args, ]options */{
    if (arguments.length === 1) {
      // A missing field in a {{foo}} construct.
      return undefined;
    } else {
      // Someone is actually trying to call something, blow up.
      throw new _exception2['default']('Missing helper: "' + arguments[arguments.length - 1].name + '"');
    }
  });
};

module.exports = exports['default'];


},{"../exception":368}],373:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _utils = require('../utils');

exports['default'] = function (instance) {
  instance.registerHelper('if', function (conditional, options) {
    if (_utils.isFunction(conditional)) {
      conditional = conditional.call(this);
    }

    // Default behavior is to render the positive path if the value is truthy and not empty.
    // The `includeZero` option may be set to treat the condtional as purely not empty based on the
    // behavior of isEmpty. Effectively this determines if 0 is handled by the positive path or negative.
    if (!options.hash.includeZero && !conditional || _utils.isEmpty(conditional)) {
      return options.inverse(this);
    } else {
      return options.fn(this);
    }
  });

  instance.registerHelper('unless', function (conditional, options) {
    return instance.helpers['if'].call(this, conditional, { fn: options.inverse, inverse: options.fn, hash: options.hash });
  });
};

module.exports = exports['default'];


},{"../utils":381}],374:[function(require,module,exports){
'use strict';

exports.__esModule = true;

exports['default'] = function (instance) {
  instance.registerHelper('log', function () /* message, options */{
    var args = [undefined],
        options = arguments[arguments.length - 1];
    for (var i = 0; i < arguments.length - 1; i++) {
      args.push(arguments[i]);
    }

    var level = 1;
    if (options.hash.level != null) {
      level = options.hash.level;
    } else if (options.data && options.data.level != null) {
      level = options.data.level;
    }
    args[0] = level;

    instance.log.apply(instance, args);
  });
};

module.exports = exports['default'];


},{}],375:[function(require,module,exports){
'use strict';

exports.__esModule = true;

exports['default'] = function (instance) {
  instance.registerHelper('lookup', function (obj, field) {
    return obj && obj[field];
  });
};

module.exports = exports['default'];


},{}],376:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _utils = require('../utils');

exports['default'] = function (instance) {
  instance.registerHelper('with', function (context, options) {
    if (_utils.isFunction(context)) {
      context = context.call(this);
    }

    var fn = options.fn;

    if (!_utils.isEmpty(context)) {
      var data = options.data;
      if (options.data && options.ids) {
        data = _utils.createFrame(options.data);
        data.contextPath = _utils.appendContextPath(options.data.contextPath, options.ids[0]);
      }

      return fn(context, {
        data: data,
        blockParams: _utils.blockParams([context], [data && data.contextPath])
      });
    } else {
      return options.inverse(this);
    }
  });
};

module.exports = exports['default'];


},{"../utils":381}],377:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _utils = require('./utils');

var logger = {
  methodMap: ['debug', 'info', 'warn', 'error'],
  level: 'info',

  // Maps a given level value to the `methodMap` indexes above.
  lookupLevel: function lookupLevel(level) {
    if (typeof level === 'string') {
      var levelMap = _utils.indexOf(logger.methodMap, level.toLowerCase());
      if (levelMap >= 0) {
        level = levelMap;
      } else {
        level = parseInt(level, 10);
      }
    }

    return level;
  },

  // Can be overridden in the host environment
  log: function log(level) {
    level = logger.lookupLevel(level);

    if (typeof console !== 'undefined' && logger.lookupLevel(logger.level) <= level) {
      var method = logger.methodMap[level];
      if (!console[method]) {
        // eslint-disable-line no-console
        method = 'log';
      }

      for (var _len = arguments.length, message = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        message[_key - 1] = arguments[_key];
      }

      console[method].apply(console, message); // eslint-disable-line no-console
    }
  }
};

exports['default'] = logger;
module.exports = exports['default'];


},{"./utils":381}],378:[function(require,module,exports){
(function (global){
/* global window */
'use strict';

exports.__esModule = true;

exports['default'] = function (Handlebars) {
  /* istanbul ignore next */
  var root = typeof global !== 'undefined' ? global : window,
      $Handlebars = root.Handlebars;
  /* istanbul ignore next */
  Handlebars.noConflict = function () {
    if (root.Handlebars === Handlebars) {
      root.Handlebars = $Handlebars;
    }
    return Handlebars;
  };
};

module.exports = exports['default'];


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],379:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports.checkRevision = checkRevision;
exports.template = template;
exports.wrapProgram = wrapProgram;
exports.resolvePartial = resolvePartial;
exports.invokePartial = invokePartial;
exports.noop = noop;
// istanbul ignore next

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

// istanbul ignore next

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

var _utils = require('./utils');

var Utils = _interopRequireWildcard(_utils);

var _exception = require('./exception');

var _exception2 = _interopRequireDefault(_exception);

var _base = require('./base');

function checkRevision(compilerInfo) {
  var compilerRevision = compilerInfo && compilerInfo[0] || 1,
      currentRevision = _base.COMPILER_REVISION;

  if (compilerRevision !== currentRevision) {
    if (compilerRevision < currentRevision) {
      var runtimeVersions = _base.REVISION_CHANGES[currentRevision],
          compilerVersions = _base.REVISION_CHANGES[compilerRevision];
      throw new _exception2['default']('Template was precompiled with an older version of Handlebars than the current runtime. ' + 'Please update your precompiler to a newer version (' + runtimeVersions + ') or downgrade your runtime to an older version (' + compilerVersions + ').');
    } else {
      // Use the embedded version info since the runtime doesn't know about this revision yet
      throw new _exception2['default']('Template was precompiled with a newer version of Handlebars than the current runtime. ' + 'Please update your runtime to a newer version (' + compilerInfo[1] + ').');
    }
  }
}

function template(templateSpec, env) {
  /* istanbul ignore next */
  if (!env) {
    throw new _exception2['default']('No environment passed to template');
  }
  if (!templateSpec || !templateSpec.main) {
    throw new _exception2['default']('Unknown template object: ' + typeof templateSpec);
  }

  templateSpec.main.decorator = templateSpec.main_d;

  // Note: Using env.VM references rather than local var references throughout this section to allow
  // for external users to override these as psuedo-supported APIs.
  env.VM.checkRevision(templateSpec.compiler);

  function invokePartialWrapper(partial, context, options) {
    if (options.hash) {
      context = Utils.extend({}, context, options.hash);
      if (options.ids) {
        options.ids[0] = true;
      }
    }

    partial = env.VM.resolvePartial.call(this, partial, context, options);
    var result = env.VM.invokePartial.call(this, partial, context, options);

    if (result == null && env.compile) {
      options.partials[options.name] = env.compile(partial, templateSpec.compilerOptions, env);
      result = options.partials[options.name](context, options);
    }
    if (result != null) {
      if (options.indent) {
        var lines = result.split('\n');
        for (var i = 0, l = lines.length; i < l; i++) {
          if (!lines[i] && i + 1 === l) {
            break;
          }

          lines[i] = options.indent + lines[i];
        }
        result = lines.join('\n');
      }
      return result;
    } else {
      throw new _exception2['default']('The partial ' + options.name + ' could not be compiled when running in runtime-only mode');
    }
  }

  // Just add water
  var container = {
    strict: function strict(obj, name) {
      if (!(name in obj)) {
        throw new _exception2['default']('"' + name + '" not defined in ' + obj);
      }
      return obj[name];
    },
    lookup: function lookup(depths, name) {
      var len = depths.length;
      for (var i = 0; i < len; i++) {
        if (depths[i] && depths[i][name] != null) {
          return depths[i][name];
        }
      }
    },
    lambda: function lambda(current, context) {
      return typeof current === 'function' ? current.call(context) : current;
    },

    escapeExpression: Utils.escapeExpression,
    invokePartial: invokePartialWrapper,

    fn: function fn(i) {
      var ret = templateSpec[i];
      ret.decorator = templateSpec[i + '_d'];
      return ret;
    },

    programs: [],
    program: function program(i, data, declaredBlockParams, blockParams, depths) {
      var programWrapper = this.programs[i],
          fn = this.fn(i);
      if (data || depths || blockParams || declaredBlockParams) {
        programWrapper = wrapProgram(this, i, fn, data, declaredBlockParams, blockParams, depths);
      } else if (!programWrapper) {
        programWrapper = this.programs[i] = wrapProgram(this, i, fn);
      }
      return programWrapper;
    },

    data: function data(value, depth) {
      while (value && depth--) {
        value = value._parent;
      }
      return value;
    },
    merge: function merge(param, common) {
      var obj = param || common;

      if (param && common && param !== common) {
        obj = Utils.extend({}, common, param);
      }

      return obj;
    },
    // An empty object to use as replacement for null-contexts
    nullContext: Object.seal({}),

    noop: env.VM.noop,
    compilerInfo: templateSpec.compiler
  };

  function ret(context) {
    var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

    var data = options.data;

    ret._setup(options);
    if (!options.partial && templateSpec.useData) {
      data = initData(context, data);
    }
    var depths = undefined,
        blockParams = templateSpec.useBlockParams ? [] : undefined;
    if (templateSpec.useDepths) {
      if (options.depths) {
        depths = context != options.depths[0] ? [context].concat(options.depths) : options.depths;
      } else {
        depths = [context];
      }
    }

    function main(context /*, options*/) {
      return '' + templateSpec.main(container, context, container.helpers, container.partials, data, blockParams, depths);
    }
    main = executeDecorators(templateSpec.main, main, container, options.depths || [], data, blockParams);
    return main(context, options);
  }
  ret.isTop = true;

  ret._setup = function (options) {
    if (!options.partial) {
      container.helpers = container.merge(options.helpers, env.helpers);

      if (templateSpec.usePartial) {
        container.partials = container.merge(options.partials, env.partials);
      }
      if (templateSpec.usePartial || templateSpec.useDecorators) {
        container.decorators = container.merge(options.decorators, env.decorators);
      }
    } else {
      container.helpers = options.helpers;
      container.partials = options.partials;
      container.decorators = options.decorators;
    }
  };

  ret._child = function (i, data, blockParams, depths) {
    if (templateSpec.useBlockParams && !blockParams) {
      throw new _exception2['default']('must pass block params');
    }
    if (templateSpec.useDepths && !depths) {
      throw new _exception2['default']('must pass parent depths');
    }

    return wrapProgram(container, i, templateSpec[i], data, 0, blockParams, depths);
  };
  return ret;
}

function wrapProgram(container, i, fn, data, declaredBlockParams, blockParams, depths) {
  function prog(context) {
    var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

    var currentDepths = depths;
    if (depths && context != depths[0] && !(context === container.nullContext && depths[0] === null)) {
      currentDepths = [context].concat(depths);
    }

    return fn(container, context, container.helpers, container.partials, options.data || data, blockParams && [options.blockParams].concat(blockParams), currentDepths);
  }

  prog = executeDecorators(fn, prog, container, depths, data, blockParams);

  prog.program = i;
  prog.depth = depths ? depths.length : 0;
  prog.blockParams = declaredBlockParams || 0;
  return prog;
}

function resolvePartial(partial, context, options) {
  if (!partial) {
    if (options.name === '@partial-block') {
      partial = options.data['partial-block'];
    } else {
      partial = options.partials[options.name];
    }
  } else if (!partial.call && !options.name) {
    // This is a dynamic partial that returned a string
    options.name = partial;
    partial = options.partials[partial];
  }
  return partial;
}

function invokePartial(partial, context, options) {
  // Use the current closure context to save the partial-block if this partial
  var currentPartialBlock = options.data && options.data['partial-block'];
  options.partial = true;
  if (options.ids) {
    options.data.contextPath = options.ids[0] || options.data.contextPath;
  }

  var partialBlock = undefined;
  if (options.fn && options.fn !== noop) {
    (function () {
      options.data = _base.createFrame(options.data);
      // Wrapper function to get access to currentPartialBlock from the closure
      var fn = options.fn;
      partialBlock = options.data['partial-block'] = function partialBlockWrapper(context) {
        var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

        // Restore the partial-block from the closure for the execution of the block
        // i.e. the part inside the block of the partial call.
        options.data = _base.createFrame(options.data);
        options.data['partial-block'] = currentPartialBlock;
        return fn(context, options);
      };
      if (fn.partials) {
        options.partials = Utils.extend({}, options.partials, fn.partials);
      }
    })();
  }

  if (partial === undefined && partialBlock) {
    partial = partialBlock;
  }

  if (partial === undefined) {
    throw new _exception2['default']('The partial ' + options.name + ' could not be found');
  } else if (partial instanceof Function) {
    return partial(context, options);
  }
}

function noop() {
  return '';
}

function initData(context, data) {
  if (!data || !('root' in data)) {
    data = data ? _base.createFrame(data) : {};
    data.root = context;
  }
  return data;
}

function executeDecorators(fn, prog, container, depths, data, blockParams) {
  if (fn.decorator) {
    var props = {};
    prog = fn.decorator(prog, props, container, depths && depths[0], data, blockParams, depths);
    Utils.extend(prog, props);
  }
  return prog;
}


},{"./base":365,"./exception":368,"./utils":381}],380:[function(require,module,exports){
// Build out our basic SafeString type
'use strict';

exports.__esModule = true;
function SafeString(string) {
  this.string = string;
}

SafeString.prototype.toString = SafeString.prototype.toHTML = function () {
  return '' + this.string;
};

exports['default'] = SafeString;
module.exports = exports['default'];


},{}],381:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports.extend = extend;
exports.indexOf = indexOf;
exports.escapeExpression = escapeExpression;
exports.isEmpty = isEmpty;
exports.createFrame = createFrame;
exports.blockParams = blockParams;
exports.appendContextPath = appendContextPath;
var escape = {
  '&': '&amp;',
  '<': '&lt;',
  '>': '&gt;',
  '"': '&quot;',
  "'": '&#x27;',
  '`': '&#x60;',
  '=': '&#x3D;'
};

var badChars = /[&<>"'`=]/g,
    possible = /[&<>"'`=]/;

function escapeChar(chr) {
  return escape[chr];
}

function extend(obj /* , ...source */) {
  for (var i = 1; i < arguments.length; i++) {
    for (var key in arguments[i]) {
      if (Object.prototype.hasOwnProperty.call(arguments[i], key)) {
        obj[key] = arguments[i][key];
      }
    }
  }

  return obj;
}

var toString = Object.prototype.toString;

exports.toString = toString;
// Sourced from lodash
// https://github.com/bestiejs/lodash/blob/master/LICENSE.txt
/* eslint-disable func-style */
var isFunction = function isFunction(value) {
  return typeof value === 'function';
};
// fallback for older versions of Chrome and Safari
/* istanbul ignore next */
if (isFunction(/x/)) {
  exports.isFunction = isFunction = function (value) {
    return typeof value === 'function' && toString.call(value) === '[object Function]';
  };
}
exports.isFunction = isFunction;

/* eslint-enable func-style */

/* istanbul ignore next */
var isArray = Array.isArray || function (value) {
  return value && typeof value === 'object' ? toString.call(value) === '[object Array]' : false;
};

exports.isArray = isArray;
// Older IE versions do not directly support indexOf so we must implement our own, sadly.

function indexOf(array, value) {
  for (var i = 0, len = array.length; i < len; i++) {
    if (array[i] === value) {
      return i;
    }
  }
  return -1;
}

function escapeExpression(string) {
  if (typeof string !== 'string') {
    // don't escape SafeStrings, since they're already safe
    if (string && string.toHTML) {
      return string.toHTML();
    } else if (string == null) {
      return '';
    } else if (!string) {
      return string + '';
    }

    // Force a string conversion as this will be done by the append regardless and
    // the regex test will do this transparently behind the scenes, causing issues if
    // an object's to string has escaped characters in it.
    string = '' + string;
  }

  if (!possible.test(string)) {
    return string;
  }
  return string.replace(badChars, escapeChar);
}

function isEmpty(value) {
  if (!value && value !== 0) {
    return true;
  } else if (isArray(value) && value.length === 0) {
    return true;
  } else {
    return false;
  }
}

function createFrame(object) {
  var frame = extend({}, object);
  frame._parent = object;
  return frame;
}

function blockParams(params, ids) {
  params.path = ids;
  return params;
}

function appendContextPath(contextPath, id) {
  return (contextPath ? contextPath + '.' : '') + id;
}


},{}],382:[function(require,module,exports){
// Create a simple path alias to allow browserify to resolve
// the runtime on a supported path.
module.exports = require('./dist/cjs/handlebars.runtime')['default'];

},{"./dist/cjs/handlebars.runtime":364}],383:[function(require,module,exports){
module.exports = require("handlebars/runtime")["default"];

},{"handlebars/runtime":382}],384:[function(require,module,exports){
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

},{}],385:[function(require,module,exports){
var json = typeof JSON !== 'undefined' ? JSON : require('jsonify');

module.exports = function (obj, opts) {
    if (!opts) opts = {};
    if (typeof opts === 'function') opts = { cmp: opts };
    var space = opts.space || '';
    if (typeof space === 'number') space = Array(space+1).join(' ');
    var cycles = (typeof opts.cycles === 'boolean') ? opts.cycles : false;
    var replacer = opts.replacer || function(key, value) { return value; };

    var cmp = opts.cmp && (function (f) {
        return function (node) {
            return function (a, b) {
                var aobj = { key: a, value: node[a] };
                var bobj = { key: b, value: node[b] };
                return f(aobj, bobj);
            };
        };
    })(opts.cmp);

    var seen = [];
    return (function stringify (parent, key, node, level) {
        var indent = space ? ('\n' + new Array(level + 1).join(space)) : '';
        var colonSeparator = space ? ': ' : ':';

        if (node && node.toJSON && typeof node.toJSON === 'function') {
            node = node.toJSON();
        }

        node = replacer.call(parent, key, node);

        if (node === undefined) {
            return;
        }
        if (typeof node !== 'object' || node === null) {
            return json.stringify(node);
        }
        if (isArray(node)) {
            var out = [];
            for (var i = 0; i < node.length; i++) {
                var item = stringify(node, i, node[i], level+1) || json.stringify(null);
                out.push(indent + space + item);
            }
            return '[' + out.join(',') + indent + ']';
        }
        else {
            if (seen.indexOf(node) !== -1) {
                if (cycles) return json.stringify('__cycle__');
                throw new TypeError('Converting circular structure to JSON');
            }
            else seen.push(node);

            var keys = objectKeys(node).sort(cmp && cmp(node));
            var out = [];
            for (var i = 0; i < keys.length; i++) {
                var key = keys[i];
                var value = stringify(node, key, node[key], level+1);

                if(!value) continue;

                var keyValue = json.stringify(key)
                    + colonSeparator
                    + value;
                ;
                out.push(indent + space + keyValue);
            }
            seen.splice(seen.indexOf(node), 1);
            return '{' + out.join(',') + indent + '}';
        }
    })({ '': obj }, '', obj, 0);
};

var isArray = Array.isArray || function (x) {
    return {}.toString.call(x) === '[object Array]';
};

var objectKeys = Object.keys || function (obj) {
    var has = Object.prototype.hasOwnProperty || function () { return true };
    var keys = [];
    for (var key in obj) {
        if (has.call(obj, key)) keys.push(key);
    }
    return keys;
};

},{"jsonify":386}],386:[function(require,module,exports){
exports.parse = JSON.parse;
exports.stringify = JSON.stringify;

},{}],387:[function(require,module,exports){
//! moment.js locale configuration

;(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined'
       && typeof require === 'function' ? factory(require('../moment')) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var symbolMap = {
        '1': '١',
        '2': '٢',
        '3': '٣',
        '4': '٤',
        '5': '٥',
        '6': '٦',
        '7': '٧',
        '8': '٨',
        '9': '٩',
        '0': '٠'
    }, numberMap = {
        '١': '1',
        '٢': '2',
        '٣': '3',
        '٤': '4',
        '٥': '5',
        '٦': '6',
        '٧': '7',
        '٨': '8',
        '٩': '9',
        '٠': '0'
    }, pluralForm = function (n) {
        return n === 0 ? 0 : n === 1 ? 1 : n === 2 ? 2 : n % 100 >= 3 && n % 100 <= 10 ? 3 : n % 100 >= 11 ? 4 : 5;
    }, plurals = {
        s : ['أقل من ثانية', 'ثانية واحدة', ['ثانيتان', 'ثانيتين'], '%d ثوان', '%d ثانية', '%d ثانية'],
        m : ['أقل من دقيقة', 'دقيقة واحدة', ['دقيقتان', 'دقيقتين'], '%d دقائق', '%d دقيقة', '%d دقيقة'],
        h : ['أقل من ساعة', 'ساعة واحدة', ['ساعتان', 'ساعتين'], '%d ساعات', '%d ساعة', '%d ساعة'],
        d : ['أقل من يوم', 'يوم واحد', ['يومان', 'يومين'], '%d أيام', '%d يومًا', '%d يوم'],
        M : ['أقل من شهر', 'شهر واحد', ['شهران', 'شهرين'], '%d أشهر', '%d شهرا', '%d شهر'],
        y : ['أقل من عام', 'عام واحد', ['عامان', 'عامين'], '%d أعوام', '%d عامًا', '%d عام']
    }, pluralize = function (u) {
        return function (number, withoutSuffix, string, isFuture) {
            var f = pluralForm(number),
                str = plurals[u][pluralForm(number)];
            if (f === 2) {
                str = str[withoutSuffix ? 0 : 1];
            }
            return str.replace(/%d/i, number);
        };
    }, months = [
        'يناير',
        'فبراير',
        'مارس',
        'أبريل',
        'مايو',
        'يونيو',
        'يوليو',
        'أغسطس',
        'سبتمبر',
        'أكتوبر',
        'نوفمبر',
        'ديسمبر'
    ];

    var ar = moment.defineLocale('ar', {
        months : months,
        monthsShort : months,
        weekdays : 'الأحد_الإثنين_الثلاثاء_الأربعاء_الخميس_الجمعة_السبت'.split('_'),
        weekdaysShort : 'أحد_إثنين_ثلاثاء_أربعاء_خميس_جمعة_سبت'.split('_'),
        weekdaysMin : 'ح_ن_ث_ر_خ_ج_س'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'D/\u200FM/\u200FYYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd D MMMM YYYY HH:mm'
        },
        meridiemParse: /ص|م/,
        isPM : function (input) {
            return 'م' === input;
        },
        meridiem : function (hour, minute, isLower) {
            if (hour < 12) {
                return 'ص';
            } else {
                return 'م';
            }
        },
        calendar : {
            sameDay: '[اليوم عند الساعة] LT',
            nextDay: '[غدًا عند الساعة] LT',
            nextWeek: 'dddd [عند الساعة] LT',
            lastDay: '[أمس عند الساعة] LT',
            lastWeek: 'dddd [عند الساعة] LT',
            sameElse: 'L'
        },
        relativeTime : {
            future : 'بعد %s',
            past : 'منذ %s',
            s : pluralize('s'),
            ss : pluralize('s'),
            m : pluralize('m'),
            mm : pluralize('m'),
            h : pluralize('h'),
            hh : pluralize('h'),
            d : pluralize('d'),
            dd : pluralize('d'),
            M : pluralize('M'),
            MM : pluralize('M'),
            y : pluralize('y'),
            yy : pluralize('y')
        },
        preparse: function (string) {
            return string.replace(/[١٢٣٤٥٦٧٨٩٠]/g, function (match) {
                return numberMap[match];
            }).replace(/،/g, ',');
        },
        postformat: function (string) {
            return string.replace(/\d/g, function (match) {
                return symbolMap[match];
            }).replace(/,/g, '،');
        },
        week : {
            dow : 6, // Saturday is the first day of the week.
            doy : 12  // The week that contains Jan 1st is the first week of the year.
        }
    });

    return ar;

})));

},{"../moment":408}],388:[function(require,module,exports){
//! moment.js locale configuration

;(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined'
       && typeof require === 'function' ? factory(require('../moment')) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var months = 'leden_únor_březen_duben_květen_červen_červenec_srpen_září_říjen_listopad_prosinec'.split('_'),
        monthsShort = 'led_úno_bře_dub_kvě_čvn_čvc_srp_zář_říj_lis_pro'.split('_');
    function plural(n) {
        return (n > 1) && (n < 5) && (~~(n / 10) !== 1);
    }
    function translate(number, withoutSuffix, key, isFuture) {
        var result = number + ' ';
        switch (key) {
            case 's':  // a few seconds / in a few seconds / a few seconds ago
                return (withoutSuffix || isFuture) ? 'pár sekund' : 'pár sekundami';
            case 'ss': // 9 seconds / in 9 seconds / 9 seconds ago
                if (withoutSuffix || isFuture) {
                    return result + (plural(number) ? 'sekundy' : 'sekund');
                } else {
                    return result + 'sekundami';
                }
                break;
            case 'm':  // a minute / in a minute / a minute ago
                return withoutSuffix ? 'minuta' : (isFuture ? 'minutu' : 'minutou');
            case 'mm': // 9 minutes / in 9 minutes / 9 minutes ago
                if (withoutSuffix || isFuture) {
                    return result + (plural(number) ? 'minuty' : 'minut');
                } else {
                    return result + 'minutami';
                }
                break;
            case 'h':  // an hour / in an hour / an hour ago
                return withoutSuffix ? 'hodina' : (isFuture ? 'hodinu' : 'hodinou');
            case 'hh': // 9 hours / in 9 hours / 9 hours ago
                if (withoutSuffix || isFuture) {
                    return result + (plural(number) ? 'hodiny' : 'hodin');
                } else {
                    return result + 'hodinami';
                }
                break;
            case 'd':  // a day / in a day / a day ago
                return (withoutSuffix || isFuture) ? 'den' : 'dnem';
            case 'dd': // 9 days / in 9 days / 9 days ago
                if (withoutSuffix || isFuture) {
                    return result + (plural(number) ? 'dny' : 'dní');
                } else {
                    return result + 'dny';
                }
                break;
            case 'M':  // a month / in a month / a month ago
                return (withoutSuffix || isFuture) ? 'měsíc' : 'měsícem';
            case 'MM': // 9 months / in 9 months / 9 months ago
                if (withoutSuffix || isFuture) {
                    return result + (plural(number) ? 'měsíce' : 'měsíců');
                } else {
                    return result + 'měsíci';
                }
                break;
            case 'y':  // a year / in a year / a year ago
                return (withoutSuffix || isFuture) ? 'rok' : 'rokem';
            case 'yy': // 9 years / in 9 years / 9 years ago
                if (withoutSuffix || isFuture) {
                    return result + (plural(number) ? 'roky' : 'let');
                } else {
                    return result + 'lety';
                }
                break;
        }
    }

    var cs = moment.defineLocale('cs', {
        months : months,
        monthsShort : monthsShort,
        monthsParse : (function (months, monthsShort) {
            var i, _monthsParse = [];
            for (i = 0; i < 12; i++) {
                // use custom parser to solve problem with July (červenec)
                _monthsParse[i] = new RegExp('^' + months[i] + '$|^' + monthsShort[i] + '$', 'i');
            }
            return _monthsParse;
        }(months, monthsShort)),
        shortMonthsParse : (function (monthsShort) {
            var i, _shortMonthsParse = [];
            for (i = 0; i < 12; i++) {
                _shortMonthsParse[i] = new RegExp('^' + monthsShort[i] + '$', 'i');
            }
            return _shortMonthsParse;
        }(monthsShort)),
        longMonthsParse : (function (months) {
            var i, _longMonthsParse = [];
            for (i = 0; i < 12; i++) {
                _longMonthsParse[i] = new RegExp('^' + months[i] + '$', 'i');
            }
            return _longMonthsParse;
        }(months)),
        weekdays : 'neděle_pondělí_úterý_středa_čtvrtek_pátek_sobota'.split('_'),
        weekdaysShort : 'ne_po_út_st_čt_pá_so'.split('_'),
        weekdaysMin : 'ne_po_út_st_čt_pá_so'.split('_'),
        longDateFormat : {
            LT: 'H:mm',
            LTS : 'H:mm:ss',
            L : 'DD.MM.YYYY',
            LL : 'D. MMMM YYYY',
            LLL : 'D. MMMM YYYY H:mm',
            LLLL : 'dddd D. MMMM YYYY H:mm',
            l : 'D. M. YYYY'
        },
        calendar : {
            sameDay: '[dnes v] LT',
            nextDay: '[zítra v] LT',
            nextWeek: function () {
                switch (this.day()) {
                    case 0:
                        return '[v neděli v] LT';
                    case 1:
                    case 2:
                        return '[v] dddd [v] LT';
                    case 3:
                        return '[ve středu v] LT';
                    case 4:
                        return '[ve čtvrtek v] LT';
                    case 5:
                        return '[v pátek v] LT';
                    case 6:
                        return '[v sobotu v] LT';
                }
            },
            lastDay: '[včera v] LT',
            lastWeek: function () {
                switch (this.day()) {
                    case 0:
                        return '[minulou neděli v] LT';
                    case 1:
                    case 2:
                        return '[minulé] dddd [v] LT';
                    case 3:
                        return '[minulou středu v] LT';
                    case 4:
                    case 5:
                        return '[minulý] dddd [v] LT';
                    case 6:
                        return '[minulou sobotu v] LT';
                }
            },
            sameElse: 'L'
        },
        relativeTime : {
            future : 'za %s',
            past : 'před %s',
            s : translate,
            ss : translate,
            m : translate,
            mm : translate,
            h : translate,
            hh : translate,
            d : translate,
            dd : translate,
            M : translate,
            MM : translate,
            y : translate,
            yy : translate
        },
        dayOfMonthOrdinalParse : /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return cs;

})));

},{"../moment":408}],389:[function(require,module,exports){
//! moment.js locale configuration

;(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined'
       && typeof require === 'function' ? factory(require('../moment')) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    function processRelativeTime(number, withoutSuffix, key, isFuture) {
        var format = {
            'm': ['eine Minute', 'einer Minute'],
            'h': ['eine Stunde', 'einer Stunde'],
            'd': ['ein Tag', 'einem Tag'],
            'dd': [number + ' Tage', number + ' Tagen'],
            'M': ['ein Monat', 'einem Monat'],
            'MM': [number + ' Monate', number + ' Monaten'],
            'y': ['ein Jahr', 'einem Jahr'],
            'yy': [number + ' Jahre', number + ' Jahren']
        };
        return withoutSuffix ? format[key][0] : format[key][1];
    }

    var de = moment.defineLocale('de', {
        months : 'Januar_Februar_März_April_Mai_Juni_Juli_August_September_Oktober_November_Dezember'.split('_'),
        monthsShort : 'Jan._Feb._März_Apr._Mai_Juni_Juli_Aug._Sep._Okt._Nov._Dez.'.split('_'),
        monthsParseExact : true,
        weekdays : 'Sonntag_Montag_Dienstag_Mittwoch_Donnerstag_Freitag_Samstag'.split('_'),
        weekdaysShort : 'So._Mo._Di._Mi._Do._Fr._Sa.'.split('_'),
        weekdaysMin : 'So_Mo_Di_Mi_Do_Fr_Sa'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L : 'DD.MM.YYYY',
            LL : 'D. MMMM YYYY',
            LLL : 'D. MMMM YYYY HH:mm',
            LLLL : 'dddd, D. MMMM YYYY HH:mm'
        },
        calendar : {
            sameDay: '[heute um] LT [Uhr]',
            sameElse: 'L',
            nextDay: '[morgen um] LT [Uhr]',
            nextWeek: 'dddd [um] LT [Uhr]',
            lastDay: '[gestern um] LT [Uhr]',
            lastWeek: '[letzten] dddd [um] LT [Uhr]'
        },
        relativeTime : {
            future : 'in %s',
            past : 'vor %s',
            s : 'ein paar Sekunden',
            ss : '%d Sekunden',
            m : processRelativeTime,
            mm : '%d Minuten',
            h : processRelativeTime,
            hh : '%d Stunden',
            d : processRelativeTime,
            dd : processRelativeTime,
            M : processRelativeTime,
            MM : processRelativeTime,
            y : processRelativeTime,
            yy : processRelativeTime
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return de;

})));

},{"../moment":408}],390:[function(require,module,exports){
//! moment.js locale configuration

;(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined'
       && typeof require === 'function' ? factory(require('../moment')) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';

    function isFunction(input) {
        return input instanceof Function || Object.prototype.toString.call(input) === '[object Function]';
    }


    var el = moment.defineLocale('el', {
        monthsNominativeEl : 'Ιανουάριος_Φεβρουάριος_Μάρτιος_Απρίλιος_Μάιος_Ιούνιος_Ιούλιος_Αύγουστος_Σεπτέμβριος_Οκτώβριος_Νοέμβριος_Δεκέμβριος'.split('_'),
        monthsGenitiveEl : 'Ιανουαρίου_Φεβρουαρίου_Μαρτίου_Απριλίου_Μαΐου_Ιουνίου_Ιουλίου_Αυγούστου_Σεπτεμβρίου_Οκτωβρίου_Νοεμβρίου_Δεκεμβρίου'.split('_'),
        months : function (momentToFormat, format) {
            if (!momentToFormat) {
                return this._monthsNominativeEl;
            } else if (typeof format === 'string' && /D/.test(format.substring(0, format.indexOf('MMMM')))) { // if there is a day number before 'MMMM'
                return this._monthsGenitiveEl[momentToFormat.month()];
            } else {
                return this._monthsNominativeEl[momentToFormat.month()];
            }
        },
        monthsShort : 'Ιαν_Φεβ_Μαρ_Απρ_Μαϊ_Ιουν_Ιουλ_Αυγ_Σεπ_Οκτ_Νοε_Δεκ'.split('_'),
        weekdays : 'Κυριακή_Δευτέρα_Τρίτη_Τετάρτη_Πέμπτη_Παρασκευή_Σάββατο'.split('_'),
        weekdaysShort : 'Κυρ_Δευ_Τρι_Τετ_Πεμ_Παρ_Σαβ'.split('_'),
        weekdaysMin : 'Κυ_Δε_Τρ_Τε_Πε_Πα_Σα'.split('_'),
        meridiem : function (hours, minutes, isLower) {
            if (hours > 11) {
                return isLower ? 'μμ' : 'ΜΜ';
            } else {
                return isLower ? 'πμ' : 'ΠΜ';
            }
        },
        isPM : function (input) {
            return ((input + '').toLowerCase()[0] === 'μ');
        },
        meridiemParse : /[ΠΜ]\.?Μ?\.?/i,
        longDateFormat : {
            LT : 'h:mm A',
            LTS : 'h:mm:ss A',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY h:mm A',
            LLLL : 'dddd, D MMMM YYYY h:mm A'
        },
        calendarEl : {
            sameDay : '[Σήμερα {}] LT',
            nextDay : '[Αύριο {}] LT',
            nextWeek : 'dddd [{}] LT',
            lastDay : '[Χθες {}] LT',
            lastWeek : function () {
                switch (this.day()) {
                    case 6:
                        return '[το προηγούμενο] dddd [{}] LT';
                    default:
                        return '[την προηγούμενη] dddd [{}] LT';
                }
            },
            sameElse : 'L'
        },
        calendar : function (key, mom) {
            var output = this._calendarEl[key],
                hours = mom && mom.hours();
            if (isFunction(output)) {
                output = output.apply(mom);
            }
            return output.replace('{}', (hours % 12 === 1 ? 'στη' : 'στις'));
        },
        relativeTime : {
            future : 'σε %s',
            past : '%s πριν',
            s : 'λίγα δευτερόλεπτα',
            ss : '%d δευτερόλεπτα',
            m : 'ένα λεπτό',
            mm : '%d λεπτά',
            h : 'μία ώρα',
            hh : '%d ώρες',
            d : 'μία μέρα',
            dd : '%d μέρες',
            M : 'ένας μήνας',
            MM : '%d μήνες',
            y : 'ένας χρόνος',
            yy : '%d χρόνια'
        },
        dayOfMonthOrdinalParse: /\d{1,2}η/,
        ordinal: '%dη',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4st is the first week of the year.
        }
    });

    return el;

})));

},{"../moment":408}],391:[function(require,module,exports){
//! moment.js locale configuration

;(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined'
       && typeof require === 'function' ? factory(require('../moment')) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var monthsShortDot = 'ene._feb._mar._abr._may._jun._jul._ago._sep._oct._nov._dic.'.split('_'),
        monthsShort = 'ene_feb_mar_abr_may_jun_jul_ago_sep_oct_nov_dic'.split('_');

    var monthsParse = [/^ene/i, /^feb/i, /^mar/i, /^abr/i, /^may/i, /^jun/i, /^jul/i, /^ago/i, /^sep/i, /^oct/i, /^nov/i, /^dic/i];
    var monthsRegex = /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre|ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i;

    var es = moment.defineLocale('es', {
        months : 'enero_febrero_marzo_abril_mayo_junio_julio_agosto_septiembre_octubre_noviembre_diciembre'.split('_'),
        monthsShort : function (m, format) {
            if (!m) {
                return monthsShortDot;
            } else if (/-MMM-/.test(format)) {
                return monthsShort[m.month()];
            } else {
                return monthsShortDot[m.month()];
            }
        },
        monthsRegex : monthsRegex,
        monthsShortRegex : monthsRegex,
        monthsStrictRegex : /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre)/i,
        monthsShortStrictRegex : /^(ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i,
        monthsParse : monthsParse,
        longMonthsParse : monthsParse,
        shortMonthsParse : monthsParse,
        weekdays : 'domingo_lunes_martes_miércoles_jueves_viernes_sábado'.split('_'),
        weekdaysShort : 'dom._lun._mar._mié._jue._vie._sáb.'.split('_'),
        weekdaysMin : 'do_lu_ma_mi_ju_vi_sá'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT : 'H:mm',
            LTS : 'H:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D [de] MMMM [de] YYYY',
            LLL : 'D [de] MMMM [de] YYYY H:mm',
            LLLL : 'dddd, D [de] MMMM [de] YYYY H:mm'
        },
        calendar : {
            sameDay : function () {
                return '[hoy a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
            },
            nextDay : function () {
                return '[mañana a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
            },
            nextWeek : function () {
                return 'dddd [a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
            },
            lastDay : function () {
                return '[ayer a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
            },
            lastWeek : function () {
                return '[el] dddd [pasado a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
            },
            sameElse : 'L'
        },
        relativeTime : {
            future : 'en %s',
            past : 'hace %s',
            s : 'unos segundos',
            ss : '%d segundos',
            m : 'un minuto',
            mm : '%d minutos',
            h : 'una hora',
            hh : '%d horas',
            d : 'un día',
            dd : '%d días',
            M : 'un mes',
            MM : '%d meses',
            y : 'un año',
            yy : '%d años'
        },
        dayOfMonthOrdinalParse : /\d{1,2}º/,
        ordinal : '%dº',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return es;

})));

},{"../moment":408}],392:[function(require,module,exports){
//! moment.js locale configuration

;(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined'
       && typeof require === 'function' ? factory(require('../moment')) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var numbersPast = 'nolla yksi kaksi kolme neljä viisi kuusi seitsemän kahdeksan yhdeksän'.split(' '),
        numbersFuture = [
            'nolla', 'yhden', 'kahden', 'kolmen', 'neljän', 'viiden', 'kuuden',
            numbersPast[7], numbersPast[8], numbersPast[9]
        ];
    function translate(number, withoutSuffix, key, isFuture) {
        var result = '';
        switch (key) {
            case 's':
                return isFuture ? 'muutaman sekunnin' : 'muutama sekunti';
            case 'ss':
                return isFuture ? 'sekunnin' : 'sekuntia';
            case 'm':
                return isFuture ? 'minuutin' : 'minuutti';
            case 'mm':
                result = isFuture ? 'minuutin' : 'minuuttia';
                break;
            case 'h':
                return isFuture ? 'tunnin' : 'tunti';
            case 'hh':
                result = isFuture ? 'tunnin' : 'tuntia';
                break;
            case 'd':
                return isFuture ? 'päivän' : 'päivä';
            case 'dd':
                result = isFuture ? 'päivän' : 'päivää';
                break;
            case 'M':
                return isFuture ? 'kuukauden' : 'kuukausi';
            case 'MM':
                result = isFuture ? 'kuukauden' : 'kuukautta';
                break;
            case 'y':
                return isFuture ? 'vuoden' : 'vuosi';
            case 'yy':
                result = isFuture ? 'vuoden' : 'vuotta';
                break;
        }
        result = verbalNumber(number, isFuture) + ' ' + result;
        return result;
    }
    function verbalNumber(number, isFuture) {
        return number < 10 ? (isFuture ? numbersFuture[number] : numbersPast[number]) : number;
    }

    var fi = moment.defineLocale('fi', {
        months : 'tammikuu_helmikuu_maaliskuu_huhtikuu_toukokuu_kesäkuu_heinäkuu_elokuu_syyskuu_lokakuu_marraskuu_joulukuu'.split('_'),
        monthsShort : 'tammi_helmi_maalis_huhti_touko_kesä_heinä_elo_syys_loka_marras_joulu'.split('_'),
        weekdays : 'sunnuntai_maanantai_tiistai_keskiviikko_torstai_perjantai_lauantai'.split('_'),
        weekdaysShort : 'su_ma_ti_ke_to_pe_la'.split('_'),
        weekdaysMin : 'su_ma_ti_ke_to_pe_la'.split('_'),
        longDateFormat : {
            LT : 'HH.mm',
            LTS : 'HH.mm.ss',
            L : 'DD.MM.YYYY',
            LL : 'Do MMMM[ta] YYYY',
            LLL : 'Do MMMM[ta] YYYY, [klo] HH.mm',
            LLLL : 'dddd, Do MMMM[ta] YYYY, [klo] HH.mm',
            l : 'D.M.YYYY',
            ll : 'Do MMM YYYY',
            lll : 'Do MMM YYYY, [klo] HH.mm',
            llll : 'ddd, Do MMM YYYY, [klo] HH.mm'
        },
        calendar : {
            sameDay : '[tänään] [klo] LT',
            nextDay : '[huomenna] [klo] LT',
            nextWeek : 'dddd [klo] LT',
            lastDay : '[eilen] [klo] LT',
            lastWeek : '[viime] dddd[na] [klo] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : '%s päästä',
            past : '%s sitten',
            s : translate,
            ss : translate,
            m : translate,
            mm : translate,
            h : translate,
            hh : translate,
            d : translate,
            dd : translate,
            M : translate,
            MM : translate,
            y : translate,
            yy : translate
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return fi;

})));

},{"../moment":408}],393:[function(require,module,exports){
//! moment.js locale configuration

;(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined'
       && typeof require === 'function' ? factory(require('../moment')) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var frCa = moment.defineLocale('fr-ca', {
        months : 'janvier_février_mars_avril_mai_juin_juillet_août_septembre_octobre_novembre_décembre'.split('_'),
        monthsShort : 'janv._févr._mars_avr._mai_juin_juil._août_sept._oct._nov._déc.'.split('_'),
        monthsParseExact : true,
        weekdays : 'dimanche_lundi_mardi_mercredi_jeudi_vendredi_samedi'.split('_'),
        weekdaysShort : 'dim._lun._mar._mer._jeu._ven._sam.'.split('_'),
        weekdaysMin : 'di_lu_ma_me_je_ve_sa'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'YYYY-MM-DD',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd D MMMM YYYY HH:mm'
        },
        calendar : {
            sameDay : '[Aujourd’hui à] LT',
            nextDay : '[Demain à] LT',
            nextWeek : 'dddd [à] LT',
            lastDay : '[Hier à] LT',
            lastWeek : 'dddd [dernier à] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'dans %s',
            past : 'il y a %s',
            s : 'quelques secondes',
            ss : '%d secondes',
            m : 'une minute',
            mm : '%d minutes',
            h : 'une heure',
            hh : '%d heures',
            d : 'un jour',
            dd : '%d jours',
            M : 'un mois',
            MM : '%d mois',
            y : 'un an',
            yy : '%d ans'
        },
        dayOfMonthOrdinalParse: /\d{1,2}(er|e)/,
        ordinal : function (number, period) {
            switch (period) {
                // Words with masculine grammatical gender: mois, trimestre, jour
                default:
                case 'M':
                case 'Q':
                case 'D':
                case 'DDD':
                case 'd':
                    return number + (number === 1 ? 'er' : 'e');

                // Words with feminine grammatical gender: semaine
                case 'w':
                case 'W':
                    return number + (number === 1 ? 're' : 'e');
            }
        }
    });

    return frCa;

})));

},{"../moment":408}],394:[function(require,module,exports){
//! moment.js locale configuration

;(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined'
       && typeof require === 'function' ? factory(require('../moment')) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var fr = moment.defineLocale('fr', {
        months : 'janvier_février_mars_avril_mai_juin_juillet_août_septembre_octobre_novembre_décembre'.split('_'),
        monthsShort : 'janv._févr._mars_avr._mai_juin_juil._août_sept._oct._nov._déc.'.split('_'),
        monthsParseExact : true,
        weekdays : 'dimanche_lundi_mardi_mercredi_jeudi_vendredi_samedi'.split('_'),
        weekdaysShort : 'dim._lun._mar._mer._jeu._ven._sam.'.split('_'),
        weekdaysMin : 'di_lu_ma_me_je_ve_sa'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd D MMMM YYYY HH:mm'
        },
        calendar : {
            sameDay : '[Aujourd’hui à] LT',
            nextDay : '[Demain à] LT',
            nextWeek : 'dddd [à] LT',
            lastDay : '[Hier à] LT',
            lastWeek : 'dddd [dernier à] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'dans %s',
            past : 'il y a %s',
            s : 'quelques secondes',
            ss : '%d secondes',
            m : 'une minute',
            mm : '%d minutes',
            h : 'une heure',
            hh : '%d heures',
            d : 'un jour',
            dd : '%d jours',
            M : 'un mois',
            MM : '%d mois',
            y : 'un an',
            yy : '%d ans'
        },
        dayOfMonthOrdinalParse: /\d{1,2}(er|)/,
        ordinal : function (number, period) {
            switch (period) {
                // TODO: Return 'e' when day of month > 1. Move this case inside
                // block for masculine words below.
                // See https://github.com/moment/moment/issues/3375
                case 'D':
                    return number + (number === 1 ? 'er' : '');

                // Words with masculine grammatical gender: mois, trimestre, jour
                default:
                case 'M':
                case 'Q':
                case 'DDD':
                case 'd':
                    return number + (number === 1 ? 'er' : 'e');

                // Words with feminine grammatical gender: semaine
                case 'w':
                case 'W':
                    return number + (number === 1 ? 're' : 'e');
            }
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return fr;

})));

},{"../moment":408}],395:[function(require,module,exports){
//! moment.js locale configuration

;(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined'
       && typeof require === 'function' ? factory(require('../moment')) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var weekEndings = 'vasárnap hétfőn kedden szerdán csütörtökön pénteken szombaton'.split(' ');
    function translate(number, withoutSuffix, key, isFuture) {
        var num = number;
        switch (key) {
            case 's':
                return (isFuture || withoutSuffix) ? 'néhány másodperc' : 'néhány másodperce';
            case 'ss':
                return num + (isFuture || withoutSuffix) ? ' másodperc' : ' másodperce';
            case 'm':
                return 'egy' + (isFuture || withoutSuffix ? ' perc' : ' perce');
            case 'mm':
                return num + (isFuture || withoutSuffix ? ' perc' : ' perce');
            case 'h':
                return 'egy' + (isFuture || withoutSuffix ? ' óra' : ' órája');
            case 'hh':
                return num + (isFuture || withoutSuffix ? ' óra' : ' órája');
            case 'd':
                return 'egy' + (isFuture || withoutSuffix ? ' nap' : ' napja');
            case 'dd':
                return num + (isFuture || withoutSuffix ? ' nap' : ' napja');
            case 'M':
                return 'egy' + (isFuture || withoutSuffix ? ' hónap' : ' hónapja');
            case 'MM':
                return num + (isFuture || withoutSuffix ? ' hónap' : ' hónapja');
            case 'y':
                return 'egy' + (isFuture || withoutSuffix ? ' év' : ' éve');
            case 'yy':
                return num + (isFuture || withoutSuffix ? ' év' : ' éve');
        }
        return '';
    }
    function week(isFuture) {
        return (isFuture ? '' : '[múlt] ') + '[' + weekEndings[this.day()] + '] LT[-kor]';
    }

    var hu = moment.defineLocale('hu', {
        months : 'január_február_március_április_május_június_július_augusztus_szeptember_október_november_december'.split('_'),
        monthsShort : 'jan_feb_márc_ápr_máj_jún_júl_aug_szept_okt_nov_dec'.split('_'),
        weekdays : 'vasárnap_hétfő_kedd_szerda_csütörtök_péntek_szombat'.split('_'),
        weekdaysShort : 'vas_hét_kedd_sze_csüt_pén_szo'.split('_'),
        weekdaysMin : 'v_h_k_sze_cs_p_szo'.split('_'),
        longDateFormat : {
            LT : 'H:mm',
            LTS : 'H:mm:ss',
            L : 'YYYY.MM.DD.',
            LL : 'YYYY. MMMM D.',
            LLL : 'YYYY. MMMM D. H:mm',
            LLLL : 'YYYY. MMMM D., dddd H:mm'
        },
        meridiemParse: /de|du/i,
        isPM: function (input) {
            return input.charAt(1).toLowerCase() === 'u';
        },
        meridiem : function (hours, minutes, isLower) {
            if (hours < 12) {
                return isLower === true ? 'de' : 'DE';
            } else {
                return isLower === true ? 'du' : 'DU';
            }
        },
        calendar : {
            sameDay : '[ma] LT[-kor]',
            nextDay : '[holnap] LT[-kor]',
            nextWeek : function () {
                return week.call(this, true);
            },
            lastDay : '[tegnap] LT[-kor]',
            lastWeek : function () {
                return week.call(this, false);
            },
            sameElse : 'L'
        },
        relativeTime : {
            future : '%s múlva',
            past : '%s',
            s : translate,
            ss : translate,
            m : translate,
            mm : translate,
            h : translate,
            hh : translate,
            d : translate,
            dd : translate,
            M : translate,
            MM : translate,
            y : translate,
            yy : translate
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return hu;

})));

},{"../moment":408}],396:[function(require,module,exports){
//! moment.js locale configuration

;(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined'
       && typeof require === 'function' ? factory(require('../moment')) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var id = moment.defineLocale('id', {
        months : 'Januari_Februari_Maret_April_Mei_Juni_Juli_Agustus_September_Oktober_November_Desember'.split('_'),
        monthsShort : 'Jan_Feb_Mar_Apr_Mei_Jun_Jul_Agt_Sep_Okt_Nov_Des'.split('_'),
        weekdays : 'Minggu_Senin_Selasa_Rabu_Kamis_Jumat_Sabtu'.split('_'),
        weekdaysShort : 'Min_Sen_Sel_Rab_Kam_Jum_Sab'.split('_'),
        weekdaysMin : 'Mg_Sn_Sl_Rb_Km_Jm_Sb'.split('_'),
        longDateFormat : {
            LT : 'HH.mm',
            LTS : 'HH.mm.ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY [pukul] HH.mm',
            LLLL : 'dddd, D MMMM YYYY [pukul] HH.mm'
        },
        meridiemParse: /pagi|siang|sore|malam/,
        meridiemHour : function (hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === 'pagi') {
                return hour;
            } else if (meridiem === 'siang') {
                return hour >= 11 ? hour : hour + 12;
            } else if (meridiem === 'sore' || meridiem === 'malam') {
                return hour + 12;
            }
        },
        meridiem : function (hours, minutes, isLower) {
            if (hours < 11) {
                return 'pagi';
            } else if (hours < 15) {
                return 'siang';
            } else if (hours < 19) {
                return 'sore';
            } else {
                return 'malam';
            }
        },
        calendar : {
            sameDay : '[Hari ini pukul] LT',
            nextDay : '[Besok pukul] LT',
            nextWeek : 'dddd [pukul] LT',
            lastDay : '[Kemarin pukul] LT',
            lastWeek : 'dddd [lalu pukul] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'dalam %s',
            past : '%s yang lalu',
            s : 'beberapa detik',
            ss : '%d detik',
            m : 'semenit',
            mm : '%d menit',
            h : 'sejam',
            hh : '%d jam',
            d : 'sehari',
            dd : '%d hari',
            M : 'sebulan',
            MM : '%d bulan',
            y : 'setahun',
            yy : '%d tahun'
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 1st is the first week of the year.
        }
    });

    return id;

})));

},{"../moment":408}],397:[function(require,module,exports){
//! moment.js locale configuration

;(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined'
       && typeof require === 'function' ? factory(require('../moment')) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var it = moment.defineLocale('it', {
        months : 'gennaio_febbraio_marzo_aprile_maggio_giugno_luglio_agosto_settembre_ottobre_novembre_dicembre'.split('_'),
        monthsShort : 'gen_feb_mar_apr_mag_giu_lug_ago_set_ott_nov_dic'.split('_'),
        weekdays : 'domenica_lunedì_martedì_mercoledì_giovedì_venerdì_sabato'.split('_'),
        weekdaysShort : 'dom_lun_mar_mer_gio_ven_sab'.split('_'),
        weekdaysMin : 'do_lu_ma_me_gi_ve_sa'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd D MMMM YYYY HH:mm'
        },
        calendar : {
            sameDay: '[Oggi alle] LT',
            nextDay: '[Domani alle] LT',
            nextWeek: 'dddd [alle] LT',
            lastDay: '[Ieri alle] LT',
            lastWeek: function () {
                switch (this.day()) {
                    case 0:
                        return '[la scorsa] dddd [alle] LT';
                    default:
                        return '[lo scorso] dddd [alle] LT';
                }
            },
            sameElse: 'L'
        },
        relativeTime : {
            future : function (s) {
                return ((/^[0-9].+$/).test(s) ? 'tra' : 'in') + ' ' + s;
            },
            past : '%s fa',
            s : 'alcuni secondi',
            ss : '%d secondi',
            m : 'un minuto',
            mm : '%d minuti',
            h : 'un\'ora',
            hh : '%d ore',
            d : 'un giorno',
            dd : '%d giorni',
            M : 'un mese',
            MM : '%d mesi',
            y : 'un anno',
            yy : '%d anni'
        },
        dayOfMonthOrdinalParse : /\d{1,2}º/,
        ordinal: '%dº',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return it;

})));

},{"../moment":408}],398:[function(require,module,exports){
//! moment.js locale configuration

;(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined'
       && typeof require === 'function' ? factory(require('../moment')) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var ja = moment.defineLocale('ja', {
        months : '1月_2月_3月_4月_5月_6月_7月_8月_9月_10月_11月_12月'.split('_'),
        monthsShort : '1月_2月_3月_4月_5月_6月_7月_8月_9月_10月_11月_12月'.split('_'),
        weekdays : '日曜日_月曜日_火曜日_水曜日_木曜日_金曜日_土曜日'.split('_'),
        weekdaysShort : '日_月_火_水_木_金_土'.split('_'),
        weekdaysMin : '日_月_火_水_木_金_土'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'YYYY/MM/DD',
            LL : 'YYYY年M月D日',
            LLL : 'YYYY年M月D日 HH:mm',
            LLLL : 'YYYY年M月D日 dddd HH:mm',
            l : 'YYYY/MM/DD',
            ll : 'YYYY年M月D日',
            lll : 'YYYY年M月D日 HH:mm',
            llll : 'YYYY年M月D日(ddd) HH:mm'
        },
        meridiemParse: /午前|午後/i,
        isPM : function (input) {
            return input === '午後';
        },
        meridiem : function (hour, minute, isLower) {
            if (hour < 12) {
                return '午前';
            } else {
                return '午後';
            }
        },
        calendar : {
            sameDay : '[今日] LT',
            nextDay : '[明日] LT',
            nextWeek : function (now) {
                if (now.week() < this.week()) {
                    return '[来週]dddd LT';
                } else {
                    return 'dddd LT';
                }
            },
            lastDay : '[昨日] LT',
            lastWeek : function (now) {
                if (this.week() < now.week()) {
                    return '[先週]dddd LT';
                } else {
                    return 'dddd LT';
                }
            },
            sameElse : 'L'
        },
        dayOfMonthOrdinalParse : /\d{1,2}日/,
        ordinal : function (number, period) {
            switch (period) {
                case 'd':
                case 'D':
                case 'DDD':
                    return number + '日';
                default:
                    return number;
            }
        },
        relativeTime : {
            future : '%s後',
            past : '%s前',
            s : '数秒',
            ss : '%d秒',
            m : '1分',
            mm : '%d分',
            h : '1時間',
            hh : '%d時間',
            d : '1日',
            dd : '%d日',
            M : '1ヶ月',
            MM : '%dヶ月',
            y : '1年',
            yy : '%d年'
        }
    });

    return ja;

})));

},{"../moment":408}],399:[function(require,module,exports){
//! moment.js locale configuration

;(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined'
       && typeof require === 'function' ? factory(require('../moment')) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var msMy = moment.defineLocale('ms-my', {
        months : 'Januari_Februari_Mac_April_Mei_Jun_Julai_Ogos_September_Oktober_November_Disember'.split('_'),
        monthsShort : 'Jan_Feb_Mac_Apr_Mei_Jun_Jul_Ogs_Sep_Okt_Nov_Dis'.split('_'),
        weekdays : 'Ahad_Isnin_Selasa_Rabu_Khamis_Jumaat_Sabtu'.split('_'),
        weekdaysShort : 'Ahd_Isn_Sel_Rab_Kha_Jum_Sab'.split('_'),
        weekdaysMin : 'Ah_Is_Sl_Rb_Km_Jm_Sb'.split('_'),
        longDateFormat : {
            LT : 'HH.mm',
            LTS : 'HH.mm.ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY [pukul] HH.mm',
            LLLL : 'dddd, D MMMM YYYY [pukul] HH.mm'
        },
        meridiemParse: /pagi|tengahari|petang|malam/,
        meridiemHour: function (hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === 'pagi') {
                return hour;
            } else if (meridiem === 'tengahari') {
                return hour >= 11 ? hour : hour + 12;
            } else if (meridiem === 'petang' || meridiem === 'malam') {
                return hour + 12;
            }
        },
        meridiem : function (hours, minutes, isLower) {
            if (hours < 11) {
                return 'pagi';
            } else if (hours < 15) {
                return 'tengahari';
            } else if (hours < 19) {
                return 'petang';
            } else {
                return 'malam';
            }
        },
        calendar : {
            sameDay : '[Hari ini pukul] LT',
            nextDay : '[Esok pukul] LT',
            nextWeek : 'dddd [pukul] LT',
            lastDay : '[Kelmarin pukul] LT',
            lastWeek : 'dddd [lepas pukul] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'dalam %s',
            past : '%s yang lepas',
            s : 'beberapa saat',
            ss : '%d saat',
            m : 'seminit',
            mm : '%d minit',
            h : 'sejam',
            hh : '%d jam',
            d : 'sehari',
            dd : '%d hari',
            M : 'sebulan',
            MM : '%d bulan',
            y : 'setahun',
            yy : '%d tahun'
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 1st is the first week of the year.
        }
    });

    return msMy;

})));

},{"../moment":408}],400:[function(require,module,exports){
//! moment.js locale configuration

;(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined'
       && typeof require === 'function' ? factory(require('../moment')) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var monthsShortWithDots = 'jan._feb._mrt._apr._mei_jun._jul._aug._sep._okt._nov._dec.'.split('_'),
        monthsShortWithoutDots = 'jan_feb_mrt_apr_mei_jun_jul_aug_sep_okt_nov_dec'.split('_');

    var monthsParse = [/^jan/i, /^feb/i, /^maart|mrt.?$/i, /^apr/i, /^mei$/i, /^jun[i.]?$/i, /^jul[i.]?$/i, /^aug/i, /^sep/i, /^okt/i, /^nov/i, /^dec/i];
    var monthsRegex = /^(januari|februari|maart|april|mei|april|ju[nl]i|augustus|september|oktober|november|december|jan\.?|feb\.?|mrt\.?|apr\.?|ju[nl]\.?|aug\.?|sep\.?|okt\.?|nov\.?|dec\.?)/i;

    var nl = moment.defineLocale('nl', {
        months : 'januari_februari_maart_april_mei_juni_juli_augustus_september_oktober_november_december'.split('_'),
        monthsShort : function (m, format) {
            if (!m) {
                return monthsShortWithDots;
            } else if (/-MMM-/.test(format)) {
                return monthsShortWithoutDots[m.month()];
            } else {
                return monthsShortWithDots[m.month()];
            }
        },

        monthsRegex: monthsRegex,
        monthsShortRegex: monthsRegex,
        monthsStrictRegex: /^(januari|februari|maart|mei|ju[nl]i|april|augustus|september|oktober|november|december)/i,
        monthsShortStrictRegex: /^(jan\.?|feb\.?|mrt\.?|apr\.?|mei|ju[nl]\.?|aug\.?|sep\.?|okt\.?|nov\.?|dec\.?)/i,

        monthsParse : monthsParse,
        longMonthsParse : monthsParse,
        shortMonthsParse : monthsParse,

        weekdays : 'zondag_maandag_dinsdag_woensdag_donderdag_vrijdag_zaterdag'.split('_'),
        weekdaysShort : 'zo._ma._di._wo._do._vr._za.'.split('_'),
        weekdaysMin : 'zo_ma_di_wo_do_vr_za'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD-MM-YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd D MMMM YYYY HH:mm'
        },
        calendar : {
            sameDay: '[vandaag om] LT',
            nextDay: '[morgen om] LT',
            nextWeek: 'dddd [om] LT',
            lastDay: '[gisteren om] LT',
            lastWeek: '[afgelopen] dddd [om] LT',
            sameElse: 'L'
        },
        relativeTime : {
            future : 'over %s',
            past : '%s geleden',
            s : 'een paar seconden',
            ss : '%d seconden',
            m : 'één minuut',
            mm : '%d minuten',
            h : 'één uur',
            hh : '%d uur',
            d : 'één dag',
            dd : '%d dagen',
            M : 'één maand',
            MM : '%d maanden',
            y : 'één jaar',
            yy : '%d jaar'
        },
        dayOfMonthOrdinalParse: /\d{1,2}(ste|de)/,
        ordinal : function (number) {
            return number + ((number === 1 || number === 8 || number >= 20) ? 'ste' : 'de');
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return nl;

})));

},{"../moment":408}],401:[function(require,module,exports){
//! moment.js locale configuration

;(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined'
       && typeof require === 'function' ? factory(require('../moment')) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var monthsNominative = 'styczeń_luty_marzec_kwiecień_maj_czerwiec_lipiec_sierpień_wrzesień_październik_listopad_grudzień'.split('_'),
        monthsSubjective = 'stycznia_lutego_marca_kwietnia_maja_czerwca_lipca_sierpnia_września_października_listopada_grudnia'.split('_');
    function plural(n) {
        return (n % 10 < 5) && (n % 10 > 1) && ((~~(n / 10) % 10) !== 1);
    }
    function translate(number, withoutSuffix, key) {
        var result = number + ' ';
        switch (key) {
            case 'ss':
                return result + (plural(number) ? 'sekundy' : 'sekund');
            case 'm':
                return withoutSuffix ? 'minuta' : 'minutę';
            case 'mm':
                return result + (plural(number) ? 'minuty' : 'minut');
            case 'h':
                return withoutSuffix  ? 'godzina'  : 'godzinę';
            case 'hh':
                return result + (plural(number) ? 'godziny' : 'godzin');
            case 'MM':
                return result + (plural(number) ? 'miesiące' : 'miesięcy');
            case 'yy':
                return result + (plural(number) ? 'lata' : 'lat');
        }
    }

    var pl = moment.defineLocale('pl', {
        months : function (momentToFormat, format) {
            if (!momentToFormat) {
                return monthsNominative;
            } else if (format === '') {
                // Hack: if format empty we know this is used to generate
                // RegExp by moment. Give then back both valid forms of months
                // in RegExp ready format.
                return '(' + monthsSubjective[momentToFormat.month()] + '|' + monthsNominative[momentToFormat.month()] + ')';
            } else if (/D MMMM/.test(format)) {
                return monthsSubjective[momentToFormat.month()];
            } else {
                return monthsNominative[momentToFormat.month()];
            }
        },
        monthsShort : 'sty_lut_mar_kwi_maj_cze_lip_sie_wrz_paź_lis_gru'.split('_'),
        weekdays : 'niedziela_poniedziałek_wtorek_środa_czwartek_piątek_sobota'.split('_'),
        weekdaysShort : 'ndz_pon_wt_śr_czw_pt_sob'.split('_'),
        weekdaysMin : 'Nd_Pn_Wt_Śr_Cz_Pt_So'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD.MM.YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd, D MMMM YYYY HH:mm'
        },
        calendar : {
            sameDay: '[Dziś o] LT',
            nextDay: '[Jutro o] LT',
            nextWeek: function () {
                switch (this.day()) {
                    case 0:
                        return '[W niedzielę o] LT';

                    case 2:
                        return '[We wtorek o] LT';

                    case 3:
                        return '[W środę o] LT';

                    case 6:
                        return '[W sobotę o] LT';

                    default:
                        return '[W] dddd [o] LT';
                }
            },
            lastDay: '[Wczoraj o] LT',
            lastWeek: function () {
                switch (this.day()) {
                    case 0:
                        return '[W zeszłą niedzielę o] LT';
                    case 3:
                        return '[W zeszłą środę o] LT';
                    case 6:
                        return '[W zeszłą sobotę o] LT';
                    default:
                        return '[W zeszły] dddd [o] LT';
                }
            },
            sameElse: 'L'
        },
        relativeTime : {
            future : 'za %s',
            past : '%s temu',
            s : 'kilka sekund',
            ss : translate,
            m : translate,
            mm : translate,
            h : translate,
            hh : translate,
            d : '1 dzień',
            dd : '%d dni',
            M : 'miesiąc',
            MM : translate,
            y : 'rok',
            yy : translate
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return pl;

})));

},{"../moment":408}],402:[function(require,module,exports){
//! moment.js locale configuration

;(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined'
       && typeof require === 'function' ? factory(require('../moment')) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var ptBr = moment.defineLocale('pt-br', {
        months : 'janeiro_fevereiro_março_abril_maio_junho_julho_agosto_setembro_outubro_novembro_dezembro'.split('_'),
        monthsShort : 'jan_fev_mar_abr_mai_jun_jul_ago_set_out_nov_dez'.split('_'),
        weekdays : 'Domingo_Segunda-feira_Terça-feira_Quarta-feira_Quinta-feira_Sexta-feira_Sábado'.split('_'),
        weekdaysShort : 'Dom_Seg_Ter_Qua_Qui_Sex_Sáb'.split('_'),
        weekdaysMin : 'Do_2ª_3ª_4ª_5ª_6ª_Sá'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D [de] MMMM [de] YYYY',
            LLL : 'D [de] MMMM [de] YYYY [às] HH:mm',
            LLLL : 'dddd, D [de] MMMM [de] YYYY [às] HH:mm'
        },
        calendar : {
            sameDay: '[Hoje às] LT',
            nextDay: '[Amanhã às] LT',
            nextWeek: 'dddd [às] LT',
            lastDay: '[Ontem às] LT',
            lastWeek: function () {
                return (this.day() === 0 || this.day() === 6) ?
                    '[Último] dddd [às] LT' : // Saturday + Sunday
                    '[Última] dddd [às] LT'; // Monday - Friday
            },
            sameElse: 'L'
        },
        relativeTime : {
            future : 'em %s',
            past : 'há %s',
            s : 'poucos segundos',
            ss : '%d segundos',
            m : 'um minuto',
            mm : '%d minutos',
            h : 'uma hora',
            hh : '%d horas',
            d : 'um dia',
            dd : '%d dias',
            M : 'um mês',
            MM : '%d meses',
            y : 'um ano',
            yy : '%d anos'
        },
        dayOfMonthOrdinalParse: /\d{1,2}º/,
        ordinal : '%dº'
    });

    return ptBr;

})));

},{"../moment":408}],403:[function(require,module,exports){
//! moment.js locale configuration

;(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined'
       && typeof require === 'function' ? factory(require('../moment')) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var sv = moment.defineLocale('sv', {
        months : 'januari_februari_mars_april_maj_juni_juli_augusti_september_oktober_november_december'.split('_'),
        monthsShort : 'jan_feb_mar_apr_maj_jun_jul_aug_sep_okt_nov_dec'.split('_'),
        weekdays : 'söndag_måndag_tisdag_onsdag_torsdag_fredag_lördag'.split('_'),
        weekdaysShort : 'sön_mån_tis_ons_tor_fre_lör'.split('_'),
        weekdaysMin : 'sö_må_ti_on_to_fr_lö'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'YYYY-MM-DD',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY [kl.] HH:mm',
            LLLL : 'dddd D MMMM YYYY [kl.] HH:mm',
            lll : 'D MMM YYYY HH:mm',
            llll : 'ddd D MMM YYYY HH:mm'
        },
        calendar : {
            sameDay: '[Idag] LT',
            nextDay: '[Imorgon] LT',
            lastDay: '[Igår] LT',
            nextWeek: '[På] dddd LT',
            lastWeek: '[I] dddd[s] LT',
            sameElse: 'L'
        },
        relativeTime : {
            future : 'om %s',
            past : 'för %s sedan',
            s : 'några sekunder',
            ss : '%d sekunder',
            m : 'en minut',
            mm : '%d minuter',
            h : 'en timme',
            hh : '%d timmar',
            d : 'en dag',
            dd : '%d dagar',
            M : 'en månad',
            MM : '%d månader',
            y : 'ett år',
            yy : '%d år'
        },
        dayOfMonthOrdinalParse: /\d{1,2}(e|a)/,
        ordinal : function (number) {
            var b = number % 10,
                output = (~~(number % 100 / 10) === 1) ? 'e' :
                (b === 1) ? 'a' :
                (b === 2) ? 'a' :
                (b === 3) ? 'e' : 'e';
            return number + output;
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return sv;

})));

},{"../moment":408}],404:[function(require,module,exports){
//! moment.js locale configuration

;(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined'
       && typeof require === 'function' ? factory(require('../moment')) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var th = moment.defineLocale('th', {
        months : 'มกราคม_กุมภาพันธ์_มีนาคม_เมษายน_พฤษภาคม_มิถุนายน_กรกฎาคม_สิงหาคม_กันยายน_ตุลาคม_พฤศจิกายน_ธันวาคม'.split('_'),
        monthsShort : 'ม.ค._ก.พ._มี.ค._เม.ย._พ.ค._มิ.ย._ก.ค._ส.ค._ก.ย._ต.ค._พ.ย._ธ.ค.'.split('_'),
        monthsParseExact: true,
        weekdays : 'อาทิตย์_จันทร์_อังคาร_พุธ_พฤหัสบดี_ศุกร์_เสาร์'.split('_'),
        weekdaysShort : 'อาทิตย์_จันทร์_อังคาร_พุธ_พฤหัส_ศุกร์_เสาร์'.split('_'), // yes, three characters difference
        weekdaysMin : 'อา._จ._อ._พ._พฤ._ศ._ส.'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT : 'H:mm',
            LTS : 'H:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY เวลา H:mm',
            LLLL : 'วันddddที่ D MMMM YYYY เวลา H:mm'
        },
        meridiemParse: /ก่อนเที่ยง|หลังเที่ยง/,
        isPM: function (input) {
            return input === 'หลังเที่ยง';
        },
        meridiem : function (hour, minute, isLower) {
            if (hour < 12) {
                return 'ก่อนเที่ยง';
            } else {
                return 'หลังเที่ยง';
            }
        },
        calendar : {
            sameDay : '[วันนี้ เวลา] LT',
            nextDay : '[พรุ่งนี้ เวลา] LT',
            nextWeek : 'dddd[หน้า เวลา] LT',
            lastDay : '[เมื่อวานนี้ เวลา] LT',
            lastWeek : '[วัน]dddd[ที่แล้ว เวลา] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'อีก %s',
            past : '%sที่แล้ว',
            s : 'ไม่กี่วินาที',
            ss : '%d วินาที',
            m : '1 นาที',
            mm : '%d นาที',
            h : '1 ชั่วโมง',
            hh : '%d ชั่วโมง',
            d : '1 วัน',
            dd : '%d วัน',
            M : '1 เดือน',
            MM : '%d เดือน',
            y : '1 ปี',
            yy : '%d ปี'
        }
    });

    return th;

})));

},{"../moment":408}],405:[function(require,module,exports){

;(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined'
       && typeof require === 'function' ? factory(require('../moment')) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';

    var suffixes = {
        1: '\'inci',
        5: '\'inci',
        8: '\'inci',
        70: '\'inci',
        80: '\'inci',
        2: '\'nci',
        7: '\'nci',
        20: '\'nci',
        50: '\'nci',
        3: '\'üncü',
        4: '\'üncü',
        100: '\'üncü',
        6: '\'ncı',
        9: '\'uncu',
        10: '\'uncu',
        30: '\'uncu',
        60: '\'ıncı',
        90: '\'ıncı'
    };

    var tr = moment.defineLocale('tr', {
        months : 'Ocak_Şubat_Mart_Nisan_Mayıs_Haziran_Temmuz_Ağustos_Eylül_Ekim_Kasım_Aralık'.split('_'),
        monthsShort : 'Oca_Şub_Mar_Nis_May_Haz_Tem_Ağu_Eyl_Eki_Kas_Ara'.split('_'),
        weekdays : 'Pazar_Pazartesi_Salı_Çarşamba_Perşembe_Cuma_Cumartesi'.split('_'),
        weekdaysShort : 'Paz_Pts_Sal_Çar_Per_Cum_Cts'.split('_'),
        weekdaysMin : 'Pz_Pt_Sa_Ça_Pe_Cu_Ct'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD.MM.YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd, D MMMM YYYY HH:mm'
        },
        calendar : {
            sameDay : '[bugün saat] LT',
            nextDay : '[yarın saat] LT',
            nextWeek : '[gelecek] dddd [saat] LT',
            lastDay : '[dün] LT',
            lastWeek : '[geçen] dddd [saat] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : '%s sonra',
            past : '%s önce',
            s : 'birkaç saniye',
            ss : '%d saniye',
            m : 'bir dakika',
            mm : '%d dakika',
            h : 'bir saat',
            hh : '%d saat',
            d : 'bir gün',
            dd : '%d gün',
            M : 'bir ay',
            MM : '%d ay',
            y : 'bir yıl',
            yy : '%d yıl'
        },
        ordinal: function (number, period) {
            switch (period) {
                case 'd':
                case 'D':
                case 'Do':
                case 'DD':
                    return number;
                default:
                    if (number === 0) {  // special case for zero
                        return number + '\'ıncı';
                    }
                    var a = number % 10,
                        b = number % 100 - a,
                        c = number >= 100 ? 100 : null;
                    return number + (suffixes[a] || suffixes[b] || suffixes[c]);
            }
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 1st is the first week of the year.
        }
    });

    return tr;

})));

},{"../moment":408}],406:[function(require,module,exports){
//! moment.js locale configuration

;(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined'
       && typeof require === 'function' ? factory(require('../moment')) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var vi = moment.defineLocale('vi', {
        months : 'tháng 1_tháng 2_tháng 3_tháng 4_tháng 5_tháng 6_tháng 7_tháng 8_tháng 9_tháng 10_tháng 11_tháng 12'.split('_'),
        monthsShort : 'Th01_Th02_Th03_Th04_Th05_Th06_Th07_Th08_Th09_Th10_Th11_Th12'.split('_'),
        monthsParseExact : true,
        weekdays : 'chủ nhật_thứ hai_thứ ba_thứ tư_thứ năm_thứ sáu_thứ bảy'.split('_'),
        weekdaysShort : 'CN_T2_T3_T4_T5_T6_T7'.split('_'),
        weekdaysMin : 'CN_T2_T3_T4_T5_T6_T7'.split('_'),
        weekdaysParseExact : true,
        meridiemParse: /sa|ch/i,
        isPM : function (input) {
            return /^ch$/i.test(input);
        },
        meridiem : function (hours, minutes, isLower) {
            if (hours < 12) {
                return isLower ? 'sa' : 'SA';
            } else {
                return isLower ? 'ch' : 'CH';
            }
        },
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM [năm] YYYY',
            LLL : 'D MMMM [năm] YYYY HH:mm',
            LLLL : 'dddd, D MMMM [năm] YYYY HH:mm',
            l : 'DD/M/YYYY',
            ll : 'D MMM YYYY',
            lll : 'D MMM YYYY HH:mm',
            llll : 'ddd, D MMM YYYY HH:mm'
        },
        calendar : {
            sameDay: '[Hôm nay lúc] LT',
            nextDay: '[Ngày mai lúc] LT',
            nextWeek: 'dddd [tuần tới lúc] LT',
            lastDay: '[Hôm qua lúc] LT',
            lastWeek: 'dddd [tuần rồi lúc] LT',
            sameElse: 'L'
        },
        relativeTime : {
            future : '%s tới',
            past : '%s trước',
            s : 'vài giây',
            ss : '%d giây' ,
            m : 'một phút',
            mm : '%d phút',
            h : 'một giờ',
            hh : '%d giờ',
            d : 'một ngày',
            dd : '%d ngày',
            M : 'một tháng',
            MM : '%d tháng',
            y : 'một năm',
            yy : '%d năm'
        },
        dayOfMonthOrdinalParse: /\d{1,2}/,
        ordinal : function (number) {
            return number;
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return vi;

})));

},{"../moment":408}],407:[function(require,module,exports){
//! moment.js locale configuration

;(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined'
       && typeof require === 'function' ? factory(require('../moment')) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var zhTw = moment.defineLocale('zh-tw', {
        months : '一月_二月_三月_四月_五月_六月_七月_八月_九月_十月_十一月_十二月'.split('_'),
        monthsShort : '1月_2月_3月_4月_5月_6月_7月_8月_9月_10月_11月_12月'.split('_'),
        weekdays : '星期日_星期一_星期二_星期三_星期四_星期五_星期六'.split('_'),
        weekdaysShort : '週日_週一_週二_週三_週四_週五_週六'.split('_'),
        weekdaysMin : '日_一_二_三_四_五_六'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'YYYY/MM/DD',
            LL : 'YYYY年M月D日',
            LLL : 'YYYY年M月D日 HH:mm',
            LLLL : 'YYYY年M月D日dddd HH:mm',
            l : 'YYYY/M/D',
            ll : 'YYYY年M月D日',
            lll : 'YYYY年M月D日 HH:mm',
            llll : 'YYYY年M月D日dddd HH:mm'
        },
        meridiemParse: /凌晨|早上|上午|中午|下午|晚上/,
        meridiemHour : function (hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === '凌晨' || meridiem === '早上' || meridiem === '上午') {
                return hour;
            } else if (meridiem === '中午') {
                return hour >= 11 ? hour : hour + 12;
            } else if (meridiem === '下午' || meridiem === '晚上') {
                return hour + 12;
            }
        },
        meridiem : function (hour, minute, isLower) {
            var hm = hour * 100 + minute;
            if (hm < 600) {
                return '凌晨';
            } else if (hm < 900) {
                return '早上';
            } else if (hm < 1130) {
                return '上午';
            } else if (hm < 1230) {
                return '中午';
            } else if (hm < 1800) {
                return '下午';
            } else {
                return '晚上';
            }
        },
        calendar : {
            sameDay : '[今天] LT',
            nextDay : '[明天] LT',
            nextWeek : '[下]dddd LT',
            lastDay : '[昨天] LT',
            lastWeek : '[上]dddd LT',
            sameElse : 'L'
        },
        dayOfMonthOrdinalParse: /\d{1,2}(日|月|週)/,
        ordinal : function (number, period) {
            switch (period) {
                case 'd' :
                case 'D' :
                case 'DDD' :
                    return number + '日';
                case 'M' :
                    return number + '月';
                case 'w' :
                case 'W' :
                    return number + '週';
                default :
                    return number;
            }
        },
        relativeTime : {
            future : '%s內',
            past : '%s前',
            s : '幾秒',
            ss : '%d 秒',
            m : '1 分鐘',
            mm : '%d 分鐘',
            h : '1 小時',
            hh : '%d 小時',
            d : '1 天',
            dd : '%d 天',
            M : '1 個月',
            MM : '%d 個月',
            y : '1 年',
            yy : '%d 年'
        }
    });

    return zhTw;

})));

},{"../moment":408}],408:[function(require,module,exports){
//! moment.js

;(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
    typeof define === 'function' && define.amd ? define(factory) :
    global.moment = factory()
}(this, (function () { 'use strict';

    var hookCallback;

    function hooks () {
        return hookCallback.apply(null, arguments);
    }

    // This is done to register the method called with moment()
    // without creating circular dependencies.
    function setHookCallback (callback) {
        hookCallback = callback;
    }

    function isArray(input) {
        return input instanceof Array || Object.prototype.toString.call(input) === '[object Array]';
    }

    function isObject(input) {
        // IE8 will treat undefined and null as object if it wasn't for
        // input != null
        return input != null && Object.prototype.toString.call(input) === '[object Object]';
    }

    function isObjectEmpty(obj) {
        if (Object.getOwnPropertyNames) {
            return (Object.getOwnPropertyNames(obj).length === 0);
        } else {
            var k;
            for (k in obj) {
                if (obj.hasOwnProperty(k)) {
                    return false;
                }
            }
            return true;
        }
    }

    function isUndefined(input) {
        return input === void 0;
    }

    function isNumber(input) {
        return typeof input === 'number' || Object.prototype.toString.call(input) === '[object Number]';
    }

    function isDate(input) {
        return input instanceof Date || Object.prototype.toString.call(input) === '[object Date]';
    }

    function map(arr, fn) {
        var res = [], i;
        for (i = 0; i < arr.length; ++i) {
            res.push(fn(arr[i], i));
        }
        return res;
    }

    function hasOwnProp(a, b) {
        return Object.prototype.hasOwnProperty.call(a, b);
    }

    function extend(a, b) {
        for (var i in b) {
            if (hasOwnProp(b, i)) {
                a[i] = b[i];
            }
        }

        if (hasOwnProp(b, 'toString')) {
            a.toString = b.toString;
        }

        if (hasOwnProp(b, 'valueOf')) {
            a.valueOf = b.valueOf;
        }

        return a;
    }

    function createUTC (input, format, locale, strict) {
        return createLocalOrUTC(input, format, locale, strict, true).utc();
    }

    function defaultParsingFlags() {
        // We need to deep clone this object.
        return {
            empty           : false,
            unusedTokens    : [],
            unusedInput     : [],
            overflow        : -2,
            charsLeftOver   : 0,
            nullInput       : false,
            invalidMonth    : null,
            invalidFormat   : false,
            userInvalidated : false,
            iso             : false,
            parsedDateParts : [],
            meridiem        : null,
            rfc2822         : false,
            weekdayMismatch : false
        };
    }

    function getParsingFlags(m) {
        if (m._pf == null) {
            m._pf = defaultParsingFlags();
        }
        return m._pf;
    }

    var some;
    if (Array.prototype.some) {
        some = Array.prototype.some;
    } else {
        some = function (fun) {
            var t = Object(this);
            var len = t.length >>> 0;

            for (var i = 0; i < len; i++) {
                if (i in t && fun.call(this, t[i], i, t)) {
                    return true;
                }
            }

            return false;
        };
    }

    function isValid(m) {
        if (m._isValid == null) {
            var flags = getParsingFlags(m);
            var parsedParts = some.call(flags.parsedDateParts, function (i) {
                return i != null;
            });
            var isNowValid = !isNaN(m._d.getTime()) &&
                flags.overflow < 0 &&
                !flags.empty &&
                !flags.invalidMonth &&
                !flags.invalidWeekday &&
                !flags.weekdayMismatch &&
                !flags.nullInput &&
                !flags.invalidFormat &&
                !flags.userInvalidated &&
                (!flags.meridiem || (flags.meridiem && parsedParts));

            if (m._strict) {
                isNowValid = isNowValid &&
                    flags.charsLeftOver === 0 &&
                    flags.unusedTokens.length === 0 &&
                    flags.bigHour === undefined;
            }

            if (Object.isFrozen == null || !Object.isFrozen(m)) {
                m._isValid = isNowValid;
            }
            else {
                return isNowValid;
            }
        }
        return m._isValid;
    }

    function createInvalid (flags) {
        var m = createUTC(NaN);
        if (flags != null) {
            extend(getParsingFlags(m), flags);
        }
        else {
            getParsingFlags(m).userInvalidated = true;
        }

        return m;
    }

    // Plugins that add properties should also add the key here (null value),
    // so we can properly clone ourselves.
    var momentProperties = hooks.momentProperties = [];

    function copyConfig(to, from) {
        var i, prop, val;

        if (!isUndefined(from._isAMomentObject)) {
            to._isAMomentObject = from._isAMomentObject;
        }
        if (!isUndefined(from._i)) {
            to._i = from._i;
        }
        if (!isUndefined(from._f)) {
            to._f = from._f;
        }
        if (!isUndefined(from._l)) {
            to._l = from._l;
        }
        if (!isUndefined(from._strict)) {
            to._strict = from._strict;
        }
        if (!isUndefined(from._tzm)) {
            to._tzm = from._tzm;
        }
        if (!isUndefined(from._isUTC)) {
            to._isUTC = from._isUTC;
        }
        if (!isUndefined(from._offset)) {
            to._offset = from._offset;
        }
        if (!isUndefined(from._pf)) {
            to._pf = getParsingFlags(from);
        }
        if (!isUndefined(from._locale)) {
            to._locale = from._locale;
        }

        if (momentProperties.length > 0) {
            for (i = 0; i < momentProperties.length; i++) {
                prop = momentProperties[i];
                val = from[prop];
                if (!isUndefined(val)) {
                    to[prop] = val;
                }
            }
        }

        return to;
    }

    var updateInProgress = false;

    // Moment prototype object
    function Moment(config) {
        copyConfig(this, config);
        this._d = new Date(config._d != null ? config._d.getTime() : NaN);
        if (!this.isValid()) {
            this._d = new Date(NaN);
        }
        // Prevent infinite loop in case updateOffset creates new moment
        // objects.
        if (updateInProgress === false) {
            updateInProgress = true;
            hooks.updateOffset(this);
            updateInProgress = false;
        }
    }

    function isMoment (obj) {
        return obj instanceof Moment || (obj != null && obj._isAMomentObject != null);
    }

    function absFloor (number) {
        if (number < 0) {
            // -0 -> 0
            return Math.ceil(number) || 0;
        } else {
            return Math.floor(number);
        }
    }

    function toInt(argumentForCoercion) {
        var coercedNumber = +argumentForCoercion,
            value = 0;

        if (coercedNumber !== 0 && isFinite(coercedNumber)) {
            value = absFloor(coercedNumber);
        }

        return value;
    }

    // compare two arrays, return the number of differences
    function compareArrays(array1, array2, dontConvert) {
        var len = Math.min(array1.length, array2.length),
            lengthDiff = Math.abs(array1.length - array2.length),
            diffs = 0,
            i;
        for (i = 0; i < len; i++) {
            if ((dontConvert && array1[i] !== array2[i]) ||
                (!dontConvert && toInt(array1[i]) !== toInt(array2[i]))) {
                diffs++;
            }
        }
        return diffs + lengthDiff;
    }

    function warn(msg) {
        if (hooks.suppressDeprecationWarnings === false &&
                (typeof console !==  'undefined') && console.warn) {
            console.warn('Deprecation warning: ' + msg);
        }
    }

    function deprecate(msg, fn) {
        var firstTime = true;

        return extend(function () {
            if (hooks.deprecationHandler != null) {
                hooks.deprecationHandler(null, msg);
            }
            if (firstTime) {
                var args = [];
                var arg;
                for (var i = 0; i < arguments.length; i++) {
                    arg = '';
                    if (typeof arguments[i] === 'object') {
                        arg += '\n[' + i + '] ';
                        for (var key in arguments[0]) {
                            arg += key + ': ' + arguments[0][key] + ', ';
                        }
                        arg = arg.slice(0, -2); // Remove trailing comma and space
                    } else {
                        arg = arguments[i];
                    }
                    args.push(arg);
                }
                warn(msg + '\nArguments: ' + Array.prototype.slice.call(args).join('') + '\n' + (new Error()).stack);
                firstTime = false;
            }
            return fn.apply(this, arguments);
        }, fn);
    }

    var deprecations = {};

    function deprecateSimple(name, msg) {
        if (hooks.deprecationHandler != null) {
            hooks.deprecationHandler(name, msg);
        }
        if (!deprecations[name]) {
            warn(msg);
            deprecations[name] = true;
        }
    }

    hooks.suppressDeprecationWarnings = false;
    hooks.deprecationHandler = null;

    function isFunction(input) {
        return input instanceof Function || Object.prototype.toString.call(input) === '[object Function]';
    }

    function set (config) {
        var prop, i;
        for (i in config) {
            prop = config[i];
            if (isFunction(prop)) {
                this[i] = prop;
            } else {
                this['_' + i] = prop;
            }
        }
        this._config = config;
        // Lenient ordinal parsing accepts just a number in addition to
        // number + (possibly) stuff coming from _dayOfMonthOrdinalParse.
        // TODO: Remove "ordinalParse" fallback in next major release.
        this._dayOfMonthOrdinalParseLenient = new RegExp(
            (this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) +
                '|' + (/\d{1,2}/).source);
    }

    function mergeConfigs(parentConfig, childConfig) {
        var res = extend({}, parentConfig), prop;
        for (prop in childConfig) {
            if (hasOwnProp(childConfig, prop)) {
                if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {
                    res[prop] = {};
                    extend(res[prop], parentConfig[prop]);
                    extend(res[prop], childConfig[prop]);
                } else if (childConfig[prop] != null) {
                    res[prop] = childConfig[prop];
                } else {
                    delete res[prop];
                }
            }
        }
        for (prop in parentConfig) {
            if (hasOwnProp(parentConfig, prop) &&
                    !hasOwnProp(childConfig, prop) &&
                    isObject(parentConfig[prop])) {
                // make sure changes to properties don't modify parent config
                res[prop] = extend({}, res[prop]);
            }
        }
        return res;
    }

    function Locale(config) {
        if (config != null) {
            this.set(config);
        }
    }

    var keys;

    if (Object.keys) {
        keys = Object.keys;
    } else {
        keys = function (obj) {
            var i, res = [];
            for (i in obj) {
                if (hasOwnProp(obj, i)) {
                    res.push(i);
                }
            }
            return res;
        };
    }

    var defaultCalendar = {
        sameDay : '[Today at] LT',
        nextDay : '[Tomorrow at] LT',
        nextWeek : 'dddd [at] LT',
        lastDay : '[Yesterday at] LT',
        lastWeek : '[Last] dddd [at] LT',
        sameElse : 'L'
    };

    function calendar (key, mom, now) {
        var output = this._calendar[key] || this._calendar['sameElse'];
        return isFunction(output) ? output.call(mom, now) : output;
    }

    var defaultLongDateFormat = {
        LTS  : 'h:mm:ss A',
        LT   : 'h:mm A',
        L    : 'MM/DD/YYYY',
        LL   : 'MMMM D, YYYY',
        LLL  : 'MMMM D, YYYY h:mm A',
        LLLL : 'dddd, MMMM D, YYYY h:mm A'
    };

    function longDateFormat (key) {
        var format = this._longDateFormat[key],
            formatUpper = this._longDateFormat[key.toUpperCase()];

        if (format || !formatUpper) {
            return format;
        }

        this._longDateFormat[key] = formatUpper.replace(/MMMM|MM|DD|dddd/g, function (val) {
            return val.slice(1);
        });

        return this._longDateFormat[key];
    }

    var defaultInvalidDate = 'Invalid date';

    function invalidDate () {
        return this._invalidDate;
    }

    var defaultOrdinal = '%d';
    var defaultDayOfMonthOrdinalParse = /\d{1,2}/;

    function ordinal (number) {
        return this._ordinal.replace('%d', number);
    }

    var defaultRelativeTime = {
        future : 'in %s',
        past   : '%s ago',
        s  : 'a few seconds',
        ss : '%d seconds',
        m  : 'a minute',
        mm : '%d minutes',
        h  : 'an hour',
        hh : '%d hours',
        d  : 'a day',
        dd : '%d days',
        M  : 'a month',
        MM : '%d months',
        y  : 'a year',
        yy : '%d years'
    };

    function relativeTime (number, withoutSuffix, string, isFuture) {
        var output = this._relativeTime[string];
        return (isFunction(output)) ?
            output(number, withoutSuffix, string, isFuture) :
            output.replace(/%d/i, number);
    }

    function pastFuture (diff, output) {
        var format = this._relativeTime[diff > 0 ? 'future' : 'past'];
        return isFunction(format) ? format(output) : format.replace(/%s/i, output);
    }

    var aliases = {};

    function addUnitAlias (unit, shorthand) {
        var lowerCase = unit.toLowerCase();
        aliases[lowerCase] = aliases[lowerCase + 's'] = aliases[shorthand] = unit;
    }

    function normalizeUnits(units) {
        return typeof units === 'string' ? aliases[units] || aliases[units.toLowerCase()] : undefined;
    }

    function normalizeObjectUnits(inputObject) {
        var normalizedInput = {},
            normalizedProp,
            prop;

        for (prop in inputObject) {
            if (hasOwnProp(inputObject, prop)) {
                normalizedProp = normalizeUnits(prop);
                if (normalizedProp) {
                    normalizedInput[normalizedProp] = inputObject[prop];
                }
            }
        }

        return normalizedInput;
    }

    var priorities = {};

    function addUnitPriority(unit, priority) {
        priorities[unit] = priority;
    }

    function getPrioritizedUnits(unitsObj) {
        var units = [];
        for (var u in unitsObj) {
            units.push({unit: u, priority: priorities[u]});
        }
        units.sort(function (a, b) {
            return a.priority - b.priority;
        });
        return units;
    }

    function zeroFill(number, targetLength, forceSign) {
        var absNumber = '' + Math.abs(number),
            zerosToFill = targetLength - absNumber.length,
            sign = number >= 0;
        return (sign ? (forceSign ? '+' : '') : '-') +
            Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
    }

    var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g;

    var localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g;

    var formatFunctions = {};

    var formatTokenFunctions = {};

    // token:    'M'
    // padded:   ['MM', 2]
    // ordinal:  'Mo'
    // callback: function () { this.month() + 1 }
    function addFormatToken (token, padded, ordinal, callback) {
        var func = callback;
        if (typeof callback === 'string') {
            func = function () {
                return this[callback]();
            };
        }
        if (token) {
            formatTokenFunctions[token] = func;
        }
        if (padded) {
            formatTokenFunctions[padded[0]] = function () {
                return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
            };
        }
        if (ordinal) {
            formatTokenFunctions[ordinal] = function () {
                return this.localeData().ordinal(func.apply(this, arguments), token);
            };
        }
    }

    function removeFormattingTokens(input) {
        if (input.match(/\[[\s\S]/)) {
            return input.replace(/^\[|\]$/g, '');
        }
        return input.replace(/\\/g, '');
    }

    function makeFormatFunction(format) {
        var array = format.match(formattingTokens), i, length;

        for (i = 0, length = array.length; i < length; i++) {
            if (formatTokenFunctions[array[i]]) {
                array[i] = formatTokenFunctions[array[i]];
            } else {
                array[i] = removeFormattingTokens(array[i]);
            }
        }

        return function (mom) {
            var output = '', i;
            for (i = 0; i < length; i++) {
                output += isFunction(array[i]) ? array[i].call(mom, format) : array[i];
            }
            return output;
        };
    }

    // format date using native date object
    function formatMoment(m, format) {
        if (!m.isValid()) {
            return m.localeData().invalidDate();
        }

        format = expandFormat(format, m.localeData());
        formatFunctions[format] = formatFunctions[format] || makeFormatFunction(format);

        return formatFunctions[format](m);
    }

    function expandFormat(format, locale) {
        var i = 5;

        function replaceLongDateFormatTokens(input) {
            return locale.longDateFormat(input) || input;
        }

        localFormattingTokens.lastIndex = 0;
        while (i >= 0 && localFormattingTokens.test(format)) {
            format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);
            localFormattingTokens.lastIndex = 0;
            i -= 1;
        }

        return format;
    }

    var match1         = /\d/;            //       0 - 9
    var match2         = /\d\d/;          //      00 - 99
    var match3         = /\d{3}/;         //     000 - 999
    var match4         = /\d{4}/;         //    0000 - 9999
    var match6         = /[+-]?\d{6}/;    // -999999 - 999999
    var match1to2      = /\d\d?/;         //       0 - 99
    var match3to4      = /\d\d\d\d?/;     //     999 - 9999
    var match5to6      = /\d\d\d\d\d\d?/; //   99999 - 999999
    var match1to3      = /\d{1,3}/;       //       0 - 999
    var match1to4      = /\d{1,4}/;       //       0 - 9999
    var match1to6      = /[+-]?\d{1,6}/;  // -999999 - 999999

    var matchUnsigned  = /\d+/;           //       0 - inf
    var matchSigned    = /[+-]?\d+/;      //    -inf - inf

    var matchOffset    = /Z|[+-]\d\d:?\d\d/gi; // +00:00 -00:00 +0000 -0000 or Z
    var matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi; // +00 -00 +00:00 -00:00 +0000 -0000 or Z

    var matchTimestamp = /[+-]?\d+(\.\d{1,3})?/; // 123456789 123456789.123

    // any word (or two) characters or numbers including two/three word month in arabic.
    // includes scottish gaelic two word and hyphenated months
    var matchWord = /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i;

    var regexes = {};

    function addRegexToken (token, regex, strictRegex) {
        regexes[token] = isFunction(regex) ? regex : function (isStrict, localeData) {
            return (isStrict && strictRegex) ? strictRegex : regex;
        };
    }

    function getParseRegexForToken (token, config) {
        if (!hasOwnProp(regexes, token)) {
            return new RegExp(unescapeFormat(token));
        }

        return regexes[token](config._strict, config._locale);
    }

    // Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript
    function unescapeFormat(s) {
        return regexEscape(s.replace('\\', '').replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function (matched, p1, p2, p3, p4) {
            return p1 || p2 || p3 || p4;
        }));
    }

    function regexEscape(s) {
        return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
    }

    var tokens = {};

    function addParseToken (token, callback) {
        var i, func = callback;
        if (typeof token === 'string') {
            token = [token];
        }
        if (isNumber(callback)) {
            func = function (input, array) {
                array[callback] = toInt(input);
            };
        }
        for (i = 0; i < token.length; i++) {
            tokens[token[i]] = func;
        }
    }

    function addWeekParseToken (token, callback) {
        addParseToken(token, function (input, array, config, token) {
            config._w = config._w || {};
            callback(input, config._w, config, token);
        });
    }

    function addTimeToArrayFromToken(token, input, config) {
        if (input != null && hasOwnProp(tokens, token)) {
            tokens[token](input, config._a, config, token);
        }
    }

    var YEAR = 0;
    var MONTH = 1;
    var DATE = 2;
    var HOUR = 3;
    var MINUTE = 4;
    var SECOND = 5;
    var MILLISECOND = 6;
    var WEEK = 7;
    var WEEKDAY = 8;

    // FORMATTING

    addFormatToken('Y', 0, 0, function () {
        var y = this.year();
        return y <= 9999 ? '' + y : '+' + y;
    });

    addFormatToken(0, ['YY', 2], 0, function () {
        return this.year() % 100;
    });

    addFormatToken(0, ['YYYY',   4],       0, 'year');
    addFormatToken(0, ['YYYYY',  5],       0, 'year');
    addFormatToken(0, ['YYYYYY', 6, true], 0, 'year');

    // ALIASES

    addUnitAlias('year', 'y');

    // PRIORITIES

    addUnitPriority('year', 1);

    // PARSING

    addRegexToken('Y',      matchSigned);
    addRegexToken('YY',     match1to2, match2);
    addRegexToken('YYYY',   match1to4, match4);
    addRegexToken('YYYYY',  match1to6, match6);
    addRegexToken('YYYYYY', match1to6, match6);

    addParseToken(['YYYYY', 'YYYYYY'], YEAR);
    addParseToken('YYYY', function (input, array) {
        array[YEAR] = input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);
    });
    addParseToken('YY', function (input, array) {
        array[YEAR] = hooks.parseTwoDigitYear(input);
    });
    addParseToken('Y', function (input, array) {
        array[YEAR] = parseInt(input, 10);
    });

    // HELPERS

    function daysInYear(year) {
        return isLeapYear(year) ? 366 : 365;
    }

    function isLeapYear(year) {
        return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
    }

    // HOOKS

    hooks.parseTwoDigitYear = function (input) {
        return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);
    };

    // MOMENTS

    var getSetYear = makeGetSet('FullYear', true);

    function getIsLeapYear () {
        return isLeapYear(this.year());
    }

    function makeGetSet (unit, keepTime) {
        return function (value) {
            if (value != null) {
                set$1(this, unit, value);
                hooks.updateOffset(this, keepTime);
                return this;
            } else {
                return get(this, unit);
            }
        };
    }

    function get (mom, unit) {
        return mom.isValid() ?
            mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]() : NaN;
    }

    function set$1 (mom, unit, value) {
        if (mom.isValid() && !isNaN(value)) {
            if (unit === 'FullYear' && isLeapYear(mom.year()) && mom.month() === 1 && mom.date() === 29) {
                mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value, mom.month(), daysInMonth(value, mom.month()));
            }
            else {
                mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);
            }
        }
    }

    // MOMENTS

    function stringGet (units) {
        units = normalizeUnits(units);
        if (isFunction(this[units])) {
            return this[units]();
        }
        return this;
    }


    function stringSet (units, value) {
        if (typeof units === 'object') {
            units = normalizeObjectUnits(units);
            var prioritized = getPrioritizedUnits(units);
            for (var i = 0; i < prioritized.length; i++) {
                this[prioritized[i].unit](units[prioritized[i].unit]);
            }
        } else {
            units = normalizeUnits(units);
            if (isFunction(this[units])) {
                return this[units](value);
            }
        }
        return this;
    }

    function mod(n, x) {
        return ((n % x) + x) % x;
    }

    var indexOf;

    if (Array.prototype.indexOf) {
        indexOf = Array.prototype.indexOf;
    } else {
        indexOf = function (o) {
            // I know
            var i;
            for (i = 0; i < this.length; ++i) {
                if (this[i] === o) {
                    return i;
                }
            }
            return -1;
        };
    }

    function daysInMonth(year, month) {
        if (isNaN(year) || isNaN(month)) {
            return NaN;
        }
        var modMonth = mod(month, 12);
        year += (month - modMonth) / 12;
        return modMonth === 1 ? (isLeapYear(year) ? 29 : 28) : (31 - modMonth % 7 % 2);
    }

    // FORMATTING

    addFormatToken('M', ['MM', 2], 'Mo', function () {
        return this.month() + 1;
    });

    addFormatToken('MMM', 0, 0, function (format) {
        return this.localeData().monthsShort(this, format);
    });

    addFormatToken('MMMM', 0, 0, function (format) {
        return this.localeData().months(this, format);
    });

    // ALIASES

    addUnitAlias('month', 'M');

    // PRIORITY

    addUnitPriority('month', 8);

    // PARSING

    addRegexToken('M',    match1to2);
    addRegexToken('MM',   match1to2, match2);
    addRegexToken('MMM',  function (isStrict, locale) {
        return locale.monthsShortRegex(isStrict);
    });
    addRegexToken('MMMM', function (isStrict, locale) {
        return locale.monthsRegex(isStrict);
    });

    addParseToken(['M', 'MM'], function (input, array) {
        array[MONTH] = toInt(input) - 1;
    });

    addParseToken(['MMM', 'MMMM'], function (input, array, config, token) {
        var month = config._locale.monthsParse(input, token, config._strict);
        // if we didn't find a month name, mark the date as invalid.
        if (month != null) {
            array[MONTH] = month;
        } else {
            getParsingFlags(config).invalidMonth = input;
        }
    });

    // LOCALES

    var MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/;
    var defaultLocaleMonths = 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_');
    function localeMonths (m, format) {
        if (!m) {
            return isArray(this._months) ? this._months :
                this._months['standalone'];
        }
        return isArray(this._months) ? this._months[m.month()] :
            this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format) ? 'format' : 'standalone'][m.month()];
    }

    var defaultLocaleMonthsShort = 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_');
    function localeMonthsShort (m, format) {
        if (!m) {
            return isArray(this._monthsShort) ? this._monthsShort :
                this._monthsShort['standalone'];
        }
        return isArray(this._monthsShort) ? this._monthsShort[m.month()] :
            this._monthsShort[MONTHS_IN_FORMAT.test(format) ? 'format' : 'standalone'][m.month()];
    }

    function handleStrictParse(monthName, format, strict) {
        var i, ii, mom, llc = monthName.toLocaleLowerCase();
        if (!this._monthsParse) {
            // this is not used
            this._monthsParse = [];
            this._longMonthsParse = [];
            this._shortMonthsParse = [];
            for (i = 0; i < 12; ++i) {
                mom = createUTC([2000, i]);
                this._shortMonthsParse[i] = this.monthsShort(mom, '').toLocaleLowerCase();
                this._longMonthsParse[i] = this.months(mom, '').toLocaleLowerCase();
            }
        }

        if (strict) {
            if (format === 'MMM') {
                ii = indexOf.call(this._shortMonthsParse, llc);
                return ii !== -1 ? ii : null;
            } else {
                ii = indexOf.call(this._longMonthsParse, llc);
                return ii !== -1 ? ii : null;
            }
        } else {
            if (format === 'MMM') {
                ii = indexOf.call(this._shortMonthsParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._longMonthsParse, llc);
                return ii !== -1 ? ii : null;
            } else {
                ii = indexOf.call(this._longMonthsParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._shortMonthsParse, llc);
                return ii !== -1 ? ii : null;
            }
        }
    }

    function localeMonthsParse (monthName, format, strict) {
        var i, mom, regex;

        if (this._monthsParseExact) {
            return handleStrictParse.call(this, monthName, format, strict);
        }

        if (!this._monthsParse) {
            this._monthsParse = [];
            this._longMonthsParse = [];
            this._shortMonthsParse = [];
        }

        // TODO: add sorting
        // Sorting makes sure if one month (or abbr) is a prefix of another
        // see sorting in computeMonthsParse
        for (i = 0; i < 12; i++) {
            // make the regex if we don't have it already
            mom = createUTC([2000, i]);
            if (strict && !this._longMonthsParse[i]) {
                this._longMonthsParse[i] = new RegExp('^' + this.months(mom, '').replace('.', '') + '$', 'i');
                this._shortMonthsParse[i] = new RegExp('^' + this.monthsShort(mom, '').replace('.', '') + '$', 'i');
            }
            if (!strict && !this._monthsParse[i]) {
                regex = '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');
                this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');
            }
            // test the regex
            if (strict && format === 'MMMM' && this._longMonthsParse[i].test(monthName)) {
                return i;
            } else if (strict && format === 'MMM' && this._shortMonthsParse[i].test(monthName)) {
                return i;
            } else if (!strict && this._monthsParse[i].test(monthName)) {
                return i;
            }
        }
    }

    // MOMENTS

    function setMonth (mom, value) {
        var dayOfMonth;

        if (!mom.isValid()) {
            // No op
            return mom;
        }

        if (typeof value === 'string') {
            if (/^\d+$/.test(value)) {
                value = toInt(value);
            } else {
                value = mom.localeData().monthsParse(value);
                // TODO: Another silent failure?
                if (!isNumber(value)) {
                    return mom;
                }
            }
        }

        dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
        mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);
        return mom;
    }

    function getSetMonth (value) {
        if (value != null) {
            setMonth(this, value);
            hooks.updateOffset(this, true);
            return this;
        } else {
            return get(this, 'Month');
        }
    }

    function getDaysInMonth () {
        return daysInMonth(this.year(), this.month());
    }

    var defaultMonthsShortRegex = matchWord;
    function monthsShortRegex (isStrict) {
        if (this._monthsParseExact) {
            if (!hasOwnProp(this, '_monthsRegex')) {
                computeMonthsParse.call(this);
            }
            if (isStrict) {
                return this._monthsShortStrictRegex;
            } else {
                return this._monthsShortRegex;
            }
        } else {
            if (!hasOwnProp(this, '_monthsShortRegex')) {
                this._monthsShortRegex = defaultMonthsShortRegex;
            }
            return this._monthsShortStrictRegex && isStrict ?
                this._monthsShortStrictRegex : this._monthsShortRegex;
        }
    }

    var defaultMonthsRegex = matchWord;
    function monthsRegex (isStrict) {
        if (this._monthsParseExact) {
            if (!hasOwnProp(this, '_monthsRegex')) {
                computeMonthsParse.call(this);
            }
            if (isStrict) {
                return this._monthsStrictRegex;
            } else {
                return this._monthsRegex;
            }
        } else {
            if (!hasOwnProp(this, '_monthsRegex')) {
                this._monthsRegex = defaultMonthsRegex;
            }
            return this._monthsStrictRegex && isStrict ?
                this._monthsStrictRegex : this._monthsRegex;
        }
    }

    function computeMonthsParse () {
        function cmpLenRev(a, b) {
            return b.length - a.length;
        }

        var shortPieces = [], longPieces = [], mixedPieces = [],
            i, mom;
        for (i = 0; i < 12; i++) {
            // make the regex if we don't have it already
            mom = createUTC([2000, i]);
            shortPieces.push(this.monthsShort(mom, ''));
            longPieces.push(this.months(mom, ''));
            mixedPieces.push(this.months(mom, ''));
            mixedPieces.push(this.monthsShort(mom, ''));
        }
        // Sorting makes sure if one month (or abbr) is a prefix of another it
        // will match the longer piece.
        shortPieces.sort(cmpLenRev);
        longPieces.sort(cmpLenRev);
        mixedPieces.sort(cmpLenRev);
        for (i = 0; i < 12; i++) {
            shortPieces[i] = regexEscape(shortPieces[i]);
            longPieces[i] = regexEscape(longPieces[i]);
        }
        for (i = 0; i < 24; i++) {
            mixedPieces[i] = regexEscape(mixedPieces[i]);
        }

        this._monthsRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
        this._monthsShortRegex = this._monthsRegex;
        this._monthsStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
        this._monthsShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
    }

    function createDate (y, m, d, h, M, s, ms) {
        // can't just apply() to create a date:
        // https://stackoverflow.com/q/181348
        var date = new Date(y, m, d, h, M, s, ms);

        // the date constructor remaps years 0-99 to 1900-1999
        if (y < 100 && y >= 0 && isFinite(date.getFullYear())) {
            date.setFullYear(y);
        }
        return date;
    }

    function createUTCDate (y) {
        var date = new Date(Date.UTC.apply(null, arguments));

        // the Date.UTC function remaps years 0-99 to 1900-1999
        if (y < 100 && y >= 0 && isFinite(date.getUTCFullYear())) {
            date.setUTCFullYear(y);
        }
        return date;
    }

    // start-of-first-week - start-of-year
    function firstWeekOffset(year, dow, doy) {
        var // first-week day -- which january is always in the first week (4 for iso, 1 for other)
            fwd = 7 + dow - doy,
            // first-week day local weekday -- which local weekday is fwd
            fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;

        return -fwdlw + fwd - 1;
    }

    // https://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday
    function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
        var localWeekday = (7 + weekday - dow) % 7,
            weekOffset = firstWeekOffset(year, dow, doy),
            dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset,
            resYear, resDayOfYear;

        if (dayOfYear <= 0) {
            resYear = year - 1;
            resDayOfYear = daysInYear(resYear) + dayOfYear;
        } else if (dayOfYear > daysInYear(year)) {
            resYear = year + 1;
            resDayOfYear = dayOfYear - daysInYear(year);
        } else {
            resYear = year;
            resDayOfYear = dayOfYear;
        }

        return {
            year: resYear,
            dayOfYear: resDayOfYear
        };
    }

    function weekOfYear(mom, dow, doy) {
        var weekOffset = firstWeekOffset(mom.year(), dow, doy),
            week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1,
            resWeek, resYear;

        if (week < 1) {
            resYear = mom.year() - 1;
            resWeek = week + weeksInYear(resYear, dow, doy);
        } else if (week > weeksInYear(mom.year(), dow, doy)) {
            resWeek = week - weeksInYear(mom.year(), dow, doy);
            resYear = mom.year() + 1;
        } else {
            resYear = mom.year();
            resWeek = week;
        }

        return {
            week: resWeek,
            year: resYear
        };
    }

    function weeksInYear(year, dow, doy) {
        var weekOffset = firstWeekOffset(year, dow, doy),
            weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
        return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
    }

    // FORMATTING

    addFormatToken('w', ['ww', 2], 'wo', 'week');
    addFormatToken('W', ['WW', 2], 'Wo', 'isoWeek');

    // ALIASES

    addUnitAlias('week', 'w');
    addUnitAlias('isoWeek', 'W');

    // PRIORITIES

    addUnitPriority('week', 5);
    addUnitPriority('isoWeek', 5);

    // PARSING

    addRegexToken('w',  match1to2);
    addRegexToken('ww', match1to2, match2);
    addRegexToken('W',  match1to2);
    addRegexToken('WW', match1to2, match2);

    addWeekParseToken(['w', 'ww', 'W', 'WW'], function (input, week, config, token) {
        week[token.substr(0, 1)] = toInt(input);
    });

    // HELPERS

    // LOCALES

    function localeWeek (mom) {
        return weekOfYear(mom, this._week.dow, this._week.doy).week;
    }

    var defaultLocaleWeek = {
        dow : 0, // Sunday is the first day of the week.
        doy : 6  // The week that contains Jan 1st is the first week of the year.
    };

    function localeFirstDayOfWeek () {
        return this._week.dow;
    }

    function localeFirstDayOfYear () {
        return this._week.doy;
    }

    // MOMENTS

    function getSetWeek (input) {
        var week = this.localeData().week(this);
        return input == null ? week : this.add((input - week) * 7, 'd');
    }

    function getSetISOWeek (input) {
        var week = weekOfYear(this, 1, 4).week;
        return input == null ? week : this.add((input - week) * 7, 'd');
    }

    // FORMATTING

    addFormatToken('d', 0, 'do', 'day');

    addFormatToken('dd', 0, 0, function (format) {
        return this.localeData().weekdaysMin(this, format);
    });

    addFormatToken('ddd', 0, 0, function (format) {
        return this.localeData().weekdaysShort(this, format);
    });

    addFormatToken('dddd', 0, 0, function (format) {
        return this.localeData().weekdays(this, format);
    });

    addFormatToken('e', 0, 0, 'weekday');
    addFormatToken('E', 0, 0, 'isoWeekday');

    // ALIASES

    addUnitAlias('day', 'd');
    addUnitAlias('weekday', 'e');
    addUnitAlias('isoWeekday', 'E');

    // PRIORITY
    addUnitPriority('day', 11);
    addUnitPriority('weekday', 11);
    addUnitPriority('isoWeekday', 11);

    // PARSING

    addRegexToken('d',    match1to2);
    addRegexToken('e',    match1to2);
    addRegexToken('E',    match1to2);
    addRegexToken('dd',   function (isStrict, locale) {
        return locale.weekdaysMinRegex(isStrict);
    });
    addRegexToken('ddd',   function (isStrict, locale) {
        return locale.weekdaysShortRegex(isStrict);
    });
    addRegexToken('dddd',   function (isStrict, locale) {
        return locale.weekdaysRegex(isStrict);
    });

    addWeekParseToken(['dd', 'ddd', 'dddd'], function (input, week, config, token) {
        var weekday = config._locale.weekdaysParse(input, token, config._strict);
        // if we didn't get a weekday name, mark the date as invalid
        if (weekday != null) {
            week.d = weekday;
        } else {
            getParsingFlags(config).invalidWeekday = input;
        }
    });

    addWeekParseToken(['d', 'e', 'E'], function (input, week, config, token) {
        week[token] = toInt(input);
    });

    // HELPERS

    function parseWeekday(input, locale) {
        if (typeof input !== 'string') {
            return input;
        }

        if (!isNaN(input)) {
            return parseInt(input, 10);
        }

        input = locale.weekdaysParse(input);
        if (typeof input === 'number') {
            return input;
        }

        return null;
    }

    function parseIsoWeekday(input, locale) {
        if (typeof input === 'string') {
            return locale.weekdaysParse(input) % 7 || 7;
        }
        return isNaN(input) ? null : input;
    }

    // LOCALES

    var defaultLocaleWeekdays = 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_');
    function localeWeekdays (m, format) {
        if (!m) {
            return isArray(this._weekdays) ? this._weekdays :
                this._weekdays['standalone'];
        }
        return isArray(this._weekdays) ? this._weekdays[m.day()] :
            this._weekdays[this._weekdays.isFormat.test(format) ? 'format' : 'standalone'][m.day()];
    }

    var defaultLocaleWeekdaysShort = 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_');
    function localeWeekdaysShort (m) {
        return (m) ? this._weekdaysShort[m.day()] : this._weekdaysShort;
    }

    var defaultLocaleWeekdaysMin = 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_');
    function localeWeekdaysMin (m) {
        return (m) ? this._weekdaysMin[m.day()] : this._weekdaysMin;
    }

    function handleStrictParse$1(weekdayName, format, strict) {
        var i, ii, mom, llc = weekdayName.toLocaleLowerCase();
        if (!this._weekdaysParse) {
            this._weekdaysParse = [];
            this._shortWeekdaysParse = [];
            this._minWeekdaysParse = [];

            for (i = 0; i < 7; ++i) {
                mom = createUTC([2000, 1]).day(i);
                this._minWeekdaysParse[i] = this.weekdaysMin(mom, '').toLocaleLowerCase();
                this._shortWeekdaysParse[i] = this.weekdaysShort(mom, '').toLocaleLowerCase();
                this._weekdaysParse[i] = this.weekdays(mom, '').toLocaleLowerCase();
            }
        }

        if (strict) {
            if (format === 'dddd') {
                ii = indexOf.call(this._weekdaysParse, llc);
                return ii !== -1 ? ii : null;
            } else if (format === 'ddd') {
                ii = indexOf.call(this._shortWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            } else {
                ii = indexOf.call(this._minWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            }
        } else {
            if (format === 'dddd') {
                ii = indexOf.call(this._weekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._shortWeekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._minWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            } else if (format === 'ddd') {
                ii = indexOf.call(this._shortWeekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._weekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._minWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            } else {
                ii = indexOf.call(this._minWeekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._weekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._shortWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            }
        }
    }

    function localeWeekdaysParse (weekdayName, format, strict) {
        var i, mom, regex;

        if (this._weekdaysParseExact) {
            return handleStrictParse$1.call(this, weekdayName, format, strict);
        }

        if (!this._weekdaysParse) {
            this._weekdaysParse = [];
            this._minWeekdaysParse = [];
            this._shortWeekdaysParse = [];
            this._fullWeekdaysParse = [];
        }

        for (i = 0; i < 7; i++) {
            // make the regex if we don't have it already

            mom = createUTC([2000, 1]).day(i);
            if (strict && !this._fullWeekdaysParse[i]) {
                this._fullWeekdaysParse[i] = new RegExp('^' + this.weekdays(mom, '').replace('.', '\\.?') + '$', 'i');
                this._shortWeekdaysParse[i] = new RegExp('^' + this.weekdaysShort(mom, '').replace('.', '\\.?') + '$', 'i');
                this._minWeekdaysParse[i] = new RegExp('^' + this.weekdaysMin(mom, '').replace('.', '\\.?') + '$', 'i');
            }
            if (!this._weekdaysParse[i]) {
                regex = '^' + this.weekdays(mom, '') + '|^' + this.weekdaysShort(mom, '') + '|^' + this.weekdaysMin(mom, '');
                this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');
            }
            // test the regex
            if (strict && format === 'dddd' && this._fullWeekdaysParse[i].test(weekdayName)) {
                return i;
            } else if (strict && format === 'ddd' && this._shortWeekdaysParse[i].test(weekdayName)) {
                return i;
            } else if (strict && format === 'dd' && this._minWeekdaysParse[i].test(weekdayName)) {
                return i;
            } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {
                return i;
            }
        }
    }

    // MOMENTS

    function getSetDayOfWeek (input) {
        if (!this.isValid()) {
            return input != null ? this : NaN;
        }
        var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
        if (input != null) {
            input = parseWeekday(input, this.localeData());
            return this.add(input - day, 'd');
        } else {
            return day;
        }
    }

    function getSetLocaleDayOfWeek (input) {
        if (!this.isValid()) {
            return input != null ? this : NaN;
        }
        var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
        return input == null ? weekday : this.add(input - weekday, 'd');
    }

    function getSetISODayOfWeek (input) {
        if (!this.isValid()) {
            return input != null ? this : NaN;
        }

        // behaves the same as moment#day except
        // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)
        // as a setter, sunday should belong to the previous week.

        if (input != null) {
            var weekday = parseIsoWeekday(input, this.localeData());
            return this.day(this.day() % 7 ? weekday : weekday - 7);
        } else {
            return this.day() || 7;
        }
    }

    var defaultWeekdaysRegex = matchWord;
    function weekdaysRegex (isStrict) {
        if (this._weekdaysParseExact) {
            if (!hasOwnProp(this, '_weekdaysRegex')) {
                computeWeekdaysParse.call(this);
            }
            if (isStrict) {
                return this._weekdaysStrictRegex;
            } else {
                return this._weekdaysRegex;
            }
        } else {
            if (!hasOwnProp(this, '_weekdaysRegex')) {
                this._weekdaysRegex = defaultWeekdaysRegex;
            }
            return this._weekdaysStrictRegex && isStrict ?
                this._weekdaysStrictRegex : this._weekdaysRegex;
        }
    }

    var defaultWeekdaysShortRegex = matchWord;
    function weekdaysShortRegex (isStrict) {
        if (this._weekdaysParseExact) {
            if (!hasOwnProp(this, '_weekdaysRegex')) {
                computeWeekdaysParse.call(this);
            }
            if (isStrict) {
                return this._weekdaysShortStrictRegex;
            } else {
                return this._weekdaysShortRegex;
            }
        } else {
            if (!hasOwnProp(this, '_weekdaysShortRegex')) {
                this._weekdaysShortRegex = defaultWeekdaysShortRegex;
            }
            return this._weekdaysShortStrictRegex && isStrict ?
                this._weekdaysShortStrictRegex : this._weekdaysShortRegex;
        }
    }

    var defaultWeekdaysMinRegex = matchWord;
    function weekdaysMinRegex (isStrict) {
        if (this._weekdaysParseExact) {
            if (!hasOwnProp(this, '_weekdaysRegex')) {
                computeWeekdaysParse.call(this);
            }
            if (isStrict) {
                return this._weekdaysMinStrictRegex;
            } else {
                return this._weekdaysMinRegex;
            }
        } else {
            if (!hasOwnProp(this, '_weekdaysMinRegex')) {
                this._weekdaysMinRegex = defaultWeekdaysMinRegex;
            }
            return this._weekdaysMinStrictRegex && isStrict ?
                this._weekdaysMinStrictRegex : this._weekdaysMinRegex;
        }
    }


    function computeWeekdaysParse () {
        function cmpLenRev(a, b) {
            return b.length - a.length;
        }

        var minPieces = [], shortPieces = [], longPieces = [], mixedPieces = [],
            i, mom, minp, shortp, longp;
        for (i = 0; i < 7; i++) {
            // make the regex if we don't have it already
            mom = createUTC([2000, 1]).day(i);
            minp = this.weekdaysMin(mom, '');
            shortp = this.weekdaysShort(mom, '');
            longp = this.weekdays(mom, '');
            minPieces.push(minp);
            shortPieces.push(shortp);
            longPieces.push(longp);
            mixedPieces.push(minp);
            mixedPieces.push(shortp);
            mixedPieces.push(longp);
        }
        // Sorting makes sure if one weekday (or abbr) is a prefix of another it
        // will match the longer piece.
        minPieces.sort(cmpLenRev);
        shortPieces.sort(cmpLenRev);
        longPieces.sort(cmpLenRev);
        mixedPieces.sort(cmpLenRev);
        for (i = 0; i < 7; i++) {
            shortPieces[i] = regexEscape(shortPieces[i]);
            longPieces[i] = regexEscape(longPieces[i]);
            mixedPieces[i] = regexEscape(mixedPieces[i]);
        }

        this._weekdaysRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
        this._weekdaysShortRegex = this._weekdaysRegex;
        this._weekdaysMinRegex = this._weekdaysRegex;

        this._weekdaysStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
        this._weekdaysShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
        this._weekdaysMinStrictRegex = new RegExp('^(' + minPieces.join('|') + ')', 'i');
    }

    // FORMATTING

    function hFormat() {
        return this.hours() % 12 || 12;
    }

    function kFormat() {
        return this.hours() || 24;
    }

    addFormatToken('H', ['HH', 2], 0, 'hour');
    addFormatToken('h', ['hh', 2], 0, hFormat);
    addFormatToken('k', ['kk', 2], 0, kFormat);

    addFormatToken('hmm', 0, 0, function () {
        return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2);
    });

    addFormatToken('hmmss', 0, 0, function () {
        return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2) +
            zeroFill(this.seconds(), 2);
    });

    addFormatToken('Hmm', 0, 0, function () {
        return '' + this.hours() + zeroFill(this.minutes(), 2);
    });

    addFormatToken('Hmmss', 0, 0, function () {
        return '' + this.hours() + zeroFill(this.minutes(), 2) +
            zeroFill(this.seconds(), 2);
    });

    function meridiem (token, lowercase) {
        addFormatToken(token, 0, 0, function () {
            return this.localeData().meridiem(this.hours(), this.minutes(), lowercase);
        });
    }

    meridiem('a', true);
    meridiem('A', false);

    // ALIASES

    addUnitAlias('hour', 'h');

    // PRIORITY
    addUnitPriority('hour', 13);

    // PARSING

    function matchMeridiem (isStrict, locale) {
        return locale._meridiemParse;
    }

    addRegexToken('a',  matchMeridiem);
    addRegexToken('A',  matchMeridiem);
    addRegexToken('H',  match1to2);
    addRegexToken('h',  match1to2);
    addRegexToken('k',  match1to2);
    addRegexToken('HH', match1to2, match2);
    addRegexToken('hh', match1to2, match2);
    addRegexToken('kk', match1to2, match2);

    addRegexToken('hmm', match3to4);
    addRegexToken('hmmss', match5to6);
    addRegexToken('Hmm', match3to4);
    addRegexToken('Hmmss', match5to6);

    addParseToken(['H', 'HH'], HOUR);
    addParseToken(['k', 'kk'], function (input, array, config) {
        var kInput = toInt(input);
        array[HOUR] = kInput === 24 ? 0 : kInput;
    });
    addParseToken(['a', 'A'], function (input, array, config) {
        config._isPm = config._locale.isPM(input);
        config._meridiem = input;
    });
    addParseToken(['h', 'hh'], function (input, array, config) {
        array[HOUR] = toInt(input);
        getParsingFlags(config).bigHour = true;
    });
    addParseToken('hmm', function (input, array, config) {
        var pos = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos));
        array[MINUTE] = toInt(input.substr(pos));
        getParsingFlags(config).bigHour = true;
    });
    addParseToken('hmmss', function (input, array, config) {
        var pos1 = input.length - 4;
        var pos2 = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos1));
        array[MINUTE] = toInt(input.substr(pos1, 2));
        array[SECOND] = toInt(input.substr(pos2));
        getParsingFlags(config).bigHour = true;
    });
    addParseToken('Hmm', function (input, array, config) {
        var pos = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos));
        array[MINUTE] = toInt(input.substr(pos));
    });
    addParseToken('Hmmss', function (input, array, config) {
        var pos1 = input.length - 4;
        var pos2 = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos1));
        array[MINUTE] = toInt(input.substr(pos1, 2));
        array[SECOND] = toInt(input.substr(pos2));
    });

    // LOCALES

    function localeIsPM (input) {
        // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays
        // Using charAt should be more compatible.
        return ((input + '').toLowerCase().charAt(0) === 'p');
    }

    var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i;
    function localeMeridiem (hours, minutes, isLower) {
        if (hours > 11) {
            return isLower ? 'pm' : 'PM';
        } else {
            return isLower ? 'am' : 'AM';
        }
    }


    // MOMENTS

    // Setting the hour should keep the time, because the user explicitly
    // specified which hour they want. So trying to maintain the same hour (in
    // a new timezone) makes sense. Adding/subtracting hours does not follow
    // this rule.
    var getSetHour = makeGetSet('Hours', true);

    var baseConfig = {
        calendar: defaultCalendar,
        longDateFormat: defaultLongDateFormat,
        invalidDate: defaultInvalidDate,
        ordinal: defaultOrdinal,
        dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,
        relativeTime: defaultRelativeTime,

        months: defaultLocaleMonths,
        monthsShort: defaultLocaleMonthsShort,

        week: defaultLocaleWeek,

        weekdays: defaultLocaleWeekdays,
        weekdaysMin: defaultLocaleWeekdaysMin,
        weekdaysShort: defaultLocaleWeekdaysShort,

        meridiemParse: defaultLocaleMeridiemParse
    };

    // internal storage for locale config files
    var locales = {};
    var localeFamilies = {};
    var globalLocale;

    function normalizeLocale(key) {
        return key ? key.toLowerCase().replace('_', '-') : key;
    }

    // pick the locale from the array
    // try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each
    // substring from most specific to least, but move to the next array item if it's a more specific variant than the current root
    function chooseLocale(names) {
        var i = 0, j, next, locale, split;

        while (i < names.length) {
            split = normalizeLocale(names[i]).split('-');
            j = split.length;
            next = normalizeLocale(names[i + 1]);
            next = next ? next.split('-') : null;
            while (j > 0) {
                locale = loadLocale(split.slice(0, j).join('-'));
                if (locale) {
                    return locale;
                }
                if (next && next.length >= j && compareArrays(split, next, true) >= j - 1) {
                    //the next array item is better than a shallower substring of this one
                    break;
                }
                j--;
            }
            i++;
        }
        return globalLocale;
    }

    function loadLocale(name) {
        var oldLocale = null;
        // TODO: Find a better way to register and load all the locales in Node
        if (!locales[name] && (typeof module !== 'undefined') &&
                module && module.exports) {
            try {
                oldLocale = globalLocale._abbr;
                var aliasedRequire = require;
                aliasedRequire('./locale/' + name);
                getSetGlobalLocale(oldLocale);
            } catch (e) {}
        }
        return locales[name];
    }

    // This function will load locale and then set the global locale.  If
    // no arguments are passed in, it will simply return the current global
    // locale key.
    function getSetGlobalLocale (key, values) {
        var data;
        if (key) {
            if (isUndefined(values)) {
                data = getLocale(key);
            }
            else {
                data = defineLocale(key, values);
            }

            if (data) {
                // moment.duration._locale = moment._locale = data;
                globalLocale = data;
            }
            else {
                if ((typeof console !==  'undefined') && console.warn) {
                    //warn user if arguments are passed but the locale could not be set
                    console.warn('Locale ' + key +  ' not found. Did you forget to load it?');
                }
            }
        }

        return globalLocale._abbr;
    }

    function defineLocale (name, config) {
        if (config !== null) {
            var locale, parentConfig = baseConfig;
            config.abbr = name;
            if (locales[name] != null) {
                deprecateSimple('defineLocaleOverride',
                        'use moment.updateLocale(localeName, config) to change ' +
                        'an existing locale. moment.defineLocale(localeName, ' +
                        'config) should only be used for creating a new locale ' +
                        'See http://momentjs.com/guides/#/warnings/define-locale/ for more info.');
                parentConfig = locales[name]._config;
            } else if (config.parentLocale != null) {
                if (locales[config.parentLocale] != null) {
                    parentConfig = locales[config.parentLocale]._config;
                } else {
                    locale = loadLocale(config.parentLocale);
                    if (locale != null) {
                        parentConfig = locale._config;
                    } else {
                        if (!localeFamilies[config.parentLocale]) {
                            localeFamilies[config.parentLocale] = [];
                        }
                        localeFamilies[config.parentLocale].push({
                            name: name,
                            config: config
                        });
                        return null;
                    }
                }
            }
            locales[name] = new Locale(mergeConfigs(parentConfig, config));

            if (localeFamilies[name]) {
                localeFamilies[name].forEach(function (x) {
                    defineLocale(x.name, x.config);
                });
            }

            // backwards compat for now: also set the locale
            // make sure we set the locale AFTER all child locales have been
            // created, so we won't end up with the child locale set.
            getSetGlobalLocale(name);


            return locales[name];
        } else {
            // useful for testing
            delete locales[name];
            return null;
        }
    }

    function updateLocale(name, config) {
        if (config != null) {
            var locale, tmpLocale, parentConfig = baseConfig;
            // MERGE
            tmpLocale = loadLocale(name);
            if (tmpLocale != null) {
                parentConfig = tmpLocale._config;
            }
            config = mergeConfigs(parentConfig, config);
            locale = new Locale(config);
            locale.parentLocale = locales[name];
            locales[name] = locale;

            // backwards compat for now: also set the locale
            getSetGlobalLocale(name);
        } else {
            // pass null for config to unupdate, useful for tests
            if (locales[name] != null) {
                if (locales[name].parentLocale != null) {
                    locales[name] = locales[name].parentLocale;
                } else if (locales[name] != null) {
                    delete locales[name];
                }
            }
        }
        return locales[name];
    }

    // returns locale data
    function getLocale (key) {
        var locale;

        if (key && key._locale && key._locale._abbr) {
            key = key._locale._abbr;
        }

        if (!key) {
            return globalLocale;
        }

        if (!isArray(key)) {
            //short-circuit everything else
            locale = loadLocale(key);
            if (locale) {
                return locale;
            }
            key = [key];
        }

        return chooseLocale(key);
    }

    function listLocales() {
        return keys(locales);
    }

    function checkOverflow (m) {
        var overflow;
        var a = m._a;

        if (a && getParsingFlags(m).overflow === -2) {
            overflow =
                a[MONTH]       < 0 || a[MONTH]       > 11  ? MONTH :
                a[DATE]        < 1 || a[DATE]        > daysInMonth(a[YEAR], a[MONTH]) ? DATE :
                a[HOUR]        < 0 || a[HOUR]        > 24 || (a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0)) ? HOUR :
                a[MINUTE]      < 0 || a[MINUTE]      > 59  ? MINUTE :
                a[SECOND]      < 0 || a[SECOND]      > 59  ? SECOND :
                a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND :
                -1;

            if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
                overflow = DATE;
            }
            if (getParsingFlags(m)._overflowWeeks && overflow === -1) {
                overflow = WEEK;
            }
            if (getParsingFlags(m)._overflowWeekday && overflow === -1) {
                overflow = WEEKDAY;
            }

            getParsingFlags(m).overflow = overflow;
        }

        return m;
    }

    // Pick the first defined of two or three arguments.
    function defaults(a, b, c) {
        if (a != null) {
            return a;
        }
        if (b != null) {
            return b;
        }
        return c;
    }

    function currentDateArray(config) {
        // hooks is actually the exported moment object
        var nowValue = new Date(hooks.now());
        if (config._useUTC) {
            return [nowValue.getUTCFullYear(), nowValue.getUTCMonth(), nowValue.getUTCDate()];
        }
        return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
    }

    // convert an array to a date.
    // the array should mirror the parameters below
    // note: all values past the year are optional and will default to the lowest possible value.
    // [year, month, day , hour, minute, second, millisecond]
    function configFromArray (config) {
        var i, date, input = [], currentDate, expectedWeekday, yearToUse;

        if (config._d) {
            return;
        }

        currentDate = currentDateArray(config);

        //compute day of the year from weeks and weekdays
        if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
            dayOfYearFromWeekInfo(config);
        }

        //if the day of the year is set, figure out what it is
        if (config._dayOfYear != null) {
            yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);

            if (config._dayOfYear > daysInYear(yearToUse) || config._dayOfYear === 0) {
                getParsingFlags(config)._overflowDayOfYear = true;
            }

            date = createUTCDate(yearToUse, 0, config._dayOfYear);
            config._a[MONTH] = date.getUTCMonth();
            config._a[DATE] = date.getUTCDate();
        }

        // Default to current date.
        // * if no year, month, day of month are given, default to today
        // * if day of month is given, default month and year
        // * if month is given, default only year
        // * if year is given, don't default anything
        for (i = 0; i < 3 && config._a[i] == null; ++i) {
            config._a[i] = input[i] = currentDate[i];
        }

        // Zero out whatever was not defaulted, including time
        for (; i < 7; i++) {
            config._a[i] = input[i] = (config._a[i] == null) ? (i === 2 ? 1 : 0) : config._a[i];
        }

        // Check for 24:00:00.000
        if (config._a[HOUR] === 24 &&
                config._a[MINUTE] === 0 &&
                config._a[SECOND] === 0 &&
                config._a[MILLISECOND] === 0) {
            config._nextDay = true;
            config._a[HOUR] = 0;
        }

        config._d = (config._useUTC ? createUTCDate : createDate).apply(null, input);
        expectedWeekday = config._useUTC ? config._d.getUTCDay() : config._d.getDay();

        // Apply timezone offset from input. The actual utcOffset can be changed
        // with parseZone.
        if (config._tzm != null) {
            config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
        }

        if (config._nextDay) {
            config._a[HOUR] = 24;
        }

        // check for mismatching day of week
        if (config._w && typeof config._w.d !== 'undefined' && config._w.d !== expectedWeekday) {
            getParsingFlags(config).weekdayMismatch = true;
        }
    }

    function dayOfYearFromWeekInfo(config) {
        var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow;

        w = config._w;
        if (w.GG != null || w.W != null || w.E != null) {
            dow = 1;
            doy = 4;

            // TODO: We need to take the current isoWeekYear, but that depends on
            // how we interpret now (local, utc, fixed offset). So create
            // a now version of current config (take local/utc/offset flags, and
            // create now).
            weekYear = defaults(w.GG, config._a[YEAR], weekOfYear(createLocal(), 1, 4).year);
            week = defaults(w.W, 1);
            weekday = defaults(w.E, 1);
            if (weekday < 1 || weekday > 7) {
                weekdayOverflow = true;
            }
        } else {
            dow = config._locale._week.dow;
            doy = config._locale._week.doy;

            var curWeek = weekOfYear(createLocal(), dow, doy);

            weekYear = defaults(w.gg, config._a[YEAR], curWeek.year);

            // Default to current week.
            week = defaults(w.w, curWeek.week);

            if (w.d != null) {
                // weekday -- low day numbers are considered next week
                weekday = w.d;
                if (weekday < 0 || weekday > 6) {
                    weekdayOverflow = true;
                }
            } else if (w.e != null) {
                // local weekday -- counting starts from begining of week
                weekday = w.e + dow;
                if (w.e < 0 || w.e > 6) {
                    weekdayOverflow = true;
                }
            } else {
                // default to begining of week
                weekday = dow;
            }
        }
        if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
            getParsingFlags(config)._overflowWeeks = true;
        } else if (weekdayOverflow != null) {
            getParsingFlags(config)._overflowWeekday = true;
        } else {
            temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
            config._a[YEAR] = temp.year;
            config._dayOfYear = temp.dayOfYear;
        }
    }

    // iso 8601 regex
    // 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)
    var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/;
    var basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/;

    var tzRegex = /Z|[+-]\d\d(?::?\d\d)?/;

    var isoDates = [
        ['YYYYYY-MM-DD', /[+-]\d{6}-\d\d-\d\d/],
        ['YYYY-MM-DD', /\d{4}-\d\d-\d\d/],
        ['GGGG-[W]WW-E', /\d{4}-W\d\d-\d/],
        ['GGGG-[W]WW', /\d{4}-W\d\d/, false],
        ['YYYY-DDD', /\d{4}-\d{3}/],
        ['YYYY-MM', /\d{4}-\d\d/, false],
        ['YYYYYYMMDD', /[+-]\d{10}/],
        ['YYYYMMDD', /\d{8}/],
        // YYYYMM is NOT allowed by the standard
        ['GGGG[W]WWE', /\d{4}W\d{3}/],
        ['GGGG[W]WW', /\d{4}W\d{2}/, false],
        ['YYYYDDD', /\d{7}/]
    ];

    // iso time formats and regexes
    var isoTimes = [
        ['HH:mm:ss.SSSS', /\d\d:\d\d:\d\d\.\d+/],
        ['HH:mm:ss,SSSS', /\d\d:\d\d:\d\d,\d+/],
        ['HH:mm:ss', /\d\d:\d\d:\d\d/],
        ['HH:mm', /\d\d:\d\d/],
        ['HHmmss.SSSS', /\d\d\d\d\d\d\.\d+/],
        ['HHmmss,SSSS', /\d\d\d\d\d\d,\d+/],
        ['HHmmss', /\d\d\d\d\d\d/],
        ['HHmm', /\d\d\d\d/],
        ['HH', /\d\d/]
    ];

    var aspNetJsonRegex = /^\/?Date\((\-?\d+)/i;

    // date from iso format
    function configFromISO(config) {
        var i, l,
            string = config._i,
            match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string),
            allowTime, dateFormat, timeFormat, tzFormat;

        if (match) {
            getParsingFlags(config).iso = true;

            for (i = 0, l = isoDates.length; i < l; i++) {
                if (isoDates[i][1].exec(match[1])) {
                    dateFormat = isoDates[i][0];
                    allowTime = isoDates[i][2] !== false;
                    break;
                }
            }
            if (dateFormat == null) {
                config._isValid = false;
                return;
            }
            if (match[3]) {
                for (i = 0, l = isoTimes.length; i < l; i++) {
                    if (isoTimes[i][1].exec(match[3])) {
                        // match[2] should be 'T' or space
                        timeFormat = (match[2] || ' ') + isoTimes[i][0];
                        break;
                    }
                }
                if (timeFormat == null) {
                    config._isValid = false;
                    return;
                }
            }
            if (!allowTime && timeFormat != null) {
                config._isValid = false;
                return;
            }
            if (match[4]) {
                if (tzRegex.exec(match[4])) {
                    tzFormat = 'Z';
                } else {
                    config._isValid = false;
                    return;
                }
            }
            config._f = dateFormat + (timeFormat || '') + (tzFormat || '');
            configFromStringAndFormat(config);
        } else {
            config._isValid = false;
        }
    }

    // RFC 2822 regex: For details see https://tools.ietf.org/html/rfc2822#section-3.3
    var rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/;

    function extractFromRFC2822Strings(yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {
        var result = [
            untruncateYear(yearStr),
            defaultLocaleMonthsShort.indexOf(monthStr),
            parseInt(dayStr, 10),
            parseInt(hourStr, 10),
            parseInt(minuteStr, 10)
        ];

        if (secondStr) {
            result.push(parseInt(secondStr, 10));
        }

        return result;
    }

    function untruncateYear(yearStr) {
        var year = parseInt(yearStr, 10);
        if (year <= 49) {
            return 2000 + year;
        } else if (year <= 999) {
            return 1900 + year;
        }
        return year;
    }

    function preprocessRFC2822(s) {
        // Remove comments and folding whitespace and replace multiple-spaces with a single space
        return s.replace(/\([^)]*\)|[\n\t]/g, ' ').replace(/(\s\s+)/g, ' ').replace(/^\s\s*/, '').replace(/\s\s*$/, '');
    }

    function checkWeekday(weekdayStr, parsedInput, config) {
        if (weekdayStr) {
            // TODO: Replace the vanilla JS Date object with an indepentent day-of-week check.
            var weekdayProvided = defaultLocaleWeekdaysShort.indexOf(weekdayStr),
                weekdayActual = new Date(parsedInput[0], parsedInput[1], parsedInput[2]).getDay();
            if (weekdayProvided !== weekdayActual) {
                getParsingFlags(config).weekdayMismatch = true;
                config._isValid = false;
                return false;
            }
        }
        return true;
    }

    var obsOffsets = {
        UT: 0,
        GMT: 0,
        EDT: -4 * 60,
        EST: -5 * 60,
        CDT: -5 * 60,
        CST: -6 * 60,
        MDT: -6 * 60,
        MST: -7 * 60,
        PDT: -7 * 60,
        PST: -8 * 60
    };

    function calculateOffset(obsOffset, militaryOffset, numOffset) {
        if (obsOffset) {
            return obsOffsets[obsOffset];
        } else if (militaryOffset) {
            // the only allowed military tz is Z
            return 0;
        } else {
            var hm = parseInt(numOffset, 10);
            var m = hm % 100, h = (hm - m) / 100;
            return h * 60 + m;
        }
    }

    // date and time from ref 2822 format
    function configFromRFC2822(config) {
        var match = rfc2822.exec(preprocessRFC2822(config._i));
        if (match) {
            var parsedArray = extractFromRFC2822Strings(match[4], match[3], match[2], match[5], match[6], match[7]);
            if (!checkWeekday(match[1], parsedArray, config)) {
                return;
            }

            config._a = parsedArray;
            config._tzm = calculateOffset(match[8], match[9], match[10]);

            config._d = createUTCDate.apply(null, config._a);
            config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);

            getParsingFlags(config).rfc2822 = true;
        } else {
            config._isValid = false;
        }
    }

    // date from iso format or fallback
    function configFromString(config) {
        var matched = aspNetJsonRegex.exec(config._i);

        if (matched !== null) {
            config._d = new Date(+matched[1]);
            return;
        }

        configFromISO(config);
        if (config._isValid === false) {
            delete config._isValid;
        } else {
            return;
        }

        configFromRFC2822(config);
        if (config._isValid === false) {
            delete config._isValid;
        } else {
            return;
        }

        // Final attempt, use Input Fallback
        hooks.createFromInputFallback(config);
    }

    hooks.createFromInputFallback = deprecate(
        'value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), ' +
        'which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are ' +
        'discouraged and will be removed in an upcoming major release. Please refer to ' +
        'http://momentjs.com/guides/#/warnings/js-date/ for more info.',
        function (config) {
            config._d = new Date(config._i + (config._useUTC ? ' UTC' : ''));
        }
    );

    // constant that refers to the ISO standard
    hooks.ISO_8601 = function () {};

    // constant that refers to the RFC 2822 form
    hooks.RFC_2822 = function () {};

    // date from string and format string
    function configFromStringAndFormat(config) {
        // TODO: Move this to another part of the creation flow to prevent circular deps
        if (config._f === hooks.ISO_8601) {
            configFromISO(config);
            return;
        }
        if (config._f === hooks.RFC_2822) {
            configFromRFC2822(config);
            return;
        }
        config._a = [];
        getParsingFlags(config).empty = true;

        // This array is used to make a Date, either with `new Date` or `Date.UTC`
        var string = '' + config._i,
            i, parsedInput, tokens, token, skipped,
            stringLength = string.length,
            totalParsedInputLength = 0;

        tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [];

        for (i = 0; i < tokens.length; i++) {
            token = tokens[i];
            parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];
            // console.log('token', token, 'parsedInput', parsedInput,
            //         'regex', getParseRegexForToken(token, config));
            if (parsedInput) {
                skipped = string.substr(0, string.indexOf(parsedInput));
                if (skipped.length > 0) {
                    getParsingFlags(config).unusedInput.push(skipped);
                }
                string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
                totalParsedInputLength += parsedInput.length;
            }
            // don't parse if it's not a known token
            if (formatTokenFunctions[token]) {
                if (parsedInput) {
                    getParsingFlags(config).empty = false;
                }
                else {
                    getParsingFlags(config).unusedTokens.push(token);
                }
                addTimeToArrayFromToken(token, parsedInput, config);
            }
            else if (config._strict && !parsedInput) {
                getParsingFlags(config).unusedTokens.push(token);
            }
        }

        // add remaining unparsed input length to the string
        getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;
        if (string.length > 0) {
            getParsingFlags(config).unusedInput.push(string);
        }

        // clear _12h flag if hour is <= 12
        if (config._a[HOUR] <= 12 &&
            getParsingFlags(config).bigHour === true &&
            config._a[HOUR] > 0) {
            getParsingFlags(config).bigHour = undefined;
        }

        getParsingFlags(config).parsedDateParts = config._a.slice(0);
        getParsingFlags(config).meridiem = config._meridiem;
        // handle meridiem
        config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem);

        configFromArray(config);
        checkOverflow(config);
    }


    function meridiemFixWrap (locale, hour, meridiem) {
        var isPm;

        if (meridiem == null) {
            // nothing to do
            return hour;
        }
        if (locale.meridiemHour != null) {
            return locale.meridiemHour(hour, meridiem);
        } else if (locale.isPM != null) {
            // Fallback
            isPm = locale.isPM(meridiem);
            if (isPm && hour < 12) {
                hour += 12;
            }
            if (!isPm && hour === 12) {
                hour = 0;
            }
            return hour;
        } else {
            // this is not supposed to happen
            return hour;
        }
    }

    // date from string and array of format strings
    function configFromStringAndArray(config) {
        var tempConfig,
            bestMoment,

            scoreToBeat,
            i,
            currentScore;

        if (config._f.length === 0) {
            getParsingFlags(config).invalidFormat = true;
            config._d = new Date(NaN);
            return;
        }

        for (i = 0; i < config._f.length; i++) {
            currentScore = 0;
            tempConfig = copyConfig({}, config);
            if (config._useUTC != null) {
                tempConfig._useUTC = config._useUTC;
            }
            tempConfig._f = config._f[i];
            configFromStringAndFormat(tempConfig);

            if (!isValid(tempConfig)) {
                continue;
            }

            // if there is any input that was not parsed add a penalty for that format
            currentScore += getParsingFlags(tempConfig).charsLeftOver;

            //or tokens
            currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;

            getParsingFlags(tempConfig).score = currentScore;

            if (scoreToBeat == null || currentScore < scoreToBeat) {
                scoreToBeat = currentScore;
                bestMoment = tempConfig;
            }
        }

        extend(config, bestMoment || tempConfig);
    }

    function configFromObject(config) {
        if (config._d) {
            return;
        }

        var i = normalizeObjectUnits(config._i);
        config._a = map([i.year, i.month, i.day || i.date, i.hour, i.minute, i.second, i.millisecond], function (obj) {
            return obj && parseInt(obj, 10);
        });

        configFromArray(config);
    }

    function createFromConfig (config) {
        var res = new Moment(checkOverflow(prepareConfig(config)));
        if (res._nextDay) {
            // Adding is smart enough around DST
            res.add(1, 'd');
            res._nextDay = undefined;
        }

        return res;
    }

    function prepareConfig (config) {
        var input = config._i,
            format = config._f;

        config._locale = config._locale || getLocale(config._l);

        if (input === null || (format === undefined && input === '')) {
            return createInvalid({nullInput: true});
        }

        if (typeof input === 'string') {
            config._i = input = config._locale.preparse(input);
        }

        if (isMoment(input)) {
            return new Moment(checkOverflow(input));
        } else if (isDate(input)) {
            config._d = input;
        } else if (isArray(format)) {
            configFromStringAndArray(config);
        } else if (format) {
            configFromStringAndFormat(config);
        }  else {
            configFromInput(config);
        }

        if (!isValid(config)) {
            config._d = null;
        }

        return config;
    }

    function configFromInput(config) {
        var input = config._i;
        if (isUndefined(input)) {
            config._d = new Date(hooks.now());
        } else if (isDate(input)) {
            config._d = new Date(input.valueOf());
        } else if (typeof input === 'string') {
            configFromString(config);
        } else if (isArray(input)) {
            config._a = map(input.slice(0), function (obj) {
                return parseInt(obj, 10);
            });
            configFromArray(config);
        } else if (isObject(input)) {
            configFromObject(config);
        } else if (isNumber(input)) {
            // from milliseconds
            config._d = new Date(input);
        } else {
            hooks.createFromInputFallback(config);
        }
    }

    function createLocalOrUTC (input, format, locale, strict, isUTC) {
        var c = {};

        if (locale === true || locale === false) {
            strict = locale;
            locale = undefined;
        }

        if ((isObject(input) && isObjectEmpty(input)) ||
                (isArray(input) && input.length === 0)) {
            input = undefined;
        }
        // object construction must be done this way.
        // https://github.com/moment/moment/issues/1423
        c._isAMomentObject = true;
        c._useUTC = c._isUTC = isUTC;
        c._l = locale;
        c._i = input;
        c._f = format;
        c._strict = strict;

        return createFromConfig(c);
    }

    function createLocal (input, format, locale, strict) {
        return createLocalOrUTC(input, format, locale, strict, false);
    }

    var prototypeMin = deprecate(
        'moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/',
        function () {
            var other = createLocal.apply(null, arguments);
            if (this.isValid() && other.isValid()) {
                return other < this ? this : other;
            } else {
                return createInvalid();
            }
        }
    );

    var prototypeMax = deprecate(
        'moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/',
        function () {
            var other = createLocal.apply(null, arguments);
            if (this.isValid() && other.isValid()) {
                return other > this ? this : other;
            } else {
                return createInvalid();
            }
        }
    );

    // Pick a moment m from moments so that m[fn](other) is true for all
    // other. This relies on the function fn to be transitive.
    //
    // moments should either be an array of moment objects or an array, whose
    // first element is an array of moment objects.
    function pickBy(fn, moments) {
        var res, i;
        if (moments.length === 1 && isArray(moments[0])) {
            moments = moments[0];
        }
        if (!moments.length) {
            return createLocal();
        }
        res = moments[0];
        for (i = 1; i < moments.length; ++i) {
            if (!moments[i].isValid() || moments[i][fn](res)) {
                res = moments[i];
            }
        }
        return res;
    }

    // TODO: Use [].sort instead?
    function min () {
        var args = [].slice.call(arguments, 0);

        return pickBy('isBefore', args);
    }

    function max () {
        var args = [].slice.call(arguments, 0);

        return pickBy('isAfter', args);
    }

    var now = function () {
        return Date.now ? Date.now() : +(new Date());
    };

    var ordering = ['year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', 'millisecond'];

    function isDurationValid(m) {
        for (var key in m) {
            if (!(indexOf.call(ordering, key) !== -1 && (m[key] == null || !isNaN(m[key])))) {
                return false;
            }
        }

        var unitHasDecimal = false;
        for (var i = 0; i < ordering.length; ++i) {
            if (m[ordering[i]]) {
                if (unitHasDecimal) {
                    return false; // only allow non-integers for smallest unit
                }
                if (parseFloat(m[ordering[i]]) !== toInt(m[ordering[i]])) {
                    unitHasDecimal = true;
                }
            }
        }

        return true;
    }

    function isValid$1() {
        return this._isValid;
    }

    function createInvalid$1() {
        return createDuration(NaN);
    }

    function Duration (duration) {
        var normalizedInput = normalizeObjectUnits(duration),
            years = normalizedInput.year || 0,
            quarters = normalizedInput.quarter || 0,
            months = normalizedInput.month || 0,
            weeks = normalizedInput.week || 0,
            days = normalizedInput.day || 0,
            hours = normalizedInput.hour || 0,
            minutes = normalizedInput.minute || 0,
            seconds = normalizedInput.second || 0,
            milliseconds = normalizedInput.millisecond || 0;

        this._isValid = isDurationValid(normalizedInput);

        // representation for dateAddRemove
        this._milliseconds = +milliseconds +
            seconds * 1e3 + // 1000
            minutes * 6e4 + // 1000 * 60
            hours * 1000 * 60 * 60; //using 1000 * 60 * 60 instead of 36e5 to avoid floating point rounding errors https://github.com/moment/moment/issues/2978
        // Because of dateAddRemove treats 24 hours as different from a
        // day when working around DST, we need to store them separately
        this._days = +days +
            weeks * 7;
        // It is impossible to translate months into days without knowing
        // which months you are are talking about, so we have to store
        // it separately.
        this._months = +months +
            quarters * 3 +
            years * 12;

        this._data = {};

        this._locale = getLocale();

        this._bubble();
    }

    function isDuration (obj) {
        return obj instanceof Duration;
    }

    function absRound (number) {
        if (number < 0) {
            return Math.round(-1 * number) * -1;
        } else {
            return Math.round(number);
        }
    }

    // FORMATTING

    function offset (token, separator) {
        addFormatToken(token, 0, 0, function () {
            var offset = this.utcOffset();
            var sign = '+';
            if (offset < 0) {
                offset = -offset;
                sign = '-';
            }
            return sign + zeroFill(~~(offset / 60), 2) + separator + zeroFill(~~(offset) % 60, 2);
        });
    }

    offset('Z', ':');
    offset('ZZ', '');

    // PARSING

    addRegexToken('Z',  matchShortOffset);
    addRegexToken('ZZ', matchShortOffset);
    addParseToken(['Z', 'ZZ'], function (input, array, config) {
        config._useUTC = true;
        config._tzm = offsetFromString(matchShortOffset, input);
    });

    // HELPERS

    // timezone chunker
    // '+10:00' > ['10',  '00']
    // '-1530'  > ['-15', '30']
    var chunkOffset = /([\+\-]|\d\d)/gi;

    function offsetFromString(matcher, string) {
        var matches = (string || '').match(matcher);

        if (matches === null) {
            return null;
        }

        var chunk   = matches[matches.length - 1] || [];
        var parts   = (chunk + '').match(chunkOffset) || ['-', 0, 0];
        var minutes = +(parts[1] * 60) + toInt(parts[2]);

        return minutes === 0 ?
          0 :
          parts[0] === '+' ? minutes : -minutes;
    }

    // Return a moment from input, that is local/utc/zone equivalent to model.
    function cloneWithOffset(input, model) {
        var res, diff;
        if (model._isUTC) {
            res = model.clone();
            diff = (isMoment(input) || isDate(input) ? input.valueOf() : createLocal(input).valueOf()) - res.valueOf();
            // Use low-level api, because this fn is low-level api.
            res._d.setTime(res._d.valueOf() + diff);
            hooks.updateOffset(res, false);
            return res;
        } else {
            return createLocal(input).local();
        }
    }

    function getDateOffset (m) {
        // On Firefox.24 Date#getTimezoneOffset returns a floating point.
        // https://github.com/moment/moment/pull/1871
        return -Math.round(m._d.getTimezoneOffset() / 15) * 15;
    }

    // HOOKS

    // This function will be called whenever a moment is mutated.
    // It is intended to keep the offset in sync with the timezone.
    hooks.updateOffset = function () {};

    // MOMENTS

    // keepLocalTime = true means only change the timezone, without
    // affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]-->
    // 5:31:26 +0200 It is possible that 5:31:26 doesn't exist with offset
    // +0200, so we adjust the time as needed, to be valid.
    //
    // Keeping the time actually adds/subtracts (one hour)
    // from the actual represented time. That is why we call updateOffset
    // a second time. In case it wants us to change the offset again
    // _changeInProgress == true case, then we have to adjust, because
    // there is no such time in the given timezone.
    function getSetOffset (input, keepLocalTime, keepMinutes) {
        var offset = this._offset || 0,
            localAdjust;
        if (!this.isValid()) {
            return input != null ? this : NaN;
        }
        if (input != null) {
            if (typeof input === 'string') {
                input = offsetFromString(matchShortOffset, input);
                if (input === null) {
                    return this;
                }
            } else if (Math.abs(input) < 16 && !keepMinutes) {
                input = input * 60;
            }
            if (!this._isUTC && keepLocalTime) {
                localAdjust = getDateOffset(this);
            }
            this._offset = input;
            this._isUTC = true;
            if (localAdjust != null) {
                this.add(localAdjust, 'm');
            }
            if (offset !== input) {
                if (!keepLocalTime || this._changeInProgress) {
                    addSubtract(this, createDuration(input - offset, 'm'), 1, false);
                } else if (!this._changeInProgress) {
                    this._changeInProgress = true;
                    hooks.updateOffset(this, true);
                    this._changeInProgress = null;
                }
            }
            return this;
        } else {
            return this._isUTC ? offset : getDateOffset(this);
        }
    }

    function getSetZone (input, keepLocalTime) {
        if (input != null) {
            if (typeof input !== 'string') {
                input = -input;
            }

            this.utcOffset(input, keepLocalTime);

            return this;
        } else {
            return -this.utcOffset();
        }
    }

    function setOffsetToUTC (keepLocalTime) {
        return this.utcOffset(0, keepLocalTime);
    }

    function setOffsetToLocal (keepLocalTime) {
        if (this._isUTC) {
            this.utcOffset(0, keepLocalTime);
            this._isUTC = false;

            if (keepLocalTime) {
                this.subtract(getDateOffset(this), 'm');
            }
        }
        return this;
    }

    function setOffsetToParsedOffset () {
        if (this._tzm != null) {
            this.utcOffset(this._tzm, false, true);
        } else if (typeof this._i === 'string') {
            var tZone = offsetFromString(matchOffset, this._i);
            if (tZone != null) {
                this.utcOffset(tZone);
            }
            else {
                this.utcOffset(0, true);
            }
        }
        return this;
    }

    function hasAlignedHourOffset (input) {
        if (!this.isValid()) {
            return false;
        }
        input = input ? createLocal(input).utcOffset() : 0;

        return (this.utcOffset() - input) % 60 === 0;
    }

    function isDaylightSavingTime () {
        return (
            this.utcOffset() > this.clone().month(0).utcOffset() ||
            this.utcOffset() > this.clone().month(5).utcOffset()
        );
    }

    function isDaylightSavingTimeShifted () {
        if (!isUndefined(this._isDSTShifted)) {
            return this._isDSTShifted;
        }

        var c = {};

        copyConfig(c, this);
        c = prepareConfig(c);

        if (c._a) {
            var other = c._isUTC ? createUTC(c._a) : createLocal(c._a);
            this._isDSTShifted = this.isValid() &&
                compareArrays(c._a, other.toArray()) > 0;
        } else {
            this._isDSTShifted = false;
        }

        return this._isDSTShifted;
    }

    function isLocal () {
        return this.isValid() ? !this._isUTC : false;
    }

    function isUtcOffset () {
        return this.isValid() ? this._isUTC : false;
    }

    function isUtc () {
        return this.isValid() ? this._isUTC && this._offset === 0 : false;
    }

    // ASP.NET json date format regex
    var aspNetRegex = /^(\-|\+)?(?:(\d*)[. ])?(\d+)\:(\d+)(?:\:(\d+)(\.\d*)?)?$/;

    // from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html
    // somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere
    // and further modified to allow for strings containing both week and day
    var isoRegex = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;

    function createDuration (input, key) {
        var duration = input,
            // matching against regexp is expensive, do it on demand
            match = null,
            sign,
            ret,
            diffRes;

        if (isDuration(input)) {
            duration = {
                ms : input._milliseconds,
                d  : input._days,
                M  : input._months
            };
        } else if (isNumber(input)) {
            duration = {};
            if (key) {
                duration[key] = input;
            } else {
                duration.milliseconds = input;
            }
        } else if (!!(match = aspNetRegex.exec(input))) {
            sign = (match[1] === '-') ? -1 : 1;
            duration = {
                y  : 0,
                d  : toInt(match[DATE])                         * sign,
                h  : toInt(match[HOUR])                         * sign,
                m  : toInt(match[MINUTE])                       * sign,
                s  : toInt(match[SECOND])                       * sign,
                ms : toInt(absRound(match[MILLISECOND] * 1000)) * sign // the millisecond decimal point is included in the match
            };
        } else if (!!(match = isoRegex.exec(input))) {
            sign = (match[1] === '-') ? -1 : (match[1] === '+') ? 1 : 1;
            duration = {
                y : parseIso(match[2], sign),
                M : parseIso(match[3], sign),
                w : parseIso(match[4], sign),
                d : parseIso(match[5], sign),
                h : parseIso(match[6], sign),
                m : parseIso(match[7], sign),
                s : parseIso(match[8], sign)
            };
        } else if (duration == null) {// checks for null or undefined
            duration = {};
        } else if (typeof duration === 'object' && ('from' in duration || 'to' in duration)) {
            diffRes = momentsDifference(createLocal(duration.from), createLocal(duration.to));

            duration = {};
            duration.ms = diffRes.milliseconds;
            duration.M = diffRes.months;
        }

        ret = new Duration(duration);

        if (isDuration(input) && hasOwnProp(input, '_locale')) {
            ret._locale = input._locale;
        }

        return ret;
    }

    createDuration.fn = Duration.prototype;
    createDuration.invalid = createInvalid$1;

    function parseIso (inp, sign) {
        // We'd normally use ~~inp for this, but unfortunately it also
        // converts floats to ints.
        // inp may be undefined, so careful calling replace on it.
        var res = inp && parseFloat(inp.replace(',', '.'));
        // apply sign while we're at it
        return (isNaN(res) ? 0 : res) * sign;
    }

    function positiveMomentsDifference(base, other) {
        var res = {milliseconds: 0, months: 0};

        res.months = other.month() - base.month() +
            (other.year() - base.year()) * 12;
        if (base.clone().add(res.months, 'M').isAfter(other)) {
            --res.months;
        }

        res.milliseconds = +other - +(base.clone().add(res.months, 'M'));

        return res;
    }

    function momentsDifference(base, other) {
        var res;
        if (!(base.isValid() && other.isValid())) {
            return {milliseconds: 0, months: 0};
        }

        other = cloneWithOffset(other, base);
        if (base.isBefore(other)) {
            res = positiveMomentsDifference(base, other);
        } else {
            res = positiveMomentsDifference(other, base);
            res.milliseconds = -res.milliseconds;
            res.months = -res.months;
        }

        return res;
    }

    // TODO: remove 'name' arg after deprecation is removed
    function createAdder(direction, name) {
        return function (val, period) {
            var dur, tmp;
            //invert the arguments, but complain about it
            if (period !== null && !isNaN(+period)) {
                deprecateSimple(name, 'moment().' + name  + '(period, number) is deprecated. Please use moment().' + name + '(number, period). ' +
                'See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info.');
                tmp = val; val = period; period = tmp;
            }

            val = typeof val === 'string' ? +val : val;
            dur = createDuration(val, period);
            addSubtract(this, dur, direction);
            return this;
        };
    }

    function addSubtract (mom, duration, isAdding, updateOffset) {
        var milliseconds = duration._milliseconds,
            days = absRound(duration._days),
            months = absRound(duration._months);

        if (!mom.isValid()) {
            // No op
            return;
        }

        updateOffset = updateOffset == null ? true : updateOffset;

        if (months) {
            setMonth(mom, get(mom, 'Month') + months * isAdding);
        }
        if (days) {
            set$1(mom, 'Date', get(mom, 'Date') + days * isAdding);
        }
        if (milliseconds) {
            mom._d.setTime(mom._d.valueOf() + milliseconds * isAdding);
        }
        if (updateOffset) {
            hooks.updateOffset(mom, days || months);
        }
    }

    var add      = createAdder(1, 'add');
    var subtract = createAdder(-1, 'subtract');

    function getCalendarFormat(myMoment, now) {
        var diff = myMoment.diff(now, 'days', true);
        return diff < -6 ? 'sameElse' :
                diff < -1 ? 'lastWeek' :
                diff < 0 ? 'lastDay' :
                diff < 1 ? 'sameDay' :
                diff < 2 ? 'nextDay' :
                diff < 7 ? 'nextWeek' : 'sameElse';
    }

    function calendar$1 (time, formats) {
        // We want to compare the start of today, vs this.
        // Getting start-of-today depends on whether we're local/utc/offset or not.
        var now = time || createLocal(),
            sod = cloneWithOffset(now, this).startOf('day'),
            format = hooks.calendarFormat(this, sod) || 'sameElse';

        var output = formats && (isFunction(formats[format]) ? formats[format].call(this, now) : formats[format]);

        return this.format(output || this.localeData().calendar(format, this, createLocal(now)));
    }

    function clone () {
        return new Moment(this);
    }

    function isAfter (input, units) {
        var localInput = isMoment(input) ? input : createLocal(input);
        if (!(this.isValid() && localInput.isValid())) {
            return false;
        }
        units = normalizeUnits(!isUndefined(units) ? units : 'millisecond');
        if (units === 'millisecond') {
            return this.valueOf() > localInput.valueOf();
        } else {
            return localInput.valueOf() < this.clone().startOf(units).valueOf();
        }
    }

    function isBefore (input, units) {
        var localInput = isMoment(input) ? input : createLocal(input);
        if (!(this.isValid() && localInput.isValid())) {
            return false;
        }
        units = normalizeUnits(!isUndefined(units) ? units : 'millisecond');
        if (units === 'millisecond') {
            return this.valueOf() < localInput.valueOf();
        } else {
            return this.clone().endOf(units).valueOf() < localInput.valueOf();
        }
    }

    function isBetween (from, to, units, inclusivity) {
        inclusivity = inclusivity || '()';
        return (inclusivity[0] === '(' ? this.isAfter(from, units) : !this.isBefore(from, units)) &&
            (inclusivity[1] === ')' ? this.isBefore(to, units) : !this.isAfter(to, units));
    }

    function isSame (input, units) {
        var localInput = isMoment(input) ? input : createLocal(input),
            inputMs;
        if (!(this.isValid() && localInput.isValid())) {
            return false;
        }
        units = normalizeUnits(units || 'millisecond');
        if (units === 'millisecond') {
            return this.valueOf() === localInput.valueOf();
        } else {
            inputMs = localInput.valueOf();
            return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();
        }
    }

    function isSameOrAfter (input, units) {
        return this.isSame(input, units) || this.isAfter(input,units);
    }

    function isSameOrBefore (input, units) {
        return this.isSame(input, units) || this.isBefore(input,units);
    }

    function diff (input, units, asFloat) {
        var that,
            zoneDelta,
            output;

        if (!this.isValid()) {
            return NaN;
        }

        that = cloneWithOffset(input, this);

        if (!that.isValid()) {
            return NaN;
        }

        zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;

        units = normalizeUnits(units);

        switch (units) {
            case 'year': output = monthDiff(this, that) / 12; break;
            case 'month': output = monthDiff(this, that); break;
            case 'quarter': output = monthDiff(this, that) / 3; break;
            case 'second': output = (this - that) / 1e3; break; // 1000
            case 'minute': output = (this - that) / 6e4; break; // 1000 * 60
            case 'hour': output = (this - that) / 36e5; break; // 1000 * 60 * 60
            case 'day': output = (this - that - zoneDelta) / 864e5; break; // 1000 * 60 * 60 * 24, negate dst
            case 'week': output = (this - that - zoneDelta) / 6048e5; break; // 1000 * 60 * 60 * 24 * 7, negate dst
            default: output = this - that;
        }

        return asFloat ? output : absFloor(output);
    }

    function monthDiff (a, b) {
        // difference in months
        var wholeMonthDiff = ((b.year() - a.year()) * 12) + (b.month() - a.month()),
            // b is in (anchor - 1 month, anchor + 1 month)
            anchor = a.clone().add(wholeMonthDiff, 'months'),
            anchor2, adjust;

        if (b - anchor < 0) {
            anchor2 = a.clone().add(wholeMonthDiff - 1, 'months');
            // linear across the month
            adjust = (b - anchor) / (anchor - anchor2);
        } else {
            anchor2 = a.clone().add(wholeMonthDiff + 1, 'months');
            // linear across the month
            adjust = (b - anchor) / (anchor2 - anchor);
        }

        //check for negative zero, return zero if negative zero
        return -(wholeMonthDiff + adjust) || 0;
    }

    hooks.defaultFormat = 'YYYY-MM-DDTHH:mm:ssZ';
    hooks.defaultFormatUtc = 'YYYY-MM-DDTHH:mm:ss[Z]';

    function toString () {
        return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');
    }

    function toISOString(keepOffset) {
        if (!this.isValid()) {
            return null;
        }
        var utc = keepOffset !== true;
        var m = utc ? this.clone().utc() : this;
        if (m.year() < 0 || m.year() > 9999) {
            return formatMoment(m, utc ? 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]' : 'YYYYYY-MM-DD[T]HH:mm:ss.SSSZ');
        }
        if (isFunction(Date.prototype.toISOString)) {
            // native implementation is ~50x faster, use it when we can
            if (utc) {
                return this.toDate().toISOString();
            } else {
                return new Date(this.valueOf() + this.utcOffset() * 60 * 1000).toISOString().replace('Z', formatMoment(m, 'Z'));
            }
        }
        return formatMoment(m, utc ? 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]' : 'YYYY-MM-DD[T]HH:mm:ss.SSSZ');
    }

    /**
     * Return a human readable representation of a moment that can
     * also be evaluated to get a new moment which is the same
     *
     * @link https://nodejs.org/dist/latest/docs/api/util.html#util_custom_inspect_function_on_objects
     */
    function inspect () {
        if (!this.isValid()) {
            return 'moment.invalid(/* ' + this._i + ' */)';
        }
        var func = 'moment';
        var zone = '';
        if (!this.isLocal()) {
            func = this.utcOffset() === 0 ? 'moment.utc' : 'moment.parseZone';
            zone = 'Z';
        }
        var prefix = '[' + func + '("]';
        var year = (0 <= this.year() && this.year() <= 9999) ? 'YYYY' : 'YYYYYY';
        var datetime = '-MM-DD[T]HH:mm:ss.SSS';
        var suffix = zone + '[")]';

        return this.format(prefix + year + datetime + suffix);
    }

    function format (inputString) {
        if (!inputString) {
            inputString = this.isUtc() ? hooks.defaultFormatUtc : hooks.defaultFormat;
        }
        var output = formatMoment(this, inputString);
        return this.localeData().postformat(output);
    }

    function from (time, withoutSuffix) {
        if (this.isValid() &&
                ((isMoment(time) && time.isValid()) ||
                 createLocal(time).isValid())) {
            return createDuration({to: this, from: time}).locale(this.locale()).humanize(!withoutSuffix);
        } else {
            return this.localeData().invalidDate();
        }
    }

    function fromNow (withoutSuffix) {
        return this.from(createLocal(), withoutSuffix);
    }

    function to (time, withoutSuffix) {
        if (this.isValid() &&
                ((isMoment(time) && time.isValid()) ||
                 createLocal(time).isValid())) {
            return createDuration({from: this, to: time}).locale(this.locale()).humanize(!withoutSuffix);
        } else {
            return this.localeData().invalidDate();
        }
    }

    function toNow (withoutSuffix) {
        return this.to(createLocal(), withoutSuffix);
    }

    // If passed a locale key, it will set the locale for this
    // instance.  Otherwise, it will return the locale configuration
    // variables for this instance.
    function locale (key) {
        var newLocaleData;

        if (key === undefined) {
            return this._locale._abbr;
        } else {
            newLocaleData = getLocale(key);
            if (newLocaleData != null) {
                this._locale = newLocaleData;
            }
            return this;
        }
    }

    var lang = deprecate(
        'moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.',
        function (key) {
            if (key === undefined) {
                return this.localeData();
            } else {
                return this.locale(key);
            }
        }
    );

    function localeData () {
        return this._locale;
    }

    function startOf (units) {
        units = normalizeUnits(units);
        // the following switch intentionally omits break keywords
        // to utilize falling through the cases.
        switch (units) {
            case 'year':
                this.month(0);
                /* falls through */
            case 'quarter':
            case 'month':
                this.date(1);
                /* falls through */
            case 'week':
            case 'isoWeek':
            case 'day':
            case 'date':
                this.hours(0);
                /* falls through */
            case 'hour':
                this.minutes(0);
                /* falls through */
            case 'minute':
                this.seconds(0);
                /* falls through */
            case 'second':
                this.milliseconds(0);
        }

        // weeks are a special case
        if (units === 'week') {
            this.weekday(0);
        }
        if (units === 'isoWeek') {
            this.isoWeekday(1);
        }

        // quarters are also special
        if (units === 'quarter') {
            this.month(Math.floor(this.month() / 3) * 3);
        }

        return this;
    }

    function endOf (units) {
        units = normalizeUnits(units);
        if (units === undefined || units === 'millisecond') {
            return this;
        }

        // 'date' is an alias for 'day', so it should be considered as such.
        if (units === 'date') {
            units = 'day';
        }

        return this.startOf(units).add(1, (units === 'isoWeek' ? 'week' : units)).subtract(1, 'ms');
    }

    function valueOf () {
        return this._d.valueOf() - ((this._offset || 0) * 60000);
    }

    function unix () {
        return Math.floor(this.valueOf() / 1000);
    }

    function toDate () {
        return new Date(this.valueOf());
    }

    function toArray () {
        var m = this;
        return [m.year(), m.month(), m.date(), m.hour(), m.minute(), m.second(), m.millisecond()];
    }

    function toObject () {
        var m = this;
        return {
            years: m.year(),
            months: m.month(),
            date: m.date(),
            hours: m.hours(),
            minutes: m.minutes(),
            seconds: m.seconds(),
            milliseconds: m.milliseconds()
        };
    }

    function toJSON () {
        // new Date(NaN).toJSON() === null
        return this.isValid() ? this.toISOString() : null;
    }

    function isValid$2 () {
        return isValid(this);
    }

    function parsingFlags () {
        return extend({}, getParsingFlags(this));
    }

    function invalidAt () {
        return getParsingFlags(this).overflow;
    }

    function creationData() {
        return {
            input: this._i,
            format: this._f,
            locale: this._locale,
            isUTC: this._isUTC,
            strict: this._strict
        };
    }

    // FORMATTING

    addFormatToken(0, ['gg', 2], 0, function () {
        return this.weekYear() % 100;
    });

    addFormatToken(0, ['GG', 2], 0, function () {
        return this.isoWeekYear() % 100;
    });

    function addWeekYearFormatToken (token, getter) {
        addFormatToken(0, [token, token.length], 0, getter);
    }

    addWeekYearFormatToken('gggg',     'weekYear');
    addWeekYearFormatToken('ggggg',    'weekYear');
    addWeekYearFormatToken('GGGG',  'isoWeekYear');
    addWeekYearFormatToken('GGGGG', 'isoWeekYear');

    // ALIASES

    addUnitAlias('weekYear', 'gg');
    addUnitAlias('isoWeekYear', 'GG');

    // PRIORITY

    addUnitPriority('weekYear', 1);
    addUnitPriority('isoWeekYear', 1);


    // PARSING

    addRegexToken('G',      matchSigned);
    addRegexToken('g',      matchSigned);
    addRegexToken('GG',     match1to2, match2);
    addRegexToken('gg',     match1to2, match2);
    addRegexToken('GGGG',   match1to4, match4);
    addRegexToken('gggg',   match1to4, match4);
    addRegexToken('GGGGG',  match1to6, match6);
    addRegexToken('ggggg',  match1to6, match6);

    addWeekParseToken(['gggg', 'ggggg', 'GGGG', 'GGGGG'], function (input, week, config, token) {
        week[token.substr(0, 2)] = toInt(input);
    });

    addWeekParseToken(['gg', 'GG'], function (input, week, config, token) {
        week[token] = hooks.parseTwoDigitYear(input);
    });

    // MOMENTS

    function getSetWeekYear (input) {
        return getSetWeekYearHelper.call(this,
                input,
                this.week(),
                this.weekday(),
                this.localeData()._week.dow,
                this.localeData()._week.doy);
    }

    function getSetISOWeekYear (input) {
        return getSetWeekYearHelper.call(this,
                input, this.isoWeek(), this.isoWeekday(), 1, 4);
    }

    function getISOWeeksInYear () {
        return weeksInYear(this.year(), 1, 4);
    }

    function getWeeksInYear () {
        var weekInfo = this.localeData()._week;
        return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
    }

    function getSetWeekYearHelper(input, week, weekday, dow, doy) {
        var weeksTarget;
        if (input == null) {
            return weekOfYear(this, dow, doy).year;
        } else {
            weeksTarget = weeksInYear(input, dow, doy);
            if (week > weeksTarget) {
                week = weeksTarget;
            }
            return setWeekAll.call(this, input, week, weekday, dow, doy);
        }
    }

    function setWeekAll(weekYear, week, weekday, dow, doy) {
        var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy),
            date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);

        this.year(date.getUTCFullYear());
        this.month(date.getUTCMonth());
        this.date(date.getUTCDate());
        return this;
    }

    // FORMATTING

    addFormatToken('Q', 0, 'Qo', 'quarter');

    // ALIASES

    addUnitAlias('quarter', 'Q');

    // PRIORITY

    addUnitPriority('quarter', 7);

    // PARSING

    addRegexToken('Q', match1);
    addParseToken('Q', function (input, array) {
        array[MONTH] = (toInt(input) - 1) * 3;
    });

    // MOMENTS

    function getSetQuarter (input) {
        return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
    }

    // FORMATTING

    addFormatToken('D', ['DD', 2], 'Do', 'date');

    // ALIASES

    addUnitAlias('date', 'D');

    // PRIORITY
    addUnitPriority('date', 9);

    // PARSING

    addRegexToken('D',  match1to2);
    addRegexToken('DD', match1to2, match2);
    addRegexToken('Do', function (isStrict, locale) {
        // TODO: Remove "ordinalParse" fallback in next major release.
        return isStrict ?
          (locale._dayOfMonthOrdinalParse || locale._ordinalParse) :
          locale._dayOfMonthOrdinalParseLenient;
    });

    addParseToken(['D', 'DD'], DATE);
    addParseToken('Do', function (input, array) {
        array[DATE] = toInt(input.match(match1to2)[0]);
    });

    // MOMENTS

    var getSetDayOfMonth = makeGetSet('Date', true);

    // FORMATTING

    addFormatToken('DDD', ['DDDD', 3], 'DDDo', 'dayOfYear');

    // ALIASES

    addUnitAlias('dayOfYear', 'DDD');

    // PRIORITY
    addUnitPriority('dayOfYear', 4);

    // PARSING

    addRegexToken('DDD',  match1to3);
    addRegexToken('DDDD', match3);
    addParseToken(['DDD', 'DDDD'], function (input, array, config) {
        config._dayOfYear = toInt(input);
    });

    // HELPERS

    // MOMENTS

    function getSetDayOfYear (input) {
        var dayOfYear = Math.round((this.clone().startOf('day') - this.clone().startOf('year')) / 864e5) + 1;
        return input == null ? dayOfYear : this.add((input - dayOfYear), 'd');
    }

    // FORMATTING

    addFormatToken('m', ['mm', 2], 0, 'minute');

    // ALIASES

    addUnitAlias('minute', 'm');

    // PRIORITY

    addUnitPriority('minute', 14);

    // PARSING

    addRegexToken('m',  match1to2);
    addRegexToken('mm', match1to2, match2);
    addParseToken(['m', 'mm'], MINUTE);

    // MOMENTS

    var getSetMinute = makeGetSet('Minutes', false);

    // FORMATTING

    addFormatToken('s', ['ss', 2], 0, 'second');

    // ALIASES

    addUnitAlias('second', 's');

    // PRIORITY

    addUnitPriority('second', 15);

    // PARSING

    addRegexToken('s',  match1to2);
    addRegexToken('ss', match1to2, match2);
    addParseToken(['s', 'ss'], SECOND);

    // MOMENTS

    var getSetSecond = makeGetSet('Seconds', false);

    // FORMATTING

    addFormatToken('S', 0, 0, function () {
        return ~~(this.millisecond() / 100);
    });

    addFormatToken(0, ['SS', 2], 0, function () {
        return ~~(this.millisecond() / 10);
    });

    addFormatToken(0, ['SSS', 3], 0, 'millisecond');
    addFormatToken(0, ['SSSS', 4], 0, function () {
        return this.millisecond() * 10;
    });
    addFormatToken(0, ['SSSSS', 5], 0, function () {
        return this.millisecond() * 100;
    });
    addFormatToken(0, ['SSSSSS', 6], 0, function () {
        return this.millisecond() * 1000;
    });
    addFormatToken(0, ['SSSSSSS', 7], 0, function () {
        return this.millisecond() * 10000;
    });
    addFormatToken(0, ['SSSSSSSS', 8], 0, function () {
        return this.millisecond() * 100000;
    });
    addFormatToken(0, ['SSSSSSSSS', 9], 0, function () {
        return this.millisecond() * 1000000;
    });


    // ALIASES

    addUnitAlias('millisecond', 'ms');

    // PRIORITY

    addUnitPriority('millisecond', 16);

    // PARSING

    addRegexToken('S',    match1to3, match1);
    addRegexToken('SS',   match1to3, match2);
    addRegexToken('SSS',  match1to3, match3);

    var token;
    for (token = 'SSSS'; token.length <= 9; token += 'S') {
        addRegexToken(token, matchUnsigned);
    }

    function parseMs(input, array) {
        array[MILLISECOND] = toInt(('0.' + input) * 1000);
    }

    for (token = 'S'; token.length <= 9; token += 'S') {
        addParseToken(token, parseMs);
    }
    // MOMENTS

    var getSetMillisecond = makeGetSet('Milliseconds', false);

    // FORMATTING

    addFormatToken('z',  0, 0, 'zoneAbbr');
    addFormatToken('zz', 0, 0, 'zoneName');

    // MOMENTS

    function getZoneAbbr () {
        return this._isUTC ? 'UTC' : '';
    }

    function getZoneName () {
        return this._isUTC ? 'Coordinated Universal Time' : '';
    }

    var proto = Moment.prototype;

    proto.add               = add;
    proto.calendar          = calendar$1;
    proto.clone             = clone;
    proto.diff              = diff;
    proto.endOf             = endOf;
    proto.format            = format;
    proto.from              = from;
    proto.fromNow           = fromNow;
    proto.to                = to;
    proto.toNow             = toNow;
    proto.get               = stringGet;
    proto.invalidAt         = invalidAt;
    proto.isAfter           = isAfter;
    proto.isBefore          = isBefore;
    proto.isBetween         = isBetween;
    proto.isSame            = isSame;
    proto.isSameOrAfter     = isSameOrAfter;
    proto.isSameOrBefore    = isSameOrBefore;
    proto.isValid           = isValid$2;
    proto.lang              = lang;
    proto.locale            = locale;
    proto.localeData        = localeData;
    proto.max               = prototypeMax;
    proto.min               = prototypeMin;
    proto.parsingFlags      = parsingFlags;
    proto.set               = stringSet;
    proto.startOf           = startOf;
    proto.subtract          = subtract;
    proto.toArray           = toArray;
    proto.toObject          = toObject;
    proto.toDate            = toDate;
    proto.toISOString       = toISOString;
    proto.inspect           = inspect;
    proto.toJSON            = toJSON;
    proto.toString          = toString;
    proto.unix              = unix;
    proto.valueOf           = valueOf;
    proto.creationData      = creationData;
    proto.year       = getSetYear;
    proto.isLeapYear = getIsLeapYear;
    proto.weekYear    = getSetWeekYear;
    proto.isoWeekYear = getSetISOWeekYear;
    proto.quarter = proto.quarters = getSetQuarter;
    proto.month       = getSetMonth;
    proto.daysInMonth = getDaysInMonth;
    proto.week           = proto.weeks        = getSetWeek;
    proto.isoWeek        = proto.isoWeeks     = getSetISOWeek;
    proto.weeksInYear    = getWeeksInYear;
    proto.isoWeeksInYear = getISOWeeksInYear;
    proto.date       = getSetDayOfMonth;
    proto.day        = proto.days             = getSetDayOfWeek;
    proto.weekday    = getSetLocaleDayOfWeek;
    proto.isoWeekday = getSetISODayOfWeek;
    proto.dayOfYear  = getSetDayOfYear;
    proto.hour = proto.hours = getSetHour;
    proto.minute = proto.minutes = getSetMinute;
    proto.second = proto.seconds = getSetSecond;
    proto.millisecond = proto.milliseconds = getSetMillisecond;
    proto.utcOffset            = getSetOffset;
    proto.utc                  = setOffsetToUTC;
    proto.local                = setOffsetToLocal;
    proto.parseZone            = setOffsetToParsedOffset;
    proto.hasAlignedHourOffset = hasAlignedHourOffset;
    proto.isDST                = isDaylightSavingTime;
    proto.isLocal              = isLocal;
    proto.isUtcOffset          = isUtcOffset;
    proto.isUtc                = isUtc;
    proto.isUTC                = isUtc;
    proto.zoneAbbr = getZoneAbbr;
    proto.zoneName = getZoneName;
    proto.dates  = deprecate('dates accessor is deprecated. Use date instead.', getSetDayOfMonth);
    proto.months = deprecate('months accessor is deprecated. Use month instead', getSetMonth);
    proto.years  = deprecate('years accessor is deprecated. Use year instead', getSetYear);
    proto.zone   = deprecate('moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/', getSetZone);
    proto.isDSTShifted = deprecate('isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information', isDaylightSavingTimeShifted);

    function createUnix (input) {
        return createLocal(input * 1000);
    }

    function createInZone () {
        return createLocal.apply(null, arguments).parseZone();
    }

    function preParsePostFormat (string) {
        return string;
    }

    var proto$1 = Locale.prototype;

    proto$1.calendar        = calendar;
    proto$1.longDateFormat  = longDateFormat;
    proto$1.invalidDate     = invalidDate;
    proto$1.ordinal         = ordinal;
    proto$1.preparse        = preParsePostFormat;
    proto$1.postformat      = preParsePostFormat;
    proto$1.relativeTime    = relativeTime;
    proto$1.pastFuture      = pastFuture;
    proto$1.set             = set;

    proto$1.months            =        localeMonths;
    proto$1.monthsShort       =        localeMonthsShort;
    proto$1.monthsParse       =        localeMonthsParse;
    proto$1.monthsRegex       = monthsRegex;
    proto$1.monthsShortRegex  = monthsShortRegex;
    proto$1.week = localeWeek;
    proto$1.firstDayOfYear = localeFirstDayOfYear;
    proto$1.firstDayOfWeek = localeFirstDayOfWeek;

    proto$1.weekdays       =        localeWeekdays;
    proto$1.weekdaysMin    =        localeWeekdaysMin;
    proto$1.weekdaysShort  =        localeWeekdaysShort;
    proto$1.weekdaysParse  =        localeWeekdaysParse;

    proto$1.weekdaysRegex       =        weekdaysRegex;
    proto$1.weekdaysShortRegex  =        weekdaysShortRegex;
    proto$1.weekdaysMinRegex    =        weekdaysMinRegex;

    proto$1.isPM = localeIsPM;
    proto$1.meridiem = localeMeridiem;

    function get$1 (format, index, field, setter) {
        var locale = getLocale();
        var utc = createUTC().set(setter, index);
        return locale[field](utc, format);
    }

    function listMonthsImpl (format, index, field) {
        if (isNumber(format)) {
            index = format;
            format = undefined;
        }

        format = format || '';

        if (index != null) {
            return get$1(format, index, field, 'month');
        }

        var i;
        var out = [];
        for (i = 0; i < 12; i++) {
            out[i] = get$1(format, i, field, 'month');
        }
        return out;
    }

    // ()
    // (5)
    // (fmt, 5)
    // (fmt)
    // (true)
    // (true, 5)
    // (true, fmt, 5)
    // (true, fmt)
    function listWeekdaysImpl (localeSorted, format, index, field) {
        if (typeof localeSorted === 'boolean') {
            if (isNumber(format)) {
                index = format;
                format = undefined;
            }

            format = format || '';
        } else {
            format = localeSorted;
            index = format;
            localeSorted = false;

            if (isNumber(format)) {
                index = format;
                format = undefined;
            }

            format = format || '';
        }

        var locale = getLocale(),
            shift = localeSorted ? locale._week.dow : 0;

        if (index != null) {
            return get$1(format, (index + shift) % 7, field, 'day');
        }

        var i;
        var out = [];
        for (i = 0; i < 7; i++) {
            out[i] = get$1(format, (i + shift) % 7, field, 'day');
        }
        return out;
    }

    function listMonths (format, index) {
        return listMonthsImpl(format, index, 'months');
    }

    function listMonthsShort (format, index) {
        return listMonthsImpl(format, index, 'monthsShort');
    }

    function listWeekdays (localeSorted, format, index) {
        return listWeekdaysImpl(localeSorted, format, index, 'weekdays');
    }

    function listWeekdaysShort (localeSorted, format, index) {
        return listWeekdaysImpl(localeSorted, format, index, 'weekdaysShort');
    }

    function listWeekdaysMin (localeSorted, format, index) {
        return listWeekdaysImpl(localeSorted, format, index, 'weekdaysMin');
    }

    getSetGlobalLocale('en', {
        dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
        ordinal : function (number) {
            var b = number % 10,
                output = (toInt(number % 100 / 10) === 1) ? 'th' :
                (b === 1) ? 'st' :
                (b === 2) ? 'nd' :
                (b === 3) ? 'rd' : 'th';
            return number + output;
        }
    });

    // Side effect imports

    hooks.lang = deprecate('moment.lang is deprecated. Use moment.locale instead.', getSetGlobalLocale);
    hooks.langData = deprecate('moment.langData is deprecated. Use moment.localeData instead.', getLocale);

    var mathAbs = Math.abs;

    function abs () {
        var data           = this._data;

        this._milliseconds = mathAbs(this._milliseconds);
        this._days         = mathAbs(this._days);
        this._months       = mathAbs(this._months);

        data.milliseconds  = mathAbs(data.milliseconds);
        data.seconds       = mathAbs(data.seconds);
        data.minutes       = mathAbs(data.minutes);
        data.hours         = mathAbs(data.hours);
        data.months        = mathAbs(data.months);
        data.years         = mathAbs(data.years);

        return this;
    }

    function addSubtract$1 (duration, input, value, direction) {
        var other = createDuration(input, value);

        duration._milliseconds += direction * other._milliseconds;
        duration._days         += direction * other._days;
        duration._months       += direction * other._months;

        return duration._bubble();
    }

    // supports only 2.0-style add(1, 's') or add(duration)
    function add$1 (input, value) {
        return addSubtract$1(this, input, value, 1);
    }

    // supports only 2.0-style subtract(1, 's') or subtract(duration)
    function subtract$1 (input, value) {
        return addSubtract$1(this, input, value, -1);
    }

    function absCeil (number) {
        if (number < 0) {
            return Math.floor(number);
        } else {
            return Math.ceil(number);
        }
    }

    function bubble () {
        var milliseconds = this._milliseconds;
        var days         = this._days;
        var months       = this._months;
        var data         = this._data;
        var seconds, minutes, hours, years, monthsFromDays;

        // if we have a mix of positive and negative values, bubble down first
        // check: https://github.com/moment/moment/issues/2166
        if (!((milliseconds >= 0 && days >= 0 && months >= 0) ||
                (milliseconds <= 0 && days <= 0 && months <= 0))) {
            milliseconds += absCeil(monthsToDays(months) + days) * 864e5;
            days = 0;
            months = 0;
        }

        // The following code bubbles up values, see the tests for
        // examples of what that means.
        data.milliseconds = milliseconds % 1000;

        seconds           = absFloor(milliseconds / 1000);
        data.seconds      = seconds % 60;

        minutes           = absFloor(seconds / 60);
        data.minutes      = minutes % 60;

        hours             = absFloor(minutes / 60);
        data.hours        = hours % 24;

        days += absFloor(hours / 24);

        // convert days to months
        monthsFromDays = absFloor(daysToMonths(days));
        months += monthsFromDays;
        days -= absCeil(monthsToDays(monthsFromDays));

        // 12 months -> 1 year
        years = absFloor(months / 12);
        months %= 12;

        data.days   = days;
        data.months = months;
        data.years  = years;

        return this;
    }

    function daysToMonths (days) {
        // 400 years have 146097 days (taking into account leap year rules)
        // 400 years have 12 months === 4800
        return days * 4800 / 146097;
    }

    function monthsToDays (months) {
        // the reverse of daysToMonths
        return months * 146097 / 4800;
    }

    function as (units) {
        if (!this.isValid()) {
            return NaN;
        }
        var days;
        var months;
        var milliseconds = this._milliseconds;

        units = normalizeUnits(units);

        if (units === 'month' || units === 'year') {
            days   = this._days   + milliseconds / 864e5;
            months = this._months + daysToMonths(days);
            return units === 'month' ? months : months / 12;
        } else {
            // handle milliseconds separately because of floating point math errors (issue #1867)
            days = this._days + Math.round(monthsToDays(this._months));
            switch (units) {
                case 'week'   : return days / 7     + milliseconds / 6048e5;
                case 'day'    : return days         + milliseconds / 864e5;
                case 'hour'   : return days * 24    + milliseconds / 36e5;
                case 'minute' : return days * 1440  + milliseconds / 6e4;
                case 'second' : return days * 86400 + milliseconds / 1000;
                // Math.floor prevents floating point math errors here
                case 'millisecond': return Math.floor(days * 864e5) + milliseconds;
                default: throw new Error('Unknown unit ' + units);
            }
        }
    }

    // TODO: Use this.as('ms')?
    function valueOf$1 () {
        if (!this.isValid()) {
            return NaN;
        }
        return (
            this._milliseconds +
            this._days * 864e5 +
            (this._months % 12) * 2592e6 +
            toInt(this._months / 12) * 31536e6
        );
    }

    function makeAs (alias) {
        return function () {
            return this.as(alias);
        };
    }

    var asMilliseconds = makeAs('ms');
    var asSeconds      = makeAs('s');
    var asMinutes      = makeAs('m');
    var asHours        = makeAs('h');
    var asDays         = makeAs('d');
    var asWeeks        = makeAs('w');
    var asMonths       = makeAs('M');
    var asYears        = makeAs('y');

    function clone$1 () {
        return createDuration(this);
    }

    function get$2 (units) {
        units = normalizeUnits(units);
        return this.isValid() ? this[units + 's']() : NaN;
    }

    function makeGetter(name) {
        return function () {
            return this.isValid() ? this._data[name] : NaN;
        };
    }

    var milliseconds = makeGetter('milliseconds');
    var seconds      = makeGetter('seconds');
    var minutes      = makeGetter('minutes');
    var hours        = makeGetter('hours');
    var days         = makeGetter('days');
    var months       = makeGetter('months');
    var years        = makeGetter('years');

    function weeks () {
        return absFloor(this.days() / 7);
    }

    var round = Math.round;
    var thresholds = {
        ss: 44,         // a few seconds to seconds
        s : 45,         // seconds to minute
        m : 45,         // minutes to hour
        h : 22,         // hours to day
        d : 26,         // days to month
        M : 11          // months to year
    };

    // helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize
    function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
        return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
    }

    function relativeTime$1 (posNegDuration, withoutSuffix, locale) {
        var duration = createDuration(posNegDuration).abs();
        var seconds  = round(duration.as('s'));
        var minutes  = round(duration.as('m'));
        var hours    = round(duration.as('h'));
        var days     = round(duration.as('d'));
        var months   = round(duration.as('M'));
        var years    = round(duration.as('y'));

        var a = seconds <= thresholds.ss && ['s', seconds]  ||
                seconds < thresholds.s   && ['ss', seconds] ||
                minutes <= 1             && ['m']           ||
                minutes < thresholds.m   && ['mm', minutes] ||
                hours   <= 1             && ['h']           ||
                hours   < thresholds.h   && ['hh', hours]   ||
                days    <= 1             && ['d']           ||
                days    < thresholds.d   && ['dd', days]    ||
                months  <= 1             && ['M']           ||
                months  < thresholds.M   && ['MM', months]  ||
                years   <= 1             && ['y']           || ['yy', years];

        a[2] = withoutSuffix;
        a[3] = +posNegDuration > 0;
        a[4] = locale;
        return substituteTimeAgo.apply(null, a);
    }

    // This function allows you to set the rounding function for relative time strings
    function getSetRelativeTimeRounding (roundingFunction) {
        if (roundingFunction === undefined) {
            return round;
        }
        if (typeof(roundingFunction) === 'function') {
            round = roundingFunction;
            return true;
        }
        return false;
    }

    // This function allows you to set a threshold for relative time strings
    function getSetRelativeTimeThreshold (threshold, limit) {
        if (thresholds[threshold] === undefined) {
            return false;
        }
        if (limit === undefined) {
            return thresholds[threshold];
        }
        thresholds[threshold] = limit;
        if (threshold === 's') {
            thresholds.ss = limit - 1;
        }
        return true;
    }

    function humanize (withSuffix) {
        if (!this.isValid()) {
            return this.localeData().invalidDate();
        }

        var locale = this.localeData();
        var output = relativeTime$1(this, !withSuffix, locale);

        if (withSuffix) {
            output = locale.pastFuture(+this, output);
        }

        return locale.postformat(output);
    }

    var abs$1 = Math.abs;

    function sign(x) {
        return ((x > 0) - (x < 0)) || +x;
    }

    function toISOString$1() {
        // for ISO strings we do not use the normal bubbling rules:
        //  * milliseconds bubble up until they become hours
        //  * days do not bubble at all
        //  * months bubble up until they become years
        // This is because there is no context-free conversion between hours and days
        // (think of clock changes)
        // and also not between days and months (28-31 days per month)
        if (!this.isValid()) {
            return this.localeData().invalidDate();
        }

        var seconds = abs$1(this._milliseconds) / 1000;
        var days         = abs$1(this._days);
        var months       = abs$1(this._months);
        var minutes, hours, years;

        // 3600 seconds -> 60 minutes -> 1 hour
        minutes           = absFloor(seconds / 60);
        hours             = absFloor(minutes / 60);
        seconds %= 60;
        minutes %= 60;

        // 12 months -> 1 year
        years  = absFloor(months / 12);
        months %= 12;


        // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js
        var Y = years;
        var M = months;
        var D = days;
        var h = hours;
        var m = minutes;
        var s = seconds ? seconds.toFixed(3).replace(/\.?0+$/, '') : '';
        var total = this.asSeconds();

        if (!total) {
            // this is the same as C#'s (Noda) and python (isodate)...
            // but not other JS (goog.date)
            return 'P0D';
        }

        var totalSign = total < 0 ? '-' : '';
        var ymSign = sign(this._months) !== sign(total) ? '-' : '';
        var daysSign = sign(this._days) !== sign(total) ? '-' : '';
        var hmsSign = sign(this._milliseconds) !== sign(total) ? '-' : '';

        return totalSign + 'P' +
            (Y ? ymSign + Y + 'Y' : '') +
            (M ? ymSign + M + 'M' : '') +
            (D ? daysSign + D + 'D' : '') +
            ((h || m || s) ? 'T' : '') +
            (h ? hmsSign + h + 'H' : '') +
            (m ? hmsSign + m + 'M' : '') +
            (s ? hmsSign + s + 'S' : '');
    }

    var proto$2 = Duration.prototype;

    proto$2.isValid        = isValid$1;
    proto$2.abs            = abs;
    proto$2.add            = add$1;
    proto$2.subtract       = subtract$1;
    proto$2.as             = as;
    proto$2.asMilliseconds = asMilliseconds;
    proto$2.asSeconds      = asSeconds;
    proto$2.asMinutes      = asMinutes;
    proto$2.asHours        = asHours;
    proto$2.asDays         = asDays;
    proto$2.asWeeks        = asWeeks;
    proto$2.asMonths       = asMonths;
    proto$2.asYears        = asYears;
    proto$2.valueOf        = valueOf$1;
    proto$2._bubble        = bubble;
    proto$2.clone          = clone$1;
    proto$2.get            = get$2;
    proto$2.milliseconds   = milliseconds;
    proto$2.seconds        = seconds;
    proto$2.minutes        = minutes;
    proto$2.hours          = hours;
    proto$2.days           = days;
    proto$2.weeks          = weeks;
    proto$2.months         = months;
    proto$2.years          = years;
    proto$2.humanize       = humanize;
    proto$2.toISOString    = toISOString$1;
    proto$2.toString       = toISOString$1;
    proto$2.toJSON         = toISOString$1;
    proto$2.locale         = locale;
    proto$2.localeData     = localeData;

    proto$2.toIsoString = deprecate('toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)', toISOString$1);
    proto$2.lang = lang;

    // Side effect imports

    // FORMATTING

    addFormatToken('X', 0, 0, 'unix');
    addFormatToken('x', 0, 0, 'valueOf');

    // PARSING

    addRegexToken('x', matchSigned);
    addRegexToken('X', matchTimestamp);
    addParseToken('X', function (input, array, config) {
        config._d = new Date(parseFloat(input, 10) * 1000);
    });
    addParseToken('x', function (input, array, config) {
        config._d = new Date(toInt(input));
    });

    // Side effect imports


    hooks.version = '2.22.2';

    setHookCallback(createLocal);

    hooks.fn                    = proto;
    hooks.min                   = min;
    hooks.max                   = max;
    hooks.now                   = now;
    hooks.utc                   = createUTC;
    hooks.unix                  = createUnix;
    hooks.months                = listMonths;
    hooks.isDate                = isDate;
    hooks.locale                = getSetGlobalLocale;
    hooks.invalid               = createInvalid;
    hooks.duration              = createDuration;
    hooks.isMoment              = isMoment;
    hooks.weekdays              = listWeekdays;
    hooks.parseZone             = createInZone;
    hooks.localeData            = getLocale;
    hooks.isDuration            = isDuration;
    hooks.monthsShort           = listMonthsShort;
    hooks.weekdaysMin           = listWeekdaysMin;
    hooks.defineLocale          = defineLocale;
    hooks.updateLocale          = updateLocale;
    hooks.locales               = listLocales;
    hooks.weekdaysShort         = listWeekdaysShort;
    hooks.normalizeUnits        = normalizeUnits;
    hooks.relativeTimeRounding  = getSetRelativeTimeRounding;
    hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;
    hooks.calendarFormat        = getCalendarFormat;
    hooks.prototype             = proto;

    // currently HTML5 input type only supports 24-hour formats
    hooks.HTML5_FMT = {
        DATETIME_LOCAL: 'YYYY-MM-DDTHH:mm',             // <input type="datetime-local" />
        DATETIME_LOCAL_SECONDS: 'YYYY-MM-DDTHH:mm:ss',  // <input type="datetime-local" step="1" />
        DATETIME_LOCAL_MS: 'YYYY-MM-DDTHH:mm:ss.SSS',   // <input type="datetime-local" step="0.001" />
        DATE: 'YYYY-MM-DD',                             // <input type="date" />
        TIME: 'HH:mm',                                  // <input type="time" />
        TIME_SECONDS: 'HH:mm:ss',                       // <input type="time" step="1" />
        TIME_MS: 'HH:mm:ss.SSS',                        // <input type="time" step="0.001" />
        WEEK: 'YYYY-[W]WW',                             // <input type="week" />
        MONTH: 'YYYY-MM'                                // <input type="month" />
    };

    return hooks;

})));

},{}],409:[function(require,module,exports){
var indexOf = require('./indexOf');

    /**
     * Combines an array with all the items of another.
     * Does not allow duplicates and is case and type sensitive.
     */
    function combine(arr1, arr2) {
        if (arr2 == null) {
            return arr1;
        }

        var i = -1, len = arr2.length;
        while (++i < len) {
            if (indexOf(arr1, arr2[i]) === -1) {
                arr1.push(arr2[i]);
            }
        }

        return arr1;
    }
    module.exports = combine;


},{"./indexOf":416}],410:[function(require,module,exports){
var indexOf = require('./indexOf');

    /**
     * If array contains values.
     */
    function contains(arr, val) {
        return indexOf(arr, val) !== -1;
    }
    module.exports = contains;


},{"./indexOf":416}],411:[function(require,module,exports){
var unique = require('./unique');
var filter = require('./filter');
var some = require('./some');
var contains = require('./contains');
var slice = require('./slice');


    /**
     * Return a new Array with elements that aren't present in the other Arrays.
     */
    function difference(arr) {
        var arrs = slice(arguments, 1),
            result = filter(unique(arr), function(needle){
                return !some(arrs, function(haystack){
                    return contains(haystack, needle);
                });
            });
        return result;
    }

    module.exports = difference;



},{"./contains":410,"./filter":414,"./slice":420,"./some":421,"./unique":422}],412:[function(require,module,exports){
var is = require('../lang/is');
var isArray = require('../lang/isArray');
var every = require('./every');

    /**
     * Compares if both arrays have the same elements
     */
    function equals(a, b, callback){
        callback = callback || is;

        if (!isArray(a) || !isArray(b)) {
            return callback(a, b);
        }

        if (a.length !== b.length) {
            return false;
        }

        return every(a, makeCompare(callback), b);
    }

    function makeCompare(callback) {
        return function(value, i) {
            return i in this && callback(value, this[i]);
        };
    }

    module.exports = equals;



},{"../lang/is":431,"../lang/isArray":432,"./every":413}],413:[function(require,module,exports){
var makeIterator = require('../function/makeIterator_');

    /**
     * Array every
     */
    function every(arr, callback, thisObj) {
        callback = makeIterator(callback, thisObj);
        var result = true;
        if (arr == null) {
            return result;
        }

        var i = -1, len = arr.length;
        while (++i < len) {
            // we iterate over sparse items since there is no way to make it
            // work properly on IE 7-8. see #64
            if (!callback(arr[i], i, arr) ) {
                result = false;
                break;
            }
        }

        return result;
    }

    module.exports = every;


},{"../function/makeIterator_":425}],414:[function(require,module,exports){
var makeIterator = require('../function/makeIterator_');

    /**
     * Array filter
     */
    function filter(arr, callback, thisObj) {
        callback = makeIterator(callback, thisObj);
        var results = [];
        if (arr == null) {
            return results;
        }

        var i = -1, len = arr.length, value;
        while (++i < len) {
            value = arr[i];
            if (callback(value, i, arr)) {
                results.push(value);
            }
        }

        return results;
    }

    module.exports = filter;



},{"../function/makeIterator_":425}],415:[function(require,module,exports){


    /**
     * Array forEach
     */
    function forEach(arr, callback, thisObj) {
        if (arr == null) {
            return;
        }
        var i = -1,
            len = arr.length;
        while (++i < len) {
            // we iterate over sparse items since there is no way to make it
            // work properly on IE 7-8. see #64
            if ( callback.call(thisObj, arr[i], i, arr) === false ) {
                break;
            }
        }
    }

    module.exports = forEach;



},{}],416:[function(require,module,exports){


    /**
     * Array.indexOf
     */
    function indexOf(arr, item, fromIndex) {
        fromIndex = fromIndex || 0;
        if (arr == null) {
            return -1;
        }

        var len = arr.length,
            i = fromIndex < 0 ? len + fromIndex : fromIndex;
        while (i < len) {
            // we iterate over sparse items since there is no way to make it
            // work properly on IE 7-8. see #64
            if (arr[i] === item) {
                return i;
            }

            i++;
        }

        return -1;
    }

    module.exports = indexOf;


},{}],417:[function(require,module,exports){
var unique = require('./unique');
var filter = require('./filter');
var every = require('./every');
var contains = require('./contains');
var slice = require('./slice');


    /**
     * Return a new Array with elements common to all Arrays.
     * - based on underscore.js implementation
     */
    function intersection(arr) {
        var arrs = slice(arguments, 1),
            result = filter(unique(arr), function(needle){
                return every(arrs, function(haystack){
                    return contains(haystack, needle);
                });
            });
        return result;
    }

    module.exports = intersection;



},{"./contains":410,"./every":413,"./filter":414,"./slice":420,"./unique":422}],418:[function(require,module,exports){
var makeIterator = require('../function/makeIterator_');

    /**
     * Array map
     */
    function map(arr, callback, thisObj) {
        callback = makeIterator(callback, thisObj);
        var results = [];
        if (arr == null){
            return results;
        }

        var i = -1, len = arr.length;
        while (++i < len) {
            results[i] = callback(arr[i], i, arr);
        }

        return results;
    }

     module.exports = map;


},{"../function/makeIterator_":425}],419:[function(require,module,exports){
var countSteps = require('../math/countSteps');

    /**
     * Returns an Array of numbers inside range.
     */
    function range(start, stop, step) {
        if (stop == null) {
            stop = start;
            start = 0;
        }
        step = step || 1;

        var result = [],
            nSteps = countSteps(stop - start, step),
            i = start;

        while (i <= stop) {
            result.push(i);
            i += step;
        }

        return result;
    }

    module.exports = range;



},{"../math/countSteps":440}],420:[function(require,module,exports){


    /**
     * Create slice of source array or array-like object
     */
    function slice(arr, start, end){
        var len = arr.length;

        if (start == null) {
            start = 0;
        } else if (start < 0) {
            start = Math.max(len + start, 0);
        } else {
            start = Math.min(start, len);
        }

        if (end == null) {
            end = len;
        } else if (end < 0) {
            end = Math.max(len + end, 0);
        } else {
            end = Math.min(end, len);
        }

        var result = [];
        while (start < end) {
            result.push(arr[start++]);
        }

        return result;
    }

    module.exports = slice;



},{}],421:[function(require,module,exports){
var makeIterator = require('../function/makeIterator_');

    /**
     * Array some
     */
    function some(arr, callback, thisObj) {
        callback = makeIterator(callback, thisObj);
        var result = false;
        if (arr == null) {
            return result;
        }

        var i = -1, len = arr.length;
        while (++i < len) {
            // we iterate over sparse items since there is no way to make it
            // work properly on IE 7-8. see #64
            if ( callback(arr[i], i, arr) ) {
                result = true;
                break;
            }
        }

        return result;
    }

    module.exports = some;


},{"../function/makeIterator_":425}],422:[function(require,module,exports){
var filter = require('./filter');

    /**
     * @return {array} Array of unique items
     */
    function unique(arr, compare){
        compare = compare || isEqual;
        return filter(arr, function(item, i, arr){
            var n = arr.length;
            while (++i < n) {
                if ( compare(item, arr[i]) ) {
                    return false;
                }
            }
            return true;
        });
    }

    function isEqual(a, b){
        return a === b;
    }

    module.exports = unique;



},{"./filter":414}],423:[function(require,module,exports){


    /**
     * Debounce callback execution
     */
    function debounce(fn, threshold, isAsap){
        var timeout, result;
        function debounced(){
            var args = arguments, context = this;
            function delayed(){
                if (! isAsap) {
                    result = fn.apply(context, args);
                }
                timeout = null;
            }
            if (timeout) {
                clearTimeout(timeout);
            } else if (isAsap) {
                result = fn.apply(context, args);
            }
            timeout = setTimeout(delayed, threshold);
            return result;
        }
        debounced.cancel = function(){
            clearTimeout(timeout);
        };
        return debounced;
    }

    module.exports = debounce;



},{}],424:[function(require,module,exports){


    /**
     * Returns the first argument provided to it.
     */
    function identity(val){
        return val;
    }

    module.exports = identity;



},{}],425:[function(require,module,exports){
var identity = require('./identity');
var prop = require('./prop');
var deepMatches = require('../object/deepMatches');

    /**
     * Converts argument into a valid iterator.
     * Used internally on most array/object/collection methods that receives a
     * callback/iterator providing a shortcut syntax.
     */
    function makeIterator(src, thisObj){
        if (src == null) {
            return identity;
        }
        switch(typeof src) {
            case 'function':
                // function is the first to improve perf (most common case)
                // also avoid using `Function#call` if not needed, which boosts
                // perf a lot in some cases
                return (typeof thisObj !== 'undefined')? function(val, i, arr){
                    return src.call(thisObj, val, i, arr);
                } : src;
            case 'object':
                return function(val){
                    return deepMatches(val, src);
                };
            case 'string':
            case 'number':
                return prop(src);
        }
    }

    module.exports = makeIterator;



},{"../object/deepMatches":441,"./identity":424,"./prop":426}],426:[function(require,module,exports){


    /**
     * Returns a function that gets a property of the passed object
     */
    function prop(name){
        return function(obj){
            return obj[name];
        };
    }

    module.exports = prop;



},{}],427:[function(require,module,exports){
var kindOf = require('./kindOf');
var isPlainObject = require('./isPlainObject');
var mixIn = require('../object/mixIn');

    /**
     * Clone native types.
     */
    function clone(val){
        switch (kindOf(val)) {
            case 'Object':
                return cloneObject(val);
            case 'Array':
                return cloneArray(val);
            case 'RegExp':
                return cloneRegExp(val);
            case 'Date':
                return cloneDate(val);
            default:
                return val;
        }
    }

    function cloneObject(source) {
        if (isPlainObject(source)) {
            return mixIn({}, source);
        } else {
            return source;
        }
    }

    function cloneRegExp(r) {
        var flags = '';
        flags += r.multiline ? 'm' : '';
        flags += r.global ? 'g' : '';
        flags += r.ignoreCase ? 'i' : '';
        return new RegExp(r.source, flags);
    }

    function cloneDate(date) {
        return new Date(+date);
    }

    function cloneArray(arr) {
        return arr.slice();
    }

    module.exports = clone;



},{"../object/mixIn":449,"./isPlainObject":436,"./kindOf":438}],428:[function(require,module,exports){
var mixIn = require('../object/mixIn');

    /**
     * Create Object using prototypal inheritance and setting custom properties.
     * - Mix between Douglas Crockford Prototypal Inheritance <http://javascript.crockford.com/prototypal.html> and the EcmaScript 5 `Object.create()` method.
     * @param {object} parent    Parent Object.
     * @param {object} [props] Object properties.
     * @return {object} Created object.
     */
    function createObject(parent, props){
        function F(){}
        F.prototype = parent;
        return mixIn(new F(), props);

    }
    module.exports = createObject;



},{"../object/mixIn":449}],429:[function(require,module,exports){
var clone = require('./clone');
var forOwn = require('../object/forOwn');
var kindOf = require('./kindOf');
var isPlainObject = require('./isPlainObject');

    /**
     * Recursively clone native types.
     */
    function deepClone(val, instanceClone) {
        switch ( kindOf(val) ) {
            case 'Object':
                return cloneObject(val, instanceClone);
            case 'Array':
                return cloneArray(val, instanceClone);
            default:
                return clone(val);
        }
    }

    function cloneObject(source, instanceClone) {
        if (isPlainObject(source)) {
            var out = {};
            forOwn(source, function(val, key) {
                this[key] = deepClone(val, instanceClone);
            }, out);
            return out;
        } else if (instanceClone) {
            return instanceClone(source);
        } else {
            return source;
        }
    }

    function cloneArray(arr, instanceClone) {
        var out = [],
            i = -1,
            n = arr.length,
            val;
        while (++i < n) {
            out[i] = deepClone(arr[i], instanceClone);
        }
        return out;
    }

    module.exports = deepClone;




},{"../object/forOwn":446,"./clone":427,"./isPlainObject":436,"./kindOf":438}],430:[function(require,module,exports){
var is = require('./is');
var isObject = require('./isObject');
var isArray = require('./isArray');
var objEquals = require('../object/equals');
var arrEquals = require('../array/equals');

    /**
     * Recursively checks for same properties and values.
     */
    function deepEquals(a, b, callback){
        callback = callback || is;

        var bothObjects = isObject(a) && isObject(b);
        var bothArrays = !bothObjects && isArray(a) && isArray(b);

        if (!bothObjects && !bothArrays) {
            return callback(a, b);
        }

        function compare(a, b){
            return deepEquals(a, b, callback);
        }

        var method = bothObjects ? objEquals : arrEquals;
        return method(a, b, compare);
    }

    module.exports = deepEquals;



},{"../array/equals":412,"../object/equals":443,"./is":431,"./isArray":432,"./isObject":435}],431:[function(require,module,exports){


    /**
     * Check if both arguments are egal.
     */
    function is(x, y){
        // implementation borrowed from harmony:egal spec
        if (x === y) {
          // 0 === -0, but they are not identical
          return x !== 0 || 1 / x === 1 / y;
        }

        // NaN !== NaN, but they are identical.
        // NaNs are the only non-reflexive value, i.e., if x !== x,
        // then x is a NaN.
        // isNaN is broken: it converts its argument to number, so
        // isNaN("foo") => true
        return x !== x && y !== y;
    }

    module.exports = is;



},{}],432:[function(require,module,exports){
var isKind = require('./isKind');
    /**
     */
    var isArray = Array.isArray || function (val) {
        return isKind(val, 'Array');
    };
    module.exports = isArray;


},{"./isKind":433}],433:[function(require,module,exports){
var kindOf = require('./kindOf');
    /**
     * Check if value is from a specific "kind".
     */
    function isKind(val, kind){
        return kindOf(val) === kind;
    }
    module.exports = isKind;


},{"./kindOf":438}],434:[function(require,module,exports){
var isKind = require('./isKind');
    /**
     */
    function isNumber(val) {
        return isKind(val, 'Number');
    }
    module.exports = isNumber;


},{"./isKind":433}],435:[function(require,module,exports){
var isKind = require('./isKind');
    /**
     */
    function isObject(val) {
        return isKind(val, 'Object');
    }
    module.exports = isObject;


},{"./isKind":433}],436:[function(require,module,exports){


    /**
     * Checks if the value is created by the `Object` constructor.
     */
    function isPlainObject(value) {
        return (!!value && typeof value === 'object' &&
            value.constructor === Object);
    }

    module.exports = isPlainObject;



},{}],437:[function(require,module,exports){
var isKind = require('./isKind');
    /**
     */
    function isRegExp(val) {
        return isKind(val, 'RegExp');
    }
    module.exports = isRegExp;


},{"./isKind":433}],438:[function(require,module,exports){

    /**
     * Gets the "kind" of value. (e.g. "String", "Number", etc)
     */
    function kindOf(val) {
        return Object.prototype.toString.call(val).slice(8, -1);
    }
    module.exports = kindOf;


},{}],439:[function(require,module,exports){


    /**
     * Typecast a value to a String, using an empty string value for null or
     * undefined.
     */
    function toString(val){
        return val == null ? '' : val.toString();
    }

    module.exports = toString;



},{}],440:[function(require,module,exports){

    /**
    * Count number of full steps.
    */
    function countSteps(val, step, overflow){
        val = Math.floor(val / step);

        if (overflow) {
            return val % overflow;
        }

        return val;
    }

    module.exports = countSteps;


},{}],441:[function(require,module,exports){
var forOwn = require('./forOwn');
var isArray = require('../lang/isArray');

    function containsMatch(array, pattern) {
        var i = -1, length = array.length;
        while (++i < length) {
            if (deepMatches(array[i], pattern)) {
                return true;
            }
        }

        return false;
    }

    function matchArray(target, pattern) {
        var i = -1, patternLength = pattern.length;
        while (++i < patternLength) {
            if (!containsMatch(target, pattern[i])) {
                return false;
            }
        }

        return true;
    }

    function matchObject(target, pattern) {
        var result = true;
        forOwn(pattern, function(val, key) {
            if (!deepMatches(target[key], val)) {
                // Return false to break out of forOwn early
                return (result = false);
            }
        });

        return result;
    }

    /**
     * Recursively check if the objects match.
     */
    function deepMatches(target, pattern){
        if (target && typeof target === 'object' &&
            pattern && typeof pattern === 'object') {
            if (isArray(target) && isArray(pattern)) {
                return matchArray(target, pattern);
            } else {
                return matchObject(target, pattern);
            }
        } else {
            return target === pattern;
        }
    }

    module.exports = deepMatches;



},{"../lang/isArray":432,"./forOwn":446}],442:[function(require,module,exports){
var forOwn = require('./forOwn');
var isPlainObject = require('../lang/isPlainObject');

    /**
     * Mixes objects into the target object, recursively mixing existing child
     * objects.
     */
    function deepMixIn(target, objects) {
        var i = 0,
            n = arguments.length,
            obj;

        while(++i < n){
            obj = arguments[i];
            if (obj) {
                forOwn(obj, copyProp, target);
            }
        }

        return target;
    }

    function copyProp(val, key) {
        var existing = this[key];
        if (isPlainObject(val) && isPlainObject(existing)) {
            deepMixIn(existing, val);
        } else {
            this[key] = val;
        }
    }

    module.exports = deepMixIn;



},{"../lang/isPlainObject":436,"./forOwn":446}],443:[function(require,module,exports){
var hasOwn = require('./hasOwn');
var every = require('./every');
var isObject = require('../lang/isObject');
var is = require('../lang/is');

    // Makes a function to compare the object values from the specified compare
    // operation callback.
    function makeCompare(callback) {
        return function(value, key) {
            return hasOwn(this, key) && callback(value, this[key]);
        };
    }

    function checkProperties(value, key) {
        return hasOwn(this, key);
    }

    /**
     * Checks if two objects have the same keys and values.
     */
    function equals(a, b, callback) {
        callback = callback || is;

        if (!isObject(a) || !isObject(b)) {
            return callback(a, b);
        }

        return (every(a, makeCompare(callback), b) &&
                every(b, checkProperties, a));
    }

    module.exports = equals;


},{"../lang/is":431,"../lang/isObject":435,"./every":444,"./hasOwn":447}],444:[function(require,module,exports){
var forOwn = require('./forOwn');
var makeIterator = require('../function/makeIterator_');

    /**
     * Object every
     */
    function every(obj, callback, thisObj) {
        callback = makeIterator(callback, thisObj);
        var result = true;
        forOwn(obj, function(val, key) {
            // we consider any falsy values as "false" on purpose so shorthand
            // syntax can be used to check property existence
            if (!callback(val, key, obj)) {
                result = false;
                return false; // break
            }
        });
        return result;
    }

    module.exports = every;



},{"../function/makeIterator_":425,"./forOwn":446}],445:[function(require,module,exports){
var hasOwn = require('./hasOwn');

    var _hasDontEnumBug,
        _dontEnums;

    function checkDontEnum(){
        _dontEnums = [
                'toString',
                'toLocaleString',
                'valueOf',
                'hasOwnProperty',
                'isPrototypeOf',
                'propertyIsEnumerable',
                'constructor'
            ];

        _hasDontEnumBug = true;

        for (var key in {'toString': null}) {
            _hasDontEnumBug = false;
        }
    }

    /**
     * Similar to Array/forEach but works over object properties and fixes Don't
     * Enum bug on IE.
     * based on: http://whattheheadsaid.com/2010/10/a-safer-object-keys-compatibility-implementation
     */
    function forIn(obj, fn, thisObj){
        var key, i = 0;
        // no need to check if argument is a real object that way we can use
        // it for arrays, functions, date, etc.

        //post-pone check till needed
        if (_hasDontEnumBug == null) checkDontEnum();

        for (key in obj) {
            if (exec(fn, obj, key, thisObj) === false) {
                break;
            }
        }


        if (_hasDontEnumBug) {
            var ctor = obj.constructor,
                isProto = !!ctor && obj === ctor.prototype;

            while (key = _dontEnums[i++]) {
                // For constructor, if it is a prototype object the constructor
                // is always non-enumerable unless defined otherwise (and
                // enumerated above).  For non-prototype objects, it will have
                // to be defined on this object, since it cannot be defined on
                // any prototype objects.
                //
                // For other [[DontEnum]] properties, check if the value is
                // different than Object prototype value.
                if (
                    (key !== 'constructor' ||
                        (!isProto && hasOwn(obj, key))) &&
                    obj[key] !== Object.prototype[key]
                ) {
                    if (exec(fn, obj, key, thisObj) === false) {
                        break;
                    }
                }
            }
        }
    }

    function exec(fn, obj, key, thisObj){
        return fn.call(thisObj, obj[key], key, obj);
    }

    module.exports = forIn;



},{"./hasOwn":447}],446:[function(require,module,exports){
var hasOwn = require('./hasOwn');
var forIn = require('./forIn');

    /**
     * Similar to Array/forEach but works over object properties and fixes Don't
     * Enum bug on IE.
     * based on: http://whattheheadsaid.com/2010/10/a-safer-object-keys-compatibility-implementation
     */
    function forOwn(obj, fn, thisObj){
        forIn(obj, function(val, key){
            if (hasOwn(obj, key)) {
                return fn.call(thisObj, obj[key], key, obj);
            }
        });
    }

    module.exports = forOwn;



},{"./forIn":445,"./hasOwn":447}],447:[function(require,module,exports){


    /**
     * Safer Object.hasOwnProperty
     */
     function hasOwn(obj, prop){
         return Object.prototype.hasOwnProperty.call(obj, prop);
     }

     module.exports = hasOwn;



},{}],448:[function(require,module,exports){
var hasOwn = require('./hasOwn');
var deepClone = require('../lang/deepClone');
var isObject = require('../lang/isObject');

    /**
     * Deep merge objects.
     */
    function merge() {
        var i = 1,
            key, val, obj, target;

        // make sure we don't modify source element and it's properties
        // objects are passed by reference
        target = deepClone( arguments[0] );

        while (obj = arguments[i++]) {
            for (key in obj) {
                if ( ! hasOwn(obj, key) ) {
                    continue;
                }

                val = obj[key];

                if ( isObject(val) && isObject(target[key]) ){
                    // inception, deep merge objects
                    target[key] = merge(target[key], val);
                } else {
                    // make sure arrays, regexp, date, objects are cloned
                    target[key] = deepClone(val);
                }

            }
        }

        return target;
    }

    module.exports = merge;



},{"../lang/deepClone":429,"../lang/isObject":435,"./hasOwn":447}],449:[function(require,module,exports){
var forOwn = require('./forOwn');

    /**
    * Combine properties from all the objects into first one.
    * - This method affects target object in place, if you want to create a new Object pass an empty object as first param.
    * @param {object} target    Target Object
    * @param {...object} objects    Objects to be combined (0...n objects).
    * @return {object} Target Object.
    */
    function mixIn(target, objects){
        var i = 0,
            n = arguments.length,
            obj;
        while(++i < n){
            obj = arguments[i];
            if (obj != null) {
                forOwn(obj, copyProp, target);
            }
        }
        return target;
    }

    function copyProp(val, key){
        this[key] = val;
    }

    module.exports = mixIn;


},{"./forOwn":446}],450:[function(require,module,exports){
var slice = require('../array/slice');

    /**
     * Return a copy of the object, filtered to only have values for the whitelisted keys.
     */
    function pick(obj, var_keys){
        var keys = typeof arguments[1] !== 'string'? arguments[1] : slice(arguments, 1),
            out = {},
            i = 0, key;
        while (key = keys[i++]) {
            out[key] = obj[key];
        }
        return out;
    }

    module.exports = pick;



},{"../array/slice":420}],451:[function(require,module,exports){

    /**
     * Contains all Unicode white-spaces. Taken from
     * http://en.wikipedia.org/wiki/Whitespace_character.
     */
    module.exports = [
        ' ', '\n', '\r', '\t', '\f', '\v', '\u00A0', '\u1680', '\u180E',
        '\u2000', '\u2001', '\u2002', '\u2003', '\u2004', '\u2005', '\u2006',
        '\u2007', '\u2008', '\u2009', '\u200A', '\u2028', '\u2029', '\u202F',
        '\u205F', '\u3000'
    ];


},{}],452:[function(require,module,exports){
var toString = require('../lang/toString');

    /**
     * Escape RegExp string chars.
     */
    function escapeRegExp(str) {
        return toString(str).replace(/\W/g,'\\$&');
    }

    module.exports = escapeRegExp;



},{"../lang/toString":439}],453:[function(require,module,exports){
var toString = require('../lang/toString');
var WHITE_SPACES = require('./WHITE_SPACES');
    /**
     * Remove chars from beginning of string.
     */
    function ltrim(str, chars) {
        str = toString(str);
        chars = chars || WHITE_SPACES;

        var start = 0,
            len = str.length,
            charLen = chars.length,
            found = true,
            i, c;

        while (found && start < len) {
            found = false;
            i = -1;
            c = str.charAt(start);

            while (++i < charLen) {
                if (c === chars[i]) {
                    found = true;
                    start++;
                    break;
                }
            }
        }

        return (start >= len) ? '' : str.substr(start, len);
    }

    module.exports = ltrim;


},{"../lang/toString":439,"./WHITE_SPACES":451}],454:[function(require,module,exports){
var toString = require('../lang/toString');
var WHITE_SPACES = require('./WHITE_SPACES');
    /**
     * Remove chars from end of string.
     */
    function rtrim(str, chars) {
        str = toString(str);
        chars = chars || WHITE_SPACES;

        var end = str.length - 1,
            charLen = chars.length,
            found = true,
            i, c;

        while (found && end >= 0) {
            found = false;
            i = -1;
            c = str.charAt(end);

            while (++i < charLen) {
                if (c === chars[i]) {
                    found = true;
                    end--;
                    break;
                }
            }
        }

        return (end >= 0) ? str.substring(0, end + 1) : '';
    }

    module.exports = rtrim;


},{"../lang/toString":439,"./WHITE_SPACES":451}],455:[function(require,module,exports){
var toString = require('../lang/toString');
var WHITE_SPACES = require('./WHITE_SPACES');
var ltrim = require('./ltrim');
var rtrim = require('./rtrim');
    /**
     * Remove white-spaces from beginning and end of string.
     */
    function trim(str, chars) {
        str = toString(str);
        chars = chars || WHITE_SPACES;
        return ltrim(rtrim(str, chars), chars);
    }

    module.exports = trim;


},{"../lang/toString":439,"./WHITE_SPACES":451,"./ltrim":453,"./rtrim":454}],456:[function(require,module,exports){


    /**
     * Get current time in miliseconds
     */
    function now(){
        // yes, we defer the work to another function to allow mocking it
        // during the tests
        return now.get();
    }

    now.get = (typeof Date.now === 'function')? Date.now : function(){
        return +(new Date());
    };

    module.exports = now;



},{}],457:[function(require,module,exports){
/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */

module.exports = function(val, options) {
  options = options || {};
  var type = typeof val;
  if (type === 'string' && val.length > 0) {
    return parse(val);
  } else if (type === 'number' && isNaN(val) === false) {
    return options.long ? fmtLong(val) : fmtShort(val);
  }
  throw new Error(
    'val is not a non-empty string or a valid number. val=' +
      JSON.stringify(val)
  );
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  str = String(str);
  if (str.length > 100) {
    return;
  }
  var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(
    str
  );
  if (!match) {
    return;
  }
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
    default:
      return undefined;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtShort(ms) {
  if (ms >= d) {
    return Math.round(ms / d) + 'd';
  }
  if (ms >= h) {
    return Math.round(ms / h) + 'h';
  }
  if (ms >= m) {
    return Math.round(ms / m) + 'm';
  }
  if (ms >= s) {
    return Math.round(ms / s) + 's';
  }
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtLong(ms) {
  return plural(ms, d, 'day') ||
    plural(ms, h, 'hour') ||
    plural(ms, m, 'minute') ||
    plural(ms, s, 'second') ||
    ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, n, name) {
  if (ms < n) {
    return;
  }
  if (ms < n * 1.5) {
    return Math.floor(ms / n) + ' ' + name;
  }
  return Math.ceil(ms / n) + ' ' + name + 's';
}

},{}],458:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],459:[function(require,module,exports){
function RavenConfigError(message) {
  this.name = 'RavenConfigError';
  this.message = message;
}
RavenConfigError.prototype = new Error();
RavenConfigError.prototype.constructor = RavenConfigError;

module.exports = RavenConfigError;

},{}],460:[function(require,module,exports){
var utils = require('./utils');

var wrapMethod = function(console, level, callback) {
  var originalConsoleLevel = console[level];
  var originalConsole = console;

  if (!(level in console)) {
    return;
  }

  var sentryLevel = level === 'warn' ? 'warning' : level;

  console[level] = function() {
    var args = [].slice.call(arguments);

    var msg = utils.safeJoin(args, ' ');
    var data = {level: sentryLevel, logger: 'console', extra: {arguments: args}};

    if (level === 'assert') {
      if (args[0] === false) {
        // Default browsers message
        msg =
          'Assertion failed: ' + (utils.safeJoin(args.slice(1), ' ') || 'console.assert');
        data.extra.arguments = args.slice(1);
        callback && callback(msg, data);
      }
    } else {
      callback && callback(msg, data);
    }

    // this fails for some browsers. :(
    if (originalConsoleLevel) {
      // IE9 doesn't allow calling apply on console functions directly
      // See: https://stackoverflow.com/questions/5472938/does-ie9-support-console-log-and-is-it-a-real-function#answer-5473193
      Function.prototype.apply.call(originalConsoleLevel, originalConsole, args);
    }
  };
};

module.exports = {
  wrapMethod: wrapMethod
};

},{"./utils":463}],461:[function(require,module,exports){
(function (global){
/*global XDomainRequest:false */

var TraceKit = require('../vendor/TraceKit/tracekit');
var stringify = require('../vendor/json-stringify-safe/stringify');
var md5 = require('../vendor/md5/md5');
var RavenConfigError = require('./configError');

var utils = require('./utils');
var isErrorEvent = utils.isErrorEvent;
var isDOMError = utils.isDOMError;
var isDOMException = utils.isDOMException;
var isError = utils.isError;
var isObject = utils.isObject;
var isPlainObject = utils.isPlainObject;
var isUndefined = utils.isUndefined;
var isFunction = utils.isFunction;
var isString = utils.isString;
var isArray = utils.isArray;
var isEmptyObject = utils.isEmptyObject;
var each = utils.each;
var objectMerge = utils.objectMerge;
var truncate = utils.truncate;
var objectFrozen = utils.objectFrozen;
var hasKey = utils.hasKey;
var joinRegExp = utils.joinRegExp;
var urlencode = utils.urlencode;
var uuid4 = utils.uuid4;
var htmlTreeAsString = utils.htmlTreeAsString;
var isSameException = utils.isSameException;
var isSameStacktrace = utils.isSameStacktrace;
var parseUrl = utils.parseUrl;
var fill = utils.fill;
var supportsFetch = utils.supportsFetch;
var supportsReferrerPolicy = utils.supportsReferrerPolicy;
var serializeKeysForMessage = utils.serializeKeysForMessage;
var serializeException = utils.serializeException;
var sanitize = utils.sanitize;

var wrapConsoleMethod = require('./console').wrapMethod;

var dsnKeys = 'source protocol user pass host port path'.split(' '),
  dsnPattern = /^(?:(\w+):)?\/\/(?:(\w+)(:\w+)?@)?([\w\.-]+)(?::(\d+))?(\/.*)/;

function now() {
  return +new Date();
}

// This is to be defensive in environments where window does not exist (see https://github.com/getsentry/raven-js/pull/785)
var _window =
  typeof window !== 'undefined'
    ? window
    : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};
var _document = _window.document;
var _navigator = _window.navigator;

function keepOriginalCallback(original, callback) {
  return isFunction(callback)
    ? function(data) {
        return callback(data, original);
      }
    : callback;
}

// First, check for JSON support
// If there is no JSON, we no-op the core features of Raven
// since JSON is required to encode the payload
function Raven() {
  this._hasJSON = !!(typeof JSON === 'object' && JSON.stringify);
  // Raven can run in contexts where there's no document (react-native)
  this._hasDocument = !isUndefined(_document);
  this._hasNavigator = !isUndefined(_navigator);
  this._lastCapturedException = null;
  this._lastData = null;
  this._lastEventId = null;
  this._globalServer = null;
  this._globalKey = null;
  this._globalProject = null;
  this._globalContext = {};
  this._globalOptions = {
    // SENTRY_RELEASE can be injected by https://github.com/getsentry/sentry-webpack-plugin
    release: _window.SENTRY_RELEASE && _window.SENTRY_RELEASE.id,
    logger: 'javascript',
    ignoreErrors: [],
    ignoreUrls: [],
    whitelistUrls: [],
    includePaths: [],
    headers: null,
    collectWindowErrors: true,
    captureUnhandledRejections: true,
    maxMessageLength: 0,
    // By default, truncates URL values to 250 chars
    maxUrlLength: 250,
    stackTraceLimit: 50,
    autoBreadcrumbs: true,
    instrument: true,
    sampleRate: 1,
    sanitizeKeys: []
  };
  this._fetchDefaults = {
    method: 'POST',
    keepalive: true,
    // Despite all stars in the sky saying that Edge supports old draft syntax, aka 'never', 'always', 'origin' and 'default
    // https://caniuse.com/#feat=referrer-policy
    // It doesn't. And it throw exception instead of ignoring this parameter...
    // REF: https://github.com/getsentry/raven-js/issues/1233
    referrerPolicy: supportsReferrerPolicy() ? 'origin' : ''
  };
  this._ignoreOnError = 0;
  this._isRavenInstalled = false;
  this._originalErrorStackTraceLimit = Error.stackTraceLimit;
  // capture references to window.console *and* all its methods first
  // before the console plugin has a chance to monkey patch
  this._originalConsole = _window.console || {};
  this._originalConsoleMethods = {};
  this._plugins = [];
  this._startTime = now();
  this._wrappedBuiltIns = [];
  this._breadcrumbs = [];
  this._lastCapturedEvent = null;
  this._keypressTimeout;
  this._location = _window.location;
  this._lastHref = this._location && this._location.href;
  this._resetBackoff();

  // eslint-disable-next-line guard-for-in
  for (var method in this._originalConsole) {
    this._originalConsoleMethods[method] = this._originalConsole[method];
  }
}

/*
 * The core Raven singleton
 *
 * @this {Raven}
 */

Raven.prototype = {
  // Hardcode version string so that raven source can be loaded directly via
  // webpack (using a build step causes webpack #1617). Grunt verifies that
  // this value matches package.json during build.
  //   See: https://github.com/getsentry/raven-js/issues/465
  VERSION: '3.26.2',

  debug: false,

  TraceKit: TraceKit, // alias to TraceKit

  /*
     * Configure Raven with a DSN and extra options
     *
     * @param {string} dsn The public Sentry DSN
     * @param {object} options Set of global options [optional]
     * @return {Raven}
     */
  config: function(dsn, options) {
    var self = this;

    if (self._globalServer) {
      this._logDebug('error', 'Error: Raven has already been configured');
      return self;
    }
    if (!dsn) return self;

    var globalOptions = self._globalOptions;

    // merge in options
    if (options) {
      each(options, function(key, value) {
        // tags and extra are special and need to be put into context
        if (key === 'tags' || key === 'extra' || key === 'user') {
          self._globalContext[key] = value;
        } else {
          globalOptions[key] = value;
        }
      });
    }

    self.setDSN(dsn);

    // "Script error." is hard coded into browsers for errors that it can't read.
    // this is the result of a script being pulled in from an external domain and CORS.
    globalOptions.ignoreErrors.push(/^Script error\.?$/);
    globalOptions.ignoreErrors.push(/^Javascript error: Script error\.? on line 0$/);

    // join regexp rules into one big rule
    globalOptions.ignoreErrors = joinRegExp(globalOptions.ignoreErrors);
    globalOptions.ignoreUrls = globalOptions.ignoreUrls.length
      ? joinRegExp(globalOptions.ignoreUrls)
      : false;
    globalOptions.whitelistUrls = globalOptions.whitelistUrls.length
      ? joinRegExp(globalOptions.whitelistUrls)
      : false;
    globalOptions.includePaths = joinRegExp(globalOptions.includePaths);
    globalOptions.maxBreadcrumbs = Math.max(
      0,
      Math.min(globalOptions.maxBreadcrumbs || 100, 100)
    ); // default and hard limit is 100

    var autoBreadcrumbDefaults = {
      xhr: true,
      console: true,
      dom: true,
      location: true,
      sentry: true
    };

    var autoBreadcrumbs = globalOptions.autoBreadcrumbs;
    if ({}.toString.call(autoBreadcrumbs) === '[object Object]') {
      autoBreadcrumbs = objectMerge(autoBreadcrumbDefaults, autoBreadcrumbs);
    } else if (autoBreadcrumbs !== false) {
      autoBreadcrumbs = autoBreadcrumbDefaults;
    }
    globalOptions.autoBreadcrumbs = autoBreadcrumbs;

    var instrumentDefaults = {
      tryCatch: true
    };

    var instrument = globalOptions.instrument;
    if ({}.toString.call(instrument) === '[object Object]') {
      instrument = objectMerge(instrumentDefaults, instrument);
    } else if (instrument !== false) {
      instrument = instrumentDefaults;
    }
    globalOptions.instrument = instrument;

    TraceKit.collectWindowErrors = !!globalOptions.collectWindowErrors;

    // return for chaining
    return self;
  },

  /*
     * Installs a global window.onerror error handler
     * to capture and report uncaught exceptions.
     * At this point, install() is required to be called due
     * to the way TraceKit is set up.
     *
     * @return {Raven}
     */
  install: function() {
    var self = this;
    if (self.isSetup() && !self._isRavenInstalled) {
      TraceKit.report.subscribe(function() {
        self._handleOnErrorStackInfo.apply(self, arguments);
      });

      if (self._globalOptions.captureUnhandledRejections) {
        self._attachPromiseRejectionHandler();
      }

      self._patchFunctionToString();

      if (self._globalOptions.instrument && self._globalOptions.instrument.tryCatch) {
        self._instrumentTryCatch();
      }

      if (self._globalOptions.autoBreadcrumbs) self._instrumentBreadcrumbs();

      // Install all of the plugins
      self._drainPlugins();

      self._isRavenInstalled = true;
    }

    Error.stackTraceLimit = self._globalOptions.stackTraceLimit;
    return this;
  },

  /*
     * Set the DSN (can be called multiple time unlike config)
     *
     * @param {string} dsn The public Sentry DSN
     */
  setDSN: function(dsn) {
    var self = this,
      uri = self._parseDSN(dsn),
      lastSlash = uri.path.lastIndexOf('/'),
      path = uri.path.substr(1, lastSlash);

    self._dsn = dsn;
    self._globalKey = uri.user;
    self._globalSecret = uri.pass && uri.pass.substr(1);
    self._globalProject = uri.path.substr(lastSlash + 1);

    self._globalServer = self._getGlobalServer(uri);

    self._globalEndpoint =
      self._globalServer + '/' + path + 'api/' + self._globalProject + '/store/';

    // Reset backoff state since we may be pointing at a
    // new project/server
    this._resetBackoff();
  },

  /*
     * Wrap code within a context so Raven can capture errors
     * reliably across domains that is executed immediately.
     *
     * @param {object} options A specific set of options for this context [optional]
     * @param {function} func The callback to be immediately executed within the context
     * @param {array} args An array of arguments to be called with the callback [optional]
     */
  context: function(options, func, args) {
    if (isFunction(options)) {
      args = func || [];
      func = options;
      options = {};
    }

    return this.wrap(options, func).apply(this, args);
  },

  /*
     * Wrap code within a context and returns back a new function to be executed
     *
     * @param {object} options A specific set of options for this context [optional]
     * @param {function} func The function to be wrapped in a new context
     * @param {function} _before A function to call before the try/catch wrapper [optional, private]
     * @return {function} The newly wrapped functions with a context
     */
  wrap: function(options, func, _before) {
    var self = this;
    // 1 argument has been passed, and it's not a function
    // so just return it
    if (isUndefined(func) && !isFunction(options)) {
      return options;
    }

    // options is optional
    if (isFunction(options)) {
      func = options;
      options = undefined;
    }

    // At this point, we've passed along 2 arguments, and the second one
    // is not a function either, so we'll just return the second argument.
    if (!isFunction(func)) {
      return func;
    }

    // We don't wanna wrap it twice!
    try {
      if (func.__raven__) {
        return func;
      }

      // If this has already been wrapped in the past, return that
      if (func.__raven_wrapper__) {
        return func.__raven_wrapper__;
      }
    } catch (e) {
      // Just accessing custom props in some Selenium environments
      // can cause a "Permission denied" exception (see raven-js#495).
      // Bail on wrapping and return the function as-is (defers to window.onerror).
      return func;
    }

    function wrapped() {
      var args = [],
        i = arguments.length,
        deep = !options || (options && options.deep !== false);

      if (_before && isFunction(_before)) {
        _before.apply(this, arguments);
      }

      // Recursively wrap all of a function's arguments that are
      // functions themselves.
      while (i--) args[i] = deep ? self.wrap(options, arguments[i]) : arguments[i];

      try {
        // Attempt to invoke user-land function
        // NOTE: If you are a Sentry user, and you are seeing this stack frame, it
        //       means Raven caught an error invoking your application code. This is
        //       expected behavior and NOT indicative of a bug with Raven.js.
        return func.apply(this, args);
      } catch (e) {
        self._ignoreNextOnError();
        self.captureException(e, options);
        throw e;
      }
    }

    // copy over properties of the old function
    for (var property in func) {
      if (hasKey(func, property)) {
        wrapped[property] = func[property];
      }
    }
    wrapped.prototype = func.prototype;

    func.__raven_wrapper__ = wrapped;
    // Signal that this function has been wrapped/filled already
    // for both debugging and to prevent it to being wrapped/filled twice
    wrapped.__raven__ = true;
    wrapped.__orig__ = func;

    return wrapped;
  },

  /**
   * Uninstalls the global error handler.
   *
   * @return {Raven}
   */
  uninstall: function() {
    TraceKit.report.uninstall();

    this._detachPromiseRejectionHandler();
    this._unpatchFunctionToString();
    this._restoreBuiltIns();
    this._restoreConsole();

    Error.stackTraceLimit = this._originalErrorStackTraceLimit;
    this._isRavenInstalled = false;

    return this;
  },

  /**
   * Callback used for `unhandledrejection` event
   *
   * @param {PromiseRejectionEvent} event An object containing
   *   promise: the Promise that was rejected
   *   reason: the value with which the Promise was rejected
   * @return void
   */
  _promiseRejectionHandler: function(event) {
    this._logDebug('debug', 'Raven caught unhandled promise rejection:', event);
    this.captureException(event.reason, {
      mechanism: {
        type: 'onunhandledrejection',
        handled: false
      }
    });
  },

  /**
   * Installs the global promise rejection handler.
   *
   * @return {raven}
   */
  _attachPromiseRejectionHandler: function() {
    this._promiseRejectionHandler = this._promiseRejectionHandler.bind(this);
    _window.addEventListener &&
      _window.addEventListener('unhandledrejection', this._promiseRejectionHandler);
    return this;
  },

  /**
   * Uninstalls the global promise rejection handler.
   *
   * @return {raven}
   */
  _detachPromiseRejectionHandler: function() {
    _window.removeEventListener &&
      _window.removeEventListener('unhandledrejection', this._promiseRejectionHandler);
    return this;
  },

  /**
   * Manually capture an exception and send it over to Sentry
   *
   * @param {error} ex An exception to be logged
   * @param {object} options A specific set of options for this error [optional]
   * @return {Raven}
   */
  captureException: function(ex, options) {
    options = objectMerge({trimHeadFrames: 0}, options ? options : {});

    if (isErrorEvent(ex) && ex.error) {
      // If it is an ErrorEvent with `error` property, extract it to get actual Error
      ex = ex.error;
    } else if (isDOMError(ex) || isDOMException(ex)) {
      // If it is a DOMError or DOMException (which are legacy APIs, but still supported in some browsers)
      // then we just extract the name and message, as they don't provide anything else
      // https://developer.mozilla.org/en-US/docs/Web/API/DOMError
      // https://developer.mozilla.org/en-US/docs/Web/API/DOMException
      var name = ex.name || (isDOMError(ex) ? 'DOMError' : 'DOMException');
      var message = ex.message ? name + ': ' + ex.message : name;

      return this.captureMessage(
        message,
        objectMerge(options, {
          // neither DOMError or DOMException provide stack trace and we most likely wont get it this way as well
          // but it's barely any overhead so we may at least try
          stacktrace: true,
          trimHeadFrames: options.trimHeadFrames + 1
        })
      );
    } else if (isError(ex)) {
      // we have a real Error object
      ex = ex;
    } else if (isPlainObject(ex)) {
      // If it is plain Object, serialize it manually and extract options
      // This will allow us to group events based on top-level keys
      // which is much better than creating new group when any key/value change
      options = this._getCaptureExceptionOptionsFromPlainObject(options, ex);
      ex = new Error(options.message);
    } else {
      // If none of previous checks were valid, then it means that
      // it's not a DOMError/DOMException
      // it's not a plain Object
      // it's not a valid ErrorEvent (one with an error property)
      // it's not an Error
      // So bail out and capture it as a simple message:
      return this.captureMessage(
        ex,
        objectMerge(options, {
          stacktrace: true, // if we fall back to captureMessage, default to attempting a new trace
          trimHeadFrames: options.trimHeadFrames + 1
        })
      );
    }

    // Store the raw exception object for potential debugging and introspection
    this._lastCapturedException = ex;

    // TraceKit.report will re-raise any exception passed to it,
    // which means you have to wrap it in try/catch. Instead, we
    // can wrap it here and only re-raise if TraceKit.report
    // raises an exception different from the one we asked to
    // report on.
    try {
      var stack = TraceKit.computeStackTrace(ex);
      this._handleStackInfo(stack, options);
    } catch (ex1) {
      if (ex !== ex1) {
        throw ex1;
      }
    }

    return this;
  },

  _getCaptureExceptionOptionsFromPlainObject: function(currentOptions, ex) {
    var exKeys = Object.keys(ex).sort();
    var options = objectMerge(currentOptions, {
      message:
        'Non-Error exception captured with keys: ' + serializeKeysForMessage(exKeys),
      fingerprint: [md5(exKeys)],
      extra: currentOptions.extra || {}
    });
    options.extra.__serialized__ = serializeException(ex);

    return options;
  },

  /*
     * Manually send a message to Sentry
     *
     * @param {string} msg A plain message to be captured in Sentry
     * @param {object} options A specific set of options for this message [optional]
     * @return {Raven}
     */
  captureMessage: function(msg, options) {
    // config() automagically converts ignoreErrors from a list to a RegExp so we need to test for an
    // early call; we'll error on the side of logging anything called before configuration since it's
    // probably something you should see:
    if (
      !!this._globalOptions.ignoreErrors.test &&
      this._globalOptions.ignoreErrors.test(msg)
    ) {
      return;
    }

    options = options || {};
    msg = msg + ''; // Make sure it's actually a string

    var data = objectMerge(
      {
        message: msg
      },
      options
    );

    var ex;
    // Generate a "synthetic" stack trace from this point.
    // NOTE: If you are a Sentry user, and you are seeing this stack frame, it is NOT indicative
    //       of a bug with Raven.js. Sentry generates synthetic traces either by configuration,
    //       or if it catches a thrown object without a "stack" property.
    try {
      throw new Error(msg);
    } catch (ex1) {
      ex = ex1;
    }

    // null exception name so `Error` isn't prefixed to msg
    ex.name = null;
    var stack = TraceKit.computeStackTrace(ex);

    // stack[0] is `throw new Error(msg)` call itself, we are interested in the frame that was just before that, stack[1]
    var initialCall = isArray(stack.stack) && stack.stack[1];

    // if stack[1] is `Raven.captureException`, it means that someone passed a string to it and we redirected that call
    // to be handled by `captureMessage`, thus `initialCall` is the 3rd one, not 2nd
    // initialCall => captureException(string) => captureMessage(string)
    if (initialCall && initialCall.func === 'Raven.captureException') {
      initialCall = stack.stack[2];
    }

    var fileurl = (initialCall && initialCall.url) || '';

    if (
      !!this._globalOptions.ignoreUrls.test &&
      this._globalOptions.ignoreUrls.test(fileurl)
    ) {
      return;
    }

    if (
      !!this._globalOptions.whitelistUrls.test &&
      !this._globalOptions.whitelistUrls.test(fileurl)
    ) {
      return;
    }

    if (this._globalOptions.stacktrace || (options && options.stacktrace)) {
      // fingerprint on msg, not stack trace (legacy behavior, could be revisited)
      data.fingerprint = data.fingerprint == null ? msg : data.fingerprint;

      options = objectMerge(
        {
          trimHeadFrames: 0
        },
        options
      );
      // Since we know this is a synthetic trace, the top frame (this function call)
      // MUST be from Raven.js, so mark it for trimming
      // We add to the trim counter so that callers can choose to trim extra frames, such
      // as utility functions.
      options.trimHeadFrames += 1;

      var frames = this._prepareFrames(stack, options);
      data.stacktrace = {
        // Sentry expects frames oldest to newest
        frames: frames.reverse()
      };
    }

    // Make sure that fingerprint is always wrapped in an array
    if (data.fingerprint) {
      data.fingerprint = isArray(data.fingerprint)
        ? data.fingerprint
        : [data.fingerprint];
    }

    // Fire away!
    this._send(data);

    return this;
  },

  captureBreadcrumb: function(obj) {
    var crumb = objectMerge(
      {
        timestamp: now() / 1000
      },
      obj
    );

    if (isFunction(this._globalOptions.breadcrumbCallback)) {
      var result = this._globalOptions.breadcrumbCallback(crumb);

      if (isObject(result) && !isEmptyObject(result)) {
        crumb = result;
      } else if (result === false) {
        return this;
      }
    }

    this._breadcrumbs.push(crumb);
    if (this._breadcrumbs.length > this._globalOptions.maxBreadcrumbs) {
      this._breadcrumbs.shift();
    }
    return this;
  },

  addPlugin: function(plugin /*arg1, arg2, ... argN*/) {
    var pluginArgs = [].slice.call(arguments, 1);

    this._plugins.push([plugin, pluginArgs]);
    if (this._isRavenInstalled) {
      this._drainPlugins();
    }

    return this;
  },

  /*
     * Set/clear a user to be sent along with the payload.
     *
     * @param {object} user An object representing user data [optional]
     * @return {Raven}
     */
  setUserContext: function(user) {
    // Intentionally do not merge here since that's an unexpected behavior.
    this._globalContext.user = user;

    return this;
  },

  /*
     * Merge extra attributes to be sent along with the payload.
     *
     * @param {object} extra An object representing extra data [optional]
     * @return {Raven}
     */
  setExtraContext: function(extra) {
    this._mergeContext('extra', extra);

    return this;
  },

  /*
     * Merge tags to be sent along with the payload.
     *
     * @param {object} tags An object representing tags [optional]
     * @return {Raven}
     */
  setTagsContext: function(tags) {
    this._mergeContext('tags', tags);

    return this;
  },

  /*
     * Clear all of the context.
     *
     * @return {Raven}
     */
  clearContext: function() {
    this._globalContext = {};

    return this;
  },

  /*
     * Get a copy of the current context. This cannot be mutated.
     *
     * @return {object} copy of context
     */
  getContext: function() {
    // lol javascript
    return JSON.parse(stringify(this._globalContext));
  },

  /*
     * Set environment of application
     *
     * @param {string} environment Typically something like 'production'.
     * @return {Raven}
     */
  setEnvironment: function(environment) {
    this._globalOptions.environment = environment;

    return this;
  },

  /*
     * Set release version of application
     *
     * @param {string} release Typically something like a git SHA to identify version
     * @return {Raven}
     */
  setRelease: function(release) {
    this._globalOptions.release = release;

    return this;
  },

  /*
     * Set the dataCallback option
     *
     * @param {function} callback The callback to run which allows the
     *                            data blob to be mutated before sending
     * @return {Raven}
     */
  setDataCallback: function(callback) {
    var original = this._globalOptions.dataCallback;
    this._globalOptions.dataCallback = keepOriginalCallback(original, callback);
    return this;
  },

  /*
     * Set the breadcrumbCallback option
     *
     * @param {function} callback The callback to run which allows filtering
     *                            or mutating breadcrumbs
     * @return {Raven}
     */
  setBreadcrumbCallback: function(callback) {
    var original = this._globalOptions.breadcrumbCallback;
    this._globalOptions.breadcrumbCallback = keepOriginalCallback(original, callback);
    return this;
  },

  /*
     * Set the shouldSendCallback option
     *
     * @param {function} callback The callback to run which allows
     *                            introspecting the blob before sending
     * @return {Raven}
     */
  setShouldSendCallback: function(callback) {
    var original = this._globalOptions.shouldSendCallback;
    this._globalOptions.shouldSendCallback = keepOriginalCallback(original, callback);
    return this;
  },

  /**
   * Override the default HTTP transport mechanism that transmits data
   * to the Sentry server.
   *
   * @param {function} transport Function invoked instead of the default
   *                             `makeRequest` handler.
   *
   * @return {Raven}
   */
  setTransport: function(transport) {
    this._globalOptions.transport = transport;

    return this;
  },

  /*
     * Get the latest raw exception that was captured by Raven.
     *
     * @return {error}
     */
  lastException: function() {
    return this._lastCapturedException;
  },

  /*
     * Get the last event id
     *
     * @return {string}
     */
  lastEventId: function() {
    return this._lastEventId;
  },

  /*
     * Determine if Raven is setup and ready to go.
     *
     * @return {boolean}
     */
  isSetup: function() {
    if (!this._hasJSON) return false; // needs JSON support
    if (!this._globalServer) {
      if (!this.ravenNotConfiguredError) {
        this.ravenNotConfiguredError = true;
        this._logDebug('error', 'Error: Raven has not been configured.');
      }
      return false;
    }
    return true;
  },

  afterLoad: function() {
    // TODO: remove window dependence?

    // Attempt to initialize Raven on load
    var RavenConfig = _window.RavenConfig;
    if (RavenConfig) {
      this.config(RavenConfig.dsn, RavenConfig.config).install();
    }
  },

  showReportDialog: function(options) {
    if (
      !_document // doesn't work without a document (React native)
    )
      return;

    options = options || {};

    var lastEventId = options.eventId || this.lastEventId();
    if (!lastEventId) {
      throw new RavenConfigError('Missing eventId');
    }

    var dsn = options.dsn || this._dsn;
    if (!dsn) {
      throw new RavenConfigError('Missing DSN');
    }

    var encode = encodeURIComponent;
    var qs = '';
    qs += '?eventId=' + encode(lastEventId);
    qs += '&dsn=' + encode(dsn);

    var user = options.user || this._globalContext.user;
    if (user) {
      if (user.name) qs += '&name=' + encode(user.name);
      if (user.email) qs += '&email=' + encode(user.email);
    }

    var globalServer = this._getGlobalServer(this._parseDSN(dsn));

    var script = _document.createElement('script');
    script.async = true;
    script.src = globalServer + '/api/embed/error-page/' + qs;
    (_document.head || _document.body).appendChild(script);
  },

  /**** Private functions ****/
  _ignoreNextOnError: function() {
    var self = this;
    this._ignoreOnError += 1;
    setTimeout(function() {
      // onerror should trigger before setTimeout
      self._ignoreOnError -= 1;
    });
  },

  _triggerEvent: function(eventType, options) {
    // NOTE: `event` is a native browser thing, so let's avoid conflicting wiht it
    var evt, key;

    if (!this._hasDocument) return;

    options = options || {};

    eventType = 'raven' + eventType.substr(0, 1).toUpperCase() + eventType.substr(1);

    if (_document.createEvent) {
      evt = _document.createEvent('HTMLEvents');
      evt.initEvent(eventType, true, true);
    } else {
      evt = _document.createEventObject();
      evt.eventType = eventType;
    }

    for (key in options)
      if (hasKey(options, key)) {
        evt[key] = options[key];
      }

    if (_document.createEvent) {
      // IE9 if standards
      _document.dispatchEvent(evt);
    } else {
      // IE8 regardless of Quirks or Standards
      // IE9 if quirks
      try {
        _document.fireEvent('on' + evt.eventType.toLowerCase(), evt);
      } catch (e) {
        // Do nothing
      }
    }
  },

  /**
   * Wraps addEventListener to capture UI breadcrumbs
   * @param evtName the event name (e.g. "click")
   * @returns {Function}
   * @private
   */
  _breadcrumbEventHandler: function(evtName) {
    var self = this;
    return function(evt) {
      // reset keypress timeout; e.g. triggering a 'click' after
      // a 'keypress' will reset the keypress debounce so that a new
      // set of keypresses can be recorded
      self._keypressTimeout = null;

      // It's possible this handler might trigger multiple times for the same
      // event (e.g. event propagation through node ancestors). Ignore if we've
      // already captured the event.
      if (self._lastCapturedEvent === evt) return;

      self._lastCapturedEvent = evt;

      // try/catch both:
      // - accessing evt.target (see getsentry/raven-js#838, #768)
      // - `htmlTreeAsString` because it's complex, and just accessing the DOM incorrectly
      //   can throw an exception in some circumstances.
      var target;
      try {
        target = htmlTreeAsString(evt.target);
      } catch (e) {
        target = '<unknown>';
      }

      self.captureBreadcrumb({
        category: 'ui.' + evtName, // e.g. ui.click, ui.input
        message: target
      });
    };
  },

  /**
   * Wraps addEventListener to capture keypress UI events
   * @returns {Function}
   * @private
   */
  _keypressEventHandler: function() {
    var self = this,
      debounceDuration = 1000; // milliseconds

    // TODO: if somehow user switches keypress target before
    //       debounce timeout is triggered, we will only capture
    //       a single breadcrumb from the FIRST target (acceptable?)
    return function(evt) {
      var target;
      try {
        target = evt.target;
      } catch (e) {
        // just accessing event properties can throw an exception in some rare circumstances
        // see: https://github.com/getsentry/raven-js/issues/838
        return;
      }
      var tagName = target && target.tagName;

      // only consider keypress events on actual input elements
      // this will disregard keypresses targeting body (e.g. tabbing
      // through elements, hotkeys, etc)
      if (
        !tagName ||
        (tagName !== 'INPUT' && tagName !== 'TEXTAREA' && !target.isContentEditable)
      )
        return;

      // record first keypress in a series, but ignore subsequent
      // keypresses until debounce clears
      var timeout = self._keypressTimeout;
      if (!timeout) {
        self._breadcrumbEventHandler('input')(evt);
      }
      clearTimeout(timeout);
      self._keypressTimeout = setTimeout(function() {
        self._keypressTimeout = null;
      }, debounceDuration);
    };
  },

  /**
   * Captures a breadcrumb of type "navigation", normalizing input URLs
   * @param to the originating URL
   * @param from the target URL
   * @private
   */
  _captureUrlChange: function(from, to) {
    var parsedLoc = parseUrl(this._location.href);
    var parsedTo = parseUrl(to);
    var parsedFrom = parseUrl(from);

    // because onpopstate only tells you the "new" (to) value of location.href, and
    // not the previous (from) value, we need to track the value of the current URL
    // state ourselves
    this._lastHref = to;

    // Use only the path component of the URL if the URL matches the current
    // document (almost all the time when using pushState)
    if (parsedLoc.protocol === parsedTo.protocol && parsedLoc.host === parsedTo.host)
      to = parsedTo.relative;
    if (parsedLoc.protocol === parsedFrom.protocol && parsedLoc.host === parsedFrom.host)
      from = parsedFrom.relative;

    this.captureBreadcrumb({
      category: 'navigation',
      data: {
        to: to,
        from: from
      }
    });
  },

  _patchFunctionToString: function() {
    var self = this;
    self._originalFunctionToString = Function.prototype.toString;
    // eslint-disable-next-line no-extend-native
    Function.prototype.toString = function() {
      if (typeof this === 'function' && this.__raven__) {
        return self._originalFunctionToString.apply(this.__orig__, arguments);
      }
      return self._originalFunctionToString.apply(this, arguments);
    };
  },

  _unpatchFunctionToString: function() {
    if (this._originalFunctionToString) {
      // eslint-disable-next-line no-extend-native
      Function.prototype.toString = this._originalFunctionToString;
    }
  },

  /**
   * Wrap timer functions and event targets to catch errors and provide
   * better metadata.
   */
  _instrumentTryCatch: function() {
    var self = this;

    var wrappedBuiltIns = self._wrappedBuiltIns;

    function wrapTimeFn(orig) {
      return function(fn, t) {
        // preserve arity
        // Make a copy of the arguments to prevent deoptimization
        // https://github.com/petkaantonov/bluebird/wiki/Optimization-killers#32-leaking-arguments
        var args = new Array(arguments.length);
        for (var i = 0; i < args.length; ++i) {
          args[i] = arguments[i];
        }
        var originalCallback = args[0];
        if (isFunction(originalCallback)) {
          args[0] = self.wrap(
            {
              mechanism: {
                type: 'instrument',
                data: {function: orig.name || '<anonymous>'}
              }
            },
            originalCallback
          );
        }

        // IE < 9 doesn't support .call/.apply on setInterval/setTimeout, but it
        // also supports only two arguments and doesn't care what this is, so we
        // can just call the original function directly.
        if (orig.apply) {
          return orig.apply(this, args);
        } else {
          return orig(args[0], args[1]);
        }
      };
    }

    var autoBreadcrumbs = this._globalOptions.autoBreadcrumbs;

    function wrapEventTarget(global) {
      var proto = _window[global] && _window[global].prototype;
      if (proto && proto.hasOwnProperty && proto.hasOwnProperty('addEventListener')) {
        fill(
          proto,
          'addEventListener',
          function(orig) {
            return function(evtName, fn, capture, secure) {
              // preserve arity
              try {
                if (fn && fn.handleEvent) {
                  fn.handleEvent = self.wrap(
                    {
                      mechanism: {
                        type: 'instrument',
                        data: {
                          target: global,
                          function: 'handleEvent',
                          handler: (fn && fn.name) || '<anonymous>'
                        }
                      }
                    },
                    fn.handleEvent
                  );
                }
              } catch (err) {
                // can sometimes get 'Permission denied to access property "handle Event'
              }

              // More breadcrumb DOM capture ... done here and not in `_instrumentBreadcrumbs`
              // so that we don't have more than one wrapper function
              var before, clickHandler, keypressHandler;

              if (
                autoBreadcrumbs &&
                autoBreadcrumbs.dom &&
                (global === 'EventTarget' || global === 'Node')
              ) {
                // NOTE: generating multiple handlers per addEventListener invocation, should
                //       revisit and verify we can just use one (almost certainly)
                clickHandler = self._breadcrumbEventHandler('click');
                keypressHandler = self._keypressEventHandler();
                before = function(evt) {
                  // need to intercept every DOM event in `before` argument, in case that
                  // same wrapped method is re-used for different events (e.g. mousemove THEN click)
                  // see #724
                  if (!evt) return;

                  var eventType;
                  try {
                    eventType = evt.type;
                  } catch (e) {
                    // just accessing event properties can throw an exception in some rare circumstances
                    // see: https://github.com/getsentry/raven-js/issues/838
                    return;
                  }
                  if (eventType === 'click') return clickHandler(evt);
                  else if (eventType === 'keypress') return keypressHandler(evt);
                };
              }
              return orig.call(
                this,
                evtName,
                self.wrap(
                  {
                    mechanism: {
                      type: 'instrument',
                      data: {
                        target: global,
                        function: 'addEventListener',
                        handler: (fn && fn.name) || '<anonymous>'
                      }
                    }
                  },
                  fn,
                  before
                ),
                capture,
                secure
              );
            };
          },
          wrappedBuiltIns
        );
        fill(
          proto,
          'removeEventListener',
          function(orig) {
            return function(evt, fn, capture, secure) {
              try {
                fn = fn && (fn.__raven_wrapper__ ? fn.__raven_wrapper__ : fn);
              } catch (e) {
                // ignore, accessing __raven_wrapper__ will throw in some Selenium environments
              }
              return orig.call(this, evt, fn, capture, secure);
            };
          },
          wrappedBuiltIns
        );
      }
    }

    fill(_window, 'setTimeout', wrapTimeFn, wrappedBuiltIns);
    fill(_window, 'setInterval', wrapTimeFn, wrappedBuiltIns);
    if (_window.requestAnimationFrame) {
      fill(
        _window,
        'requestAnimationFrame',
        function(orig) {
          return function(cb) {
            return orig(
              self.wrap(
                {
                  mechanism: {
                    type: 'instrument',
                    data: {
                      function: 'requestAnimationFrame',
                      handler: (orig && orig.name) || '<anonymous>'
                    }
                  }
                },
                cb
              )
            );
          };
        },
        wrappedBuiltIns
      );
    }

    // event targets borrowed from bugsnag-js:
    // https://github.com/bugsnag/bugsnag-js/blob/master/src/bugsnag.js#L666
    var eventTargets = [
      'EventTarget',
      'Window',
      'Node',
      'ApplicationCache',
      'AudioTrackList',
      'ChannelMergerNode',
      'CryptoOperation',
      'EventSource',
      'FileReader',
      'HTMLUnknownElement',
      'IDBDatabase',
      'IDBRequest',
      'IDBTransaction',
      'KeyOperation',
      'MediaController',
      'MessagePort',
      'ModalWindow',
      'Notification',
      'SVGElementInstance',
      'Screen',
      'TextTrack',
      'TextTrackCue',
      'TextTrackList',
      'WebSocket',
      'WebSocketWorker',
      'Worker',
      'XMLHttpRequest',
      'XMLHttpRequestEventTarget',
      'XMLHttpRequestUpload'
    ];
    for (var i = 0; i < eventTargets.length; i++) {
      wrapEventTarget(eventTargets[i]);
    }
  },

  /**
   * Instrument browser built-ins w/ breadcrumb capturing
   *  - XMLHttpRequests
   *  - DOM interactions (click/typing)
   *  - window.location changes
   *  - console
   *
   * Can be disabled or individually configured via the `autoBreadcrumbs` config option
   */
  _instrumentBreadcrumbs: function() {
    var self = this;
    var autoBreadcrumbs = this._globalOptions.autoBreadcrumbs;

    var wrappedBuiltIns = self._wrappedBuiltIns;

    function wrapProp(prop, xhr) {
      if (prop in xhr && isFunction(xhr[prop])) {
        fill(xhr, prop, function(orig) {
          return self.wrap(
            {
              mechanism: {
                type: 'instrument',
                data: {function: prop, handler: (orig && orig.name) || '<anonymous>'}
              }
            },
            orig
          );
        }); // intentionally don't track filled methods on XHR instances
      }
    }

    if (autoBreadcrumbs.xhr && 'XMLHttpRequest' in _window) {
      var xhrproto = _window.XMLHttpRequest && _window.XMLHttpRequest.prototype;
      fill(
        xhrproto,
        'open',
        function(origOpen) {
          return function(method, url) {
            // preserve arity

            // if Sentry key appears in URL, don't capture
            if (isString(url) && url.indexOf(self._globalKey) === -1) {
              this.__raven_xhr = {
                method: method,
                url: url,
                status_code: null
              };
            }

            return origOpen.apply(this, arguments);
          };
        },
        wrappedBuiltIns
      );

      fill(
        xhrproto,
        'send',
        function(origSend) {
          return function() {
            // preserve arity
            var xhr = this;

            function onreadystatechangeHandler() {
              if (xhr.__raven_xhr && xhr.readyState === 4) {
                try {
                  // touching statusCode in some platforms throws
                  // an exception
                  xhr.__raven_xhr.status_code = xhr.status;
                } catch (e) {
                  /* do nothing */
                }

                self.captureBreadcrumb({
                  type: 'http',
                  category: 'xhr',
                  data: xhr.__raven_xhr
                });
              }
            }

            var props = ['onload', 'onerror', 'onprogress'];
            for (var j = 0; j < props.length; j++) {
              wrapProp(props[j], xhr);
            }

            if ('onreadystatechange' in xhr && isFunction(xhr.onreadystatechange)) {
              fill(
                xhr,
                'onreadystatechange',
                function(orig) {
                  return self.wrap(
                    {
                      mechanism: {
                        type: 'instrument',
                        data: {
                          function: 'onreadystatechange',
                          handler: (orig && orig.name) || '<anonymous>'
                        }
                      }
                    },
                    orig,
                    onreadystatechangeHandler
                  );
                } /* intentionally don't track this instrumentation */
              );
            } else {
              // if onreadystatechange wasn't actually set by the page on this xhr, we
              // are free to set our own and capture the breadcrumb
              xhr.onreadystatechange = onreadystatechangeHandler;
            }

            return origSend.apply(this, arguments);
          };
        },
        wrappedBuiltIns
      );
    }

    if (autoBreadcrumbs.xhr && supportsFetch()) {
      fill(
        _window,
        'fetch',
        function(origFetch) {
          return function() {
            // preserve arity
            // Make a copy of the arguments to prevent deoptimization
            // https://github.com/petkaantonov/bluebird/wiki/Optimization-killers#32-leaking-arguments
            var args = new Array(arguments.length);
            for (var i = 0; i < args.length; ++i) {
              args[i] = arguments[i];
            }

            var fetchInput = args[0];
            var method = 'GET';
            var url;

            if (typeof fetchInput === 'string') {
              url = fetchInput;
            } else if ('Request' in _window && fetchInput instanceof _window.Request) {
              url = fetchInput.url;
              if (fetchInput.method) {
                method = fetchInput.method;
              }
            } else {
              url = '' + fetchInput;
            }

            // if Sentry key appears in URL, don't capture, as it's our own request
            if (url.indexOf(self._globalKey) !== -1) {
              return origFetch.apply(this, args);
            }

            if (args[1] && args[1].method) {
              method = args[1].method;
            }

            var fetchData = {
              method: method,
              url: url,
              status_code: null
            };

            return origFetch
              .apply(this, args)
              .then(function(response) {
                fetchData.status_code = response.status;

                self.captureBreadcrumb({
                  type: 'http',
                  category: 'fetch',
                  data: fetchData
                });

                return response;
              })
              ['catch'](function(err) {
                // if there is an error performing the request
                self.captureBreadcrumb({
                  type: 'http',
                  category: 'fetch',
                  data: fetchData,
                  level: 'error'
                });

                throw err;
              });
          };
        },
        wrappedBuiltIns
      );
    }

    // Capture breadcrumbs from any click that is unhandled / bubbled up all the way
    // to the document. Do this before we instrument addEventListener.
    if (autoBreadcrumbs.dom && this._hasDocument) {
      if (_document.addEventListener) {
        _document.addEventListener('click', self._breadcrumbEventHandler('click'), false);
        _document.addEventListener('keypress', self._keypressEventHandler(), false);
      } else if (_document.attachEvent) {
        // IE8 Compatibility
        _document.attachEvent('onclick', self._breadcrumbEventHandler('click'));
        _document.attachEvent('onkeypress', self._keypressEventHandler());
      }
    }

    // record navigation (URL) changes
    // NOTE: in Chrome App environment, touching history.pushState, *even inside
    //       a try/catch block*, will cause Chrome to output an error to console.error
    // borrowed from: https://github.com/angular/angular.js/pull/13945/files
    var chrome = _window.chrome;
    var isChromePackagedApp = chrome && chrome.app && chrome.app.runtime;
    var hasPushAndReplaceState =
      !isChromePackagedApp &&
      _window.history &&
      _window.history.pushState &&
      _window.history.replaceState;
    if (autoBreadcrumbs.location && hasPushAndReplaceState) {
      // TODO: remove onpopstate handler on uninstall()
      var oldOnPopState = _window.onpopstate;
      _window.onpopstate = function() {
        var currentHref = self._location.href;
        self._captureUrlChange(self._lastHref, currentHref);

        if (oldOnPopState) {
          return oldOnPopState.apply(this, arguments);
        }
      };

      var historyReplacementFunction = function(origHistFunction) {
        // note history.pushState.length is 0; intentionally not declaring
        // params to preserve 0 arity
        return function(/* state, title, url */) {
          var url = arguments.length > 2 ? arguments[2] : undefined;

          // url argument is optional
          if (url) {
            // coerce to string (this is what pushState does)
            self._captureUrlChange(self._lastHref, url + '');
          }

          return origHistFunction.apply(this, arguments);
        };
      };

      fill(_window.history, 'pushState', historyReplacementFunction, wrappedBuiltIns);
      fill(_window.history, 'replaceState', historyReplacementFunction, wrappedBuiltIns);
    }

    if (autoBreadcrumbs.console && 'console' in _window && console.log) {
      // console
      var consoleMethodCallback = function(msg, data) {
        self.captureBreadcrumb({
          message: msg,
          level: data.level,
          category: 'console'
        });
      };

      each(['debug', 'info', 'warn', 'error', 'log'], function(_, level) {
        wrapConsoleMethod(console, level, consoleMethodCallback);
      });
    }
  },

  _restoreBuiltIns: function() {
    // restore any wrapped builtins
    var builtin;
    while (this._wrappedBuiltIns.length) {
      builtin = this._wrappedBuiltIns.shift();

      var obj = builtin[0],
        name = builtin[1],
        orig = builtin[2];

      obj[name] = orig;
    }
  },

  _restoreConsole: function() {
    // eslint-disable-next-line guard-for-in
    for (var method in this._originalConsoleMethods) {
      this._originalConsole[method] = this._originalConsoleMethods[method];
    }
  },

  _drainPlugins: function() {
    var self = this;

    // FIX ME TODO
    each(this._plugins, function(_, plugin) {
      var installer = plugin[0];
      var args = plugin[1];
      installer.apply(self, [self].concat(args));
    });
  },

  _parseDSN: function(str) {
    var m = dsnPattern.exec(str),
      dsn = {},
      i = 7;

    try {
      while (i--) dsn[dsnKeys[i]] = m[i] || '';
    } catch (e) {
      throw new RavenConfigError('Invalid DSN: ' + str);
    }

    if (dsn.pass && !this._globalOptions.allowSecretKey) {
      throw new RavenConfigError(
        'Do not specify your secret key in the DSN. See: http://bit.ly/raven-secret-key'
      );
    }

    return dsn;
  },

  _getGlobalServer: function(uri) {
    // assemble the endpoint from the uri pieces
    var globalServer = '//' + uri.host + (uri.port ? ':' + uri.port : '');

    if (uri.protocol) {
      globalServer = uri.protocol + ':' + globalServer;
    }
    return globalServer;
  },

  _handleOnErrorStackInfo: function(stackInfo, options) {
    options = options || {};
    options.mechanism = options.mechanism || {
      type: 'onerror',
      handled: false
    };

    // if we are intentionally ignoring errors via onerror, bail out
    if (!this._ignoreOnError) {
      this._handleStackInfo(stackInfo, options);
    }
  },

  _handleStackInfo: function(stackInfo, options) {
    var frames = this._prepareFrames(stackInfo, options);

    this._triggerEvent('handle', {
      stackInfo: stackInfo,
      options: options
    });

    this._processException(
      stackInfo.name,
      stackInfo.message,
      stackInfo.url,
      stackInfo.lineno,
      frames,
      options
    );
  },

  _prepareFrames: function(stackInfo, options) {
    var self = this;
    var frames = [];
    if (stackInfo.stack && stackInfo.stack.length) {
      each(stackInfo.stack, function(i, stack) {
        var frame = self._normalizeFrame(stack, stackInfo.url);
        if (frame) {
          frames.push(frame);
        }
      });

      // e.g. frames captured via captureMessage throw
      if (options && options.trimHeadFrames) {
        for (var j = 0; j < options.trimHeadFrames && j < frames.length; j++) {
          frames[j].in_app = false;
        }
      }
    }
    frames = frames.slice(0, this._globalOptions.stackTraceLimit);
    return frames;
  },

  _normalizeFrame: function(frame, stackInfoUrl) {
    // normalize the frames data
    var normalized = {
      filename: frame.url,
      lineno: frame.line,
      colno: frame.column,
      function: frame.func || '?'
    };

    // Case when we don't have any information about the error
    // E.g. throwing a string or raw object, instead of an `Error` in Firefox
    // Generating synthetic error doesn't add any value here
    //
    // We should probably somehow let a user know that they should fix their code
    if (!frame.url) {
      normalized.filename = stackInfoUrl; // fallback to whole stacks url from onerror handler
    }

    normalized.in_app = !// determine if an exception came from outside of our app
    // first we check the global includePaths list.
    (
      (!!this._globalOptions.includePaths.test &&
        !this._globalOptions.includePaths.test(normalized.filename)) ||
      // Now we check for fun, if the function name is Raven or TraceKit
      /(Raven|TraceKit)\./.test(normalized['function']) ||
      // finally, we do a last ditch effort and check for raven.min.js
      /raven\.(min\.)?js$/.test(normalized.filename)
    );

    return normalized;
  },

  _processException: function(type, message, fileurl, lineno, frames, options) {
    var prefixedMessage = (type ? type + ': ' : '') + (message || '');
    if (
      !!this._globalOptions.ignoreErrors.test &&
      (this._globalOptions.ignoreErrors.test(message) ||
        this._globalOptions.ignoreErrors.test(prefixedMessage))
    ) {
      return;
    }

    var stacktrace;

    if (frames && frames.length) {
      fileurl = frames[0].filename || fileurl;
      // Sentry expects frames oldest to newest
      // and JS sends them as newest to oldest
      frames.reverse();
      stacktrace = {frames: frames};
    } else if (fileurl) {
      stacktrace = {
        frames: [
          {
            filename: fileurl,
            lineno: lineno,
            in_app: true
          }
        ]
      };
    }

    if (
      !!this._globalOptions.ignoreUrls.test &&
      this._globalOptions.ignoreUrls.test(fileurl)
    ) {
      return;
    }

    if (
      !!this._globalOptions.whitelistUrls.test &&
      !this._globalOptions.whitelistUrls.test(fileurl)
    ) {
      return;
    }

    var data = objectMerge(
      {
        // sentry.interfaces.Exception
        exception: {
          values: [
            {
              type: type,
              value: message,
              stacktrace: stacktrace
            }
          ]
        },
        transaction: fileurl
      },
      options
    );

    // Move mechanism from options to exception interface
    // We do this, as requiring user to pass `{exception:{mechanism:{ ... }}}` would be
    // too much
    if (!data.exception.mechanism && data.mechanism) {
      data.exception.mechanism = data.mechanism;
      delete data.mechanism;
    }

    data.exception.mechanism = objectMerge(
      {
        type: 'generic',
        handled: true
      },
      data.exception.mechanism || {}
    );

    // Fire away!
    this._send(data);
  },

  _trimPacket: function(data) {
    // For now, we only want to truncate the two different messages
    // but this could/should be expanded to just trim everything
    var max = this._globalOptions.maxMessageLength;
    if (data.message) {
      data.message = truncate(data.message, max);
    }
    if (data.exception) {
      var exception = data.exception.values[0];
      exception.value = truncate(exception.value, max);
    }

    var request = data.request;
    if (request) {
      if (request.url) {
        request.url = truncate(request.url, this._globalOptions.maxUrlLength);
      }
      if (request.Referer) {
        request.Referer = truncate(request.Referer, this._globalOptions.maxUrlLength);
      }
    }

    if (data.breadcrumbs && data.breadcrumbs.values)
      this._trimBreadcrumbs(data.breadcrumbs);

    return data;
  },

  /**
   * Truncate breadcrumb values (right now just URLs)
   */
  _trimBreadcrumbs: function(breadcrumbs) {
    // known breadcrumb properties with urls
    // TODO: also consider arbitrary prop values that start with (https?)?://
    var urlProps = ['to', 'from', 'url'],
      urlProp,
      crumb,
      data;

    for (var i = 0; i < breadcrumbs.values.length; ++i) {
      crumb = breadcrumbs.values[i];
      if (
        !crumb.hasOwnProperty('data') ||
        !isObject(crumb.data) ||
        objectFrozen(crumb.data)
      )
        continue;

      data = objectMerge({}, crumb.data);
      for (var j = 0; j < urlProps.length; ++j) {
        urlProp = urlProps[j];
        if (data.hasOwnProperty(urlProp) && data[urlProp]) {
          data[urlProp] = truncate(data[urlProp], this._globalOptions.maxUrlLength);
        }
      }
      breadcrumbs.values[i].data = data;
    }
  },

  _getHttpData: function() {
    if (!this._hasNavigator && !this._hasDocument) return;
    var httpData = {};

    if (this._hasNavigator && _navigator.userAgent) {
      httpData.headers = {
        'User-Agent': _navigator.userAgent
      };
    }

    // Check in `window` instead of `document`, as we may be in ServiceWorker environment
    if (_window.location && _window.location.href) {
      httpData.url = _window.location.href;
    }

    if (this._hasDocument && _document.referrer) {
      if (!httpData.headers) httpData.headers = {};
      httpData.headers.Referer = _document.referrer;
    }

    return httpData;
  },

  _resetBackoff: function() {
    this._backoffDuration = 0;
    this._backoffStart = null;
  },

  _shouldBackoff: function() {
    return this._backoffDuration && now() - this._backoffStart < this._backoffDuration;
  },

  /**
   * Returns true if the in-process data payload matches the signature
   * of the previously-sent data
   *
   * NOTE: This has to be done at this level because TraceKit can generate
   *       data from window.onerror WITHOUT an exception object (IE8, IE9,
   *       other old browsers). This can take the form of an "exception"
   *       data object with a single frame (derived from the onerror args).
   */
  _isRepeatData: function(current) {
    var last = this._lastData;

    if (
      !last ||
      current.message !== last.message || // defined for captureMessage
      current.transaction !== last.transaction // defined for captureException/onerror
    )
      return false;

    // Stacktrace interface (i.e. from captureMessage)
    if (current.stacktrace || last.stacktrace) {
      return isSameStacktrace(current.stacktrace, last.stacktrace);
    } else if (current.exception || last.exception) {
      // Exception interface (i.e. from captureException/onerror)
      return isSameException(current.exception, last.exception);
    }

    return true;
  },

  _setBackoffState: function(request) {
    // If we are already in a backoff state, don't change anything
    if (this._shouldBackoff()) {
      return;
    }

    var status = request.status;

    // 400 - project_id doesn't exist or some other fatal
    // 401 - invalid/revoked dsn
    // 429 - too many requests
    if (!(status === 400 || status === 401 || status === 429)) return;

    var retry;
    try {
      // If Retry-After is not in Access-Control-Expose-Headers, most
      // browsers will throw an exception trying to access it
      if (supportsFetch()) {
        retry = request.headers.get('Retry-After');
      } else {
        retry = request.getResponseHeader('Retry-After');
      }

      // Retry-After is returned in seconds
      retry = parseInt(retry, 10) * 1000;
    } catch (e) {
      /* eslint no-empty:0 */
    }

    this._backoffDuration = retry
      ? // If Sentry server returned a Retry-After value, use it
        retry
      : // Otherwise, double the last backoff duration (starts at 1 sec)
        this._backoffDuration * 2 || 1000;

    this._backoffStart = now();
  },

  _send: function(data) {
    var globalOptions = this._globalOptions;

    var baseData = {
        project: this._globalProject,
        logger: globalOptions.logger,
        platform: 'javascript'
      },
      httpData = this._getHttpData();

    if (httpData) {
      baseData.request = httpData;
    }

    // HACK: delete `trimHeadFrames` to prevent from appearing in outbound payload
    if (data.trimHeadFrames) delete data.trimHeadFrames;

    data = objectMerge(baseData, data);

    // Merge in the tags and extra separately since objectMerge doesn't handle a deep merge
    data.tags = objectMerge(objectMerge({}, this._globalContext.tags), data.tags);
    data.extra = objectMerge(objectMerge({}, this._globalContext.extra), data.extra);

    // Send along our own collected metadata with extra
    data.extra['session:duration'] = now() - this._startTime;

    if (this._breadcrumbs && this._breadcrumbs.length > 0) {
      // intentionally make shallow copy so that additions
      // to breadcrumbs aren't accidentally sent in this request
      data.breadcrumbs = {
        values: [].slice.call(this._breadcrumbs, 0)
      };
    }

    if (this._globalContext.user) {
      // sentry.interfaces.User
      data.user = this._globalContext.user;
    }

    // Include the environment if it's defined in globalOptions
    if (globalOptions.environment) data.environment = globalOptions.environment;

    // Include the release if it's defined in globalOptions
    if (globalOptions.release) data.release = globalOptions.release;

    // Include server_name if it's defined in globalOptions
    if (globalOptions.serverName) data.server_name = globalOptions.serverName;

    data = this._sanitizeData(data);

    // Cleanup empty properties before sending them to the server
    Object.keys(data).forEach(function(key) {
      if (data[key] == null || data[key] === '' || isEmptyObject(data[key])) {
        delete data[key];
      }
    });

    if (isFunction(globalOptions.dataCallback)) {
      data = globalOptions.dataCallback(data) || data;
    }

    // Why??????????
    if (!data || isEmptyObject(data)) {
      return;
    }

    // Check if the request should be filtered or not
    if (
      isFunction(globalOptions.shouldSendCallback) &&
      !globalOptions.shouldSendCallback(data)
    ) {
      return;
    }

    // Backoff state: Sentry server previously responded w/ an error (e.g. 429 - too many requests),
    // so drop requests until "cool-off" period has elapsed.
    if (this._shouldBackoff()) {
      this._logDebug('warn', 'Raven dropped error due to backoff: ', data);
      return;
    }

    if (typeof globalOptions.sampleRate === 'number') {
      if (Math.random() < globalOptions.sampleRate) {
        this._sendProcessedPayload(data);
      }
    } else {
      this._sendProcessedPayload(data);
    }
  },

  _sanitizeData: function(data) {
    return sanitize(data, this._globalOptions.sanitizeKeys);
  },

  _getUuid: function() {
    return uuid4();
  },

  _sendProcessedPayload: function(data, callback) {
    var self = this;
    var globalOptions = this._globalOptions;

    if (!this.isSetup()) return;

    // Try and clean up the packet before sending by truncating long values
    data = this._trimPacket(data);

    // ideally duplicate error testing should occur *before* dataCallback/shouldSendCallback,
    // but this would require copying an un-truncated copy of the data packet, which can be
    // arbitrarily deep (extra_data) -- could be worthwhile? will revisit
    if (!this._globalOptions.allowDuplicates && this._isRepeatData(data)) {
      this._logDebug('warn', 'Raven dropped repeat event: ', data);
      return;
    }

    // Send along an event_id if not explicitly passed.
    // This event_id can be used to reference the error within Sentry itself.
    // Set lastEventId after we know the error should actually be sent
    this._lastEventId = data.event_id || (data.event_id = this._getUuid());

    // Store outbound payload after trim
    this._lastData = data;

    this._logDebug('debug', 'Raven about to send:', data);

    var auth = {
      sentry_version: '7',
      sentry_client: 'raven-js/' + this.VERSION,
      sentry_key: this._globalKey
    };

    if (this._globalSecret) {
      auth.sentry_secret = this._globalSecret;
    }

    var exception = data.exception && data.exception.values[0];

    // only capture 'sentry' breadcrumb is autoBreadcrumbs is truthy
    if (
      this._globalOptions.autoBreadcrumbs &&
      this._globalOptions.autoBreadcrumbs.sentry
    ) {
      this.captureBreadcrumb({
        category: 'sentry',
        message: exception
          ? (exception.type ? exception.type + ': ' : '') + exception.value
          : data.message,
        event_id: data.event_id,
        level: data.level || 'error' // presume error unless specified
      });
    }

    var url = this._globalEndpoint;
    (globalOptions.transport || this._makeRequest).call(this, {
      url: url,
      auth: auth,
      data: data,
      options: globalOptions,
      onSuccess: function success() {
        self._resetBackoff();

        self._triggerEvent('success', {
          data: data,
          src: url
        });
        callback && callback();
      },
      onError: function failure(error) {
        self._logDebug('error', 'Raven transport failed to send: ', error);

        if (error.request) {
          self._setBackoffState(error.request);
        }

        self._triggerEvent('failure', {
          data: data,
          src: url
        });
        error = error || new Error('Raven send failed (no additional details provided)');
        callback && callback(error);
      }
    });
  },

  _makeRequest: function(opts) {
    // Auth is intentionally sent as part of query string (NOT as custom HTTP header) to avoid preflight CORS requests
    var url = opts.url + '?' + urlencode(opts.auth);

    var evaluatedHeaders = null;
    var evaluatedFetchParameters = {};

    if (opts.options.headers) {
      evaluatedHeaders = this._evaluateHash(opts.options.headers);
    }

    if (opts.options.fetchParameters) {
      evaluatedFetchParameters = this._evaluateHash(opts.options.fetchParameters);
    }

    if (supportsFetch()) {
      evaluatedFetchParameters.body = stringify(opts.data);

      var defaultFetchOptions = objectMerge({}, this._fetchDefaults);
      var fetchOptions = objectMerge(defaultFetchOptions, evaluatedFetchParameters);

      if (evaluatedHeaders) {
        fetchOptions.headers = evaluatedHeaders;
      }

      return _window
        .fetch(url, fetchOptions)
        .then(function(response) {
          if (response.ok) {
            opts.onSuccess && opts.onSuccess();
          } else {
            var error = new Error('Sentry error code: ' + response.status);
            // It's called request only to keep compatibility with XHR interface
            // and not add more redundant checks in setBackoffState method
            error.request = response;
            opts.onError && opts.onError(error);
          }
        })
        ['catch'](function() {
          opts.onError &&
            opts.onError(new Error('Sentry error code: network unavailable'));
        });
    }

    var request = _window.XMLHttpRequest && new _window.XMLHttpRequest();
    if (!request) return;

    // if browser doesn't support CORS (e.g. IE7), we are out of luck
    var hasCORS = 'withCredentials' in request || typeof XDomainRequest !== 'undefined';

    if (!hasCORS) return;

    if ('withCredentials' in request) {
      request.onreadystatechange = function() {
        if (request.readyState !== 4) {
          return;
        } else if (request.status === 200) {
          opts.onSuccess && opts.onSuccess();
        } else if (opts.onError) {
          var err = new Error('Sentry error code: ' + request.status);
          err.request = request;
          opts.onError(err);
        }
      };
    } else {
      request = new XDomainRequest();
      // xdomainrequest cannot go http -> https (or vice versa),
      // so always use protocol relative
      url = url.replace(/^https?:/, '');

      // onreadystatechange not supported by XDomainRequest
      if (opts.onSuccess) {
        request.onload = opts.onSuccess;
      }
      if (opts.onError) {
        request.onerror = function() {
          var err = new Error('Sentry error code: XDomainRequest');
          err.request = request;
          opts.onError(err);
        };
      }
    }

    request.open('POST', url);

    if (evaluatedHeaders) {
      each(evaluatedHeaders, function(key, value) {
        request.setRequestHeader(key, value);
      });
    }

    request.send(stringify(opts.data));
  },

  _evaluateHash: function(hash) {
    var evaluated = {};

    for (var key in hash) {
      if (hash.hasOwnProperty(key)) {
        var value = hash[key];
        evaluated[key] = typeof value === 'function' ? value() : value;
      }
    }

    return evaluated;
  },

  _logDebug: function(level) {
    // We allow `Raven.debug` and `Raven.config(DSN, { debug: true })` to not make backward incompatible API change
    if (
      this._originalConsoleMethods[level] &&
      (this.debug || this._globalOptions.debug)
    ) {
      // In IE<10 console methods do not have their own 'apply' method
      Function.prototype.apply.call(
        this._originalConsoleMethods[level],
        this._originalConsole,
        [].slice.call(arguments, 1)
      );
    }
  },

  _mergeContext: function(key, context) {
    if (isUndefined(context)) {
      delete this._globalContext[key];
    } else {
      this._globalContext[key] = objectMerge(this._globalContext[key] || {}, context);
    }
  }
};

// Deprecations
Raven.prototype.setUser = Raven.prototype.setUserContext;
Raven.prototype.setReleaseContext = Raven.prototype.setRelease;

module.exports = Raven;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../vendor/TraceKit/tracekit":464,"../vendor/json-stringify-safe/stringify":465,"../vendor/md5/md5":466,"./configError":459,"./console":460,"./utils":463}],462:[function(require,module,exports){
(function (global){
/**
 * Enforces a single instance of the Raven client, and the
 * main entry point for Raven. If you are a consumer of the
 * Raven library, you SHOULD load this file (vs raven.js).
 **/

var RavenConstructor = require('./raven');

// This is to be defensive in environments where window does not exist (see https://github.com/getsentry/raven-js/pull/785)
var _window =
  typeof window !== 'undefined'
    ? window
    : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};
var _Raven = _window.Raven;

var Raven = new RavenConstructor();

/*
 * Allow multiple versions of Raven to be installed.
 * Strip Raven from the global context and returns the instance.
 *
 * @return {Raven}
 */
Raven.noConflict = function() {
  _window.Raven = _Raven;
  return Raven;
};

Raven.afterLoad();

module.exports = Raven;

/**
 * DISCLAIMER:
 *
 * Expose `Client` constructor for cases where user want to track multiple "sub-applications" in one larger app.
 * It's not meant to be used by a wide audience, so pleaaase make sure that you know what you're doing before using it.
 * Accidentally calling `install` multiple times, may result in an unexpected behavior that's very hard to debug.
 *
 * It's called `Client' to be in-line with Raven Node implementation.
 *
 * HOWTO:
 *
 * import Raven from 'raven-js';
 *
 * const someAppReporter = new Raven.Client();
 * const someOtherAppReporter = new Raven.Client();
 *
 * someAppReporter.config('__DSN__', {
 *   ...config goes here
 * });
 *
 * someOtherAppReporter.config('__OTHER_DSN__', {
 *   ...config goes here
 * });
 *
 * someAppReporter.captureMessage(...);
 * someAppReporter.captureException(...);
 * someAppReporter.captureBreadcrumb(...);
 *
 * someOtherAppReporter.captureMessage(...);
 * someOtherAppReporter.captureException(...);
 * someOtherAppReporter.captureBreadcrumb(...);
 *
 * It should "just work".
 */
module.exports.Client = RavenConstructor;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./raven":461}],463:[function(require,module,exports){
(function (global){
var stringify = require('../vendor/json-stringify-safe/stringify');

var _window =
  typeof window !== 'undefined'
    ? window
    : typeof global !== 'undefined'
      ? global
      : typeof self !== 'undefined'
        ? self
        : {};

function isObject(what) {
  return typeof what === 'object' && what !== null;
}

// Yanked from https://git.io/vS8DV re-used under CC0
// with some tiny modifications
function isError(value) {
  switch (Object.prototype.toString.call(value)) {
    case '[object Error]':
      return true;
    case '[object Exception]':
      return true;
    case '[object DOMException]':
      return true;
    default:
      return value instanceof Error;
  }
}

function isErrorEvent(value) {
  return Object.prototype.toString.call(value) === '[object ErrorEvent]';
}

function isDOMError(value) {
  return Object.prototype.toString.call(value) === '[object DOMError]';
}

function isDOMException(value) {
  return Object.prototype.toString.call(value) === '[object DOMException]';
}

function isUndefined(what) {
  return what === void 0;
}

function isFunction(what) {
  return typeof what === 'function';
}

function isPlainObject(what) {
  return Object.prototype.toString.call(what) === '[object Object]';
}

function isString(what) {
  return Object.prototype.toString.call(what) === '[object String]';
}

function isArray(what) {
  return Object.prototype.toString.call(what) === '[object Array]';
}

function isEmptyObject(what) {
  if (!isPlainObject(what)) return false;

  for (var _ in what) {
    if (what.hasOwnProperty(_)) {
      return false;
    }
  }
  return true;
}

function supportsErrorEvent() {
  try {
    new ErrorEvent(''); // eslint-disable-line no-new
    return true;
  } catch (e) {
    return false;
  }
}

function supportsDOMError() {
  try {
    new DOMError(''); // eslint-disable-line no-new
    return true;
  } catch (e) {
    return false;
  }
}

function supportsDOMException() {
  try {
    new DOMException(''); // eslint-disable-line no-new
    return true;
  } catch (e) {
    return false;
  }
}

function supportsFetch() {
  if (!('fetch' in _window)) return false;

  try {
    new Headers(); // eslint-disable-line no-new
    new Request(''); // eslint-disable-line no-new
    new Response(); // eslint-disable-line no-new
    return true;
  } catch (e) {
    return false;
  }
}

// Despite all stars in the sky saying that Edge supports old draft syntax, aka 'never', 'always', 'origin' and 'default
// https://caniuse.com/#feat=referrer-policy
// It doesn't. And it throw exception instead of ignoring this parameter...
// REF: https://github.com/getsentry/raven-js/issues/1233
function supportsReferrerPolicy() {
  if (!supportsFetch()) return false;

  try {
    // eslint-disable-next-line no-new
    new Request('pickleRick', {
      referrerPolicy: 'origin'
    });
    return true;
  } catch (e) {
    return false;
  }
}

function supportsPromiseRejectionEvent() {
  return typeof PromiseRejectionEvent === 'function';
}

function wrappedCallback(callback) {
  function dataCallback(data, original) {
    var normalizedData = callback(data) || data;
    if (original) {
      return original(normalizedData) || normalizedData;
    }
    return normalizedData;
  }

  return dataCallback;
}

function each(obj, callback) {
  var i, j;

  if (isUndefined(obj.length)) {
    for (i in obj) {
      if (hasKey(obj, i)) {
        callback.call(null, i, obj[i]);
      }
    }
  } else {
    j = obj.length;
    if (j) {
      for (i = 0; i < j; i++) {
        callback.call(null, i, obj[i]);
      }
    }
  }
}

function objectMerge(obj1, obj2) {
  if (!obj2) {
    return obj1;
  }
  each(obj2, function(key, value) {
    obj1[key] = value;
  });
  return obj1;
}

/**
 * This function is only used for react-native.
 * react-native freezes object that have already been sent over the
 * js bridge. We need this function in order to check if the object is frozen.
 * So it's ok that objectFrozen returns false if Object.isFrozen is not
 * supported because it's not relevant for other "platforms". See related issue:
 * https://github.com/getsentry/react-native-sentry/issues/57
 */
function objectFrozen(obj) {
  if (!Object.isFrozen) {
    return false;
  }
  return Object.isFrozen(obj);
}

function truncate(str, max) {
  if (typeof max !== 'number') {
    throw new Error('2nd argument to `truncate` function should be a number');
  }
  if (typeof str !== 'string' || max === 0) {
    return str;
  }
  return str.length <= max ? str : str.substr(0, max) + '\u2026';
}

/**
 * hasKey, a better form of hasOwnProperty
 * Example: hasKey(MainHostObject, property) === true/false
 *
 * @param {Object} host object to check property
 * @param {string} key to check
 */
function hasKey(object, key) {
  return Object.prototype.hasOwnProperty.call(object, key);
}

function joinRegExp(patterns) {
  // Combine an array of regular expressions and strings into one large regexp
  // Be mad.
  var sources = [],
    i = 0,
    len = patterns.length,
    pattern;

  for (; i < len; i++) {
    pattern = patterns[i];
    if (isString(pattern)) {
      // If it's a string, we need to escape it
      // Taken from: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions
      sources.push(pattern.replace(/([.*+?^=!:${}()|\[\]\/\\])/g, '\\$1'));
    } else if (pattern && pattern.source) {
      // If it's a regexp already, we want to extract the source
      sources.push(pattern.source);
    }
    // Intentionally skip other cases
  }
  return new RegExp(sources.join('|'), 'i');
}

function urlencode(o) {
  var pairs = [];
  each(o, function(key, value) {
    pairs.push(encodeURIComponent(key) + '=' + encodeURIComponent(value));
  });
  return pairs.join('&');
}

// borrowed from https://tools.ietf.org/html/rfc3986#appendix-B
// intentionally using regex and not <a/> href parsing trick because React Native and other
// environments where DOM might not be available
function parseUrl(url) {
  if (typeof url !== 'string') return {};
  var match = url.match(/^(([^:\/?#]+):)?(\/\/([^\/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?$/);

  // coerce to undefined values to empty string so we don't get 'undefined'
  var query = match[6] || '';
  var fragment = match[8] || '';
  return {
    protocol: match[2],
    host: match[4],
    path: match[5],
    relative: match[5] + query + fragment // everything minus origin
  };
}
function uuid4() {
  var crypto = _window.crypto || _window.msCrypto;

  if (!isUndefined(crypto) && crypto.getRandomValues) {
    // Use window.crypto API if available
    // eslint-disable-next-line no-undef
    var arr = new Uint16Array(8);
    crypto.getRandomValues(arr);

    // set 4 in byte 7
    arr[3] = (arr[3] & 0xfff) | 0x4000;
    // set 2 most significant bits of byte 9 to '10'
    arr[4] = (arr[4] & 0x3fff) | 0x8000;

    var pad = function(num) {
      var v = num.toString(16);
      while (v.length < 4) {
        v = '0' + v;
      }
      return v;
    };

    return (
      pad(arr[0]) +
      pad(arr[1]) +
      pad(arr[2]) +
      pad(arr[3]) +
      pad(arr[4]) +
      pad(arr[5]) +
      pad(arr[6]) +
      pad(arr[7])
    );
  } else {
    // http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/2117523#2117523
    return 'xxxxxxxxxxxx4xxxyxxxxxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
      var r = (Math.random() * 16) | 0,
        v = c === 'x' ? r : (r & 0x3) | 0x8;
      return v.toString(16);
    });
  }
}

/**
 * Given a child DOM element, returns a query-selector statement describing that
 * and its ancestors
 * e.g. [HTMLElement] => body > div > input#foo.btn[name=baz]
 * @param elem
 * @returns {string}
 */
function htmlTreeAsString(elem) {
  /* eslint no-extra-parens:0*/
  var MAX_TRAVERSE_HEIGHT = 5,
    MAX_OUTPUT_LEN = 80,
    out = [],
    height = 0,
    len = 0,
    separator = ' > ',
    sepLength = separator.length,
    nextStr;

  while (elem && height++ < MAX_TRAVERSE_HEIGHT) {
    nextStr = htmlElementAsString(elem);
    // bail out if
    // - nextStr is the 'html' element
    // - the length of the string that would be created exceeds MAX_OUTPUT_LEN
    //   (ignore this limit if we are on the first iteration)
    if (
      nextStr === 'html' ||
      (height > 1 && len + out.length * sepLength + nextStr.length >= MAX_OUTPUT_LEN)
    ) {
      break;
    }

    out.push(nextStr);

    len += nextStr.length;
    elem = elem.parentNode;
  }

  return out.reverse().join(separator);
}

/**
 * Returns a simple, query-selector representation of a DOM element
 * e.g. [HTMLElement] => input#foo.btn[name=baz]
 * @param HTMLElement
 * @returns {string}
 */
function htmlElementAsString(elem) {
  var out = [],
    className,
    classes,
    key,
    attr,
    i;

  if (!elem || !elem.tagName) {
    return '';
  }

  out.push(elem.tagName.toLowerCase());
  if (elem.id) {
    out.push('#' + elem.id);
  }

  className = elem.className;
  if (className && isString(className)) {
    classes = className.split(/\s+/);
    for (i = 0; i < classes.length; i++) {
      out.push('.' + classes[i]);
    }
  }
  var attrWhitelist = ['type', 'name', 'title', 'alt'];
  for (i = 0; i < attrWhitelist.length; i++) {
    key = attrWhitelist[i];
    attr = elem.getAttribute(key);
    if (attr) {
      out.push('[' + key + '="' + attr + '"]');
    }
  }
  return out.join('');
}

/**
 * Returns true if either a OR b is truthy, but not both
 */
function isOnlyOneTruthy(a, b) {
  return !!(!!a ^ !!b);
}

/**
 * Returns true if both parameters are undefined
 */
function isBothUndefined(a, b) {
  return isUndefined(a) && isUndefined(b);
}

/**
 * Returns true if the two input exception interfaces have the same content
 */
function isSameException(ex1, ex2) {
  if (isOnlyOneTruthy(ex1, ex2)) return false;

  ex1 = ex1.values[0];
  ex2 = ex2.values[0];

  if (ex1.type !== ex2.type || ex1.value !== ex2.value) return false;

  // in case both stacktraces are undefined, we can't decide so default to false
  if (isBothUndefined(ex1.stacktrace, ex2.stacktrace)) return false;

  return isSameStacktrace(ex1.stacktrace, ex2.stacktrace);
}

/**
 * Returns true if the two input stack trace interfaces have the same content
 */
function isSameStacktrace(stack1, stack2) {
  if (isOnlyOneTruthy(stack1, stack2)) return false;

  var frames1 = stack1.frames;
  var frames2 = stack2.frames;

  // Exit early if stacktrace is malformed
  if (frames1 === undefined || frames2 === undefined) return false;

  // Exit early if frame count differs
  if (frames1.length !== frames2.length) return false;

  // Iterate through every frame; bail out if anything differs
  var a, b;
  for (var i = 0; i < frames1.length; i++) {
    a = frames1[i];
    b = frames2[i];
    if (
      a.filename !== b.filename ||
      a.lineno !== b.lineno ||
      a.colno !== b.colno ||
      a['function'] !== b['function']
    )
      return false;
  }
  return true;
}

/**
 * Polyfill a method
 * @param obj object e.g. `document`
 * @param name method name present on object e.g. `addEventListener`
 * @param replacement replacement function
 * @param track {optional} record instrumentation to an array
 */
function fill(obj, name, replacement, track) {
  if (obj == null) return;
  var orig = obj[name];
  obj[name] = replacement(orig);
  obj[name].__raven__ = true;
  obj[name].__orig__ = orig;
  if (track) {
    track.push([obj, name, orig]);
  }
}

/**
 * Join values in array
 * @param input array of values to be joined together
 * @param delimiter string to be placed in-between values
 * @returns {string}
 */
function safeJoin(input, delimiter) {
  if (!isArray(input)) return '';

  var output = [];

  for (var i = 0; i < input.length; i++) {
    try {
      output.push(String(input[i]));
    } catch (e) {
      output.push('[value cannot be serialized]');
    }
  }

  return output.join(delimiter);
}

// Default Node.js REPL depth
var MAX_SERIALIZE_EXCEPTION_DEPTH = 3;
// 50kB, as 100kB is max payload size, so half sounds reasonable
var MAX_SERIALIZE_EXCEPTION_SIZE = 50 * 1024;
var MAX_SERIALIZE_KEYS_LENGTH = 40;

function utf8Length(value) {
  return ~-encodeURI(value).split(/%..|./).length;
}

function jsonSize(value) {
  return utf8Length(JSON.stringify(value));
}

function serializeValue(value) {
  if (typeof value === 'string') {
    var maxLength = 40;
    return truncate(value, maxLength);
  } else if (
    typeof value === 'number' ||
    typeof value === 'boolean' ||
    typeof value === 'undefined'
  ) {
    return value;
  }

  var type = Object.prototype.toString.call(value);

  // Node.js REPL notation
  if (type === '[object Object]') return '[Object]';
  if (type === '[object Array]') return '[Array]';
  if (type === '[object Function]')
    return value.name ? '[Function: ' + value.name + ']' : '[Function]';

  return value;
}

function serializeObject(value, depth) {
  if (depth === 0) return serializeValue(value);

  if (isPlainObject(value)) {
    return Object.keys(value).reduce(function(acc, key) {
      acc[key] = serializeObject(value[key], depth - 1);
      return acc;
    }, {});
  } else if (Array.isArray(value)) {
    return value.map(function(val) {
      return serializeObject(val, depth - 1);
    });
  }

  return serializeValue(value);
}

function serializeException(ex, depth, maxSize) {
  if (!isPlainObject(ex)) return ex;

  depth = typeof depth !== 'number' ? MAX_SERIALIZE_EXCEPTION_DEPTH : depth;
  maxSize = typeof depth !== 'number' ? MAX_SERIALIZE_EXCEPTION_SIZE : maxSize;

  var serialized = serializeObject(ex, depth);

  if (jsonSize(stringify(serialized)) > maxSize) {
    return serializeException(ex, depth - 1);
  }

  return serialized;
}

function serializeKeysForMessage(keys, maxLength) {
  if (typeof keys === 'number' || typeof keys === 'string') return keys.toString();
  if (!Array.isArray(keys)) return '';

  keys = keys.filter(function(key) {
    return typeof key === 'string';
  });
  if (keys.length === 0) return '[object has no keys]';

  maxLength = typeof maxLength !== 'number' ? MAX_SERIALIZE_KEYS_LENGTH : maxLength;
  if (keys[0].length >= maxLength) return keys[0];

  for (var usedKeys = keys.length; usedKeys > 0; usedKeys--) {
    var serialized = keys.slice(0, usedKeys).join(', ');
    if (serialized.length > maxLength) continue;
    if (usedKeys === keys.length) return serialized;
    return serialized + '\u2026';
  }

  return '';
}

function sanitize(input, sanitizeKeys) {
  if (!isArray(sanitizeKeys) || (isArray(sanitizeKeys) && sanitizeKeys.length === 0))
    return input;

  var sanitizeRegExp = joinRegExp(sanitizeKeys);
  var sanitizeMask = '********';
  var safeInput;

  try {
    safeInput = JSON.parse(stringify(input));
  } catch (o_O) {
    return input;
  }

  function sanitizeWorker(workerInput) {
    if (isArray(workerInput)) {
      return workerInput.map(function(val) {
        return sanitizeWorker(val);
      });
    }

    if (isPlainObject(workerInput)) {
      return Object.keys(workerInput).reduce(function(acc, k) {
        if (sanitizeRegExp.test(k)) {
          acc[k] = sanitizeMask;
        } else {
          acc[k] = sanitizeWorker(workerInput[k]);
        }
        return acc;
      }, {});
    }

    return workerInput;
  }

  return sanitizeWorker(safeInput);
}

module.exports = {
  isObject: isObject,
  isError: isError,
  isErrorEvent: isErrorEvent,
  isDOMError: isDOMError,
  isDOMException: isDOMException,
  isUndefined: isUndefined,
  isFunction: isFunction,
  isPlainObject: isPlainObject,
  isString: isString,
  isArray: isArray,
  isEmptyObject: isEmptyObject,
  supportsErrorEvent: supportsErrorEvent,
  supportsDOMError: supportsDOMError,
  supportsDOMException: supportsDOMException,
  supportsFetch: supportsFetch,
  supportsReferrerPolicy: supportsReferrerPolicy,
  supportsPromiseRejectionEvent: supportsPromiseRejectionEvent,
  wrappedCallback: wrappedCallback,
  each: each,
  objectMerge: objectMerge,
  truncate: truncate,
  objectFrozen: objectFrozen,
  hasKey: hasKey,
  joinRegExp: joinRegExp,
  urlencode: urlencode,
  uuid4: uuid4,
  htmlTreeAsString: htmlTreeAsString,
  htmlElementAsString: htmlElementAsString,
  isSameException: isSameException,
  isSameStacktrace: isSameStacktrace,
  parseUrl: parseUrl,
  fill: fill,
  safeJoin: safeJoin,
  serializeException: serializeException,
  serializeKeysForMessage: serializeKeysForMessage,
  sanitize: sanitize
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../vendor/json-stringify-safe/stringify":465}],464:[function(require,module,exports){
(function (global){
var utils = require('../../src/utils');

/*
 TraceKit - Cross brower stack traces

 This was originally forked from github.com/occ/TraceKit, but has since been
 largely re-written and is now maintained as part of raven-js.  Tests for
 this are in test/vendor.

 MIT license
*/

var TraceKit = {
  collectWindowErrors: true,
  debug: false
};

// This is to be defensive in environments where window does not exist (see https://github.com/getsentry/raven-js/pull/785)
var _window =
  typeof window !== 'undefined'
    ? window
    : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

// global reference to slice
var _slice = [].slice;
var UNKNOWN_FUNCTION = '?';

// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error#Error_types
var ERROR_TYPES_RE = /^(?:[Uu]ncaught (?:exception: )?)?(?:((?:Eval|Internal|Range|Reference|Syntax|Type|URI|)Error): )?(.*)$/;

function getLocationHref() {
  if (typeof document === 'undefined' || document.location == null) return '';
  return document.location.href;
}

function getLocationOrigin() {
  if (typeof document === 'undefined' || document.location == null) return '';

  // Oh dear IE10...
  if (!document.location.origin) {
    return (
      document.location.protocol +
      '//' +
      document.location.hostname +
      (document.location.port ? ':' + document.location.port : '')
    );
  }

  return document.location.origin;
}

/**
 * TraceKit.report: cross-browser processing of unhandled exceptions
 *
 * Syntax:
 *   TraceKit.report.subscribe(function(stackInfo) { ... })
 *   TraceKit.report.unsubscribe(function(stackInfo) { ... })
 *   TraceKit.report(exception)
 *   try { ...code... } catch(ex) { TraceKit.report(ex); }
 *
 * Supports:
 *   - Firefox: full stack trace with line numbers, plus column number
 *              on top frame; column number is not guaranteed
 *   - Opera:   full stack trace with line and column numbers
 *   - Chrome:  full stack trace with line and column numbers
 *   - Safari:  line and column number for the top frame only; some frames
 *              may be missing, and column number is not guaranteed
 *   - IE:      line and column number for the top frame only; some frames
 *              may be missing, and column number is not guaranteed
 *
 * In theory, TraceKit should work on all of the following versions:
 *   - IE5.5+ (only 8.0 tested)
 *   - Firefox 0.9+ (only 3.5+ tested)
 *   - Opera 7+ (only 10.50 tested; versions 9 and earlier may require
 *     Exceptions Have Stacktrace to be enabled in opera:config)
 *   - Safari 3+ (only 4+ tested)
 *   - Chrome 1+ (only 5+ tested)
 *   - Konqueror 3.5+ (untested)
 *
 * Requires TraceKit.computeStackTrace.
 *
 * Tries to catch all unhandled exceptions and report them to the
 * subscribed handlers. Please note that TraceKit.report will rethrow the
 * exception. This is REQUIRED in order to get a useful stack trace in IE.
 * If the exception does not reach the top of the browser, you will only
 * get a stack trace from the point where TraceKit.report was called.
 *
 * Handlers receive a stackInfo object as described in the
 * TraceKit.computeStackTrace docs.
 */
TraceKit.report = (function reportModuleWrapper() {
  var handlers = [],
    lastArgs = null,
    lastException = null,
    lastExceptionStack = null;

  /**
   * Add a crash handler.
   * @param {Function} handler
   */
  function subscribe(handler) {
    installGlobalHandler();
    handlers.push(handler);
  }

  /**
   * Remove a crash handler.
   * @param {Function} handler
   */
  function unsubscribe(handler) {
    for (var i = handlers.length - 1; i >= 0; --i) {
      if (handlers[i] === handler) {
        handlers.splice(i, 1);
      }
    }
  }

  /**
   * Remove all crash handlers.
   */
  function unsubscribeAll() {
    uninstallGlobalHandler();
    handlers = [];
  }

  /**
   * Dispatch stack information to all handlers.
   * @param {Object.<string, *>} stack
   */
  function notifyHandlers(stack, isWindowError) {
    var exception = null;
    if (isWindowError && !TraceKit.collectWindowErrors) {
      return;
    }
    for (var i in handlers) {
      if (handlers.hasOwnProperty(i)) {
        try {
          handlers[i].apply(null, [stack].concat(_slice.call(arguments, 2)));
        } catch (inner) {
          exception = inner;
        }
      }
    }

    if (exception) {
      throw exception;
    }
  }

  var _oldOnerrorHandler, _onErrorHandlerInstalled;

  /**
   * Ensures all global unhandled exceptions are recorded.
   * Supported by Gecko and IE.
   * @param {string} msg Error message.
   * @param {string} url URL of script that generated the exception.
   * @param {(number|string)} lineNo The line number at which the error
   * occurred.
   * @param {?(number|string)} colNo The column number at which the error
   * occurred.
   * @param {?Error} ex The actual Error object.
   */
  function traceKitWindowOnError(msg, url, lineNo, colNo, ex) {
    var stack = null;
    // If 'ex' is ErrorEvent, get real Error from inside
    var exception = utils.isErrorEvent(ex) ? ex.error : ex;
    // If 'msg' is ErrorEvent, get real message from inside
    var message = utils.isErrorEvent(msg) ? msg.message : msg;

    if (lastExceptionStack) {
      TraceKit.computeStackTrace.augmentStackTraceWithInitialElement(
        lastExceptionStack,
        url,
        lineNo,
        message
      );
      processLastException();
    } else if (exception && utils.isError(exception)) {
      // non-string `exception` arg; attempt to extract stack trace

      // New chrome and blink send along a real error object
      // Let's just report that like a normal error.
      // See: https://mikewest.org/2013/08/debugging-runtime-errors-with-window-onerror
      stack = TraceKit.computeStackTrace(exception);
      notifyHandlers(stack, true);
    } else {
      var location = {
        url: url,
        line: lineNo,
        column: colNo
      };

      var name = undefined;
      var groups;

      if ({}.toString.call(message) === '[object String]') {
        var groups = message.match(ERROR_TYPES_RE);
        if (groups) {
          name = groups[1];
          message = groups[2];
        }
      }

      location.func = UNKNOWN_FUNCTION;

      stack = {
        name: name,
        message: message,
        url: getLocationHref(),
        stack: [location]
      };
      notifyHandlers(stack, true);
    }

    if (_oldOnerrorHandler) {
      return _oldOnerrorHandler.apply(this, arguments);
    }

    return false;
  }

  function installGlobalHandler() {
    if (_onErrorHandlerInstalled) {
      return;
    }
    _oldOnerrorHandler = _window.onerror;
    _window.onerror = traceKitWindowOnError;
    _onErrorHandlerInstalled = true;
  }

  function uninstallGlobalHandler() {
    if (!_onErrorHandlerInstalled) {
      return;
    }
    _window.onerror = _oldOnerrorHandler;
    _onErrorHandlerInstalled = false;
    _oldOnerrorHandler = undefined;
  }

  function processLastException() {
    var _lastExceptionStack = lastExceptionStack,
      _lastArgs = lastArgs;
    lastArgs = null;
    lastExceptionStack = null;
    lastException = null;
    notifyHandlers.apply(null, [_lastExceptionStack, false].concat(_lastArgs));
  }

  /**
   * Reports an unhandled Error to TraceKit.
   * @param {Error} ex
   * @param {?boolean} rethrow If false, do not re-throw the exception.
   * Only used for window.onerror to not cause an infinite loop of
   * rethrowing.
   */
  function report(ex, rethrow) {
    var args = _slice.call(arguments, 1);
    if (lastExceptionStack) {
      if (lastException === ex) {
        return; // already caught by an inner catch block, ignore
      } else {
        processLastException();
      }
    }

    var stack = TraceKit.computeStackTrace(ex);
    lastExceptionStack = stack;
    lastException = ex;
    lastArgs = args;

    // If the stack trace is incomplete, wait for 2 seconds for
    // slow slow IE to see if onerror occurs or not before reporting
    // this exception; otherwise, we will end up with an incomplete
    // stack trace
    setTimeout(function() {
      if (lastException === ex) {
        processLastException();
      }
    }, stack.incomplete ? 2000 : 0);

    if (rethrow !== false) {
      throw ex; // re-throw to propagate to the top level (and cause window.onerror)
    }
  }

  report.subscribe = subscribe;
  report.unsubscribe = unsubscribe;
  report.uninstall = unsubscribeAll;
  return report;
})();

/**
 * TraceKit.computeStackTrace: cross-browser stack traces in JavaScript
 *
 * Syntax:
 *   s = TraceKit.computeStackTrace(exception) // consider using TraceKit.report instead (see below)
 * Returns:
 *   s.name              - exception name
 *   s.message           - exception message
 *   s.stack[i].url      - JavaScript or HTML file URL
 *   s.stack[i].func     - function name, or empty for anonymous functions (if guessing did not work)
 *   s.stack[i].args     - arguments passed to the function, if known
 *   s.stack[i].line     - line number, if known
 *   s.stack[i].column   - column number, if known
 *
 * Supports:
 *   - Firefox:  full stack trace with line numbers and unreliable column
 *               number on top frame
 *   - Opera 10: full stack trace with line and column numbers
 *   - Opera 9-: full stack trace with line numbers
 *   - Chrome:   full stack trace with line and column numbers
 *   - Safari:   line and column number for the topmost stacktrace element
 *               only
 *   - IE:       no line numbers whatsoever
 *
 * Tries to guess names of anonymous functions by looking for assignments
 * in the source code. In IE and Safari, we have to guess source file names
 * by searching for function bodies inside all page scripts. This will not
 * work for scripts that are loaded cross-domain.
 * Here be dragons: some function names may be guessed incorrectly, and
 * duplicate functions may be mismatched.
 *
 * TraceKit.computeStackTrace should only be used for tracing purposes.
 * Logging of unhandled exceptions should be done with TraceKit.report,
 * which builds on top of TraceKit.computeStackTrace and provides better
 * IE support by utilizing the window.onerror event to retrieve information
 * about the top of the stack.
 *
 * Note: In IE and Safari, no stack trace is recorded on the Error object,
 * so computeStackTrace instead walks its *own* chain of callers.
 * This means that:
 *  * in Safari, some methods may be missing from the stack trace;
 *  * in IE, the topmost function in the stack trace will always be the
 *    caller of computeStackTrace.
 *
 * This is okay for tracing (because you are likely to be calling
 * computeStackTrace from the function you want to be the topmost element
 * of the stack trace anyway), but not okay for logging unhandled
 * exceptions (because your catch block will likely be far away from the
 * inner function that actually caused the exception).
 *
 */
TraceKit.computeStackTrace = (function computeStackTraceWrapper() {
  // Contents of Exception in various browsers.
  //
  // SAFARI:
  // ex.message = Can't find variable: qq
  // ex.line = 59
  // ex.sourceId = 580238192
  // ex.sourceURL = http://...
  // ex.expressionBeginOffset = 96
  // ex.expressionCaretOffset = 98
  // ex.expressionEndOffset = 98
  // ex.name = ReferenceError
  //
  // FIREFOX:
  // ex.message = qq is not defined
  // ex.fileName = http://...
  // ex.lineNumber = 59
  // ex.columnNumber = 69
  // ex.stack = ...stack trace... (see the example below)
  // ex.name = ReferenceError
  //
  // CHROME:
  // ex.message = qq is not defined
  // ex.name = ReferenceError
  // ex.type = not_defined
  // ex.arguments = ['aa']
  // ex.stack = ...stack trace...
  //
  // INTERNET EXPLORER:
  // ex.message = ...
  // ex.name = ReferenceError
  //
  // OPERA:
  // ex.message = ...message... (see the example below)
  // ex.name = ReferenceError
  // ex.opera#sourceloc = 11  (pretty much useless, duplicates the info in ex.message)
  // ex.stacktrace = n/a; see 'opera:config#UserPrefs|Exceptions Have Stacktrace'

  /**
   * Computes stack trace information from the stack property.
   * Chrome and Gecko use this property.
   * @param {Error} ex
   * @return {?Object.<string, *>} Stack trace information.
   */
  function computeStackTraceFromStackProp(ex) {
    if (typeof ex.stack === 'undefined' || !ex.stack) return;

    var chrome = /^\s*at (?:(.*?) ?\()?((?:file|https?|blob|chrome-extension|native|eval|webpack|<anonymous>|[a-z]:|\/).*?)(?::(\d+))?(?::(\d+))?\)?\s*$/i;
    var winjs = /^\s*at (?:((?:\[object object\])?.+) )?\(?((?:file|ms-appx(?:-web)|https?|webpack|blob):.*?):(\d+)(?::(\d+))?\)?\s*$/i;
    // NOTE: blob urls are now supposed to always have an origin, therefore it's format
    // which is `blob:http://url/path/with-some-uuid`, is matched by `blob.*?:\/` as well
    var gecko = /^\s*(.*?)(?:\((.*?)\))?(?:^|@)((?:file|https?|blob|chrome|webpack|resource|moz-extension).*?:\/.*?|\[native code\]|[^@]*bundle)(?::(\d+))?(?::(\d+))?\s*$/i;
    // Used to additionally parse URL/line/column from eval frames
    var geckoEval = /(\S+) line (\d+)(?: > eval line \d+)* > eval/i;
    var chromeEval = /\((\S*)(?::(\d+))(?::(\d+))\)/;
    var lines = ex.stack.split('\n');
    var stack = [];
    var submatch;
    var parts;
    var element;
    var reference = /^(.*) is undefined$/.exec(ex.message);

    for (var i = 0, j = lines.length; i < j; ++i) {
      if ((parts = chrome.exec(lines[i]))) {
        var isNative = parts[2] && parts[2].indexOf('native') === 0; // start of line
        var isEval = parts[2] && parts[2].indexOf('eval') === 0; // start of line
        if (isEval && (submatch = chromeEval.exec(parts[2]))) {
          // throw out eval line/column and use top-most line/column number
          parts[2] = submatch[1]; // url
          parts[3] = submatch[2]; // line
          parts[4] = submatch[3]; // column
        }
        element = {
          url: !isNative ? parts[2] : null,
          func: parts[1] || UNKNOWN_FUNCTION,
          args: isNative ? [parts[2]] : [],
          line: parts[3] ? +parts[3] : null,
          column: parts[4] ? +parts[4] : null
        };
      } else if ((parts = winjs.exec(lines[i]))) {
        element = {
          url: parts[2],
          func: parts[1] || UNKNOWN_FUNCTION,
          args: [],
          line: +parts[3],
          column: parts[4] ? +parts[4] : null
        };
      } else if ((parts = gecko.exec(lines[i]))) {
        var isEval = parts[3] && parts[3].indexOf(' > eval') > -1;
        if (isEval && (submatch = geckoEval.exec(parts[3]))) {
          // throw out eval line/column and use top-most line number
          parts[3] = submatch[1];
          parts[4] = submatch[2];
          parts[5] = null; // no column when eval
        } else if (i === 0 && !parts[5] && typeof ex.columnNumber !== 'undefined') {
          // FireFox uses this awesome columnNumber property for its top frame
          // Also note, Firefox's column number is 0-based and everything else expects 1-based,
          // so adding 1
          // NOTE: this hack doesn't work if top-most frame is eval
          stack[0].column = ex.columnNumber + 1;
        }
        element = {
          url: parts[3],
          func: parts[1] || UNKNOWN_FUNCTION,
          args: parts[2] ? parts[2].split(',') : [],
          line: parts[4] ? +parts[4] : null,
          column: parts[5] ? +parts[5] : null
        };
      } else {
        continue;
      }

      if (!element.func && element.line) {
        element.func = UNKNOWN_FUNCTION;
      }

      if (element.url && element.url.substr(0, 5) === 'blob:') {
        // Special case for handling JavaScript loaded into a blob.
        // We use a synchronous AJAX request here as a blob is already in
        // memory - it's not making a network request.  This will generate a warning
        // in the browser console, but there has already been an error so that's not
        // that much of an issue.
        var xhr = new XMLHttpRequest();
        xhr.open('GET', element.url, false);
        xhr.send(null);

        // If we failed to download the source, skip this patch
        if (xhr.status === 200) {
          var source = xhr.responseText || '';

          // We trim the source down to the last 300 characters as sourceMappingURL is always at the end of the file.
          // Why 300? To be in line with: https://github.com/getsentry/sentry/blob/4af29e8f2350e20c28a6933354e4f42437b4ba42/src/sentry/lang/javascript/processor.py#L164-L175
          source = source.slice(-300);

          // Now we dig out the source map URL
          var sourceMaps = source.match(/\/\/# sourceMappingURL=(.*)$/);

          // If we don't find a source map comment or we find more than one, continue on to the next element.
          if (sourceMaps) {
            var sourceMapAddress = sourceMaps[1];

            // Now we check to see if it's a relative URL.
            // If it is, convert it to an absolute one.
            if (sourceMapAddress.charAt(0) === '~') {
              sourceMapAddress = getLocationOrigin() + sourceMapAddress.slice(1);
            }

            // Now we strip the '.map' off of the end of the URL and update the
            // element so that Sentry can match the map to the blob.
            element.url = sourceMapAddress.slice(0, -4);
          }
        }
      }

      stack.push(element);
    }

    if (!stack.length) {
      return null;
    }

    return {
      name: ex.name,
      message: ex.message,
      url: getLocationHref(),
      stack: stack
    };
  }

  /**
   * Adds information about the first frame to incomplete stack traces.
   * Safari and IE require this to get complete data on the first frame.
   * @param {Object.<string, *>} stackInfo Stack trace information from
   * one of the compute* methods.
   * @param {string} url The URL of the script that caused an error.
   * @param {(number|string)} lineNo The line number of the script that
   * caused an error.
   * @param {string=} message The error generated by the browser, which
   * hopefully contains the name of the object that caused the error.
   * @return {boolean} Whether or not the stack information was
   * augmented.
   */
  function augmentStackTraceWithInitialElement(stackInfo, url, lineNo, message) {
    var initial = {
      url: url,
      line: lineNo
    };

    if (initial.url && initial.line) {
      stackInfo.incomplete = false;

      if (!initial.func) {
        initial.func = UNKNOWN_FUNCTION;
      }

      if (stackInfo.stack.length > 0) {
        if (stackInfo.stack[0].url === initial.url) {
          if (stackInfo.stack[0].line === initial.line) {
            return false; // already in stack trace
          } else if (
            !stackInfo.stack[0].line &&
            stackInfo.stack[0].func === initial.func
          ) {
            stackInfo.stack[0].line = initial.line;
            return false;
          }
        }
      }

      stackInfo.stack.unshift(initial);
      stackInfo.partial = true;
      return true;
    } else {
      stackInfo.incomplete = true;
    }

    return false;
  }

  /**
   * Computes stack trace information by walking the arguments.caller
   * chain at the time the exception occurred. This will cause earlier
   * frames to be missed but is the only way to get any stack trace in
   * Safari and IE. The top frame is restored by
   * {@link augmentStackTraceWithInitialElement}.
   * @param {Error} ex
   * @return {?Object.<string, *>} Stack trace information.
   */
  function computeStackTraceByWalkingCallerChain(ex, depth) {
    var functionName = /function\s+([_$a-zA-Z\xA0-\uFFFF][_$a-zA-Z0-9\xA0-\uFFFF]*)?\s*\(/i,
      stack = [],
      funcs = {},
      recursion = false,
      parts,
      item,
      source;

    for (
      var curr = computeStackTraceByWalkingCallerChain.caller;
      curr && !recursion;
      curr = curr.caller
    ) {
      if (curr === computeStackTrace || curr === TraceKit.report) {
        // console.log('skipping internal function');
        continue;
      }

      item = {
        url: null,
        func: UNKNOWN_FUNCTION,
        line: null,
        column: null
      };

      if (curr.name) {
        item.func = curr.name;
      } else if ((parts = functionName.exec(curr.toString()))) {
        item.func = parts[1];
      }

      if (typeof item.func === 'undefined') {
        try {
          item.func = parts.input.substring(0, parts.input.indexOf('{'));
        } catch (e) {}
      }

      if (funcs['' + curr]) {
        recursion = true;
      } else {
        funcs['' + curr] = true;
      }

      stack.push(item);
    }

    if (depth) {
      // console.log('depth is ' + depth);
      // console.log('stack is ' + stack.length);
      stack.splice(0, depth);
    }

    var result = {
      name: ex.name,
      message: ex.message,
      url: getLocationHref(),
      stack: stack
    };
    augmentStackTraceWithInitialElement(
      result,
      ex.sourceURL || ex.fileName,
      ex.line || ex.lineNumber,
      ex.message || ex.description
    );
    return result;
  }

  /**
   * Computes a stack trace for an exception.
   * @param {Error} ex
   * @param {(string|number)=} depth
   */
  function computeStackTrace(ex, depth) {
    var stack = null;
    depth = depth == null ? 0 : +depth;

    try {
      stack = computeStackTraceFromStackProp(ex);
      if (stack) {
        return stack;
      }
    } catch (e) {
      if (TraceKit.debug) {
        throw e;
      }
    }

    try {
      stack = computeStackTraceByWalkingCallerChain(ex, depth + 1);
      if (stack) {
        return stack;
      }
    } catch (e) {
      if (TraceKit.debug) {
        throw e;
      }
    }
    return {
      name: ex.name,
      message: ex.message,
      url: getLocationHref()
    };
  }

  computeStackTrace.augmentStackTraceWithInitialElement = augmentStackTraceWithInitialElement;
  computeStackTrace.computeStackTraceFromStackProp = computeStackTraceFromStackProp;

  return computeStackTrace;
})();

module.exports = TraceKit;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../src/utils":463}],465:[function(require,module,exports){
/*
 json-stringify-safe
 Like JSON.stringify, but doesn't throw on circular references.

 Originally forked from https://github.com/isaacs/json-stringify-safe
 version 5.0.1 on 3/8/2017 and modified to handle Errors serialization
 and IE8 compatibility. Tests for this are in test/vendor.

 ISC license: https://github.com/isaacs/json-stringify-safe/blob/master/LICENSE
*/

exports = module.exports = stringify;
exports.getSerialize = serializer;

function indexOf(haystack, needle) {
  for (var i = 0; i < haystack.length; ++i) {
    if (haystack[i] === needle) return i;
  }
  return -1;
}

function stringify(obj, replacer, spaces, cycleReplacer) {
  return JSON.stringify(obj, serializer(replacer, cycleReplacer), spaces);
}

// https://github.com/ftlabs/js-abbreviate/blob/fa709e5f139e7770a71827b1893f22418097fbda/index.js#L95-L106
function stringifyError(value) {
  var err = {
    // These properties are implemented as magical getters and don't show up in for in
    stack: value.stack,
    message: value.message,
    name: value.name
  };

  for (var i in value) {
    if (Object.prototype.hasOwnProperty.call(value, i)) {
      err[i] = value[i];
    }
  }

  return err;
}

function serializer(replacer, cycleReplacer) {
  var stack = [];
  var keys = [];

  if (cycleReplacer == null) {
    cycleReplacer = function(key, value) {
      if (stack[0] === value) {
        return '[Circular ~]';
      }
      return '[Circular ~.' + keys.slice(0, indexOf(stack, value)).join('.') + ']';
    };
  }

  return function(key, value) {
    if (stack.length > 0) {
      var thisPos = indexOf(stack, this);
      ~thisPos ? stack.splice(thisPos + 1) : stack.push(this);
      ~thisPos ? keys.splice(thisPos, Infinity, key) : keys.push(key);

      if (~indexOf(stack, value)) {
        value = cycleReplacer.call(this, key, value);
      }
    } else {
      stack.push(value);
    }

    return replacer == null
      ? value instanceof Error ? stringifyError(value) : value
      : replacer.call(this, key, value);
  };
}

},{}],466:[function(require,module,exports){
/*
 * JavaScript MD5
 * https://github.com/blueimp/JavaScript-MD5
 *
 * Copyright 2011, Sebastian Tschan
 * https://blueimp.net
 *
 * Licensed under the MIT license:
 * https://opensource.org/licenses/MIT
 *
 * Based on
 * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message
 * Digest Algorithm, as defined in RFC 1321.
 * Version 2.2 Copyright (C) Paul Johnston 1999 - 2009
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for more info.
 */

/*
* Add integers, wrapping at 2^32. This uses 16-bit operations internally
* to work around bugs in some JS interpreters.
*/
function safeAdd(x, y) {
  var lsw = (x & 0xffff) + (y & 0xffff);
  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
  return (msw << 16) | (lsw & 0xffff);
}

/*
* Bitwise rotate a 32-bit number to the left.
*/
function bitRotateLeft(num, cnt) {
  return (num << cnt) | (num >>> (32 - cnt));
}

/*
* These functions implement the four basic operations the algorithm uses.
*/
function md5cmn(q, a, b, x, s, t) {
  return safeAdd(bitRotateLeft(safeAdd(safeAdd(a, q), safeAdd(x, t)), s), b);
}
function md5ff(a, b, c, d, x, s, t) {
  return md5cmn((b & c) | (~b & d), a, b, x, s, t);
}
function md5gg(a, b, c, d, x, s, t) {
  return md5cmn((b & d) | (c & ~d), a, b, x, s, t);
}
function md5hh(a, b, c, d, x, s, t) {
  return md5cmn(b ^ c ^ d, a, b, x, s, t);
}
function md5ii(a, b, c, d, x, s, t) {
  return md5cmn(c ^ (b | ~d), a, b, x, s, t);
}

/*
* Calculate the MD5 of an array of little-endian words, and a bit length.
*/
function binlMD5(x, len) {
  /* append padding */
  x[len >> 5] |= 0x80 << (len % 32);
  x[(((len + 64) >>> 9) << 4) + 14] = len;

  var i;
  var olda;
  var oldb;
  var oldc;
  var oldd;
  var a = 1732584193;
  var b = -271733879;
  var c = -1732584194;
  var d = 271733878;

  for (i = 0; i < x.length; i += 16) {
    olda = a;
    oldb = b;
    oldc = c;
    oldd = d;

    a = md5ff(a, b, c, d, x[i], 7, -680876936);
    d = md5ff(d, a, b, c, x[i + 1], 12, -389564586);
    c = md5ff(c, d, a, b, x[i + 2], 17, 606105819);
    b = md5ff(b, c, d, a, x[i + 3], 22, -1044525330);
    a = md5ff(a, b, c, d, x[i + 4], 7, -176418897);
    d = md5ff(d, a, b, c, x[i + 5], 12, 1200080426);
    c = md5ff(c, d, a, b, x[i + 6], 17, -1473231341);
    b = md5ff(b, c, d, a, x[i + 7], 22, -45705983);
    a = md5ff(a, b, c, d, x[i + 8], 7, 1770035416);
    d = md5ff(d, a, b, c, x[i + 9], 12, -1958414417);
    c = md5ff(c, d, a, b, x[i + 10], 17, -42063);
    b = md5ff(b, c, d, a, x[i + 11], 22, -1990404162);
    a = md5ff(a, b, c, d, x[i + 12], 7, 1804603682);
    d = md5ff(d, a, b, c, x[i + 13], 12, -40341101);
    c = md5ff(c, d, a, b, x[i + 14], 17, -1502002290);
    b = md5ff(b, c, d, a, x[i + 15], 22, 1236535329);

    a = md5gg(a, b, c, d, x[i + 1], 5, -165796510);
    d = md5gg(d, a, b, c, x[i + 6], 9, -1069501632);
    c = md5gg(c, d, a, b, x[i + 11], 14, 643717713);
    b = md5gg(b, c, d, a, x[i], 20, -373897302);
    a = md5gg(a, b, c, d, x[i + 5], 5, -701558691);
    d = md5gg(d, a, b, c, x[i + 10], 9, 38016083);
    c = md5gg(c, d, a, b, x[i + 15], 14, -660478335);
    b = md5gg(b, c, d, a, x[i + 4], 20, -405537848);
    a = md5gg(a, b, c, d, x[i + 9], 5, 568446438);
    d = md5gg(d, a, b, c, x[i + 14], 9, -1019803690);
    c = md5gg(c, d, a, b, x[i + 3], 14, -187363961);
    b = md5gg(b, c, d, a, x[i + 8], 20, 1163531501);
    a = md5gg(a, b, c, d, x[i + 13], 5, -1444681467);
    d = md5gg(d, a, b, c, x[i + 2], 9, -51403784);
    c = md5gg(c, d, a, b, x[i + 7], 14, 1735328473);
    b = md5gg(b, c, d, a, x[i + 12], 20, -1926607734);

    a = md5hh(a, b, c, d, x[i + 5], 4, -378558);
    d = md5hh(d, a, b, c, x[i + 8], 11, -2022574463);
    c = md5hh(c, d, a, b, x[i + 11], 16, 1839030562);
    b = md5hh(b, c, d, a, x[i + 14], 23, -35309556);
    a = md5hh(a, b, c, d, x[i + 1], 4, -1530992060);
    d = md5hh(d, a, b, c, x[i + 4], 11, 1272893353);
    c = md5hh(c, d, a, b, x[i + 7], 16, -155497632);
    b = md5hh(b, c, d, a, x[i + 10], 23, -1094730640);
    a = md5hh(a, b, c, d, x[i + 13], 4, 681279174);
    d = md5hh(d, a, b, c, x[i], 11, -358537222);
    c = md5hh(c, d, a, b, x[i + 3], 16, -722521979);
    b = md5hh(b, c, d, a, x[i + 6], 23, 76029189);
    a = md5hh(a, b, c, d, x[i + 9], 4, -640364487);
    d = md5hh(d, a, b, c, x[i + 12], 11, -421815835);
    c = md5hh(c, d, a, b, x[i + 15], 16, 530742520);
    b = md5hh(b, c, d, a, x[i + 2], 23, -995338651);

    a = md5ii(a, b, c, d, x[i], 6, -198630844);
    d = md5ii(d, a, b, c, x[i + 7], 10, 1126891415);
    c = md5ii(c, d, a, b, x[i + 14], 15, -1416354905);
    b = md5ii(b, c, d, a, x[i + 5], 21, -57434055);
    a = md5ii(a, b, c, d, x[i + 12], 6, 1700485571);
    d = md5ii(d, a, b, c, x[i + 3], 10, -1894986606);
    c = md5ii(c, d, a, b, x[i + 10], 15, -1051523);
    b = md5ii(b, c, d, a, x[i + 1], 21, -2054922799);
    a = md5ii(a, b, c, d, x[i + 8], 6, 1873313359);
    d = md5ii(d, a, b, c, x[i + 15], 10, -30611744);
    c = md5ii(c, d, a, b, x[i + 6], 15, -1560198380);
    b = md5ii(b, c, d, a, x[i + 13], 21, 1309151649);
    a = md5ii(a, b, c, d, x[i + 4], 6, -145523070);
    d = md5ii(d, a, b, c, x[i + 11], 10, -1120210379);
    c = md5ii(c, d, a, b, x[i + 2], 15, 718787259);
    b = md5ii(b, c, d, a, x[i + 9], 21, -343485551);

    a = safeAdd(a, olda);
    b = safeAdd(b, oldb);
    c = safeAdd(c, oldc);
    d = safeAdd(d, oldd);
  }
  return [a, b, c, d];
}

/*
* Convert an array of little-endian words to a string
*/
function binl2rstr(input) {
  var i;
  var output = '';
  var length32 = input.length * 32;
  for (i = 0; i < length32; i += 8) {
    output += String.fromCharCode((input[i >> 5] >>> (i % 32)) & 0xff);
  }
  return output;
}

/*
* Convert a raw string to an array of little-endian words
* Characters >255 have their high-byte silently ignored.
*/
function rstr2binl(input) {
  var i;
  var output = [];
  output[(input.length >> 2) - 1] = undefined;
  for (i = 0; i < output.length; i += 1) {
    output[i] = 0;
  }
  var length8 = input.length * 8;
  for (i = 0; i < length8; i += 8) {
    output[i >> 5] |= (input.charCodeAt(i / 8) & 0xff) << (i % 32);
  }
  return output;
}

/*
* Calculate the MD5 of a raw string
*/
function rstrMD5(s) {
  return binl2rstr(binlMD5(rstr2binl(s), s.length * 8));
}

/*
* Calculate the HMAC-MD5, of a key and some data (raw strings)
*/
function rstrHMACMD5(key, data) {
  var i;
  var bkey = rstr2binl(key);
  var ipad = [];
  var opad = [];
  var hash;
  ipad[15] = opad[15] = undefined;
  if (bkey.length > 16) {
    bkey = binlMD5(bkey, key.length * 8);
  }
  for (i = 0; i < 16; i += 1) {
    ipad[i] = bkey[i] ^ 0x36363636;
    opad[i] = bkey[i] ^ 0x5c5c5c5c;
  }
  hash = binlMD5(ipad.concat(rstr2binl(data)), 512 + data.length * 8);
  return binl2rstr(binlMD5(opad.concat(hash), 512 + 128));
}

/*
* Convert a raw string to a hex string
*/
function rstr2hex(input) {
  var hexTab = '0123456789abcdef';
  var output = '';
  var x;
  var i;
  for (i = 0; i < input.length; i += 1) {
    x = input.charCodeAt(i);
    output += hexTab.charAt((x >>> 4) & 0x0f) + hexTab.charAt(x & 0x0f);
  }
  return output;
}

/*
* Encode a string as utf-8
*/
function str2rstrUTF8(input) {
  return unescape(encodeURIComponent(input));
}

/*
* Take string arguments and return either raw or hex encoded strings
*/
function rawMD5(s) {
  return rstrMD5(str2rstrUTF8(s));
}
function hexMD5(s) {
  return rstr2hex(rawMD5(s));
}
function rawHMACMD5(k, d) {
  return rstrHMACMD5(str2rstrUTF8(k), str2rstrUTF8(d));
}
function hexHMACMD5(k, d) {
  return rstr2hex(rawHMACMD5(k, d));
}

function md5(string, key, raw) {
  if (!key) {
    if (!raw) {
      return hexMD5(string);
    }
    return rawMD5(string);
  }
  if (!raw) {
    return hexHMACMD5(key, string);
  }
  return rawHMACMD5(key, string);
}

module.exports = md5;

},{}],467:[function(require,module,exports){
/*
Slick Finder
*/"use strict"

// Notable changes from Slick.Finder 1.0.x

// faster bottom -> up expression matching
// prefers mental sanity over *obsessive compulsive* milliseconds savings
// uses prototypes instead of objects
// tries to use matchesSelector smartly, whenever available
// can populate objects as well as arrays
// lots of stuff is broken or not implemented

var parse = require("./parser")

// utilities

var index = 0,
    counter = document.__counter = (parseInt(document.__counter || -1, 36) + 1).toString(36),
    key = "uid:" + counter

var uniqueID = function(n, xml){
    if (n === window) return "window"
    if (n === document) return "document"
    if (n === document.documentElement) return "html"

    if (xml) {
        var uid = n.getAttribute(key)
        if (!uid) {
            uid = (index++).toString(36)
            n.setAttribute(key, uid)
        }
        return uid
    } else {
        return n[key] || (n[key] = (index++).toString(36))
    }
}

var uniqueIDXML = function(n) {
    return uniqueID(n, true)
}

var isArray = Array.isArray || function(object){
    return Object.prototype.toString.call(object) === "[object Array]"
}

// tests

var uniqueIndex = 0;

var HAS = {

    GET_ELEMENT_BY_ID: function(test, id){
        id = "slick_" + (uniqueIndex++);
        // checks if the document has getElementById, and it works
        test.innerHTML = '<a id="' + id + '"></a>'
        return !!this.getElementById(id)
    },

    QUERY_SELECTOR: function(test){
        // this supposedly fixes a webkit bug with matchesSelector / querySelector & nth-child
        test.innerHTML = '_<style>:nth-child(2){}</style>'

        // checks if the document has querySelectorAll, and it works
        test.innerHTML = '<a class="MiX"></a>'

        return test.querySelectorAll('.MiX').length === 1
    },

    EXPANDOS: function(test, id){
        id = "slick_" + (uniqueIndex++);
        // checks if the document has elements that support expandos
        test._custom_property_ = id
        return test._custom_property_ === id
    },

    // TODO: use this ?

    // CHECKED_QUERY_SELECTOR: function(test){
    //
    //     // checks if the document supports the checked query selector
    //     test.innerHTML = '<select><option selected="selected">a</option></select>'
    //     return test.querySelectorAll(':checked').length === 1
    // },

    // TODO: use this ?

    // EMPTY_ATTRIBUTE_QUERY_SELECTOR: function(test){
    //
    //     // checks if the document supports the empty attribute query selector
    //     test.innerHTML = '<a class=""></a>'
    //     return test.querySelectorAll('[class*=""]').length === 1
    // },

    MATCHES_SELECTOR: function(test){

        test.className = "MiX"

        // checks if the document has matchesSelector, and we can use it.

        var matches = test.matchesSelector || test.mozMatchesSelector || test.webkitMatchesSelector

        // if matchesSelector trows errors on incorrect syntax we can use it
        if (matches) try {
            matches.call(test, ':slick')
        } catch(e){
            // just as a safety precaution, also test if it works on mixedcase (like querySelectorAll)
            return matches.call(test, ".MiX") ? matches : false
        }

        return false
    },

    GET_ELEMENTS_BY_CLASS_NAME: function(test){
        test.innerHTML = '<a class="f"></a><a class="b"></a>'
        if (test.getElementsByClassName('b').length !== 1) return false

        test.firstChild.className = 'b'
        if (test.getElementsByClassName('b').length !== 2) return false

        // Opera 9.6 getElementsByClassName doesnt detects the class if its not the first one
        test.innerHTML = '<a class="a"></a><a class="f b a"></a>'
        if (test.getElementsByClassName('a').length !== 2) return false

        // tests passed
        return true
    },

    // no need to know

    // GET_ELEMENT_BY_ID_NOT_NAME: function(test, id){
    //     test.innerHTML = '<a name="'+ id +'"></a><b id="'+ id +'"></b>'
    //     return this.getElementById(id) !== test.firstChild
    // },

    // this is always checked for and fixed

    // STAR_GET_ELEMENTS_BY_TAG_NAME: function(test){
    //
    //     // IE returns comment nodes for getElementsByTagName('*') for some documents
    //     test.appendChild(this.createComment(''))
    //     if (test.getElementsByTagName('*').length > 0) return false
    //
    //     // IE returns closed nodes (EG:"</foo>") for getElementsByTagName('*') for some documents
    //     test.innerHTML = 'foo</foo>'
    //     if (test.getElementsByTagName('*').length) return false
    //
    //     // tests passed
    //     return true
    // },

    // this is always checked for and fixed

    // STAR_QUERY_SELECTOR: function(test){
    //
    //     // returns closed nodes (EG:"</foo>") for querySelector('*') for some documents
    //     test.innerHTML = 'foo</foo>'
    //     return !!(test.querySelectorAll('*').length)
    // },

    GET_ATTRIBUTE: function(test){
        // tests for working getAttribute implementation
        var shout = "fus ro dah"
        test.innerHTML = '<a class="' + shout + '"></a>'
        return test.firstChild.getAttribute('class') === shout
    }

}

// Finder

var Finder = function Finder(document){

    this.document        = document
    var root = this.root = document.documentElement
    this.tested          = {}

    // uniqueID

    this.uniqueID = this.has("EXPANDOS") ? uniqueID : uniqueIDXML

    // getAttribute

    this.getAttribute = (this.has("GET_ATTRIBUTE")) ? function(node, name){

        return node.getAttribute(name)

    } : function(node, name){

        node = node.getAttributeNode(name)
        return (node && node.specified) ? node.value : null

    }

    // hasAttribute

    this.hasAttribute = (root.hasAttribute) ? function(node, attribute){

        return node.hasAttribute(attribute)

    } : function(node, attribute) {

        node = node.getAttributeNode(attribute)
        return !!(node && node.specified)

    }

    // contains

    this.contains = (document.contains && root.contains) ? function(context, node){

        return context.contains(node)

    } : (root.compareDocumentPosition) ? function(context, node){

        return context === node || !!(context.compareDocumentPosition(node) & 16)

    } : function(context, node){

        do {
            if (node === context) return true
        } while ((node = node.parentNode))

        return false
    }

    // sort
    // credits to Sizzle (http://sizzlejs.com/)

    this.sorter = (root.compareDocumentPosition) ? function(a, b){

        if (!a.compareDocumentPosition || !b.compareDocumentPosition) return 0
        return a.compareDocumentPosition(b) & 4 ? -1 : a === b ? 0 : 1

    } : ('sourceIndex' in root) ? function(a, b){

        if (!a.sourceIndex || !b.sourceIndex) return 0
        return a.sourceIndex - b.sourceIndex

    } : (document.createRange) ? function(a, b){

        if (!a.ownerDocument || !b.ownerDocument) return 0
        var aRange = a.ownerDocument.createRange(),
            bRange = b.ownerDocument.createRange()

        aRange.setStart(a, 0)
        aRange.setEnd(a, 0)
        bRange.setStart(b, 0)
        bRange.setEnd(b, 0)
        return aRange.compareBoundaryPoints(Range.START_TO_END, bRange)

    } : null

    this.failed = {}

    var nativeMatches = this.has("MATCHES_SELECTOR")

    if (nativeMatches) this.matchesSelector = function(node, expression){

        if (this.failed[expression]) return null

        try {
            return nativeMatches.call(node, expression)
        } catch(e){
            if (slick.debug) console.warn("matchesSelector failed on " + expression)
            this.failed[expression] = true
            return null
        }

    }

    if (this.has("QUERY_SELECTOR")){

        this.querySelectorAll = function(node, expression){

            if (this.failed[expression]) return true

            var result, _id, _expression, _combinator, _node


            // non-document rooted QSA
            // credits to Andrew Dupont

            if (node !== this.document){

                _combinator = expression[0].combinator

                _id         = node.getAttribute("id")
                _expression = expression

                if (!_id){
                    _node = node
                    _id = "__slick__"
                    _node.setAttribute("id", _id)
                }

                expression = "#" + _id + " " + _expression


                // these combinators need a parentNode due to how querySelectorAll works, which is:
                // finding all the elements that match the given selector
                // then filtering by the ones that have the specified element as an ancestor
                if (_combinator.indexOf("~") > -1 || _combinator.indexOf("+") > -1){

                    node = node.parentNode
                    if (!node) result = true
                    // if node has no parentNode, we return "true" as if it failed, without polluting the failed cache

                }

            }

            if (!result) try {
                result = node.querySelectorAll(expression.toString())
            } catch(e){
                if (slick.debug) console.warn("querySelectorAll failed on " + (_expression || expression))
                result = this.failed[_expression || expression] = true
            }

            if (_node) _node.removeAttribute("id")

            return result

        }

    }

}

Finder.prototype.has = function(FEATURE){

    var tested        = this.tested,
        testedFEATURE = tested[FEATURE]

    if (testedFEATURE != null) return testedFEATURE

    var root     = this.root,
        document = this.document,
        testNode = document.createElement("div")

    testNode.setAttribute("style", "display: none;")

    root.appendChild(testNode)

    var TEST = HAS[FEATURE], result = false

    if (TEST) try {
        result = TEST.call(document, testNode)
    } catch(e){}

    if (slick.debug && !result) console.warn("document has no " + FEATURE)

    root.removeChild(testNode)

    return tested[FEATURE] = result

}

var combinators = {

    " ": function(node, part, push){

        var item, items

        var noId = !part.id, noTag = !part.tag, noClass = !part.classes

        if (part.id && node.getElementById && this.has("GET_ELEMENT_BY_ID")){
            item = node.getElementById(part.id)

            // return only if id is found, else keep checking
            // might be a tad slower on non-existing ids, but less insane

            if (item && item.getAttribute('id') === part.id){
                items = [item]
                noId = true
                // if tag is star, no need to check it in match()
                if (part.tag === "*") noTag = true
            }
        }

        if (!items){

            if (part.classes && node.getElementsByClassName && this.has("GET_ELEMENTS_BY_CLASS_NAME")){
                items = node.getElementsByClassName(part.classList)
                noClass = true
                // if tag is star, no need to check it in match()
                if (part.tag === "*") noTag = true
            } else {
                items = node.getElementsByTagName(part.tag)
                // if tag is star, need to check it in match because it could select junk, boho
                if (part.tag !== "*") noTag = true
            }

            if (!items || !items.length) return false

        }

        for (var i = 0; item = items[i++];)
            if ((noTag && noId && noClass && !part.attributes && !part.pseudos) || this.match(item, part, noTag, noId, noClass))
                push(item)

        return true

    },

    ">": function(node, part, push){ // direct children
        if ((node = node.firstChild)) do {
            if (node.nodeType == 1 && this.match(node, part)) push(node)
        } while ((node = node.nextSibling))
    },

    "+": function(node, part, push){ // next sibling
        while ((node = node.nextSibling)) if (node.nodeType == 1){
            if (this.match(node, part)) push(node)
            break
        }
    },

    "^": function(node, part, push){ // first child
        node = node.firstChild
        if (node){
            if (node.nodeType === 1){
                if (this.match(node, part)) push(node)
            } else {
                combinators['+'].call(this, node, part, push)
            }
        }
    },

    "~": function(node, part, push){ // next siblings
        while ((node = node.nextSibling)){
            if (node.nodeType === 1 && this.match(node, part)) push(node)
        }
    },

    "++": function(node, part, push){ // next sibling and previous sibling
        combinators['+'].call(this, node, part, push)
        combinators['!+'].call(this, node, part, push)
    },

    "~~": function(node, part, push){ // next siblings and previous siblings
        combinators['~'].call(this, node, part, push)
        combinators['!~'].call(this, node, part, push)
    },

    "!": function(node, part, push){ // all parent nodes up to document
        while ((node = node.parentNode)) if (node !== this.document && this.match(node, part)) push(node)
    },

    "!>": function(node, part, push){ // direct parent (one level)
        node = node.parentNode
        if (node !== this.document && this.match(node, part)) push(node)
    },

    "!+": function(node, part, push){ // previous sibling
        while ((node = node.previousSibling)) if (node.nodeType == 1){
            if (this.match(node, part)) push(node)
            break
        }
    },

    "!^": function(node, part, push){ // last child
        node = node.lastChild
        if (node){
            if (node.nodeType == 1){
                if (this.match(node, part)) push(node)
            } else {
                combinators['!+'].call(this, node, part, push)
            }
        }
    },

    "!~": function(node, part, push){ // previous siblings
        while ((node = node.previousSibling)){
            if (node.nodeType === 1 && this.match(node, part)) push(node)
        }
    }

}

Finder.prototype.search = function(context, expression, found){

    if (!context) context = this.document
    else if (!context.nodeType && context.document) context = context.document

    var expressions = parse(expression)

    // no expressions were parsed. todo: is this really necessary?
    if (!expressions || !expressions.length) throw new Error("invalid expression")

    if (!found) found = []

    var uniques, push = isArray(found) ? function(node){
        found[found.length] = node
    } : function(node){
        found[found.length++] = node
    }

    // if there is more than one expression we need to check for duplicates when we push to found
    // this simply saves the old push and wraps it around an uid dupe check.
    if (expressions.length > 1){
        uniques = {}
        var plush = push
        push = function(node){
            var uid = uniqueID(node)
            if (!uniques[uid]){
                uniques[uid] = true
                plush(node)
            }
        }
    }

    // walker

    var node, nodes, part

    main: for (var i = 0; expression = expressions[i++];){

        // querySelector

        // TODO: more functional tests

        // if there is querySelectorAll (and the expression does not fail) use it.
        if (!slick.noQSA && this.querySelectorAll){

            nodes = this.querySelectorAll(context, expression)
            if (nodes !== true){
                if (nodes && nodes.length) for (var j = 0; node = nodes[j++];) if (node.nodeName > '@'){
                    push(node)
                }
                continue main
            }
        }

        // if there is only one part in the expression we don't need to check each part for duplicates.
        // todo: this might be too naive. while solid, there can be expression sequences that do not
        // produce duplicates. "body div" for instance, can never give you each div more than once.
        // "body div a" on the other hand might.
        if (expression.length === 1){

            part = expression[0]
            combinators[part.combinator].call(this, context, part, push)

        } else {

            var cs = [context], c, f, u, p = function(node){
                var uid = uniqueID(node)
                if (!u[uid]){
                    u[uid] = true
                    f[f.length] = node
                }
            }

            // loop the expression parts
            for (var j = 0; part = expression[j++];){
                f = []; u = {}
                // loop the contexts
                for (var k = 0; c = cs[k++];) combinators[part.combinator].call(this, c, part, p)
                // nothing was found, the expression failed, continue to the next expression.
                if (!f.length) continue main
                cs = f // set the contexts for future parts (if any)
            }

            if (i === 0) found = f // first expression. directly set found.
            else for (var l = 0; l < f.length; l++) push(f[l]) // any other expression needs to push to found.
        }

    }

    if (uniques && found && found.length > 1) this.sort(found)

    return found

}

Finder.prototype.sort = function(nodes){
    return this.sorter ? Array.prototype.sort.call(nodes, this.sorter) : nodes
}

// TODO: most of these pseudo selectors include <html> and qsa doesnt. fixme.

var pseudos = {


    // TODO: returns different results than qsa empty.

    'empty': function(){
        return !(this && this.nodeType === 1) && !(this.innerText || this.textContent || '').length
    },

    'not': function(expression){
        return !slick.matches(this, expression)
    },

    'contains': function(text){
        return (this.innerText || this.textContent || '').indexOf(text) > -1
    },

    'first-child': function(){
        var node = this
        while ((node = node.previousSibling)) if (node.nodeType == 1) return false
        return true
    },

    'last-child': function(){
        var node = this
        while ((node = node.nextSibling)) if (node.nodeType == 1) return false
        return true
    },

    'only-child': function(){
        var prev = this
        while ((prev = prev.previousSibling)) if (prev.nodeType == 1) return false

        var next = this
        while ((next = next.nextSibling)) if (next.nodeType == 1) return false

        return true
    },

    'first-of-type': function(){
        var node = this, nodeName = node.nodeName
        while ((node = node.previousSibling)) if (node.nodeName == nodeName) return false
        return true
    },

    'last-of-type': function(){
        var node = this, nodeName = node.nodeName
        while ((node = node.nextSibling)) if (node.nodeName == nodeName) return false
        return true
    },

    'only-of-type': function(){
        var prev = this, nodeName = this.nodeName
        while ((prev = prev.previousSibling)) if (prev.nodeName == nodeName) return false
        var next = this
        while ((next = next.nextSibling)) if (next.nodeName == nodeName) return false
        return true
    },

    'enabled': function(){
        return !this.disabled
    },

    'disabled': function(){
        return this.disabled
    },

    'checked': function(){
        return this.checked || this.selected
    },

    'selected': function(){
        return this.selected
    },

    'focus': function(){
        var doc = this.ownerDocument
        return doc.activeElement === this && (this.href || this.type || slick.hasAttribute(this, 'tabindex'))
    },

    'root': function(){
        return (this === this.ownerDocument.documentElement)
    }

}

Finder.prototype.match = function(node, bit, noTag, noId, noClass){

    // TODO: more functional tests ?

    if (!slick.noQSA && this.matchesSelector){
        var matches = this.matchesSelector(node, bit)
        if (matches !== null) return matches
    }

    // normal matching

    if (!noTag && bit.tag){

        var nodeName = node.nodeName.toLowerCase()
        if (bit.tag === "*"){
            if (nodeName < "@") return false
        } else if (nodeName != bit.tag){
            return false
        }

    }

    if (!noId && bit.id && node.getAttribute('id') !== bit.id) return false

    var i, part

    if (!noClass && bit.classes){

        var className = this.getAttribute(node, "class")
        if (!className) return false

        for (part in bit.classes) if (!RegExp('(^|\\s)' + bit.classes[part] + '(\\s|$)').test(className)) return false
    }

    var name, value

    if (bit.attributes) for (i = 0; part = bit.attributes[i++];){

        var operator  = part.operator,
            escaped   = part.escapedValue

        name  = part.name
        value = part.value

        if (!operator){

            if (!this.hasAttribute(node, name)) return false

        } else {

            var actual = this.getAttribute(node, name)
            if (actual == null) return false

            switch (operator){
                case '^=' : if (!RegExp(      '^' + escaped            ).test(actual)) return false; break
                case '$=' : if (!RegExp(            escaped + '$'      ).test(actual)) return false; break
                case '~=' : if (!RegExp('(^|\\s)' + escaped + '(\\s|$)').test(actual)) return false; break
                case '|=' : if (!RegExp(      '^' + escaped + '(-|$)'  ).test(actual)) return false; break

                case '='  : if (actual !== value) return false; break
                case '*=' : if (actual.indexOf(value) === -1) return false; break
                default   : return false
            }

        }
    }

    if (bit.pseudos) for (i = 0; part = bit.pseudos[i++];){

        name  = part.name
        value = part.value

        if (pseudos[name]) return pseudos[name].call(node, value)

        if (value != null){
            if (this.getAttribute(node, name) !== value) return false
        } else {
            if (!this.hasAttribute(node, name)) return false
        }

    }

    return true

}

Finder.prototype.matches = function(node, expression){

    var expressions = parse(expression)

    if (expressions.length === 1 && expressions[0].length === 1){ // simplest match
        return this.match(node, expressions[0][0])
    }

    // TODO: more functional tests ?

    if (!slick.noQSA && this.matchesSelector){
        var matches = this.matchesSelector(node, expressions)
        if (matches !== null) return matches
    }

    var nodes = this.search(this.document, expression, {length: 0})

    for (var i = 0, res; res = nodes[i++];) if (node === res) return true
    return false

}

var finders = {}

var finder = function(context){
    var doc = context || document
    if (doc.ownerDocument) doc = doc.ownerDocument
    else if (doc.document) doc = doc.document

    if (doc.nodeType !== 9) throw new TypeError("invalid document")

    var uid = uniqueID(doc)
    return finders[uid] || (finders[uid] = new Finder(doc))
}

// ... API ...

var slick = function(expression, context){
    return slick.search(expression, context)
}

slick.search = function(expression, context, found){
    return finder(context).search(context, expression, found)
}

slick.find = function(expression, context){
    return finder(context).search(context, expression)[0] || null
}

slick.getAttribute = function(node, name){
    return finder(node).getAttribute(node, name)
}

slick.hasAttribute = function(node, name){
    return finder(node).hasAttribute(node, name)
}

slick.contains = function(context, node){
    return finder(context).contains(context, node)
}

slick.matches = function(node, expression){
    return finder(node).matches(node, expression)
}

slick.sort = function(nodes){
    if (nodes && nodes.length > 1) finder(nodes[0]).sort(nodes)
    return nodes
}

slick.parse = parse;

// slick.debug = true
// slick.noQSA  = true

module.exports = slick

},{"./parser":469}],468:[function(require,module,exports){
(function (global){
/*
slick
*/"use strict"

module.exports = "document" in global ? require("./finder") : { parse: require("./parser") }

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./finder":467,"./parser":469}],469:[function(require,module,exports){
/*
Slick Parser
 - originally created by the almighty Thomas Aylott <@subtlegradient> (http://subtlegradient.com)
*/"use strict"

// Notable changes from Slick.Parser 1.0.x

// The parser now uses 2 classes: Expressions and Expression
// `new Expressions` produces an array-like object containing a list of Expression objects
// - Expressions::toString() produces a cleaned up expressions string
// `new Expression` produces an array-like object
// - Expression::toString() produces a cleaned up expression string
// The only exposed method is parse, which produces a (cached) `new Expressions` instance
// parsed.raw is no longer present, use .toString()
// parsed.expression is now useless, just use the indices
// parsed.reverse() has been removed for now, due to its apparent uselessness
// Other changes in the Expressions object:
// - classNames are now unique, and save both escaped and unescaped values
// - attributes now save both escaped and unescaped values
// - pseudos now save both escaped and unescaped values

var escapeRe   = /([-.*+?^${}()|[\]\/\\])/g,
    unescapeRe = /\\/g

var escape = function(string){
    // XRegExp v2.0.0-beta-3
    // « https://github.com/slevithan/XRegExp/blob/master/src/xregexp.js
    return (string + "").replace(escapeRe, '\\$1')
}

var unescape = function(string){
    return (string + "").replace(unescapeRe, '')
}

var slickRe = RegExp(
/*
#!/usr/bin/env ruby
puts "\t\t" + DATA.read.gsub(/\(\?x\)|\s+#.*$|\s+|\\$|\\n/,'')
__END__
    "(?x)^(?:\
      \\s* ( , ) \\s*               # Separator          \n\
    | \\s* ( <combinator>+ ) \\s*   # Combinator         \n\
    |      ( \\s+ )                 # CombinatorChildren \n\
    |      ( <unicode>+ | \\* )     # Tag                \n\
    | \\#  ( <unicode>+       )     # ID                 \n\
    | \\.  ( <unicode>+       )     # ClassName          \n\
    |                               # Attribute          \n\
    \\[  \
        \\s* (<unicode1>+)  (?:  \
            \\s* ([*^$!~|]?=)  (?:  \
                \\s* (?:\
                    ([\"']?)(.*?)\\9 \
                )\
            )  \
        )?  \\s*  \
    \\](?!\\]) \n\
    |   :+ ( <unicode>+ )(?:\
    \\( (?:\
        (?:([\"'])([^\\12]*)\\12)|((?:\\([^)]+\\)|[^()]*)+)\
    ) \\)\
    )?\
    )"
*/
"^(?:\\s*(,)\\s*|\\s*(<combinator>+)\\s*|(\\s+)|(<unicode>+|\\*)|\\#(<unicode>+)|\\.(<unicode>+)|\\[\\s*(<unicode1>+)(?:\\s*([*^$!~|]?=)(?:\\s*(?:([\"']?)(.*?)\\9)))?\\s*\\](?!\\])|(:+)(<unicode>+)(?:\\((?:(?:([\"'])([^\\13]*)\\13)|((?:\\([^)]+\\)|[^()]*)+))\\))?)"
    .replace(/<combinator>/, '[' + escape(">+~`!@$%^&={}\\;</") + ']')
    .replace(/<unicode>/g, '(?:[\\w\\u00a1-\\uFFFF-]|\\\\[^\\s0-9a-f])')
    .replace(/<unicode1>/g, '(?:[:\\w\\u00a1-\\uFFFF-]|\\\\[^\\s0-9a-f])')
)

// Part

var Part = function Part(combinator){
    this.combinator = combinator || " "
    this.tag = "*"
}

Part.prototype.toString = function(){

    if (!this.raw){

        var xpr = "", k, part

        xpr += this.tag || "*"
        if (this.id) xpr += "#" + this.id
        if (this.classes) xpr += "." + this.classList.join(".")
        if (this.attributes) for (k = 0; part = this.attributes[k++];){
            xpr += "[" + part.name + (part.operator ? part.operator + '"' + part.value + '"' : '') + "]"
        }
        if (this.pseudos) for (k = 0; part = this.pseudos[k++];){
            xpr += ":" + part.name
            if (part.value) xpr += "(" + part.value + ")"
        }

        this.raw = xpr

    }

    return this.raw
}

// Expression

var Expression = function Expression(){
    this.length = 0
}

Expression.prototype.toString = function(){

    if (!this.raw){

        var xpr = ""

        for (var j = 0, bit; bit = this[j++];){
            if (j !== 1) xpr += " "
            if (bit.combinator !== " ") xpr += bit.combinator + " "
            xpr += bit
        }

        this.raw = xpr

    }

    return this.raw
}

var replacer = function(
    rawMatch,

    separator,
    combinator,
    combinatorChildren,

    tagName,
    id,
    className,

    attributeKey,
    attributeOperator,
    attributeQuote,
    attributeValue,

    pseudoMarker,
    pseudoClass,
    pseudoQuote,
    pseudoClassQuotedValue,
    pseudoClassValue
){

    var expression, current

    if (separator || !this.length){
        expression = this[this.length++] = new Expression
        if (separator) return ''
    }

    if (!expression) expression = this[this.length - 1]

    if (combinator || combinatorChildren || !expression.length){
        current = expression[expression.length++] = new Part(combinator)
    }

    if (!current) current = expression[expression.length - 1]

    if (tagName){

        current.tag = unescape(tagName)

    } else if (id){

        current.id = unescape(id)

    } else if (className){

        var unescaped = unescape(className)

        var classes = current.classes || (current.classes = {})
        if (!classes[unescaped]){
            classes[unescaped] = escape(className)
            var classList = current.classList || (current.classList = [])
            classList.push(unescaped)
            classList.sort()
        }

    } else if (pseudoClass){

        pseudoClassValue = pseudoClassValue || pseudoClassQuotedValue

        ;(current.pseudos || (current.pseudos = [])).push({
            type         : pseudoMarker.length == 1 ? 'class' : 'element',
            name         : unescape(pseudoClass),
            escapedName  : escape(pseudoClass),
            value        : pseudoClassValue ? unescape(pseudoClassValue) : null,
            escapedValue : pseudoClassValue ? escape(pseudoClassValue) : null
        })

    } else if (attributeKey){

        attributeValue = attributeValue ? escape(attributeValue) : null

        ;(current.attributes || (current.attributes = [])).push({
            operator     : attributeOperator,
            name         : unescape(attributeKey),
            escapedName  : escape(attributeKey),
            value        : attributeValue ? unescape(attributeValue) : null,
            escapedValue : attributeValue ? escape(attributeValue) : null
        })

    }

    return ''

}

// Expressions

var Expressions = function Expressions(expression){
    this.length = 0

    var self = this

    var original = expression, replaced

    while (expression){
        replaced = expression.replace(slickRe, function(){
            return replacer.apply(self, arguments)
        })
        if (replaced === expression) throw new Error(original + ' is an invalid expression')
        expression = replaced
    }
}

Expressions.prototype.toString = function(){
    if (!this.raw){
        var expressions = []
        for (var i = 0, expression; expression = this[i++];) expressions.push(expression)
        this.raw = expressions.join(", ")
    }

    return this.raw
}

var cache = {}

var parse = function(expression){
    if (expression == null) return null
    expression = ('' + expression).replace(/^\s+|\s+$/g, '')
    return cache[expression] || (cache[expression] = new Expressions(expression))
}

module.exports = parse

},{}],470:[function(require,module,exports){
(function() {
  /**
   * @file
   * Introduces a function called "defer" that allows functions to be
   * executed in the next available tick.
   *
   * Unlike "setTimeout", "defer" executes the function at the nearest
   * possible time without clamping.
   *
   * @see Spotify.defer
   */
  'use strict';

  var hasWindow = typeof window != 'undefined';
  var hasDefineProperty = typeof Object.defineProperty == 'function';

  if (hasWindow && window.__modDefFn) {
    // If deferred has been attached to the global scope
    module.exports = window.__modDefFn;
    return;
  }

  /**
   * Storage for deferred functions to be executed.
   *
   * @type {Array.<function()>}
   * @private
   */
  var deferred = [];


  /**
   * A bound version of the postMessage routine used to trigger deferred
   * execution.
   *
   * @type {function()}
   * @private
   */
  var send;
  var origin;

  function bindSendDom() {
    origin = (window.location.origin ||
          window.location.protocol + '//' + window.location.hostname);
    send = window.postMessage.bind(window, '@execute_deferreds', origin);
    if (!window.__hasDeferredHandler) {
      if (hasDefineProperty) {
        Object.defineProperty(window, '__hasDeferredHandler', {value: 1});
      } else {
        window.__hasDeferredHandler = 1;
      }
      var handler = function(e) {
        if (e.origin != origin && e.data != '@execute_deferreds') {
          return;
        }
        executeDeferreds();
      };
      if (window.addEventListener) {
        window.addEventListener('message', handler);
      } else {
        window.attachEvent('onmessage', handler);
      }
    }
  }

  function bindSendImmediate() {
    send = setImmediate.bind(null, executeDeferreds);
  }

  function bindSendTimeout() {
    send = setTimeout.bind(null, executeDeferreds, 10);
  }

  function bindSendAuto() {
    if (hasWindow && window.postMessage) {
      bindSendDom();
    } else if (typeof setImmediate != 'undefined') {
      bindSendImmediate();
    } else {
      bindSendTimeout();
    }
  }

  bindSendAuto();

  /**
   * Executes the deferred functions when the window
   * receives an 'execute_deferreds' message.
   *
   * @private
   */
  function executeDeferreds() {
    var fns = deferred.splice(0);
    if (!fns.length) return;
    for (var i = 0, l = fns.length; i < l; i++) {
      try {
        fns[i]();
      } finally {
        // Do nothing.
        null;
      }
    }
  }


  /**
   * Executes the function applied at the nearest possible time without
   * clamping.
   *
   * @param {function()} fn The function to execute.
   */
  var defer = function(fn) {
    var trigger = !deferred.length;
    deferred.push(fn);
    if (trigger) send();
  };

  if (hasWindow && !window.__modDefFn) {
    if (hasDefineProperty) {
      Object.defineProperty(window, '__modDefFn', {value: defer});
    } else {
      window.__modDefFn = defer;
    }
  }

  /**
   * Export interface for binding send method to a particular implementation,
   * which is intended primarily for use by integration tests where the send method
   * can be explicitly set to immediate/timeout, even if mock DOM globals exist.
   */
  defer.use = {
    auto: bindSendAuto,
    dom: bindSendDom,
    immediate: bindSendImmediate,
    timeout: bindSendTimeout,
  };

  /**
   * Export public interface
   */
  module.exports = defer;

})();

},{}],471:[function(require,module,exports){
'use strict';

var hasDefineProperty = typeof Object.defineProperty === 'function';

var DEFAULT_DESCRIPTOR = {
  value: false,
  writable: true
};

/**
 * Represents an Event.
 *
 * **NOTE**: The Event class is an internal class: you cannot instantiate it
 * directly. Instead, you should use the provided
 * {@link module:spotify-eventemitter.createEvent} function.
 *
 * @constructor
 * @param {string} type The type name of the event object.
 * @param {Object} props An object that will be added as properties of the
 *     event object.
 * @see {@link module:spotify-eventemitter.createEvent}
 */
function Event(type, props) {
  /**
   * The type of the event.
   *
   * @type {string}
   */
  this.type = type;

  // Parse the extra event properties. We do this before setting the internal
  // flags in case `props` is actually an Event instance. It makes it easier for
  // us to override the flags later.
  if (props) {
    for (var key in props) {
      if (!props.hasOwnProperty(key) || key == 'type') {
        continue;
      }
      this[key] = props[key];
    }
  }

  if (hasDefineProperty) {
    Object.defineProperty(this, '_prevented', DEFAULT_DESCRIPTOR);
    Object.defineProperty(this, '_stopped', DEFAULT_DESCRIPTOR);
    Object.defineProperty(this, '_immediateStopped', DEFAULT_DESCRIPTOR);
    Object.defineProperty(this, 'defaultPrevented', {
      get: function() {
        return this._prevented;
      }.bind(this),
      set: function(value) {
        return value;
      }
    });
  } else {
    /**
     * External property that indicates whether the event's `preventDefault` 
     * method was called.
     *
     * @type {boolean}
     * @public
     */
    this.defaultPrevented = false;

    /**
     * An internal flag for whether preventDefault was called.
     *
     * @type {boolean}
     * @private
     */
    this._prevented = false;

    /**
     * An internal flag for whether stopPropagation was called
     *
     * @type {boolean}
     * @private
     */
    this._stopped = false;

    /**
     * An internal flag for whether stopImmediatePropagation was called.
     *
     * @type {boolean}
     * @private
     */
    this._immediateStopped = false;
  }
}

/**
 * Returns whether stopPropagation was called on the event.
 *
 * @param {Event} ev The event.
 * @return {boolean} True if stopPropagation was called, false otherwise.
 */
Event.wasPropagationStopped = function(ev) {
  return !!ev._stopped;
};

/**
 * Returns whether stopImmediatePropagation was called on the event.
 *
 * @param {Event} ev The event.
 * @return {boolean} True if stopImmediatePropagation was called, false
 *     otherwise.
 */
Event.wasImmediatePropagationStopped = function(ev) {
  return !!ev._immediateStopped;
};

/**
 * Prevents the default operation for the event.
 */
Event.prototype.preventDefault = function() {
  this._prevented = true;
  if (!hasDefineProperty) {
    this.defaultPrevented = true;
  }
};

/**
 * Stops the propagation of the event.
 */
Event.prototype.stopPropagation = function() {
  this._stopped = true;
};

/**
 * Stops the immediate propagation of the event.
 *
 * Handlers added after any event handler calling this method will not receive
 * the event.
 */
Event.prototype.stopImmediatePropagation = function() {
  this._immediateStopped = true;
};

module.exports = Event;

},{}],472:[function(require,module,exports){
/**
 * @module spotify-eventemitter
 */
'use strict';

/**
 * @private
 */
var _defer = require('spotify-deferred');
var Event = require('./_internal/event');

/**
 * The prefixes added for metalisteners.
 *
 * @const {string}
 * @private
 */
var InternalPrefix = {
  ADD: 'add:',
  REMOVE: 'remove:'
};

/**
 * A function that takes in an event.
 *
 * @typedef {function(Event)}
 * @private
 */
var EventHandler;

/**
 * The event handlers.
 *
 * @typedef {Array.<function>}
 * @private
 */
var EventHandlers;

/**
 * An EventEmitter is an object that can be listened to for events.
 *
 * Instances of this class are not usually used directly; instead, a class that
 * needs EventEmitter functionality would inherit from the EventEmitter class
 * so that it's instances can use events.
 *
 * @constructor
 * @alias module:spotify-eventemitter
 *
 * @example <caption>Direct usage</caption>
 * var EventEmitter = require('spotify-eventemitter');
 * var emitter = new EventEmitter();
 * emitter.on('someEvent', function() {
 *     console.log('someEvent fired!');
 * });
 * emitter.emit('someEvent');
 * @example <caption>Inheritance</caption>
 * var EventEmitter = require('spotify-eventemitter');
 * var inherit = require('spotify-inherit/inherit');
 *
 * function MyClass() {
 *   EventEmitter.call(this);
 * }
 * inherit(MyClass, EventEmitter);
 *
 * var instance = new MyClass();
 * instance.on('someEvent', function() {
 *     console.log('someEvent fired!');
 * });
 * instance.emit('someEvent');
 */
function EventEmitter() {
  /**
   * A map of event names to event handlers.
   *
   * @type {Object.<string, module:spotify-eventemitter~EventHandlers>}
   * @private
   */
  this._listenerMap = {};
}

/**
 * Creates a new Event object.
 *
 * @param {string} type The type name of the event.
 * @param {Object=} opt_params An object containing properties for the new event
 *     object.
 * @return {module:spotify-eventemitter~Event} The new event object.
 */
EventEmitter.createEvent = function(type, opt_params) {
  if (!type) {
    throw new TypeError('Cannot create event with empty type.');
  }
  return new Event(type, opt_params);
};

/**
 * Returns whether there are listeners for a given event.
 *
 */
EventEmitter.prototype._hasListenersFor = function(type) {
  var _listenerMap = this._listenerMap;
  var listeners = _listenerMap && _listenerMap[type];
  return !!(listeners && listeners.length);
};

/**
 * Adds an event listener to the emitter.
 *
 * This method is idempotent: calling it multiple times using the same type
 * and listener arguments will only set the listener once. This behaviour is
 * done to prevent accidental additions of the same event listener.
 *
 * @param {string} type The type of event to listen to.
 * @param {function} listener A function to be called when the emitter fires
 *     the event specified in the type.
 * @return {module:spotify-eventemitter} The event emitter.
 */
EventEmitter.prototype.on = function(type, listener) {
  if (!type) {
    throw new TypeError('Cannot add event listener with empty type.');
  }
  var _listenerMap = this._listenerMap || (this._listenerMap = {});
  var listeners = _listenerMap[type] || (_listenerMap[type] = []);
  if (listeners.indexOf(listener) != -1) {
    // Handler already added, return quickly.
    return this;
  }
  var metaListenerType = InternalPrefix.ADD + type;
  if (this._hasListenersFor(metaListenerType)) {
    var event = this.emitSync(metaListenerType, {listener: listener});
    if (event.defaultPrevented) {
      return this;
    }
  }
  listeners.push(listener);
  return this;
};

/**
 * Adds a "once" event listener to the emitter, which will be removed right
 * after it has been fired.
 *
 * In order to achieve the "once" behaviour, the listener argument passed to
 * this method is wrapped in a function, which is then returned by the method.
 *
 * Because of this wrapping, this method is not idempotent: calling it multiple
 * times with the same type and listener arguments will result to multiple
 * event listeners attached.
 *
 * @param {string} type The type of event to listen to.
 * @param {function} listener A function to be called when the emitter fires
 *     the event specified in the type and then automatically removed.
 * @return {function} The function used to wrap the listener function argument.
 *     This function can be used as an argument to removeEvent.
 */
EventEmitter.prototype.once = function(type, listener) {
  if (!type) {
    throw new TypeError('Cannot add once listener with empty type.');
  }
  var wrapper = function() {
    this.removeListener(type, wrapper);
    return listener.apply(this, arguments);
  };
  this.on(type, wrapper);
  return wrapper;
};

/**
 * Adds multiple event listeners to the emitter.
 *
 * @param {Object.<string, function>} eventListeners An object, the keys of
 *     which correspond to the name of events to listen to, and the value of
 *     each of these keys should be a function that would be added as the
 *     listener for that event.
 * @return {module:spotify-eventemitter} The event emitter.
 */
EventEmitter.prototype.addListeners = function(eventListeners) {
  for (var type in eventListeners) {
    this.on(type, eventListeners[type]);
  }
  return this;
};

/**
 * Removes an event listener from the emitter.
 *
 * @param {string} type The type of event to remove.
 * @param {function} listener The listener function to remove. This must be a
 *     function that was added previously using addEvent.
 * @return {module:spotify-eventemitter} The event emitter.
 */
EventEmitter.prototype.removeListener = function(type, listener) {
  var _listenerMap = this._listenerMap;
  var listeners = _listenerMap && _listenerMap[type];
  if (!listeners) {
    return this;
  }
  var index = listeners.indexOf(listener);
  if (index == -1) {
    return this;
  }
  var metaListenerType = InternalPrefix.REMOVE + type;
  if (this._hasListenersFor(metaListenerType)) {
    var event = this.emitSync(metaListenerType, {
      listener: listener,
      remainingLength: listeners.length - 1
    });
    if (event.defaultPrevented) {
      return this;
    }
  }
  listeners.splice(index, 1);
  if (!listeners.length) {
    _listenerMap[type] = null;
  }
  return this;
};

/**
 * Removes all event listeners from the emitter for a particular type.
 * If no event type is given, all event listeners will be removed.
 *
 * @param {string=} opt_type The event type to remove.
 * @return {module:spotify-eventemitter} The event emitter.
 */
EventEmitter.prototype.removeAllListeners = function(opt_type) {
  var _listenerMap = this._listenerMap;
  if (!_listenerMap) {
    return this;
  }
  if (opt_type === undefined) {
    this._listenerMap = {};
    return this;
  }
  _listenerMap[opt_type] = null;
  return this;
};

/**
 * Removes multiple event listeners from the emitter.
 *
 * @param {Object.<string, function>} eventListeners An object, the keys of
 *     which correspond to the name of events to listen to, and the value of
 *     each of these keys should be a function that would be added as the
 *     listener for that event.
 * @return {module:spotify-eventemitter} The event emitter.
 */
EventEmitter.prototype.removeListeners = function(eventListeners) {
  for (var type in eventListeners) {
    this.removeListener(type, eventListeners[type]);
  }
  return this;
};

// ALIASES

/**
 * Adds an event listener to the emitter.
 *
 * **NOTE**: This method is an alias of
 * {@link module:spotify-eventemitter#on}.
 *
 * This method is idempotent: calling it multiple times using the same type
 * and listener arguments will only set the listener once. This behaviour is
 * done to prevent accidental additions of the same event listener.
 *
 * @param {string} type The type of event to listen to.
 * @param {function} listener A function to be called when the emitter fires
 *     the event specified in the type.
 * @return {module:spotify-eventemitter} The event emitter.
 * @see {@link module:spotify-eventemitter#on}
 */
EventEmitter.prototype.addListener = function(type, listener) {
  return this.on(type, listener);
};

/**
 * Adds a "once" event listener to the emitter, which will be removed right
 * after it has been fired.
 *
 * **NOTE**: This method is an alias of
 * {@link module:spotify-eventemitter#once}.
 *
 * In order to achieve the "once" behaviour, the listener argument passed to
 * this method is wrapped in a function, which is then returned by the method.
 *
 * Because of this wrapping, this method is not idempotent: calling it multiple
 * times with the same type and listener arguments will result to multiple
 * event listeners attached.
 *
 * @param {string} type The type of event to listen to.
 * @param {function} listener A function to be called when the emitter fires
 *     the event specified in the type and then automatically removed.
 * @return {function} The function used to wrap the listener function argument.
 *     This function can be used as an argument to removeEvent.
 * @see {@link module:spotify-eventemitter#once}
 */
EventEmitter.prototype.addOnceListener = function(type, listener) {
  return this.once(type, listener);
};

/**
 * Creates and emits an event on the emitter.
 *
 * This method invokes all the added event listeners of the `type` provided in
 * the order they were added, passing in a new Event object created using the
 * provided `type` and `opt_params` arguments.
 *
 * This method emits events asynchronously: the listeners are not called until
 * the next run loop.
 *
 * @param {string} type The type name of the event to emit.
 * @param {Object=} opt_params An object containing parameters for the Event
 *     object.
 * @return {module:spotify-eventemitter~Event} The Event object that was
 *     created.
 */
EventEmitter.prototype.emit = function(type, opt_params) {
  if (!type) {
    throw new TypeError('Cannot emit empty type event.');
  }
  var event = new Event(type, opt_params);
  _defer(function() {
    this.emitEventSync(event);
  }.bind(this));
  return event;
};

/**
 * Emits an event like the `emit` method, but then calls a provided function
 * after all the event listeners have been called.
 *
 * @param {string} type The type name of the event to emit.
 * @param {Object=} opt_params An object containing parameters for the Event
 *     object.
 * @param {EventHandler} done An event handler that will be called after all of
 *     the event handlers have been called.
 * @return {module:spotify-eventemitter~Event} The Event object that was
 *     created.
 */
EventEmitter.prototype.emitAndWait = function(type, opt_params, done) {
  if (!type) {
    throw new TypeError('Cannot emit empty type event.');
  }
  var event = new Event(type, opt_params);
  _defer(function() {
    this.emitEventSync(event);
    if (typeof done === 'function') {
      done(event);
    }
  }.bind(this));
  return event;
};

/**
 * Emits an event on the emitter.
 *
 * This method invokes all the added event listeners of the `type` of the
 * `event` provided in the order they were added, passing in the `event` as an
 * argument.
 *
 * This method emits events asynchronously: the listeners are not called until
 * the next run loop.
 *
 * @param {module:spotify-eventemitter~Event} event The Event object.
 * @return {module:spotify-eventemitter~Event} The Event object that was passed.
 */
EventEmitter.prototype.emitEvent = function(event) {
  _defer(function() {
    this.emitEventSync(event);
  }.bind(this));
  return event;
};

/**
 * Emits an event like `emitEvent`, but then calls a provided function after all
 * the event listeners have been called.
 *
 * @param {module:spotify-eventemitter~Event} event The Event object.
 * @param {EventHandler} done An event handler that will be called after all of
 *     the event handlers have been called.
 * @return {module:spotify-eventemitter~Event} The Event object that was passed.
 */
EventEmitter.prototype.emitEventAndWait = function(event, done) {
  _defer(function() {
    this.emitEventSync(event);
    if (typeof done === 'function') {
      done(event);
    }
  }.bind(this));
  return event;
};

/**
 * Creates and synchronously emits an event on the emitter.
 *
 * This method invokes all the added event listeners of the `type` provided in
 * the order they were added, passing in a new Event object created using the
 * provided `type` and `opt_params` arguments.
 *
 * @param {string} type The type name of event to emit.
 * @param {Object=} opt_params An object containing parameters for the event
 *     object.
 * @return {module:spotify-eventemitter~Event} The Event object that was
 *     created.
 */
EventEmitter.prototype.emitSync = function(type, opt_params) {
  var event = new Event(type, opt_params);
  this.emitEventSync(event);
  return event;
};

/**
 * Synchronously emits an event on the emitter.
 *
 * This method invokes all the added event listeners of the `type` of the
 * `event` provided in the order they were added, passing in the `event` as an
 * argument.
 *
 * @param {module:spotify-eventemitter~Event} event The Event object.
 * @return {module:spotify-eventemitter~Event} The Event object that was passed.
 */
EventEmitter.prototype.emitEventSync = function(event) {
  var type = event.type;
  var _listenerMap = this._listenerMap;
  var listeners = _listenerMap && _listenerMap[type];
  if (!listeners || !listeners.length) {
    return event;
  }
  listeners = listeners.slice(0);
  for (var i = 0, l = listeners.length; i < l; i++) {
    listeners[i].call(this, event);
    if (Event.wasImmediatePropagationStopped(event)) {
      break;
    }
  }
  return event;
};

/**
 * Proxies an event from another `EventEmitter` instance.
 *
 * This is used when we want to redirect events from internal objects to the
 * wrapping object. For example, if we have EventEmitter `A` that is referenced
 * inside EventEmitter `B` and we want to "re-emit" the event `A#eventName` as
 * `B#otherEventName`, we can call B.proxyEmit(A, 'eventName', 'otherEventName')
 *
 * @param {EventEmitter} source The EventEmitter source of the event.
 * @param {string} sourceType The type of event from the source to redirect.
 * @param {string} proxyType The type of event to fire for the current instance
 *     when `sourceType` is fired by `source`.
 * @return {EventEmitter} The current object.
 */
EventEmitter.prototype.proxyEmit = function(source, sourceType, proxyType) {
  if (!source || typeof source.on !== 'function') {
    throw new TypeError('Source must be an EventEmitter');
  }
  if (source === this) {
    throw new ReferenceError('Cannot create a recursive proxy.');
  }
  if (!sourceType || !proxyType) {
    throw new TypeError('Parameters sourceType and proxyType are required.');
  }
  source.on(sourceType, this.emit.bind(this, proxyType));
  return this;
};

/**
 * A synchronous version of `proxyEmit` (see that method for details).
 *
 * @param {EventEmitter} source The EventEmitter source of the event.
 * @param {string} sourceType The type of event from the source to redirect.
 * @param {string} proxyType The type of event to fire for the current instance
 *     when `sourceType` is fired by `source`.
 * @return {EventEmitter} The current object.
 */
EventEmitter.prototype.proxyEmitSync = function(source, sourceType, proxyType) {
  if (!source || typeof source.on !== 'function') {
    throw new TypeError('Source must be an EventEmitter');
  }
  if (source === this) {
    throw new ReferenceError('Cannot create a recursive proxy.');
  }
  if (!sourceType || !proxyType) {
    throw new TypeError('Parameters sourceType and proxyType are required.');
  }
  source.on(sourceType, this.emitSync.bind(this, proxyType));
  return this;
};

/**
 * Adds a "meta-listener" that will be called every time an event listener for
 * the given type is added to the EventEmitter.
 *
 * @param {string} type The type of event to listen for.
 * @param {function} listener A function that will be called when an event
 *     listener for the given type is added to the emitter.
 * @return {EventEmitter} The current object.
 */
EventEmitter.prototype.onAddListener = function(type, listener) {
  this.on(InternalPrefix.ADD + type, listener);
  return this;
};

/**
 * Adds a "meta-listener" that will be called every time an event listener for
 * the given type is removed from the EventEmitter.
 *
 * @param {string} type The type of event we were listening for.
 * @param {function} listener A function that will be called when an event
 *     listener for the given type is removed from the emitter.
 * @return {EventEmitter} The current object.
 */
EventEmitter.prototype.onRemoveListener = function(type, listener) {
  this.on(InternalPrefix.REMOVE + type, listener);
  return this;
};

module.exports = EventEmitter;

},{"./_internal/event":471,"spotify-deferred":470}],473:[function(require,module,exports){
'use strict';

/**
 * Makes a class inherit from a superclass' prototype indirectly.
 *
 * @param {Spotify.ClassLike} Sub The class that will inherit.
 * @param {Spotify.ClassLike} Super The class to inherit from.
 */
var inherit = function(Sub, Super) {
  var superProto = Super.prototype;
  function Superclass() {}
  Superclass.prototype = Sub._super = superProto;
  Superclass.prototype.constructor = Super;
  Sub.prototype = new Superclass();
};


/**
 * Export public interface
 */
module.exports = inherit;

},{}],474:[function(require,module,exports){
/**
 * Copyright (c) 2017 Spotify AB
 *
 * Fast base62 encoder/decoder.
 *
 * Usage:
 *
 *   Base62.toHex('1C0pasJ0dS2Z46GKh2puYo') // -> '34ff970885ca8fa02c0d6e459377d5d0'
 *                         ^^^
 *                          |
 *               Length-22 base62-encoded ID.
 *         Lengths other than 22 or invalid base62 IDs
 *                  are not supported.
 *
 *   Base62.fromHex('34ff970885ca8fa02c0d6e459377d5d0') // -> '1C0pasJ0dS2Z46GKh2puYo'
 *                         ^^^
 *                          |
 *               Length-32 hex-encoded ID.
 *         Lengths other than 32 are not supported.
 *
 * Written by @ludde, programatically tested and documented by @felipec.
 */
(function() {
  // Alphabets
  var HEX16 = '0123456789abcdef';
  var BASE62 =
    '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';

  // Hexadecimal fragments
  var HEX256 = [];
  HEX256.length = 256;
  for (var i = 0; i < 256; i++) {
    HEX256[i] = HEX16[i >> 4] + HEX16[i & 0xf];
  }

  // Look-up tables
  var ID62 = [];
  ID62.length = 128;
  for (var i = 0; i < BASE62.length; ++i) {
    ID62[BASE62.charCodeAt(i)] = i;
  }
  var ID16 = [];
  for (var i = 0; i < 16; i++) {
    ID16[HEX16.charCodeAt(i)] = i;
  }
  for (var i = 0; i < 6; i++) {
    ID16['ABCDEF'.charCodeAt(i)] = 10 + i;
  }

  var Base62 = {
    toHex: function(s) {
      if (s.length !== 22) {
        // Can only parse base62 ids with length == 22.
        // Invalid base62 ids will lead to garbage in the output.
        return null;
      }

      // 1 / (2^32)
      var MAX_INT_INV = 2.3283064365386963e-10;
      // 2^32
      var MAX_INT = 0x100000000;
      // 62^3
      var P62_3 = 238328;

      var p0, p1, p2, p3;
      var v;
      // First 7 characters fit in 2^53
      // prettier-ignore
      p0 =
        ID62[s.charCodeAt(0)] * 56800235584 +  // * 62^6
        ID62[s.charCodeAt(1)] * 916132832 +    // * 62^5
        ID62[s.charCodeAt(2)] * 14776336 +     // * 62^4
        ID62[s.charCodeAt(3)] * 238328 +       // * 62^3
        ID62[s.charCodeAt(4)] * 3844 +         // * 62^2
        ID62[s.charCodeAt(5)] * 62 +           // * 62^1
        ID62[s.charCodeAt(6)];                 // * 62^0
      p1 = (p0 * MAX_INT_INV) | 0;
      p0 -= p1 * MAX_INT;
      // 62^10 < 2^64
      v =
        ID62[s.charCodeAt(7)] * 3844 +
        ID62[s.charCodeAt(8)] * 62 +
        ID62[s.charCodeAt(9)];
      (p0 = p0 * P62_3 + v), (p0 = p0 - (v = (p0 * MAX_INT_INV) | 0) * MAX_INT);
      p1 = p1 * P62_3 + v;
      // 62^13 < 2^96
      v =
        ID62[s.charCodeAt(10)] * 3844 +
        ID62[s.charCodeAt(11)] * 62 +
        ID62[s.charCodeAt(12)];
      (p0 = p0 * P62_3 + v), (p0 = p0 - (v = (p0 * MAX_INT_INV) | 0) * MAX_INT);
      (p1 = p1 * P62_3 + v), (p1 = p1 - (v = (p1 * MAX_INT_INV) | 0) * MAX_INT);
      p2 = v;
      // 62^16 < 2^96
      v =
        ID62[s.charCodeAt(13)] * 3844 +
        ID62[s.charCodeAt(14)] * 62 +
        ID62[s.charCodeAt(15)];
      (p0 = p0 * P62_3 + v), (p0 = p0 - (v = (p0 * MAX_INT_INV) | 0) * MAX_INT);
      (p1 = p1 * P62_3 + v), (p1 = p1 - (v = (p1 * MAX_INT_INV) | 0) * MAX_INT);
      p2 = p2 * P62_3 + v;
      // 62^19 < 2^128
      v =
        ID62[s.charCodeAt(16)] * 3844 +
        ID62[s.charCodeAt(17)] * 62 +
        ID62[s.charCodeAt(18)];
      (p0 = p0 * P62_3 + v), (p0 = p0 - (v = (p0 * MAX_INT_INV) | 0) * MAX_INT);
      (p1 = p1 * P62_3 + v), (p1 = p1 - (v = (p1 * MAX_INT_INV) | 0) * MAX_INT);
      (p2 = p2 * P62_3 + v), (p2 = p2 - (v = (p2 * MAX_INT_INV) | 0) * MAX_INT);
      p3 = v;
      v =
        ID62[s.charCodeAt(19)] * 3844 +
        ID62[s.charCodeAt(20)] * 62 +
        ID62[s.charCodeAt(21)];
      (p0 = p0 * P62_3 + v), (p0 = p0 - (v = (p0 * MAX_INT_INV) | 0) * MAX_INT);
      (p1 = p1 * P62_3 + v), (p1 = p1 - (v = (p1 * MAX_INT_INV) | 0) * MAX_INT);
      (p2 = p2 * P62_3 + v), (p2 = p2 - (v = (p2 * MAX_INT_INV) | 0) * MAX_INT);
      (p3 = p3 * P62_3 + v), (p3 = p3 - (v = (p3 * MAX_INT_INV) | 0) * MAX_INT);
      if (v) {
        // carry not allowed
        return null;
      }
      // prettier-ignore
      return HEX256[p3>>>24]+HEX256[(p3>>>16)&0xFF]+HEX256[(p3>>>8)&0xFF]+HEX256[(p3)&0xFF] +
             HEX256[p2>>>24]+HEX256[(p2>>>16)&0xFF]+HEX256[(p2>>>8)&0xFF]+HEX256[(p2)&0xFF] +
             HEX256[p1>>>24]+HEX256[(p1>>>16)&0xFF]+HEX256[(p1>>>8)&0xFF]+HEX256[(p1)&0xFF] +
             HEX256[p0>>>24]+HEX256[(p0>>>16)&0xFF]+HEX256[(p0>>>8)&0xFF]+HEX256[(p0)&0xFF];
    },

    fromHex: function(s) {
      var i;
      var p0 = 0, p1 = 0, p2 = 0;
      for (i = 0; i < 10; i++) p2 = p2 * 16 + ID16[s.charCodeAt(i)];
      for (i = 0; i < 11; i++) p1 = p1 * 16 + ID16[s.charCodeAt(i + 10)];
      for (i = 0; i < 11; i++) p0 = p0 * 16 + ID16[s.charCodeAt(i + 21)];
      if (isNaN(p0 + p1 + p2)) {
        return null;
      }
      var P16_11 = 17592186044416; // 16^11
      var INV_62 = 1.0 / 62;

      var acc;
      var ret = '';
      i = 0;
      for (; i < 7; ++i) {
        acc = p2;
        p2 = Math.floor(acc * INV_62);
        acc = (acc - p2 * 62) * P16_11 + p1;
        p1 = Math.floor(acc * INV_62);
        acc = (acc - p1 * 62) * P16_11 + p0;
        p0 = Math.floor(acc * INV_62);
        ret = BASE62[acc - p0 * 62] + ret;
      }
      p1 += p2 * P16_11;
      for (; i < 15; ++i) {
        acc = p1;
        p1 = Math.floor(acc * INV_62);
        acc = (acc - p1 * 62) * P16_11 + p0;
        p0 = Math.floor(acc * INV_62);
        ret = BASE62[acc - p0 * 62] + ret;
      }
      p0 += p1 * P16_11;
      for (; i < 21; ++i) {
        acc = p0;
        p0 = Math.floor(acc * INV_62);
        ret = BASE62[acc - p0 * 62] + ret;
      }
      return BASE62[p0] + ret;
    },

    // Expose the lookup tables
    HEX256: HEX256, // number -> 'hh'
    ID16: ID16,  // hexadecimal char code -> 0..15
    ID62: ID62,  // base62 char code -> 0..61
  };

  if (typeof module !== 'undefined' && typeof module.exports !== 'undefined') {
    module.exports = Base62;
  } else {
    window.Base62 = Base62;
  }
})();

},{}],475:[function(require,module,exports){
'use strict';

/**
 * @private
 */
var Base62 = require('./base62');

/**
 * The URI prefix for URIs.
 *
 * @const
 * @private
 */
var URI_PREFIX = 'spotify:';

/**
 * The URL prefix for Play.
 *
 * @const
 * @private
 */
var PLAY_HTTP_PREFIX = 'http://play.spotify.com/';

/**
 * The HTTPS URL prefix for Play.
 *
 * @const
 * @private
 */
var PLAY_HTTPS_PREFIX = 'https://play.spotify.com/';

/**
 * The URL prefix for Open.
 *
 * @const
 * @private
 */
var OPEN_HTTP_PREFIX = 'http://open.spotify.com/';

/**
 * The HTTPS URL prefix for Open.
 *
 * @const
 * @private
 */
var OPEN_HTTPS_PREFIX = 'https://open.spotify.com/';

var ERROR_INVALID = new TypeError('Invalid Spotify URI!');
var ERROR_NOT_IMPLEMENTED = new TypeError('Not implemented!');


/**
 * The format for the URI to parse.
 *
 * @enum {number}
 * @private
 */
var Format = {
  URI: 0,
  URL: 1
};

/**
 * Represents the result of a URI splitting operation.
 *
 * @typedef {{
 *    format: Format,
 *    components: Array.<string>
 * }}
 * @see _splitIntoComponents
 * @private
 */
var SplittedURI;

/**
 * Split an string URI or HTTP/HTTPS URL into components, skipping the prefix.
 *
 * @param {string} str A string URI to split.
 * @return {SplittedURI} The parsed URI.
 * @private
 */
var _splitIntoComponents = function(str) {
  var components;
  var format;
  var query;
  var anchor;

  var querySplit = str.split('?');
  if (querySplit.length > 1) {
    str = querySplit.shift();
    query = querySplit.pop();

    var queryHashSplit = query.split('#');
    if (queryHashSplit.length > 1) {
      query = queryHashSplit.shift();
      anchor = queryHashSplit.pop();
    }

    query = decodeQueryString(query);
  }

  var hashSplit = str.split('#');
  if (hashSplit.length > 1) {
    // first token
    str = hashSplit.shift();
    // last token
    anchor = hashSplit.pop();
  }

  if (str.indexOf(URI_PREFIX) === 0) {
    components = str.slice(URI_PREFIX.length).split(':');
    format = Format.URI;
  } else {
    // For HTTP URLs, ignore any query string argument
    str = str.split('?')[0];

    if (str.indexOf(PLAY_HTTP_PREFIX) === 0) {
      components = str.slice(PLAY_HTTP_PREFIX.length).split('/');
    } else if (str.indexOf(PLAY_HTTPS_PREFIX) === 0) {
      components = str.slice(PLAY_HTTPS_PREFIX.length).split('/');
    } else if (str.indexOf(OPEN_HTTP_PREFIX) === 0) {
      components = str.slice(OPEN_HTTP_PREFIX.length).split('/');
    } else if (str.indexOf(OPEN_HTTPS_PREFIX) === 0) {
      components = str.slice(OPEN_HTTPS_PREFIX.length).split('/');
    } else {
      throw ERROR_INVALID;
    }
    format = Format.URL;
  }

  if (anchor) {
    components.push(anchor);
  }

  return {
    format: format,
    components: components,
    query: query
  };
};

/**
 * Encodes a component according to a format.
 *
 * @param {string} component A component string.
 * @param {Format} format A format.
 * @return {string} An encoded component string.
 * @private
 */
var _encodeComponent = function(component, format) {
  component = encodeURIComponent(component);
  if (format === Format.URI) {
    component = component.replace(/%20/g, '+');
  }

  // encode characters that are not encoded by default by encodeURIComponent
  // but that the Spotify URI spec encodes: !'*()
  component = component.replace(/[!'()]/g, escape);
  component = component.replace(/\*/g, '%2A');

  return component;
};

/**
 * Decodes a component according to a format.
 *
 * @param {string} component An encoded component string.
 * @param {Format} format A format.
 * @return {string} An decoded component string.
 * @private
 */
var _decodeComponent = function(component, format) {
  var part = format == Format.URI ? component.replace(/\+/g, '%20') : component;
  return decodeURIComponent(part);
};

/**
 * Returns the components of a URI as an array.
 *
 * @param {URI} uri A uri.
 * @param {Format} format The output format.
 * @return {Array.<string>} An array of uri components.
 * @private
 */
var _getComponents = function(uri, format) {
  var base62;
  if (uri.id) {
    base62 = uri._base62Id;
  }

  var components;
  var i;
  var len;
  switch (uri.type) {
    case URI.Type.ALBUM:
      components = [URI.Type.ALBUM, base62];
      if (uri.disc) {
        components.push(uri.disc);
      }
      return components;
    case URI.Type.AD:
      return [URI.Type.AD, uri._base62Id];
    case URI.Type.ARTIST:
      return [URI.Type.ARTIST, base62];
    case URI.Type.ARTIST_TOPLIST:
      return [URI.Type.ARTIST, base62, URI.Type.TOP, uri.toplist];
    case URI.Type.DAILY_MIX:
      return [URI.Type.DAILY_MIX, base62];
    case URI.Type.SEARCH:
      return [URI.Type.SEARCH, _encodeComponent(uri.query, format)];
    case URI.Type.TRACK:
      if (uri.context || uri.play) {
        base62 += encodeQueryString({
          context: uri.context,
          play: uri.play
        });
      }
      if (uri.anchor) {
        base62 += '#' + uri.anchor;
      }
      return [URI.Type.TRACK, base62];
    case URI.Type.TRACKSET:
      var trackIds = [];
      for (i = 0, len = uri.tracks.length; i < len; i++) {
        trackIds.push(uri.tracks[i]._base62Id);
      }
      trackIds = [trackIds.join(',')];
      // Index can be 0 sometimes (required for trackset)
      if (uri.index !== null) {
        trackIds.push('#', uri.index);
      }
      return [URI.Type.TRACKSET, _encodeComponent(uri.name)].concat(trackIds);
    case URI.Type.FACEBOOK:
      return [URI.Type.USER, URI.Type.FACEBOOK, uri.uid];
    case URI.Type.AUDIO_FILE:
      return [URI.Type.AUDIO_FILE, uri.extension, uri._base62Id];
    case URI.Type.FOLDER:
      return [URI.Type.USER, _encodeComponent(uri.username, format), URI.Type.FOLDER, uri._base62Id];
    case URI.Type.FOLLOWERS:
      return [URI.Type.USER, _encodeComponent(uri.username, format), URI.Type.FOLLOWERS];
    case URI.Type.FOLLOWING:
      return [URI.Type.USER, _encodeComponent(uri.username, format), URI.Type.FOLLOWING];
    case URI.Type.PLAYLIST:
      return [URI.Type.USER, _encodeComponent(uri.username, format), URI.Type.PLAYLIST, base62];
    case URI.Type.PLAYLIST_V2:
      return [URI.Type.PLAYLIST, base62];
    case URI.Type.STARRED:
      return [URI.Type.USER, _encodeComponent(uri.username, format), URI.Type.STARRED];
    case URI.Type.TEMP_PLAYLIST:
      return [URI.Type.TEMP_PLAYLIST, uri.origin, uri.data];
    case URI.Type.CONTEXT_GROUP:
      return [URI.Type.CONTEXT_GROUP, uri.origin, uri.name];
    case URI.Type.USER_TOPLIST:
      return [URI.Type.USER, _encodeComponent(uri.username, format), URI.Type.TOP, uri.toplist];
    // Legacy Toplist
    case URI.Type.USER_TOP_TRACKS:
      return [URI.Type.USER, _encodeComponent(uri.username, format), URI.Type.TOPLIST];
    case URI.Type.TOPLIST:
      return [URI.Type.TOP, uri.toplist].concat(uri.global ? [URI.Type.GLOBAL] : ['country', uri.country]);
    case URI.Type.INBOX:
      return [URI.Type.USER, _encodeComponent(uri.username, format), URI.Type.INBOX];
    case URI.Type.ROOTLIST:
      return [URI.Type.USER, _encodeComponent(uri.username, format), URI.Type.ROOTLIST];
    case URI.Type.PUBLISHED_ROOTLIST:
      return [URI.Type.USER, _encodeComponent(uri.username, format), URI.Type.PUBLISHED_ROOTLIST];
    case URI.Type.COLLECTION_TRACK_LIST:
      return [URI.Type.USER, _encodeComponent(uri.username, format), URI.Type.COLLECTION_TRACK_LIST, base62];
    case URI.Type.PROFILE:
      if (uri.args && uri.args.length > 0)
        return [URI.Type.USER, _encodeComponent(uri.username, format)].concat(uri.args);
      return [URI.Type.USER, _encodeComponent(uri.username, format)];
    case URI.Type.LOCAL_ARTIST:
      return [URI.Type.LOCAL, _encodeComponent(uri.artist, format)];
    case URI.Type.LOCAL_ALBUM:
      return [URI.Type.LOCAL, _encodeComponent(uri.artist, format), _encodeComponent(uri.album, format)];
    case URI.Type.LOCAL:
      return [URI.Type.LOCAL,
        _encodeComponent(uri.artist, format),
        _encodeComponent(uri.album, format),
        _encodeComponent(uri.track, format),
        uri.duration];
    case URI.Type.LIBRARY:
      return [URI.Type.USER, _encodeComponent(uri.username, format), URI.Type.LIBRARY].concat(uri.category ? [uri.category] : []);
    case URI.Type.IMAGE:
      return [URI.Type.IMAGE, uri._base62Id];
    case URI.Type.MOSAIC:
      components = uri.ids.slice(0);
      components.unshift(URI.Type.MOSAIC);
      return components;
    case URI.Type.RADIO:
      return [URI.Type.RADIO, uri.args];
    case URI.Type.SPECIAL:
      components = [URI.Type.SPECIAL];
      var args = uri.args || [];
      for (i = 0, len = args.length; i < len; ++i)
        components.push(_encodeComponent(args[i], format));
      return components;
    case URI.Type.STATION:
      components = [URI.Type.STATION];
      var args = uri.args || [];
      for (i = 0, len = args.length; i < len; i++) {
        components.push(_encodeComponent(args[i], format));
      }
      return components;
    case URI.Type.APPLICATION:
      components = [URI.Type.APP, uri._base62Id];
      var args = uri.args || [];
      for (i = 0, len = args.length; i < len; ++i)
        components.push(_encodeComponent(args[i], format));
      return components;
    case URI.Type.COLLECTION_ALBUM:
      return [URI.Type.USER, _encodeComponent(uri.username, format), URI.Type.COLLECTION, URI.Type.ALBUM, base62];
    case URI.Type.COLLECTION_MISSING_ALBUM:
      return [URI.Type.USER, _encodeComponent(uri.username, format), URI.Type.COLLECTION, URI.Type.ALBUM, base62, 'missing'];
    case URI.Type.COLLECTION_ARTIST:
      return [URI.Type.USER, _encodeComponent(uri.username, format), URI.Type.COLLECTION, URI.Type.ARTIST, base62];
    case URI.Type.COLLECTION:
      return [URI.Type.USER, _encodeComponent(uri.username, format), URI.Type.COLLECTION].concat(uri.category ? [uri.category] : []);
    case URI.Type.EPISODE:
      if (uri.context || uri.play) {
        base62 += encodeQueryString({
          context: uri.context,
          play: uri.play
        });
      }
      return [URI.Type.EPISODE, base62];
    case URI.Type.SHOW:
      return [URI.Type.SHOW, base62];
    case URI.Type.CONCERT:
      return [URI.Type.CONCERT, base62];
    default:
      throw ERROR_INVALID;
  }
};

var encodeQueryString = function(values) {
  var str = '?';
  for (var i in values) {
    if (values.hasOwnProperty(i) && values[i] !== undefined) {
      if (str.length > 1) {
        str += '&';
      }
      str += i + '=' + encodeURIComponent(values[i]);
    }
  }
  return str;
};

var decodeQueryString = function(str) {
  return str.split('&').reduce(function(object, pair) {
    pair = pair.split('=');
    object[pair[0]] = decodeURIComponent(pair[1]);
    return object;
  }, {});
};

/**
 * Parses the components of a URI into a real URI object.
 *
 * @param {Array.<string>} components The components of the URI as a string
 *     array.
 * @param {Format} format The format of the source string.
 * @return {URI} The URI object.
 * @private
 */
var _parseFromComponents = function(components, format, query) {
  var _current = 0;
  query = query || {};

  var _getNextComponent = function() {
    return components[_current++];
  };

  var _getIdComponent = function() {
    var component = _getNextComponent();

    if (component.length > 22) {
      throw new Error('Invalid ID');
    }
    return component;
  };

  var _getRemainingComponents = function() {
    return components.slice(_current);
  };

  var _getRemainingString = function() {
    var separator = (format == Format.URI) ? ':' : '/';
    return components.slice(_current).join(separator);
  };

  var part = _getNextComponent();
  var id;
  var i;
  var len;

  switch (part) {
    case URI.Type.ALBUM:
      return URI.albumURI(_getIdComponent(), parseInt(_getNextComponent(), 10));
    case URI.Type.AD:
      return URI.adURI(_getNextComponent());
    case URI.Type.ARTIST:
      id = _getIdComponent();
      if (_getNextComponent() == URI.Type.TOP) {
        return URI.artistToplistURI(id, _getNextComponent());
      } else {
        return URI.artistURI(id);
      }
    case URI.Type.AUDIO_FILE:
      return URI.audioFileURI(_getNextComponent(), _getNextComponent());
    case URI.Type.DAILY_MIX:
      return URI.dailyMixURI(_getIdComponent());
    case URI.Type.TEMP_PLAYLIST:
      return URI.temporaryPlaylistURI(_getNextComponent(), _getRemainingString());
    case URI.Type.PLAYLIST:
      return URI.playlistV2URI(_getIdComponent());
    case URI.Type.SEARCH:
      return URI.searchURI(_decodeComponent(_getRemainingString(), format));
    case URI.Type.TRACK:
      return URI.trackURI(_getIdComponent(), _getNextComponent(), query.context, query.play);
    case URI.Type.TRACKSET:
      var name = _decodeComponent(_getNextComponent());
      var tracksArray = _getNextComponent();
      var hashSign = _getNextComponent();
      var index = parseInt(_getNextComponent(), 10);
      // Sanity check: %23 is URL code for "#"
      if (hashSign !== '%23' || isNaN(index)) {
        index = null;
      }
      var tracksetTracks = [];
      if (tracksArray) {
        tracksArray = _decodeComponent(tracksArray).split(',');
        for (i = 0, len = tracksArray.length; i < len; i++) {
          var trackId = tracksArray[i];
          tracksetTracks.push(URI.trackURI(trackId));
        }
      }
      return URI.tracksetURI(tracksetTracks, name, index);
    case URI.Type.CONTEXT_GROUP:
      return URI.contextGroupURI(_getNextComponent(), _getNextComponent());
    case URI.Type.TOP:
      var type = _getNextComponent();
      if (_getNextComponent() == URI.Type.GLOBAL) {
        return URI.toplistURI(type, null, true);
      } else {
        return URI.toplistURI(type, _getNextComponent(), false);
      }
    case URI.Type.USER:
      var username = _decodeComponent(_getNextComponent(), format);
      var text = _getNextComponent();
      if (username == URI.Type.FACEBOOK && text != null) {
        return URI.facebookURI(parseInt(text, 10));
      } else if (text != null) {
        switch (text) {
          case URI.Type.PLAYLIST:
            return URI.playlistURI(username, _getIdComponent());
          case URI.Type.FOLDER:
            return URI.folderURI(username, _getIdComponent());
          case URI.Type.COLLECTION_TRACK_LIST:
            return URI.collectionTrackList(username, _getIdComponent());
          case URI.Type.COLLECTION:
            var collectionItemType = _getNextComponent();
            switch (collectionItemType) {
              case URI.Type.ALBUM:
                id = _getIdComponent();
                if (_getNextComponent() === 'missing') {
                  return URI.collectionMissingAlbumURI(username, id);
                } else {
                  return URI.collectionAlbumURI(username, id);
                }
              case URI.Type.ARTIST:
                return URI.collectionArtistURI(username, _getIdComponent());
              default:
                return URI.collectionURI(username, collectionItemType);
            }
          case URI.Type.STARRED:
            return URI.starredURI(username);
          case URI.Type.FOLLOWERS:
            return URI.followersURI(username);
          case URI.Type.FOLLOWING:
            return URI.followingURI(username);
          case URI.Type.TOP:
            return URI.userToplistURI(username, _getNextComponent());
          case URI.Type.INBOX:
            return URI.inboxURI(username);
          case URI.Type.ROOTLIST:
            return URI.rootlistURI(username);
          case URI.Type.PUBLISHED_ROOTLIST:
            return URI.publishedRootlistURI(username);
          case URI.Type.TOPLIST:
            // legacy toplist
            return URI.userTopTracksURI(username);
          case URI.Type.LIBRARY:
            return URI.libraryURI(username, _getNextComponent());
        }
      }
      var rem = _getRemainingComponents();
      if (text != null && rem.length > 0) {
        return URI.profileURI(username, [text].concat(rem));
      } else if (text != null) {
        return URI.profileURI(username, [text]);
      } else {
        return URI.profileURI(username);
      }
    case URI.Type.LOCAL:
      var artistNameComponent = _getNextComponent();
      var artistName = artistNameComponent && _decodeComponent(artistNameComponent, format);
      var albumNameComponent = _getNextComponent();
      var albumName = albumNameComponent && _decodeComponent(albumNameComponent, format);
      var trackNameComponent = _getNextComponent();
      var trackName = trackNameComponent && _decodeComponent(trackNameComponent, format);
      var durationComponent = _getNextComponent();
      var duration = parseInt(durationComponent, 10);
      if (trackNameComponent !== undefined) {
        return URI.localURI(artistName, albumName, trackName, duration);
      } else if (albumNameComponent !== undefined) {
        return URI.localAlbumURI(artistName, albumName);
      } else {
        return URI.localArtistURI(artistName);
      }
    case URI.Type.IMAGE:
      return URI.imageURI(_getIdComponent());
    case URI.Type.MOSAIC:
      return URI.mosaicURI(components.slice(_current));
    case URI.Type.RADIO:
      return URI.radioURI(_getRemainingString());
    case URI.Type.SPECIAL:
      var args = _getRemainingComponents();
      for (i = 0, len = args.length; i < len; ++i)
        args[i] = _decodeComponent(args[i], format);
      return URI.specialURI(args);
    case URI.Type.STATION:
      return URI.stationURI(_getRemainingComponents());
    case URI.Type.EPISODE:
      return URI.episodeURI(_getIdComponent(), query.context, query.play);
    case URI.Type.SHOW:
      return URI.showURI(_getIdComponent());
    case URI.Type.CONCERT:
      return URI.concertURI(_getIdComponent());
    case '':
      break;
    default:
      if (part === URI.Type.APP) {
        id = _getNextComponent();
      } else {
        id = part;
      }
      var decodedId = _decodeComponent(id, format);
      if (_encodeComponent(decodedId, format) !== id) {
        break;
      }
      var args = _getRemainingComponents();
      for (i = 0, len = args.length; i < len; ++i)
        args[i] = _decodeComponent(args[i], format);
      return URI.applicationURI(decodedId, args);
  }

  throw ERROR_INVALID;
};

/**
 * A class holding information about a uri.
 *
 * @constructor
 * @param {URI.Type} type
 * @param {Object} props
 */
function URI(type, props) {
  this.type = type;

  // Merge properties into URI object.
  for (var prop in props) {
    if (typeof props[prop] == 'function') {
      continue;
    }
    this[prop] = props[prop];
  }
}

// Lazy convert the id to hexadecimal only when requested
Object.defineProperty(URI.prototype, 'id', {
  get: function() {
    if (!this._hexId) {
      this._hexId = this._base62Id ? URI.idToHex(this._base62Id) : undefined;
    }
    return this._hexId;
  },
  set: function(id) {
    this._base62Id = id ? URI.hexToId(id) : undefined;
    this._hexId = undefined;
  },
  enumerable: true,
  configurable: true
});

/**
 * Creates an application URI object from the current URI object.
 *
 * If the current URI object is already an application type, a copy is made.
 *
 * @return {URI} The current URI as an application URI.
 */
URI.prototype.toAppType = function() {
  if (this.type == URI.Type.APPLICATION) {
    return URI.applicationURI(this.id, this.args);
  } else {
    var components = _getComponents(this, Format.URL);
    var id = components.shift();
    var len = components.length;
    if (len) {
      while (len--) {
        components[len] = _decodeComponent(components[len], Format.URL);
      }
    }
    if (this.type == URI.Type.RADIO) {
      components = components.shift().split(':');
    }
    var result = URI.applicationURI(id, components);
    return result;
  }
};

/**
 * Creates a URI object from an application URI object.
 *
 * If the current URI object is not an application type, a copy is made.
 *
 * @return {URI} The current URI as a real typed URI.
 */
URI.prototype.toRealType = function() {
  if (this.type == URI.Type.APPLICATION) {
    return _parseFromComponents([this.id].concat(this.args), Format.URI);
  } else {
    return new URI(null, this);
  }
};

/**
 * Returns the URI representation of this URI.
 *
 * @return {String} The URI representation of this uri.
 */
URI.prototype.toURI = function() {
  return URI_PREFIX + _getComponents(this, Format.URI).join(':');
};

/**
 * Returns the String representation of this URI.
 *
 * @return {String} The URI representation of this uri.
 * @see {URI#toURI}
 */
URI.prototype.toString = function() {
  return this.toURI();
};

/**
 * Get the URL path of this uri.
 *
 * @param {boolean} opt_leadingSlash True if a leading slash should be prepended.
 * @return {String} The path of this uri.
 */
URI.prototype.toURLPath = function(opt_leadingSlash) {
  var components = _getComponents(this, Format.URL);
  if (components[0] === URI.Type.APP) {
    components.shift();
  }

  // Some URIs are allowed to have empty components. It should be investigated
  // whether we need to strip empty components at all from any URIs. For now,
  // we check specifically for tracksets and local tracks and strip empty
  // components for all other URIs.
  //
  // For tracksets, it's permissible to have a path that looks like
  // 'trackset//trackURI' because the identifier parameter for a trackset can
  // be blank. For local tracks, some metadata can be missing, like missing
  // album name would be 'spotify:local:artist::track:duration'.
  var isTrackset = components[0] === URI.Type.TRACKSET;
  var isLocalTrack = components[0] === URI.Type.LOCAL;
  var shouldStripEmptyComponents = !isTrackset && !isLocalTrack;

  if (shouldStripEmptyComponents) {
    var _temp = [];
    for (var i = 0, l = components.length; i < l; i++) {
      var component = components[i];
      if (!!component) {
        _temp.push(component);
      }
    }
    components = _temp;
  }
  var path = components.join('/');
  return opt_leadingSlash ? '/' + path : path;
};

/**
 * Returns the Play URL string for the uri.
 *
 * @return {string} The Play URL string for the uri.
 */
URI.prototype.toPlayURL = function() {
    return PLAY_HTTPS_PREFIX + this.toURLPath();
};

/**
 * Returns the URL string for the uri.
 *
 * @return {string} The URL string for the uri.
 * @see {URL#toPlayURL}
 */
URI.prototype.toURL = function() {
  return this.toPlayURL();
};

/**
 * Returns the Open URL string for the uri.
 *
 * @return {string} The Open URL string for the uri.
 */
URI.prototype.toOpenURL = function() {
  return OPEN_HTTPS_PREFIX + this.toURLPath();
};

/**
 * Returns the Play HTTPS URL string for the uri.
 *
 * @return {string} The Play HTTPS URL string for the uri.
 */
URI.prototype.toSecurePlayURL = function() {
    return this.toPlayURL();
};

/**
 * Returns the HTTPS URL string for the uri.
 *
 * @return {string} The HTTPS URL string for the uri.
 * @see {URL#toSecurePlayURL}
 */
URI.prototype.toSecureURL = function() {
  return this.toPlayURL();
};

/**
 * Returns the Open HTTPS URL string for the uri.
 *
 * @return {string} The Open HTTPS URL string for the uri.
 */
URI.prototype.toSecureOpenURL = function() {
  return this.toOpenURL();
};

/**
 * Returns the id of the uri as a bytestring.
 *
 * @return {Array} The id of the uri as a bytestring.
 */
URI.prototype.idToByteString = function() {
  var hexId = Base62.toHex(this._base62Id);
  if (!hexId) {
    var zero = '';
    for (var i = 0; i < 16; i++) {
      zero += String.fromCharCode(0);
    }
    return zero;
  }
  var data = '';
  for (var i = 0; i < 32; i += 2) {
    var upper = Base62.ID16[hexId.charCodeAt(i)];
    var lower = Base62.ID16[hexId.charCodeAt(i + 1)];
    var byte = (upper << 4) + lower;
    data += String.fromCharCode(byte);
  }
  return data;
};

URI.prototype.getPath = function() {
  var uri = this.toString().replace(/[#?].*/, '');
  return uri;
}

URI.prototype.getBase62Id = function() {
  return this._base62Id;
}


/**
* Checks whether two URI:s refer to the same thing even though they might
* not necessarily be equal.
*
* These two Playlist URIs, for example, refer to the same playlist:
*
*   spotify:user:napstersean:playlist:3vxotOnOGDlZXyzJPLFnm2
*   spotify:playlist:3vxotOnOGDlZXyzJPLFnm2
*
* @param {*} uri The uri to compare identity for.
* @return {boolean} Whether they shared idenitity
*/
URI.prototype.isSameIdentity = function(uri) {
  var uriObject = URI.from(uri);
  if (!uriObject) return false;
  if (this.toString() === uri.toString()) return true;
  if (
    (this.type === URI.Type.PLAYLIST || this.type === URI.Type.PLAYLIST_V2) &&
    (uriObject.type === URI.Type.PLAYLIST || uriObject.type === URI.Type.PLAYLIST_V2)
  ) {
    return this.id === uriObject.id;
  } else if (this.type === URI.Type.STATION && uriObject.type === URI.Type.STATION) {
    var thisStationContextUriObject = _parseFromComponents(this.args, Format.URI);
    return !!thisStationContextUriObject &&
      thisStationContextUriObject.isSameIdentity(
        _parseFromComponents(uriObject.args, Format.URI)
      );
  } else {
    return false;
  }
}

/**
 * The various URI Types.
 *
 * Note that some of the types in this enum are not real URI types, but are
 * actually URI particles. They are marked so.
 *
 * @enum {string}
 */
URI.Type = {
  EMPTY: 'empty',
  ALBUM: 'album',
  AD: 'ad',
  /** URI particle; not an actual URI. */
  APP: 'app',
  APPLICATION: 'application',
  ARTIST: 'artist',
  ARTIST_TOPLIST: 'artist-toplist',
  AUDIO_FILE: 'audiofile',
  COLLECTION: 'collection',
  COLLECTION_ALBUM: 'collection-album',
  COLLECTION_MISSING_ALBUM: 'collection-missing-album',
  COLLECTION_ARTIST: 'collection-artist',
  CONTEXT_GROUP: 'context-group',
  DAILY_MIX: 'dailymix',
  EPISODE: 'episode',
  /** URI particle; not an actual URI. */
  FACEBOOK: 'facebook',
  FOLDER: 'folder',
  FOLLOWERS: 'followers',
  FOLLOWING: 'following',
  /** URI particle; not an actual URI. */
  GLOBAL: 'global',
  IMAGE: 'image',
  INBOX: 'inbox',
  LOCAL_ARTIST: 'local-artist',
  LOCAL_ALBUM: 'local-album',
  LOCAL: 'local',
  LIBRARY: 'library',
  MOSAIC: 'mosaic',
  PLAYLIST: 'playlist',
  /** Only used for URI classification. Not a valid URI fragment. */
  PLAYLIST_V2: 'playlist-v2',
  PROFILE: 'profile',
  PUBLISHED_ROOTLIST: 'published-rootlist',
  RADIO: 'radio',
  ROOTLIST: 'rootlist',
  COLLECTION_TRACK_LIST: 'collectiontracklist',
  SEARCH: 'search',
  SHOW: 'show',
  CONCERT: 'concert',
  SPECIAL: 'special',
  STARRED: 'starred',
  STATION: 'station',
  TEMP_PLAYLIST: 'temp-playlist',
  /** URI particle; not an actual URI. */
  TOP: 'top',
  TOPLIST: 'toplist',
  TRACK: 'track',
  TRACKSET: 'trackset',
  /** URI particle; not an actual URI. */
  USER: 'user',
  USER_TOPLIST: 'user-toplist',
  USER_TOP_TRACKS: 'user-top-tracks',
  /** Deprecated contant. Please use USER_TOP_TRACKS. */
  USET_TOP_TRACKS: 'user-top-tracks'
};

/**
 * Creates a new URI object from a parsed string argument.
 *
 * @param {string} str The string that will be parsed into a URI object.
 * @throws TypeError If the string argument is not a valid URI, a TypeError will
 *     be thrown.
 * @return {URI} The parsed URI object.
 */
URI.fromString = function(str) {
  var splitted = _splitIntoComponents(str);
  return _parseFromComponents(splitted.components, splitted.format, splitted.query);
};

/**
 * Parses a given object into a URI instance.
 *
 * Unlike URI.fromString, this function could receive any kind of value. If
 * the value is already a URI instance, it is simply returned.
 * Otherwise the value will be stringified before parsing.
 *
 * This function also does not throw an error like URI.fromString, but
 * instead simply returns null if it can't parse the value.
 *
 * @param {*} value The value to parse.
 * @return {URI?} The corresponding URI instance, or null if the
 *     passed value is not a valid value.
 */
URI.from = function(value) {
  try {
    if (value instanceof URI) {
      return value;
    }
    if (typeof value == 'object' && value.type) {
      return new URI(null, value);
    }
    return URI.fromString(value.toString());
  } catch(e) {
    return null;
  }
};

/**
 * Creates a new URI from a bytestring.
 *
 * @param {URI.Type} type The type of the URI.
 * @param {ByteString} idByteString The ID of the URI as a bytestring.
 * @param {Object} opt_args Optional arguments to the URI constructor.
 * @return {URI} The URI object created.
 */
URI.fromByteString = function(type, idByteString, opt_args) {
  while (idByteString.length != 16) {
    idByteString = String.fromCharCode(0) + idByteString;
  }
  var hexId = '';
  for (var i = 0; i < idByteString.length; i++) {
    var byte = idByteString.charCodeAt(i);
    hexId += Base62.HEX256[byte];
  }
  var id = Base62.fromHex(hexId);
  var args = opt_args || {};
  args.id = id;
  return new URI(type, args);
};

/**
 * Clones a given SpotifyURI instance.
 *
 * @param {URI} uri The uri to clone.
 * @return {URI?} An instance of URI.
 */
URI.clone = function(uri) {
  if (!(uri instanceof URI)) {
    return null;
  }
  return new URI(null, uri);
};

/**
 * @deprecated
 */
URI.getCanonical = function(username) {
  return this.getCanonical(username);
};

/**
 * Returns the canonical representation of a username.
 *
 * @param {string} username The username to encode.
 * @return {string} The encoded canonical representation of the username.
 */
URI.getCanonicalUsername = function(username) {
  return _encodeComponent(username, Format.URI);
};

/**
 * Returns the non-canonical representation of a username.
 *
 * @param {string} username The username to encode.
 * @return {string} The unencoded canonical representation of the username.
 */
URI.getDisplayUsername = function(username) {
  return _decodeComponent(username, Format.URI);
};

/**
 * Returns the hex representation of a Base62 encoded id.
 *
 * @param {string} id The base62 encoded id.
 * @return {string} The hex representation of the base62 id.
 */
URI.idToHex = function(id) {
  if (id.length == 22) {
    return Base62.toHex(id);
  }
  return id;
};

/**
 * Returns the base62 representation of a hex encoded id.
 *
 * @param {string} hex The hex encoded id.
 * @return {string} The base62 representation of the id.
 */
URI.hexToId = function(hex) {
  if (hex.length == 32) {
    return Base62.fromHex(hex);
  }
  return hex;
};

/**
 * Creates a new empty URI.
 *
 * @return {URI} The empty URI.
 */
URI.emptyURI = function() {
  return new URI(URI.Type.EMPTY, {});
};

/**
 * Creates a new 'album' type URI.
 *
 * @param {string} id The id of the album.
 * @param {number} disc The disc number of the album.
 * @return {URI} The album URI.
 */
URI.albumURI = function(id, disc) {
  return new URI(URI.Type.ALBUM, {id: id, disc: disc});
};

/**
 * Creates a new 'ad' type URI.
 *
 * @param {string} id The id of the ad.
 * @return {URI} The ad URI.
 */
URI.adURI = function(id) {
  return new URI(URI.Type.AD, {id: id});
};

/**
 * Creates a new 'audiofile' type URI.
 *
 * @param {string} extension The extension of the audiofile.
 * @param {string} id The id of the extension.
 * @return {URI} The audiofile URI.
 */
URI.audioFileURI = function(extension, id) {
  return new URI(URI.Type.AUDIO_FILE, {id: id, extension: extension});
};

/**
 * Creates a new 'artist' type URI.
 *
 * @param {string} id The id of the artist.
 * @return {URI} The artist URI.
 */
URI.artistURI = function(id) {
  return new URI(URI.Type.ARTIST, {id: id});
};

/**
 * Creates a new 'artist-toplist' type URI.
 *
 * @param {string} id The id of the artist.
 * @param {string} toplist The toplist type.
 * @return {URI} The artist-toplist URI.
 */
URI.artistToplistURI = function(id, toplist) {
  return new URI(URI.Type.ARTIST_TOPLIST, {id: id, toplist: toplist});
};

/**
 * Creates a new 'dailymix' type URI.
 *
 * @param {Array.<string>} args An array of arguments for the dailymix.
 * @return {URI} The dailymix URI.
 */
URI.dailyMixURI = function(id) {
  return new URI(URI.Type.DAILY_MIX, {id: id});
};

/**
 * Creates a new 'search' type URI.
 *
 * @param {string} query The unencoded search query.
 * @return {URI} The search URI
 */
URI.searchURI = function(query) {
  return new URI(URI.Type.SEARCH, {query: query});
};

/**
 * Creates a new 'track' type URI.
 *
 * @param {string} id The id of the track.
 * @param {string} anchor The point in the track formatted as mm:ss
 * @return {URI} The track URI.
 */
URI.trackURI = function(id, anchor, context, play) {
  return new URI(URI.Type.TRACK, {
    id: id,
    anchor: anchor,
    context: context ? URI.fromString(context) : context,
    play: play
  });
};

/**
 * Creates a new 'trackset' type URI.
 *
 * @param {Array.<URI>} tracks An array of 'track' type URIs.
 * @param {string} name The name of the trackset.
 * @param {number} index The index in the trackset.
 * @return {URI} The trackset URI.
 */
URI.tracksetURI = function(tracks, name, index) {
  return new URI(URI.Type.TRACKSET, {
    tracks: tracks,
    name: name || '',
    index: isNaN(index) ? null : index
  });
};

/**
 * Creates a new 'facebook' type URI.
 *
 * @param {string} uid The user id.
 * @return {URI} The facebook URI.
 */
URI.facebookURI = function(uid) {
  return new URI(URI.Type.FACEBOOK, {uid: uid});
};

/**
 * Creates a new 'followers' type URI.
 *
 * @param {string} username The non-canonical username.
 * @return {URI} The followers URI.
 */
URI.followersURI = function(username) {
  return new URI(URI.Type.FOLLOWERS, {username: username});
};

/**
 * Creates a new 'following' type URI.
 *
 * @param {string} username The non-canonical username.
 * @return {URI} The following URI.
 */
URI.followingURI = function(username) {
  return new URI(URI.Type.FOLLOWING, {username: username});
};

/**
 * Creates a new 'playlist' type URI.
 *
 * @param {string} username The non-canonical username of the playlist owner.
 * @param {string} id The id of the playlist.
 * @return {URI} The playlist URI.
 */
URI.playlistURI = function(username, id) {
  return new URI(URI.Type.PLAYLIST, {username: username, id: id});
};

/**
 * Creates a new 'playlist-v2' type URI.
 *
 * @param {string} id The id of the playlist.
 * @return {URI} The playlist URI.
 */
URI.playlistV2URI = function(id) {
  return new URI(URI.Type.PLAYLIST_V2, {id: id});
};

/**
 * Creates a new 'folder' type URI.
 *
 * @param {string} username The non-canonical username of the folder owner.
 * @param {string} id The id of the folder.
 * @return {URI} The folder URI.
 */
URI.folderURI = function(username, id) {
  return new URI(URI.Type.FOLDER, {username: username, id: id});
};

/**
 * Creates a new 'collectiontracklist' type URI.
 *
 * @param {string} username The non-canonical username of the collection owner.
 * @param {string} id The id of the tracklist.
 * @return {URI} The collectiontracklist URI.
 */
URI.collectionTrackList = function(username, id) {
  return new URI(URI.Type.COLLECTION_TRACK_LIST, {username: username, id: id});
};

/**
 * Creates a new 'starred' type URI.
 *
 * @param {string} username The non-canonical username of the starred list owner.
 * @return {URI} The starred URI.
 */
URI.starredURI = function(username) {
  return new URI(URI.Type.STARRED, {username: username});
};

/**
 * Creates a new 'user-toplist' type URI.
 *
 * @param {string} username The non-canonical username of the toplist owner.
 * @param {string} toplist The toplist type.
 * @return {URI} The user-toplist URI.
 */
URI.userToplistURI = function(username, toplist) {
  return new URI(URI.Type.USER_TOPLIST, {username: username, toplist: toplist});
};

/**
 * Creates a new 'user-top-tracks' type URI.
 *
 * @deprecated
 * @param {string} username The non-canonical username of the toplist owner.
 * @return {URI} The user-top-tracks URI.
 */
URI.userTopTracksURI = function(username) {
  return new URI(URI.Type.USER_TOP_TRACKS, {username: username});
};

/**
 * Creates a new 'toplist' type URI.
 *
 * @param {string} toplist The toplist type.
 * @param {string} country The country code for the toplist.
 * @param {boolean} global True if this is a global rather than a country list.
 * @return {URI} The toplist URI.
 */
URI.toplistURI = function(toplist, country, global) {
  return new URI(URI.Type.TOPLIST, {toplist: toplist, country: country, global: !!global});
};

/**
 * Creates a new 'inbox' type URI.
 *
 * @param {string} username The non-canonical username of the inbox owner.
 * @return {URI} The inbox URI.
 */
URI.inboxURI = function(username) {
  return new URI(URI.Type.INBOX, {username: username});
};

/**
 * Creates a new 'rootlist' type URI.
 *
 * @param {string} username The non-canonical username of the rootlist owner.
 * @return {URI} The rootlist URI.
 */
URI.rootlistURI = function(username) {
  return new URI(URI.Type.ROOTLIST, {username: username});
};

/**
 * Creates a new 'published-rootlist' type URI.
 *
 * @param {string} username The non-canonical username of the published-rootlist owner.
 * @return {URI} The published-rootlist URI.
 */
URI.publishedRootlistURI = function(username) {
  return new URI(URI.Type.PUBLISHED_ROOTLIST, {username: username});
};

/**
 * Creates a new 'local-artist' type URI.
 *
 * @param {string} artist The artist name.
 * @return {URI} The local-artist URI.
 */
URI.localArtistURI = function(artist) {
  return new URI(URI.Type.LOCAL_ARTIST, {artist: artist});
};

/**
 * Creates a new 'local-album' type URI.
 *
 * @param {string} artist The artist name.
 * @param {string} album The album name.
 * @return {URI} The local-album URI.
 */
URI.localAlbumURI = function(artist, album) {
  return new URI(URI.Type.LOCAL_ALBUM, {artist: artist, album: album});
};

/**
 * Creates a new 'local' type URI.
 *
 * @param {string} artist The artist name.
 * @param {string} album The album name.
 * @param {string} track The track name.
 * @param {number} duration The track duration in ms.
 * @return {URI} The local URI.
 */
URI.localURI = function(artist, album, track, duration) {
  return new URI(URI.Type.LOCAL, {
    artist: artist,
    album: album,
    track: track,
    duration: duration
  });
};

/**
 * Creates a new 'library' type URI.
 *
 * @param {string} username The non-canonical username of the rootlist owner.
 * @param {string} category The category of the library.
 * @return {URI} The library URI.
 */
URI.libraryURI = function(username, category) {
  return new URI(URI.Type.LIBRARY, {username: username, category: category});
};

/**
 * Creates a new 'collection' type URI.
 *
 * @param {string} username The non-canonical username of the rootlist owner.
 * @param {string} category The category of the collection.
 * @return {URI} The collection URI.
 */
URI.collectionURI = function(username, category) {
  return new URI(URI.Type.COLLECTION, {username: username, category: category});
};

/**
 * Creates a new 'temp-playlist' type URI.
 *
 * @param {string} origin The origin of the temporary playlist.
 * @param {string} data Additional data for the playlist.
 * @return {URI} The temp-playlist URI.
 */
URI.temporaryPlaylistURI = function(origin, data) {
  return new URI(URI.Type.TEMP_PLAYLIST, {origin: origin, data: data});
};

/**
 * Creates a new 'context-group' type URI.
 *
 * @deprecated
 * @param {string} origin The origin of the temporary playlist.
 * @param {string} name The name of the context group.
 * @return {URI} The context-group URI.
 */
URI.contextGroupURI = function(origin, name) {
  return new URI(URI.Type.CONTEXT_GROUP, {origin: origin, name: name});
};

/**
 * Creates a new 'profile' type URI.
 *
 * @param {string} username The non-canonical username of the rootlist owner.
 * @param {Array.<string>} args A list of arguments.
 * @return {URI} The profile URI.
 */
URI.profileURI = function(username, args) {
  return new URI(URI.Type.PROFILE, {username: username, args: args});
};

/**
 * Creates a new 'image' type URI.
 *
 * @param {string} id The id of the image.
 * @return {URI} The image URI.
 */
URI.imageURI = function(id) {
  return new URI(URI.Type.IMAGE, {id: id});
};

/**
 * Creates a new 'mosaic' type URI.
 *
 * @param {Array.<string>} ids The ids of the mosaic immages.
 * @return {URI} The mosaic URI.
 */
URI.mosaicURI = function(ids) {
  return new URI(URI.Type.MOSAIC, {ids: ids});
};

/**
 * Creates a new 'radio' type URI.
 *
 * @param {string} args The radio seed arguments.
 * @return {URI} The radio URI.
 */
URI.radioURI = function(args) {
  args = typeof args === 'undefined' ? '' : args;
  return new URI(URI.Type.RADIO, {args: args});
};

/**
 * Creates a new 'special' type URI.
 *
 * @param {Array.<string>} args An array containing the other arguments.
 * @return {URI} The special URI.
 */
URI.specialURI = function(args) {
  args = typeof args === 'undefined' ? [] : args;
  return new URI(URI.Type.SPECIAL, {args: args});
};

/**
 * Creates a new 'station' type URI.
 *
 * @param {Array.<string>} args An array of arguments for the station.
 * @return {URI} The station URI.
 */
URI.stationURI = function(args) {
  args = typeof args === 'undefined' ? [] : args;
  return new URI(URI.Type.STATION, {args: args});
};

/**
 * Creates a new 'application' type URI.
 *
 * @param {string} id The id of the application.
 * @param {Array.<string>} args An array containing the arguments to the app.
 * @return {URI} The application URI.
 */
URI.applicationURI = function(id, args) {
  args = typeof args === 'undefined' ? [] : args;
  return new URI(URI.Type.APPLICATION, {id: id, args: args});
};

/**
 * Creates a new 'collection-album' type URI.
 *
 * @param {string} username The non-canonical username of the rootlist owner.
 * @param {string} id The id of the album.
 * @return {URI} The collection-album URI.
 */
URI.collectionAlbumURI = function(username, id) {
  return new URI(URI.Type.COLLECTION_ALBUM, {username: username, id: id});
};

/**
 * Creates a new 'collection-album-missing' type URI.
 *
 * @param {string} username The non-canonical username of the rootlist owner.
 * @param {string} id The id of the album.
 * @return {URI} The collection-album-missing URI.
 */
URI.collectionMissingAlbumURI = function(username, id) {
  return new URI(URI.Type.COLLECTION_MISSING_ALBUM, {username: username, id: id});
};

/**
 * Creates a new 'collection-artist' type URI.
 *
 * @param {string} username The non-canonical username of the rootlist owner.
 * @param {string} id The id of the artist.
 * @return {URI} The collection-artist URI.
 */
URI.collectionArtistURI = function(username, id) {
  return new URI(URI.Type.COLLECTION_ARTIST, {username: username, id: id});
};

/**
 * Creates a new 'episode' type URI.
 *
 * @param {string} id The id of the episode.
 * @param {string} context An optional context URI
 * @param {boolean} play Toggles autoplay in the episode URI
 * @return {URI} The episode URI.
 */
URI.episodeURI = function(id, context, play) {
  return new URI(URI.Type.EPISODE, {
    id: id,
    context: context ? URI.fromString(context) : context,
    play: play
  });
};

/**
 * Creates a new 'show' type URI.
 *
 * @param {string} id The id of the show.
 * @return {URI} The show URI.
 */
URI.showURI = function(id) {
  return new URI(URI.Type.SHOW, {id: id});
};

/**
 * Creates a new 'concert' type URI.
 *
 * @param {string} id The id of the concert.
 * @return {URI} The concert URI.
 */
URI.concertURI = function(id) {
  return new URI(URI.Type.CONCERT, {id: id});
};

URI.isAlbum = function(uri) { return (URI.from(uri) || {}).type === URI.Type.ALBUM; };
URI.isAd = function(uri) { return (URI.from(uri) || {}).type === URI.Type.AD; };
URI.isApplication = function(uri) { return (URI.from(uri) || {}).type === URI.Type.APPLICATION; };
URI.isArtist = function(uri) { return (URI.from(uri) || {}).type === URI.Type.ARTIST; };
URI.isCollection = function(uri) { return (URI.from(uri) || {}).type === URI.Type.COLLECTION; };
URI.isCollectionAlbum = function(uri) { return (URI.from(uri) || {}).type === URI.Type.COLLECTION_ALBUM; };
URI.isCollectionArtist = function(uri) { return (URI.from(uri) || {}).type === URI.Type.COLLECTION_ARTIST; };
URI.isDailyMix = function(uri) { return (URI.from(uri) || {}).type === URI.Type.DAILY_MIX; };
URI.isEpisode = function(uri) { return (URI.from(uri) || {}).type === URI.Type.EPISODE; };
URI.isFacebook = function(uri) { return (URI.from(uri) || {}).type === URI.Type.FACEBOOK; };
URI.isFolder = function(uri) { return (URI.from(uri) || {}).type === URI.Type.FOLDER; };
URI.isLocalArtist = function(uri) { return (URI.from(uri) || {}).type === URI.Type.LOCAL_ARTIST; };
URI.isLocalAlbum = function(uri) { return (URI.from(uri) || {}).type === URI.Type.LOCAL_ALBUM; };
URI.isLocalTrack = function(uri) { return (URI.from(uri) || {}).type === URI.Type.LOCAL; };
URI.isMosaic = function(uri) { return (URI.from(uri) || {}).type === URI.Type.MOSAIC; };
URI.isPlaylistV1 = function(uri) { return (URI.from(uri) || {}).type === URI.Type.PLAYLIST; };
URI.isPlaylistV2 = function(uri) { return (URI.from(uri) || {}).type === URI.Type.PLAYLIST_V2; };
URI.isRadio = function(uri) { return (URI.from(uri) || {}).type === URI.Type.RADIO; };
URI.isRootlist = function(uri) { return (URI.from(uri) || {}).type === URI.Type.ROOTLIST; };
URI.isSearch = function(uri) { return (URI.from(uri) || {}).type === URI.Type.SEARCH; };
URI.isShow = function(uri) { return (URI.from(uri) || {}).type === URI.Type.SHOW; };
URI.isConcert = function(uri) { return (URI.from(uri) || {}).type === URI.Type.CONCERT; };
URI.isStation = function(uri) { return (URI.from(uri) || {}).type === URI.Type.STATION; };
URI.isTrack = function(uri) { return (URI.from(uri) || {}).type === URI.Type.TRACK; };
URI.isProfile = function(uri) { return (URI.from(uri) || {}).type === URI.Type.PROFILE; };
URI.isPlaylistV1OrV2 = function(uri) {
  var uriObject = URI.from(uri);
  return !!uriObject && (uriObject.type === URI.Type.PLAYLIST || uriObject.type === URI.Type.PLAYLIST_V2);
};

/**
 * Export public interface
 */
module.exports = URI;

},{"./base62":474}],476:[function(require,module,exports){
//     Underscore.js 1.8.3
//     http://underscorejs.org
//     (c) 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
//     Underscore may be freely distributed under the MIT license.

(function() {

  // Baseline setup
  // --------------

  // Establish the root object, `window` in the browser, or `exports` on the server.
  var root = this;

  // Save the previous value of the `_` variable.
  var previousUnderscore = root._;

  // Save bytes in the minified (but not gzipped) version:
  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;

  // Create quick reference variables for speed access to core prototypes.
  var
    push             = ArrayProto.push,
    slice            = ArrayProto.slice,
    toString         = ObjProto.toString,
    hasOwnProperty   = ObjProto.hasOwnProperty;

  // All **ECMAScript 5** native function implementations that we hope to use
  // are declared here.
  var
    nativeIsArray      = Array.isArray,
    nativeKeys         = Object.keys,
    nativeBind         = FuncProto.bind,
    nativeCreate       = Object.create;

  // Naked function reference for surrogate-prototype-swapping.
  var Ctor = function(){};

  // Create a safe reference to the Underscore object for use below.
  var _ = function(obj) {
    if (obj instanceof _) return obj;
    if (!(this instanceof _)) return new _(obj);
    this._wrapped = obj;
  };

  // Export the Underscore object for **Node.js**, with
  // backwards-compatibility for the old `require()` API. If we're in
  // the browser, add `_` as a global object.
  if (typeof exports !== 'undefined') {
    if (typeof module !== 'undefined' && module.exports) {
      exports = module.exports = _;
    }
    exports._ = _;
  } else {
    root._ = _;
  }

  // Current version.
  _.VERSION = '1.8.3';

  // Internal function that returns an efficient (for current engines) version
  // of the passed-in callback, to be repeatedly applied in other Underscore
  // functions.
  var optimizeCb = function(func, context, argCount) {
    if (context === void 0) return func;
    switch (argCount == null ? 3 : argCount) {
      case 1: return function(value) {
        return func.call(context, value);
      };
      case 2: return function(value, other) {
        return func.call(context, value, other);
      };
      case 3: return function(value, index, collection) {
        return func.call(context, value, index, collection);
      };
      case 4: return function(accumulator, value, index, collection) {
        return func.call(context, accumulator, value, index, collection);
      };
    }
    return function() {
      return func.apply(context, arguments);
    };
  };

  // A mostly-internal function to generate callbacks that can be applied
  // to each element in a collection, returning the desired result — either
  // identity, an arbitrary callback, a property matcher, or a property accessor.
  var cb = function(value, context, argCount) {
    if (value == null) return _.identity;
    if (_.isFunction(value)) return optimizeCb(value, context, argCount);
    if (_.isObject(value)) return _.matcher(value);
    return _.property(value);
  };
  _.iteratee = function(value, context) {
    return cb(value, context, Infinity);
  };

  // An internal function for creating assigner functions.
  var createAssigner = function(keysFunc, undefinedOnly) {
    return function(obj) {
      var length = arguments.length;
      if (length < 2 || obj == null) return obj;
      for (var index = 1; index < length; index++) {
        var source = arguments[index],
            keys = keysFunc(source),
            l = keys.length;
        for (var i = 0; i < l; i++) {
          var key = keys[i];
          if (!undefinedOnly || obj[key] === void 0) obj[key] = source[key];
        }
      }
      return obj;
    };
  };

  // An internal function for creating a new object that inherits from another.
  var baseCreate = function(prototype) {
    if (!_.isObject(prototype)) return {};
    if (nativeCreate) return nativeCreate(prototype);
    Ctor.prototype = prototype;
    var result = new Ctor;
    Ctor.prototype = null;
    return result;
  };

  var property = function(key) {
    return function(obj) {
      return obj == null ? void 0 : obj[key];
    };
  };

  // Helper for collection methods to determine whether a collection
  // should be iterated as an array or as an object
  // Related: http://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength
  // Avoids a very nasty iOS 8 JIT bug on ARM-64. #2094
  var MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;
  var getLength = property('length');
  var isArrayLike = function(collection) {
    var length = getLength(collection);
    return typeof length == 'number' && length >= 0 && length <= MAX_ARRAY_INDEX;
  };

  // Collection Functions
  // --------------------

  // The cornerstone, an `each` implementation, aka `forEach`.
  // Handles raw objects in addition to array-likes. Treats all
  // sparse array-likes as if they were dense.
  _.each = _.forEach = function(obj, iteratee, context) {
    iteratee = optimizeCb(iteratee, context);
    var i, length;
    if (isArrayLike(obj)) {
      for (i = 0, length = obj.length; i < length; i++) {
        iteratee(obj[i], i, obj);
      }
    } else {
      var keys = _.keys(obj);
      for (i = 0, length = keys.length; i < length; i++) {
        iteratee(obj[keys[i]], keys[i], obj);
      }
    }
    return obj;
  };

  // Return the results of applying the iteratee to each element.
  _.map = _.collect = function(obj, iteratee, context) {
    iteratee = cb(iteratee, context);
    var keys = !isArrayLike(obj) && _.keys(obj),
        length = (keys || obj).length,
        results = Array(length);
    for (var index = 0; index < length; index++) {
      var currentKey = keys ? keys[index] : index;
      results[index] = iteratee(obj[currentKey], currentKey, obj);
    }
    return results;
  };

  // Create a reducing function iterating left or right.
  function createReduce(dir) {
    // Optimized iterator function as using arguments.length
    // in the main function will deoptimize the, see #1991.
    function iterator(obj, iteratee, memo, keys, index, length) {
      for (; index >= 0 && index < length; index += dir) {
        var currentKey = keys ? keys[index] : index;
        memo = iteratee(memo, obj[currentKey], currentKey, obj);
      }
      return memo;
    }

    return function(obj, iteratee, memo, context) {
      iteratee = optimizeCb(iteratee, context, 4);
      var keys = !isArrayLike(obj) && _.keys(obj),
          length = (keys || obj).length,
          index = dir > 0 ? 0 : length - 1;
      // Determine the initial value if none is provided.
      if (arguments.length < 3) {
        memo = obj[keys ? keys[index] : index];
        index += dir;
      }
      return iterator(obj, iteratee, memo, keys, index, length);
    };
  }

  // **Reduce** builds up a single result from a list of values, aka `inject`,
  // or `foldl`.
  _.reduce = _.foldl = _.inject = createReduce(1);

  // The right-associative version of reduce, also known as `foldr`.
  _.reduceRight = _.foldr = createReduce(-1);

  // Return the first value which passes a truth test. Aliased as `detect`.
  _.find = _.detect = function(obj, predicate, context) {
    var key;
    if (isArrayLike(obj)) {
      key = _.findIndex(obj, predicate, context);
    } else {
      key = _.findKey(obj, predicate, context);
    }
    if (key !== void 0 && key !== -1) return obj[key];
  };

  // Return all the elements that pass a truth test.
  // Aliased as `select`.
  _.filter = _.select = function(obj, predicate, context) {
    var results = [];
    predicate = cb(predicate, context);
    _.each(obj, function(value, index, list) {
      if (predicate(value, index, list)) results.push(value);
    });
    return results;
  };

  // Return all the elements for which a truth test fails.
  _.reject = function(obj, predicate, context) {
    return _.filter(obj, _.negate(cb(predicate)), context);
  };

  // Determine whether all of the elements match a truth test.
  // Aliased as `all`.
  _.every = _.all = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var keys = !isArrayLike(obj) && _.keys(obj),
        length = (keys || obj).length;
    for (var index = 0; index < length; index++) {
      var currentKey = keys ? keys[index] : index;
      if (!predicate(obj[currentKey], currentKey, obj)) return false;
    }
    return true;
  };

  // Determine if at least one element in the object matches a truth test.
  // Aliased as `any`.
  _.some = _.any = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var keys = !isArrayLike(obj) && _.keys(obj),
        length = (keys || obj).length;
    for (var index = 0; index < length; index++) {
      var currentKey = keys ? keys[index] : index;
      if (predicate(obj[currentKey], currentKey, obj)) return true;
    }
    return false;
  };

  // Determine if the array or object contains a given item (using `===`).
  // Aliased as `includes` and `include`.
  _.contains = _.includes = _.include = function(obj, item, fromIndex, guard) {
    if (!isArrayLike(obj)) obj = _.values(obj);
    if (typeof fromIndex != 'number' || guard) fromIndex = 0;
    return _.indexOf(obj, item, fromIndex) >= 0;
  };

  // Invoke a method (with arguments) on every item in a collection.
  _.invoke = function(obj, method) {
    var args = slice.call(arguments, 2);
    var isFunc = _.isFunction(method);
    return _.map(obj, function(value) {
      var func = isFunc ? method : value[method];
      return func == null ? func : func.apply(value, args);
    });
  };

  // Convenience version of a common use case of `map`: fetching a property.
  _.pluck = function(obj, key) {
    return _.map(obj, _.property(key));
  };

  // Convenience version of a common use case of `filter`: selecting only objects
  // containing specific `key:value` pairs.
  _.where = function(obj, attrs) {
    return _.filter(obj, _.matcher(attrs));
  };

  // Convenience version of a common use case of `find`: getting the first object
  // containing specific `key:value` pairs.
  _.findWhere = function(obj, attrs) {
    return _.find(obj, _.matcher(attrs));
  };

  // Return the maximum element (or element-based computation).
  _.max = function(obj, iteratee, context) {
    var result = -Infinity, lastComputed = -Infinity,
        value, computed;
    if (iteratee == null && obj != null) {
      obj = isArrayLike(obj) ? obj : _.values(obj);
      for (var i = 0, length = obj.length; i < length; i++) {
        value = obj[i];
        if (value > result) {
          result = value;
        }
      }
    } else {
      iteratee = cb(iteratee, context);
      _.each(obj, function(value, index, list) {
        computed = iteratee(value, index, list);
        if (computed > lastComputed || computed === -Infinity && result === -Infinity) {
          result = value;
          lastComputed = computed;
        }
      });
    }
    return result;
  };

  // Return the minimum element (or element-based computation).
  _.min = function(obj, iteratee, context) {
    var result = Infinity, lastComputed = Infinity,
        value, computed;
    if (iteratee == null && obj != null) {
      obj = isArrayLike(obj) ? obj : _.values(obj);
      for (var i = 0, length = obj.length; i < length; i++) {
        value = obj[i];
        if (value < result) {
          result = value;
        }
      }
    } else {
      iteratee = cb(iteratee, context);
      _.each(obj, function(value, index, list) {
        computed = iteratee(value, index, list);
        if (computed < lastComputed || computed === Infinity && result === Infinity) {
          result = value;
          lastComputed = computed;
        }
      });
    }
    return result;
  };

  // Shuffle a collection, using the modern version of the
  // [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/Fisher–Yates_shuffle).
  _.shuffle = function(obj) {
    var set = isArrayLike(obj) ? obj : _.values(obj);
    var length = set.length;
    var shuffled = Array(length);
    for (var index = 0, rand; index < length; index++) {
      rand = _.random(0, index);
      if (rand !== index) shuffled[index] = shuffled[rand];
      shuffled[rand] = set[index];
    }
    return shuffled;
  };

  // Sample **n** random values from a collection.
  // If **n** is not specified, returns a single random element.
  // The internal `guard` argument allows it to work with `map`.
  _.sample = function(obj, n, guard) {
    if (n == null || guard) {
      if (!isArrayLike(obj)) obj = _.values(obj);
      return obj[_.random(obj.length - 1)];
    }
    return _.shuffle(obj).slice(0, Math.max(0, n));
  };

  // Sort the object's values by a criterion produced by an iteratee.
  _.sortBy = function(obj, iteratee, context) {
    iteratee = cb(iteratee, context);
    return _.pluck(_.map(obj, function(value, index, list) {
      return {
        value: value,
        index: index,
        criteria: iteratee(value, index, list)
      };
    }).sort(function(left, right) {
      var a = left.criteria;
      var b = right.criteria;
      if (a !== b) {
        if (a > b || a === void 0) return 1;
        if (a < b || b === void 0) return -1;
      }
      return left.index - right.index;
    }), 'value');
  };

  // An internal function used for aggregate "group by" operations.
  var group = function(behavior) {
    return function(obj, iteratee, context) {
      var result = {};
      iteratee = cb(iteratee, context);
      _.each(obj, function(value, index) {
        var key = iteratee(value, index, obj);
        behavior(result, value, key);
      });
      return result;
    };
  };

  // Groups the object's values by a criterion. Pass either a string attribute
  // to group by, or a function that returns the criterion.
  _.groupBy = group(function(result, value, key) {
    if (_.has(result, key)) result[key].push(value); else result[key] = [value];
  });

  // Indexes the object's values by a criterion, similar to `groupBy`, but for
  // when you know that your index values will be unique.
  _.indexBy = group(function(result, value, key) {
    result[key] = value;
  });

  // Counts instances of an object that group by a certain criterion. Pass
  // either a string attribute to count by, or a function that returns the
  // criterion.
  _.countBy = group(function(result, value, key) {
    if (_.has(result, key)) result[key]++; else result[key] = 1;
  });

  // Safely create a real, live array from anything iterable.
  _.toArray = function(obj) {
    if (!obj) return [];
    if (_.isArray(obj)) return slice.call(obj);
    if (isArrayLike(obj)) return _.map(obj, _.identity);
    return _.values(obj);
  };

  // Return the number of elements in an object.
  _.size = function(obj) {
    if (obj == null) return 0;
    return isArrayLike(obj) ? obj.length : _.keys(obj).length;
  };

  // Split a collection into two arrays: one whose elements all satisfy the given
  // predicate, and one whose elements all do not satisfy the predicate.
  _.partition = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var pass = [], fail = [];
    _.each(obj, function(value, key, obj) {
      (predicate(value, key, obj) ? pass : fail).push(value);
    });
    return [pass, fail];
  };

  // Array Functions
  // ---------------

  // Get the first element of an array. Passing **n** will return the first N
  // values in the array. Aliased as `head` and `take`. The **guard** check
  // allows it to work with `_.map`.
  _.first = _.head = _.take = function(array, n, guard) {
    if (array == null) return void 0;
    if (n == null || guard) return array[0];
    return _.initial(array, array.length - n);
  };

  // Returns everything but the last entry of the array. Especially useful on
  // the arguments object. Passing **n** will return all the values in
  // the array, excluding the last N.
  _.initial = function(array, n, guard) {
    return slice.call(array, 0, Math.max(0, array.length - (n == null || guard ? 1 : n)));
  };

  // Get the last element of an array. Passing **n** will return the last N
  // values in the array.
  _.last = function(array, n, guard) {
    if (array == null) return void 0;
    if (n == null || guard) return array[array.length - 1];
    return _.rest(array, Math.max(0, array.length - n));
  };

  // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.
  // Especially useful on the arguments object. Passing an **n** will return
  // the rest N values in the array.
  _.rest = _.tail = _.drop = function(array, n, guard) {
    return slice.call(array, n == null || guard ? 1 : n);
  };

  // Trim out all falsy values from an array.
  _.compact = function(array) {
    return _.filter(array, _.identity);
  };

  // Internal implementation of a recursive `flatten` function.
  var flatten = function(input, shallow, strict, startIndex) {
    var output = [], idx = 0;
    for (var i = startIndex || 0, length = getLength(input); i < length; i++) {
      var value = input[i];
      if (isArrayLike(value) && (_.isArray(value) || _.isArguments(value))) {
        //flatten current level of array or arguments object
        if (!shallow) value = flatten(value, shallow, strict);
        var j = 0, len = value.length;
        output.length += len;
        while (j < len) {
          output[idx++] = value[j++];
        }
      } else if (!strict) {
        output[idx++] = value;
      }
    }
    return output;
  };

  // Flatten out an array, either recursively (by default), or just one level.
  _.flatten = function(array, shallow) {
    return flatten(array, shallow, false);
  };

  // Return a version of the array that does not contain the specified value(s).
  _.without = function(array) {
    return _.difference(array, slice.call(arguments, 1));
  };

  // Produce a duplicate-free version of the array. If the array has already
  // been sorted, you have the option of using a faster algorithm.
  // Aliased as `unique`.
  _.uniq = _.unique = function(array, isSorted, iteratee, context) {
    if (!_.isBoolean(isSorted)) {
      context = iteratee;
      iteratee = isSorted;
      isSorted = false;
    }
    if (iteratee != null) iteratee = cb(iteratee, context);
    var result = [];
    var seen = [];
    for (var i = 0, length = getLength(array); i < length; i++) {
      var value = array[i],
          computed = iteratee ? iteratee(value, i, array) : value;
      if (isSorted) {
        if (!i || seen !== computed) result.push(value);
        seen = computed;
      } else if (iteratee) {
        if (!_.contains(seen, computed)) {
          seen.push(computed);
          result.push(value);
        }
      } else if (!_.contains(result, value)) {
        result.push(value);
      }
    }
    return result;
  };

  // Produce an array that contains the union: each distinct element from all of
  // the passed-in arrays.
  _.union = function() {
    return _.uniq(flatten(arguments, true, true));
  };

  // Produce an array that contains every item shared between all the
  // passed-in arrays.
  _.intersection = function(array) {
    var result = [];
    var argsLength = arguments.length;
    for (var i = 0, length = getLength(array); i < length; i++) {
      var item = array[i];
      if (_.contains(result, item)) continue;
      for (var j = 1; j < argsLength; j++) {
        if (!_.contains(arguments[j], item)) break;
      }
      if (j === argsLength) result.push(item);
    }
    return result;
  };

  // Take the difference between one array and a number of other arrays.
  // Only the elements present in just the first array will remain.
  _.difference = function(array) {
    var rest = flatten(arguments, true, true, 1);
    return _.filter(array, function(value){
      return !_.contains(rest, value);
    });
  };

  // Zip together multiple lists into a single array -- elements that share
  // an index go together.
  _.zip = function() {
    return _.unzip(arguments);
  };

  // Complement of _.zip. Unzip accepts an array of arrays and groups
  // each array's elements on shared indices
  _.unzip = function(array) {
    var length = array && _.max(array, getLength).length || 0;
    var result = Array(length);

    for (var index = 0; index < length; index++) {
      result[index] = _.pluck(array, index);
    }
    return result;
  };

  // Converts lists into objects. Pass either a single array of `[key, value]`
  // pairs, or two parallel arrays of the same length -- one of keys, and one of
  // the corresponding values.
  _.object = function(list, values) {
    var result = {};
    for (var i = 0, length = getLength(list); i < length; i++) {
      if (values) {
        result[list[i]] = values[i];
      } else {
        result[list[i][0]] = list[i][1];
      }
    }
    return result;
  };

  // Generator function to create the findIndex and findLastIndex functions
  function createPredicateIndexFinder(dir) {
    return function(array, predicate, context) {
      predicate = cb(predicate, context);
      var length = getLength(array);
      var index = dir > 0 ? 0 : length - 1;
      for (; index >= 0 && index < length; index += dir) {
        if (predicate(array[index], index, array)) return index;
      }
      return -1;
    };
  }

  // Returns the first index on an array-like that passes a predicate test
  _.findIndex = createPredicateIndexFinder(1);
  _.findLastIndex = createPredicateIndexFinder(-1);

  // Use a comparator function to figure out the smallest index at which
  // an object should be inserted so as to maintain order. Uses binary search.
  _.sortedIndex = function(array, obj, iteratee, context) {
    iteratee = cb(iteratee, context, 1);
    var value = iteratee(obj);
    var low = 0, high = getLength(array);
    while (low < high) {
      var mid = Math.floor((low + high) / 2);
      if (iteratee(array[mid]) < value) low = mid + 1; else high = mid;
    }
    return low;
  };

  // Generator function to create the indexOf and lastIndexOf functions
  function createIndexFinder(dir, predicateFind, sortedIndex) {
    return function(array, item, idx) {
      var i = 0, length = getLength(array);
      if (typeof idx == 'number') {
        if (dir > 0) {
            i = idx >= 0 ? idx : Math.max(idx + length, i);
        } else {
            length = idx >= 0 ? Math.min(idx + 1, length) : idx + length + 1;
        }
      } else if (sortedIndex && idx && length) {
        idx = sortedIndex(array, item);
        return array[idx] === item ? idx : -1;
      }
      if (item !== item) {
        idx = predicateFind(slice.call(array, i, length), _.isNaN);
        return idx >= 0 ? idx + i : -1;
      }
      for (idx = dir > 0 ? i : length - 1; idx >= 0 && idx < length; idx += dir) {
        if (array[idx] === item) return idx;
      }
      return -1;
    };
  }

  // Return the position of the first occurrence of an item in an array,
  // or -1 if the item is not included in the array.
  // If the array is large and already in sort order, pass `true`
  // for **isSorted** to use binary search.
  _.indexOf = createIndexFinder(1, _.findIndex, _.sortedIndex);
  _.lastIndexOf = createIndexFinder(-1, _.findLastIndex);

  // Generate an integer Array containing an arithmetic progression. A port of
  // the native Python `range()` function. See
  // [the Python documentation](http://docs.python.org/library/functions.html#range).
  _.range = function(start, stop, step) {
    if (stop == null) {
      stop = start || 0;
      start = 0;
    }
    step = step || 1;

    var length = Math.max(Math.ceil((stop - start) / step), 0);
    var range = Array(length);

    for (var idx = 0; idx < length; idx++, start += step) {
      range[idx] = start;
    }

    return range;
  };

  // Function (ahem) Functions
  // ------------------

  // Determines whether to execute a function as a constructor
  // or a normal function with the provided arguments
  var executeBound = function(sourceFunc, boundFunc, context, callingContext, args) {
    if (!(callingContext instanceof boundFunc)) return sourceFunc.apply(context, args);
    var self = baseCreate(sourceFunc.prototype);
    var result = sourceFunc.apply(self, args);
    if (_.isObject(result)) return result;
    return self;
  };

  // Create a function bound to a given object (assigning `this`, and arguments,
  // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if
  // available.
  _.bind = function(func, context) {
    if (nativeBind && func.bind === nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));
    if (!_.isFunction(func)) throw new TypeError('Bind must be called on a function');
    var args = slice.call(arguments, 2);
    var bound = function() {
      return executeBound(func, bound, context, this, args.concat(slice.call(arguments)));
    };
    return bound;
  };

  // Partially apply a function by creating a version that has had some of its
  // arguments pre-filled, without changing its dynamic `this` context. _ acts
  // as a placeholder, allowing any combination of arguments to be pre-filled.
  _.partial = function(func) {
    var boundArgs = slice.call(arguments, 1);
    var bound = function() {
      var position = 0, length = boundArgs.length;
      var args = Array(length);
      for (var i = 0; i < length; i++) {
        args[i] = boundArgs[i] === _ ? arguments[position++] : boundArgs[i];
      }
      while (position < arguments.length) args.push(arguments[position++]);
      return executeBound(func, bound, this, this, args);
    };
    return bound;
  };

  // Bind a number of an object's methods to that object. Remaining arguments
  // are the method names to be bound. Useful for ensuring that all callbacks
  // defined on an object belong to it.
  _.bindAll = function(obj) {
    var i, length = arguments.length, key;
    if (length <= 1) throw new Error('bindAll must be passed function names');
    for (i = 1; i < length; i++) {
      key = arguments[i];
      obj[key] = _.bind(obj[key], obj);
    }
    return obj;
  };

  // Memoize an expensive function by storing its results.
  _.memoize = function(func, hasher) {
    var memoize = function(key) {
      var cache = memoize.cache;
      var address = '' + (hasher ? hasher.apply(this, arguments) : key);
      if (!_.has(cache, address)) cache[address] = func.apply(this, arguments);
      return cache[address];
    };
    memoize.cache = {};
    return memoize;
  };

  // Delays a function for the given number of milliseconds, and then calls
  // it with the arguments supplied.
  _.delay = function(func, wait) {
    var args = slice.call(arguments, 2);
    return setTimeout(function(){
      return func.apply(null, args);
    }, wait);
  };

  // Defers a function, scheduling it to run after the current call stack has
  // cleared.
  _.defer = _.partial(_.delay, _, 1);

  // Returns a function, that, when invoked, will only be triggered at most once
  // during a given window of time. Normally, the throttled function will run
  // as much as it can, without ever going more than once per `wait` duration;
  // but if you'd like to disable the execution on the leading edge, pass
  // `{leading: false}`. To disable execution on the trailing edge, ditto.
  _.throttle = function(func, wait, options) {
    var context, args, result;
    var timeout = null;
    var previous = 0;
    if (!options) options = {};
    var later = function() {
      previous = options.leading === false ? 0 : _.now();
      timeout = null;
      result = func.apply(context, args);
      if (!timeout) context = args = null;
    };
    return function() {
      var now = _.now();
      if (!previous && options.leading === false) previous = now;
      var remaining = wait - (now - previous);
      context = this;
      args = arguments;
      if (remaining <= 0 || remaining > wait) {
        if (timeout) {
          clearTimeout(timeout);
          timeout = null;
        }
        previous = now;
        result = func.apply(context, args);
        if (!timeout) context = args = null;
      } else if (!timeout && options.trailing !== false) {
        timeout = setTimeout(later, remaining);
      }
      return result;
    };
  };

  // Returns a function, that, as long as it continues to be invoked, will not
  // be triggered. The function will be called after it stops being called for
  // N milliseconds. If `immediate` is passed, trigger the function on the
  // leading edge, instead of the trailing.
  _.debounce = function(func, wait, immediate) {
    var timeout, args, context, timestamp, result;

    var later = function() {
      var last = _.now() - timestamp;

      if (last < wait && last >= 0) {
        timeout = setTimeout(later, wait - last);
      } else {
        timeout = null;
        if (!immediate) {
          result = func.apply(context, args);
          if (!timeout) context = args = null;
        }
      }
    };

    return function() {
      context = this;
      args = arguments;
      timestamp = _.now();
      var callNow = immediate && !timeout;
      if (!timeout) timeout = setTimeout(later, wait);
      if (callNow) {
        result = func.apply(context, args);
        context = args = null;
      }

      return result;
    };
  };

  // Returns the first function passed as an argument to the second,
  // allowing you to adjust arguments, run code before and after, and
  // conditionally execute the original function.
  _.wrap = function(func, wrapper) {
    return _.partial(wrapper, func);
  };

  // Returns a negated version of the passed-in predicate.
  _.negate = function(predicate) {
    return function() {
      return !predicate.apply(this, arguments);
    };
  };

  // Returns a function that is the composition of a list of functions, each
  // consuming the return value of the function that follows.
  _.compose = function() {
    var args = arguments;
    var start = args.length - 1;
    return function() {
      var i = start;
      var result = args[start].apply(this, arguments);
      while (i--) result = args[i].call(this, result);
      return result;
    };
  };

  // Returns a function that will only be executed on and after the Nth call.
  _.after = function(times, func) {
    return function() {
      if (--times < 1) {
        return func.apply(this, arguments);
      }
    };
  };

  // Returns a function that will only be executed up to (but not including) the Nth call.
  _.before = function(times, func) {
    var memo;
    return function() {
      if (--times > 0) {
        memo = func.apply(this, arguments);
      }
      if (times <= 1) func = null;
      return memo;
    };
  };

  // Returns a function that will be executed at most one time, no matter how
  // often you call it. Useful for lazy initialization.
  _.once = _.partial(_.before, 2);

  // Object Functions
  // ----------------

  // Keys in IE < 9 that won't be iterated by `for key in ...` and thus missed.
  var hasEnumBug = !{toString: null}.propertyIsEnumerable('toString');
  var nonEnumerableProps = ['valueOf', 'isPrototypeOf', 'toString',
                      'propertyIsEnumerable', 'hasOwnProperty', 'toLocaleString'];

  function collectNonEnumProps(obj, keys) {
    var nonEnumIdx = nonEnumerableProps.length;
    var constructor = obj.constructor;
    var proto = (_.isFunction(constructor) && constructor.prototype) || ObjProto;

    // Constructor is a special case.
    var prop = 'constructor';
    if (_.has(obj, prop) && !_.contains(keys, prop)) keys.push(prop);

    while (nonEnumIdx--) {
      prop = nonEnumerableProps[nonEnumIdx];
      if (prop in obj && obj[prop] !== proto[prop] && !_.contains(keys, prop)) {
        keys.push(prop);
      }
    }
  }

  // Retrieve the names of an object's own properties.
  // Delegates to **ECMAScript 5**'s native `Object.keys`
  _.keys = function(obj) {
    if (!_.isObject(obj)) return [];
    if (nativeKeys) return nativeKeys(obj);
    var keys = [];
    for (var key in obj) if (_.has(obj, key)) keys.push(key);
    // Ahem, IE < 9.
    if (hasEnumBug) collectNonEnumProps(obj, keys);
    return keys;
  };

  // Retrieve all the property names of an object.
  _.allKeys = function(obj) {
    if (!_.isObject(obj)) return [];
    var keys = [];
    for (var key in obj) keys.push(key);
    // Ahem, IE < 9.
    if (hasEnumBug) collectNonEnumProps(obj, keys);
    return keys;
  };

  // Retrieve the values of an object's properties.
  _.values = function(obj) {
    var keys = _.keys(obj);
    var length = keys.length;
    var values = Array(length);
    for (var i = 0; i < length; i++) {
      values[i] = obj[keys[i]];
    }
    return values;
  };

  // Returns the results of applying the iteratee to each element of the object
  // In contrast to _.map it returns an object
  _.mapObject = function(obj, iteratee, context) {
    iteratee = cb(iteratee, context);
    var keys =  _.keys(obj),
          length = keys.length,
          results = {},
          currentKey;
      for (var index = 0; index < length; index++) {
        currentKey = keys[index];
        results[currentKey] = iteratee(obj[currentKey], currentKey, obj);
      }
      return results;
  };

  // Convert an object into a list of `[key, value]` pairs.
  _.pairs = function(obj) {
    var keys = _.keys(obj);
    var length = keys.length;
    var pairs = Array(length);
    for (var i = 0; i < length; i++) {
      pairs[i] = [keys[i], obj[keys[i]]];
    }
    return pairs;
  };

  // Invert the keys and values of an object. The values must be serializable.
  _.invert = function(obj) {
    var result = {};
    var keys = _.keys(obj);
    for (var i = 0, length = keys.length; i < length; i++) {
      result[obj[keys[i]]] = keys[i];
    }
    return result;
  };

  // Return a sorted list of the function names available on the object.
  // Aliased as `methods`
  _.functions = _.methods = function(obj) {
    var names = [];
    for (var key in obj) {
      if (_.isFunction(obj[key])) names.push(key);
    }
    return names.sort();
  };

  // Extend a given object with all the properties in passed-in object(s).
  _.extend = createAssigner(_.allKeys);

  // Assigns a given object with all the own properties in the passed-in object(s)
  // (https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/assign)
  _.extendOwn = _.assign = createAssigner(_.keys);

  // Returns the first key on an object that passes a predicate test
  _.findKey = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var keys = _.keys(obj), key;
    for (var i = 0, length = keys.length; i < length; i++) {
      key = keys[i];
      if (predicate(obj[key], key, obj)) return key;
    }
  };

  // Return a copy of the object only containing the whitelisted properties.
  _.pick = function(object, oiteratee, context) {
    var result = {}, obj = object, iteratee, keys;
    if (obj == null) return result;
    if (_.isFunction(oiteratee)) {
      keys = _.allKeys(obj);
      iteratee = optimizeCb(oiteratee, context);
    } else {
      keys = flatten(arguments, false, false, 1);
      iteratee = function(value, key, obj) { return key in obj; };
      obj = Object(obj);
    }
    for (var i = 0, length = keys.length; i < length; i++) {
      var key = keys[i];
      var value = obj[key];
      if (iteratee(value, key, obj)) result[key] = value;
    }
    return result;
  };

   // Return a copy of the object without the blacklisted properties.
  _.omit = function(obj, iteratee, context) {
    if (_.isFunction(iteratee)) {
      iteratee = _.negate(iteratee);
    } else {
      var keys = _.map(flatten(arguments, false, false, 1), String);
      iteratee = function(value, key) {
        return !_.contains(keys, key);
      };
    }
    return _.pick(obj, iteratee, context);
  };

  // Fill in a given object with default properties.
  _.defaults = createAssigner(_.allKeys, true);

  // Creates an object that inherits from the given prototype object.
  // If additional properties are provided then they will be added to the
  // created object.
  _.create = function(prototype, props) {
    var result = baseCreate(prototype);
    if (props) _.extendOwn(result, props);
    return result;
  };

  // Create a (shallow-cloned) duplicate of an object.
  _.clone = function(obj) {
    if (!_.isObject(obj)) return obj;
    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);
  };

  // Invokes interceptor with the obj, and then returns obj.
  // The primary purpose of this method is to "tap into" a method chain, in
  // order to perform operations on intermediate results within the chain.
  _.tap = function(obj, interceptor) {
    interceptor(obj);
    return obj;
  };

  // Returns whether an object has a given set of `key:value` pairs.
  _.isMatch = function(object, attrs) {
    var keys = _.keys(attrs), length = keys.length;
    if (object == null) return !length;
    var obj = Object(object);
    for (var i = 0; i < length; i++) {
      var key = keys[i];
      if (attrs[key] !== obj[key] || !(key in obj)) return false;
    }
    return true;
  };


  // Internal recursive comparison function for `isEqual`.
  var eq = function(a, b, aStack, bStack) {
    // Identical objects are equal. `0 === -0`, but they aren't identical.
    // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).
    if (a === b) return a !== 0 || 1 / a === 1 / b;
    // A strict comparison is necessary because `null == undefined`.
    if (a == null || b == null) return a === b;
    // Unwrap any wrapped objects.
    if (a instanceof _) a = a._wrapped;
    if (b instanceof _) b = b._wrapped;
    // Compare `[[Class]]` names.
    var className = toString.call(a);
    if (className !== toString.call(b)) return false;
    switch (className) {
      // Strings, numbers, regular expressions, dates, and booleans are compared by value.
      case '[object RegExp]':
      // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')
      case '[object String]':
        // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
        // equivalent to `new String("5")`.
        return '' + a === '' + b;
      case '[object Number]':
        // `NaN`s are equivalent, but non-reflexive.
        // Object(NaN) is equivalent to NaN
        if (+a !== +a) return +b !== +b;
        // An `egal` comparison is performed for other numeric values.
        return +a === 0 ? 1 / +a === 1 / b : +a === +b;
      case '[object Date]':
      case '[object Boolean]':
        // Coerce dates and booleans to numeric primitive values. Dates are compared by their
        // millisecond representations. Note that invalid dates with millisecond representations
        // of `NaN` are not equivalent.
        return +a === +b;
    }

    var areArrays = className === '[object Array]';
    if (!areArrays) {
      if (typeof a != 'object' || typeof b != 'object') return false;

      // Objects with different constructors are not equivalent, but `Object`s or `Array`s
      // from different frames are.
      var aCtor = a.constructor, bCtor = b.constructor;
      if (aCtor !== bCtor && !(_.isFunction(aCtor) && aCtor instanceof aCtor &&
                               _.isFunction(bCtor) && bCtor instanceof bCtor)
                          && ('constructor' in a && 'constructor' in b)) {
        return false;
      }
    }
    // Assume equality for cyclic structures. The algorithm for detecting cyclic
    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.

    // Initializing stack of traversed objects.
    // It's done here since we only need them for objects and arrays comparison.
    aStack = aStack || [];
    bStack = bStack || [];
    var length = aStack.length;
    while (length--) {
      // Linear search. Performance is inversely proportional to the number of
      // unique nested structures.
      if (aStack[length] === a) return bStack[length] === b;
    }

    // Add the first object to the stack of traversed objects.
    aStack.push(a);
    bStack.push(b);

    // Recursively compare objects and arrays.
    if (areArrays) {
      // Compare array lengths to determine if a deep comparison is necessary.
      length = a.length;
      if (length !== b.length) return false;
      // Deep compare the contents, ignoring non-numeric properties.
      while (length--) {
        if (!eq(a[length], b[length], aStack, bStack)) return false;
      }
    } else {
      // Deep compare objects.
      var keys = _.keys(a), key;
      length = keys.length;
      // Ensure that both objects contain the same number of properties before comparing deep equality.
      if (_.keys(b).length !== length) return false;
      while (length--) {
        // Deep compare each member
        key = keys[length];
        if (!(_.has(b, key) && eq(a[key], b[key], aStack, bStack))) return false;
      }
    }
    // Remove the first object from the stack of traversed objects.
    aStack.pop();
    bStack.pop();
    return true;
  };

  // Perform a deep comparison to check if two objects are equal.
  _.isEqual = function(a, b) {
    return eq(a, b);
  };

  // Is a given array, string, or object empty?
  // An "empty" object has no enumerable own-properties.
  _.isEmpty = function(obj) {
    if (obj == null) return true;
    if (isArrayLike(obj) && (_.isArray(obj) || _.isString(obj) || _.isArguments(obj))) return obj.length === 0;
    return _.keys(obj).length === 0;
  };

  // Is a given value a DOM element?
  _.isElement = function(obj) {
    return !!(obj && obj.nodeType === 1);
  };

  // Is a given value an array?
  // Delegates to ECMA5's native Array.isArray
  _.isArray = nativeIsArray || function(obj) {
    return toString.call(obj) === '[object Array]';
  };

  // Is a given variable an object?
  _.isObject = function(obj) {
    var type = typeof obj;
    return type === 'function' || type === 'object' && !!obj;
  };

  // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp, isError.
  _.each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp', 'Error'], function(name) {
    _['is' + name] = function(obj) {
      return toString.call(obj) === '[object ' + name + ']';
    };
  });

  // Define a fallback version of the method in browsers (ahem, IE < 9), where
  // there isn't any inspectable "Arguments" type.
  if (!_.isArguments(arguments)) {
    _.isArguments = function(obj) {
      return _.has(obj, 'callee');
    };
  }

  // Optimize `isFunction` if appropriate. Work around some typeof bugs in old v8,
  // IE 11 (#1621), and in Safari 8 (#1929).
  if (typeof /./ != 'function' && typeof Int8Array != 'object') {
    _.isFunction = function(obj) {
      return typeof obj == 'function' || false;
    };
  }

  // Is a given object a finite number?
  _.isFinite = function(obj) {
    return isFinite(obj) && !isNaN(parseFloat(obj));
  };

  // Is the given value `NaN`? (NaN is the only number which does not equal itself).
  _.isNaN = function(obj) {
    return _.isNumber(obj) && obj !== +obj;
  };

  // Is a given value a boolean?
  _.isBoolean = function(obj) {
    return obj === true || obj === false || toString.call(obj) === '[object Boolean]';
  };

  // Is a given value equal to null?
  _.isNull = function(obj) {
    return obj === null;
  };

  // Is a given variable undefined?
  _.isUndefined = function(obj) {
    return obj === void 0;
  };

  // Shortcut function for checking if an object has a given property directly
  // on itself (in other words, not on a prototype).
  _.has = function(obj, key) {
    return obj != null && hasOwnProperty.call(obj, key);
  };

  // Utility Functions
  // -----------------

  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its
  // previous owner. Returns a reference to the Underscore object.
  _.noConflict = function() {
    root._ = previousUnderscore;
    return this;
  };

  // Keep the identity function around for default iteratees.
  _.identity = function(value) {
    return value;
  };

  // Predicate-generating functions. Often useful outside of Underscore.
  _.constant = function(value) {
    return function() {
      return value;
    };
  };

  _.noop = function(){};

  _.property = property;

  // Generates a function for a given object that returns a given property.
  _.propertyOf = function(obj) {
    return obj == null ? function(){} : function(key) {
      return obj[key];
    };
  };

  // Returns a predicate for checking whether an object has a given set of
  // `key:value` pairs.
  _.matcher = _.matches = function(attrs) {
    attrs = _.extendOwn({}, attrs);
    return function(obj) {
      return _.isMatch(obj, attrs);
    };
  };

  // Run a function **n** times.
  _.times = function(n, iteratee, context) {
    var accum = Array(Math.max(0, n));
    iteratee = optimizeCb(iteratee, context, 1);
    for (var i = 0; i < n; i++) accum[i] = iteratee(i);
    return accum;
  };

  // Return a random integer between min and max (inclusive).
  _.random = function(min, max) {
    if (max == null) {
      max = min;
      min = 0;
    }
    return min + Math.floor(Math.random() * (max - min + 1));
  };

  // A (possibly faster) way to get the current timestamp as an integer.
  _.now = Date.now || function() {
    return new Date().getTime();
  };

   // List of HTML entities for escaping.
  var escapeMap = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#x27;',
    '`': '&#x60;'
  };
  var unescapeMap = _.invert(escapeMap);

  // Functions for escaping and unescaping strings to/from HTML interpolation.
  var createEscaper = function(map) {
    var escaper = function(match) {
      return map[match];
    };
    // Regexes for identifying a key that needs to be escaped
    var source = '(?:' + _.keys(map).join('|') + ')';
    var testRegexp = RegExp(source);
    var replaceRegexp = RegExp(source, 'g');
    return function(string) {
      string = string == null ? '' : '' + string;
      return testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string;
    };
  };
  _.escape = createEscaper(escapeMap);
  _.unescape = createEscaper(unescapeMap);

  // If the value of the named `property` is a function then invoke it with the
  // `object` as context; otherwise, return it.
  _.result = function(object, property, fallback) {
    var value = object == null ? void 0 : object[property];
    if (value === void 0) {
      value = fallback;
    }
    return _.isFunction(value) ? value.call(object) : value;
  };

  // Generate a unique integer id (unique within the entire client session).
  // Useful for temporary DOM ids.
  var idCounter = 0;
  _.uniqueId = function(prefix) {
    var id = ++idCounter + '';
    return prefix ? prefix + id : id;
  };

  // By default, Underscore uses ERB-style template delimiters, change the
  // following template settings to use alternative delimiters.
  _.templateSettings = {
    evaluate    : /<%([\s\S]+?)%>/g,
    interpolate : /<%=([\s\S]+?)%>/g,
    escape      : /<%-([\s\S]+?)%>/g
  };

  // When customizing `templateSettings`, if you don't want to define an
  // interpolation, evaluation or escaping regex, we need one that is
  // guaranteed not to match.
  var noMatch = /(.)^/;

  // Certain characters need to be escaped so that they can be put into a
  // string literal.
  var escapes = {
    "'":      "'",
    '\\':     '\\',
    '\r':     'r',
    '\n':     'n',
    '\u2028': 'u2028',
    '\u2029': 'u2029'
  };

  var escaper = /\\|'|\r|\n|\u2028|\u2029/g;

  var escapeChar = function(match) {
    return '\\' + escapes[match];
  };

  // JavaScript micro-templating, similar to John Resig's implementation.
  // Underscore templating handles arbitrary delimiters, preserves whitespace,
  // and correctly escapes quotes within interpolated code.
  // NB: `oldSettings` only exists for backwards compatibility.
  _.template = function(text, settings, oldSettings) {
    if (!settings && oldSettings) settings = oldSettings;
    settings = _.defaults({}, settings, _.templateSettings);

    // Combine delimiters into one regular expression via alternation.
    var matcher = RegExp([
      (settings.escape || noMatch).source,
      (settings.interpolate || noMatch).source,
      (settings.evaluate || noMatch).source
    ].join('|') + '|$', 'g');

    // Compile the template source, escaping string literals appropriately.
    var index = 0;
    var source = "__p+='";
    text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {
      source += text.slice(index, offset).replace(escaper, escapeChar);
      index = offset + match.length;

      if (escape) {
        source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
      } else if (interpolate) {
        source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
      } else if (evaluate) {
        source += "';\n" + evaluate + "\n__p+='";
      }

      // Adobe VMs need the match returned to produce the correct offest.
      return match;
    });
    source += "';\n";

    // If a variable is not specified, place data values in local scope.
    if (!settings.variable) source = 'with(obj||{}){\n' + source + '}\n';

    source = "var __t,__p='',__j=Array.prototype.join," +
      "print=function(){__p+=__j.call(arguments,'');};\n" +
      source + 'return __p;\n';

    try {
      var render = new Function(settings.variable || 'obj', '_', source);
    } catch (e) {
      e.source = source;
      throw e;
    }

    var template = function(data) {
      return render.call(this, data, _);
    };

    // Provide the compiled source as a convenience for precompilation.
    var argument = settings.variable || 'obj';
    template.source = 'function(' + argument + '){\n' + source + '}';

    return template;
  };

  // Add a "chain" function. Start chaining a wrapped Underscore object.
  _.chain = function(obj) {
    var instance = _(obj);
    instance._chain = true;
    return instance;
  };

  // OOP
  // ---------------
  // If Underscore is called as a function, it returns a wrapped object that
  // can be used OO-style. This wrapper holds altered versions of all the
  // underscore functions. Wrapped objects may be chained.

  // Helper function to continue chaining intermediate results.
  var result = function(instance, obj) {
    return instance._chain ? _(obj).chain() : obj;
  };

  // Add your own custom functions to the Underscore object.
  _.mixin = function(obj) {
    _.each(_.functions(obj), function(name) {
      var func = _[name] = obj[name];
      _.prototype[name] = function() {
        var args = [this._wrapped];
        push.apply(args, arguments);
        return result(this, func.apply(_, args));
      };
    });
  };

  // Add all of the Underscore functions to the wrapper object.
  _.mixin(_);

  // Add all mutator Array functions to the wrapper.
  _.each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {
    var method = ArrayProto[name];
    _.prototype[name] = function() {
      var obj = this._wrapped;
      method.apply(obj, arguments);
      if ((name === 'shift' || name === 'splice') && obj.length === 0) delete obj[0];
      return result(this, obj);
    };
  });

  // Add all accessor Array functions to the wrapper.
  _.each(['concat', 'join', 'slice'], function(name) {
    var method = ArrayProto[name];
    _.prototype[name] = function() {
      return result(this, method.apply(this._wrapped, arguments));
    };
  });

  // Extracts the result from a wrapped and chained object.
  _.prototype.value = function() {
    return this._wrapped;
  };

  // Provide unwrapping proxy for some methods used in engine operations
  // such as arithmetic and JSON stringification.
  _.prototype.valueOf = _.prototype.toJSON = _.prototype.value;

  _.prototype.toString = function() {
    return '' + this._wrapped;
  };

  // AMD registration happens at the end for compatibility with AMD loaders
  // that may not enforce next-turn semantics on modules. Even though general
  // practice for AMD registration is to be anonymous, underscore registers
  // as a named module because, like jQuery, it is a base library that is
  // popular enough to be bundled in a third party lib, but not be part of
  // an AMD load request. Those cases could generate an error when an
  // anonymous define() is called outside of a loader request.
  if (typeof define === 'function' && define.amd) {
    define('underscore', [], function() {
      return _;
    });
  }
}.call(this));

},{}],477:[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}

},{}],478:[function(require,module,exports){
module.exports = function isBuffer(arg) {
  return arg && typeof arg === 'object'
    && typeof arg.copy === 'function'
    && typeof arg.fill === 'function'
    && typeof arg.readUInt8 === 'function';
}
},{}],479:[function(require,module,exports){
(function (process,global){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};


// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function(fn, msg) {
  // Allow for deprecating things in the process of starting up.
  if (isUndefined(global.process)) {
    return function() {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  if (process.noDeprecation === true) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
};


var debugs = {};
var debugEnviron;
exports.debuglog = function(set) {
  if (isUndefined(debugEnviron))
    debugEnviron = process.env.NODE_DEBUG || '';
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
      var pid = process.pid;
      debugs[set] = function() {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function() {};
    }
  }
  return debugs[set];
};


/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value)
      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = require('./support/isBuffer');

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = require('inherits');

exports._extend = function(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./support/isBuffer":478,"_process":458,"inherits":477}],480:[function(require,module,exports){
/*
 * UUID-js: A js library to generate and parse UUIDs, TimeUUIDs and generate
 * TimeUUID based on dates for range selections.
 * @see http://www.ietf.org/rfc/rfc4122.txt
 **/

function UUIDjs() {
};

UUIDjs.maxFromBits = function(bits) {
  return Math.pow(2, bits);
};

UUIDjs.limitUI04 = UUIDjs.maxFromBits(4);
UUIDjs.limitUI06 = UUIDjs.maxFromBits(6);
UUIDjs.limitUI08 = UUIDjs.maxFromBits(8);
UUIDjs.limitUI12 = UUIDjs.maxFromBits(12);
UUIDjs.limitUI14 = UUIDjs.maxFromBits(14);
UUIDjs.limitUI16 = UUIDjs.maxFromBits(16);
UUIDjs.limitUI32 = UUIDjs.maxFromBits(32);
UUIDjs.limitUI40 = UUIDjs.maxFromBits(40);
UUIDjs.limitUI48 = UUIDjs.maxFromBits(48);

// Returns a random integer between min and max
// Using Math.round() will give you a non-uniform distribution!
// @see https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Math/random
function getRandomInt(min, max) {
  return Math.floor(Math.random() * (max - min + 1)) + min;
}

UUIDjs.randomUI04 = function() {
  return getRandomInt(0, UUIDjs.limitUI04-1);
};
UUIDjs.randomUI06 = function() {
  return getRandomInt(0, UUIDjs.limitUI06-1);
};
UUIDjs.randomUI08 = function() {
  return getRandomInt(0, UUIDjs.limitUI08-1);
};
UUIDjs.randomUI12 = function() {
  return getRandomInt(0, UUIDjs.limitUI12-1);
};
UUIDjs.randomUI14 = function() {
  return getRandomInt(0, UUIDjs.limitUI14-1);
};
UUIDjs.randomUI16 = function() {
  return getRandomInt(0, UUIDjs.limitUI16-1);
};
UUIDjs.randomUI32 = function() {
  return getRandomInt(0, UUIDjs.limitUI32-1);
};
UUIDjs.randomUI40 = function() {
  return (0 | Math.random() * (1 << 30)) + (0 | Math.random() * (1 << 40 - 30)) * (1 << 30);
};
UUIDjs.randomUI48 = function() {
  return (0 | Math.random() * (1 << 30)) + (0 | Math.random() * (1 << 48 - 30)) * (1 << 30);
};

UUIDjs.paddedString = function(string, length, z) {
  string = String(string);
  z = (!z) ? '0' : z;
  var i = length - string.length;
  for (; i > 0; i >>>= 1, z += z) {
    if (i & 1) {
      string = z + string;
    }
  }
  return string;
};

UUIDjs.prototype.fromParts = function(timeLow, timeMid, timeHiAndVersion, clockSeqHiAndReserved, clockSeqLow, node) {
  this.version = (timeHiAndVersion >> 12) & 0xF;
  this.hex = UUIDjs.paddedString(timeLow.toString(16), 8)
             + '-'
             + UUIDjs.paddedString(timeMid.toString(16), 4)
             + '-'
             + UUIDjs.paddedString(timeHiAndVersion.toString(16), 4)
             + '-'
             + UUIDjs.paddedString(clockSeqHiAndReserved.toString(16), 2)
             + UUIDjs.paddedString(clockSeqLow.toString(16), 2)
             + '-'
             + UUIDjs.paddedString(node.toString(16), 12);
  return this;
};

UUIDjs.prototype.toString = function() {
  return this.hex;
};
UUIDjs.prototype.toURN = function() {
  return 'urn:uuid:' + this.hex;
};

UUIDjs.prototype.toBytes = function() {
  var parts = this.hex.split('-');
  var ints = [];
  var intPos = 0;
  for (var i = 0; i < parts.length; i++) {
    for (var j = 0; j < parts[i].length; j+=2) {
      ints[intPos++] = parseInt(parts[i].substr(j, 2), 16);
    }
  }
  return ints;
};

UUIDjs.prototype.equals = function(uuid) {
  if (!(uuid instanceof UUID)) {
    return false;
  }
  if (this.hex !== uuid.hex) {
    return false;
  }
  return true;
};

UUIDjs.getTimeFieldValues = function(time) {
  var ts = time - Date.UTC(1582, 9, 15);
  var hm = ((ts / 0x100000000) * 10000) & 0xFFFFFFF;
  return { low: ((ts & 0xFFFFFFF) * 10000) % 0x100000000,
            mid: hm & 0xFFFF, hi: hm >>> 16, timestamp: ts };
};

UUIDjs._create4 = function() {
  return new UUIDjs().fromParts(
    UUIDjs.randomUI32(),
    UUIDjs.randomUI16(),
    0x4000 | UUIDjs.randomUI12(),
    0x80   | UUIDjs.randomUI06(),
    UUIDjs.randomUI08(),
    UUIDjs.randomUI48()
  );
};

UUIDjs._create1 = function() {
  var now = new Date().getTime();
  var sequence = UUIDjs.randomUI14();
  var node = (UUIDjs.randomUI08() | 1) * 0x10000000000 + UUIDjs.randomUI40();
  var tick = UUIDjs.randomUI04();
  var timestamp = 0;
  var timestampRatio = 1/4;

  if (now != timestamp) {
    if (now < timestamp) {
      sequence++;
    }
    timestamp = now;
    tick = UUIDjs.randomUI04();
  } else if (Math.random() < timestampRatio && tick < 9984) {
    tick += 1 + UUIDjs.randomUI04();
  } else {
    sequence++;
  }

  var tf = UUIDjs.getTimeFieldValues(timestamp);
  var tl = tf.low + tick;
  var thav = (tf.hi & 0xFFF) | 0x1000;

  sequence &= 0x3FFF;
  var cshar = (sequence >>> 8) | 0x80;
  var csl = sequence & 0xFF;

  return new UUIDjs().fromParts(tl, tf.mid, thav, cshar, csl, node);
};

UUIDjs.create = function(version) {
  version = version || 4;
  return this['_create' + version]();
};

UUIDjs.fromTime = function(time, last) {
  last = (!last) ? false : last;
  var tf = UUIDjs.getTimeFieldValues(time);
  var tl = tf.low;
  var thav = (tf.hi & 0xFFF) | 0x1000;  // set version '0001'
  if (last === false) {
    return new UUIDjs().fromParts(tl, tf.mid, thav, 0, 0, 0);
  } else {
    return new UUIDjs().fromParts(tl, tf.mid, thav, 0x80 | UUIDjs.limitUI06, UUIDjs.limitUI08 - 1, UUIDjs.limitUI48 - 1);
  }
};

UUIDjs.firstFromTime = function(time) {
  return UUIDjs.fromTime(time, false);
};
UUIDjs.lastFromTime = function(time) {
  return UUIDjs.fromTime(time, true);
};

UUIDjs.fromURN = function(strId) {
  var r, p = /^(?:urn:uuid:|\{)?([0-9a-f]{8})-([0-9a-f]{4})-([0-9a-f]{4})-([0-9a-f]{2})([0-9a-f]{2})-([0-9a-f]{12})(?:\})?$/i;
  if ((r = p.exec(strId))) {
    return new UUIDjs().fromParts(parseInt(r[1], 16), parseInt(r[2], 16),
                            parseInt(r[3], 16), parseInt(r[4], 16),
                            parseInt(r[5], 16), parseInt(r[6], 16));
  }
  return null;
};

UUIDjs.fromBytes = function(ints) {
  if (ints.length < 5) {
    return null;
  }
  var str = '';
  var pos = 0;
  var parts = [4, 2, 2, 2, 6];
  for (var i = 0; i < parts.length; i++) {
    for (var j = 0; j < parts[i]; j++) {
      var octet = ints[pos++].toString(16);
      if (octet.length == 1) {
        octet = '0' + octet;
      }
      str += octet;
    }
    if (parts[i] !== 6) {
      str += '-';
    }
  }
  return UUIDjs.fromURN(str);
};

UUIDjs.fromBinary = function(binary) {
  var ints = [];
  for (var i = 0; i < binary.length; i++) {
    ints[i] = binary.charCodeAt(i);
    if (ints[i] > 255 || ints[i] < 0) {
      throw new Error('Unexpected byte in binary data.');
    }
  }
  return UUIDjs.fromBytes(ints);
};

// Aliases to support legacy code. Do not use these when writing new code as
// they may be removed in future versions!
UUIDjs.new = function() {
  return this.create(4);
};
UUIDjs.newTS = function() {
  return this.create(1);
};

module.exports = UUIDjs;

},{}],481:[function(require,module,exports){
/** @license MIT License (c) copyright 2010-2014 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

(function(define) { 'use strict';
define(function (require) {

	var makePromise = require('./makePromise');
	var Scheduler = require('./Scheduler');
	var async = require('./env').asap;

	return makePromise({
		scheduler: new Scheduler(async)
	});

});
})(typeof define === 'function' && define.amd ? define : function (factory) { module.exports = factory(require); });

},{"./Scheduler":482,"./env":494,"./makePromise":497}],482:[function(require,module,exports){
/** @license MIT License (c) copyright 2010-2014 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

(function(define) { 'use strict';
define(function() {

	// Credit to Twisol (https://github.com/Twisol) for suggesting
	// this type of extensible queue + trampoline approach for next-tick conflation.

	/**
	 * Async task scheduler
	 * @param {function} async function to schedule a single async function
	 * @constructor
	 */
	function Scheduler(async) {
		this._async = async;
		this._running = false;

		this._queue = this;
		this._queueLen = 0;
		this._afterQueue = {};
		this._afterQueueLen = 0;

		var self = this;
		this.drain = function() {
			self._drain();
		};
	}

	/**
	 * Enqueue a task
	 * @param {{ run:function }} task
	 */
	Scheduler.prototype.enqueue = function(task) {
		this._queue[this._queueLen++] = task;
		this.run();
	};

	/**
	 * Enqueue a task to run after the main task queue
	 * @param {{ run:function }} task
	 */
	Scheduler.prototype.afterQueue = function(task) {
		this._afterQueue[this._afterQueueLen++] = task;
		this.run();
	};

	Scheduler.prototype.run = function() {
		if (!this._running) {
			this._running = true;
			this._async(this.drain);
		}
	};

	/**
	 * Drain the handler queue entirely, and then the after queue
	 */
	Scheduler.prototype._drain = function() {
		var i = 0;
		for (; i < this._queueLen; ++i) {
			this._queue[i].run();
			this._queue[i] = void 0;
		}

		this._queueLen = 0;
		this._running = false;

		for (i = 0; i < this._afterQueueLen; ++i) {
			this._afterQueue[i].run();
			this._afterQueue[i] = void 0;
		}

		this._afterQueueLen = 0;
	};

	return Scheduler;

});
}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(); }));

},{}],483:[function(require,module,exports){
/** @license MIT License (c) copyright 2010-2014 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

(function(define) { 'use strict';
define(function() {

	/**
	 * Custom error type for promises rejected by promise.timeout
	 * @param {string} message
	 * @constructor
	 */
	function TimeoutError (message) {
		Error.call(this);
		this.message = message;
		this.name = TimeoutError.name;
		if (typeof Error.captureStackTrace === 'function') {
			Error.captureStackTrace(this, TimeoutError);
		}
	}

	TimeoutError.prototype = Object.create(Error.prototype);
	TimeoutError.prototype.constructor = TimeoutError;

	return TimeoutError;
});
}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(); }));
},{}],484:[function(require,module,exports){
/** @license MIT License (c) copyright 2010-2014 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

(function(define) { 'use strict';
define(function() {

	makeApply.tryCatchResolve = tryCatchResolve;

	return makeApply;

	function makeApply(Promise, call) {
		if(arguments.length < 2) {
			call = tryCatchResolve;
		}

		return apply;

		function apply(f, thisArg, args) {
			var p = Promise._defer();
			var l = args.length;
			var params = new Array(l);
			callAndResolve({ f:f, thisArg:thisArg, args:args, params:params, i:l-1, call:call }, p._handler);

			return p;
		}

		function callAndResolve(c, h) {
			if(c.i < 0) {
				return call(c.f, c.thisArg, c.params, h);
			}

			var handler = Promise._handler(c.args[c.i]);
			handler.fold(callAndResolveNext, c, void 0, h);
		}

		function callAndResolveNext(c, x, h) {
			c.params[c.i] = x;
			c.i -= 1;
			callAndResolve(c, h);
		}
	}

	function tryCatchResolve(f, thisArg, args, resolver) {
		try {
			resolver.resolve(f.apply(thisArg, args));
		} catch(e) {
			resolver.reject(e);
		}
	}

});
}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(); }));



},{}],485:[function(require,module,exports){
/** @license MIT License (c) copyright 2010-2014 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

(function(define) { 'use strict';
define(function(require) {

	var state = require('../state');
	var applier = require('../apply');

	return function array(Promise) {

		var applyFold = applier(Promise);
		var toPromise = Promise.resolve;
		var all = Promise.all;

		var ar = Array.prototype.reduce;
		var arr = Array.prototype.reduceRight;
		var slice = Array.prototype.slice;

		// Additional array combinators

		Promise.any = any;
		Promise.some = some;
		Promise.settle = settle;

		Promise.map = map;
		Promise.filter = filter;
		Promise.reduce = reduce;
		Promise.reduceRight = reduceRight;

		/**
		 * When this promise fulfills with an array, do
		 * onFulfilled.apply(void 0, array)
		 * @param {function} onFulfilled function to apply
		 * @returns {Promise} promise for the result of applying onFulfilled
		 */
		Promise.prototype.spread = function(onFulfilled) {
			return this.then(all).then(function(array) {
				return onFulfilled.apply(this, array);
			});
		};

		return Promise;

		/**
		 * One-winner competitive race.
		 * Return a promise that will fulfill when one of the promises
		 * in the input array fulfills, or will reject when all promises
		 * have rejected.
		 * @param {array} promises
		 * @returns {Promise} promise for the first fulfilled value
		 */
		function any(promises) {
			var p = Promise._defer();
			var resolver = p._handler;
			var l = promises.length>>>0;

			var pending = l;
			var errors = [];

			for (var h, x, i = 0; i < l; ++i) {
				x = promises[i];
				if(x === void 0 && !(i in promises)) {
					--pending;
					continue;
				}

				h = Promise._handler(x);
				if(h.state() > 0) {
					resolver.become(h);
					Promise._visitRemaining(promises, i, h);
					break;
				} else {
					h.visit(resolver, handleFulfill, handleReject);
				}
			}

			if(pending === 0) {
				resolver.reject(new RangeError('any(): array must not be empty'));
			}

			return p;

			function handleFulfill(x) {
				/*jshint validthis:true*/
				errors = null;
				this.resolve(x); // this === resolver
			}

			function handleReject(e) {
				/*jshint validthis:true*/
				if(this.resolved) { // this === resolver
					return;
				}

				errors.push(e);
				if(--pending === 0) {
					this.reject(errors);
				}
			}
		}

		/**
		 * N-winner competitive race
		 * Return a promise that will fulfill when n input promises have
		 * fulfilled, or will reject when it becomes impossible for n
		 * input promises to fulfill (ie when promises.length - n + 1
		 * have rejected)
		 * @param {array} promises
		 * @param {number} n
		 * @returns {Promise} promise for the earliest n fulfillment values
		 *
		 * @deprecated
		 */
		function some(promises, n) {
			/*jshint maxcomplexity:7*/
			var p = Promise._defer();
			var resolver = p._handler;

			var results = [];
			var errors = [];

			var l = promises.length>>>0;
			var nFulfill = 0;
			var nReject;
			var x, i; // reused in both for() loops

			// First pass: count actual array items
			for(i=0; i<l; ++i) {
				x = promises[i];
				if(x === void 0 && !(i in promises)) {
					continue;
				}
				++nFulfill;
			}

			// Compute actual goals
			n = Math.max(n, 0);
			nReject = (nFulfill - n + 1);
			nFulfill = Math.min(n, nFulfill);

			if(n > nFulfill) {
				resolver.reject(new RangeError('some(): array must contain at least '
				+ n + ' item(s), but had ' + nFulfill));
			} else if(nFulfill === 0) {
				resolver.resolve(results);
			}

			// Second pass: observe each array item, make progress toward goals
			for(i=0; i<l; ++i) {
				x = promises[i];
				if(x === void 0 && !(i in promises)) {
					continue;
				}

				Promise._handler(x).visit(resolver, fulfill, reject, resolver.notify);
			}

			return p;

			function fulfill(x) {
				/*jshint validthis:true*/
				if(this.resolved) { // this === resolver
					return;
				}

				results.push(x);
				if(--nFulfill === 0) {
					errors = null;
					this.resolve(results);
				}
			}

			function reject(e) {
				/*jshint validthis:true*/
				if(this.resolved) { // this === resolver
					return;
				}

				errors.push(e);
				if(--nReject === 0) {
					results = null;
					this.reject(errors);
				}
			}
		}

		/**
		 * Apply f to the value of each promise in a list of promises
		 * and return a new list containing the results.
		 * @param {array} promises
		 * @param {function(x:*, index:Number):*} f mapping function
		 * @returns {Promise}
		 */
		function map(promises, f) {
			return Promise._traverse(f, promises);
		}

		/**
		 * Filter the provided array of promises using the provided predicate.  Input may
		 * contain promises and values
		 * @param {Array} promises array of promises and values
		 * @param {function(x:*, index:Number):boolean} predicate filtering predicate.
		 *  Must return truthy (or promise for truthy) for items to retain.
		 * @returns {Promise} promise that will fulfill with an array containing all items
		 *  for which predicate returned truthy.
		 */
		function filter(promises, predicate) {
			var a = slice.call(promises);
			return Promise._traverse(predicate, a).then(function(keep) {
				return filterSync(a, keep);
			});
		}

		function filterSync(promises, keep) {
			// Safe because we know all promises have fulfilled if we've made it this far
			var l = keep.length;
			var filtered = new Array(l);
			for(var i=0, j=0; i<l; ++i) {
				if(keep[i]) {
					filtered[j++] = Promise._handler(promises[i]).value;
				}
			}
			filtered.length = j;
			return filtered;

		}

		/**
		 * Return a promise that will always fulfill with an array containing
		 * the outcome states of all input promises.  The returned promise
		 * will never reject.
		 * @param {Array} promises
		 * @returns {Promise} promise for array of settled state descriptors
		 */
		function settle(promises) {
			return all(promises.map(settleOne));
		}

		function settleOne(p) {
			// Optimize the case where we get an already-resolved when.js promise
			//  by extracting its state:
			var handler;
			if (p instanceof Promise) {
				// This is our own Promise type and we can reach its handler internals:
				handler = p._handler.join();
			}
			if((handler && handler.state() === 0) || !handler) {
				// Either still pending, or not a Promise at all:
				return toPromise(p).then(state.fulfilled, state.rejected);
			}

			// The promise is our own, but it is already resolved. Take a shortcut.
			// Since we're not actually handling the resolution, we need to disable
			// rejection reporting.
			handler._unreport();
			return state.inspect(handler);
		}

		/**
		 * Traditional reduce function, similar to `Array.prototype.reduce()`, but
		 * input may contain promises and/or values, and reduceFunc
		 * may return either a value or a promise, *and* initialValue may
		 * be a promise for the starting value.
		 * @param {Array|Promise} promises array or promise for an array of anything,
		 *      may contain a mix of promises and values.
		 * @param {function(accumulated:*, x:*, index:Number):*} f reduce function
		 * @returns {Promise} that will resolve to the final reduced value
		 */
		function reduce(promises, f /*, initialValue */) {
			return arguments.length > 2 ? ar.call(promises, liftCombine(f), arguments[2])
					: ar.call(promises, liftCombine(f));
		}

		/**
		 * Traditional reduce function, similar to `Array.prototype.reduceRight()`, but
		 * input may contain promises and/or values, and reduceFunc
		 * may return either a value or a promise, *and* initialValue may
		 * be a promise for the starting value.
		 * @param {Array|Promise} promises array or promise for an array of anything,
		 *      may contain a mix of promises and values.
		 * @param {function(accumulated:*, x:*, index:Number):*} f reduce function
		 * @returns {Promise} that will resolve to the final reduced value
		 */
		function reduceRight(promises, f /*, initialValue */) {
			return arguments.length > 2 ? arr.call(promises, liftCombine(f), arguments[2])
					: arr.call(promises, liftCombine(f));
		}

		function liftCombine(f) {
			return function(z, x, i) {
				return applyFold(f, void 0, [z,x,i]);
			};
		}
	};

});
}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(require); }));

},{"../apply":484,"../state":498}],486:[function(require,module,exports){
/** @license MIT License (c) copyright 2010-2014 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

(function(define) { 'use strict';
define(function() {

	return function flow(Promise) {

		var resolve = Promise.resolve;
		var reject = Promise.reject;
		var origCatch = Promise.prototype['catch'];

		/**
		 * Handle the ultimate fulfillment value or rejection reason, and assume
		 * responsibility for all errors.  If an error propagates out of result
		 * or handleFatalError, it will be rethrown to the host, resulting in a
		 * loud stack track on most platforms and a crash on some.
		 * @param {function?} onResult
		 * @param {function?} onError
		 * @returns {undefined}
		 */
		Promise.prototype.done = function(onResult, onError) {
			this._handler.visit(this._handler.receiver, onResult, onError);
		};

		/**
		 * Add Error-type and predicate matching to catch.  Examples:
		 * promise.catch(TypeError, handleTypeError)
		 *   .catch(predicate, handleMatchedErrors)
		 *   .catch(handleRemainingErrors)
		 * @param onRejected
		 * @returns {*}
		 */
		Promise.prototype['catch'] = Promise.prototype.otherwise = function(onRejected) {
			if (arguments.length < 2) {
				return origCatch.call(this, onRejected);
			}

			if(typeof onRejected !== 'function') {
				return this.ensure(rejectInvalidPredicate);
			}

			return origCatch.call(this, createCatchFilter(arguments[1], onRejected));
		};

		/**
		 * Wraps the provided catch handler, so that it will only be called
		 * if the predicate evaluates truthy
		 * @param {?function} handler
		 * @param {function} predicate
		 * @returns {function} conditional catch handler
		 */
		function createCatchFilter(handler, predicate) {
			return function(e) {
				return evaluatePredicate(e, predicate)
					? handler.call(this, e)
					: reject(e);
			};
		}

		/**
		 * Ensures that onFulfilledOrRejected will be called regardless of whether
		 * this promise is fulfilled or rejected.  onFulfilledOrRejected WILL NOT
		 * receive the promises' value or reason.  Any returned value will be disregarded.
		 * onFulfilledOrRejected may throw or return a rejected promise to signal
		 * an additional error.
		 * @param {function} handler handler to be called regardless of
		 *  fulfillment or rejection
		 * @returns {Promise}
		 */
		Promise.prototype['finally'] = Promise.prototype.ensure = function(handler) {
			if(typeof handler !== 'function') {
				return this;
			}

			return this.then(function(x) {
				return runSideEffect(handler, this, identity, x);
			}, function(e) {
				return runSideEffect(handler, this, reject, e);
			});
		};

		function runSideEffect (handler, thisArg, propagate, value) {
			var result = handler.call(thisArg);
			return maybeThenable(result)
				? propagateValue(result, propagate, value)
				: propagate(value);
		}

		function propagateValue (result, propagate, x) {
			return resolve(result).then(function () {
				return propagate(x);
			});
		}

		/**
		 * Recover from a failure by returning a defaultValue.  If defaultValue
		 * is a promise, it's fulfillment value will be used.  If defaultValue is
		 * a promise that rejects, the returned promise will reject with the
		 * same reason.
		 * @param {*} defaultValue
		 * @returns {Promise} new promise
		 */
		Promise.prototype['else'] = Promise.prototype.orElse = function(defaultValue) {
			return this.then(void 0, function() {
				return defaultValue;
			});
		};

		/**
		 * Shortcut for .then(function() { return value; })
		 * @param  {*} value
		 * @return {Promise} a promise that:
		 *  - is fulfilled if value is not a promise, or
		 *  - if value is a promise, will fulfill with its value, or reject
		 *    with its reason.
		 */
		Promise.prototype['yield'] = function(value) {
			return this.then(function() {
				return value;
			});
		};

		/**
		 * Runs a side effect when this promise fulfills, without changing the
		 * fulfillment value.
		 * @param {function} onFulfilledSideEffect
		 * @returns {Promise}
		 */
		Promise.prototype.tap = function(onFulfilledSideEffect) {
			return this.then(onFulfilledSideEffect)['yield'](this);
		};

		return Promise;
	};

	function rejectInvalidPredicate() {
		throw new TypeError('catch predicate must be a function');
	}

	function evaluatePredicate(e, predicate) {
		return isError(predicate) ? e instanceof predicate : predicate(e);
	}

	function isError(predicate) {
		return predicate === Error
			|| (predicate != null && predicate.prototype instanceof Error);
	}

	function maybeThenable(x) {
		return (typeof x === 'object' || typeof x === 'function') && x !== null;
	}

	function identity(x) {
		return x;
	}

});
}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(); }));

},{}],487:[function(require,module,exports){
/** @license MIT License (c) copyright 2010-2014 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */
/** @author Jeff Escalante */

(function(define) { 'use strict';
define(function() {

	return function fold(Promise) {

		Promise.prototype.fold = function(f, z) {
			var promise = this._beget();

			this._handler.fold(function(z, x, to) {
				Promise._handler(z).fold(function(x, z, to) {
					to.resolve(f.call(this, z, x));
				}, x, this, to);
			}, z, promise._handler.receiver, promise._handler);

			return promise;
		};

		return Promise;
	};

});
}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(); }));

},{}],488:[function(require,module,exports){
/** @license MIT License (c) copyright 2010-2014 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

(function(define) { 'use strict';
define(function(require) {

	var inspect = require('../state').inspect;

	return function inspection(Promise) {

		Promise.prototype.inspect = function() {
			return inspect(Promise._handler(this));
		};

		return Promise;
	};

});
}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(require); }));

},{"../state":498}],489:[function(require,module,exports){
/** @license MIT License (c) copyright 2010-2014 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

(function(define) { 'use strict';
define(function() {

	return function generate(Promise) {

		var resolve = Promise.resolve;

		Promise.iterate = iterate;
		Promise.unfold = unfold;

		return Promise;

		/**
		 * @deprecated Use github.com/cujojs/most streams and most.iterate
		 * Generate a (potentially infinite) stream of promised values:
		 * x, f(x), f(f(x)), etc. until condition(x) returns true
		 * @param {function} f function to generate a new x from the previous x
		 * @param {function} condition function that, given the current x, returns
		 *  truthy when the iterate should stop
		 * @param {function} handler function to handle the value produced by f
		 * @param {*|Promise} x starting value, may be a promise
		 * @return {Promise} the result of the last call to f before
		 *  condition returns true
		 */
		function iterate(f, condition, handler, x) {
			return unfold(function(x) {
				return [x, f(x)];
			}, condition, handler, x);
		}

		/**
		 * @deprecated Use github.com/cujojs/most streams and most.unfold
		 * Generate a (potentially infinite) stream of promised values
		 * by applying handler(generator(seed)) iteratively until
		 * condition(seed) returns true.
		 * @param {function} unspool function that generates a [value, newSeed]
		 *  given a seed.
		 * @param {function} condition function that, given the current seed, returns
		 *  truthy when the unfold should stop
		 * @param {function} handler function to handle the value produced by unspool
		 * @param x {*|Promise} starting value, may be a promise
		 * @return {Promise} the result of the last value produced by unspool before
		 *  condition returns true
		 */
		function unfold(unspool, condition, handler, x) {
			return resolve(x).then(function(seed) {
				return resolve(condition(seed)).then(function(done) {
					return done ? seed : resolve(unspool(seed)).spread(next);
				});
			});

			function next(item, newSeed) {
				return resolve(handler(item)).then(function() {
					return unfold(unspool, condition, handler, newSeed);
				});
			}
		}
	};

});
}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(); }));

},{}],490:[function(require,module,exports){
/** @license MIT License (c) copyright 2010-2014 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

(function(define) { 'use strict';
define(function() {

	return function progress(Promise) {

		/**
		 * @deprecated
		 * Register a progress handler for this promise
		 * @param {function} onProgress
		 * @returns {Promise}
		 */
		Promise.prototype.progress = function(onProgress) {
			return this.then(void 0, void 0, onProgress);
		};

		return Promise;
	};

});
}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(); }));

},{}],491:[function(require,module,exports){
/** @license MIT License (c) copyright 2010-2014 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

(function(define) { 'use strict';
define(function(require) {

	var env = require('../env');
	var TimeoutError = require('../TimeoutError');

	function setTimeout(f, ms, x, y) {
		return env.setTimer(function() {
			f(x, y, ms);
		}, ms);
	}

	return function timed(Promise) {
		/**
		 * Return a new promise whose fulfillment value is revealed only
		 * after ms milliseconds
		 * @param {number} ms milliseconds
		 * @returns {Promise}
		 */
		Promise.prototype.delay = function(ms) {
			var p = this._beget();
			this._handler.fold(handleDelay, ms, void 0, p._handler);
			return p;
		};

		function handleDelay(ms, x, h) {
			setTimeout(resolveDelay, ms, x, h);
		}

		function resolveDelay(x, h) {
			h.resolve(x);
		}

		/**
		 * Return a new promise that rejects after ms milliseconds unless
		 * this promise fulfills earlier, in which case the returned promise
		 * fulfills with the same value.
		 * @param {number} ms milliseconds
		 * @param {Error|*=} reason optional rejection reason to use, defaults
		 *   to a TimeoutError if not provided
		 * @returns {Promise}
		 */
		Promise.prototype.timeout = function(ms, reason) {
			var p = this._beget();
			var h = p._handler;

			var t = setTimeout(onTimeout, ms, reason, p._handler);

			this._handler.visit(h,
				function onFulfill(x) {
					env.clearTimer(t);
					this.resolve(x); // this = h
				},
				function onReject(x) {
					env.clearTimer(t);
					this.reject(x); // this = h
				},
				h.notify);

			return p;
		};

		function onTimeout(reason, h, ms) {
			var e = typeof reason === 'undefined'
				? new TimeoutError('timed out after ' + ms + 'ms')
				: reason;
			h.reject(e);
		}

		return Promise;
	};

});
}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(require); }));

},{"../TimeoutError":483,"../env":494}],492:[function(require,module,exports){
/** @license MIT License (c) copyright 2010-2014 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

(function(define) { 'use strict';
define(function(require) {

	var setTimer = require('../env').setTimer;
	var format = require('../format');

	return function unhandledRejection(Promise) {

		var logError = noop;
		var logInfo = noop;
		var localConsole;

		if(typeof console !== 'undefined') {
			// Alias console to prevent things like uglify's drop_console option from
			// removing console.log/error. Unhandled rejections fall into the same
			// category as uncaught exceptions, and build tools shouldn't silence them.
			localConsole = console;
			logError = typeof localConsole.error !== 'undefined'
				? function (e) { localConsole.error(e); }
				: function (e) { localConsole.log(e); };

			logInfo = typeof localConsole.info !== 'undefined'
				? function (e) { localConsole.info(e); }
				: function (e) { localConsole.log(e); };
		}

		Promise.onPotentiallyUnhandledRejection = function(rejection) {
			enqueue(report, rejection);
		};

		Promise.onPotentiallyUnhandledRejectionHandled = function(rejection) {
			enqueue(unreport, rejection);
		};

		Promise.onFatalRejection = function(rejection) {
			enqueue(throwit, rejection.value);
		};

		var tasks = [];
		var reported = [];
		var running = null;

		function report(r) {
			if(!r.handled) {
				reported.push(r);
				logError('Potentially unhandled rejection [' + r.id + '] ' + format.formatError(r.value));
			}
		}

		function unreport(r) {
			var i = reported.indexOf(r);
			if(i >= 0) {
				reported.splice(i, 1);
				logInfo('Handled previous rejection [' + r.id + '] ' + format.formatObject(r.value));
			}
		}

		function enqueue(f, x) {
			tasks.push(f, x);
			if(running === null) {
				running = setTimer(flush, 0);
			}
		}

		function flush() {
			running = null;
			while(tasks.length > 0) {
				tasks.shift()(tasks.shift());
			}
		}

		return Promise;
	};

	function throwit(e) {
		throw e;
	}

	function noop() {}

});
}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(require); }));

},{"../env":494,"../format":495}],493:[function(require,module,exports){
/** @license MIT License (c) copyright 2010-2014 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

(function(define) { 'use strict';
define(function() {

	return function addWith(Promise) {
		/**
		 * Returns a promise whose handlers will be called with `this` set to
		 * the supplied receiver.  Subsequent promises derived from the
		 * returned promise will also have their handlers called with receiver
		 * as `this`. Calling `with` with undefined or no arguments will return
		 * a promise whose handlers will again be called in the usual Promises/A+
		 * way (no `this`) thus safely undoing any previous `with` in the
		 * promise chain.
		 *
		 * WARNING: Promises returned from `with`/`withThis` are NOT Promises/A+
		 * compliant, specifically violating 2.2.5 (http://promisesaplus.com/#point-41)
		 *
		 * @param {object} receiver `this` value for all handlers attached to
		 *  the returned promise.
		 * @returns {Promise}
		 */
		Promise.prototype['with'] = Promise.prototype.withThis = function(receiver) {
			var p = this._beget();
			var child = p._handler;
			child.receiver = receiver;
			this._handler.chain(child, receiver);
			return p;
		};

		return Promise;
	};

});
}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(); }));


},{}],494:[function(require,module,exports){
(function (process){
/** @license MIT License (c) copyright 2010-2014 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

/*global process,document,setTimeout,clearTimeout,MutationObserver,WebKitMutationObserver*/
(function(define) { 'use strict';
define(function(require) {
	/*jshint maxcomplexity:6*/

	// Sniff "best" async scheduling option
	// Prefer process.nextTick or MutationObserver, then check for
	// setTimeout, and finally vertx, since its the only env that doesn't
	// have setTimeout

	var MutationObs;
	var capturedSetTimeout = typeof setTimeout !== 'undefined' && setTimeout;

	// Default env
	var setTimer = function(f, ms) { return setTimeout(f, ms); };
	var clearTimer = function(t) { return clearTimeout(t); };
	var asap = function (f) { return capturedSetTimeout(f, 0); };

	// Detect specific env
	if (isNode()) { // Node
		asap = function (f) { return process.nextTick(f); };

	} else if (MutationObs = hasMutationObserver()) { // Modern browser
		asap = initMutationObserver(MutationObs);

	} else if (!capturedSetTimeout) { // vert.x
		var vertxRequire = require;
		var vertx = vertxRequire('vertx');
		setTimer = function (f, ms) { return vertx.setTimer(ms, f); };
		clearTimer = vertx.cancelTimer;
		asap = vertx.runOnLoop || vertx.runOnContext;
	}

	return {
		setTimer: setTimer,
		clearTimer: clearTimer,
		asap: asap
	};

	function isNode () {
		return typeof process !== 'undefined' &&
			Object.prototype.toString.call(process) === '[object process]';
	}

	function hasMutationObserver () {
	    return (typeof MutationObserver !== 'undefined' && MutationObserver) ||
			(typeof WebKitMutationObserver !== 'undefined' && WebKitMutationObserver);
	}

	function initMutationObserver(MutationObserver) {
		var scheduled;
		var node = document.createTextNode('');
		var o = new MutationObserver(run);
		o.observe(node, { characterData: true });

		function run() {
			var f = scheduled;
			scheduled = void 0;
			f();
		}

		var i = 0;
		return function (f) {
			scheduled = f;
			node.data = (i ^= 1);
		};
	}
});
}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(require); }));

}).call(this,require('_process'))
},{"_process":458}],495:[function(require,module,exports){
/** @license MIT License (c) copyright 2010-2014 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

(function(define) { 'use strict';
define(function() {

	return {
		formatError: formatError,
		formatObject: formatObject,
		tryStringify: tryStringify
	};

	/**
	 * Format an error into a string.  If e is an Error and has a stack property,
	 * it's returned.  Otherwise, e is formatted using formatObject, with a
	 * warning added about e not being a proper Error.
	 * @param {*} e
	 * @returns {String} formatted string, suitable for output to developers
	 */
	function formatError(e) {
		var s = typeof e === 'object' && e !== null && (e.stack || e.message) ? e.stack || e.message : formatObject(e);
		return e instanceof Error ? s : s + ' (WARNING: non-Error used)';
	}

	/**
	 * Format an object, detecting "plain" objects and running them through
	 * JSON.stringify if possible.
	 * @param {Object} o
	 * @returns {string}
	 */
	function formatObject(o) {
		var s = String(o);
		if(s === '[object Object]' && typeof JSON !== 'undefined') {
			s = tryStringify(o, s);
		}
		return s;
	}

	/**
	 * Try to return the result of JSON.stringify(x).  If that fails, return
	 * defaultValue
	 * @param {*} x
	 * @param {*} defaultValue
	 * @returns {String|*} JSON.stringify(x) or defaultValue
	 */
	function tryStringify(x, defaultValue) {
		try {
			return JSON.stringify(x);
		} catch(e) {
			return defaultValue;
		}
	}

});
}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(); }));

},{}],496:[function(require,module,exports){
/** @license MIT License (c) copyright 2010-2014 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

(function(define) { 'use strict';
define(function() {

	return function liftAll(liftOne, combine, dst, src) {
		if(typeof combine === 'undefined') {
			combine = defaultCombine;
		}

		return Object.keys(src).reduce(function(dst, key) {
			var f = src[key];
			return typeof f === 'function' ? combine(dst, liftOne(f), key) : dst;
		}, typeof dst === 'undefined' ? defaultDst(src) : dst);
	};

	function defaultCombine(o, f, k) {
		o[k] = f;
		return o;
	}

	function defaultDst(src) {
		return typeof src === 'function' ? src.bind() : Object.create(src);
	}
});
}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(); }));

},{}],497:[function(require,module,exports){
(function (process){
/** @license MIT License (c) copyright 2010-2014 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

(function(define) { 'use strict';
define(function() {

	return function makePromise(environment) {

		var tasks = environment.scheduler;
		var emitRejection = initEmitRejection();

		var objectCreate = Object.create ||
			function(proto) {
				function Child() {}
				Child.prototype = proto;
				return new Child();
			};

		/**
		 * Create a promise whose fate is determined by resolver
		 * @constructor
		 * @returns {Promise} promise
		 * @name Promise
		 */
		function Promise(resolver, handler) {
			this._handler = resolver === Handler ? handler : init(resolver);
		}

		/**
		 * Run the supplied resolver
		 * @param resolver
		 * @returns {Pending}
		 */
		function init(resolver) {
			var handler = new Pending();

			try {
				resolver(promiseResolve, promiseReject, promiseNotify);
			} catch (e) {
				promiseReject(e);
			}

			return handler;

			/**
			 * Transition from pre-resolution state to post-resolution state, notifying
			 * all listeners of the ultimate fulfillment or rejection
			 * @param {*} x resolution value
			 */
			function promiseResolve (x) {
				handler.resolve(x);
			}
			/**
			 * Reject this promise with reason, which will be used verbatim
			 * @param {Error|*} reason rejection reason, strongly suggested
			 *   to be an Error type
			 */
			function promiseReject (reason) {
				handler.reject(reason);
			}

			/**
			 * @deprecated
			 * Issue a progress event, notifying all progress listeners
			 * @param {*} x progress event payload to pass to all listeners
			 */
			function promiseNotify (x) {
				handler.notify(x);
			}
		}

		// Creation

		Promise.resolve = resolve;
		Promise.reject = reject;
		Promise.never = never;

		Promise._defer = defer;
		Promise._handler = getHandler;

		/**
		 * Returns a trusted promise. If x is already a trusted promise, it is
		 * returned, otherwise returns a new trusted Promise which follows x.
		 * @param  {*} x
		 * @return {Promise} promise
		 */
		function resolve(x) {
			return isPromise(x) ? x
				: new Promise(Handler, new Async(getHandler(x)));
		}

		/**
		 * Return a reject promise with x as its reason (x is used verbatim)
		 * @param {*} x
		 * @returns {Promise} rejected promise
		 */
		function reject(x) {
			return new Promise(Handler, new Async(new Rejected(x)));
		}

		/**
		 * Return a promise that remains pending forever
		 * @returns {Promise} forever-pending promise.
		 */
		function never() {
			return foreverPendingPromise; // Should be frozen
		}

		/**
		 * Creates an internal {promise, resolver} pair
		 * @private
		 * @returns {Promise}
		 */
		function defer() {
			return new Promise(Handler, new Pending());
		}

		// Transformation and flow control

		/**
		 * Transform this promise's fulfillment value, returning a new Promise
		 * for the transformed result.  If the promise cannot be fulfilled, onRejected
		 * is called with the reason.  onProgress *may* be called with updates toward
		 * this promise's fulfillment.
		 * @param {function=} onFulfilled fulfillment handler
		 * @param {function=} onRejected rejection handler
		 * @param {function=} onProgress @deprecated progress handler
		 * @return {Promise} new promise
		 */
		Promise.prototype.then = function(onFulfilled, onRejected, onProgress) {
			var parent = this._handler;
			var state = parent.join().state();

			if ((typeof onFulfilled !== 'function' && state > 0) ||
				(typeof onRejected !== 'function' && state < 0)) {
				// Short circuit: value will not change, simply share handler
				return new this.constructor(Handler, parent);
			}

			var p = this._beget();
			var child = p._handler;

			parent.chain(child, parent.receiver, onFulfilled, onRejected, onProgress);

			return p;
		};

		/**
		 * If this promise cannot be fulfilled due to an error, call onRejected to
		 * handle the error. Shortcut for .then(undefined, onRejected)
		 * @param {function?} onRejected
		 * @return {Promise}
		 */
		Promise.prototype['catch'] = function(onRejected) {
			return this.then(void 0, onRejected);
		};

		/**
		 * Creates a new, pending promise of the same type as this promise
		 * @private
		 * @returns {Promise}
		 */
		Promise.prototype._beget = function() {
			return begetFrom(this._handler, this.constructor);
		};

		function begetFrom(parent, Promise) {
			var child = new Pending(parent.receiver, parent.join().context);
			return new Promise(Handler, child);
		}

		// Array combinators

		Promise.all = all;
		Promise.race = race;
		Promise._traverse = traverse;

		/**
		 * Return a promise that will fulfill when all promises in the
		 * input array have fulfilled, or will reject when one of the
		 * promises rejects.
		 * @param {array} promises array of promises
		 * @returns {Promise} promise for array of fulfillment values
		 */
		function all(promises) {
			return traverseWith(snd, null, promises);
		}

		/**
		 * Array<Promise<X>> -> Promise<Array<f(X)>>
		 * @private
		 * @param {function} f function to apply to each promise's value
		 * @param {Array} promises array of promises
		 * @returns {Promise} promise for transformed values
		 */
		function traverse(f, promises) {
			return traverseWith(tryCatch2, f, promises);
		}

		function traverseWith(tryMap, f, promises) {
			var handler = typeof f === 'function' ? mapAt : settleAt;

			var resolver = new Pending();
			var pending = promises.length >>> 0;
			var results = new Array(pending);

			for (var i = 0, x; i < promises.length && !resolver.resolved; ++i) {
				x = promises[i];

				if (x === void 0 && !(i in promises)) {
					--pending;
					continue;
				}

				traverseAt(promises, handler, i, x, resolver);
			}

			if(pending === 0) {
				resolver.become(new Fulfilled(results));
			}

			return new Promise(Handler, resolver);

			function mapAt(i, x, resolver) {
				if(!resolver.resolved) {
					traverseAt(promises, settleAt, i, tryMap(f, x, i), resolver);
				}
			}

			function settleAt(i, x, resolver) {
				results[i] = x;
				if(--pending === 0) {
					resolver.become(new Fulfilled(results));
				}
			}
		}

		function traverseAt(promises, handler, i, x, resolver) {
			if (maybeThenable(x)) {
				var h = getHandlerMaybeThenable(x);
				var s = h.state();

				if (s === 0) {
					h.fold(handler, i, void 0, resolver);
				} else if (s > 0) {
					handler(i, h.value, resolver);
				} else {
					resolver.become(h);
					visitRemaining(promises, i+1, h);
				}
			} else {
				handler(i, x, resolver);
			}
		}

		Promise._visitRemaining = visitRemaining;
		function visitRemaining(promises, start, handler) {
			for(var i=start; i<promises.length; ++i) {
				markAsHandled(getHandler(promises[i]), handler);
			}
		}

		function markAsHandled(h, handler) {
			if(h === handler) {
				return;
			}

			var s = h.state();
			if(s === 0) {
				h.visit(h, void 0, h._unreport);
			} else if(s < 0) {
				h._unreport();
			}
		}

		/**
		 * Fulfill-reject competitive race. Return a promise that will settle
		 * to the same state as the earliest input promise to settle.
		 *
		 * WARNING: The ES6 Promise spec requires that race()ing an empty array
		 * must return a promise that is pending forever.  This implementation
		 * returns a singleton forever-pending promise, the same singleton that is
		 * returned by Promise.never(), thus can be checked with ===
		 *
		 * @param {array} promises array of promises to race
		 * @returns {Promise} if input is non-empty, a promise that will settle
		 * to the same outcome as the earliest input promise to settle. if empty
		 * is empty, returns a promise that will never settle.
		 */
		function race(promises) {
			if(typeof promises !== 'object' || promises === null) {
				return reject(new TypeError('non-iterable passed to race()'));
			}

			// Sigh, race([]) is untestable unless we return *something*
			// that is recognizable without calling .then() on it.
			return promises.length === 0 ? never()
				 : promises.length === 1 ? resolve(promises[0])
				 : runRace(promises);
		}

		function runRace(promises) {
			var resolver = new Pending();
			var i, x, h;
			for(i=0; i<promises.length; ++i) {
				x = promises[i];
				if (x === void 0 && !(i in promises)) {
					continue;
				}

				h = getHandler(x);
				if(h.state() !== 0) {
					resolver.become(h);
					visitRemaining(promises, i+1, h);
					break;
				} else {
					h.visit(resolver, resolver.resolve, resolver.reject);
				}
			}
			return new Promise(Handler, resolver);
		}

		// Promise internals
		// Below this, everything is @private

		/**
		 * Get an appropriate handler for x, without checking for cycles
		 * @param {*} x
		 * @returns {object} handler
		 */
		function getHandler(x) {
			if(isPromise(x)) {
				return x._handler.join();
			}
			return maybeThenable(x) ? getHandlerUntrusted(x) : new Fulfilled(x);
		}

		/**
		 * Get a handler for thenable x.
		 * NOTE: You must only call this if maybeThenable(x) == true
		 * @param {object|function|Promise} x
		 * @returns {object} handler
		 */
		function getHandlerMaybeThenable(x) {
			return isPromise(x) ? x._handler.join() : getHandlerUntrusted(x);
		}

		/**
		 * Get a handler for potentially untrusted thenable x
		 * @param {*} x
		 * @returns {object} handler
		 */
		function getHandlerUntrusted(x) {
			try {
				var untrustedThen = x.then;
				return typeof untrustedThen === 'function'
					? new Thenable(untrustedThen, x)
					: new Fulfilled(x);
			} catch(e) {
				return new Rejected(e);
			}
		}

		/**
		 * Handler for a promise that is pending forever
		 * @constructor
		 */
		function Handler() {}

		Handler.prototype.when
			= Handler.prototype.become
			= Handler.prototype.notify // deprecated
			= Handler.prototype.fail
			= Handler.prototype._unreport
			= Handler.prototype._report
			= noop;

		Handler.prototype._state = 0;

		Handler.prototype.state = function() {
			return this._state;
		};

		/**
		 * Recursively collapse handler chain to find the handler
		 * nearest to the fully resolved value.
		 * @returns {object} handler nearest the fully resolved value
		 */
		Handler.prototype.join = function() {
			var h = this;
			while(h.handler !== void 0) {
				h = h.handler;
			}
			return h;
		};

		Handler.prototype.chain = function(to, receiver, fulfilled, rejected, progress) {
			this.when({
				resolver: to,
				receiver: receiver,
				fulfilled: fulfilled,
				rejected: rejected,
				progress: progress
			});
		};

		Handler.prototype.visit = function(receiver, fulfilled, rejected, progress) {
			this.chain(failIfRejected, receiver, fulfilled, rejected, progress);
		};

		Handler.prototype.fold = function(f, z, c, to) {
			this.when(new Fold(f, z, c, to));
		};

		/**
		 * Handler that invokes fail() on any handler it becomes
		 * @constructor
		 */
		function FailIfRejected() {}

		inherit(Handler, FailIfRejected);

		FailIfRejected.prototype.become = function(h) {
			h.fail();
		};

		var failIfRejected = new FailIfRejected();

		/**
		 * Handler that manages a queue of consumers waiting on a pending promise
		 * @constructor
		 */
		function Pending(receiver, inheritedContext) {
			Promise.createContext(this, inheritedContext);

			this.consumers = void 0;
			this.receiver = receiver;
			this.handler = void 0;
			this.resolved = false;
		}

		inherit(Handler, Pending);

		Pending.prototype._state = 0;

		Pending.prototype.resolve = function(x) {
			this.become(getHandler(x));
		};

		Pending.prototype.reject = function(x) {
			if(this.resolved) {
				return;
			}

			this.become(new Rejected(x));
		};

		Pending.prototype.join = function() {
			if (!this.resolved) {
				return this;
			}

			var h = this;

			while (h.handler !== void 0) {
				h = h.handler;
				if (h === this) {
					return this.handler = cycle();
				}
			}

			return h;
		};

		Pending.prototype.run = function() {
			var q = this.consumers;
			var handler = this.handler;
			this.handler = this.handler.join();
			this.consumers = void 0;

			for (var i = 0; i < q.length; ++i) {
				handler.when(q[i]);
			}
		};

		Pending.prototype.become = function(handler) {
			if(this.resolved) {
				return;
			}

			this.resolved = true;
			this.handler = handler;
			if(this.consumers !== void 0) {
				tasks.enqueue(this);
			}

			if(this.context !== void 0) {
				handler._report(this.context);
			}
		};

		Pending.prototype.when = function(continuation) {
			if(this.resolved) {
				tasks.enqueue(new ContinuationTask(continuation, this.handler));
			} else {
				if(this.consumers === void 0) {
					this.consumers = [continuation];
				} else {
					this.consumers.push(continuation);
				}
			}
		};

		/**
		 * @deprecated
		 */
		Pending.prototype.notify = function(x) {
			if(!this.resolved) {
				tasks.enqueue(new ProgressTask(x, this));
			}
		};

		Pending.prototype.fail = function(context) {
			var c = typeof context === 'undefined' ? this.context : context;
			this.resolved && this.handler.join().fail(c);
		};

		Pending.prototype._report = function(context) {
			this.resolved && this.handler.join()._report(context);
		};

		Pending.prototype._unreport = function() {
			this.resolved && this.handler.join()._unreport();
		};

		/**
		 * Wrap another handler and force it into a future stack
		 * @param {object} handler
		 * @constructor
		 */
		function Async(handler) {
			this.handler = handler;
		}

		inherit(Handler, Async);

		Async.prototype.when = function(continuation) {
			tasks.enqueue(new ContinuationTask(continuation, this));
		};

		Async.prototype._report = function(context) {
			this.join()._report(context);
		};

		Async.prototype._unreport = function() {
			this.join()._unreport();
		};

		/**
		 * Handler that wraps an untrusted thenable and assimilates it in a future stack
		 * @param {function} then
		 * @param {{then: function}} thenable
		 * @constructor
		 */
		function Thenable(then, thenable) {
			Pending.call(this);
			tasks.enqueue(new AssimilateTask(then, thenable, this));
		}

		inherit(Pending, Thenable);

		/**
		 * Handler for a fulfilled promise
		 * @param {*} x fulfillment value
		 * @constructor
		 */
		function Fulfilled(x) {
			Promise.createContext(this);
			this.value = x;
		}

		inherit(Handler, Fulfilled);

		Fulfilled.prototype._state = 1;

		Fulfilled.prototype.fold = function(f, z, c, to) {
			runContinuation3(f, z, this, c, to);
		};

		Fulfilled.prototype.when = function(cont) {
			runContinuation1(cont.fulfilled, this, cont.receiver, cont.resolver);
		};

		var errorId = 0;

		/**
		 * Handler for a rejected promise
		 * @param {*} x rejection reason
		 * @constructor
		 */
		function Rejected(x) {
			Promise.createContext(this);

			this.id = ++errorId;
			this.value = x;
			this.handled = false;
			this.reported = false;

			this._report();
		}

		inherit(Handler, Rejected);

		Rejected.prototype._state = -1;

		Rejected.prototype.fold = function(f, z, c, to) {
			to.become(this);
		};

		Rejected.prototype.when = function(cont) {
			if(typeof cont.rejected === 'function') {
				this._unreport();
			}
			runContinuation1(cont.rejected, this, cont.receiver, cont.resolver);
		};

		Rejected.prototype._report = function(context) {
			tasks.afterQueue(new ReportTask(this, context));
		};

		Rejected.prototype._unreport = function() {
			if(this.handled) {
				return;
			}
			this.handled = true;
			tasks.afterQueue(new UnreportTask(this));
		};

		Rejected.prototype.fail = function(context) {
			this.reported = true;
			emitRejection('unhandledRejection', this);
			Promise.onFatalRejection(this, context === void 0 ? this.context : context);
		};

		function ReportTask(rejection, context) {
			this.rejection = rejection;
			this.context = context;
		}

		ReportTask.prototype.run = function() {
			if(!this.rejection.handled && !this.rejection.reported) {
				this.rejection.reported = true;
				emitRejection('unhandledRejection', this.rejection) ||
					Promise.onPotentiallyUnhandledRejection(this.rejection, this.context);
			}
		};

		function UnreportTask(rejection) {
			this.rejection = rejection;
		}

		UnreportTask.prototype.run = function() {
			if(this.rejection.reported) {
				emitRejection('rejectionHandled', this.rejection) ||
					Promise.onPotentiallyUnhandledRejectionHandled(this.rejection);
			}
		};

		// Unhandled rejection hooks
		// By default, everything is a noop

		Promise.createContext
			= Promise.enterContext
			= Promise.exitContext
			= Promise.onPotentiallyUnhandledRejection
			= Promise.onPotentiallyUnhandledRejectionHandled
			= Promise.onFatalRejection
			= noop;

		// Errors and singletons

		var foreverPendingHandler = new Handler();
		var foreverPendingPromise = new Promise(Handler, foreverPendingHandler);

		function cycle() {
			return new Rejected(new TypeError('Promise cycle'));
		}

		// Task runners

		/**
		 * Run a single consumer
		 * @constructor
		 */
		function ContinuationTask(continuation, handler) {
			this.continuation = continuation;
			this.handler = handler;
		}

		ContinuationTask.prototype.run = function() {
			this.handler.join().when(this.continuation);
		};

		/**
		 * Run a queue of progress handlers
		 * @constructor
		 */
		function ProgressTask(value, handler) {
			this.handler = handler;
			this.value = value;
		}

		ProgressTask.prototype.run = function() {
			var q = this.handler.consumers;
			if(q === void 0) {
				return;
			}

			for (var c, i = 0; i < q.length; ++i) {
				c = q[i];
				runNotify(c.progress, this.value, this.handler, c.receiver, c.resolver);
			}
		};

		/**
		 * Assimilate a thenable, sending it's value to resolver
		 * @param {function} then
		 * @param {object|function} thenable
		 * @param {object} resolver
		 * @constructor
		 */
		function AssimilateTask(then, thenable, resolver) {
			this._then = then;
			this.thenable = thenable;
			this.resolver = resolver;
		}

		AssimilateTask.prototype.run = function() {
			var h = this.resolver;
			tryAssimilate(this._then, this.thenable, _resolve, _reject, _notify);

			function _resolve(x) { h.resolve(x); }
			function _reject(x)  { h.reject(x); }
			function _notify(x)  { h.notify(x); }
		};

		function tryAssimilate(then, thenable, resolve, reject, notify) {
			try {
				then.call(thenable, resolve, reject, notify);
			} catch (e) {
				reject(e);
			}
		}

		/**
		 * Fold a handler value with z
		 * @constructor
		 */
		function Fold(f, z, c, to) {
			this.f = f; this.z = z; this.c = c; this.to = to;
			this.resolver = failIfRejected;
			this.receiver = this;
		}

		Fold.prototype.fulfilled = function(x) {
			this.f.call(this.c, this.z, x, this.to);
		};

		Fold.prototype.rejected = function(x) {
			this.to.reject(x);
		};

		Fold.prototype.progress = function(x) {
			this.to.notify(x);
		};

		// Other helpers

		/**
		 * @param {*} x
		 * @returns {boolean} true iff x is a trusted Promise
		 */
		function isPromise(x) {
			return x instanceof Promise;
		}

		/**
		 * Test just enough to rule out primitives, in order to take faster
		 * paths in some code
		 * @param {*} x
		 * @returns {boolean} false iff x is guaranteed *not* to be a thenable
		 */
		function maybeThenable(x) {
			return (typeof x === 'object' || typeof x === 'function') && x !== null;
		}

		function runContinuation1(f, h, receiver, next) {
			if(typeof f !== 'function') {
				return next.become(h);
			}

			Promise.enterContext(h);
			tryCatchReject(f, h.value, receiver, next);
			Promise.exitContext();
		}

		function runContinuation3(f, x, h, receiver, next) {
			if(typeof f !== 'function') {
				return next.become(h);
			}

			Promise.enterContext(h);
			tryCatchReject3(f, x, h.value, receiver, next);
			Promise.exitContext();
		}

		/**
		 * @deprecated
		 */
		function runNotify(f, x, h, receiver, next) {
			if(typeof f !== 'function') {
				return next.notify(x);
			}

			Promise.enterContext(h);
			tryCatchReturn(f, x, receiver, next);
			Promise.exitContext();
		}

		function tryCatch2(f, a, b) {
			try {
				return f(a, b);
			} catch(e) {
				return reject(e);
			}
		}

		/**
		 * Return f.call(thisArg, x), or if it throws return a rejected promise for
		 * the thrown exception
		 */
		function tryCatchReject(f, x, thisArg, next) {
			try {
				next.become(getHandler(f.call(thisArg, x)));
			} catch(e) {
				next.become(new Rejected(e));
			}
		}

		/**
		 * Same as above, but includes the extra argument parameter.
		 */
		function tryCatchReject3(f, x, y, thisArg, next) {
			try {
				f.call(thisArg, x, y, next);
			} catch(e) {
				next.become(new Rejected(e));
			}
		}

		/**
		 * @deprecated
		 * Return f.call(thisArg, x), or if it throws, *return* the exception
		 */
		function tryCatchReturn(f, x, thisArg, next) {
			try {
				next.notify(f.call(thisArg, x));
			} catch(e) {
				next.notify(e);
			}
		}

		function inherit(Parent, Child) {
			Child.prototype = objectCreate(Parent.prototype);
			Child.prototype.constructor = Child;
		}

		function snd(x, y) {
			return y;
		}

		function noop() {}

		function hasCustomEvent() {
			if(typeof CustomEvent === 'function') {
				try {
					var ev = new CustomEvent('unhandledRejection');
					return ev instanceof CustomEvent;
				} catch (ignoredException) {}
			}
			return false;
		}

		function hasInternetExplorerCustomEvent() {
			if(typeof document !== 'undefined' && typeof document.createEvent === 'function') {
				try {
					// Try to create one event to make sure it's supported
					var ev = document.createEvent('CustomEvent');
					ev.initCustomEvent('eventType', false, true, {});
					return true;
				} catch (ignoredException) {}
			}
			return false;
		}

		function initEmitRejection() {
			/*global process, self, CustomEvent*/
			if(typeof process !== 'undefined' && process !== null
				&& typeof process.emit === 'function') {
				// Returning falsy here means to call the default
				// onPotentiallyUnhandledRejection API.  This is safe even in
				// browserify since process.emit always returns falsy in browserify:
				// https://github.com/defunctzombie/node-process/blob/master/browser.js#L40-L46
				return function(type, rejection) {
					return type === 'unhandledRejection'
						? process.emit(type, rejection.value, rejection)
						: process.emit(type, rejection);
				};
			} else if(typeof self !== 'undefined' && hasCustomEvent()) {
				return (function (self, CustomEvent) {
					return function (type, rejection) {
						var ev = new CustomEvent(type, {
							detail: {
								reason: rejection.value,
								key: rejection
							},
							bubbles: false,
							cancelable: true
						});

						return !self.dispatchEvent(ev);
					};
				}(self, CustomEvent));
			} else if(typeof self !== 'undefined' && hasInternetExplorerCustomEvent()) {
				return (function(self, document) {
					return function(type, rejection) {
						var ev = document.createEvent('CustomEvent');
						ev.initCustomEvent(type, false, true, {
							reason: rejection.value,
							key: rejection
						});

						return !self.dispatchEvent(ev);
					};
				}(self, document));
			}

			return noop;
		}

		return Promise;
	};
});
}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(); }));

}).call(this,require('_process'))
},{"_process":458}],498:[function(require,module,exports){
/** @license MIT License (c) copyright 2010-2014 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

(function(define) { 'use strict';
define(function() {

	return {
		pending: toPendingState,
		fulfilled: toFulfilledState,
		rejected: toRejectedState,
		inspect: inspect
	};

	function toPendingState() {
		return { state: 'pending' };
	}

	function toRejectedState(e) {
		return { state: 'rejected', reason: e };
	}

	function toFulfilledState(x) {
		return { state: 'fulfilled', value: x };
	}

	function inspect(handler) {
		var state = handler.state();
		return state === 0 ? toPendingState()
			 : state > 0   ? toFulfilledState(handler.value)
			               : toRejectedState(handler.value);
	}

});
}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(); }));

},{}],499:[function(require,module,exports){
/** @license MIT License (c) copyright 2013 original author or authors */

/**
 * Collection of helpers for interfacing with node-style asynchronous functions
 * using promises.
 *
 * @author Brian Cavalier
 * @contributor Renato Zannon
 */

(function(define) {
define(function(require) {

	var when = require('./when');
	var _liftAll = require('./lib/liftAll');
	var setTimer = require('./lib/env').setTimer;
	var slice = Array.prototype.slice;

	var _apply = require('./lib/apply')(when.Promise, dispatch);

	return {
		lift: lift,
		liftAll: liftAll,
		apply: apply,
		call: call,
		createCallback: createCallback,
		bindCallback: bindCallback,
		liftCallback: liftCallback
	};

	/**
	 * Takes a node-style async function and calls it immediately (with an optional
	 * array of arguments or promises for arguments). It returns a promise whose
	 * resolution depends on whether the async functions calls its callback with the
	 * conventional error argument or not.
	 *
	 * With this it becomes possible to leverage existing APIs while still reaping
	 * the benefits of promises.
	 *
	 * @example
	 *    function onlySmallNumbers(n, callback) {
	 *		if(n < 10) {
	 *			callback(null, n + 10);
	 *		} else {
	 *			callback(new Error("Calculation failed"));
	 *		}
	 *	}
	 *
	 *    var nodefn = require("when/node/function");
	 *
	 *    // Logs '15'
	 *    nodefn.apply(onlySmallNumbers, [5]).then(console.log, console.error);
	 *
	 *    // Logs 'Calculation failed'
	 *    nodefn.apply(onlySmallNumbers, [15]).then(console.log, console.error);
	 *
	 * @param {function} f node-style function that will be called
	 * @param {Array} [args] array of arguments to func
	 * @returns {Promise} promise for the value func passes to its callback
	 */
	function apply(f, args) {
		return _apply(f, this, args || []);
	}

	function dispatch(f, thisArg, args, h) {
		var cb = createCallback(h);
		try {
			switch(args.length) {
				case 2: f.call(thisArg, args[0], args[1], cb); break;
				case 1: f.call(thisArg, args[0], cb); break;
				case 0: f.call(thisArg, cb); break;
				default:
					args.push(cb);
					f.apply(thisArg, args);
			}
		} catch(e) {
			h.reject(e);
		}
	}

	/**
	 * Has the same behavior that {@link apply} has, with the difference that the
	 * arguments to the function are provided individually, while {@link apply} accepts
	 * a single array.
	 *
	 * @example
	 *    function sumSmallNumbers(x, y, callback) {
	 *		var result = x + y;
	 *		if(result < 10) {
	 *			callback(null, result);
	 *		} else {
	 *			callback(new Error("Calculation failed"));
	 *		}
	 *	}
	 *
	 *    // Logs '5'
	 *    nodefn.call(sumSmallNumbers, 2, 3).then(console.log, console.error);
	 *
	 *    // Logs 'Calculation failed'
	 *    nodefn.call(sumSmallNumbers, 5, 10).then(console.log, console.error);
	 *
	 * @param {function} f node-style function that will be called
	 * @param {...*} [args] arguments that will be forwarded to the function
	 * @returns {Promise} promise for the value func passes to its callback
	 */
	function call(f /*, args... */) {
		return _apply(f, this, slice.call(arguments, 1));
	}

	/**
	 * Takes a node-style function and returns new function that wraps the
	 * original and, instead of taking a callback, returns a promise. Also, it
	 * knows how to handle promises given as arguments, waiting for their
	 * resolution before executing.
	 *
	 * Upon execution, the orginal function is executed as well. If it passes
	 * a truthy value as the first argument to the callback, it will be
	 * interpreted as an error condition, and the promise will be rejected
	 * with it. Otherwise, the call is considered a resolution, and the promise
	 * is resolved with the callback's second argument.
	 *
	 * @example
	 *    var fs = require("fs"), nodefn = require("when/node/function");
	 *
	 *    var promiseRead = nodefn.lift(fs.readFile);
	 *
	 *    // The promise is resolved with the contents of the file if everything
	 *    // goes ok
	 *    promiseRead('exists.txt').then(console.log, console.error);
	 *
	 *    // And will be rejected if something doesn't work out
	 *    // (e.g. the files does not exist)
	 *    promiseRead('doesnt_exist.txt').then(console.log, console.error);
	 *
	 *
	 * @param {Function} f node-style function to be lifted
	 * @param {...*} [args] arguments to be prepended for the new function @deprecated
	 * @returns {Function} a promise-returning function
	 */
	function lift(f /*, args... */) {
		var args1 = arguments.length > 1 ? slice.call(arguments, 1) : [];
		return function() {
			// TODO: Simplify once partialing has been removed
			var l = args1.length;
			var al = arguments.length;
			var args = new Array(al + l);
			var i;
			for(i=0; i<l; ++i) {
				args[i] = args1[i];
			}
			for(i=0; i<al; ++i) {
				args[i+l] = arguments[i];
			}
			return _apply(f, this, args);
		};
	}

	/**
	 * Lift all the functions/methods on src
	 * @param {object|function} src source whose functions will be lifted
	 * @param {function?} combine optional function for customizing the lifting
	 *  process. It is passed dst, the lifted function, and the property name of
	 *  the original function on src.
	 * @param {(object|function)?} dst option destination host onto which to place lifted
	 *  functions. If not provided, liftAll returns a new object.
	 * @returns {*} If dst is provided, returns dst with lifted functions as
	 *  properties.  If dst not provided, returns a new object with lifted functions.
	 */
	function liftAll(src, combine, dst) {
		return _liftAll(lift, combine, dst, src);
	}

	/**
	 * Takes an object that responds to the resolver interface, and returns
	 * a function that will resolve or reject it depending on how it is called.
	 *
	 * @example
	 *	function callbackTakingFunction(callback) {
	 *		if(somethingWrongHappened) {
	 *			callback(error);
	 *		} else {
	 *			callback(null, interestingValue);
	 *		}
	 *	}
	 *
	 *	var when = require('when'), nodefn = require('when/node/function');
	 *
	 *	var deferred = when.defer();
	 *	callbackTakingFunction(nodefn.createCallback(deferred.resolver));
	 *
	 *	deferred.promise.then(function(interestingValue) {
	 *		// Use interestingValue
	 *	});
	 *
	 * @param {Resolver} resolver that will be 'attached' to the callback
	 * @returns {Function} a node-style callback function
	 */
	function createCallback(resolver) {
		return function(err, value) {
			if(err) {
				resolver.reject(err);
			} else if(arguments.length > 2) {
				resolver.resolve(slice.call(arguments, 1));
			} else {
				resolver.resolve(value);
			}
		};
	}

	/**
	 * Attaches a node-style callback to a promise, ensuring the callback is
	 * called for either fulfillment or rejection. Returns a promise with the same
	 * state as the passed-in promise.
	 *
	 * @example
	 *	var deferred = when.defer();
	 *
	 *	function callback(err, value) {
	 *		// Handle err or use value
	 *	}
	 *
	 *	bindCallback(deferred.promise, callback);
	 *
	 *	deferred.resolve('interesting value');
	 *
	 * @param {Promise} promise The promise to be attached to.
	 * @param {Function} callback The node-style callback to attach.
	 * @returns {Promise} A promise with the same state as the passed-in promise.
	 */
	function bindCallback(promise, callback) {
		promise = when(promise);

		if (callback) {
			promise.then(success, wrapped);
		}

		return promise;

		function success(value) {
			wrapped(null, value);
		}

		function wrapped(err, value) {
			setTimer(function () {
				callback(err, value);
			}, 0);
		}
	}

	/**
	 * Takes a node-style callback and returns new function that accepts a
	 * promise, calling the original callback when the promise is either
	 * fulfilled or rejected with the appropriate arguments.
	 *
	 * @example
	 *	var deferred = when.defer();
	 *
	 *	function callback(err, value) {
	 *		// Handle err or use value
	 *	}
	 *
	 *	var wrapped = liftCallback(callback);
	 *
	 *	// `wrapped` can now be passed around at will
	 *	wrapped(deferred.promise);
	 *
	 *	deferred.resolve('interesting value');
	 *
	 * @param {Function} callback The node-style callback to wrap.
	 * @returns {Function} The lifted, promise-accepting function.
	 */
	function liftCallback(callback) {
		return function(promise) {
			return bindCallback(promise, callback);
		};
	}
});

})(typeof define === 'function' && define.amd ? define : function (factory) { module.exports = factory(require); });




},{"./lib/apply":484,"./lib/env":494,"./lib/liftAll":496,"./when":500}],500:[function(require,module,exports){
/** @license MIT License (c) copyright 2010-2014 original author or authors */

/**
 * Promises/A+ and when() implementation
 * when is part of the cujoJS family of libraries (http://cujojs.com/)
 * @author Brian Cavalier
 * @author John Hann
 */
(function(define) { 'use strict';
define(function (require) {

	var timed = require('./lib/decorators/timed');
	var array = require('./lib/decorators/array');
	var flow = require('./lib/decorators/flow');
	var fold = require('./lib/decorators/fold');
	var inspect = require('./lib/decorators/inspect');
	var generate = require('./lib/decorators/iterate');
	var progress = require('./lib/decorators/progress');
	var withThis = require('./lib/decorators/with');
	var unhandledRejection = require('./lib/decorators/unhandledRejection');
	var TimeoutError = require('./lib/TimeoutError');

	var Promise = [array, flow, fold, generate, progress,
		inspect, withThis, timed, unhandledRejection]
		.reduce(function(Promise, feature) {
			return feature(Promise);
		}, require('./lib/Promise'));

	var apply = require('./lib/apply')(Promise);

	// Public API

	when.promise     = promise;              // Create a pending promise
	when.resolve     = Promise.resolve;      // Create a resolved promise
	when.reject      = Promise.reject;       // Create a rejected promise

	when.lift        = lift;                 // lift a function to return promises
	when['try']      = attempt;              // call a function and return a promise
	when.attempt     = attempt;              // alias for when.try

	when.iterate     = Promise.iterate;      // DEPRECATED (use cujojs/most streams) Generate a stream of promises
	when.unfold      = Promise.unfold;       // DEPRECATED (use cujojs/most streams) Generate a stream of promises

	when.join        = join;                 // Join 2 or more promises

	when.all         = all;                  // Resolve a list of promises
	when.settle      = settle;               // Settle a list of promises

	when.any         = lift(Promise.any);    // One-winner race
	when.some        = lift(Promise.some);   // Multi-winner race
	when.race        = lift(Promise.race);   // First-to-settle race

	when.map         = map;                  // Array.map() for promises
	when.filter      = filter;               // Array.filter() for promises
	when.reduce      = lift(Promise.reduce);       // Array.reduce() for promises
	when.reduceRight = lift(Promise.reduceRight);  // Array.reduceRight() for promises

	when.isPromiseLike = isPromiseLike;      // Is something promise-like, aka thenable

	when.Promise     = Promise;              // Promise constructor
	when.defer       = defer;                // Create a {promise, resolve, reject} tuple

	// Error types

	when.TimeoutError = TimeoutError;

	/**
	 * Get a trusted promise for x, or by transforming x with onFulfilled
	 *
	 * @param {*} x
	 * @param {function?} onFulfilled callback to be called when x is
	 *   successfully fulfilled.  If promiseOrValue is an immediate value, callback
	 *   will be invoked immediately.
	 * @param {function?} onRejected callback to be called when x is
	 *   rejected.
	 * @param {function?} onProgress callback to be called when progress updates
	 *   are issued for x. @deprecated
	 * @returns {Promise} a new promise that will fulfill with the return
	 *   value of callback or errback or the completion value of promiseOrValue if
	 *   callback and/or errback is not supplied.
	 */
	function when(x, onFulfilled, onRejected, onProgress) {
		var p = Promise.resolve(x);
		if (arguments.length < 2) {
			return p;
		}

		return p.then(onFulfilled, onRejected, onProgress);
	}

	/**
	 * Creates a new promise whose fate is determined by resolver.
	 * @param {function} resolver function(resolve, reject, notify)
	 * @returns {Promise} promise whose fate is determine by resolver
	 */
	function promise(resolver) {
		return new Promise(resolver);
	}

	/**
	 * Lift the supplied function, creating a version of f that returns
	 * promises, and accepts promises as arguments.
	 * @param {function} f
	 * @returns {Function} version of f that returns promises
	 */
	function lift(f) {
		return function() {
			for(var i=0, l=arguments.length, a=new Array(l); i<l; ++i) {
				a[i] = arguments[i];
			}
			return apply(f, this, a);
		};
	}

	/**
	 * Call f in a future turn, with the supplied args, and return a promise
	 * for the result.
	 * @param {function} f
	 * @returns {Promise}
	 */
	function attempt(f /*, args... */) {
		/*jshint validthis:true */
		for(var i=0, l=arguments.length-1, a=new Array(l); i<l; ++i) {
			a[i] = arguments[i+1];
		}
		return apply(f, this, a);
	}

	/**
	 * Creates a {promise, resolver} pair, either or both of which
	 * may be given out safely to consumers.
	 * @return {{promise: Promise, resolve: function, reject: function, notify: function}}
	 */
	function defer() {
		return new Deferred();
	}

	function Deferred() {
		var p = Promise._defer();

		function resolve(x) { p._handler.resolve(x); }
		function reject(x) { p._handler.reject(x); }
		function notify(x) { p._handler.notify(x); }

		this.promise = p;
		this.resolve = resolve;
		this.reject = reject;
		this.notify = notify;
		this.resolver = { resolve: resolve, reject: reject, notify: notify };
	}

	/**
	 * Determines if x is promise-like, i.e. a thenable object
	 * NOTE: Will return true for *any thenable object*, and isn't truly
	 * safe, since it may attempt to access the `then` property of x (i.e.
	 *  clever/malicious getters may do weird things)
	 * @param {*} x anything
	 * @returns {boolean} true if x is promise-like
	 */
	function isPromiseLike(x) {
		return x && typeof x.then === 'function';
	}

	/**
	 * Return a promise that will resolve only once all the supplied arguments
	 * have resolved. The resolution value of the returned promise will be an array
	 * containing the resolution values of each of the arguments.
	 * @param {...*} arguments may be a mix of promises and values
	 * @returns {Promise}
	 */
	function join(/* ...promises */) {
		return Promise.all(arguments);
	}

	/**
	 * Return a promise that will fulfill once all input promises have
	 * fulfilled, or reject when any one input promise rejects.
	 * @param {array|Promise} promises array (or promise for an array) of promises
	 * @returns {Promise}
	 */
	function all(promises) {
		return when(promises, Promise.all);
	}

	/**
	 * Return a promise that will always fulfill with an array containing
	 * the outcome states of all input promises.  The returned promise
	 * will only reject if `promises` itself is a rejected promise.
	 * @param {array|Promise} promises array (or promise for an array) of promises
	 * @returns {Promise} promise for array of settled state descriptors
	 */
	function settle(promises) {
		return when(promises, Promise.settle);
	}

	/**
	 * Promise-aware array map function, similar to `Array.prototype.map()`,
	 * but input array may contain promises or values.
	 * @param {Array|Promise} promises array of anything, may contain promises and values
	 * @param {function(x:*, index:Number):*} mapFunc map function which may
	 *  return a promise or value
	 * @returns {Promise} promise that will fulfill with an array of mapped values
	 *  or reject if any input promise rejects.
	 */
	function map(promises, mapFunc) {
		return when(promises, function(promises) {
			return Promise.map(promises, mapFunc);
		});
	}

	/**
	 * Filter the provided array of promises using the provided predicate.  Input may
	 * contain promises and values
	 * @param {Array|Promise} promises array of promises and values
	 * @param {function(x:*, index:Number):boolean} predicate filtering predicate.
	 *  Must return truthy (or promise for truthy) for items to retain.
	 * @returns {Promise} promise that will fulfill with an array containing all items
	 *  for which predicate returned truthy.
	 */
	function filter(promises, predicate) {
		return when(promises, function(promises) {
			return Promise.filter(promises, predicate);
		});
	}

	return when;
});
})(typeof define === 'function' && define.amd ? define : function (factory) { module.exports = factory(require); });

},{"./lib/Promise":481,"./lib/TimeoutError":483,"./lib/apply":484,"./lib/decorators/array":485,"./lib/decorators/flow":486,"./lib/decorators/fold":487,"./lib/decorators/inspect":488,"./lib/decorators/iterate":489,"./lib/decorators/progress":490,"./lib/decorators/timed":491,"./lib/decorators/unhandledRejection":492,"./lib/decorators/with":493}]},{},[25]);
