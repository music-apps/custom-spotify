(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
'use strict';

// This file will likely become a generated file in the future. Please
// avoid adding extra APIs or exports here.

const i18n = require('../../../libs/spotify-i18n')({
  'cs': require('./json/cs.json'),
  'de': require('./json/de.json'),
  'el': require('./json/el.json'),
  'en': require('./json/en.json'),
  'es': require('./json/es.json'),
  'es-419': require('./json/es-419.json'),
  'fi': require('./json/fi.json'),
  'fr': require('./json/fr.json'),
  'fr-CA': require('./json/fr-CA.json'),
  'hu': require('./json/hu.json'),
  'id': require('./json/id.json'),
  'it': require('./json/it.json'),
  'ja': require('./json/ja.json'),
  'nl': require('./json/nl.json'),
  'pl': require('./json/pl.json'),
  'pt-BR': require('./json/pt-BR.json'),
  'sv': require('./json/sv.json'),
  'th': require('./json/th.json'),
  'tr': require('./json/tr.json'),
  'vi': require('./json/vi.json'),
  'zh-Hant': require('./json/zh-Hant.json'),
  'zsm': require('./json/zsm.json')
});

module.exports = i18n;

},{"../../../libs/spotify-i18n":353,"./json/cs.json":2,"./json/de.json":3,"./json/el.json":4,"./json/en.json":5,"./json/es-419.json":6,"./json/es.json":7,"./json/fi.json":8,"./json/fr-CA.json":9,"./json/fr.json":10,"./json/hu.json":11,"./json/id.json":12,"./json/it.json":13,"./json/ja.json":14,"./json/nl.json":15,"./json/pl.json":16,"./json/pt-BR.json":17,"./json/sv.json":18,"./json/th.json":19,"./json/tr.json":20,"./json/vi.json":21,"./json/zh-Hant.json":22,"./json/zsm.json":23}],2:[function(require,module,exports){
module.exports={
  "app.name": "Neo Search",
  "app.description": "",
  "app.offlineTitle": "Hledání není v režimu offline k dispozici.",
  "app.offlineMessage": "Pro načtení přejdi prosím online.",
  "app.errorTitle": "Chyba",
  "app.errorMessage": "Načítání se nezdařilo.",
  "header.recentlySearchedTitle": "Nedávno vyhledávané",
  "header.searchResultsTitle": "Výsledky vyhledávání",
  "header.allResultsTitle": "Výsledky pro zadání {0}",
  "header.artistsResultsTitle": "Umělci odpovídající zadání {0}",
  "header.albumsResultsTitle": "Alba odpovídající zadání {0}",
  "header.tracksResultsTitle": "Skladby odpovídající zadání {0}",
  "header.playlistsResultsTitle": "Playlisty odpovídající zadání {0}",
  "header.profilesResultsTitle": "Profily odpovídající zadání {0}",
  "header.genresResultsTitle": "Žánry odpovídající zadání {0}",
  "header.showsResultsTitle": "Podcasty a videa odpovídající zadání {0}",
  "header.videoepisodesResultsTitle": "Epizody videa odpovídající zadání {0}",
  "recentlySearched.removeFromRecentlySearched": "Odstranit ze seznamu nedávných hledání",
  "recentlySearched.clearRecentSearches": "Vymazat seznam",
  "emptyView.searchSpotify": "Prohledat Spotify",
  "emptyView.findYourMusic": "Vyhledej své oblíbené skladby, umělce, alba, podcasty a videa, playlisty nebo přátele.",
  "emptyView.noResults": "Pro „{0}“ nebyly nalezeny žádné výsledky",
  "emptyView.noResultsText": "Zkontroluj, jestli v zadání nemáš překlep, nebo použij jiná klíčová slova.",
  "emptyView.errorTitle": "Něco se pokazilo",
  "emptyView.errorText": "Zkus to prosím později.",
  "emptyView.offlineTitle": "Offline jsme nenašli nic, co by odpovídalo zadání „{0}“.",
  "emptyView.offlineText": "Připoj se k internetu a vyhledávej mezi miliony skladeb.",
  "emptyView.spotifyOffline": "Spotify v režimu offline",
  "emptyView.offlineResultsText": "Spotify je v režimu offline. Proto máš přístup jen ke svým místním souborům. Celou knihovnu uvidíš, až se připojíš k internetu.",
  "facebookFriend": "Přítel na Facebooku",
  "following": "Sleduješ",
  "followers": {
    "one": "1 sledující",
    "few": "Počet sledujících: {0}",
    "other": "Počet sledujících: {0}"
  },
  "topHit": "Nejlepší výsledek",
  "topRecommendations": "Obsahuje: {0}",
  "artists": "Umělci",
  "tracks": "Skladby",
  "playlists": "Playlisty",
  "albums": "Alba",
  "genres": "Žánry",
  "profiles": "Profily",
  "shows": "Podcasty a videa",
  "videoepisodes": "Epizody videa",
  "localFiles": "Místní soubory",
  "see_all": "Zobrazit vše",
  "artist": "Umělec",
  "track": "Skladba",
  "playlist": "Playlist",
  "album": "Album",
  "genre": "Žánr",
  "profile": "Profil",
  "audio": "Podcast",
  "video": "Video",
  "episode": "Epizoda videa",
  "see_all_tracks": "Zobrazit všechny skladby",
  "see_all_artists": "Zobrazit všechny umělce",
  "see_all_albums": "Zobrazit všechna alba",
  "see_all_playlists": "Zobrazit všechny playlisty",
  "see_all_profiles": "Zobrazit všechny profily",
  "see_all_genres": "Zobrazit všechny žánry",
  "see_all_shows": "Zobrazit všechny podcasty a videa",
  "see_all_videoepisodes": "Zobrazit všechny epizody videa"
}
},{}],3:[function(require,module,exports){
module.exports={
  "app.name": "Neo Search",
  "app.description": "",
  "app.offlineTitle": "Suchen ohne Internetverbindung nicht möglich.",
  "app.offlineMessage": "Geh zum Laden online.",
  "app.errorTitle": "Fehler",
  "app.errorMessage": "Fehler beim Laden",
  "header.recentlySearchedTitle": "Letzte Suchanfragen",
  "header.searchResultsTitle": "Suchergebnisse",
  "header.allResultsTitle": "Ergebnisse für {0} werden angezeigt",
  "header.artistsResultsTitle": "Künstler für {0}",
  "header.albumsResultsTitle": "Alben für {0}",
  "header.tracksResultsTitle": "Songs für {0}",
  "header.playlistsResultsTitle": "Playlists für {0}",
  "header.profilesResultsTitle": "Profile für {0}",
  "header.genresResultsTitle": "Genres für {0}",
  "header.showsResultsTitle": "Podcasts und Videos für {0}",
  "header.videoepisodesResultsTitle": "Videofolgen für {0}",
  "recentlySearched.removeFromRecentlySearched": "Aus „Letzte Suchanfragen“ entfernen",
  "recentlySearched.clearRecentSearches": "Letzte Suchanfragen löschen",
  "emptyView.searchSpotify": "Suche in Spotify",
  "emptyView.findYourMusic": "Finde deine Lieblingssongs, -künstler, -alben, -videos, -freunde, -Podcasts und -Playlists.",
  "emptyView.noResults": "Keine Suchergebnisse für „{0}“",
  "emptyView.noResultsText": "Bitte achte darauf, dass du alle Wörter richtig geschrieben hast, oder versuch es mit weniger oder anderen Suchbegriffen.",
  "emptyView.errorTitle": "Irgendwas ist schiefgelaufen.",
  "emptyView.errorText": "Bitte versuch es später noch mal.",
  "emptyView.offlineTitle": "Keine Offline-Ergebnisse für \"{0}\"",
  "emptyView.offlineText": "Geh online, um Millionen von Songs zu durchsuchen.",
  "emptyView.spotifyOffline": "Spotify ist offline",
  "emptyView.offlineResultsText": "Spotify ist momentan offline. Du kannst daher gerade nur auf deine lokalen Dateien zugreifen. Geh online, um deine gesamte Bibliothek zu sehen.",
  "facebookFriend": "Facebook-Freund",
  "following": "Folge ich",
  "followers": {
    "one": "1 Follower",
    "few": "{0} Follower",
    "other": "{0} Follower"
  },
  "topHit": "Top-Ergebnis",
  "topRecommendations": "Featuring {0}",
  "artists": "Künstler",
  "tracks": "Songs",
  "playlists": "Playlists",
  "albums": "Alben",
  "genres": "Genres",
  "profiles": "Profile",
  "shows": "Podcasts & Video Shows",
  "videoepisodes": "Videofolgen",
  "localFiles": "Lokale Dateien",
  "see_all": "Alle ansehen",
  "artist": "Künstler",
  "track": "Song",
  "playlist": "Playlist",
  "album": "Album",
  "genre": "Genre",
  "profile": "Profil",
  "audio": "Podcast",
  "video": "Video",
  "episode": "Videofolge",
  "see_all_tracks": "Alle Songs anzeigen",
  "see_all_artists": "Alle Künstler anzeigen",
  "see_all_albums": "Alle Alben anzeigen",
  "see_all_playlists": "Alle Playlists anzeigen",
  "see_all_profiles": "Alle Profile anzeigen",
  "see_all_genres": "Alle Genres anzeigen",
  "see_all_shows": "Alle Podcasts & Video Shows anzeigen",
  "see_all_videoepisodes": "Alle Videofolgen anzeigen"
}
},{}],4:[function(require,module,exports){
module.exports={
  "app.name": "Neo Search",
  "app.description": "",
  "app.offlineTitle": "Η αναζήτηση δεν είναι διαθέσιμη εκτός σύνδεσης.",
  "app.offlineMessage": "Συνδέσου στο διαδίκτυο για να πραγματοποιηθεί φόρτωση.",
  "app.errorTitle": "Σφάλμα",
  "app.errorMessage": "Η φόρτωση απέτυχε.",
  "header.recentlySearchedTitle": "Πρόσφατες αναζητήσεις",
  "header.searchResultsTitle": "Αποτελέσματα αναζήτησης",
  "header.allResultsTitle": "Εμφανίζονται αποτελέσματα για {0}",
  "header.artistsResultsTitle": "Εμφανίζονται καλλιτέχνες για {0}",
  "header.albumsResultsTitle": "Εμφανίζονται άλμπουμ για {0}",
  "header.tracksResultsTitle": "Εμφανίζονται τραγούδια για {0}",
  "header.playlistsResultsTitle": "Εμφανίζονται playlist για {0}",
  "header.profilesResultsTitle": "Εμφανίζονται προφίλ για {0}",
  "header.genresResultsTitle": "Εμφανίζονται είδη για {0}",
  "header.showsResultsTitle": "Εμφανίζονται podcast και βίντεο για {0}",
  "header.videoepisodesResultsTitle": "Εμφανίζονται επεισόδια βίντεο για {0}",
  "recentlySearched.removeFromRecentlySearched": "Κατάργηση από τις Πρόσφατες Αναζητήσεις",
  "recentlySearched.clearRecentSearches": "Απαλοιφή πρόσφατων αναζητήσεων",
  "emptyView.searchSpotify": "Αναζήτηση στο Spotify",
  "emptyView.findYourMusic": "Βρες τα αγαπημένα σου τραγούδια, καλλιτέχνες, άλμπουμ, podcast και βίντεο, playlist και φίλους.",
  "emptyView.noResults": "Δεν βρέθηκαν αποτελέσματα για \"{0}\"",
  "emptyView.noResultsText": "Βεβαιώσου ότι έχεις γράψει σωστά τις λέξεις ή χρησιμοποίησε λιγότερες ή διαφορετικές λέξεις-κλειδιά.",
  "emptyView.errorTitle": "Κάτι δεν πήγε καλά",
  "emptyView.errorText": "Δοκίμασε ξανά αργότερα.",
  "emptyView.offlineTitle": "Δεν βρέθηκαν αποτελέσματα εκτός σύνδεσης για «{0}»",
  "emptyView.offlineText": "Συνδέσου στο διαδίκτυο για να αναζητήσεις εκατομμύρια τραγούδια.",
  "emptyView.spotifyOffline": "Spotify εκτός σύνδεσης",
  "emptyView.offlineResultsText": "Προς το παρόν το Spotify είναι εκτός σύνδεσης με πρόσβαση μόνο στα τοπικά σου αρχεία. Συνδέσου online για να δεις όλη τη Βιβλιοθήκη.",
  "facebookFriend": "Φίλος/η από το Facebook",
  "following": "Aκολουθείται",
  "followers": {
    "one": "1 ακόλουθος",
    "few": "{0} ακόλουθοι",
    "other": "{0} ακόλουθοι"
  },
  "topHit": "Κορυφαίο αποτέλεσμα",
  "topRecommendations": "Περιλαμβάνει: {0}",
  "artists": "Καλλιτέχνες",
  "tracks": "Τραγούδια",
  "playlists": "Λίστες",
  "albums": "Άλμπουμ",
  "genres": "Μουσικά είδη",
  "profiles": "Προφίλ",
  "shows": "Podcast και βίντεο",
  "videoepisodes": "Επεισόδια βίντεο",
  "localFiles": "Τοπικά αρχεία",
  "see_all": "Δες τα όλα",
  "artist": "Καλλιτέχνης",
  "track": "Τραγούδι",
  "playlist": "Λίστα",
  "album": "Άλμπουμ",
  "genre": "Είδος",
  "profile": "Προφίλ",
  "audio": "Podcast",
  "video": "Βίντεο",
  "episode": "Επεισόδιο βίντεο",
  "see_all_tracks": "Δες όλα τα τραγούδια",
  "see_all_artists": "Δες όλους τους καλλιτέχνες",
  "see_all_albums": "Εμφάνιση όλων των άλμπουμ",
  "see_all_playlists": "Δες όλες τις λίστες",
  "see_all_profiles": "Δες όλα τα προφίλ",
  "see_all_genres": "Δες όλα τα είδη",
  "see_all_shows": "Δες όλα τα podcast και τα βίντεο",
  "see_all_videoepisodes": "Δες όλα τα επεισόδια βίντεο"
}
},{}],5:[function(require,module,exports){
module.exports={
  "app.name": "Neo Search",
  "app.description": "",
  "app.offlineTitle": "Search is not available offline.",
  "app.offlineMessage": "Please go online to load.",
  "app.errorTitle": "Error",
  "app.errorMessage": "Failed to load.",
  "header.recentlySearchedTitle": "Recent Searches",
  "header.searchResultsTitle": "Search Results",
  "header.allResultsTitle": "Showing results for {0}",
  "header.artistsResultsTitle": "Showing Artists for {0}",
  "header.albumsResultsTitle": "Showing Albums for {0}",
  "header.tracksResultsTitle": "Showing Songs for {0}",
  "header.playlistsResultsTitle": "Showing Playlists for {0}",
  "header.profilesResultsTitle": "Showing Profiles for {0}",
  "header.genresResultsTitle": "Showing Genres for {0}",
  "header.showsResultsTitle": "Showing Podcasts & Videos for {0}",
  "header.videoepisodesResultsTitle": "Showing Video Episodes for {0}",
  "recentlySearched.removeFromRecentlySearched": "Remove from Recent Searches",
  "recentlySearched.clearRecentSearches": "Clear Recent Searches",
  "emptyView.searchSpotify": "Search Spotify",
  "emptyView.findYourMusic": "Find your favorite songs, artists, albums, podcasts & videos, playlists and friends.",
  "emptyView.noResults": "No results found for \"{0}\"",
  "emptyView.noResultsText": "Please make sure your words are spelled correctly or use less or different keywords.",
  "emptyView.errorTitle": "Something went wrong",
  "emptyView.errorText": "Please try again later.",
  "emptyView.offlineTitle": "No offline results found for \"{0}\"",
  "emptyView.offlineText": "Go online to search millions of songs.",
  "emptyView.spotifyOffline": "Spotify Offline",
  "emptyView.offlineResultsText": "Spotify is currently offline with access to only your Local files. Go online to see all of our Library.",
  "facebookFriend": "Facebook friend",
  "following": "Following",
  "followers": {
    "one": "1 Follower",
    "few": "{0} Followers",
    "other": "{0} Followers"
  },
  "topHit": "Top Result",
  "topRecommendations": "Featuring {0}",
  "artists": "Artists",
  "tracks": "Songs",
  "playlists": "Playlists",
  "albums": "Albums",
  "genres": "Genres",
  "profiles": "Profiles",
  "shows": "Podcasts & Videos",
  "videoepisodes": "Video Episodes",
  "localFiles": "Local Files",
  "see_all": "See All",
  "artist": "Artist",
  "track": "Song",
  "playlist": "Playlist",
  "album": "Album",
  "genre": "Genre",
  "profile": "Profile",
  "audio": "Podcast",
  "video": "Video",
  "episode": "Video Episode",
  "see_all_tracks": "See all songs",
  "see_all_artists": "See all artists",
  "see_all_albums": "See all albums",
  "see_all_playlists": "See all playlists",
  "see_all_profiles": "See all profiles",
  "see_all_genres": "See all genres",
  "see_all_shows": "See all podcasts and videos",
  "see_all_videoepisodes": "See all video episodes"
}
},{}],6:[function(require,module,exports){
module.exports={
  "app.name": "Neo Search",
  "app.description": "",
  "app.offlineTitle": "La función Buscar no está disponible sin conexión.",
  "app.offlineMessage": "Conéctate a la red para cargar.",
  "app.errorTitle": "Error",
  "app.errorMessage": "No se pudo cargar.",
  "header.recentlySearchedTitle": "Búsquedas recientes",
  "header.searchResultsTitle": "Resultados de búsqueda",
  "header.allResultsTitle": "Mostrando resultados para {0}",
  "header.artistsResultsTitle": "Mostrando artistas para {0}",
  "header.albumsResultsTitle": "Mostrando álbumes para {0}",
  "header.tracksResultsTitle": "Mostrando canciones para {0}",
  "header.playlistsResultsTitle": "Mostrando playlists para {0}",
  "header.profilesResultsTitle": "Mostrando perfiles para {0}",
  "header.genresResultsTitle": "Mostrando géneros para {0}",
  "header.showsResultsTitle": "Mostrando Podcasts y videos para {0}",
  "header.videoepisodesResultsTitle": "Mostrando episodios de video para {0}",
  "recentlySearched.removeFromRecentlySearched": "Eliminar de búsquedas recientes",
  "recentlySearched.clearRecentSearches": "Eliminar búsquedas recientes",
  "emptyView.searchSpotify": "Busca en Spotify",
  "emptyView.findYourMusic": "Encuentra a tus amigos, tus canciones, artistas, álbumes, playlists, podcasts y videos favoritos.",
  "emptyView.noResults": "No se han encontrado resultados para \"{0}\"",
  "emptyView.noResultsText": "Asegúrate de escribir correctamente las palabras y utiliza menos o distintas palabras clave.",
  "emptyView.errorTitle": "Algo salió mal",
  "emptyView.errorText": "Inténtalo de nuevo más adelante.",
  "emptyView.offlineTitle": "No se han encontrado resultados sin conexión para \"{0}\"",
  "emptyView.offlineText": "Conéctate para buscar millones de canciones.",
  "emptyView.spotifyOffline": "Spotify no tiene conexión",
  "emptyView.offlineResultsText": "Por el momento, Spotify no tiene conexión y solo tiene acceso a tus archivos locales. Conéctate para ver toda nuestra Biblioteca.",
  "facebookFriend": "Amigo de Facebook",
  "following": "Siguiendo",
  "followers": {
    "one": "1 seguidor",
    "few": "{0} seguidores",
    "other": "{0} seguidores"
  },
  "topHit": "Mejor resultado",
  "topRecommendations": "Con {0}",
  "artists": "Artistas",
  "tracks": "Canciones",
  "playlists": "Playlists",
  "albums": "Álbumes",
  "genres": "Géneros",
  "profiles": "Perfiles",
  "shows": "Podcasts y videos",
  "videoepisodes": "Episodios de video",
  "localFiles": "Archivos Locales",
  "see_all": "Ver todas",
  "artist": "Artista",
  "track": "Canción",
  "playlist": "Lista",
  "album": "Álbum",
  "genre": "Género",
  "profile": "Perfil",
  "audio": "Podcast",
  "video": "Video",
  "episode": "Episodio de video",
  "see_all_tracks": "Ver todas las canciones",
  "see_all_artists": "Ver todos los artistas",
  "see_all_albums": "Ver todos los álbumes",
  "see_all_playlists": "Ver todas las playlists",
  "see_all_profiles": "Ver todos los perfiles",
  "see_all_genres": "Ver todos los géneros",
  "see_all_shows": "Ver todos los podcasts y videos",
  "see_all_videoepisodes": "Ver todos los episodios de video"
}
},{}],7:[function(require,module,exports){
module.exports={
  "app.name": "Neo Search",
  "app.description": "",
  "app.offlineTitle": "La búsqueda no está disponible sin conexión.",
  "app.offlineMessage": "Por favor, conéctate para cargar.",
  "app.errorTitle": "Error",
  "app.errorMessage": "No se ha logrado cargar.",
  "header.recentlySearchedTitle": "Búsquedas recientes",
  "header.searchResultsTitle": "Resultados de la búsqueda",
  "header.allResultsTitle": "Mostrando resultados para {0}",
  "header.artistsResultsTitle": "Mostrando artistas para {0}",
  "header.albumsResultsTitle": "Mostrando álbumes para {0}",
  "header.tracksResultsTitle": "Mostrando canciones para {0}",
  "header.playlistsResultsTitle": "Mostrando playlists para {0}",
  "header.profilesResultsTitle": "Mostrando perfiles para {0}",
  "header.genresResultsTitle": "Mostrando géneros para {0}",
  "header.showsResultsTitle": "Mostrando podcasts y vídeos para {0}",
  "header.videoepisodesResultsTitle": "Mostrando episodios en vídeo para {0}",
  "recentlySearched.removeFromRecentlySearched": "Retirar de Búsquedas recientes",
  "recentlySearched.clearRecentSearches": "Eliminar búsquedas recientes",
  "emptyView.searchSpotify": "Buscar en Spotify",
  "emptyView.findYourMusic": "Encuentra tus canciones, álbumes, artistas, amigos, playlists, podcasts y vídeos favoritos.",
  "emptyView.noResults": "No se ha encontrado ningún resultado para \"{0}\"",
  "emptyView.noResultsText": "Asegúrate de que las palabras estén correctamente escritas o prueba con menos palabras o con otras distintas.",
  "emptyView.errorTitle": "Algo no ha ido como debía",
  "emptyView.errorText": "Prueba de nuevo más tarde.",
  "emptyView.offlineTitle": "No se ha encontrado ningún resultado sin conexión para \"{0}\"",
  "emptyView.offlineText": "Conéctate a Internet para buscar entre millones de canciones.",
  "emptyView.spotifyOffline": "Spotify sin conexión",
  "emptyView.offlineResultsText": "Actualmente Spotify está en modo sin conexión, con acceso sólo a tus archivos locales. Si quieres ver toda tu biblioteca, conéctate a Internet.",
  "facebookFriend": "Amigo de Facebook",
  "following": "Siguiendo",
  "followers": {
    "one": "1 seguidor",
    "few": "{0} seguidores",
    "other": "{0} seguidores"
  },
  "topHit": "Resultado principal",
  "topRecommendations": "Incluye a {0}",
  "artists": "Artistas",
  "tracks": "Canciones",
  "playlists": "Playlists",
  "albums": "Álbumes",
  "genres": "Géneros",
  "profiles": "Perfiles",
  "shows": "Podcasts y vídeos",
  "videoepisodes": "Episodios en vídeo",
  "localFiles": "Archivos Locales",
  "see_all": "Ver todas",
  "artist": "Artista",
  "track": "Canción",
  "playlist": "Lista",
  "album": "Álbum",
  "genre": "Género",
  "profile": "Perfil",
  "audio": "Podcast",
  "video": "Vídeo",
  "episode": "Episodio en vídeo",
  "see_all_tracks": "Ver todas las canciones",
  "see_all_artists": "Ver todos los artistas",
  "see_all_albums": "Ver todos los álbumes",
  "see_all_playlists": "Ver todas las playlists",
  "see_all_profiles": "Ver todos los perfiles",
  "see_all_genres": "Ver todos los géneros",
  "see_all_shows": "Ver todos los podcasts y vídeos",
  "see_all_videoepisodes": "Ver todos los episodios en vídeo"
}
},{}],8:[function(require,module,exports){
module.exports={
  "app.name": "Neo Search",
  "app.description": "",
  "app.offlineTitle": "Hakua ei voi käyttää offline-tilassa.",
  "app.offlineMessage": "Siirry online-tilaan, jotta voit ladata.",
  "app.errorTitle": "Virhe",
  "app.errorMessage": "Lataus epäonnistui.",
  "header.recentlySearchedTitle": "Viimeisimmät haut",
  "header.searchResultsTitle": "Hakutulokset",
  "header.allResultsTitle": "Näytetään tulokset haulle {0}",
  "header.artistsResultsTitle": "Näytetään artistit haulle {0}",
  "header.albumsResultsTitle": "Näytetään albumit haulle {0}",
  "header.tracksResultsTitle": "Näytetään kappaleet haulle {0}",
  "header.playlistsResultsTitle": "Näytetään soittolistat haulle {0}",
  "header.profilesResultsTitle": "Näytetään profiilit haulle {0}",
  "header.genresResultsTitle": "Näytetään genret haulle {0}",
  "header.showsResultsTitle": "Näytetään podcastit ja videot haulle {0}",
  "header.videoepisodesResultsTitle": "Näytetään videojaksot haulle {0}",
  "recentlySearched.removeFromRecentlySearched": "Poista viimeisimmistä hauista",
  "recentlySearched.clearRecentSearches": "Tyhjennä viimeisimmät haut",
  "emptyView.searchSpotify": "Hae Spotifysta",
  "emptyView.findYourMusic": "Löydä haluamasi kappaleet, artistit, albumit, podcastit ja videot, soittolistat ja kaverit.",
  "emptyView.noResults": "Ei tuloksia haulle \"{0}\"",
  "emptyView.noResultsText": "Tarkista, että kirjoitit sanat oikein, tai käytä vähemmän tai erilaisia avainsanoja.",
  "emptyView.errorTitle": "Jotain meni vikaan",
  "emptyView.errorText": "Yritä myöhemmin uudelleen.",
  "emptyView.offlineTitle": "Ei offline-tuloksia haulle {0}",
  "emptyView.offlineText": "Siirry online-tilaan, jotta voit hakea miljoonista kappaleista.",
  "emptyView.spotifyOffline": "Spotify on offline-tilassa",
  "emptyView.offlineResultsText": "Spotify on tällä hetkellä offline-tilassa, ja vain paikalliset tiedostot ovat saatavilla. Näet koko kirjastosi, kun siirryt online-tilaan.",
  "facebookFriend": "Facebook-kaveri",
  "following": "Seurataan",
  "followers": {
    "one": "1 seuraaja",
    "few": "{0} seuraajaa",
    "other": "{0} seuraajaa"
  },
  "topHit": "Paras tulos",
  "topRecommendations": "Listalla soi {0}",
  "artists": "Artistit",
  "tracks": "Kappaleet",
  "playlists": "Soittolistat",
  "albums": "Albumit",
  "genres": "Lajit",
  "profiles": "Profiilit",
  "shows": "Podcastit ja videot",
  "videoepisodes": "Videon jaksot",
  "localFiles": "Paikalliset tiedostot",
  "see_all": "Näytä kaikki",
  "artist": "Artisti",
  "track": "Kappale",
  "playlist": "Soittolista",
  "album": "Albumi",
  "genre": "Genre",
  "profile": "Profiili",
  "audio": "Podcast",
  "video": "Video",
  "episode": "Videojakso",
  "see_all_tracks": "Näytä kaikki kappaleet",
  "see_all_artists": "Näytä kaikki artistit",
  "see_all_albums": "Näytä kaikki albumit",
  "see_all_playlists": "Näytä kaikki soittolistat",
  "see_all_profiles": "Näytä kaikki profiilit",
  "see_all_genres": "Näytä kaikki genret",
  "see_all_shows": "Näytä kaikki podcastit ja videot",
  "see_all_videoepisodes": "Näytä kaikki videojaksot"
}
},{}],9:[function(require,module,exports){
module.exports={
  "app.name": "Neo Search",
  "app.description": "",
  "app.offlineTitle": "La recherche est indisponible hors connexion.",
  "app.offlineMessage": "Veuillez accéder à Internet pour charger le contenu.",
  "app.errorTitle": "Erreur",
  "app.errorMessage": "Le chargement a échoué.",
  "header.recentlySearchedTitle": "Recherches récentes",
  "header.searchResultsTitle": "Résultats de recherche",
  "header.allResultsTitle": "Affichage des résultats pour {0}",
  "header.artistsResultsTitle": "Affichage des artistes correspondant à {0}",
  "header.albumsResultsTitle": "Affichage des albums correspondant à {0}",
  "header.tracksResultsTitle": "Affichage des chansons correspondant à {0}",
  "header.playlistsResultsTitle": "Affichage des listes de lectures correspondant à {0}",
  "header.profilesResultsTitle": "Affichage des profils correspondant à {0}",
  "header.genresResultsTitle": "Affichage des genres correspondant à {0}",
  "header.showsResultsTitle": "Affichage des balados et des vidéos correspondant à {0}",
  "header.videoepisodesResultsTitle": "Affichage des épisodes vidéo correspondant à {0}",
  "recentlySearched.removeFromRecentlySearched": "Supprimer des recherches récentes",
  "recentlySearched.clearRecentSearches": "Effacer les recherches récentes",
  "emptyView.searchSpotify": "Rechercher dans Spotify",
  "emptyView.findYourMusic": "Trouvez vos chansons, artistes, albums, balados, vidéos, listes de lecture et amis préférés.",
  "emptyView.noResults": "Aucun résultat pour « {0} »",
  "emptyView.noResultsText": "Veuillez vérifier l'orthographe, utiliser moins de mots-clés ou utiliser d'autres mots-clés.",
  "emptyView.errorTitle": "Une erreur s'est produite",
  "emptyView.errorText": "Réessayez plus tard.",
  "emptyView.offlineTitle": "Aucun résultat trouvé hors ligne pour « {0} »",
  "emptyView.offlineText": "Connectez-vous pour accéder à des millions de titres.",
  "emptyView.spotifyOffline": "Spotify hors ligne",
  "emptyView.offlineResultsText": "Spotify est actuellement hors ligne, vous n'avez donc accès qu'à vos fichiers locaux. Accédez à Internez pour voir l’ensemble de notre Bibliothèque.",
  "facebookFriend": "Ami Facebook",
  "following": "Suivis",
  "followers": {
    "one": "1 abonné",
    "few": "{0} abonnés",
    "other": "{0} abonnés"
  },
  "topHit": "Top hit",
  "topRecommendations": "Mettant en vedette {0}",
  "artists": "Artistes",
  "tracks": "Titres",
  "playlists": "Playlists",
  "albums": "Albums",
  "genres": "Genres",
  "profiles": "Profils",
  "shows": "Balados et vidéos",
  "videoepisodes": "Épisodes vidéo",
  "localFiles": "Fichiers locaux",
  "see_all": "Voir tout",
  "artist": "Artiste",
  "track": "Titre",
  "playlist": "Playlist",
  "album": "Album",
  "genre": "Genre",
  "profile": "Profil",
  "audio": "Balado",
  "video": "Vidéo",
  "episode": "Épisode vidéo",
  "see_all_tracks": "Voir toutes les chansons",
  "see_all_artists": "Voir tous les artistes",
  "see_all_albums": "Voir tous les albums",
  "see_all_playlists": "Voir toutes les listes de lecture",
  "see_all_profiles": "Voir tous les profils",
  "see_all_genres": "Afficher tous les genres",
  "see_all_shows": "Afficher tous les balados et toutes les vidéos",
  "see_all_videoepisodes": "Afficher tous les épisodes vidéo"
}
},{}],10:[function(require,module,exports){
module.exports={
  "app.name": "Neo Search",
  "app.description": "",
  "app.offlineTitle": "La recherche n'est pas disponible hors connexion.",
  "app.offlineMessage": "Connectez-vous pour procéder au chargement.",
  "app.errorTitle": "Erreur",
  "app.errorMessage": "Échec du chargement.",
  "header.recentlySearchedTitle": "Recherches récentes",
  "header.searchResultsTitle": "Résultats de la recherche",
  "header.allResultsTitle": "Résultats correspondant à {0}",
  "header.artistsResultsTitle": "Afficher les artistes contenant le(s) terme(s) {0}",
  "header.albumsResultsTitle": "Afficher les albums contenant le(s) terme(s) {0}",
  "header.tracksResultsTitle": "Afficher les titres contenant le(s) terme(s) {0}",
  "header.playlistsResultsTitle": "Afficher les playlists contenant le(s) terme(s) {0}",
  "header.profilesResultsTitle": "Afficher les profils contenant le(s) terme(s) {0}",
  "header.genresResultsTitle": "Afficher les genres contenant le(s) terme(s) {0}",
  "header.showsResultsTitle": "Afficher les podcasts et les vidéos contenant le(s) terme(s) {0}",
  "header.videoepisodesResultsTitle": "Afficher les épisodes vidéo contenant le(s) terme(s) {0}",
  "recentlySearched.removeFromRecentlySearched": "Supprimer des recherches récentes",
  "recentlySearched.clearRecentSearches": "Effacer les recherches récentes",
  "emptyView.searchSpotify": "Rechercher dans Spotify",
  "emptyView.findYourMusic": "Retrouvez vos titres, artistes, albums, podcasts, vidéos et playlists préférés, ainsi que vos amis.",
  "emptyView.noResults": "Aucun résultat pour « {0} »",
  "emptyView.noResultsText": "Veillez à orthographier les mots correctement ou à utiliser moins de mots clés ou des mots clés différents.",
  "emptyView.errorTitle": "Une erreur s'est produite.",
  "emptyView.errorText": "Merci de réessayer plus tard.",
  "emptyView.offlineTitle": "Aucun résultat hors connexion contenant le(s) terme(s) {0}",
  "emptyView.offlineText": "Connectez-vous pour rechercher parmi des millions de titres.",
  "emptyView.spotifyOffline": "Spotify déconnecté",
  "emptyView.offlineResultsText": "Spotify est actuellement déconnecté, et vous avez uniquement accès à vos fichiers locaux. Accédez à Internet pour voir toute votre Bibliothèque.",
  "facebookFriend": "Ami Facebook",
  "following": "Abonné",
  "followers": {
    "one": "1 abonné",
    "few": "{0} abonnés",
    "other": "{0} abonnés"
  },
  "topHit": "Meilleur résultat",
  "topRecommendations": "Avec {0}",
  "artists": "Artistes",
  "tracks": "Titres",
  "playlists": "Playlists",
  "albums": "Albums",
  "genres": "Genres",
  "profiles": "Profils",
  "shows": "Podcasts et vidéos",
  "videoepisodes": "Épisodes vidéo",
  "localFiles": "Fichiers locaux",
  "see_all": "Voir tout",
  "artist": "Artiste",
  "track": "Titre",
  "playlist": "Playlist",
  "album": "Album",
  "genre": "Genre",
  "profile": "Profil",
  "audio": "Podcast",
  "video": "Vidéo",
  "episode": "Épisode vidéo",
  "see_all_tracks": "Voir tous les titres",
  "see_all_artists": "Voir tous les artistes",
  "see_all_albums": "Voir tous les albums",
  "see_all_playlists": "Voir toutes les playlists",
  "see_all_profiles": "Voir tous les profils",
  "see_all_genres": "Voir tous les genres",
  "see_all_shows": "Voir l'ensemble des podcasts et vidéos",
  "see_all_videoepisodes": "Voir tous les épisodes vidéo"
}
},{}],11:[function(require,module,exports){
module.exports={
  "app.name": "Neo Search",
  "app.description": "",
  "app.offlineTitle": "A keresés nem érhető el offline módban.",
  "app.offlineMessage": "Csatlakozz az internethez, majd indítsd el.",
  "app.errorTitle": "Hiba",
  "app.errorMessage": "Betöltési hiba.",
  "header.recentlySearchedTitle": "Legutóbbi keresések",
  "header.searchResultsTitle": "Találatok",
  "header.allResultsTitle": "Találatok ehhez: {0}",
  "header.artistsResultsTitle": "Előadók ehhez: {0}",
  "header.albumsResultsTitle": "Albumok ehhez: {0}",
  "header.tracksResultsTitle": "Dalok ehhez: {0}",
  "header.playlistsResultsTitle": "Műsorlisták ehhez: {0}",
  "header.profilesResultsTitle": "Profilok ehhez: {0}",
  "header.genresResultsTitle": "Műfajok ehhez: {0}",
  "header.showsResultsTitle": "Podcastok és videók ehhez: {0}",
  "header.videoepisodesResultsTitle": "Videoepizódok a következőhöz: {0}",
  "recentlySearched.removeFromRecentlySearched": "Törlés a legutóbbi keresések közül",
  "recentlySearched.clearRecentSearches": "Legutóbbi keresések törlése",
  "emptyView.searchSpotify": "Keresés a Spotifyon",
  "emptyView.findYourMusic": "Keresd meg kedvenc dalaidat, előadóidat, albumaidat, podcastjaidat és videóidat, műsorlistáidat vagy az ismerőseidet.",
  "emptyView.noResults": "Nincs találat erre: „{0}”",
  "emptyView.noResultsText": "Ellenőrizd, hogy nem gépeltél-e el valamit, esetleg próbálkozz más vagy kevesebb szóból álló kifejezéssel.",
  "emptyView.errorTitle": "Műszaki hiba",
  "emptyView.errorText": "Próbálkozz újra később.",
  "emptyView.offlineTitle": "Nincs offline találat ehhez: „{0}”",
  "emptyView.offlineText": "Az internethez csatlakozva zeneszámok milliói között kereshetsz.",
  "emptyView.spotifyOffline": "Spotify offline",
  "emptyView.offlineResultsText": "A Spotify jelenleg offline módban van, és csak a helyi fájlok érhetők el. A Gyűjteményed teljes tartalmához csatlakozz az internethez.",
  "facebookFriend": "Facebookos ismerős",
  "following": "Követések",
  "followers": {
    "one": "1 követő",
    "few": "{0} követő",
    "other": "{0} követő"
  },
  "topHit": "Legnépszerűbb eredmény",
  "topRecommendations": "{0} a reflektorfényben",
  "artists": "Előadók",
  "tracks": "Dalok",
  "playlists": "Lejátszási listák",
  "albums": "Albumok",
  "genres": "Műfajok",
  "profiles": "Profilok",
  "shows": "Podcastok és videók",
  "videoepisodes": "Videoepizódok",
  "localFiles": "Helyi fájlok",
  "see_all": "Mind",
  "artist": "Előadó",
  "track": "Dal",
  "playlist": "Lejátszási lista",
  "album": "Album",
  "genre": "Műfaj",
  "profile": "Profil",
  "audio": "Podcast",
  "video": "Videó",
  "episode": "Videoepizód",
  "see_all_tracks": "Minden szám",
  "see_all_artists": "Minden előadó",
  "see_all_albums": "Az összes album megtekintése",
  "see_all_playlists": "Minden lejátszási lista",
  "see_all_profiles": "Minden profil",
  "see_all_genres": "Minden műfaj",
  "see_all_shows": "Minden podcast és videó",
  "see_all_videoepisodes": "Összes videoepizód"
}
},{}],12:[function(require,module,exports){
module.exports={
  "app.name": "Neo Search",
  "app.description": "",
  "app.offlineTitle": "Pencarian tidak tersedia secara offline. ",
  "app.offlineMessage": "Alihkan ke online untuk memuat.",
  "app.errorTitle": "Kesalahan",
  "app.errorMessage": "Gagal memuat.",
  "header.recentlySearchedTitle": "Pencarian Terkini",
  "header.searchResultsTitle": "Hasil Pencarian",
  "header.allResultsTitle": "Menampilkan hasil untuk {0}",
  "header.artistsResultsTitle": "Menampilkan Artis untuk {0}",
  "header.albumsResultsTitle": "Menampilkan Album untuk {0}",
  "header.tracksResultsTitle": "Menampilkan Lagu untuk {0}",
  "header.playlistsResultsTitle": "Menampilkan Playlist untuk {0}",
  "header.profilesResultsTitle": "Menampilkan Profil untuk {0}",
  "header.genresResultsTitle": "Menampilkan Genre untuk {0}",
  "header.showsResultsTitle": "Menampilkan Podcast & Video untuk {0}",
  "header.videoepisodesResultsTitle": "Menampilkan Episode Video untuk {0}",
  "recentlySearched.removeFromRecentlySearched": "Hapus dari Pencarian Terkini",
  "recentlySearched.clearRecentSearches": "Hapus Pencarian Terkini",
  "emptyView.searchSpotify": "Cari Spotify",
  "emptyView.findYourMusic": "Temukan lagu, artis, album, podcast & video, playlist, dan teman favoritmu.",
  "emptyView.noResults": "Tidak ditemukan hasil untuk \"{0}\"",
  "emptyView.noResultsText": "Pastikan bahwa kata yang dimasukkan sudah benar, atau menggunakan kata kunci yang lebih sedikit atau berbeda.",
  "emptyView.errorTitle": "Ada yang salah",
  "emptyView.errorText": "Coba lagi nanti.",
  "emptyView.offlineTitle": "Tidak ditemukan hasil offline untuk \"{0}\"",
  "emptyView.offlineText": "Alihkan online untuk mencari jutaan lagu.",
  "emptyView.spotifyOffline": "Spotify Offline",
  "emptyView.offlineResultsText": "Spotify saat ini offline dengan akses hanya ke file Lokalmu. Alihkan ke online untuk melihat seluruh Koleksi kami.",
  "facebookFriend": "Teman Facebook",
  "following": "Mengikuti",
  "followers": {
    "one": "1 Pengikut",
    "few": "{0} Pengikut",
    "other": "{0} Pengikut"
  },
  "topHit": "Hasil Teratas",
  "topRecommendations": "Menampilkan {0}",
  "artists": "Artis",
  "tracks": "Lagu",
  "playlists": "Playlist",
  "albums": "Album",
  "genres": "Genre",
  "profiles": "Profil",
  "shows": "Podcast & Video",
  "videoepisodes": "Episode Video",
  "localFiles": "File Lokal",
  "see_all": "Lihat Semua",
  "artist": "Artis",
  "track": "Lagu",
  "playlist": "Playlist",
  "album": "Album",
  "genre": "Aliran",
  "profile": "Profil",
  "audio": "Podcast",
  "video": "Video",
  "episode": "Episode Video",
  "see_all_tracks": "Lihat semua lagu",
  "see_all_artists": "Lihat semua artis",
  "see_all_albums": "Lihat semua album",
  "see_all_playlists": "Lihat semua playlist",
  "see_all_profiles": "Lihat semua profil",
  "see_all_genres": "Lihat semua genre",
  "see_all_shows": "Lihat semua podcast dan video",
  "see_all_videoepisodes": "Lihat semua episode video"
}
},{}],13:[function(require,module,exports){
module.exports={
  "app.name": "Neo Search",
  "app.description": "",
  "app.offlineTitle": "La ricerca non è disponibile offline.",
  "app.offlineMessage": "Passa online per caricare.",
  "app.errorTitle": "Errore",
  "app.errorMessage": "Impossibile caricare.",
  "header.recentlySearchedTitle": "Ricerche recenti",
  "header.searchResultsTitle": "Risultati della ricerca",
  "header.allResultsTitle": "Visualizzazione risultati per {0}",
  "header.artistsResultsTitle": "Visualizzazione artisti per {0}",
  "header.albumsResultsTitle": "Visualizzazione album per {0}",
  "header.tracksResultsTitle": "Visualizzazione brani per {0}",
  "header.playlistsResultsTitle": "Visualizzazione playlist per {0}",
  "header.profilesResultsTitle": "Visualizzazione profili per {0}",
  "header.genresResultsTitle": "Visualizzazione generi per {0}",
  "header.showsResultsTitle": "Visualizzazione podcast e video per {0}",
  "header.videoepisodesResultsTitle": "Visualizzazione episodi video per {0}",
  "recentlySearched.removeFromRecentlySearched": "Rimuovi da Ricerche recenti",
  "recentlySearched.clearRecentSearches": "Cancella ricerche recenti",
  "emptyView.searchSpotify": "Cerca in Spotify",
  "emptyView.findYourMusic": "Trova i tuoi preferiti tra brani, artisti, album, podcast, video, playlist e amici.",
  "emptyView.noResults": "Nessun risultato trovato per \"{0}\"",
  "emptyView.noResultsText": "Controlla di aver digitato tutte le parole correttamente o usa meno parole chiave o parole diverse.",
  "emptyView.errorTitle": "Si è verificato un problema",
  "emptyView.errorText": "Riprova in un altro momento.",
  "emptyView.offlineTitle": "Nessun risultato offline trovato per \"{0}\"",
  "emptyView.offlineText": "Passa online per cercare milioni di brani.",
  "emptyView.spotifyOffline": "Spotify offline",
  "emptyView.offlineResultsText": "Spotify al momento è offline, puoi quindi accedere solo ai file locali. Per consultare l'intera libreria, passa online.",
  "facebookFriend": "Amico su Facebook",
  "following": "Following",
  "followers": {
    "one": "1 follower",
    "few": "{0} follower",
    "other": "{0} follower"
  },
  "topHit": "Risultato migliore",
  "topRecommendations": "In collaborazione con {0}",
  "artists": "Artisti",
  "tracks": "Brani",
  "playlists": "Playlist",
  "albums": "Album",
  "genres": "Generi",
  "profiles": "Profili",
  "shows": "Podcast e video",
  "videoepisodes": "Episodi video",
  "localFiles": "File locali",
  "see_all": "Vedi tutti",
  "artist": "Artista",
  "track": "Brano",
  "playlist": "Playlist",
  "album": "Album",
  "genre": "Genere",
  "profile": "Profilo",
  "audio": "Podcast",
  "video": "Video",
  "episode": "Episodio video",
  "see_all_tracks": "Vedi tutti i brani",
  "see_all_artists": "Vedi tutti gli artisti",
  "see_all_albums": "Vedi tutti gli album",
  "see_all_playlists": "Vedi tutte le playlist",
  "see_all_profiles": "Vedi tutti i profili",
  "see_all_genres": "Vedi tutti i generi",
  "see_all_shows": "Visualizza tutti i podcast e video",
  "see_all_videoepisodes": "Vedi tutti gli episodi video"
}
},{}],14:[function(require,module,exports){
module.exports={
  "app.name": "Neo Search",
  "app.description": "",
  "app.offlineTitle": "検索はオフラインではご利用できません。",
  "app.offlineMessage": "ロードするには、インターネットに接続してください。",
  "app.errorTitle": "エラー",
  "app.errorMessage": "ロードに失敗しました。",
  "header.recentlySearchedTitle": "最近の検索",
  "header.searchResultsTitle": "検索結果",
  "header.allResultsTitle": " {0}の検索結果",
  "header.artistsResultsTitle": "{0}に該当するアーティストを表示しています",
  "header.albumsResultsTitle": "{0}に該当するアルバムを表示しています",
  "header.tracksResultsTitle": "{0}に該当する曲を表示しています",
  "header.playlistsResultsTitle": "{0}に該当するプレイリストを表示しています",
  "header.profilesResultsTitle": "{0}に該当するプロフィールを表示しています",
  "header.genresResultsTitle": "{0}に該当するジャンルを表示しています",
  "header.showsResultsTitle": "{0}に該当するポッドキャスト＆ビデオを表示しています",
  "header.videoepisodesResultsTitle": "{0}に該当するビデオエピソードを表示しています",
  "recentlySearched.removeFromRecentlySearched": "最近の検索履歴から削除する",
  "recentlySearched.clearRecentSearches": "最近の検索条件をクリア",
  "emptyView.searchSpotify": "Spotifyで検索",
  "emptyView.findYourMusic": "お気に入りの曲、アーティスト、アルバム、ポッドキャスト＆ビデオ、プレイリストや友達を見つけよう。",
  "emptyView.noResults": "「{0}」に該当する結果は見つかりませんでした",
  "emptyView.noResultsText": "単語の綴りが正しいか確認し、少ない単語で検索するか、別のキーワードで検索してください。",
  "emptyView.errorTitle": "エラーが発生したようです",
  "emptyView.errorText": "しばらくしてからまた試してください",
  "emptyView.offlineTitle": "オフライン検索で「{0}」に該当する結果は見つかりませんでした",
  "emptyView.offlineText": "インターネットに接続して、4000万曲以上もの曲を検索しましょう。",
  "emptyView.spotifyOffline": "Spotify オフライン",
  "emptyView.offlineResultsText": "Spotifyは現在インターネットに接続されていないため、ローカルファイルのみアクセスできます。インターネットに接続してMy Library をすべて見よう。",
  "facebookFriend": "Facebookの友達",
  "following": "フォロー中",
  "followers": {
    "one": "1人のフォロワー",
    "few": "{0}人のフォロワー",
    "other": "{0}人のフォロワー"
  },
  "topHit": "トップ結果",
  "topRecommendations": "おすすめの",
  "artists": "アーティスト",
  "tracks": "ソング",
  "playlists": "プレイリスト",
  "albums": "アルバム",
  "genres": "ジャンル",
  "profiles": "プロフィール",
  "shows": "ポッドキャスト＆ビデオ",
  "videoepisodes": "ビデオエピソード一覧",
  "localFiles": "ローカルファイル",
  "see_all": "すべて表示",
  "artist": "アーティスト",
  "track": "ソング",
  "playlist": "プレイリスト",
  "album": "アルバム",
  "genre": "ジャンル",
  "profile": "プロフィール",
  "audio": "ポッドキャスト",
  "video": "ビデオ",
  "episode": "ビデオエピソード",
  "see_all_tracks": "すべての曲を表示",
  "see_all_artists": "すべてのアーティストを表示",
  "see_all_albums": "すべてのアルバムを表示",
  "see_all_playlists": "すべてのプレイリストを表示",
  "see_all_profiles": "すべてのプロフィールを表示",
  "see_all_genres": "すべてのジャンル＆気分を見る",
  "see_all_shows": "すべてのポッドキャスト＆ビデオを見る",
  "see_all_videoepisodes": "すべてのビデオエピソードを表示"
}
},{}],15:[function(require,module,exports){
module.exports={
  "app.name": "Neo Search",
  "app.description": "",
  "app.offlineTitle": "Zoeken is offline niet beschikbaar.",
  "app.offlineMessage": "Ga online om te laden.",
  "app.errorTitle": "Fout",
  "app.errorMessage": "Laden mislukt.",
  "header.recentlySearchedTitle": "Recente zoekopdrachten",
  "header.searchResultsTitle": "Resultaten zoeken",
  "header.allResultsTitle": "Resultaten worden weergegeven voor {0}",
  "header.artistsResultsTitle": "Artiesten voor {0}",
  "header.albumsResultsTitle": "Albums voor {0}",
  "header.tracksResultsTitle": "Nummers voor {0}",
  "header.playlistsResultsTitle": "Afspeellijsten voor {0}",
  "header.profilesResultsTitle": "Profielen voor {0}",
  "header.genresResultsTitle": "Genres voor {0}",
  "header.showsResultsTitle": "Podcasts en video's voor {0}",
  "header.videoepisodesResultsTitle": "Videoafleveringen weergeven voor {0}",
  "recentlySearched.removeFromRecentlySearched": "Verwijderen uit Recente zoekopdrachten",
  "recentlySearched.clearRecentSearches": "Recente zoekopdrachten wissen",
  "emptyView.searchSpotify": "Zoeken in Spotify",
  "emptyView.findYourMusic": "Vind je favoriete nummers, artiesten, albums, podcasts en video's, afspeellijsten en vrienden.",
  "emptyView.noResults": "Geen resultaten gevonden voor \"{0}\"",
  "emptyView.noResultsText": "Controleer of alle woorden correct zijn gespeld, of gebruik minder of andere zoekwoorden.",
  "emptyView.errorTitle": "Er is iets fout gegaan.",
  "emptyView.errorText": "Probeer het later nog eens.",
  "emptyView.offlineTitle": "Geen offline resultaten gevonden voor \"{0}\"",
  "emptyView.offlineText": "Ga online en zoek in miljoenen nummers.",
  "emptyView.spotifyOffline": "Spotify offline",
  "emptyView.offlineResultsText": "Spotify is op dit moment offline. Je hebt alleen toegang tot lokale bestanden. Ga online om je hele bibliotheek te zien.",
  "facebookFriend": "Facebook-vriend",
  "following": "Volgend",
  "followers": {
    "one": "1 volger",
    "few": "{0} volgers",
    "other": "{0} volgers"
  },
  "topHit": "Topresultaat",
  "topRecommendations": "Met {0}",
  "artists": "Artiesten",
  "tracks": "Nummers",
  "playlists": "Afspeellijsten",
  "albums": "Albums",
  "genres": "Genres",
  "profiles": "Profielen",
  "shows": "Podcasts en video's",
  "videoepisodes": "Videoafleveringen",
  "localFiles": "Lokale bestanden",
  "see_all": "Alles bekijken",
  "artist": "Artiest",
  "track": "Nummer",
  "playlist": "Afspeellijst",
  "album": "Album",
  "genre": "Genre",
  "profile": "Profiel",
  "audio": "Podcast",
  "video": "Video",
  "episode": "Videoaflevering",
  "see_all_tracks": "Alle nummers bekijken",
  "see_all_artists": "Alle artiesten bekijken",
  "see_all_albums": "Alle albums bekijken",
  "see_all_playlists": "Alle afspeellijsten bekijken",
  "see_all_profiles": "Alle profielen bekijken",
  "see_all_genres": "Alle genres weergeven",
  "see_all_shows": "Alle podcasts en video's weergeven",
  "see_all_videoepisodes": "Alle videoafleveringen bekijken"
}
},{}],16:[function(require,module,exports){
module.exports={
  "app.name": "Neo Search",
  "app.description": "",
  "app.offlineTitle": "Wyszukiwanie nie jest dostępne w trybie offline. ",
  "app.offlineMessage": "Przejdź do trybu online, aby załadować.",
  "app.errorTitle": "Błąd",
  "app.errorMessage": "Ładowanie nie powiodło się.",
  "header.recentlySearchedTitle": "Ostatnie wyszukiwania",
  "header.searchResultsTitle": "Wyniki wyszukiwania",
  "header.allResultsTitle": "Oto wyniki dla {0}",
  "header.artistsResultsTitle": "Oto wykonawcy dla {0}",
  "header.albumsResultsTitle": "Oto albumy dla {0}",
  "header.tracksResultsTitle": "Oto utwory dla {0}",
  "header.playlistsResultsTitle": "Oto playlisty dla {0}",
  "header.profilesResultsTitle": "Oto profile dla {0}",
  "header.genresResultsTitle": "Oto gatunki dla {0}",
  "header.showsResultsTitle": "Oto podcasty i filmy dla {0}",
  "header.videoepisodesResultsTitle": "Oto odcinki filmu dla {0}",
  "recentlySearched.removeFromRecentlySearched": "Usuń z Ostatnich wyszukiwań",
  "recentlySearched.clearRecentSearches": "Wyczyść ostatnie wyszukiwania",
  "emptyView.searchSpotify": "Wyszukaj Spotify",
  "emptyView.findYourMusic": "Znajdź ulubione utwory, albumy, podcasty i filmy, playlisty oraz wykonawców i znajomych.",
  "emptyView.noResults": "Brak wyników dla „{0}”",
  "emptyView.noResultsText": "Upewnij się, że w wyrazach nie ma literówek lub użyj mniej albo innych słów kluczowych.",
  "emptyView.errorTitle": "Coś się nie udało",
  "emptyView.errorText": "Spróbuj ponownie później.",
  "emptyView.offlineTitle": "Brak wyników w trybie offline dla \"{0}\"",
  "emptyView.offlineText": "Przejdź do trybu online, aby wyszukiwać wśród milionów utworów.",
  "emptyView.spotifyOffline": "Spotify Offline",
  "emptyView.offlineResultsText": "Spotify jest obecnie w trybie offline z dostępem jedynie do lokalnych plików. Przejdź na tryb online, aby wyświetlić naszą Bibliotekę.",
  "facebookFriend": "Osoba znajoma z Facebooka",
  "following": "Obserwujesz",
  "followers": {
    "one": "1 obserwujący",
    "few": "Obserwujący: {0}",
    "other": "Obserwujący: {0}"
  },
  "topHit": "Najlepszy wynik",
  "topRecommendations": "Z uwzględnieniem wykonawcy: {0}",
  "artists": "Wykonawcy",
  "tracks": "Utwory",
  "playlists": "Playlisty",
  "albums": "Albumy",
  "genres": "Gatunki",
  "profiles": "Profile",
  "shows": "Podcasty i filmy",
  "videoepisodes": "Odcinki filmu",
  "localFiles": "Lokalne pliki",
  "see_all": "Zobacz wszystko",
  "artist": "Wykonawca",
  "track": "Utwór",
  "playlist": "Playlista",
  "album": "Album",
  "genre": "Gatunek",
  "profile": "Profil",
  "audio": "Podkast",
  "video": "Film",
  "episode": "Odcinek filmu",
  "see_all_tracks": "Zobacz wszystkie utwory",
  "see_all_artists": "Zobacz wszystkich wykonawców",
  "see_all_albums": "Zobacz wszystkie albumy",
  "see_all_playlists": "Zobacz wszystkie playlisty",
  "see_all_profiles": "Zobacz wszystkie profile",
  "see_all_genres": "Zobacz wszystkie gatunki",
  "see_all_shows": "Zobacz wszystkie podcasty i filmy",
  "see_all_videoepisodes": "Zobacz wszystkie odcinki filmu"
}
},{}],17:[function(require,module,exports){
module.exports={
  "app.name": "Neo Search",
  "app.description": "",
  "app.offlineTitle": "O recurso Buscar não está disponível offline.",
  "app.offlineMessage": "Fique online para carregar.",
  "app.errorTitle": "Erro",
  "app.errorMessage": "Falha no carregamento.",
  "header.recentlySearchedTitle": "Buscas recentes",
  "header.searchResultsTitle": "Resultados da busca",
  "header.allResultsTitle": "Mostrando resultados para {0}",
  "header.artistsResultsTitle": "Mostrando artistas para {0}",
  "header.albumsResultsTitle": "Mostrando álbuns para {0}",
  "header.tracksResultsTitle": "Mostrando músicas para {0}",
  "header.playlistsResultsTitle": "Mostrando playlists para {0}",
  "header.profilesResultsTitle": "Mostrando perfis para {0}",
  "header.genresResultsTitle": "Mostrando gêneros para {0}",
  "header.showsResultsTitle": "Mostrando Podcasts e Vídeos para {0}",
  "header.videoepisodesResultsTitle": "Mostrando episódios de vídeo para {0}",
  "recentlySearched.removeFromRecentlySearched": "Remover das Buscas recentes",
  "recentlySearched.clearRecentSearches": "Limpar buscas recentes",
  "emptyView.searchSpotify": "Buscar no Spotify",
  "emptyView.findYourMusic": "Encontre suas músicas, playlists, artistas, álbuns, podcasts e vídeos favoritos e seus amigos.",
  "emptyView.noResults": "Nenhum resultado encontrado para “{0}”",
  "emptyView.noResultsText": "Confira se você escreveu as palavras corretamente ou use menos palavras-chave ou palavras-chave diferentes.",
  "emptyView.errorTitle": "Algo deu errado",
  "emptyView.errorText": "Tente de novo mais tarde.",
  "emptyView.offlineTitle": "Nenhum resultado offline encontrado para \"{0}\"",
  "emptyView.offlineText": "Fique online para buscar milhões de músicas.",
  "emptyView.spotifyOffline": "O Spotify está offline",
  "emptyView.offlineResultsText": "O Spotify está offline no momento, com acesso apenas aos seus arquivos locais. Fique online para ver toda a nossa Biblioteca.",
  "facebookFriend": "Amigo do Facebook",
  "following": "Seguindo",
  "followers": {
    "one": "1 seguidor",
    "few": "{0} seguidores",
    "other": "{0} seguidores"
  },
  "topHit": "Melhor resultado",
  "topRecommendations": "Com {0}",
  "artists": "Artistas",
  "tracks": "Músicas",
  "playlists": "Playlists",
  "albums": "Álbuns",
  "genres": "Gêneros",
  "profiles": "Perfis",
  "shows": "Podcasts e Vídeos",
  "videoepisodes": "Episódios de vídeo",
  "localFiles": "Arquivos locais",
  "see_all": "Ver todos",
  "artist": "Artista",
  "track": "Música",
  "playlist": "Playlist",
  "album": "Álbum",
  "genre": "Gênero",
  "profile": "Perfil",
  "audio": "Podcast",
  "video": "Vídeo",
  "episode": "Episódio de vídeo",
  "see_all_tracks": "Ver todas as músicas",
  "see_all_artists": "Ver todos os artistas",
  "see_all_albums": "Ver todos os álbuns",
  "see_all_playlists": "Ver todas as playlists",
  "see_all_profiles": "Ver todos os perfis",
  "see_all_genres": "Ver todos os gêneros",
  "see_all_shows": "Ver todos os podcasts e vídeos",
  "see_all_videoepisodes": "Ver todos os episódios de vídeo"
}
},{}],18:[function(require,module,exports){
module.exports={
  "app.name": "Neo Search",
  "app.description": "",
  "app.offlineTitle": "Sökfunktionen är inte tillgänglig offline.",
  "app.offlineMessage": "Anslut till internet om du vill läsa in appen.",
  "app.errorTitle": "Fel",
  "app.errorMessage": "Det gick inte att läsa in appen.",
  "header.recentlySearchedTitle": "Nyligen utförda sökningar",
  "header.searchResultsTitle": "Sökresultat",
  "header.allResultsTitle": "Visar resultat för {0}",
  "header.artistsResultsTitle": "Visar artister för {0}",
  "header.albumsResultsTitle": "Visar album för {0}",
  "header.tracksResultsTitle": "Visar låtar för {0}",
  "header.playlistsResultsTitle": "Visar spellistor för {0}",
  "header.profilesResultsTitle": "Visar profiler för {0}",
  "header.genresResultsTitle": "Visar genrer för {0}",
  "header.showsResultsTitle": "Visar podcasts och videor för {0}",
  "header.videoepisodesResultsTitle": "Visar videoavsnitt för {0}",
  "recentlySearched.removeFromRecentlySearched": "Ta bort från nyligen utförda sökningar",
  "recentlySearched.clearRecentSearches": "Rensa sökhistorik",
  "emptyView.searchSpotify": "Sök på Spotify",
  "emptyView.findYourMusic": "Hitta dina favoritlåtar, artister, album, podcasts och videor, spellistor och vänner.",
  "emptyView.noResults": "Inga resultat för \"{0}\"",
  "emptyView.noResultsText": "Kontrollera att orden är rättstavade eller använd färre eller andra sökord.",
  "emptyView.errorTitle": "Något blev fel",
  "emptyView.errorText": "Försök igen senare.",
  "emptyView.offlineTitle": "Inga offline-resultat hittades för \"{0}\"",
  "emptyView.offlineText": "Koppla upp dig och sök bland miljontals låtar.",
  "emptyView.spotifyOffline": "Spotify är offline",
  "emptyView.offlineResultsText": "Spotify är just nu offline och har endast tillgång till dina lokala filer. Gå online för att se hela ditt bibliotek.",
  "facebookFriend": "Facebook-vän",
  "following": "Följer",
  "followers": {
    "one": "1 följare",
    "few": "{0} följare",
    "other": "{0} följare"
  },
  "topHit": "Toppresultat",
  "topRecommendations": "Med {0}",
  "artists": "Artister",
  "tracks": "Låtar",
  "playlists": "Spellistor",
  "albums": "Album",
  "genres": "Genrer",
  "profiles": "Profiler",
  "shows": "Podcasts & videor",
  "videoepisodes": "Videoavsnitt",
  "localFiles": "Lokala filer",
  "see_all": "Visa alla",
  "artist": "Artist",
  "track": "Låt",
  "playlist": "Spellista",
  "album": "Album",
  "genre": "Genre",
  "profile": "Profil",
  "audio": "Podcast",
  "video": "Video",
  "episode": "Videoavsnitt",
  "see_all_tracks": "Visa alla spår",
  "see_all_artists": "Visa alla artister",
  "see_all_albums": "Visa alla album",
  "see_all_playlists": "Visa alla spellistor",
  "see_all_profiles": "Visa alla profiler",
  "see_all_genres": "Visa alla genrer",
  "see_all_shows": "Visa alla podcasts och videor",
  "see_all_videoepisodes": "Se alla videoavsnitt"
}
},{}],19:[function(require,module,exports){
module.exports={
  "app.name": "Neo Search",
  "app.description": "",
  "app.offlineTitle": "ไม่สามารถค้นหาขณะออฟไลน์ได้ ",
  "app.offlineMessage": "โปรดใช้งานแบบออนไลน์เพื่อโหลด",
  "app.errorTitle": "ผิดพลาด",
  "app.errorMessage": "โหลดไม่สำเร็จ",
  "header.recentlySearchedTitle": "การค้นหาล่าสุด",
  "header.searchResultsTitle": "ผลการค้นหา",
  "header.allResultsTitle": "แสดงผลการค้นหาสำหรับ {0}",
  "header.artistsResultsTitle": "กำลังแสดงศิลปินสำหรับ {0}",
  "header.albumsResultsTitle": "กำลังแสดงอัลบั้มสำหรับ {0}",
  "header.tracksResultsTitle": "กำลังแสดงเพลงสำหรับ {0}",
  "header.playlistsResultsTitle": "กำลังแสดงเพลย์ลิสต์สำหรับ {0}",
  "header.profilesResultsTitle": "กำลังแสดงโปรไฟล์สำหรับ {0}",
  "header.genresResultsTitle": "กำลังแสดงแนวเพลงสำหรับ {0}",
  "header.showsResultsTitle": "กำลังแสดงพอดแคสต์และวิดีโอสำหรับ {0}",
  "header.videoepisodesResultsTitle": "กำลังแสดงตอนของวิดีโอเรื่อง {0}",
  "recentlySearched.removeFromRecentlySearched": "ลบออกจากรายการที่ค้นหาล่าสุด",
  "recentlySearched.clearRecentSearches": "ล้างการค้นหาล่าสุด",
  "emptyView.searchSpotify": "ค้นหา Spotify",
  "emptyView.findYourMusic": "ค้นหาเพลงโปรด ศิลปิน อัลบั้ม พอดแคสต์ วิดีโอ เพลย์ลิสต์ และเพื่อนของคุณ",
  "emptyView.noResults": "ไม่พบผลการค้นหาสำหรับ \"{0}\"",
  "emptyView.noResultsText": "โปรดตรวจสอบว่าสะกดคำถูกต้อง ลองลดจำนวนคำ หรือใช้คำค้นหาอื่น",
  "emptyView.errorTitle": "เกิดข้อผิดพลาด",
  "emptyView.errorText": "โปรดลองอีกครั้งในภายหลัง",
  "emptyView.offlineTitle": "ไม่พบผลลัพธ์ออฟไลน์สำหรับ \"{0}\"",
  "emptyView.offlineText": "ใช้งานแบบออนไลน์เพื่อค้นหาเพลงนับล้าน",
  "emptyView.spotifyOffline": "Spotify ออฟไลน์",
  "emptyView.offlineResultsText": "ขณะนี้ Spotify อยู่ในโหมดออฟไลน์ โดยจะสามารถเข้าใช้งานได้เฉพาะไฟล์ในเครื่องของคุณเท่านั้น ใช้งานแบบออนไลน์เพื่อดูไลบรารีทั้งหมดของเรา",
  "facebookFriend": "เพื่อนใน Facebook",
  "following": "กำลังติดตาม",
  "followers": {
    "one": "ผู้ติดตาม 1 คน",
    "few": "ผู้ติดตาม {0} คน",
    "other": "ผู้ติดตาม {0} คน"
  },
  "topHit": "ผลการค้นหาสูงสุด",
  "topRecommendations": "ประกอบด้วย {0}",
  "artists": "ศิลปิน",
  "tracks": "เพลง",
  "playlists": "เพลย์ลิสต์",
  "albums": "อัลบั้ม",
  "genres": "แนวเพลง",
  "profiles": "โปรไฟล์",
  "shows": "พอดแคสต์และวิดีโอ",
  "videoepisodes": "ตอนของวิดีโอ",
  "localFiles": "ไฟล์ในเครื่อง",
  "see_all": "ดูทั้งหมด",
  "artist": "ศิลปิน",
  "track": "เพลง",
  "playlist": "เพลย์ลิสต์",
  "album": "อัลบั้ม",
  "genre": "แนวเพลง",
  "profile": "โปรไฟล์",
  "audio": "พอดแคสต์",
  "video": "วิดีโอ",
  "episode": "ตอนของวิดีโอ",
  "see_all_tracks": "ดูเพลงทั้งหมด",
  "see_all_artists": "ดูศิลปินทั้งหมด",
  "see_all_albums": "ดูอัลบั้มทั้งหมด",
  "see_all_playlists": "ดูเพลย์ลิสต์ทั้งหมด",
  "see_all_profiles": "ดูโปรไฟล์ทั้งหมด",
  "see_all_genres": "ดูแนวเพลงทั้งหมด",
  "see_all_shows": "ดูพอดแคสต์และวิดีโอทั้งหมด",
  "see_all_videoepisodes": "ดูตอนของวิดีโอทั้งหมด"
}
},{}],20:[function(require,module,exports){
module.exports={
  "app.name": "Neo Search",
  "app.description": "",
  "app.offlineTitle": "Çevrimdışıyken arama yapılamaz.",
  "app.offlineMessage": "Yüklemek için lütfen çevrimiçi ol.",
  "app.errorTitle": "Hata",
  "app.errorMessage": "Yüklenemedi.",
  "header.recentlySearchedTitle": "Yakındaki Aramalar",
  "header.searchResultsTitle": "Arama Sonuçları",
  "header.allResultsTitle": "{0} için sonuçlar gösteriliyor",
  "header.artistsResultsTitle": "{0} için Sanatçılar gösteriliyor",
  "header.albumsResultsTitle": "{0} için Albümler gösteriliyor",
  "header.tracksResultsTitle": "{0} için Şarkılar gösteriliyor.",
  "header.playlistsResultsTitle": "{0} için Çalma Listeleri gösteriliyor",
  "header.profilesResultsTitle": "{0} için Profiller gösteriliyor",
  "header.genresResultsTitle": "{0} için Müzik Türleri gösteriliyor",
  "header.showsResultsTitle": "{0} için Poscast'ler ve Videolar gösteriliyor",
  "header.videoepisodesResultsTitle": "{0} için Video Bölümleri gösteriliyor",
  "recentlySearched.removeFromRecentlySearched": "Yakındaki Aramalardan Çıkart",
  "recentlySearched.clearRecentSearches": "Yakındaki Aramaları Temizle",
  "emptyView.searchSpotify": "Spotify'da Ara",
  "emptyView.findYourMusic": "En sevdiğin şarkıları, sanatçıları, albümleri, podcast'leri ve videoları, çalma listelerini ve arkadaşları bul.",
  "emptyView.noResults": "\"{0}\" için hiç sonuç bulunamadı",
  "emptyView.noResultsText": "Kelimelerini doğru yazdığından emin ol ya da daha az veya farklı anahtar kelime kullan.",
  "emptyView.errorTitle": "Bir sorun çıktı",
  "emptyView.errorText": "Lütfen daha sonra yeniden dene.",
  "emptyView.offlineTitle": "\"{0}\" için hiç çevrimdışı sonuç bulunamadı",
  "emptyView.offlineText": "Milyonlarca şarkıyı aramak için çevrimiçi ol.",
  "emptyView.spotifyOffline": "Spotify Çevrimdışı",
  "emptyView.offlineResultsText": "Spotify şu anda çevrimdışı ve sadece Yerel Dosyalarına erişimi var. Tüm Kitaplığın'ı görmek için çevrimiçi ol.",
  "facebookFriend": "Facebook arkadaşı",
  "following": "Takip Ediliyor",
  "followers": {
    "one": "1 Takipçi",
    "few": "{0} Takipçi",
    "other": "{0} Takipçi"
  },
  "topHit": "En Çok Dinlenen Sonuçlar",
  "topRecommendations": "Karşınızda {0}",
  "artists": "Sanatçılar",
  "tracks": "Şarkılar",
  "playlists": "Çalma Listeleri",
  "albums": "Albümler",
  "genres": "Türler",
  "profiles": "Profiller",
  "shows": "Podcast'ler ve Videolar",
  "videoepisodes": "Video Bölümleri",
  "localFiles": "Yerel Dosyalar",
  "see_all": "Tümünü Gör",
  "artist": "Sanatçı",
  "track": "Şarkı",
  "playlist": "Çalma listesi",
  "album": "Albüm",
  "genre": "Tür",
  "profile": "Profil",
  "audio": "Podcast",
  "video": "Video",
  "episode": "Video Bölümü",
  "see_all_tracks": "Tüm şarkıları gör",
  "see_all_artists": "Tüm sanatçıları gör",
  "see_all_albums": "Tüm albümleri gör",
  "see_all_playlists": "Tüm çalma listelerini gör",
  "see_all_profiles": "Tüm profilleri gör",
  "see_all_genres": "Tüm müzik türlerini gör",
  "see_all_shows": "Tüm podcast ve videoları gör",
  "see_all_videoepisodes": "Tüm video bölümlerini gör"
}
},{}],21:[function(require,module,exports){
module.exports={
  "app.name": "Neo Search",
  "app.description": "",
  "app.offlineTitle": "Không thể tìm kiếm khi ngoại tuyến. ",
  "app.offlineMessage": "Vui lòng truy cập trực tuyến để tải.",
  "app.errorTitle": "Lỗi",
  "app.errorMessage": "Không tải được.",
  "header.recentlySearchedTitle": "Các tìm kiếm Gần đây",
  "header.searchResultsTitle": "Tìm kiếm Kết quả",
  "header.allResultsTitle": "Hiển thị kết quả cho {0}",
  "header.artistsResultsTitle": "Hiển thị Nghệ sĩ cho {0}",
  "header.albumsResultsTitle": "Hiển thị Album cho {0}",
  "header.tracksResultsTitle": "Hiển thị Bài hát cho {0}.",
  "header.playlistsResultsTitle": "Hiển thị Danh sách phát cho {0}",
  "header.profilesResultsTitle": "Hiển thị Hồ sơ cho {0}",
  "header.genresResultsTitle": "Hiển thị Thể loại cho {0}",
  "header.showsResultsTitle": "Hiển thị Podcast & Video cho {0}",
  "header.videoepisodesResultsTitle": "Hiển thị các Tập Video cho {0}",
  "recentlySearched.removeFromRecentlySearched": "Xóa khỏi Tìm kiếm Gần đây",
  "recentlySearched.clearRecentSearches": "Xoá các Tìm kiếm Gần đây",
  "emptyView.searchSpotify": "Tìm kiếm Spotify",
  "emptyView.findYourMusic": "Tìm các bài hát, nghệ sĩ, album, podcast & video, danh sách phát và bạn bè yêu thích của bạn.",
  "emptyView.noResults": "Không tìm thấy kết quả nào cho \"{0}\"",
  "emptyView.noResultsText": "Vui lòng đảm bảo các từ bạn viết đúng chính tả, hoặc sử dụng ít từ khoá hơn hay thử các từ khoá khác.",
  "emptyView.errorTitle": "Đã có sự cố xảy ra",
  "emptyView.errorText": "Vui lòng thử lại sau.",
  "emptyView.offlineTitle": "Không tìm thấy kết quả ngoại tuyến cho \"{0}\"",
  "emptyView.offlineText": "Truy cập trực tuyến để tìm kiếm hàng triệu bài hát.",
  "emptyView.spotifyOffline": "Spotify Offline",
  "emptyView.offlineResultsText": "Spotify hiện đang offline và chỉ truy cập được vào các Tệp trên máy của bạn. Truy cập trực tuyến để xem toàn bộ Thư viện của chúng tôi.",
  "facebookFriend": "Bạn trên Facebook",
  "following": "Đang theo dõi",
  "followers": {
    "one": "1 Người theo dõi",
    "few": "{0} Người theo dõi",
    "other": "{0} Người theo dõi"
  },
  "topHit": "Kết quả Hàng đầu",
  "topRecommendations": "Có sự xuất hiện của {0}",
  "artists": "Nghệ sĩ",
  "tracks": "Bài hát",
  "playlists": "Danh sách phát",
  "albums": "Album",
  "genres": "Thể loại",
  "profiles": "Hồ sơ",
  "shows": "Podcast & Video",
  "videoepisodes": "Các tập Video",
  "localFiles": "Tập tin Trên máy",
  "see_all": "Xem tất cả",
  "artist": "Nghệ sĩ",
  "track": "Bài hát",
  "playlist": "Danh sách phát",
  "album": "Album",
  "genre": "Thể loại",
  "profile": "Hồ sơ",
  "audio": "Podcast",
  "video": "Video",
  "episode": "Tập Video",
  "see_all_tracks": "Xem tất cả các bài hát",
  "see_all_artists": "Xem tất cả nghệ sĩ",
  "see_all_albums": "Xem tất cả album",
  "see_all_playlists": "Xem tất cả danh sách phát",
  "see_all_profiles": "Xem tất cả hồ sơ",
  "see_all_genres": "Xem tất cả thể loại",
  "see_all_shows": "Xem tất cả podcast và video",
  "see_all_videoepisodes": "Xem tất cả các tập video"
}
},{}],22:[function(require,module,exports){
module.exports={
  "app.name": "Neo Search",
  "app.description": "",
  "app.offlineTitle": "離線時無法使用搜尋。",
  "app.offlineMessage": "請上網以載入。",
  "app.errorTitle": "錯誤",
  "app.errorMessage": "載入失敗。",
  "header.recentlySearchedTitle": "最近的搜尋項目",
  "header.searchResultsTitle": "搜尋結果",
  "header.allResultsTitle": "顯示搜尋 {0} 的結果",
  "header.artistsResultsTitle": "顯示藝人中的 {0} 搜尋結果",
  "header.albumsResultsTitle": "顯示專輯中的 {0} 搜尋結果",
  "header.tracksResultsTitle": "顯示歌曲中的 {0} 搜尋結果",
  "header.playlistsResultsTitle": "顯示播放清單中的 {0} 搜尋結果",
  "header.profilesResultsTitle": "顯示個人檔案中的 {0} 搜尋結果",
  "header.genresResultsTitle": "顯示曲風中的 {0} 搜尋結果",
  "header.showsResultsTitle": "顯示搜尋 {0} 的 Podcasts 與影片項目結果",
  "header.videoepisodesResultsTitle": "顯示 {0} 的影片集數",
  "recentlySearched.removeFromRecentlySearched": "自「最近的搜尋」移除",
  "recentlySearched.clearRecentSearches": "清除最近的搜尋項目",
  "emptyView.searchSpotify": "搜尋 Spotify",
  "emptyView.findYourMusic": "尋找你最喜愛的歌曲、藝人、專輯、Podcast 與影片、播放清單與好友。",
  "emptyView.noResults": "找不到 \"{0}\" 的搜尋結果",
  "emptyView.noResultsText": "請確認所有拼字正確，或輸入較短或其它關鍵字。",
  "emptyView.errorTitle": "發生錯誤",
  "emptyView.errorText": "請稍後再試一次。",
  "emptyView.offlineTitle": "找不到有關 \"{0}\" 的離線搜尋結果",
  "emptyView.offlineText": "請上網以搜尋百萬首歌曲。",
  "emptyView.spotifyOffline": "Spotify 已離線",
  "emptyView.offlineResultsText": "Spotify 目前已離線且僅能存取你的本機檔案。重新上線來瞧瞧我們音樂庫中的所有內容。",
  "facebookFriend": "Facebook 好友",
  "following": "正在關注",
  "followers": {
    "one": "1 名粉絲",
    "few": "{0} 名粉絲",
    "other": "{0} 名粉絲"
  },
  "topHit": "排名最高的結果",
  "topRecommendations": "演出者 {0}",
  "artists": "藝人",
  "tracks": "歌曲",
  "playlists": "播放列表",
  "albums": "專輯",
  "genres": "曲風",
  "profiles": "個人檔案",
  "shows": "Podcast 與影片",
  "videoepisodes": "影片集數",
  "localFiles": "本機檔案",
  "see_all": "查看全部",
  "artist": "藝人",
  "track": "歌曲",
  "playlist": "播放列表",
  "album": "專輯",
  "genre": "曲風",
  "profile": "個人檔案",
  "audio": "Podcast",
  "video": "影片",
  "episode": "影片集數",
  "see_all_tracks": "檢視所有歌曲",
  "see_all_artists": "檢視所有藝人",
  "see_all_albums": "檢視所有專輯",
  "see_all_playlists": "檢視所有播放清單",
  "see_all_profiles": "檢視所有個人檔案",
  "see_all_genres": "檢視所有曲風",
  "see_all_shows": "檢視所有 Podcasts 與影片",
  "see_all_videoepisodes": "查看所有影片集數"
}
},{}],23:[function(require,module,exports){
module.exports={
  "app.name": "Neo Search",
  "app.description": "",
  "app.offlineTitle": "Carian tidak tersedia di luar talian.",
  "app.offlineMessage": "Sila ke online untuk memuatkan.",
  "app.errorTitle": "Ralat",
  "app.errorMessage": "Gagal untuk memuatkan.",
  "header.recentlySearchedTitle": "Carian Terkini",
  "header.searchResultsTitle": "Hasil Carian",
  "header.allResultsTitle": "Tunjukkan hasil carian untuk {0}",
  "header.artistsResultsTitle": "Memaparkan Artis untuk {0}.",
  "header.albumsResultsTitle": "Memaparkan Album untuk {0}",
  "header.tracksResultsTitle": "Memaparkan Lagu untuk {0}",
  "header.playlistsResultsTitle": "Memaparkan Playlist untuk {0}",
  "header.profilesResultsTitle": "Memaparkan Profil untuk {0}",
  "header.genresResultsTitle": "Memaparkan Genre untuk {0}",
  "header.showsResultsTitle": "Memaparkan Podcast & Video untuk {0}",
  "header.videoepisodesResultsTitle": "Memaparkan Episod Video bagi {0}",
  "recentlySearched.removeFromRecentlySearched": "Keluarkan daripada Carian Terbaharu",
  "recentlySearched.clearRecentSearches": "Kosongkan Carian Terkini",
  "emptyView.searchSpotify": "Cari Spotify",
  "emptyView.findYourMusic": "Carilah lagu, artis, album, podcast & video, senarai main dan rakan kegemaran anda.",
  "emptyView.noResults": "Tiada hasil ditemui untuk \"{0}\" ",
  "emptyView.noResultsText": "Sila pastikan perkataan anda dieja dengan betul atau gunakan kurang kata kunci atau yang berbeza.",
  "emptyView.errorTitle": "Suatu kesilapan telah berlaku",
  "emptyView.errorText": "Sila cuba lagi kemudian.",
  "emptyView.offlineTitle": "Tiada hasil luar talian ditemui untuk \"{0}\"",
  "emptyView.offlineText": "Pergi ke dalam talian untuk mencari berjuta-juta lagu.",
  "emptyView.spotifyOffline": "Spotify Luar Talian",
  "emptyView.offlineResultsText": "Spotify sekarang di luar talian dengan akses hanya ke fail Setempat anda. Pergi ke dalam talian untuk melihat keseluruhan Pustaka kami.",
  "facebookFriend": "Rakan Facebook",
  "following": "Mengikuti",
  "followers": {
    "one": "1 Pengikut",
    "few": "{0} Pengikut",
    "other": "{0} Pengikut"
  },
  "topHit": "Hasil Paling Popular",
  "topRecommendations": "Menampilkan {0}",
  "artists": "Artis",
  "tracks": "Lagu",
  "playlists": "Senarai Main",
  "albums": "Album",
  "genres": "Genre",
  "profiles": "Profil",
  "shows": "Podcast & Video",
  "videoepisodes": "Episod video",
  "localFiles": "Fail Tempatan",
  "see_all": "Lihat Semua",
  "artist": "Artis",
  "track": "Lagu",
  "playlist": "Senarai main",
  "album": "Album",
  "genre": "Genre",
  "profile": "Profil",
  "audio": "Podcast",
  "video": "Video",
  "episode": "Episod Video",
  "see_all_tracks": "Lihat semua lagu",
  "see_all_artists": "Lihat semua artis",
  "see_all_albums": "Lihat semua album",
  "see_all_playlists": "Lihat semua senarai main",
  "see_all_profiles": "Lihat semua profil",
  "see_all_genres": "Lihat semua genre",
  "see_all_shows": "Lihat semua podcast dan video",
  "see_all_videoepisodes": "Lihat semua episod video"
}
},{}],24:[function(require,module,exports){
'use strict';

var _sentry = require('../../libs/sentry');

var sentry = _interopRequireWildcard(_sentry);

var _live = require('../../libs/expose-dev-mode-debug-globals/live');

var _live2 = _interopRequireDefault(_live);

var _glue = require('../../libs/glue');

var _glue2 = _interopRequireDefault(_glue);

var _liveModels = require('../../libs/live-models');

var _liveModels2 = _interopRequireDefault(_liveModels);

var _spotifyHandlebars = require('../../libs/spotify-handlebars');

var _spotifyHandlebars2 = _interopRequireDefault(_spotifyHandlebars);

var _helpers = require('../../libs/spotify-handlebars/helpers');

var _helpers2 = _interopRequireDefault(_helpers);

var _i18n = require('./i18n');

var _i18n2 = _interopRequireDefault(_i18n);

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _reactDom = require('react-dom');

var _reactDom2 = _interopRequireDefault(_reactDom);

var _reactRedux = require('react-redux');

var _spotifyEvents = require('../../libs/spotify-events');

var _spotifyEvents2 = _interopRequireDefault(_spotifyEvents);

var _configureStore = require('./src/configureStore');

var _configureStore2 = _interopRequireDefault(_configureStore);

var _App = require('./src/components/App');

var _App2 = _interopRequireDefault(_App);

var _actions = require('./src/actions');

var _actions2 = _interopRequireDefault(_actions);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

sentry.install();

_live2.default.init();

_glue2.default.gridOverlay.listen();

_liveModels2.default.register();

_helpers2.default.loc.register(_i18n2.default.glueStrings());
_helpers2.default.loc.register(_i18n2.default.appStrings());
_helpers2.default.loc.setLocale(_i18n2.default.locale());
_helpers2.default.numeral.setLocale(_i18n2.default.locale());
_spotifyHandlebars2.default.register(_helpers2.default);

const store = (0, _configureStore2.default)();

_spotifyEvents2.default.attach();

_reactDom2.default.render(_react2.default.createElement(
  _reactRedux.Provider,
  { store: store },
  _react2.default.createElement(_App2.default, { spotifyEvents: _spotifyEvents2.default })
), document.getElementById('root'));

store.dispatch(_actions2.default.startApp());

},{"../../libs/expose-dev-mode-debug-globals/live":92,"../../libs/glue":118,"../../libs/live-models":174,"../../libs/sentry":246,"../../libs/spotify-events":301,"../../libs/spotify-handlebars":350,"../../libs/spotify-handlebars/helpers":340,"./i18n":1,"./src/actions":27,"./src/components/App":33,"./src/configureStore":51,"react":697,"react-dom":530,"react-redux":666}],25:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
const SET_TRACK_RESULTS_AB_FLAG = exports.SET_TRACK_RESULTS_AB_FLAG = 'SET_TRACK_RESULTS_AB_FLAG';

const setTrackResultsAbFlag = exports.setTrackResultsAbFlag = cell => ({
  type: SET_TRACK_RESULTS_AB_FLAG,
  cell
});

},{}],26:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
const START_APP = exports.START_APP = 'START_APP';
const ACTIVATE_APP = exports.ACTIVATE_APP = 'ACTIVATE_APP';
const DEACTIVATE_APP = exports.DEACTIVATE_APP = 'DEACTIVATE_APP';
const GO_ONLINE = exports.GO_ONLINE = 'GO_ONLINE';
const GO_OFFLINE = exports.GO_OFFLINE = 'GO_OFFLINE';
const INITIALIZE_URI = exports.INITIALIZE_URI = 'INITIALIZE_URI';
const CHANGE_URI = exports.CHANGE_URI = 'CHANGE_URI';
const WATCH_ACTIVE_STATUS = exports.WATCH_ACTIVE_STATUS = 'WATCH_ACTIVE_STATUS';
const WATCH_APP_URI = exports.WATCH_APP_URI = 'WATCH_APP_URI';
const WATCH_ONLINE_STATUS = exports.WATCH_ONLINE_STATUS = 'WATCH_ONLINE_STATUS';

const startApp = exports.startApp = () => ({
  type: START_APP
});

const activateApp = exports.activateApp = () => ({
  type: ACTIVATE_APP
});

const deactivateApp = exports.deactivateApp = () => ({
  type: DEACTIVATE_APP
});

const goOnline = exports.goOnline = () => ({
  type: GO_ONLINE
});

const goOffline = exports.goOffline = () => ({
  type: GO_OFFLINE
});

const initializeUri = exports.initializeUri = uri => ({
  type: INITIALIZE_URI,
  payload: {
    uri
  }
});

const changeUri = exports.changeUri = uri => ({
  type: CHANGE_URI,
  payload: {
    uri
  }
});

const watchActiveStatus = exports.watchActiveStatus = () => ({
  type: WATCH_ACTIVE_STATUS
});

const watchAppUri = exports.watchAppUri = () => ({
  type: WATCH_APP_URI
});

const watchOnlineStatus = exports.watchOnlineStatus = () => ({
  type: WATCH_ONLINE_STATUS
});

},{}],27:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _app = require('./app');

var app = _interopRequireWildcard(_app);

var _search = require('./search');

var search = _interopRequireWildcard(_search);

var _recentlySearched = require('./recentlySearched');

var recentlySearched = _interopRequireWildcard(_recentlySearched);

var _interactionLogging = require('./interactionLogging');

var interactionLogging = _interopRequireWildcard(_interactionLogging);

var _abTesting = require('./abTesting');

var abTesting = _interopRequireWildcard(_abTesting);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

exports.default = _extends({}, app, search, recentlySearched, interactionLogging, abTesting);

},{"./abTesting":25,"./app":26,"./interactionLogging":28,"./recentlySearched":29,"./search":30}],28:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
const LOG_INTERACTION = exports.LOG_INTERACTION = 'LOG_INTERACTION';
const LOG_CLEAR_QUERY_INTERACTION = exports.LOG_CLEAR_QUERY_INTERACTION = 'LOG_CLEAR_QUERY_INTERACTION';

const logInteraction = exports.logInteraction = (target, type) => ({
  type: LOG_INTERACTION,
  payload: { target, type }
});

const logClearQueryInteraction = exports.logClearQueryInteraction = () => ({
  type: LOG_CLEAR_QUERY_INTERACTION
});

},{}],29:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
const SAVE_RECENT = exports.SAVE_RECENT = 'SAVE_RECENT';
const REMOVE_RECENT = exports.REMOVE_RECENT = 'REMOVE_RECENT';
const REMOVE_ALL_RECENT = exports.REMOVE_ALL_RECENT = 'REMOVE_ALL_RECENT';

const saveRecent = exports.saveRecent = item => ({
  type: SAVE_RECENT,
  payload: { item }
});

const removeRecent = exports.removeRecent = uri => ({
  type: REMOVE_RECENT,
  payload: { uri }
});

const removeAllRecent = exports.removeAllRecent = () => ({
  type: REMOVE_ALL_RECENT
});

},{}],30:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.clearSearchResults = exports.fetchMoreCategoryResults = exports.fetchCategoryResults = exports.fetchAllResults = exports.fetchFailure = exports.receiveMoreCategoryResults = exports.receiveCategoryResults = exports.receiveAllResults = exports.MAX_LOCAL_FILES_IN_TRACK_RESULTS = exports.MAX_LOCAL_FILES_IN_ALL_RESULTS = exports.FETCH_ERROR = exports.CLEAR_SEARCH_RESULTS = exports.RECEIVE_MORE_CATEGORY_RESULTS = exports.RECEIVE_CATEGORY_RESULTS = exports.RECEIVE_ALL_RESULTS = undefined;

var _api = require('../api');

const RECEIVE_ALL_RESULTS = exports.RECEIVE_ALL_RESULTS = 'RECEIVE_ALL_RESULTS';
const RECEIVE_CATEGORY_RESULTS = exports.RECEIVE_CATEGORY_RESULTS = 'RECEIVE_CATEGORY_RESULTS';
const RECEIVE_MORE_CATEGORY_RESULTS = exports.RECEIVE_MORE_CATEGORY_RESULTS = 'RECEIVE_MORE_CATEGORY_RESULTS';
const CLEAR_SEARCH_RESULTS = exports.CLEAR_SEARCH_RESULTS = 'CLEAR_SEARCH_RESULTS';
const FETCH_ERROR = exports.FETCH_ERROR = 'FETCH_ERROR';

const MAX_LOCAL_FILES_IN_ALL_RESULTS = exports.MAX_LOCAL_FILES_IN_ALL_RESULTS = 2;
const MAX_LOCAL_FILES_IN_TRACK_RESULTS = exports.MAX_LOCAL_FILES_IN_TRACK_RESULTS = 50;

const receiveAllResults = exports.receiveAllResults = ({ results, requestId, categoriesOrder }, localFileResults) => ({
  type: RECEIVE_ALL_RESULTS,
  payload: {
    localFileResults,
    results,
    requestId,
    categoriesOrder
  }
});

const receiveCategoryResults = exports.receiveCategoryResults = ({ results, requestId }, localFileResults = null) => ({
  type: RECEIVE_CATEGORY_RESULTS,
  payload: {
    localFileResults,
    results,
    requestId
  }
});

const receiveMoreCategoryResults = exports.receiveMoreCategoryResults = ({ results, requestId }) => ({
  type: RECEIVE_MORE_CATEGORY_RESULTS,
  payload: {
    results,
    requestId
  }
});

const fetchFailure = exports.fetchFailure = error => ({
  type: FETCH_ERROR,
  payload: {
    error
  }
});

const concealError = promise => {
  return new Promise(resolve => {
    promise.then(result => {
      resolve([result]);
    }, error => {
      resolve([null, error]);
    });
  });
};

const fetchAllResults = exports.fetchAllResults = (api, query) => (dispatch, getState) => {
  if (query.length === 0) {
    return;
  }
  const online = getState().app.online;

  Promise.all([
  // We still need to resolve when we're offline.
  concealError(api.fetchAllResults(query)), api.fetchLocalFiles(query, online ? MAX_LOCAL_FILES_IN_ALL_RESULTS : MAX_LOCAL_FILES_IN_TRACK_RESULTS)]).then(([[serviceSuccess, serviceError], localFileResults]) => {
    if (serviceError) {
      console.error(serviceError);
    }
    dispatch(receiveAllResults(serviceSuccess || [], localFileResults));
  }, err => {
    dispatch(fetchFailure(err));
  });
};

const fetchCategoryResults = exports.fetchCategoryResults = (api, category, query) => dispatch => {
  if (query.length === 0) {
    return;
  }

  const isTrackCategory = category === 'tracks';

  Promise.all([api.fetchCategoryResults(category, query), isTrackCategory ? api.fetchLocalFiles(query, MAX_LOCAL_FILES_IN_TRACK_RESULTS) : null]).then(([serviceResults, localFiles]) => {
    dispatch(receiveCategoryResults(serviceResults, localFiles));
  }, err => {
    dispatch(fetchFailure(err));
  });
};

const fetchMoreCategoryResults = exports.fetchMoreCategoryResults = url => dispatch => {
  if (!url) {
    return;
  }

  (0, _api.fetchFromURL)(url).then(res => {
    dispatch(receiveMoreCategoryResults(res));
  }, err => {
    dispatch(fetchFailure(err));
  });
};

const clearSearchResults = exports.clearSearchResults = () => ({
  type: CLEAR_SEARCH_RESULTS
});

},{"../api":31}],31:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.fetchLocalFiles = exports.fetchCategoryResults = exports.fetchAllResults = exports.fetchFromURL = undefined;

var _spotifyCosmosApi = require('spotify-cosmos-api');

const fetchFromURL = exports.fetchFromURL = url => new Promise((resolve, reject) => {
  _spotifyCosmosApi.resolver.resolve(new _spotifyCosmosApi.Request('GET', url), (err, res) => {
    if (err) reject(err);else resolve(JSON.parse(res._body));
  });
});

const fetchAllResults = exports.fetchAllResults = context => query => new Promise((resolve, reject) => {
  const request = context.newSearchRequest().setVersion('v4').setEndpoint('search').setParameter('entityVersion', '2').setQuery(query).setParameter('limit', '10').setParameter('imageSize', 'large');

  context.sendRequest(request, {}, resolve, reject);
});

const fetchCategoryResults = exports.fetchCategoryResults = context => (category, query, limit = 40) => new Promise((resolve, reject) => {
  const request = context.newSearchRequest().setVersion('v4').setEndpoint(`search-${category}`).setParameter('entityVersion', '2').setQuery(query).setParameter('limit', `${limit}`).setParameter('imageSize', 'large');

  context.sendRequest(request, {}, resolve, reject);
});

const fetchLocalFiles = exports.fetchLocalFiles = (query, limit) => new Promise((resolve, reject) => {
  const url = `sp://local-files/v1/tracks?
      offset=0&length=${limit}&query=${encodeURIComponent(query)}`;
  fetchFromURL(url).then(resolve, reject);
});

exports.default = context => ({
  fetchAllResults: fetchAllResults(context),
  fetchCategoryResults: fetchCategoryResults(context),
  fetchLocalFiles
});

},{"spotify-cosmos-api":720}],32:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getSections = exports.AllResults = undefined;

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _reactRedux = require('react-redux');

var _SearchSection = require('./SearchSection');

var _SearchSection2 = _interopRequireDefault(_SearchSection);

var _CardList = require('./CardList');

var _CardList2 = _interopRequireDefault(_CardList);

var _TrackList = require('./TrackList');

var _TrackList2 = _interopRequireDefault(_TrackList);

var _classnames = require('classnames');

var _classnames2 = _interopRequireDefault(_classnames);

var _i18n = require('../../i18n');

var _i18n2 = _interopRequireDefault(_i18n);

var _categoryPageTypes = require('../lib/categoryPageTypes');

var categoryTypes = _interopRequireWildcard(_categoryPageTypes);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class AllResults extends _react2.default.PureComponent {
  renderSection(item, index) {
    const { query, trackResultsABcell } = this.props;
    const sectionType = Object.keys(item)[0];
    const { hits } = item[sectionType];
    const renderTrackListAsCardList = trackResultsABcell === 'Cards';
    const renderTrackListWithTrackContextRows = trackResultsABcell === 'TrackContextRows';
    const isTracklist = !renderTrackListAsCardList && sectionType === 'tracks';
    const gridClasses = isTracklist ? ['col-xs-12'] : ['col-xs-12', 'col-md-6'];

    return hits.length ? _react2.default.createElement(
      'div',
      { className: (0, _classnames2.default)('AllResults__item', ...gridClasses), key: index },
      _react2.default.createElement(
        _SearchSection2.default,
        {
          title: _i18n2.default.get(sectionType),
          type: sectionType,
          seeMoreUri: `spotify:search:${query}:${sectionType}`
        },
        isTracklist ? _react2.default.createElement(_TrackList2.default, {
          tracks: hits,
          limit: 4,
          type: sectionType,
          trackContextRows: renderTrackListWithTrackContextRows
        }) : _react2.default.createElement(_CardList2.default, {
          items: hits.slice(0, 4),
          withHorizontalCards: true,
          showMetadata: true,
          gridClasses: ['col-xs-6'],
          type: sectionType
        })
      )
    ) : null;
  }

  render() {
    const { sections, trackResultsABcell } = this.props;
    if (trackResultsABcell === undefined) {
      // Wait for ABBA flag to tell us how track results should be rendered.
      return null;
    }

    return _react2.default.createElement(
      'div',
      { className: 'AllResults row standard-grid' },
      sections.map(this.renderSection, this)
    );
  }
}

exports.AllResults = AllResults;
AllResults.propTypes = {
  query: _propTypes2.default.string.isRequired,
  sections: _propTypes2.default.array
};

AllResults.defaultProps = {
  query: null,
  sections: []
};

const getSections = exports.getSections = results => {
  const TOP_ROW_CATEGORIES = ['topHit', 'topRecommendations'];
  if (!results.categories || !results.categories.all) {
    return null;
  }

  const { categoriesOrder, entities } = results.categories.all;
  return categoriesOrder.map(category => {
    // Remove sections that don't have any hits.
    if (!entities[category] || entities[category].total === 0) {
      return null;
    }

    if (TOP_ROW_CATEGORIES.indexOf(category) > -1) {
      return null;
    }

    // Remove categories that are not whitelisted
    if (!Object.values(categoryTypes).includes(category)) {
      return null;
    }

    return { [category]: entities[category] };
  }).filter(category => category);
};

const mapStateToProps = state => ({
  query: state.query.text,
  sections: getSections(state.results),
  trackResultsABcell: state.abTesting.trackResultsABcell
});

exports.default = (0, _reactRedux.connect)(mapStateToProps)(AllResults);

},{"../../i18n":1,"../lib/categoryPageTypes":55,"./CardList":34,"./SearchSection":47,"./TrackList":50,"classnames":376,"prop-types":495,"react":697,"react-redux":666}],33:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.mapStateToProps = exports.App = undefined;

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _reactRedux = require('react-redux');

var _actions = require('../actions');

var _actions2 = _interopRequireDefault(_actions);

var _categoryPageTypes = require('../lib/categoryPageTypes');

var categories = _interopRequireWildcard(_categoryPageTypes);

var _GlueHeader = require('./GlueHeader');

var _GlueHeader2 = _interopRequireDefault(_GlueHeader);

var _Header = require('./Header');

var _Header2 = _interopRequireDefault(_Header);

var _AllResults = require('./AllResults');

var _AllResults2 = _interopRequireDefault(_AllResults);

var _TopResultsSection = require('./TopResultsSection');

var _TopResultsSection2 = _interopRequireDefault(_TopResultsSection);

var _LocalFiles = require('./LocalFiles');

var _LocalFiles2 = _interopRequireDefault(_LocalFiles);

var _RecentlySearched = require('./RecentlySearched');

var _RecentlySearched2 = _interopRequireDefault(_RecentlySearched);

var _CategoryResults = require('./CategoryResults');

var _CategoryResults2 = _interopRequireDefault(_CategoryResults);

var _Throbber = require('./Throbber');

var _Throbber2 = _interopRequireDefault(_Throbber);

var _EmptyView = require('./EmptyView');

var _EmptyView2 = _interopRequireDefault(_EmptyView);

var _i18n = require('../../i18n');

var _i18n2 = _interopRequireDefault(_i18n);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class App extends _react2.default.PureComponent {
  constructor(...args) {
    super(...args);

    this.handleClick = this.handleClick.bind(this);
  }

  componentDidMount() {
    this.props.spotifyEvents.update();
  }

  componentDidUpdate(prevProps) {
    this.props.spotifyEvents.update();

    if (prevProps.query !== this.props.query) {
      window.scrollTo(0, 0);
    }

    if (this.props.query && this.props.query.length === 0 && prevProps.query.length > 0) {
      this.props.logClearQueryInteraction();
    }
  }

  handleClick(event) {
    this.props.logInteraction(event.target, event.type);
  }

  renderErrorMessage() {
    return _react2.default.createElement(_EmptyView2.default, { title: _i18n2.default.get('emptyView.errorTitle'), text: _i18n2.default.get('emptyView.errorText') });
  }

  renderOfflineMessage(query) {
    return _react2.default.createElement(_EmptyView2.default, { title: _i18n2.default.get('emptyView.offlineTitle', query), text: _i18n2.default.get('emptyView.offlineText') });
  }

  renderHeader() {
    const { query, isOnline, error, currentCategory, totalResults, categoryResults, recentlySearched } = this.props;

    switch (currentCategory) {
      case categories.ALL_RESULTS:
        if (totalResults === null || totalResults === 0) {
          // Waiting for results from the BE or when there is no results
          return null;
        }
        if (!isOnline && !categoryResults.entities.topHit && categoryResults.entities.tracks) {
          // Offline results header
          return _react2.default.createElement(
            _GlueHeader2.default,
            null,
            _react2.default.createElement(_EmptyView2.default, {
              title: _i18n2.default.get('emptyView.spotifyOffline'),
              text: _i18n2.default.get('emptyView.offlineResultsText'),
              fullView: false
            })
          );
        }
        return _react2.default.createElement(_TopResultsSection2.default, null);

      case categories.RECENTLY_SEARCHED:
        return recentlySearched && recentlySearched.items.length > 0 ? _react2.default.createElement(_Header2.default, null) : null;

      case categories.ARTISTS:
      case categories.ALBUMS:
      case categories.TRACKS:
      case categories.PLAYLISTS:
      case categories.GENRES:
      case categories.PROFILES:
      case categories.SHOWS:
      case categories.VIDEOEPISODES:
        {
          if (totalResults === 0) {
            // Don't display header when there is no results
            return null;
          }
          if (error) {
            // Don't display header for offline messages
            return null;
          }

          return _react2.default.createElement(_Header2.default, { query: query, category: currentCategory });
        }

      default:
        return _react2.default.createElement(_Header2.default, { query: query, category: currentCategory });
    }
  }

  renderContent() {
    const { query, isOnline, error, currentCategory, totalResults, categoryResults, recentlySearched } = this.props;

    switch (currentCategory) {
      case categories.ALL_RESULTS:
        if (totalResults === null) {
          if (error) {
            return this.renderErrorMessage();
          }

          // Waiting for results from the BE
          return null;
        } else if (totalResults === 0) {
          if (!isOnline) {
            return this.renderOfflineMessage(query);
          }

          return _react2.default.createElement(_EmptyView2.default, { title: _i18n2.default.get('emptyView.noResults', query), text: _i18n2.default.get('emptyView.noResultsText') });
        }
        if (!isOnline && !categoryResults.entities.topHit && categoryResults.entities.tracks) {
          // Offline results view
          const hits = categoryResults.entities.tracks.hits;
          return _react2.default.createElement(_LocalFiles2.default, { hits: hits, type: 'tracks' });
        }
        return _react2.default.createElement(_AllResults2.default, null);

      case categories.ARTISTS:
      case categories.ALBUMS:
      case categories.TRACKS:
      case categories.PLAYLISTS:
      case categories.GENRES:
      case categories.PROFILES:
      case categories.SHOWS:
      case categories.VIDEOEPISODES:
        {
          if (!categoryResults) {
            if (!isOnline) {
              return this.renderOfflineMessage(query);
            }

            if (error) {
              return this.renderErrorMessage();
            }

            // Waiting for results from the BE
            return _react2.default.createElement(_Throbber2.default, null);
          }

          const { loadMoreUri, entities } = categoryResults;

          return _react2.default.createElement(_CategoryResults2.default, { type: currentCategory, loadMoreUri: loadMoreUri, items: entities });
        }

      case categories.RECENTLY_SEARCHED:
      default:
        return recentlySearched && recentlySearched.items.length > 0 ? _react2.default.createElement(_RecentlySearched2.default, { items: recentlySearched.items }) : _react2.default.createElement(_EmptyView2.default, {
          icon: 'search',
          title: _i18n2.default.get('emptyView.searchSpotify'),
          text: _i18n2.default.get('emptyView.findYourMusic')
        });
    }
  }

  render() {
    return _react2.default.createElement(
      'div',
      {
        className: 'App',
        'data-ta-id': 'neo-search-app',
        onClick: this.handleClick,
        onDoubleClick: this.handleClick,
        onContextMenu: this.handleClick
      },
      _react2.default.createElement(
        'div',
        { className: 'App__header' },
        this.renderHeader()
      ),
      _react2.default.createElement(
        'div',
        { className: 'App__content container' },
        this.renderContent()
      )
    );
  }
}

exports.App = App;
App.propTypes = {
  spotifyEvents: _propTypes2.default.shape({
    update: _propTypes2.default.func
  }).isRequired,
  query: _propTypes2.default.string,
  isOnline: _propTypes2.default.bool.isRequired,
  totalResults: _propTypes2.default.number,
  error: _propTypes2.default.string,
  recentlySearched: _propTypes2.default.shape({
    items: _propTypes2.default.Array
  }),
  currentCategory: _propTypes2.default.string,
  categoryResults: _propTypes2.default.object,
  logInteraction: _propTypes2.default.func,
  logClearQueryInteraction: _propTypes2.default.func
};

App.defaultProps = {
  spotifyEvents: null,
  query: null,
  isOnline: null,
  totalResults: null,
  error: null,
  recentlySearched: null,
  currentCategory: categories.RECENTLY_SEARCHED,
  categoryResults: null,
  logInteraction: () => {},
  logClearQueryInteraction: () => {}
};

const mapStateToProps = exports.mapStateToProps = state => ({
  query: state.query.text,
  isOnline: state.app.online,
  currentCategory: state.query.category,
  totalResults: state.results.categories && state.results.categories[state.query.category] ? state.results.totalResults : null,
  categoryResults: state.results.categories && state.results.categories[state.query.category],
  error: state.results.error,
  recentlySearched: (() => {
    const { entities, recencyOrder } = state.recentlySearched.data;
    return {
      items: recencyOrder.map(uri => entities[uri])
    };
  })()
});

const mapDispatchToProps = dispatch => ({
  logInteraction: (target, type) => dispatch(_actions2.default.logInteraction(target, type)),
  logClearQueryInteraction: () => dispatch(_actions2.default.logClearQueryInteraction())
});

exports.default = (0, _reactRedux.connect)(mapStateToProps, mapDispatchToProps)(App);

},{"../../i18n":1,"../actions":27,"../lib/categoryPageTypes":55,"./AllResults":32,"./CategoryResults":36,"./EmptyView":37,"./GlueHeader":42,"./Header":44,"./LocalFiles":45,"./RecentlySearched":46,"./Throbber":48,"./TopResultsSection":49,"prop-types":495,"react":697,"react-redux":666}],34:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CardList = undefined;

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _classnames = require('classnames');

var _classnames2 = _interopRequireDefault(_classnames);

var _reactRedux = require('react-redux');

var _actions = require('../actions');

var _actions2 = _interopRequireDefault(_actions);

var _GlueHandlebarsTemplate = require('../../../../libs/glue/components/GlueHandlebarsTemplate');

var _GlueHandlebarsTemplate2 = _interopRequireDefault(_GlueHandlebarsTemplate);

var _card = require('../../../../libs/glue/templates/cards/card.hbs');

var _card2 = _interopRequireDefault(_card);

var _cardHorizontal = require('../../../../libs/glue/templates/cards/card-horizontal.hbs');

var _cardHorizontal2 = _interopRequireDefault(_cardHorizontal);

var _searchPropTypes = require('../searchPropTypes');

var _convertToGlueCardData = require('../lib/convertToGlueCardData');

var _convertToGlueCardData2 = _interopRequireDefault(_convertToGlueCardData);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const INFINITE_LOADER_THRESHOLD = 300;

class CardList extends _react2.default.PureComponent {
  constructor(...args) {
    super(...args);
    this.renderItem = this.renderItem.bind(this);
    this.handleClick = this.handleClick.bind(this);
    this.handleScroll = this.handleScroll.bind(this);
    this.state = { isLoading: false };
  }

  componentDidMount() {
    window.addEventListener('scroll', this.handleScroll);
  }

  componentWillReceiveProps() {
    this.setState({ isLoading: false });
  }

  componentWillUnmount() {
    window.removeEventListener('scroll', this.handleScroll);
  }

  handleClick(event) {
    if (this.props.ignoreClicks) return;
    const element = event.target.closest('[data-uri]');
    const uri = element && element.dataset.uri;
    if (uri) {
      this.props.saveRecent(this.props.items.find(item => uri === item.uri));
    }
  }

  handleScroll() {
    const { fetchMoreCategoryResults, loadMoreUri } = this.props;
    if (!loadMoreUri || this.state.isLoading || !this.props.isOnline) return;
    if (window.pageYOffset + window.innerHeight > document.body.scrollHeight - INFINITE_LOADER_THRESHOLD) {
      this.setState({ isLoading: true });
      fetchMoreCategoryResults(loadMoreUri);
    }
  }

  renderItem(item, index) {
    const {
      showTypeMetadata,
      showMetadata,
      withHorizontalCards,
      gridClasses,
      showRemoveButtons,
      showPlaylistOwner,
      onlyPlayButtonOnCards,
      isVideo
    } = this.props;
    const template = withHorizontalCards ? _cardHorizontal2.default : _card2.default;

    return _react2.default.createElement(
      'li',
      {
        className: (0, _classnames2.default)('CardList__list__item', ...gridClasses),
        onClick: this.handleClick,
        key: index,
        'data-interaction-context': index
      },
      _react2.default.createElement(_GlueHandlebarsTemplate2.default, {
        template: template,
        data: (0, _convertToGlueCardData2.default)(item, {
          includeTypeMetadata: showTypeMetadata,
          includeMetadata: showMetadata,
          includeRemoveButton: showRemoveButtons,
          includePlaylistOwner: showPlaylistOwner,
          playButtonOnly: onlyPlayButtonOnCards,
          isVideo: isVideo
        })
      })
    );
  }

  render() {
    return _react2.default.createElement(
      'div',
      { className: 'CardList' },
      _react2.default.createElement(
        'ol',
        { className: 'CardList__list row standard-grid', 'aria-labelledby': `section-${this.props.type}` },
        this.props.items.map(this.renderItem)
      )
    );
  }
}

exports.CardList = CardList;
CardList.defaultProps = {
  type: null,
  isOnline: null,
  items: null,
  withHorizontalCards: false,
  ignoreClicks: false,
  showTypeMetadata: false,
  showMetadata: false,
  showRemoveButtons: false,
  // It's always 4 cards and they should always take up the space inside their container.
  gridClasses: ['col-xs-3'],
  loadMoreUri: null,
  saveRecent: () => {},
  fetchMoreCategoryResults: () => {},
  onlyPlayButtonOnCards: false,
  isVideo: false
};

CardList.propTypes = {
  type: _propTypes2.default.string.isRequired,
  isOnline: _propTypes2.default.bool.isRequired,
  items: _propTypes2.default.arrayOf(_searchPropTypes.cardShape).isRequired,
  withHorizontalCards: _propTypes2.default.bool,
  ignoreClicks: _propTypes2.default.bool,
  showTypeMetadata: _propTypes2.default.bool,
  showMetadata: _propTypes2.default.bool,
  showRemoveButtons: _propTypes2.default.bool,
  showPlaylistOwner: _propTypes2.default.bool,
  gridClasses: _propTypes2.default.arrayOf(_propTypes2.default.string),
  loadMoreUri: _propTypes2.default.string,
  saveRecent: _propTypes2.default.func,
  fetchMoreCategoryResults: _propTypes2.default.func,
  onlyPlayButtonOnCards: _propTypes2.default.bool,
  isVideo: _propTypes2.default.bool
};

const mapStateToProps = state => ({
  isOnline: state.app.online
});

const mapDispatchToProps = dispatch => ({
  fetchMoreCategoryResults: uri => dispatch(_actions2.default.fetchMoreCategoryResults(uri)),
  saveRecent: data => dispatch(_actions2.default.saveRecent(data))
});

exports.default = (0, _reactRedux.connect)(mapStateToProps, mapDispatchToProps)(CardList);

},{"../../../../libs/glue/components/GlueHandlebarsTemplate":95,"../../../../libs/glue/templates/cards/card-horizontal.hbs":123,"../../../../libs/glue/templates/cards/card.hbs":124,"../actions":27,"../lib/convertToGlueCardData":56,"../searchPropTypes":73,"classnames":376,"prop-types":495,"react":697,"react-redux":666}],35:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Carousel = undefined;

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _classnames = require('classnames');

var _classnames2 = _interopRequireDefault(_classnames);

var _reactRedux = require('react-redux');

var _actions = require('../actions');

var _actions2 = _interopRequireDefault(_actions);

var _GlueHandlebarsTemplate = require('../../../../libs/glue/components/GlueHandlebarsTemplate');

var _GlueHandlebarsTemplate2 = _interopRequireDefault(_GlueHandlebarsTemplate);

var _card = require('../../../../libs/glue/templates/cards/card.hbs');

var _card2 = _interopRequireDefault(_card);

var _searchPropTypes = require('../searchPropTypes');

var _convertToGlueCardData = require('../lib/convertToGlueCardData');

var _convertToGlueCardData2 = _interopRequireDefault(_convertToGlueCardData);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class Carousel extends _react2.default.PureComponent {
  constructor(...args) {
    super(...args);
    this.renderItem = this.renderItem.bind(this);
    this.handleClick = this.handleClick.bind(this);
  }

  handleClick(event) {
    const element = event.target.closest('[data-uri]');
    const uri = element && element.dataset.uri;
    if (uri) {
      this.props.saveRecent(this.props.items.find(item => uri === item.uri));
    }
  }

  renderItem(item, index) {
    return _react2.default.createElement(
      'li',
      {
        className: (0, _classnames2.default)('Carousel__item', 'col-xs-6', 'col-sm-4', 'col-md-3', 'crsl-item'),
        onClick: this.handleClick,
        key: index,
        'data-interaction-context': index
      },
      _react2.default.createElement(_GlueHandlebarsTemplate2.default, {
        template: _card2.default,
        data: (0, _convertToGlueCardData2.default)(item, {
          includeMetadata: true,
          playButtonOnly: true
        })
      })
    );
  }

  render() {
    const carouselId = `carousel-${this.props.type}`;

    return _react2.default.createElement(
      'div',
      { className: 'Carousel', 'data-carousel-main': true, 'data-carousel': carouselId },
      _react2.default.createElement(
        'div',
        { className: 'row standard-grid carousel' },
        _react2.default.createElement(
          'ol',
          {
            className: 'Carousel__inner crsl-inner',
            'data-carousel-inner': true,
            'aria-labelledby': `section-${this.props.type}`
          },
          this.props.items.map(this.renderItem)
        )
      )
    );
  }
}

exports.Carousel = Carousel;
Carousel.propTypes = {
  type: _propTypes2.default.string.isRequired,
  items: _propTypes2.default.arrayOf(_searchPropTypes.cardShape).isRequired,
  saveRecent: _propTypes2.default.func
};

Carousel.defaultProps = {
  type: null,
  items: null,
  saveRecent: () => {}
};

const mapStateToProps = () => ({});

const mapDispatchToProps = dispatch => ({
  saveRecent: data => dispatch(_actions2.default.saveRecent(data))
});

exports.default = (0, _reactRedux.connect)(mapStateToProps, mapDispatchToProps)(Carousel);

},{"../../../../libs/glue/components/GlueHandlebarsTemplate":95,"../../../../libs/glue/templates/cards/card.hbs":124,"../actions":27,"../lib/convertToGlueCardData":56,"../searchPropTypes":73,"classnames":376,"prop-types":495,"react":697,"react-redux":666}],36:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _categoryPageTypes = require('../lib/categoryPageTypes');

var _CardList = require('./CardList');

var _CardList2 = _interopRequireDefault(_CardList);

var _TrackList = require('./TrackList');

var _TrackList2 = _interopRequireDefault(_TrackList);

var _loggingSections = require('../lib/loggingSections');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class CategoryResults extends _react2.default.PureComponent {
  render() {
    const { type, items, loadMoreUri } = this.props;

    return _react2.default.createElement(
      'section',
      {
        className: 'CategoryResults',
        'data-interaction-context': `category-${type}`,
        'data-uiinteraction-section': _loggingSections.LOGGING_SECTIONS[type]
      },
      type === _categoryPageTypes.TRACKS ? _react2.default.createElement(_TrackList2.default, { tracks: items, loadMoreUri: loadMoreUri, type: type, isSortable: true }) : _react2.default.createElement(_CardList2.default, {
        items: items,
        loadMoreUri: loadMoreUri,
        showMetadata: true,
        showPlaylistOwner: true,
        gridClasses: ['col-xs-6', 'col-sm-4', 'col-md-3', 'col-lg-2'],
        type: type,
        isVideo: type === _categoryPageTypes.VIDEOEPISODES
      })
    );
  }
}

exports.default = CategoryResults;
CategoryResults.propTypes = {
  type: _propTypes2.default.string.isRequired,
  items: _propTypes2.default.array.isRequired,
  loadMoreUri: _propTypes2.default.string
};

CategoryResults.defaultProps = {
  type: null,
  items: null,
  loadMoreUri: null
};

},{"../lib/categoryPageTypes":55,"../lib/loggingSections":57,"./CardList":34,"./TrackList":50,"prop-types":495,"react":697}],37:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _classnames = require('classnames');

var _classnames2 = _interopRequireDefault(_classnames);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const EmptyView = ({ icon, title, text, fullView }) => _react2.default.createElement(
  'div',
  {
    className: (0, _classnames2.default)('EmptyView', {
      'EmptyView--full': fullView
    })
  },
  _react2.default.createElement('span', { className: `EmptyView__icon spoticon-${icon}-64` }),
  _react2.default.createElement(
    'h3',
    { className: 'EmptyView__title' },
    title
  ),
  _react2.default.createElement(
    'p',
    { className: 'EmptyView__text' },
    text
  )
);

EmptyView.defaultProps = {
  icon: 'flag',
  title: '',
  text: '',
  fullView: true
};

EmptyView.propTypes = {
  icon: _propTypes2.default.string,
  title: _propTypes2.default.string,
  text: _propTypes2.default.string,
  fullView: _propTypes2.default.bool
};

exports.default = EmptyView;

},{"classnames":376,"prop-types":495,"react":697}],38:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _classnames = require('classnames');

var _classnames2 = _interopRequireDefault(_classnames);

var _GlueHeaderTitle = require('./GlueHeaderTitle');

var _GlueHeaderTitle2 = _interopRequireDefault(_GlueHeaderTitle);

var _GlueHeaderColorBackground = require('./GlueHeaderColorBackground');

var _GlueHeaderColorBackground2 = _interopRequireDefault(_GlueHeaderColorBackground);

var _GlueHeaderImageBackground = require('./GlueHeaderImageBackground');

var _GlueHeaderImageBackground2 = _interopRequireDefault(_GlueHeaderImageBackground);

var _GlueStickyElement = require('../GlueStickyElement');

var _GlueStickyElement2 = _interopRequireDefault(_GlueStickyElement);

var _frameUpdater = require('../../../../../libs/frame-updater');

var _globalConfig = require('../../../../../libs/global-config');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const FAST_SCROLL_THRESHOLD = 30; // This is a copy of zlink/glue/components/GlueHeader
// We decided to move Glue components designed to work in embedded apps inside zlink
// and create copies of them in the iframe apps they are used in.
// This is intended to be temporary and encaurage us to move faster
// towards embedded apps architecture.

const MAX_BACKGROUND_COLOR_OPACITY = 0.4;

class GlueHeader extends _react2.default.PureComponent {
  constructor(...args) {
    super(...args);

    this.state = {
      isSticky: false,
      headerHeight: 0,
      stickyHeight: 0,
      backgroundColorOpacity: 0,
      backgroundImageOpacity: 0,
      backgroundImageBackdropOpacity: 0,
      alphaMask: [48, 72],
      isScrollingFast: false
    };

    this.scrollListenerId = -1;
    this.node = null;

    this.scrollY = 0;
    this.lastScrollY = 0;
    this.scrollPercentage = 0;
    this.scrollDiffs = [0, 0, 0, 0];

    this.onStickyAdd = this.onStickyAdd.bind(this);
    this.onStickyRemove = this.onStickyRemove.bind(this);
  }

  componentDidMount() {
    this.setScrollPosition();
    this.updateHeaderSize();
    this.updateScrollDependantState();

    const scrollNode = this.props.scrollNode || document;
    this.scrollListenerId = (0, _frameUpdater.addDebouncedScrollListener)(scrollNode, () => {
      this.setScrollPosition();
    }, () => {
      this.updateScrollDependantState();
      this.setLastScrollPosition();
    });
  }

  componentDidUpdate() {
    this.updateHeaderSize();
  }

  componentWillUnmount() {
    (0, _frameUpdater.removeDebouncedScrollListener)(this.scrollListenerId);
  }

  onStickyAdd(height) {
    this.setState({
      isSticky: true,
      stickyHeight: height
    });
    this.props.onStickyAdd(height);
  }

  onStickyRemove() {
    this.setState({ isSticky: false });
    this.props.onStickyRemove();
  }

  setScrollPosition() {
    const nodeRect = this.node.getBoundingClientRect();
    const height = nodeRect.height - _globalConfig.TOP_BAR_HEIGHT - this.state.stickyHeight;

    this.scrollY = nodeRect.top;
    if (this.props.scrollNode) {
      const scrollNodeRect = this.props.scrollNode.getBoundingClientRect();
      this.scrollY -= scrollNodeRect.top;
    }

    this.scrollDiffs.push(Math.abs(this.scrollY - this.lastScrollY));
    this.scrollDiffs.shift();

    this.scrollPercentage = 1 - Math.max((height + nodeRect.top) / height, 0);
  }

  setLastScrollPosition() {
    this.lastScrollY = this.scrollY;
  }

  updateHeaderSize() {
    const headerHeight = this.node.offsetHeight;
    if (headerHeight !== this.state.headerHeight) {
      this.setState({
        headerHeight: headerHeight
      });
    }
  }

  updateScrollDependantState() {
    // Optimize to only run header updates when scrolling within the header area
    // and also when the current scroll event is below the header but the previous
    // event was within the header.
    if (this.scrollY < this.state.headerHeight || this.lastScrollY < this.state.headerHeight) {
      const newState = {};
      this.updateBackgroundImageOpacity(newState);
      this.updateBackgroundColorOpacity(newState);
      this.updateScrollFast(newState);
      this.updateHeaderAlphaMask(newState);
      this.setState(newState);
    }
  }

  updateBackgroundImageOpacity(newState) {
    const opacity = Math.round(Math.min(1, this.scrollPercentage * 2) * 1000) / 1000;
    const backdropOpacity = Math.round(this.scrollPercentage * 1000) / 1000;
    newState.backgroundImageOpacity = opacity;
    newState.backgroundImageBackdropOpacity = backdropOpacity;
  }

  updateBackgroundColorOpacity(newState) {
    const opacity = Math.round(this.scrollPercentage * MAX_BACKGROUND_COLOR_OPACITY * 1000) / 1000;
    newState.backgroundColorOpacity = opacity;
  }

  updateHeaderAlphaMask(newState) {
    const maskHeight = 24;
    const offset1 = Math.abs(this.scrollY) + _globalConfig.TOP_BAR_HEIGHT;
    const offset2 = offset1 + maskHeight;
    newState.alphaMask = [offset1, offset2];
  }

  updateScrollFast(newState) {
    const isScrollingFast = this.scrollDiffs.some(diff => {
      return diff > FAST_SCROLL_THRESHOLD;
    });
    newState.isScrollingFast = isScrollingFast;
  }

  render() {
    const {
      backgroundType,
      backgroundColor,
      backgroundImageUrl,
      children,
      scrollNode,
      title,
      useLargeTitle,
      ariaId
    } = this.props;

    const {
      isSticky,
      headerHeight,
      stickyHeight,
      backgroundColorOpacity,
      backgroundImageOpacity,
      backgroundImageBackdropOpacity,
      alphaMask,
      isScrollingFast
    } = this.state;

    return _react2.default.createElement(
      'div',
      {
        ref: node => {
          this.node = node;
        },
        className: (0, _classnames2.default)('GlueHeader', {
          'GlueHeader--with-active-sticky-header': isSticky,
          'GlueHeader--with-fast-scrolling': isScrollingFast
        }),
        'data-ta-id': 'page-header'
      },
      _react2.default.createElement(
        'div',
        {
          className: 'GlueHeader__background',
          style: isSticky ? {
            position: 'fixed',
            top: -(headerHeight - stickyHeight - _globalConfig.TOP_BAR_HEIGHT),
            bottom: 'auto',
            height: headerHeight
          } : {}
        },
        backgroundType === 'color' && _react2.default.createElement(_GlueHeaderColorBackground2.default, {
          color: backgroundColor,
          scrollOpacity: backgroundColorOpacity
        }),
        backgroundType === 'image' && _react2.default.createElement(_GlueHeaderImageBackground2.default, {
          imageUrl: backgroundImageUrl,
          scrollOpacity: backgroundImageOpacity,
          scrollBackdropOpacity: backgroundImageBackdropOpacity
        })
      ),
      _react2.default.createElement(
        'div',
        { className: 'GlueHeader__content-wrapper container',
          style: {
            WebkitMaskImage: `linear-gradient(transparent ${alphaMask[0]}px, black ${alphaMask[1]}px)`
          }
        },
        _react2.default.createElement(
          'div',
          { className: 'GlueHeader__content' },
          children ? _react2.default.createElement(
            'div',
            { className: 'GlueHeader__custom-content' },
            children
          ) : _react2.default.createElement(
            'div',
            { className: 'GlueHeader__content-inner' },
            _react2.default.createElement(
              'div',
              { className: 'GlueHeader__data' },
              _react2.default.createElement(_GlueHeaderTitle2.default, {
                title: title,
                useLargeTitle: useLargeTitle,
                ariaId: ariaId
              })
            ),
            _react2.default.createElement('div', { className: 'GlueHeader__spacer' })
          )
        )
      ),
      _react2.default.createElement(_GlueStickyElement2.default, {
        scrollNode: scrollNode,
        onStickyAdd: this.onStickyAdd,
        onStickyRemove: this.onStickyRemove,
        className: 'GlueHeader__sticky-wrapper',
        renderElement: style => _react2.default.createElement(
          'div',
          {
            className: (0, _classnames2.default)('GlueHeader__sticky', {
              'sticky-top': isSticky
            }),
            style: style,
            'aria-hidden': true
          },
          title ? _react2.default.createElement(
            'div',
            { className: 'container' },
            _react2.default.createElement(
              'div',
              { className: 'GlueHeader__sticky-inner' },
              _react2.default.createElement(
                'h1',
                { className: 'GlueHeader__title' },
                title
              )
            )
          ) : null
        )
      })
    );
  }
}

exports.default = GlueHeader;
GlueHeader.propTypes = {
  backgroundType: _propTypes2.default.oneOf(['color', 'image']),
  backgroundColor: _propTypes2.default.string,
  backgroundImageUrl: _propTypes2.default.string,
  children: _propTypes2.default.node,
  onStickyAdd: _propTypes2.default.func,
  onStickyRemove: _propTypes2.default.func,
  scrollNode: _propTypes2.default.object,
  title: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.object]),
  ariaId: _propTypes2.default.string,
  useLargeTitle: _propTypes2.default.bool
};

GlueHeader.defaultProps = {
  backgroundType: 'color',
  backgroundColor: '#606060',
  backgroundImageUrl: '',
  onStickyAdd() {},
  onStickyRemove() {},
  scrollNode: null,
  title: null,
  ariaId: null,
  useLargeTitle: false
};

},{"../../../../../libs/frame-updater":93,"../../../../../libs/global-config":94,"../GlueStickyElement":43,"./GlueHeaderColorBackground":39,"./GlueHeaderImageBackground":40,"./GlueHeaderTitle":41,"classnames":376,"prop-types":495,"react":697}],39:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class GlueHeaderColorBackground extends _react2.default.PureComponent {
  render() {
    const { color, scrollOpacity } = this.props;

    return _react2.default.createElement(
      'div',
      null,
      _react2.default.createElement('div', {
        className: 'GlueHeader__background-color',
        style: { backgroundColor: color }
      }),
      _react2.default.createElement('div', { className: 'GlueHeader__background-overlay' }),
      _react2.default.createElement('div', { className: 'GlueHeader__background-scroll-overlay',
        style: { opacity: scrollOpacity } })
    );
  }
}

exports.default = GlueHeaderColorBackground;
GlueHeaderColorBackground.propTypes = {
  color: _propTypes2.default.string,
  scrollOpacity: _propTypes2.default.number
};

GlueHeaderColorBackground.defaultProps = {
  color: '#606060',
  scrollOpacity: 1
};

},{"prop-types":495,"react":697}],40:[function(require,module,exports){
(function (global){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _classnames = require('classnames');

var _classnames2 = _interopRequireDefault(_classnames);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class GlueHeaderImageBackground extends _react2.default.PureComponent {
  constructor(...args) {
    super(...args);

    this.state = {
      isLoaded: false
    };
  }

  componentWillMount() {
    this.loadImage(this.props.imageUrl);
  }

  componentWillReceiveProps(nextProps) {
    if (nextProps.imageUrl !== this.props.imageUrl) {
      this.loadImage(nextProps.imageUrl);
    }
  }

  loadImage(imageUrl) {
    this.setState({ isLoaded: false });

    const image = new global.Image();

    image.onload = () => {
      if (this.props.imageUrl === imageUrl) {
        this.setState({ isLoaded: true });
      }
    };

    image.src = imageUrl;
  }

  render() {
    const { imageUrl, scrollOpacity, scrollBackdropOpacity } = this.props;
    const { isLoaded } = this.state;

    return _react2.default.createElement(
      'div',
      null,
      _react2.default.createElement(
        'div',
        {
          className: (0, _classnames2.default)('GlueHeader__background-image-loader', {
            'GlueHeader__background-image-loader--is-loaded': isLoaded,
            'GlueHeader__background-image-loader--with-loading-animation': isLoaded
          })
        },
        _react2.default.createElement('div', {
          className: 'GlueHeader__background-image',
          style: imageUrl ? {
            backgroundImage: `url(${imageUrl})`
          } : {},
          'data-ta-id': 'page-header-background-image'
        })
      ),
      _react2.default.createElement('div', { className: 'GlueHeader__background-overlay' }),
      _react2.default.createElement('div', { className: 'GlueHeader__background-image-overlay-gradient' }),
      _react2.default.createElement('div', { className: 'GlueHeader__background-scroll-overlay-ellipse-backdrop',
        style: { opacity: scrollBackdropOpacity } }),
      _react2.default.createElement('div', { className: 'GlueHeader__background-scroll-overlay-ellipse',
        style: { opacity: scrollOpacity } })
    );
  }
}

exports.default = GlueHeaderImageBackground;
GlueHeaderImageBackground.propTypes = {
  imageUrl: _propTypes2.default.string,
  scrollOpacity: _propTypes2.default.number,
  scrollBackdropOpacity: _propTypes2.default.number
};

GlueHeaderImageBackground.defaultProps = {
  imageUrl: '',
  scrollOpacity: 1,
  scrollBackdropOpacity: 1
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"classnames":376,"prop-types":495,"react":697}],41:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _reactDom = require('react-dom');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// There is a bottom padding in the title element, to allow the bottom border
// of links to be rendered correctly. This number here is specified as a
// percentage of the height of a single line.
const PADDING_BOTTOM_PERCENTAGE = 0.07;
function getSizeSpecs() {
  // Some characters in Thai are too big and get cropped at the top.
  if (window.__spotify && window.__spotify.locale === 'th') {
    return {
      default: {
        fontSizes: [[48, 36], [36, 28]],
        lineHeights: [[75, 58], [58, 44]]
      },
      large: {
        fontSizes: [[96, 72, 48], [48, 36, 28]],
        lineHeights: [[148, 111, 75], [75, 58, 44]]
      }
    };
  }
  return {
    default: {
      fontSizes: [[48, 36], [36, 28]],
      lineHeights: [[56, 44], [44, 36]]
    },
    large: {
      fontSizes: [[96, 72, 48], [48, 36, 28]],
      lineHeights: [[110, 82, 56], [56, 44, 36]]
    }
  };
}

class GlueHeaderTitle extends _react2.default.PureComponent {
  constructor(props) {
    super(props);

    this.state = {
      isFontsLoaded: false,
      titleAttr: false,
      sizeSpecId: this.props.useLargeTitle ? 'large' : 'default',
      titleTypeSize: this._getInitialTitleTypography()
    };

    this.sizeIndex = 0;

    this._resizeHandler = this._resizeHandler.bind(this);
    this._setTitleTypography = this._setTitleTypography.bind(this);
  }

  componentWillMount() {
    this._loadFont().then(() => this.setState({ isFontsLoaded: true }));
  }

  componentDidMount() {
    window.addEventListener('resize', this._resizeHandler);
  }

  componentDidUpdate(prevProps) {
    if (prevProps.title !== this.props.title || prevProps.useLargeTitle !== this.props.useLargeTitle) {
      this._resetTitleTypography();
    } else {
      this._setTitleTypography();
    }
  }

  componentWillUnmount() {
    window.removeEventListener('resize', this._resizeHandler);
  }

  _loadFont() {
    return document.fonts.load('500 48px spotify-circular');
  }

  _getInitialTitleTypography() {
    const sizeSpecId = this.props.useLargeTitle ? 'large' : 'default';
    const { fontSizes, lineHeights } = getSizeSpecs()[sizeSpecId];

    const lineCount = 1;
    const fontSize = fontSizes[0][0];
    const lineHeight = lineHeights[0][0];
    const lastBottomPadding = Math.ceil(PADDING_BOTTOM_PERCENTAGE * lineHeight);

    return {
      fontSize,
      lineCount,
      lineHeight,
      lastBottomPadding
    };
  }

  _resetTitleTypography() {
    this.setState({
      sizeSpecId: this.props.useLargeTitle ? 'large' : 'default',
      titleTypeSize: this._getInitialTitleTypography()
    });

    this.sizeIndex = 0;
  }

  _setTitleTypography() {
    let { titleAttr, titleTypeSize } = this.state;

    let { fontSize, lineCount, lineHeight, lastBottomPadding } = titleTypeSize;

    const { fontSizes, lineHeights } = getSizeSpecs()[this.state.sizeSpecId];

    const node = (0, _reactDom.findDOMNode)(this);
    if (lineCount <= fontSizes.length && node.offsetHeight - lastBottomPadding > lineHeight * lineCount) {
      this.sizeIndex++;

      if (!fontSizes[lineCount - 1][this.sizeIndex]) {
        this.sizeIndex = 0;
        lineCount++;
      }

      if (lineCount <= fontSizes.length) {
        fontSize = fontSizes[lineCount - 1][this.sizeIndex];
        lineHeight = lineHeights[lineCount - 1][this.sizeIndex];
        lastBottomPadding = Math.ceil(PADDING_BOTTOM_PERCENTAGE * lineHeight);

        titleAttr = false;
        titleTypeSize = {
          fontSize,
          lineCount,
          lineHeight,
          lastBottomPadding,
          renderedLineCount: null
        };
      }
    }

    if (lineCount > fontSizes.length) {
      // Truncate and add title attribute if the text still doesn't fit
      titleAttr = node.textContent.trim();
      titleTypeSize.renderedLineCount = lineCount - 1;
    }

    this.setState({
      titleAttr,
      titleTypeSize
    });
  }

  _resizeHandler() {
    requestAnimationFrame(() => {
      this.sizeIndex = 0;
      this.setState({
        titleTypeSize: this._getInitialTitleTypography()
      });
    });
  }

  render() {
    const {
      title,
      uri,
      ariaId,
      enableContextMenu,
      enableDragging
    } = this.props;

    const { titleAttr, titleTypeSize } = this.state;

    const nodeStyles = {
      WebkitLineClamp: titleTypeSize.renderedLineCount,
      fontSize: `${titleTypeSize.fontSize}px`,
      lineHeight: `${titleTypeSize.lineHeight}px`,
      paddingBottom: `${titleTypeSize.lastBottomPadding}px`,
      marginBottom: `-${titleTypeSize.lastBottomPadding}px`
    };

    const props = {
      'data-ta-id': 'page-header-title'
    };

    if (uri) {
      props['data-uri'] = uri;
    }

    if (enableContextMenu) {
      props['data-contextmenu'] = true;
    }

    if (enableDragging) {
      props.draggable = true;
    }

    if (titleAttr) {
      props.title = titleAttr;
    }

    if (ariaId) {
      props.id = ariaId;
    }

    return _react2.default.createElement(
      'h1',
      _extends({}, props, { className: 'GlueHeader__title', style: nodeStyles }),
      title
    );
  }
}

exports.default = GlueHeaderTitle;
GlueHeaderTitle.propTypes = {
  enableContextMenu: _propTypes2.default.bool,
  enableDragging: _propTypes2.default.bool,
  title: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.object]).isRequired,
  uri: _propTypes2.default.string,
  ariaId: _propTypes2.default.string,
  useLargeTitle: _propTypes2.default.bool
};

GlueHeaderTitle.defaultProps = {
  enableContextMenu: false,
  enableDragging: false,
  title: null,
  uri: null,
  ariaId: null,
  useLargeTitle: false
};

},{"prop-types":495,"react":697,"react-dom":530}],42:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _GlueHeader = require('./GlueHeader');

Object.defineProperty(exports, 'default', {
  enumerable: true,
  get: function () {
    return _interopRequireDefault(_GlueHeader).default;
  }
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

},{"./GlueHeader":38}],43:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _frameUpdater = require('../../../../libs/frame-updater');

var _globalConfig = require('../../../../libs/global-config');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class GlueStickyElement extends _react2.default.PureComponent {
  constructor(...args) {
    super(...args);

    this.state = {
      isSticky: false,
      offsetTop: 0,
      offsetLeft: 0,
      offsetRight: 0,
      height: 0
    };

    this.listenerId = -1;
    this.node = null;
    this.nodeRect = null;
    this.scrollNodeRect = null;
  }

  componentDidMount() {
    this.updateSticky();

    const scrollNode = this.props.scrollNode || document;

    this.listenerId = (0, _frameUpdater.addDebouncedScrollListener)(scrollNode, () => {
      const rect = this.node.getBoundingClientRect();
      this.nodeRect = {
        top: rect.top,
        right: rect.right,
        bottom: rect.bottom,
        left: rect.left,
        width: rect.width,
        height: rect.height
      };

      if (this.props.scrollNode) {
        this.scrollNodeRect = this.props.scrollNode.getBoundingClientRect();
      }
    }, () => {
      this.updateSticky();
    });
  }

  componentDidUpdate() {
    this.updateSticky();
  }

  componentWillUnmount() {
    (0, _frameUpdater.removeDebouncedScrollListener)(this.listenerId);
  }

  updateSticky() {
    if (!this.node || !this.nodeRect) {
      return;
    }

    const height = this.nodeRect.height;
    let {
      top,
      left,
      right
    } = this.nodeRect;
    let scrollAreaWidth = document.documentElement.offsetWidth;

    if (this.scrollNodeRect) {
      const offsetX = this.scrollNodeRect.left;
      const offsetY = this.scrollNodeRect.top;
      top -= offsetY;
      left -= offsetX;
      right -= offsetX;
      scrollAreaWidth = this.scrollNodeRect.width;
    }

    if (top <= this.props.offset + _globalConfig.TOP_BAR_HEIGHT) {
      const wasSticky = this.state.isSticky;

      this.setState({
        isSticky: true,
        offsetTop: this.props.offset + _globalConfig.TOP_BAR_HEIGHT,
        offsetLeft: left,
        offsetRight: scrollAreaWidth - right,
        height: height
      }, () => {
        // This has to happen after state is set, since calling this function
        // might result in a new render cycle and that would then look at old
        // values from the state if the function was called before state was
        // set.
        if (!wasSticky) {
          this.props.onStickyAdd(height);
        }
      });
    } else if (this.state.isSticky) {
      this.setState({
        isSticky: false,
        offsetTop: 0,
        offsetLeft: 0,
        offsetRight: 0,
        height: 0
      }, () => {
        // This has to happen after state is set, since calling this function
        // might result in a new render cycle and that would then look at old
        // values from the state if the function was called before state was
        // set.
        this.props.onStickyRemove();
      });
    }
  }

  render() {
    const {
      className,
      renderElement
    } = this.props;

    const {
      isSticky,
      offsetTop,
      offsetLeft,
      offsetRight,
      height
    } = this.state;

    return _react2.default.createElement(
      'div',
      {
        ref: node => {
          this.node = node;
        },
        className: className,
        style: isSticky ? { height: height } : {}
      },
      renderElement(isSticky ? {
        position: 'fixed',
        top: offsetTop,
        left: offsetLeft,
        right: offsetRight
      } : {})
    );
  }

}

exports.default = GlueStickyElement;
GlueStickyElement.propTypes = {
  className: _propTypes2.default.string,
  offset: _propTypes2.default.number,
  onStickyAdd: _propTypes2.default.func,
  onStickyRemove: _propTypes2.default.func,
  renderElement: _propTypes2.default.func,
  scrollNode: _propTypes2.default.object
};

GlueStickyElement.defaultProps = {
  className: '',
  offset: 0,
  onStickyAdd() {},
  onStickyRemove() {},
  renderElement() {},
  scrollNode: null
};

},{"../../../../libs/frame-updater":93,"../../../../libs/global-config":94,"prop-types":495,"react":697}],44:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _GlueHeader = require('./GlueHeader');

var _GlueHeader2 = _interopRequireDefault(_GlueHeader);

var _i18n = require('../../i18n');

var _i18n2 = _interopRequireDefault(_i18n);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const renderTitleHighlight = query => `<span class="Header__title--highlight">${query}</span>`;

const renderSearchResultsTitleHtml = (query, category) => {
  const translationKey = category ? `header.${category}ResultsTitle` : 'header.allResultsTitle';
  return _react2.default.createElement('span', {
    className: 'Header__title',
    dangerouslySetInnerHTML: { __html: _i18n2.default.get(translationKey, renderTitleHighlight(query)) }
  });
};

const Header = ({ query, category }) => {
  const title = query ? renderSearchResultsTitleHtml(query, category) : _i18n2.default.get('header.recentlySearchedTitle');

  const ariaId = query ? `section-${category}` : 'section-recently-searched';

  return _react2.default.createElement(_GlueHeader2.default, { title: title, ariaId: ariaId });
};

Header.propTypes = {
  query: _propTypes2.default.string,
  category: _propTypes2.default.string
};

Header.defaultProps = {
  query: null,
  category: null
};

exports.default = Header;

},{"../../i18n":1,"./GlueHeader":42,"prop-types":495,"react":697}],45:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _SearchSection = require('./SearchSection');

var _SearchSection2 = _interopRequireDefault(_SearchSection);

var _TrackList = require('./TrackList');

var _TrackList2 = _interopRequireDefault(_TrackList);

var _searchPropTypes = require('../searchPropTypes');

var _i18n = require('../../i18n');

var _i18n2 = _interopRequireDefault(_i18n);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const LocalFiles = ({ type, hits }) => _react2.default.createElement(
  _SearchSection2.default,
  { title: _i18n2.default.get('localFiles'), type: type },
  _react2.default.createElement(_TrackList2.default, { tracks: hits, type: type, isSortable: true })
);

LocalFiles.propTypes = {
  type: _propTypes2.default.string.isRequired,
  hits: _propTypes2.default.arrayOf(_searchPropTypes.trackShape).isRequired
};

LocalFiles.defaultProps = {
  type: null,
  hits: null
};

exports.default = LocalFiles;

},{"../../i18n":1,"../searchPropTypes":73,"./SearchSection":47,"./TrackList":50,"prop-types":495,"react":697}],46:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.RecentlySearched = undefined;

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _reactRedux = require('react-redux');

var _actions = require('../actions');

var _actions2 = _interopRequireDefault(_actions);

var _CardList = require('./CardList');

var _CardList2 = _interopRequireDefault(_CardList);

var _i18n = require('../../i18n');

var _i18n2 = _interopRequireDefault(_i18n);

var _center = require('../../../../libs/spotify-events/center');

var _center2 = _interopRequireDefault(_center);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class RecentlySearched extends _react2.default.PureComponent {
  constructor(...args) {
    super(...args);
    this.handleRemove = this.handleRemove.bind(this);
  }

  componentDidMount() {
    _center2.default.on('card-remove', this.handleRemove);
  }

  componentWillUnmount() {
    _center2.default.off('card-remove', this.handleRemove);
  }

  handleRemove(event) {
    this.props.removeItem(event.uri);
    this.props.logInteraction(event.element, 'click');
  }

  render() {
    const { items, removeAllItems } = this.props;

    return items.length ? _react2.default.createElement(
      'div',
      {
        className: 'RecentlySearched',
        'data-interaction-context': 'recently-searched',
        'data-uiinteraction-section': 'history'
      },
      _react2.default.createElement(_CardList2.default, {
        items: items,
        ignoreClicks: true,
        showTypeMetadata: true,
        showRemoveButtons: true,
        withHorizontalCards: true,
        gridClasses: ['col-xs-12'],
        type: 'recently-searched'
      }),
      _react2.default.createElement(
        'button',
        {
          className: 'RecentlySearched__clear-all-button button button-with-stroke',
          'data-interaction-target': 'clear-button',
          'data-interaction-intent': 'clear-all',
          onClick: () => removeAllItems(),
          type: 'button'
        },
        _i18n2.default.get('recentlySearched.clearRecentSearches')
      )
    ) : null;
  }
}

exports.RecentlySearched = RecentlySearched;
RecentlySearched.propTypes = {
  items: _propTypes2.default.array.isRequired,
  removeAllItems: _propTypes2.default.func,
  removeItem: _propTypes2.default.func,
  logInteraction: _propTypes2.default.func
};

RecentlySearched.defaultProps = {
  items: null,
  removeAllItems: () => {},
  removeItem: () => {},
  logInteraction: () => {}
};

const mapStateToProps = () => ({});

const mapDispatchToProps = dispatch => ({
  removeItem: data => dispatch(_actions2.default.removeRecent(data)),
  removeAllItems: data => dispatch(_actions2.default.removeAllRecent(data)),
  logInteraction: (target, type) => dispatch(_actions2.default.logInteraction(target, type))
});

exports.default = (0, _reactRedux.connect)(mapStateToProps, mapDispatchToProps)(RecentlySearched);

},{"../../../../libs/spotify-events/center":262,"../../i18n":1,"../actions":27,"./CardList":34,"prop-types":495,"react":697,"react-redux":666}],47:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _i18n = require('../../i18n');

var _i18n2 = _interopRequireDefault(_i18n);

var _loggingSections = require('../lib/loggingSections');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const SearchSection = ({ title, type, children, seeMoreUri = null }) => _react2.default.createElement(
  'section',
  {
    className: 'SearchSection',
    'data-ta-type': type,
    'data-interaction-context': `section-${type}`,
    'data-uiinteraction-section': _loggingSections.LOGGING_SECTIONS[type]
  },
  _react2.default.createElement(
    'div',
    { className: 'section-divider' },
    _react2.default.createElement(
      'h2',
      { className: 'SearchSection__title', id: `section-${type}` },
      seeMoreUri ? _react2.default.createElement(
        'a',
        { className: 'SearchSection__link', href: encodeURI(seeMoreUri), 'data-interaction-target': 'section-title' },
        title
      ) : title
    ),
    seeMoreUri && _react2.default.createElement(
      'div',
      { className: 'section-auxiliary' },
      _react2.default.createElement(
        'a',
        {
          className: 'SearchSection__link',
          href: encodeURI(seeMoreUri),
          'data-interaction-target': 'see-more-link',
          'aria-label': _i18n2.default.get(`see_all_${type}`)
        },
        _i18n2.default.get('see_all')
      )
    )
  ),
  _react2.default.createElement(
    'div',
    { className: 'SearchSection__content' },
    children
  )
);

SearchSection.propTypes = {
  title: _propTypes2.default.string.isRequired,
  type: _propTypes2.default.string.isRequired,
  children: _propTypes2.default.node.isRequired,
  seeMoreUri: _propTypes2.default.string
};

SearchSection.defaultProps = {
  title: null,
  type: null,
  children: null,
  seeMoreUri: null
};

exports.default = SearchSection;

},{"../../i18n":1,"../lib/loggingSections":57,"prop-types":495,"react":697}],48:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _react = require("react");

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const Throbber = () => _react2.default.createElement(
  "div",
  { id: "throbber", className: "Throbber" },
  _react2.default.createElement(
    "div",
    { className: "throbber-initial" },
    _react2.default.createElement("div", null)
  )
);

exports.default = Throbber;

},{"react":697}],49:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TopResultsSection = undefined;

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _reactRedux = require('react-redux');

var _actions = require('../actions');

var _actions2 = _interopRequireDefault(_actions);

var _GlueHeader = require('./GlueHeader');

var _GlueHeader2 = _interopRequireDefault(_GlueHeader);

var _Carousel = require('./Carousel');

var _Carousel2 = _interopRequireDefault(_Carousel);

var _classnames = require('classnames');

var _classnames2 = _interopRequireDefault(_classnames);

var _convertToGlueCardData = require('../lib/convertToGlueCardData');

var _convertToGlueCardData2 = _interopRequireDefault(_convertToGlueCardData);

var _i18n = require('../../i18n');

var _i18n2 = _interopRequireDefault(_i18n);

var _GlueHandlebarsTemplate = require('../../../../libs/glue/components/GlueHandlebarsTemplate');

var _GlueHandlebarsTemplate2 = _interopRequireDefault(_GlueHandlebarsTemplate);

var _card = require('../../../../libs/glue/templates/cards/card.hbs');

var _card2 = _interopRequireDefault(_card);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const gridClasses = {
  // On x-small and small, topHit actually stands alone as fitting 4 topRecs
  // next to it would be cramped. So what limitats is more the vertical space.
  topHit: ['col-xs-4', 'col-sm-3', 'col-md-2'],
  // From medium on, topRecs stand next to topHit. Distributing 4 cards over
  // 9 columns is actually off grid, but if we want to elevate the topHit it's
  // the option that looks best.
  topRecommendations: ['col-xs-8', 'col-sm-9', 'col-md-8', 'col-md-push-1']
};

class TopResultsSection extends _react2.default.PureComponent {
  constructor(...args) {
    super(...args);

    this.handleClick = this.handleClick.bind(this);
  }

  handleClick(event) {
    const { topHit } = this.props.topResults;
    const element = event.target.closest('[data-uri]');
    const uri = element && element.dataset.uri;
    if (uri) {
      this.props.saveRecent(topHit.hits[0]);
    }
  }

  render() {
    const { topHit, topRecommendations } = this.props.topResults;

    const topHitSection = topHit ? _react2.default.createElement(
      'div',
      {
        className: (0, _classnames2.default)('TopResultsSection__top-hit', ...gridClasses.topHit),
        onClick: this.handleClick
      },
      _react2.default.createElement(
        'section',
        {
          className: 'TopResultsSection__section',
          'data-interaction-context': 'top-result',
          'data-uiinteraction-section': 'top-results'
        },
        _react2.default.createElement(
          'div',
          { className: 'TopResultsSection__section-divider' },
          _react2.default.createElement(
            'h2',
            { className: 'TopResultsSection__section-title text-center' },
            _i18n2.default.get('topHit')
          )
        ),
        _react2.default.createElement(_GlueHandlebarsTemplate2.default, {
          template: _card2.default,
          data: (0, _convertToGlueCardData2.default)(topHit.hits[0], {
            includeTypeMetadata: true,
            playButtonOnly: true
          })
        })
      )
    ) : null;

    const topRecommendationsType = 'toprecommendations';
    const carouselId = `carousel-${topRecommendationsType}`;
    const topRecommendationsSection = topRecommendations ? _react2.default.createElement(
      'div',
      { className: (0, _classnames2.default)(...gridClasses.topRecommendations) },
      _react2.default.createElement(
        'section',
        {
          className: 'TopResultsSection__section',
          'data-interaction-context': 'top-recommendations',
          'data-uiinteraction-section': 'top-recs-content-results'
        },
        _react2.default.createElement(
          'div',
          { className: 'TopResultsSection__section-divider' },
          _react2.default.createElement(
            'h2',
            { className: 'TopResultsSection__section-title', id: `section-${topRecommendationsType}` },
            topRecommendations.title || _i18n2.default.get('topRecommendations', topHit.hits[0].name)
          ),
          _react2.default.createElement(
            'div',
            { className: 'TopResultsSection__section-auxiliary', 'data-interaction-context': 'carousel-controls' },
            _react2.default.createElement('button', {
              className: 'button button-icon-only spoticon-chevron-left-16',
              'data-carousel': carouselId,
              'data-button': 'carousel-left',
              'data-interaction-target': 'left-button',
              'data-interaction-intent': 'slide-left',
              'aria-hidden': true
            }),
            _react2.default.createElement('button', {
              className: 'button button-icon-only spoticon-chevron-right-16',
              'data-carousel': carouselId,
              'data-button': 'carousel-right',
              'data-interaction-target': 'right-button',
              'data-interaction-intent': 'slide-right',
              'aria-hidden': true
            })
          )
        ),
        _react2.default.createElement(_Carousel2.default, {
          items: topRecommendations.hits,
          showMetadata: true,
          onlyPlayButtonOnCards: true,
          type: topRecommendationsType
        })
      )
    ) : null;

    return _react2.default.createElement(
      _GlueHeader2.default,
      null,
      _react2.default.createElement(
        'h1',
        { className: 'glue-hidden-visually' },
        _i18n2.default.get('header.searchResultsTitle')
      ),
      _react2.default.createElement(
        'div',
        { className: 'row' },
        topHitSection,
        topRecommendationsSection
      )
    );
  }
}

exports.TopResultsSection = TopResultsSection;
TopResultsSection.propTypes = {
  topResults: _propTypes2.default.object.isRequired,
  saveRecent: _propTypes2.default.func
};

TopResultsSection.defaultProps = {
  topResults: null,
  saveRecent: () => {}
};

const mapStateToProps = state => ({
  topResults: (() => {
    const results = state.results;
    if (!results.categories || !results.categories.all) {
      return null;
    }

    const { entities } = results.categories.all;
    return {
      topHit: entities.topHit,
      topRecommendations: entities.topRecommendations
    };
  })()
});

const mapDispatchToProps = dispatch => ({
  saveRecent: data => dispatch(_actions2.default.saveRecent(data))
});

exports.default = (0, _reactRedux.connect)(mapStateToProps, mapDispatchToProps)(TopResultsSection);

},{"../../../../libs/glue/components/GlueHandlebarsTemplate":95,"../../../../libs/glue/templates/cards/card.hbs":124,"../../i18n":1,"../actions":27,"../lib/convertToGlueCardData":56,"./Carousel":35,"./GlueHeader":42,"classnames":376,"prop-types":495,"react":697,"react-redux":666}],50:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TrackList = exports.getRowsFromProps = exports.getContextUri = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _reactRedux = require('react-redux');

var _actions = require('../actions');

var _actions2 = _interopRequireDefault(_actions);

var _live = require('../../../../libs/live');

var _live2 = _interopRequireDefault(_live);

var _searchPropTypes = require('../searchPropTypes');

var _GlueHandlebarsTemplate = require('../../../../libs/glue/components/GlueHandlebarsTemplate');

var _GlueHandlebarsTemplate2 = _interopRequireDefault(_GlueHandlebarsTemplate);

var _tracklistSearch = require('../../../../libs/glue/templates/tracklist-search.hbs');

var _tracklistSearch2 = _interopRequireDefault(_tracklistSearch);

var _tracklistSearchTrackContextRows = require('../legacy-templates/tracklist-search--track-context-rows.hbs');

var _tracklistSearchTrackContextRows2 = _interopRequireDefault(_tracklistSearchTrackContextRows);

var _tracklistSearchRow = require('../../../../libs/glue/templates/tracklist-search-row.hbs');

var _tracklistSearchRow2 = _interopRequireDefault(_tracklistSearchRow);

var _center = require('../../../../libs/spotify-events/center');

var _center2 = _interopRequireDefault(_center);

var _liveSortUri = require('../../../../libs/live-sort-uri');

var _liveSortUri2 = _interopRequireDefault(_liveSortUri);

var _spotifyEvents = require('../../../../libs/spotify-events');

var _spotifyEvents2 = _interopRequireDefault(_spotifyEvents);

var _player = require('../../../../libs/spotify-events/player');

var _player2 = _interopRequireDefault(_player);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const INFINITE_LOADER_THRESHOLD = 300;
const PLAYER_REG_EXP = /^spotify:player$/;

const trackContextRowSelectors = { selectorListRow: '[data-context][data-list-item]' };

const getContextUri = exports.getContextUri = ({ limit, query }) => {
  return `spotify:internal:search:tracklist:${encodeURIComponent(`${query}-${limit || 'all'}`)}`;
};

const getRowsFromProps = exports.getRowsFromProps = ({ limit, tracks }) => {
  const displayedTracks = typeof limit === 'number' ? tracks.slice(0, limit) : tracks;

  return displayedTracks.map(track => ({
    track: _extends({}, track, {
      // This enables the first sort of the popularity column to be descending
      // (most popular at the top)
      negPopularity: -1 * track.popularity
    })
  }));
};

class TrackList extends _react2.default.PureComponent {
  constructor(...args) {
    super(...args);
    this.handleScroll = this.handleScroll.bind(this);
    this.handlePlayback = this.handlePlayback.bind(this);
    this.onListSwap = this.onListSwap.bind(this);
    this.onScrollRequest = this.onScrollRequest.bind(this);
    this.scrollContainer = null;

    this.updateComponent(this.props);
    this.state = this.getStateFromProps(this.props);
    this.updateLiveObject();
  }

  componentDidMount() {
    this.scrollContainer = this.node ? this.node.querySelector('[data-scroll-container]') : null;

    _live2.default.subscribe(PLAYER_REG_EXP, 'play', this.handlePlayback);
    window.addEventListener('scroll', this.handleScroll);

    // Make sure dblclick and pressing enter on selected track rows works. This is here temporarily
    // for https://abtesting.spotify.net/features/2663.
    // We need it because only for this test cell the track row is a play context itself.
    // @danfooo will serisouly do his best to kill this when we can.
    // Also this means having more than one <TrackList> can be problematic, but we dont have that.
    _player2.default.setSelectors(this.props.trackContextRows ? trackContextRowSelectors : {});

    if (this.useScrollManager) {
      _center2.default.on('scroll-request', this.onScrollRequest);
    }
    _center2.default.on('list-swap', this.onListSwap);
  }

  componentWillReceiveProps(nextProps) {
    this.setState({ isLoading: false });
    if (this.props === nextProps) return;

    this.updateComponent(nextProps);
    this.setState(this.getStateFromProps(nextProps));
    this.updateLiveObject();

    this.setState({
      rows: this.useScrollManager ? null : this.rows
    });
  }

  componentDidUpdate() {
    this.scrollContainer = this.node ? this.node.querySelector('[data-scroll-container]') : null;

    if (this.scrollContainer) {
      _center2.default.emit('scroll-reset', this.scrollContainer, this.rows.length);
    }

    this.props.updateSpotifyEvents();
  }

  componentWillUnmount() {
    window.removeEventListener('scroll', this.handleScroll);
    _live2.default.unsubscribe(PLAYER_REG_EXP, 'play', this.handlePlayback);
    if (this.useScrollManager) {
      _center2.default.off('scroll-request', this.onScrollRequest);
    }
    _center2.default.off('list-swap', this.onListSwap);
  }

  onListSwap(event) {
    const parsedUri = _liveSortUri2.default.parse(event.before);
    const listSwapTracklistUri = parsedUri && parsedUri.originUri || event.before;

    // Throw away listSwap events that don't match this list
    if (listSwapTracklistUri !== this.tracklistUri) {
      return;
    }

    // Disable fetching more for sorted tracklist
    this.shouldLoadMore = this.tracklistUri === event.after;
    this.updateListFromUri(event.after);
  }

  onScrollRequest(container, range, callback) {
    if (container !== this.scrollContainer) return;

    const rowsToRender = [];

    for (let i = range.start; i < range.end; i++) {
      const tbody = document.createElement('tbody');
      const row = this.rows[i] || { track: {} };

      tbody.innerHTML = (0, _tracklistSearchRow2.default)({
        track: row.track,
        index: i.toString()
      });

      rowsToRender.push(tbody.firstChild);
    }

    callback(null, rowsToRender, this.rows.length);
  }

  getStateFromProps(props) {
    return {
      uri: this.tracklistUri,
      isLoading: false,
      sortable: props.isSortable || false,
      rows: this.useScrollManager ? null : this.rows
    };
  }

  updateComponent(props) {
    this.shouldLoadMore = !!props.loadMoreUri;
    this.tracklistUri = getContextUri(props);
    this.useScrollManager = typeof props.limit !== 'number' || props.limit > 20;
    this.rows = getRowsFromProps(props);
  }

  updateLiveObject() {
    const rowsList = (0, _live2.default)(this.state.uri).get('rows');

    if (rowsList) {
      // If rows for the given uri already exist replace them with the latest rows.
      rowsList.update([{
        type: 'remove',
        index: 0,
        length: rowsList.length
      }, {
        type: 'insert',
        index: 0,
        values: this.rows,
        keys: this.rows.map(row => row.track.uri)
      }]);
    } else {
      (0, _live2.default)(this.tracklistUri).update({
        rows: this.rows
      });
    }
  }

  updateListFromUri(uri) {
    (0, _live2.default)(uri).query('rows(track(name,uri,duration,popularity,negPopularity,explicit,local,artists(name,uri,local),album(name,uri,local)))', (error, data) => {
      if (error) throw error;

      this.rows = data.rows;
      this.setState({ uri });

      _center2.default.emit('scroll-reset', this.scrollContainer, this.rows.length);
    });
  }

  handleScroll() {
    const { fetchMoreCategoryResults, loadMoreUri } = this.props;
    if (!loadMoreUri || this.state.isLoading || !this.props.isOnline || !this.shouldLoadMore) {
      return;
    }

    if (window.pageYOffset + window.innerHeight > document.body.scrollHeight - INFINITE_LOADER_THRESHOLD) {
      this.setState({ isLoading: true });
      fetchMoreCategoryResults(loadMoreUri);
    }
  }

  handlePlayback(model, event) {
    if (event.context === getContextUri(this.props)) {
      this.props.saveRecent(this.props.tracks[event.index]);
    }
  }

  render() {
    const { trackContextRows } = this.props;
    return _react2.default.createElement(
      'div',
      {
        ref: node => {
          this.node = node;
        }
      },
      _react2.default.createElement(_GlueHandlebarsTemplate2.default, {
        template: trackContextRows ? _tracklistSearchTrackContextRows2.default : _tracklistSearch2.default,
        data: _extends({}, this.state, {
          ariaLabel: `section-${this.props.type}`
        })
      }),
      this.state.isLoading ? _react2.default.createElement(
        'div',
        { className: 'TrackList__throbber throbber' },
        _react2.default.createElement('div', null)
      ) : null
    );
  }
}

exports.TrackList = TrackList;
TrackList.propTypes = {
  query: _propTypes2.default.string.isRequired,
  type: _propTypes2.default.string.isRequired,
  isOnline: _propTypes2.default.bool.isRequired,
  tracks: _propTypes2.default.arrayOf(_searchPropTypes.trackShape).isRequired,
  isSortable: _propTypes2.default.bool,
  limit: _propTypes2.default.number,
  loadMoreUri: _propTypes2.default.string,
  updateSpotifyEvents: _propTypes2.default.func,
  saveRecent: _propTypes2.default.func,
  fetchMoreCategoryResults: _propTypes2.default.func,
  trackContextRows: _propTypes2.default.bool
};

TrackList.defaultProps = {
  query: null,
  type: null,
  isOnline: null,
  tracks: null,
  isSortable: false,
  limit: null,
  loadMoreUri: null,
  updateSpotifyEvents: () => {},
  saveRecent: () => {},
  fetchMoreCategoryResults: () => {},
  trackContextRows: false
};

const mapStateToProps = state => ({
  query: state.query.text,
  isOnline: state.app.online
});

const mapDispatchToProps = dispatch => ({
  updateSpotifyEvents: () => _spotifyEvents2.default.update(),
  fetchMoreCategoryResults: uri => dispatch(_actions2.default.fetchMoreCategoryResults(uri)),
  saveRecent: data => dispatch(_actions2.default.saveRecent(data))
});

exports.default = (0, _reactRedux.connect)(mapStateToProps, mapDispatchToProps)(TrackList);

},{"../../../../libs/glue/components/GlueHandlebarsTemplate":95,"../../../../libs/glue/templates/tracklist-search-row.hbs":131,"../../../../libs/glue/templates/tracklist-search.hbs":132,"../../../../libs/live":210,"../../../../libs/live-sort-uri":208,"../../../../libs/spotify-events":301,"../../../../libs/spotify-events/center":262,"../../../../libs/spotify-events/player":309,"../actions":27,"../legacy-templates/tracklist-search--track-context-rows.hbs":53,"../searchPropTypes":73,"prop-types":495,"react":697,"react-redux":666}],51:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = configureStore;

var _redux = require('redux');

var _reduxThunk = require('redux-thunk');

var _reduxThunk2 = _interopRequireDefault(_reduxThunk);

var _reduxLogger = require('redux-logger');

var _reduxLogger2 = _interopRequireDefault(_reduxLogger);

var _reducers = require('./reducers');

var _reducers2 = _interopRequireDefault(_reducers);

var _middlewares = require('./middlewares');

var _middlewares2 = _interopRequireDefault(_middlewares);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Used for debug.
// Log all data dispatched through the store.
const LOG_DISPATCH = false;

function configureStore() {
  const middlewares = [_reduxThunk2.default, ..._middlewares2.default];

  if (LOG_DISPATCH) {
    middlewares.push((0, _reduxLogger2.default)());
  }

  return (0, _redux.createStore)((0, _reducers2.default)(), undefined, (0, _redux.applyMiddleware)(...middlewares));
}

},{"./middlewares":63,"./reducers":69,"redux":709,"redux-logger":702,"redux-thunk":703}],52:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template({"1":function(container,depth0,helpers,partials,data) {
    var helper;

  return container.escapeExpression(((helper = (helper = helpers.name || (depth0 != null ? depth0.name : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : {},{"name":"name","hash":{},"data":data}) : helper)));
},"3":function(container,depth0,helpers,partials,data) {
    var helper;

  return container.escapeExpression(((helper = (helper = helpers.index || (depth0 != null ? depth0.index : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : {},{"name":"index","hash":{},"data":data}) : helper)));
},"5":function(container,depth0,helpers,partials,data) {
    var helper;

  return container.escapeExpression(((helper = (helper = helpers.index || (data && data.index)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : {},{"name":"index","hash":{},"data":data}) : helper)));
},"7":function(container,depth0,helpers,partials,data) {
    var stack1;

  return ((stack1 = helpers["if"].call(depth0 != null ? depth0 : {},((stack1 = (depth0 != null ? depth0.track : depth0)) != null ? stack1.offlineProgress : stack1),{"name":"if","hash":{},"fn":container.program(8, data, 0),"inverse":container.program(13, data, 0),"data":data})) != null ? stack1 : "");
},"8":function(container,depth0,helpers,partials,data) {
    var stack1;

  return ((stack1 = (helpers.compare || (depth0 && depth0.compare) || helpers.helperMissing).call(depth0 != null ? depth0 : {},((stack1 = (depth0 != null ? depth0.track : depth0)) != null ? stack1.offlineProgress : stack1),1,{"name":"compare","hash":{},"fn":container.program(9, data, 0),"inverse":container.program(11, data, 0),"data":data})) != null ? stack1 : "");
},"9":function(container,depth0,helpers,partials,data) {
    return "            offline-downloaded\n";
},"11":function(container,depth0,helpers,partials,data) {
    return "            offline-downloading\n";
},"13":function(container,depth0,helpers,partials,data) {
    return "          offline-waiting\n";
},"15":function(container,depth0,helpers,partials,data) {
    return "playing";
},"17":function(container,depth0,helpers,partials,data) {
    return "selected";
},"19":function(container,depth0,helpers,partials,data) {
    return "added";
},"21":function(container,depth0,helpers,partials,data) {
    return "unavailable";
},"23":function(container,depth0,helpers,partials,data) {
    return "local";
},"25":function(container,depth0,helpers,partials,data) {
    return "local-file-available";
},"27":function(container,depth0,helpers,partials,data) {
    var stack1;

  return "thumbs-"
    + container.escapeExpression(container.lambda(((stack1 = (depth0 != null ? depth0.track : depth0)) != null ? stack1.thumb : stack1), depth0));
},"29":function(container,depth0,helpers,partials,data) {
    return "thumbs-none";
},"31":function(container,depth0,helpers,partials,data) {
    return "tl-row--episode";
},"33":function(container,depth0,helpers,partials,data) {
    return "thumbs--show-on-hover";
},"compiler":[7,">= 4.0.0"],"main":function(container,depth0,helpers,partials,data) {
    var stack1, helper, alias1=container.lambda, alias2=container.escapeExpression, alias3=depth0 != null ? depth0 : {}, alias4=helpers.helperMissing;

  return "<tr tabindex=\"0\"\n    aria-label=\""
    + alias2(alias1(((stack1 = (depth0 != null ? depth0.track : depth0)) != null ? stack1.name : stack1), depth0))
    + " "
    + alias2((helpers.loc || (depth0 && depth0.loc) || alias4).call(alias3,"By",{"name":"loc","hash":{},"data":data}))
    + " "
    + ((stack1 = (helpers.slice || (depth0 && depth0.slice) || alias4).call(alias3,((stack1 = (depth0 != null ? depth0.track : depth0)) != null ? stack1.artists : stack1),", ",{"name":"slice","hash":{},"fn":container.program(1, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
    + ". "
    + alias2((helpers.loc || (depth0 && depth0.loc) || alias4).call(alias3,"PressEnterToPlay",{"name":"loc","hash":{},"data":data}))
    + ".\"\n    data-list-item\n    data-index=\""
    + ((stack1 = helpers["if"].call(alias3,(depth0 != null ? depth0.index : depth0),{"name":"if","hash":{},"fn":container.program(3, data, 0),"inverse":container.program(5, data, 0),"data":data})) != null ? stack1 : "")
    + "\"\n    data-context\n    data-uri=\""
    + alias2(alias1(((stack1 = (depth0 != null ? depth0.track : depth0)) != null ? stack1.uri : stack1), depth0))
    + "\"\n    data-scroll-page-item=\""
    + alias2(((helper = (helper = helpers.scrollPageItem || (depth0 != null ? depth0.scrollPageItem : depth0)) != null ? helper : alias4),(typeof helper === "function" ? helper.call(alias3,{"name":"scrollPageItem","hash":{},"data":data}) : helper)))
    + "\" draggable=\"true\"\n    data-interaction-context=\""
    + ((stack1 = helpers["if"].call(alias3,(depth0 != null ? depth0.index : depth0),{"name":"if","hash":{},"fn":container.program(3, data, 0),"inverse":container.program(5, data, 0),"data":data})) != null ? stack1 : "")
    + "\"\n    data-ta-id=\"tracklist-row\"\n    data-log-data='{\n      \"index\": "
    + ((stack1 = helpers["if"].call(alias3,(depth0 != null ? depth0.index : depth0),{"name":"if","hash":{},"fn":container.program(3, data, 0),"inverse":container.program(5, data, 0),"data":data})) != null ? stack1 : "")
    + ",\n      \"target_uri\": \""
    + alias2(alias1(((stack1 = (depth0 != null ? depth0.track : depth0)) != null ? stack1.uri : stack1), depth0))
    + "\",\n      \"name\": \""
    + alias2(alias1(((stack1 = (depth0 != null ? depth0.track : depth0)) != null ? stack1.name : stack1), depth0))
    + "\"\n    }'\n    data-contextmenu-spy\n    class=\"tl-row\n"
    + ((stack1 = helpers["if"].call(alias3,((stack1 = (depth0 != null ? depth0.track : depth0)) != null ? stack1.shouldBeOffline : stack1),{"name":"if","hash":{},"fn":container.program(7, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
    + "      "
    + ((stack1 = helpers["if"].call(alias3,((stack1 = (depth0 != null ? depth0.track : depth0)) != null ? stack1.playing : stack1),{"name":"if","hash":{},"fn":container.program(15, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
    + "\n      "
    + ((stack1 = helpers["if"].call(alias3,((stack1 = (depth0 != null ? depth0.track : depth0)) != null ? stack1.selected : stack1),{"name":"if","hash":{},"fn":container.program(17, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
    + "\n      "
    + ((stack1 = helpers["if"].call(alias3,((stack1 = (depth0 != null ? depth0.track : depth0)) != null ? stack1.added : stack1),{"name":"if","hash":{},"fn":container.program(19, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
    + "\n      "
    + ((stack1 = helpers["if"].call(alias3,((stack1 = (depth0 != null ? depth0.track : depth0)) != null ? stack1.unavailable : stack1),{"name":"if","hash":{},"fn":container.program(21, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
    + "\n      "
    + ((stack1 = helpers["if"].call(alias3,((stack1 = (depth0 != null ? depth0.track : depth0)) != null ? stack1.local : stack1),{"name":"if","hash":{},"fn":container.program(23, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
    + "\n      "
    + ((stack1 = helpers["if"].call(alias3,((stack1 = (depth0 != null ? depth0.track : depth0)) != null ? stack1.localFileAvailable : stack1),{"name":"if","hash":{},"fn":container.program(25, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
    + "\n      "
    + ((stack1 = helpers["if"].call(alias3,((stack1 = (depth0 != null ? depth0.track : depth0)) != null ? stack1.thumb : stack1),{"name":"if","hash":{},"fn":container.program(27, data, 0),"inverse":container.program(29, data, 0),"data":data})) != null ? stack1 : "")
    + "\n      "
    + ((stack1 = helpers["if"].call(alias3,((stack1 = (depth0 != null ? depth0.track : depth0)) != null ? stack1.isEpisode : stack1),{"name":"if","hash":{},"fn":container.program(31, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
    + "\n      "
    + ((stack1 = helpers["if"].call(alias3,(depth0 != null ? depth0.formatListFeedbackEnabled : depth0),{"name":"if","hash":{},"fn":container.program(33, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
    + "\n    \"\n    data-contextmenu>\n";
},"useData":true});

},{"hbsfy/runtime":429}],53:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
var partial$0 = require('../../../../libs/glue/templates/tracklist/header/play.hbs');
HandlebarsCompiler.registerPartial('../../../../libs/glue/templates/tracklist/header/play.hbs', partial$0);
var partial$1 = require('../../../../libs/glue/templates/tracklist/header/save.hbs');
HandlebarsCompiler.registerPartial('../../../../libs/glue/templates/tracklist/header/save.hbs', partial$1);
var partial$2 = require('../../../../libs/glue/templates/tracklist/header/name.hbs');
HandlebarsCompiler.registerPartial('../../../../libs/glue/templates/tracklist/header/name.hbs', partial$2);
var partial$3 = require('../../../../libs/glue/templates/tracklist/header/premium.hbs');
HandlebarsCompiler.registerPartial('../../../../libs/glue/templates/tracklist/header/premium.hbs', partial$3);
var partial$4 = require('../../../../libs/glue/templates/tracklist/header/explicit.hbs');
HandlebarsCompiler.registerPartial('../../../../libs/glue/templates/tracklist/header/explicit.hbs', partial$4);
var partial$5 = require('../../../../libs/glue/templates/tracklist/header/artists.hbs');
HandlebarsCompiler.registerPartial('../../../../libs/glue/templates/tracklist/header/artists.hbs', partial$5);
var partial$6 = require('../../../../libs/glue/templates/tracklist/header/album.hbs');
HandlebarsCompiler.registerPartial('../../../../libs/glue/templates/tracklist/header/album.hbs', partial$6);
var partial$7 = require('../../../../libs/glue/templates/tracklist/header/local.hbs');
HandlebarsCompiler.registerPartial('../../../../libs/glue/templates/tracklist/header/local.hbs', partial$7);
var partial$8 = require('../../../../libs/glue/templates/tracklist/header/more.hbs');
HandlebarsCompiler.registerPartial('../../../../libs/glue/templates/tracklist/header/more.hbs', partial$8);
var partial$9 = require('../../../../libs/glue/templates/tracklist/header/time.hbs');
HandlebarsCompiler.registerPartial('../../../../libs/glue/templates/tracklist/header/time.hbs', partial$9);
var partial$10 = require('../../../../libs/glue/templates/tracklist/header/popularity.hbs');
HandlebarsCompiler.registerPartial('../../../../libs/glue/templates/tracklist/header/popularity.hbs', partial$10);
var partial$11 = require('../../../../libs/glue/templates/tracklist/table-body-attributes.hbs');
HandlebarsCompiler.registerPartial('../../../../libs/glue/templates/tracklist/table-body-attributes.hbs', partial$11);
var partial$12 = require('./tracklist-search-row--track-context-rows.hbs');
HandlebarsCompiler.registerPartial('./tracklist-search-row--track-context-rows.hbs', partial$12);
module.exports = HandlebarsCompiler.template({"1":function(container,depth0,helpers,partials,data) {
    var helper;

  return "aria-labelledby=\""
    + container.escapeExpression(((helper = (helper = helpers.ariaLabel || (depth0 != null ? depth0.ariaLabel : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : {},{"name":"ariaLabel","hash":{},"data":data}) : helper)))
    + "\"";
},"3":function(container,depth0,helpers,partials,data) {
    var stack1;

  return ((stack1 = container.invokePartial(partials["./tracklist-search-row--track-context-rows.hbs"],depth0,{"name":"./tracklist-search-row--track-context-rows.hbs","data":data,"indent":"      ","helpers":helpers,"partials":partials,"decorators":container.decorators})) != null ? stack1 : "");
},"compiler":[7,">= 4.0.0"],"main":function(container,depth0,helpers,partials,data) {
    var stack1, helper, alias1=depth0 != null ? depth0 : {}, alias2=helpers.helperMissing, alias3="function", alias4=container.escapeExpression;

  return "<table\n  class=\"tracklist-search tracklist--track-context-rows "
    + alias4(((helper = (helper = helpers.modifiers || (depth0 != null ? depth0.modifiers : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"modifiers","hash":{},"data":data}) : helper)))
    + "\"\n  "
    + ((stack1 = helpers["if"].call(alias1,(depth0 != null ? depth0.ariaLabel : depth0),{"name":"if","hash":{},"fn":container.program(1, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
    + "\n  data-uri=\""
    + alias4(((helper = (helper = helpers.uri || (depth0 != null ? depth0.uri : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"uri","hash":{},"data":data}) : helper)))
    + "\"\n  data-interaction-context=\"tracklist\"\n  data-ta-id=\"tracklist\"\n  data-list\n>\n  <thead class=\"tl-header\">\n    <tr>\n"
    + ((stack1 = container.invokePartial(partials["../../../../libs/glue/templates/tracklist/header/play.hbs"],depth0,{"name":"../../../../libs/glue/templates/tracklist/header/play.hbs","data":data,"indent":"      ","helpers":helpers,"partials":partials,"decorators":container.decorators})) != null ? stack1 : "")
    + ((stack1 = container.invokePartial(partials["../../../../libs/glue/templates/tracklist/header/save.hbs"],depth0,{"name":"../../../../libs/glue/templates/tracklist/header/save.hbs","data":data,"indent":"      ","helpers":helpers,"partials":partials,"decorators":container.decorators})) != null ? stack1 : "")
    + ((stack1 = container.invokePartial(partials["../../../../libs/glue/templates/tracklist/header/name.hbs"],depth0,{"name":"../../../../libs/glue/templates/tracklist/header/name.hbs","data":data,"indent":"      ","helpers":helpers,"partials":partials,"decorators":container.decorators})) != null ? stack1 : "")
    + ((stack1 = container.invokePartial(partials["../../../../libs/glue/templates/tracklist/header/premium.hbs"],depth0,{"name":"../../../../libs/glue/templates/tracklist/header/premium.hbs","data":data,"indent":"      ","helpers":helpers,"partials":partials,"decorators":container.decorators})) != null ? stack1 : "")
    + ((stack1 = container.invokePartial(partials["../../../../libs/glue/templates/tracklist/header/explicit.hbs"],depth0,{"name":"../../../../libs/glue/templates/tracklist/header/explicit.hbs","data":data,"indent":"      ","helpers":helpers,"partials":partials,"decorators":container.decorators})) != null ? stack1 : "")
    + ((stack1 = container.invokePartial(partials["../../../../libs/glue/templates/tracklist/header/artists.hbs"],depth0,{"name":"../../../../libs/glue/templates/tracklist/header/artists.hbs","data":data,"indent":"      ","helpers":helpers,"partials":partials,"decorators":container.decorators})) != null ? stack1 : "")
    + ((stack1 = container.invokePartial(partials["../../../../libs/glue/templates/tracklist/header/album.hbs"],depth0,{"name":"../../../../libs/glue/templates/tracklist/header/album.hbs","data":data,"indent":"      ","helpers":helpers,"partials":partials,"decorators":container.decorators})) != null ? stack1 : "")
    + ((stack1 = container.invokePartial(partials["../../../../libs/glue/templates/tracklist/header/local.hbs"],depth0,{"name":"../../../../libs/glue/templates/tracklist/header/local.hbs","data":data,"indent":"      ","helpers":helpers,"partials":partials,"decorators":container.decorators})) != null ? stack1 : "")
    + ((stack1 = container.invokePartial(partials["../../../../libs/glue/templates/tracklist/header/more.hbs"],depth0,{"name":"../../../../libs/glue/templates/tracklist/header/more.hbs","data":data,"indent":"      ","helpers":helpers,"partials":partials,"decorators":container.decorators})) != null ? stack1 : "")
    + ((stack1 = container.invokePartial(partials["../../../../libs/glue/templates/tracklist/header/time.hbs"],depth0,{"name":"../../../../libs/glue/templates/tracklist/header/time.hbs","data":data,"indent":"      ","helpers":helpers,"partials":partials,"decorators":container.decorators})) != null ? stack1 : "")
    + ((stack1 = container.invokePartial(partials["../../../../libs/glue/templates/tracklist/header/popularity.hbs"],depth0,{"name":"../../../../libs/glue/templates/tracklist/header/popularity.hbs","data":data,"indent":"      ","helpers":helpers,"partials":partials,"decorators":container.decorators})) != null ? stack1 : "")
    + "    </tr>\n  </thead>\n  <tbody "
    + ((stack1 = container.invokePartial(partials["../../../../libs/glue/templates/tracklist/table-body-attributes.hbs"],depth0,{"name":"../../../../libs/glue/templates/tracklist/table-body-attributes.hbs","data":data,"helpers":helpers,"partials":partials,"decorators":container.decorators})) != null ? stack1 : "")
    + ">\n"
    + ((stack1 = (helpers.list || (depth0 && depth0.list) || alias2).call(alias1,(depth0 != null ? depth0.rows : depth0),{"name":"list","hash":{},"fn":container.program(3, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
    + "  </tbody>\n</table>\n";
},"usePartial":true,"useData":true});

},{"../../../../libs/glue/templates/tracklist/header/album.hbs":135,"../../../../libs/glue/templates/tracklist/header/artists.hbs":136,"../../../../libs/glue/templates/tracklist/header/explicit.hbs":137,"../../../../libs/glue/templates/tracklist/header/local.hbs":138,"../../../../libs/glue/templates/tracklist/header/more.hbs":139,"../../../../libs/glue/templates/tracklist/header/name.hbs":140,"../../../../libs/glue/templates/tracklist/header/play.hbs":141,"../../../../libs/glue/templates/tracklist/header/popularity.hbs":142,"../../../../libs/glue/templates/tracklist/header/premium.hbs":143,"../../../../libs/glue/templates/tracklist/header/save.hbs":144,"../../../../libs/glue/templates/tracklist/header/time.hbs":145,"../../../../libs/glue/templates/tracklist/table-body-attributes.hbs":154,"./tracklist-search-row--track-context-rows.hbs":54,"hbsfy/runtime":429}],54:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
var partial$0 = require('./row-start--track-context-rows.hbs');
HandlebarsCompiler.registerPartial('./row-start--track-context-rows.hbs', partial$0);
var partial$1 = require('../../../../libs/glue/templates/tracklist/play.hbs');
HandlebarsCompiler.registerPartial('../../../../libs/glue/templates/tracklist/play.hbs', partial$1);
var partial$2 = require('../../../../libs/glue/templates/tracklist/save.hbs');
HandlebarsCompiler.registerPartial('../../../../libs/glue/templates/tracklist/save.hbs', partial$2);
var partial$3 = require('../../../../libs/glue/templates/tracklist/name.hbs');
HandlebarsCompiler.registerPartial('../../../../libs/glue/templates/tracklist/name.hbs', partial$3);
var partial$4 = require('../../../../libs/glue/templates/tracklist/artists.hbs');
HandlebarsCompiler.registerPartial('../../../../libs/glue/templates/tracklist/artists.hbs', partial$4);
var partial$5 = require('../../../../libs/glue/templates/tracklist/album.hbs');
HandlebarsCompiler.registerPartial('../../../../libs/glue/templates/tracklist/album.hbs', partial$5);
var partial$6 = require('../../../../libs/glue/templates/tracklist/local.hbs');
HandlebarsCompiler.registerPartial('../../../../libs/glue/templates/tracklist/local.hbs', partial$6);
var partial$7 = require('../../../../libs/glue/templates/tracklist/more.hbs');
HandlebarsCompiler.registerPartial('../../../../libs/glue/templates/tracklist/more.hbs', partial$7);
var partial$8 = require('../../../../libs/glue/templates/tracklist/time.hbs');
HandlebarsCompiler.registerPartial('../../../../libs/glue/templates/tracklist/time.hbs', partial$8);
var partial$9 = require('../../../../libs/glue/templates/tracklist/popularity.hbs');
HandlebarsCompiler.registerPartial('../../../../libs/glue/templates/tracklist/popularity.hbs', partial$9);
module.exports = HandlebarsCompiler.template({"compiler":[7,">= 4.0.0"],"main":function(container,depth0,helpers,partials,data) {
    var stack1;

  return ((stack1 = container.invokePartial(partials["./row-start--track-context-rows.hbs"],depth0,{"name":"./row-start--track-context-rows.hbs","data":data,"helpers":helpers,"partials":partials,"decorators":container.decorators})) != null ? stack1 : "")
    + ((stack1 = container.invokePartial(partials["../../../../libs/glue/templates/tracklist/play.hbs"],depth0,{"name":"../../../../libs/glue/templates/tracklist/play.hbs","data":data,"indent":"  ","helpers":helpers,"partials":partials,"decorators":container.decorators})) != null ? stack1 : "")
    + ((stack1 = container.invokePartial(partials["../../../../libs/glue/templates/tracklist/save.hbs"],depth0,{"name":"../../../../libs/glue/templates/tracklist/save.hbs","data":data,"indent":"  ","helpers":helpers,"partials":partials,"decorators":container.decorators})) != null ? stack1 : "")
    + ((stack1 = container.invokePartial(partials["../../../../libs/glue/templates/tracklist/name.hbs"],depth0,{"name":"../../../../libs/glue/templates/tracklist/name.hbs","data":data,"indent":"  ","helpers":helpers,"partials":partials,"decorators":container.decorators})) != null ? stack1 : "")
    + ((stack1 = container.invokePartial(partials["../../../../libs/glue/templates/tracklist/artists.hbs"],depth0,{"name":"../../../../libs/glue/templates/tracklist/artists.hbs","data":data,"indent":"  ","helpers":helpers,"partials":partials,"decorators":container.decorators})) != null ? stack1 : "")
    + ((stack1 = container.invokePartial(partials["../../../../libs/glue/templates/tracklist/album.hbs"],depth0,{"name":"../../../../libs/glue/templates/tracklist/album.hbs","data":data,"indent":"  ","helpers":helpers,"partials":partials,"decorators":container.decorators})) != null ? stack1 : "")
    + ((stack1 = container.invokePartial(partials["../../../../libs/glue/templates/tracklist/local.hbs"],depth0,{"name":"../../../../libs/glue/templates/tracklist/local.hbs","data":data,"indent":"  ","helpers":helpers,"partials":partials,"decorators":container.decorators})) != null ? stack1 : "")
    + ((stack1 = container.invokePartial(partials["../../../../libs/glue/templates/tracklist/more.hbs"],depth0,{"name":"../../../../libs/glue/templates/tracklist/more.hbs","data":data,"indent":"  ","helpers":helpers,"partials":partials,"decorators":container.decorators})) != null ? stack1 : "")
    + ((stack1 = container.invokePartial(partials["../../../../libs/glue/templates/tracklist/time.hbs"],depth0,{"name":"../../../../libs/glue/templates/tracklist/time.hbs","data":data,"indent":"  ","helpers":helpers,"partials":partials,"decorators":container.decorators})) != null ? stack1 : "")
    + ((stack1 = container.invokePartial(partials["../../../../libs/glue/templates/tracklist/popularity.hbs"],depth0,{"name":"../../../../libs/glue/templates/tracklist/popularity.hbs","data":data,"indent":"  ","helpers":helpers,"partials":partials,"decorators":container.decorators})) != null ? stack1 : "")
    + "</tr>\n";
},"usePartial":true,"useData":true});

},{"../../../../libs/glue/templates/tracklist/album.hbs":133,"../../../../libs/glue/templates/tracklist/artists.hbs":134,"../../../../libs/glue/templates/tracklist/local.hbs":146,"../../../../libs/glue/templates/tracklist/more.hbs":147,"../../../../libs/glue/templates/tracklist/name.hbs":148,"../../../../libs/glue/templates/tracklist/play.hbs":149,"../../../../libs/glue/templates/tracklist/popularity.hbs":150,"../../../../libs/glue/templates/tracklist/save.hbs":152,"../../../../libs/glue/templates/tracklist/time.hbs":155,"./row-start--track-context-rows.hbs":52,"hbsfy/runtime":429}],55:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
const RECENTLY_SEARCHED = exports.RECENTLY_SEARCHED = 'recently-searched';
const ALL_RESULTS = exports.ALL_RESULTS = 'all';
const ARTISTS = exports.ARTISTS = 'artists';
const ALBUMS = exports.ALBUMS = 'albums';
const TRACKS = exports.TRACKS = 'tracks';
const PLAYLISTS = exports.PLAYLISTS = 'playlists';
const GENRES = exports.GENRES = 'genres';
const PROFILES = exports.PROFILES = 'profiles';
const SHOWS = exports.SHOWS = 'shows';
const VIDEOEPISODES = exports.VIDEOEPISODES = 'videoepisodes';
const ERROR = exports.ERROR = 'error';

},{}],56:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _spotifyLiburi = require('spotify-liburi');

var _spotifyLiburi2 = _interopRequireDefault(_spotifyLiburi);

var _i18n = require('../../i18n');

var _i18n2 = _interopRequireDefault(_i18n);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const { ARTIST, PLAYLIST, PROFILE, APPLICATION, SHOW, LOCAL, TRACK } = _spotifyLiburi2.default.Type;

const isArtistUri = uri => uri && uri.type === ARTIST;
const isPlaylistUri = uri => uri && uri.type === PLAYLIST;
const isProfileUri = uri => uri && uri.type === PROFILE;
const isAppUri = uri => uri && uri.type === APPLICATION;
const isShowUri = uri => uri && uri.type === SHOW;
const isLocalFile = uri => uri && uri.type === LOCAL;

const getRootUri = rawUri => rawUri.split(':').splice(0, 3).join(':');

const METADATA_SEPARATOR = ' \u2022 ';

const typeMetada = (uri, showType) => {
  if (isAppUri(uri) && uri.id === 'genre') {
    return _i18n2.default.get('genre');
  }

  if (isShowUri(uri) && showType) {
    return _i18n2.default.get(showType);
  }

  // We show local files inside track results, and often they are relinked
  // to a track, so the least confusing is to label them as such.
  if (isLocalFile(uri)) {
    return _i18n2.default.get(TRACK);
  }

  return _i18n2.default.get(uri.type);
};

const artistMetadata = ({ following }, uri, { includeTypeMetadata }) => {
  if (isArtistUri(uri)) {
    const parts = [];
    if (following) {
      parts.push(_i18n2.default.get('following'));
    }

    if (includeTypeMetadata) {
      parts.push(typeMetada(uri));
    }

    return {
      metadata: parts.join(METADATA_SEPARATOR) || ' '
    };
  }

  return {};
};

const artistSubtitle = ({ artists }) => {
  if (!artists) {
    return {};
  }

  const links = artists.map(artist => ({
    name: artist.name,
    uri: artist.uri
  }));

  return {
    subtitleLinks: links
  };
};

const authorSubtitle = ({ author, uri: rawUri }, uri, options) => {
  if (!author || isPlaylistUri(uri) && !options.includePlaylistOwner) {
    return {};
  }

  return {
    subtitleLinks: [{
      name: author,
      uri: getRootUri(rawUri)
    }]
  };
};

const followersMetadata = ({ following, facebook, followersCount }, uri, { includeTypeMetadata }) => {
  if (isProfileUri(uri) || isPlaylistUri(uri)) {
    const parts = [];

    if (following) {
      parts.push(_i18n2.default.get('following'));
    } else if (facebook) {
      parts.push(_i18n2.default.get('facebookFriend'));
    } else if (typeof followersCount === 'number') {
      parts.push(_i18n2.default.get('followers', followersCount));
    }

    if (includeTypeMetadata) {
      parts.push(typeMetada(uri));
    }

    return {
      metadata: parts.join(METADATA_SEPARATOR) || ' '
    };
  }

  return {};
};

const metadata = (input, uri, options) => {
  const data = _extends({}, artistMetadata(input, uri, options), followersMetadata(input, uri, options));

  if (options.includeTypeMetadata && !data.metadata) {
    data.metadata = _i18n2.default.get(typeMetada(uri, input.showType));
  }

  return data;
};

const subtitleLinks = (input, uri, options) => {
  return _extends({}, artistSubtitle(input), authorSubtitle(input, uri, options));
};

exports.default = (input, options = {}) => {
  const { name, image, uri: rawUri } = input;
  const uri = _spotifyLiburi2.default.from(rawUri);

  return _extends({
    name,
    title: name,
    dragText: name,
    uri: rawUri,
    imageUrl: image || '',
    size: 'medium',
    isVideo: options.isVideo,
    removeButton: options.includeRemoveButton,
    removeButtonTooltip: _i18n2.default.get('recentlySearched.removeFromRecentlySearched'),
    playButtonOnly: options.playButtonOnly
  }, metadata(input, uri, options), subtitleLinks(input, uri, options));
};

},{"../../i18n":1,"spotify-liburi":730}],57:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
const LOGGING_SECTIONS = exports.LOGGING_SECTIONS = {
  albums: 'album-results',
  artists: 'artist-results',
  playlists: 'playlist-results',
  profiles: 'profile-results',
  shows: 'show-results',
  tracks: 'track-results',
  videoepisodes: 'videoepisode-results'
};

},{}],58:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
const LOGGING_SELECTORS = exports.LOGGING_SELECTORS = {
  click: [{
    // Recently Searched - Cards - remove button
    selector: '[data-uiinteraction-section="history"] [data-interaction-target="remove-button"]',
    message: element => ({
      section_id: 'history',
      target_uri: element.closest('[data-uri]').getAttribute('data-uri'),
      user_intent: 'dismiss'
    })
  }, {
    // Recently Search - clear all button
    selector: '[data-uiinteraction-section="history"] [data-interaction-target="clear-button"]',
    message: () => ({
      section_id: 'history',
      user_intent: 'clear'
    })
  }, {
    // Cards - title or horizontal card
    selector: '[data-uiinteraction-section] [data-interaction-target="title"]',
    message: element => ({
      section_id: element.closest('[data-uiinteraction-section]').getAttribute('data-uiinteraction-section'),
      target_uri: element.closest('[data-uri]').getAttribute('data-uri')
    })
  }, {
    // Cards - image
    selector: '[data-uiinteraction-section] [data-interaction-target="image"]',
    message: element => ({
      section_id: element.closest('[data-uiinteraction-section]').getAttribute('data-uiinteraction-section'),
      target_uri: element.closest('[data-uri]').getAttribute('data-uri')
    })
  }, {
    // Cards, tracklist - play button
    selector: '[data-uiinteraction-section] [data-interaction-target="play-pause-button"]',
    message: element => ({
      section_id: element.closest('[data-uiinteraction-section]').getAttribute('data-uiinteraction-section'),
      target_uri: element.closest('[data-uri]').getAttribute('data-uri'),
      user_intent: element.getAttribute('data-interaction-intent')
    })
  }, {
    // Cards, tracklist - add button
    selector: '[data-uiinteraction-section] [data-interaction-target="save-remove-button"]',
    message: element => ({
      section_id: element.closest('[data-uiinteraction-section]').getAttribute('data-uiinteraction-section'),
      target_uri: element.closest('[data-uri]').getAttribute('data-uri'),
      user_intent: element.getAttribute('data-interaction-intent')
    })
  }, {
    // Cards, tracklist - context menu button
    selector: '[data-uiinteraction-section] [data-interaction-target="context-menu-button"]',
    message: element => ({
      section_id: element.closest('[data-uiinteraction-section]').getAttribute('data-uiinteraction-section'),
      target_uri: element.closest('[data-uri]').getAttribute('data-uri'),
      user_intent: 'context-menu'
    })
  }, {
    // Section - title
    selector: '[data-uiinteraction-section] [data-interaction-target="section-title"]',
    message: element => ({
      section_id: element.closest('[data-uiinteraction-section]').getAttribute('data-uiinteraction-section'),
      target_uri: element.getAttribute('href')
    })
  }, {
    // Section - See more link
    selector: '[data-uiinteraction-section] [data-interaction-target="see-more-link"]',
    message: element => ({
      section_id: element.closest('[data-uiinteraction-section]').getAttribute('data-uiinteraction-section'),
      target_uri: element.getAttribute('href')
    })
  }, {
    // Links in cards and tracklists
    selector: '[data-uiinteraction-section] [data-uri]',
    message: element => ({
      section_id: element.closest('[data-uiinteraction-section]').getAttribute('data-uiinteraction-section'),
      target_uri: element.getAttribute('data-uri')
    })
  }],
  dblclick: [{
    // Tracklist - double click row
    selector: '[data-uiinteraction-section] [data-interaction-context="tracklist"] tr[data-uri]',
    message: element => ({
      section_id: element.closest('[data-uiinteraction-section]').getAttribute('data-uiinteraction-section'),
      target_uri: element.closest('[data-uri]').getAttribute('data-uri'),
      user_intent: 'play'
    })
  }],
  contextmenu: [{
    // Contextmenu
    selector: '[data-uiinteraction-section] [data-contextmenu]',
    message: element => ({
      section_id: element.closest('[data-uiinteraction-section]').getAttribute('data-uiinteraction-section'),
      target_uri: element.closest('[data-uri]').getAttribute('data-uri'),
      user_intent: 'context-menu'
    })
  }]
};

},{}],59:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.storeRecents = exports.getStoredRecents = undefined;

var _localStorage = require('../../../../libs/local-storage');

var _localStorage2 = _interopRequireDefault(_localStorage);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const KEY = 'recentlySearched';

// In order to be able to keep Recent Searches when changing the app's name from neo-search
// to search we need to migrate Recent Searches that are saved in neo-search's localStorage to
// zlink's localStorage
// After data is migrated to zlink's localStorage, data from neo-search's localStorage is
// removed and from now on only zlink's localStorage is used.
// TODO: (ula) Clean this file when renaming neo-search to search.
const getStoredRecents = exports.getStoredRecents = () => {
  // Retrieve data from neo-search's localStorage
  _localStorage2.default.useTopLocalStorage(false);
  const appData = JSON.parse(_localStorage2.default.get(KEY));

  // If data exists move it from neo-search's localStorage to zlink's localStorage
  if (appData) {
    // Remove data from app's localStorage
    _localStorage2.default.remove(KEY);

    // Save data from the app's localStorage in zlink's localStorage
    _localStorage2.default.useTopLocalStorage(true);
    _localStorage2.default.set(KEY, JSON.stringify(appData));
  }

  // Get data from zlink's localStorage
  _localStorage2.default.useTopLocalStorage(true);
  return JSON.parse(_localStorage2.default.get(KEY));
};

const storeRecents = exports.storeRecents = recents => {
  // Save data only in zlink's localStorage
  _localStorage2.default.useTopLocalStorage(true);
  _localStorage2.default.set(KEY, JSON.stringify(recents));
};

},{"../../../../libs/local-storage":215}],60:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _categoryPageTypes = require('./categoryPageTypes');

exports.default = [_categoryPageTypes.ARTISTS, _categoryPageTypes.ALBUMS, _categoryPageTypes.TRACKS, _categoryPageTypes.PLAYLISTS, _categoryPageTypes.GENRES, _categoryPageTypes.PROFILES, _categoryPageTypes.SHOWS, _categoryPageTypes.VIDEOEPISODES];

},{"./categoryPageTypes":55}],61:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _actions = require('../actions');

var _actions2 = _interopRequireDefault(_actions);

var _abba = require('../../../../libs/abba');

var _abba2 = _interopRequireDefault(_abba);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = store => next => action => {
  const result = next(action);

  switch (action.type) {
    case _actions2.default.START_APP:
      {
        _abba2.default.get('desktop-search-track-results', (error, cell) => {
          if (error) {
            console.error('Couldn\'t fetch ab flag desktop-search-track-results', error);
          }
          store.dispatch(_actions2.default.setTrackResultsAbFlag(error ? null : cell));
        });
        break;
      }

    default:
      break;
  }

  return result;
};

},{"../../../../libs/abba":74,"../actions":27}],62:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _actions = require('../actions');

var _actions2 = _interopRequireDefault(_actions);

var _live = require('../../../../libs/live');

var _live2 = _interopRequireDefault(_live);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = store => next => action => {
  const result = next(action);

  switch (action.type) {
    case _actions2.default.INITIALIZE_URI:
    case _actions2.default.CHANGE_URI:
      window.parent.postMessage({
        type: 'notify_ready',
        pageId: 'neo-search'
      }, '*');
      break;

    case _actions2.default.START_APP:
      store.dispatch(_actions2.default.watchActiveStatus());
      store.dispatch(_actions2.default.watchAppUri());
      store.dispatch(_actions2.default.watchOnlineStatus());
      // Don't add your app's own startup things here. Instead, create your own
      // middleware that listens for START_APP actions and kicks off its startup
      // there. If you need to wait until basic info about the app's state is
      // ready, such as the current URI, then listen for INITIALIZE_URI actions
      // instead of START_APP.
      break;

    case _actions2.default.WATCH_ACTIVE_STATUS:
      window.addEventListener('message', ({ data }) => {
        if (data && data.name === 'set_active') {
          if (data.active) {
            // zlink has reactivated the app's iframe, meaning the user has
            // navigated back to the app after previously navigating away
            // to a different one
            store.dispatch(_actions2.default.activateApp());
          } else {
            // zlink has deactivated the the app's iframe, meaning the user
            // has left the app for now and our iframe is being hidden
            store.dispatch(_actions2.default.deactivateApp());
          }
        }
      });
      break;

    case _actions2.default.WATCH_APP_URI:
      (0, _live2.default)('spotify:application').on('update', ({ state }) => {
        if (!state) {
          // sometimes the application live model updates but doesn't contain a
          // state property, in which case there is nothing to do here
          return;
        }
        const uri = state.getURI();
        if (store.getState().app.uri === uri) {
          // if the URI in the application live model update isn't different from
          // the URI currently in the store then there's nothing to do here
          return;
        }
        if (store.getState().app.uri === undefined) {
          store.dispatch(_actions2.default.initializeUri(uri));
        } else {
          store.dispatch(_actions2.default.changeUri(uri));
        }
      });
      break;

    case _actions2.default.WATCH_ONLINE_STATUS:
      (0, _live2.default)('spotify:client').get('session', (error, session) => {
        const handleOnlineStatus = online => {
          if (store.getState().app.online === online) {
            return;
          }
          if (online === true) {
            store.dispatch(_actions2.default.goOnline());
          } else if (online === false) {
            store.dispatch(_actions2.default.goOffline());
          }
        };

        handleOnlineStatus(session.get('online'));
        session.on('update', ({ online }) => handleOnlineStatus(online));
      });
      break;

    default:
      break;
  }

  return result;
};

},{"../../../../libs/live":210,"../actions":27}],63:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _bfsKmSession = require('../../../../libs/bfs-km-session');

var _bfsKmSearchview = require('../../../../libs/bfs-km-searchview');

var _live = require('../../../../libs/live');

var _live2 = _interopRequireDefault(_live);

var _app = require('./app');

var _app2 = _interopRequireDefault(_app);

var _query = require('./query');

var _query2 = _interopRequireDefault(_query);

var _recentlySearched = require('./recentlySearched');

var _recentlySearched2 = _interopRequireDefault(_recentlySearched);

var _interactionLogging = require('./interactionLogging');

var _interactionLogging2 = _interopRequireDefault(_interactionLogging);

var _abTesting = require('./abTesting');

var _abTesting2 = _interopRequireDefault(_abTesting);

var _api = require('../api');

var _api2 = _interopRequireDefault(_api);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const context = _bfsKmSearchview.Context.create(new _bfsKmSession.Session(), _live2.default);
const api = (0, _api2.default)(context);

exports.default = [_app2.default, (0, _query2.default)(api), _recentlySearched2.default, _interactionLogging2.default, _abTesting2.default];

},{"../../../../libs/bfs-km-searchview":75,"../../../../libs/bfs-km-session":84,"../../../../libs/live":210,"../api":31,"./abTesting":61,"./app":62,"./interactionLogging":64,"./query":65,"./recentlySearched":66}],64:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _actions = require('../actions');

var _actions2 = _interopRequireDefault(_actions);

var _loggingSelectors = require('../lib/loggingSelectors');

var _UIInteraction = require('../../../../libs/logger/messages/UIInteraction5');

var _UIInteraction2 = _interopRequireDefault(_UIInteraction);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const logInteraction = (element, data, type) => {
  const logData = {
    timestamp: Date.now(),
    request_id: data.requestId,
    pageuri: data.pageuri,
    feature_id: 'search',
    section_id: null,
    target_uri: null,
    interaction_type: 'hit',
    user_intent: 'navigate-forward'
  };

  if (!_loggingSelectors.LOGGING_SELECTORS[type]) {
    return;
  }

  _loggingSelectors.LOGGING_SELECTORS[type].some(({ selector, message }) => {
    if (element.closest(selector)) {
      _UIInteraction2.default.log(_extends({}, logData, message(element)));
      return true;
    }

    return false;
  });
};

exports.default = store => next => action => {
  const result = next(action);

  const state = store.getState();
  const category = state.query.category;
  const requestId = category && state.results.categories && state.results.categories[category] ? state.results.categories[category].requestId : null;

  const pageuri = state.query.pageuri;

  if (action.type === _actions2.default.LOG_INTERACTION) {
    logInteraction(action.payload.target, {
      requestId,
      pageuri
    }, action.payload.type);
  } else if (action.type === _actions2.default.LOG_CLEAR_QUERY_INTERACTION) {
    _UIInteraction2.default.log({
      timestamp: Date.now(),
      request_id: null,
      pageuri: pageuri,
      feature_id: 'search',
      section_id: 'search-field',
      target_uri: null,
      interaction_type: 'hit',
      user_intent: 'clear'
    });
  }

  return result;
};

},{"../../../../libs/logger/messages/UIInteraction5":222,"../actions":27,"../lib/loggingSelectors":58}],65:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _spotifyCosmosApi = require('spotify-cosmos-api');

var _spotifyCosmosApi2 = _interopRequireDefault(_spotifyCosmosApi);

var _actions = require('../actions');

var _actions2 = _interopRequireDefault(_actions);

var _categoryPageTypes = require('../lib/categoryPageTypes');

var _searchCategoryEndpoints = require('../lib/searchCategoryEndpoints');

var _searchCategoryEndpoints2 = _interopRequireDefault(_searchCategoryEndpoints);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const onCosmosMessage = (api, store) => (err, res) => {
  if (err) {
    store.dispatch(_actions2.default.fetchFailure(err));
    console.warn(err);
    return;
  }

  const body = res.getJSONBody();
  if (body.type === 'removeFromRecentlySearched') {
    store.dispatch(_actions2.default.removeRecent(body.uri));
  }
};

exports.default = api => store => next => action => {
  const result = next(action);

  switch (action.type) {
    case _actions2.default.START_APP:
      _spotifyCosmosApi2.default.resolver.subscribe('sp://messages/v1/neo-search', onCosmosMessage(api, store));
      break;

    case _actions2.default.INITIALIZE_URI:
    case _actions2.default.CHANGE_URI:
    case _actions2.default.GO_ONLINE:
      {
        const state = store.getState();
        const query = state.query.text;
        const category = state.query.category;

        if (category === _categoryPageTypes.ALL_RESULTS) {
          store.dispatch(_actions2.default.fetchAllResults(api, query));
        } else if (_searchCategoryEndpoints2.default.includes(category)) {
          store.dispatch(_actions2.default.fetchCategoryResults(api, category, query));
        }
        break;
      }

    default:
    // noop
  }

  return result;
};

},{"../actions":27,"../lib/categoryPageTypes":55,"../lib/searchCategoryEndpoints":60,"spotify-cosmos-api":720}],66:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _recentlySearchedStorage = require('../lib/recentlySearchedStorage');

var _actions = require('../actions');

var _actions2 = _interopRequireDefault(_actions);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = store => next => action => {
  const result = next(action);

  if (![_actions2.default.SAVE_RECENT, _actions2.default.REMOVE_RECENT, _actions2.default.REMOVE_ALL_RECENT].includes(action.type)) return result;

  (0, _recentlySearchedStorage.storeRecents)(store.getState().recentlySearched.data);

  return result;
};

},{"../actions":27,"../lib/recentlySearchedStorage":59}],67:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.default = queryReducer;

var _actions = require('../actions');

var _actions2 = _interopRequireDefault(_actions);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const defaultState = {
  trackResultsABcell: undefined
};

function queryReducer(state = defaultState, action) {
  switch (action.type) {
    case _actions2.default.SET_TRACK_RESULTS_AB_FLAG:
      {
        return _extends({}, state, {
          trackResultsABcell: action.cell
        });
      }

    default:
      return state;
  }
}

},{"../actions":27}],68:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.default = app;

var _actions = require('../actions');

var _actions2 = _interopRequireDefault(_actions);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const defaultState = {
  active: true,
  online: true
};

function app(state = defaultState, action) {
  switch (action.type) {
    case _actions2.default.ACTIVATE_APP:
      return _extends({}, state, { active: true });

    case _actions2.default.DEACTIVATE_APP:
      return _extends({}, state, { active: false });

    case _actions2.default.GO_ONLINE:
      return _extends({}, state, { online: true });

    case _actions2.default.GO_OFFLINE:
      return _extends({}, state, { online: false });

    default:
      return state;
  }
}

},{"../actions":27}],69:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = createReducer;

var _redux = require('redux');

var _query = require('./query');

var _query2 = _interopRequireDefault(_query);

var _app = require('./app');

var _app2 = _interopRequireDefault(_app);

var _recentlySearched = require('./recentlySearched');

var _recentlySearched2 = _interopRequireDefault(_recentlySearched);

var _results = require('./results');

var _results2 = _interopRequireDefault(_results);

var _abTesting = require('./abTesting');

var _abTesting2 = _interopRequireDefault(_abTesting);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function createReducer() {
  return (0, _redux.combineReducers)({
    app: _app2.default,
    query: _query2.default,
    recentlySearched: _recentlySearched2.default,
    results: _results2.default,
    abTesting: _abTesting2.default
  });
}

},{"./abTesting":67,"./app":68,"./query":70,"./recentlySearched":71,"./results":72,"redux":709}],70:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.default = queryReducer;

var _spotifyLiburi = require('spotify-liburi');

var _spotifyLiburi2 = _interopRequireDefault(_spotifyLiburi);

var _actions = require('../actions');

var _actions2 = _interopRequireDefault(_actions);

var _categoryPageTypes = require('../lib/categoryPageTypes');

var _searchCategoryEndpoints = require('../lib/searchCategoryEndpoints');

var _searchCategoryEndpoints2 = _interopRequireDefault(_searchCategoryEndpoints);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const validCategories = [..._searchCategoryEndpoints2.default, _categoryPageTypes.ALL_RESULTS, _categoryPageTypes.RECENTLY_SEARCHED];

const defaultState = {
  category: _categoryPageTypes.RECENTLY_SEARCHED,
  text: ''
};

function queryReducer(state = defaultState, action) {
  switch (action.type) {
    case _actions2.default.CLEAR_SEARCH_RESULTS:
      return defaultState;

    case _actions2.default.INITIALIZE_URI:
    case _actions2.default.CHANGE_URI:
      {
        const uri = _spotifyLiburi2.default.from(action.payload.uri);
        const args = [...uri.toAppType().args];
        let text = '';
        let category;

        // URI format required for logging UIInteraction5
        const pageuri = `spotify:search:${args.slice().reverse().join(':')}`;

        switch (args.length) {
          case 0:
            category = _categoryPageTypes.RECENTLY_SEARCHED;
            break;
          case 1:
            [text] = args;
            category = text ? _categoryPageTypes.ALL_RESULTS : _categoryPageTypes.RECENTLY_SEARCHED;
            break;
          default:
            category = args.pop();
            text = args.join(':');
        }

        if (!validCategories.includes(category)) {
          if (category) text = `${text}:${category}`;
          category = _categoryPageTypes.ALL_RESULTS;
        }

        return _extends({}, state, {
          uri: action.payload.uri,
          pageuri,
          category,
          text
        });
      }

    default:
      return state;
  }
}

},{"../actions":27,"../lib/categoryPageTypes":55,"../lib/searchCategoryEndpoints":60,"spotify-liburi":730}],71:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.default = recentlySearchedReducer;

var _actions = require('../actions');

var _actions2 = _interopRequireDefault(_actions);

var _recentlySearchedStorage = require('../lib/recentlySearchedStorage');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const getInitialState = () => ({
  data: (0, _recentlySearchedStorage.getStoredRecents)() || {
    entities: {}, // dictionary of entities by URI
    recencyOrder: [] // recency orders of entities
  }
});

const moveToFirst = (item, array = []) => {
  const clone = [...array];
  const index = clone.indexOf(item);
  if (index >= 0) clone.splice(index, 1);
  clone.unshift(item);
  return clone;
};

const insertRecent = ({ entities, recencyOrder }, item) => ({
  entities: _extends({}, entities, {
    [item.uri]: item
  }),
  recencyOrder: moveToFirst(item.uri, recencyOrder)
});

const removeRecent = ({ entities, recencyOrder }, uri) => {
  const _entities = _extends({}, entities);
  delete _entities[uri];

  const _recencyOrder = [...recencyOrder];
  _recencyOrder.splice(recencyOrder.indexOf(uri), 1);

  return {
    entities: _entities,
    recencyOrder: _recencyOrder
  };
};

function recentlySearchedReducer(state = getInitialState(), { type, payload }) {
  switch (type) {
    case _actions2.default.SAVE_RECENT:
      return payload.item ? { data: insertRecent(state.data, payload.item) } : state;

    case _actions2.default.REMOVE_RECENT:
      return payload.uri ? { data: removeRecent(state.data, payload.uri) } : state;

    case _actions2.default.REMOVE_ALL_RECENT:
      return {
        data: {
          entities: [],
          recencyOrder: []
        }
      };

    default:
      return state;
  }
}

},{"../actions":27,"../lib/recentlySearchedStorage":59}],72:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.default = resultsReducer;

var _actions = require('../actions');

var _actions2 = _interopRequireDefault(_actions);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function getInitialState() {
  return {
    error: null,
    categories: {
      /*
      [all|artists|tracks|etc.]: {
        requestId: '',
        entities: [],
        loadMoreUri: '',
        title: '',
        categoriesOrder: []
      }
      */
    },
    totalResults: null
  };
}

const offlineCategoryOrder = ['tracks'];

function dedupe(localFiles) {
  const seen = {};
  return localFiles.filter(file => {
    if (seen[file.uri]) {
      return false;
    }
    seen[file.uri] = true;
    return true;
  });
}

const countEntities = entities => Object.values(entities).reduce((acc, _entities) => {
  let sum = acc;
  sum += _entities.hits ? _entities.hits.length : 0;

  return sum;
}, 0);

const getType = results => results ? Object.keys(results)[0] : null;

function resultsReducer(state = getInitialState(), action) {
  switch (action.type) {
    case _actions2.default.CLEAR_SEARCH_RESULTS:
      return getInitialState();

    case _actions2.default.RECEIVE_ALL_RESULTS:
      {
        const { localFileResults, requestId, categoriesOrder = offlineCategoryOrder, results } = action.payload;

        let entities = results;

        if (localFileResults && localFileResults.length) {
          entities = _extends({}, results);
          const localFiles = dedupe(localFileResults);

          if (!entities.tracks) {
            entities.tracks = {
              hits: localFiles,
              total: localFiles.length
            };
          } else {
            entities.tracks = {
              hits: [...localFiles, ...results.tracks.hits],
              total: results.tracks.total + localFiles.length
            };
          }
        }

        return _extends({}, getInitialState(), {
          categories: {
            all: {
              requestId,
              categoriesOrder,
              entities
            }
          },
          totalResults: entities ? countEntities(entities) : 0
        });
      }

    case _actions2.default.RECEIVE_CATEGORY_RESULTS:
      {
        const { requestId, results, localFileResults } = action.payload;
        const type = getType(results);

        if (!type) return _extends({}, getInitialState());

        const { loadMoreURI } = results[type];
        let entities = results[type];
        const isTrackResults = type === 'tracks';
        if (isTrackResults && localFileResults.length) {
          entities = _extends({}, results[type]);
          const localFiles = dedupe(localFileResults);
          if (!entities.hits) {
            entities.hits = localFiles;
          } else {
            entities.hits = [...localFiles, ...entities.hits];
          }
        }

        return _extends({}, getInitialState(), {
          categories: {
            [type]: {
              requestId,
              entities: entities.hits,
              loadMoreUri: loadMoreURI
            }
          },
          totalResults: entities.hits.length
        });
      }

    case _actions2.default.RECEIVE_MORE_CATEGORY_RESULTS:
      {
        const { requestId, results } = action.payload;
        const type = getType(results);

        if (!type) return _extends({}, state);

        const { hits, loadMoreURI, title } = results[type];
        const entities = [...state.categories[type].entities, ...hits];

        return _extends({}, getInitialState(), {
          categories: {
            [type]: _extends({}, state.categories[type], {
              requestId,
              title,
              loadMoreUri: loadMoreURI,
              entities
            })
          },
          totalResults: entities ? entities.length : 0
        });
      }

    case _actions2.default.FETCH_ERROR:
      if (action.payload) {
        console.error(action.payload.error);
      }

      return _extends({}, getInitialState(), {
        error: 'FETCH'
      });

    default:
      return state;
  }
}

},{"../actions":27}],73:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.trackShape = exports.cardShape = undefined;

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const entityShape = _propTypes2.default.shape({
  name: _propTypes2.default.string.isRequired,
  uri: _propTypes2.default.string.isRequired
});

const cardShape = exports.cardShape = _propTypes2.default.shape({
  image: _propTypes2.default.string,
  name: _propTypes2.default.string,
  uri: _propTypes2.default.string,
  artists: _propTypes2.default.arrayOf(entityShape),
  album: entityShape,
  followersCount: _propTypes2.default.number,
  popularity: _propTypes2.default.number,
  duration: _propTypes2.default.number
});

const trackShape = exports.trackShape = _propTypes2.default.shape({
  album: entityShape,
  artists: _propTypes2.default.arrayOf(entityShape),
  duration: _propTypes2.default.number,
  popularity: _propTypes2.default.number,
  name: _propTypes2.default.string.isRequired,
  uri: _propTypes2.default.string.isRequired
});

},{"prop-types":495}],74:[function(require,module,exports){
'use strict';

var _spotifyCosmosApi = require('spotify-cosmos-api');

var _spotifyCosmosApi2 = _interopRequireDefault(_spotifyCosmosApi);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

let subscriptions = [];

module.exports = {
  get,
  subscribe,
  clearSubscriptions,
  fetch
};

/**
 * Debug API
 * Exposed on the window for debugging and TA tests
 */
if (typeof window !== 'undefined') {
  window.abba = {
    get
  };
}

function _getFlagsFromCosmos(requestedFlags, callback) {
  _spotifyCosmosApi2.default.resolver.post({
    url: 'sp://abba/v1/flags',
    body: {
      flags: requestedFlags
    }
  }, (err, response) => {
    if (err) {
      callback(err);
    } else {
      const { flags = [] } = response.getJSONBody();
      callback(null, flags);
    }
  });
}

function fetch(flags) {
  const cells = {};
  const overrides = readOverrides();
  const notOverridden = flags.reduce((acc, flag) => {
    if (overrides.hasOwnProperty(flag)) {
      console.warn(`Abba: Override for ${flag} : ${overrides[flag]}`);
      cells[flag] = overrides[flag];
    } else {
      acc.push(flag);
    }
    return acc;
  }, []);

  if (!notOverridden.length) {
    return Promise.resolve(cells);
  }

  return new Promise((resolve, reject) => {
    _getFlagsFromCosmos(notOverridden, (err, fetchedFlags) => {
      if (err) {
        reject(err);
        return;
      }
      fetchedFlags.forEach(flag => {
        cells[flag.featureName] = flag.cell;
      });
      if (Object.keys(cells).length !== flags.length) {
        flags.forEach(flag => {
          if (!cells.hasOwnProperty(flag)) {
            cells[flag] = null;
          }
        });
      }
      resolve(cells);
    });
  });
}

function get(flag, callback) {
  const overrides = readOverrides();
  if (overrides.hasOwnProperty(flag)) {
    console.warn(`Abba: Override for ${flag} : ${overrides[flag]}`);
    setTimeout(() => callback(null, overrides[flag]), 0);
    return;
  }

  _getFlagsFromCosmos([flag], (err, flags) => {
    if (err) {
      callback(err);
      return;
    }
    const featureFlagCell = flags[0] && flags[0].featureName === flag && flags[0].cell;
    callback(null, featureFlagCell || null);
  });
}

function subscribe(flag, callback) {
  let oldValue;

  const update = newValue => {
    // ABBA might pub even though the value we're after haven't actually
    // changed, so must make sure that the flag we're tracking actually
    // changed value.
    if (newValue !== oldValue) {
      oldValue = newValue;
      callback(null, newValue);
    }
  };

  let cosmosSubscription = _spotifyCosmosApi2.default.resolver.subscribe({
    url: 'sp://abba/v1/flags',
    body: {
      flags: [flag]
    }
  }, subscribeError => {
    if (subscribeError) {
      callback(subscribeError);
      return;
    }

    get(flag, (err, newValue) => {
      if (err) {
        callback(err);
        return;
      }
      update(newValue);
    });
  });

  let subscription = {
    cancel: () => {
      if (cosmosSubscription) cosmosSubscription.cancel();
      const index = subscriptions[flag].indexOf(subscription);
      if (index !== -1) {
        subscriptions[flag].splice(index, 1);
      }
      subscription = cosmosSubscription = null;
    },
    _update: update
  };

  if (!(flag in subscriptions)) {
    subscriptions[flag] = [];
  }
  subscriptions[flag].push(subscription);

  return subscription;
}

function clearSubscriptions() {
  subscriptions = [];
}

function readOverrides() {
  const value = typeof __spotify !== 'undefined' && __spotify.product_state ? __spotify.product_state.abbaOverrides || __spotify.product_state.abbaoverrides : '';
  if (value) {
    try {
      return JSON.parse(value);
    } catch (e) {
      console.error('error parsing value=%o, error=%o', value, e);
    }
  }
  return {};
}

},{"spotify-cosmos-api":720}],75:[function(require,module,exports){
'use strict';

module.exports = require('./source/index.js');

},{"./source/index.js":77}],76:[function(require,module,exports){
(function (global){
'use strict';

const requests = require('./requests/requests.js');
const Session = require('../../bfs-km-session').Session;
const types = require('bfs-km-types');
const proxyConfiguration = require('./proxyConfiguration');

const CATALOGUE = 'catalogue';
const COUNTRY = 'country';
const GET = 'GET';
const LOCALE = 'locale';
const PLATFORM = 'platform';
const USERNAME = 'username';

/**
 * Constructs a new context.
 */
const Context = function Context(session, live) {
  types.check.type(session, Session);

  this.id = 0;
  this.session = session;
  this.proxyConfig = proxyConfiguration.getConfiguration(live);
};

/**
 * Static method that creates a new context with the default dependencies.
 */
Context.create = function (session, live) {
  types.check.type(session, Session);

  return new Context(session, live);
};

/**
 * Static method that creates a mock context which responds with the given
 * serialized json response for all requests.
 */
Context.createMockThatRespondsWith = function (response) {
  types.check.string(response);

  const Mock = types.mock(Context);

  Mock.prototype.resolve = function (uri, caller, success, failure) {
    let json;

    types.check.string(uri);
    types.check.type(caller, global.Object);
    types.check.function(success);
    types.check.function(failure);

    try {
      json = global.JSON.parse(response);
    } catch (error) {
      failure.call(caller, error);

      return;
    }

    success.call(caller, json);
  };

  return new Mock(Session.createMock());
};

/**
 * Clones the context instance.
 */
Context.prototype.clone = function () {
  const that = new this.constructor(this.session);

  return that;
};

/**
 * Helper method that creates a new hub request.
 */
Context.prototype.newHubRequest = function () {
  return requests.Hub.create();
};

/**
 * Helper method that creates a new search request.
 */
Context.prototype.newSearchRequest = function () {
  return requests.Search.create();
};

/**
 * Resolve the given uri based on the proxy configuration.
 */
Context.prototype.resolve = function (uri, caller, success, failure) {
  this.proxyConfig.then(function (proxy) {
    if (proxy.enabled) {
      this._localhostRequest(uri, proxy, success, failure, caller);
      return;
    }

    this._cosmosRequest(uri, caller, success, failure);
  }.bind(this));
};

/**
 * Resolves the given uri using the cosmos resolver and calls the succes
 * callback or the failure callback depending on whether the request was
 * successful or not.
 */
Context.prototype._cosmosRequest = function (uri, caller, success, failure) {
  let callback;

  const cosmos = require('spotify-cosmos-api');

  types.check.string(uri);
  types.check.type(caller, global.Object);
  types.check.function(success);
  types.check.function(failure);

  const id = ++this.id;

  callback = function (error, response) {
    let json;

    if (id === this.id) {
      if (types.is.type(error, global.Error)) {
        failure.call(caller, error);
      } else {
        json = response.getJSONBody();

        if (types.is.object(json)) {
          success.call(caller, json);
        } else {
          failure.call(caller, new global.Error('Received malformed json!'));
        }
      }
    }
  };

  callback = callback.bind(this);

  cosmos.resolver.resolve(new cosmos.Request(GET, uri), callback);
};

/**
 * Make a request to the proxy running locally.
 */
Context.prototype._localhostRequest = function (uri, proxy, success, failure, caller) {
  types.check.string(uri);
  types.check.type(caller, global.Object);
  types.check.function(success);
  types.check.function(failure);

  const id = ++this.id;
  const httpUri = uri.replace(/^hm:\/\//, `${proxy.host}:${proxy.port}/`);
  const xhr = new XMLHttpRequest();

  xhr.onreadystatechange = function () {
    if (id !== this.id || xhr.readyState !== 4) {
      return;
    }

    let json = null;
    if (xhr.status === 200) {
      try {
        json = JSON.parse(xhr.response);
      } catch (error) {
        failure.call(caller, error);
      }
    }

    if (types.is.object(json)) {
      success.call(caller, json);
    } else {
      failure.call(caller, new global.Error('Received malformed json!'));
    }
  }.bind(this);

  xhr.open('GET', httpUri, true);
  xhr.setRequestHeader('x-spotify-catalogue', proxy.catalogue);
  xhr.setRequestHeader('x-spotify-country', proxy.country);
  xhr.setRequestHeader('x-spotify-employee', String(proxy.employee));
  xhr.setRequestHeader('x-spotify-username', proxy.username);
  xhr.send();
};

/**
 * Sends a request to the given uri. If the request fails, the given failure
 * callback is called with the Error as its argument. If the request succeeds,
 * the given success callback is called with the json response as its argument.
 * No context parameters are appended to the uri.
 */
Context.prototype.send = function (uri, caller, success, failure) {
  types.check.string(uri);
  types.check.type(caller, global.Object);
  types.check.function(success);
  types.check.function(failure);

  this.resolve(uri, caller, success, failure);
};

/**
 * Sends a request to the uri of the given request. If the request fails, the
 * given failure callback is called with the Error as its argument. If the
 * request succeeds, the given success callback is called with the json response
 * as its argument. All context parameters are appended to the uri.
 */
Context.prototype.sendRequest = function (request, caller, success, failure) {
  types.check.type(request, requests.Request);
  types.check.type(caller, global.Object);
  types.check.function(success);
  types.check.function(failure);

  const cloned = request.clone();

  cloned.setParameter(CATALOGUE, this.session.getCatalogue());
  cloned.setParameter(COUNTRY, this.session.getCountry());
  cloned.setParameter(LOCALE, this.session.getLocale());
  cloned.setParameter(PLATFORM, this.session.getPlatform());
  cloned.setParameter(USERNAME, this.session.getUsername());

  const uri = cloned.toUri();

  this.resolve(uri, caller, success, failure);
};

module.exports = Context;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../bfs-km-session":84,"./proxyConfiguration":78,"./requests/requests.js":83,"bfs-km-types":370,"spotify-cosmos-api":720}],77:[function(require,module,exports){
'use strict';

exports.Context = require('./Context.js');
exports.requests = require('./requests/requests.js');
exports.proxyConfiguration = require('./proxyConfiguration');

},{"./Context.js":76,"./proxyConfiguration":78,"./requests/requests.js":83}],78:[function(require,module,exports){
'use strict';

const proxyConfigurationState = require('./proxyConfigurationState');

const STORAGE_NAMESPACE = 'search-proxy';
const STORAGE_FIELDS = ['enabled', 'host', 'port', 'catalogue', 'username', 'country', 'employee'];
const STORAGE_FIELDS_WITH_NAMESPACE = STORAGE_FIELDS.map(formatStorageKey);

const DEFAULT_CONFIGURATION = {
  enabled: false,
  host: 'http://127.0.0.1',
  port: '1337',
  catalogue: 'free',
  username: null,
  country: null,
  employee: false
};

exports = module.exports = function (live) {
  return {
    getConfiguration: getConfiguration.bind(null, live),
    getDefaultConfiguration: getDefaultConfiguration,
    getUserData: getUserData.bind(null, live),
    getAllPreferences: getAllPreferences.bind(null, live),
    updatePreferences: updatePreferences.bind(null, live)
  };
};

/**
 * Get the proxy configuration based on user data & preferences.
 */
exports.getConfiguration = getConfiguration;

function getConfiguration(live) {
  return Promise.all([getDefaultConfiguration(), getUserData(live), getAllPreferences(live)]).then(function (data) {
    const defaultConfiguration = data[0];
    const userData = data[1];
    const preferences = data[2];

    return proxyConfigurationState(defaultConfiguration, userData, preferences);
  });
}

/**
 * Get the default configuration used by searchview.
 */
exports.getDefaultConfiguration = getDefaultConfiguration;

function getDefaultConfiguration() {
  return Promise.resolve(DEFAULT_CONFIGURATION);
}

/**
 * Get user data from live model.
 */
exports.getUserData = getUserData;

function getUserData(live) {
  return new Promise(function (resolve, reject) {
    live('spotify:client').query('currentUser(username), session(country)', function (err, data) {
      if (err) {
        reject(err);
        return;
      }

      resolve({
        username: data.currentUser.username,
        country: data.session.country,
        catalogue: window.__spotify.product_state.catalogue
      });
    });
  });
}

/**
 * Get all user's proxy preferences defined in the settings page.
 */
exports.getAllPreferences = getAllPreferences;

function getAllPreferences(live) {
  return new Promise(function (resolve, reject) {
    live('spotify:client-storage').get(STORAGE_FIELDS_WITH_NAMESPACE, function (err, storageData) {
      if (err) {
        reject(err);
        return;
      }

      // Map `storageData` with `STORAGE_FIELDS`.
      // It uses `STORAGE_FIELDS` values as keys and `storageData` as values.
      const result = STORAGE_FIELDS.reduce(function (acc, key, index) {
        let value = storageData[index];

        if (value === 'true') {
          value = true;
        } else if (value === 'false') {
          value = false;
        }

        acc[key] = value;
        return acc;
      }, {});

      resolve(result);
    });
  });
}

/**
 * Update the given keys.
 */
exports.updatePreferences = updatePreferences;

function updatePreferences(live, data) {
  // Preprend the storage namespace to the keys.
  const storageData = Object.keys(data).reduce(function (acc, key) {
    acc[formatStorageKey(key)] = data[key];
    return acc;
  }, {});

  live('spotify:client-storage').publish(storageData);

  return Promise.resolve();
}

/**
 * Format a key using the storage namespace.
 */
function formatStorageKey(key) {
  return `${STORAGE_NAMESPACE}:${key}`;
}

},{"./proxyConfigurationState":79}],79:[function(require,module,exports){
'use strict';

exports = module.exports = proxyConfigurationState;

/**
 * Merge DEFAULT_STATE, userData and preferences into one object.
 * @public
 */
function proxyConfigurationState(defaultState, userData, preferences) {
  const filterUserData = excludeEmptyProperties(userData);
  const filterPreferences = excludeEmptyProperties(preferences);

  const state = Object.assign({}, defaultState, filterUserData, filterPreferences);

  return state;
}

/**
 * Exclude properties that are considered as "empty".
 * @private
 */
function excludeEmptyProperties(data) {
  if (!data) {
    return {};
  }

  const res = Object.keys(data).reduce(function (acc, key) {
    const value = data[key];

    // Exclude if the property is not defined or an emtpy string.
    if (value === undefined || value === null || value === '') {
      return acc;
    }

    acc[key] = value;

    return acc;
  }, {});

  return res;
}

},{}],80:[function(require,module,exports){
(function (global){
'use strict';

const Request = require('./Request.js');
const types = require('bfs-km-types');

const BASE_URI = 'hm://hubview/km/';
const EMPTY = '';
const HUB = 'hub';
const SUB_HUB = 'sub-hub';
const SUB_SUB_HUB = 'sub-sub-hub';
const SYMBOL_FORWARD_SLASH = '/';
const VERSION = 'version';

/**
 * Constructs a new hub request.
 */
const Hub = function Hub() {
  Request.call(this);

  this.storage[HUB] = EMPTY;
  this.storage[SUB_HUB] = EMPTY;
  this.storage[SUB_SUB_HUB] = EMPTY;
  this.storage[VERSION] = EMPTY;
};

types.extend(Hub, Request);

/**
 * Static method that creates a new request.
 */
Hub.create = function () {
  return new Hub();
};

/**
 * Static method that creates a mock request.
 */
Hub.createMock = function () {
  const Mock = types.mock(Hub);

  return new Mock();
};

/**
 * Clones the request instance.
 */
Hub.prototype.clone = function () {
  const that = new this.constructor();

  that.storage = types.clone(this.storage);

  return that;
};

/**
 * Gets the base uri for the request.
 */
Hub.prototype.getBaseUri = function () {
  let uri;

  uri = EMPTY;

  uri += BASE_URI;
  uri += global.encodeURIComponent(this.storage[VERSION]);
  uri += SYMBOL_FORWARD_SLASH;
  uri += global.encodeURIComponent(this.storage[HUB]);

  if (this.storage[SUB_HUB] === '') {
    return uri;
  }

  uri += SYMBOL_FORWARD_SLASH;
  uri += global.encodeURIComponent(this.storage[SUB_HUB]);

  if (this.storage[SUB_SUB_HUB] === '') {
    return uri;
  }

  uri += SYMBOL_FORWARD_SLASH;
  uri += global.encodeURIComponent(this.storage[SUB_SUB_HUB]);

  return uri;
};

/**
 * Gets the hub.
 */
Hub.prototype.getHub = function () {
  return this.storage[HUB];
};

/**
 * Gets the sub hub.
 */
Hub.prototype.getSubHub = function () {
  return this.storage[SUB_HUB];
};

/**
 * Gets the sub sub hub.
 */
Hub.prototype.getSubSubHub = function () {
  return this.storage[SUB_SUB_HUB];
};

/**
 * Gets the version.
 */
Hub.prototype.getVersion = function () {
  return this.storage[VERSION];
};

/**
 * Sets the hub.
 */
Hub.prototype.setHub = function (hub) {
  types.check.string(hub);

  this.storage[HUB] = hub;

  return this;
};

/**
 * Sets the sub hub.
 */
Hub.prototype.setSubHub = function (subHub) {
  types.check.string(subHub);

  this.storage[SUB_HUB] = subHub;

  return this;
};

/**
 * Sets the sub sub hub.
 */
Hub.prototype.setSubSubHub = function (subSubHub) {
  types.check.string(subSubHub);

  this.storage[SUB_SUB_HUB] = subSubHub;

  return this;
};

/**
 * Sets the version.
 */
Hub.prototype.setVersion = function (version) {
  types.check.string(version);

  this.storage[VERSION] = version;

  return this;
};

module.exports = Hub;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./Request.js":81,"bfs-km-types":370}],81:[function(require,module,exports){
(function (global){
'use strict';

const types = require('bfs-km-types');

const EMPTY = '';
const PARAMETERS = 'parameters';
const SYMBOL_AMPERSAND = '&';
const SYMBOL_EQUALITY_SIGN = '=';
const SYMBOL_QUESTION_MARK = '?';

/**
 * Constructs a new request.
 */
const Request = function Request() {
  this.storage = {};

  this.storage[PARAMETERS] = {};
};

types.define(Request);

/**
 * Clones the request instance.
 */
Request.prototype.clone = function () {
  throw new global.Error('Abstract method!');
};

/**
 * Gets the base uri for the request.
 */
Request.prototype.getBaseUri = function () {
  throw new global.Error('Abstract method!');
};

/**
 * Gets the parameter with the given key. Returns null if the parameter with the
 * given key is unset.
 */
Request.prototype.getParameter = function (key) {
  types.check.string(key);

  return types.fallback.string(this.storage[PARAMETERS][key], null);
};

/**
 * Sets the parameter with the given key to the given value. Note that the value
 * must be a string.
 */
Request.prototype.setParameter = function (key, value) {
  types.check.string(key);
  types.check.string(value);

  this.storage[PARAMETERS][key] = value;

  return this;
};

/**
 * Sets all parameters defined by the given object. Note that all values must be
 * strings.
 */
Request.prototype.setParameters = function (object) {
  types.check.object(object);

  Object.keys(object).forEach(function (key) {
    this.setParameter(key, object[key]);
  }.bind(this));

  return this;
};

/**
 * Converts the request to a uri.
 */
Request.prototype.toUri = function () {
  let query;
  let uri;

  uri = this.getBaseUri();

  query = EMPTY;

  Object.keys(this.storage[PARAMETERS]).forEach(function (key) {
    query += query.length === 0 ? SYMBOL_QUESTION_MARK : SYMBOL_AMPERSAND;
    query += global.encodeURIComponent(key);
    query += SYMBOL_EQUALITY_SIGN;
    query += global.encodeURIComponent(this.storage[PARAMETERS][key]);
  }.bind(this));

  uri += query;

  return uri;
};

module.exports = Request;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"bfs-km-types":370}],82:[function(require,module,exports){
(function (global){
'use strict';

const Request = require('./Request.js');
const types = require('bfs-km-types');

const BASE_URI = 'hm://searchview/km/';
const EMPTY = '';
const ENDPOINT = 'endpoint';
const QUERY = 'query';
const SYMBOL_FORWARD_SLASH = '/';
const VERSION = 'version';

/**
 * Constructs a new search request.
 */
const Search = function Search() {
  Request.call(this);

  this.storage[ENDPOINT] = EMPTY;
  this.storage[QUERY] = EMPTY;
  this.storage[VERSION] = EMPTY;
};

types.extend(Search, Request);

/**
 * Static method that creates a new request.
 */
Search.create = function () {
  return new Search();
};

/**
 * Static method that creates a mock request.
 */
Search.createMock = function () {
  const Mock = types.mock(Search);

  return new Mock();
};

/**
 * Clones the request instance.
 */
Search.prototype.clone = function () {
  const that = new this.constructor();

  that.storage = types.clone(this.storage);

  return that;
};

/**
 * Gets the base uri for the request.
 */
Search.prototype.getBaseUri = function () {
  let uri;

  uri = EMPTY;

  uri += BASE_URI;
  uri += global.encodeURIComponent(this.storage[VERSION]);
  uri += SYMBOL_FORWARD_SLASH;
  uri += global.encodeURIComponent(this.storage[ENDPOINT]);
  uri += SYMBOL_FORWARD_SLASH;
  uri += global.encodeURIComponent(this.storage[QUERY]);

  return uri;
};

/**
 * Gets the endpoint.
 */
Search.prototype.getEndpoint = function () {
  return this.storage[ENDPOINT];
};

/**
 * Gets the query.
 */
Search.prototype.getQuery = function () {
  return this.storage[QUERY];
};

/**
 * Gets the version.
 */
Search.prototype.getVersion = function () {
  return this.storage[VERSION];
};

/**
 * Sets the endpoint.
 */
Search.prototype.setEndpoint = function (endpoint) {
  types.check.string(endpoint);

  this.storage[ENDPOINT] = endpoint;

  return this;
};

/**
 * Sets the query.
 */
Search.prototype.setQuery = function (query) {
  types.check.string(query);

  this.storage[QUERY] = query;

  return this;
};

/**
 * Sets the version.
 */
Search.prototype.setVersion = function (version) {
  types.check.string(version);

  this.storage[VERSION] = version;

  return this;
};

module.exports = Search;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./Request.js":81,"bfs-km-types":370}],83:[function(require,module,exports){
'use strict';

exports.Hub = require('./Hub.js');
exports.Request = require('./Request.js');
exports.Search = require('./Search.js');

},{"./Hub.js":80,"./Request.js":81,"./Search.js":82}],84:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Session = undefined;

var _bfsKmTypes = require('bfs-km-types');

var _bfsKmTypes2 = _interopRequireDefault(_bfsKmTypes);

var _live = require('../live');

var _live2 = _interopRequireDefault(_live);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class Session {
  constructor() {
    this.storage = {
      catalogue: '',
      country: '',
      incognito: false,
      locale: '',
      online: true,
      platform: 'zelda',
      username: ''
    };

    this.listen();
  }

  static createMock() {
    class Mock extends Session {
      listen() {}
    }

    return new Mock();
  }

  getCatalogue() {
    return this.storage.catalogue;
  }

  getCountry() {
    return this.storage.country;
  }

  getIncognito() {
    return this.storage.incognito;
  }

  getLocale() {
    return this.storage.locale;
  }

  getOnline() {
    return this.storage.online;
  }

  getPlatform() {
    return this.storage.platform;
  }

  getUsername() {
    return this.storage.username;
  }

  /**
   * A method that makes the session listen for state changes from the client.
   */
  listen() {
    const client = (0, _live2.default)('spotify:client');
    const query = 'currentUser(username), session(country, incognito, language, online)';

    client.query(query, (error, json) => {
      if (_bfsKmTypes2.default.conforms(json, { currentUser: {} })) {
        this.parseCurrentUser(json.currentUser);
      }

      client.get('currentUser').on('update', data => {
        this.parseCurrentUser(data);
      });

      if (_bfsKmTypes2.default.conforms(json, { session: {} })) {
        this.parseSession(json.session);
      }

      client.get('session').on('update', data => {
        this.parseSession(data);
      });
    });
  }

  parseCurrentUser(json) {
    if (_bfsKmTypes2.default.conforms(json, { username: '' })) {
      this.storage.username = json.username;
    }
  }

  parseSession(json) {
    if (_bfsKmTypes2.default.conforms(json, { catalogue: '' })) {
      this.storage.catalogue = json.catalogue;
    }

    if (_bfsKmTypes2.default.conforms(json, { country: '' })) {
      this.storage.country = json.country;
    }

    if (_bfsKmTypes2.default.conforms(json, { incognito: false })) {
      this.storage.incognito = json.incognito;
    }

    if (_bfsKmTypes2.default.conforms(json, { language: '' })) {
      this.storage.locale = json.language;
    }

    if (_bfsKmTypes2.default.conforms(json, { online: false })) {
      this.storage.online = json.online;
    }
  }
}
exports.Session = Session;

},{"../live":210,"bfs-km-types":370}],85:[function(require,module,exports){
'use strict';

const TEN_PER_SECOND_FOR_A_YEAR = 10 * 60 * 60 * 24 * 365;

const COSMOS_VERBS = ['GET', 'HEAD', 'POST', 'PUT', 'SUB', 'PATCH', 'DELETE'];

const ERROR_PREFIX = 'bridge.cosmosRequest: ';

// Base function that doesn't have any dependencies on it's own. Expects to get
// state (a plain, empty object) injected in addition to a bridge request
// function.
function cosmosRequest(state, bridge, opts, callback) {
  if (opts.url) throw new Error(`${ERROR_PREFIX}"url" is not a valid option, did you mean "uri"?`);

  if (typeof opts.uri !== 'string') throw new Error(`${ERROR_PREFIX}Expected uri to be string.`);

  if (COSMOS_VERBS.indexOf(opts.method) === -1) {
    throw new Error(`${ERROR_PREFIX}Method must match valid verb in uppercase (GET, POST etc)`);
  }

  if (opts.body && typeof opts.body !== 'string') {
    throw new Error(`${ERROR_PREFIX}If body is provided it should be a string.`);
  }

  if (opts.headers && Object.prototype.toString.call(opts.headers) !== '[object Object]') {
    throw new Error(`${ERROR_PREFIX}Expected headers be a plain object.`);
  }

  const cosmosOptions = {
    action: opts.method,
    uri: opts.uri
  };
  if (opts.body) cosmosOptions.body = opts.body;
  if (opts.headers) cosmosOptions.headers = opts.headers;

  /* Cosmos requires each request to have a unique ID. Ideally, this would be
  uuids, but unfortunately, it is integers. This means that in apps that for
  some reason need to use spotify-cosmos-api, there would between the two
  counters if cosmosRequest started from 0. To make it safe for the two
  implemenations to co-exist if needed, we begin counting at
  significantly higher number: */
  state.requestIDCounter = state.requestIDCounter || TEN_PER_SECOND_FOR_A_YEAR;
  state.requestIDCounter++;

  const requestArguments = [state.requestIDCounter, cosmosOptions];

  let isCanceled = false;
  const stateRequestIDCounter = state.requestIDCounter;

  function cancelFunction() {
    isCanceled = true;
    bridge('cosmos_request_cancel', [stateRequestIDCounter]);
  }

  // run is a recursive function that does a bridge request and then keeps
  // pulling values after every response in the case of a subscription. In
  // case we are not subscribing, or the cancelFunction has been called,
  // run sends cosmos_request_cancel and terminates.
  function run(isFirst, requestIDCounter) {
    const messageName = isFirst ? 'cosmos_request_create' : 'cosmos_request_pull';
    bridge(messageName, requestArguments, function (error, responseString) {
      // The request to cancel may not have gotten to the bridge
      // before the original request got resolved,
      // so make sure not to continue if we detect it's been canceled.
      if (isCanceled) {
        return;
      }
      try {
        if (callback) {
          if (error) {
            callback(error);
          } else {
            callback(null, responseString);
          }
        }
      } finally {
        if (opts.method !== 'SUB') {
          // If the request was a non-SUB, tell core to clean up the request.
          // NOTE: Not sure if this is strictly necessary,
          // have not been to investigate in C++-land, so for now
          // we are just mimicing the behavior of spotify-cosmos-api.
          bridge('cosmos_request_cancel', [requestIDCounter]);
        } else if (!isCanceled) {
          // maybe canceled in above callback
          run(false, requestIDCounter);
        }
      }
    });
  }

  run(true, stateRequestIDCounter);

  return cancelFunction;
}

module.exports = cosmosRequest;

},{}],86:[function(require,module,exports){
(function (global){
'use strict';

const debug = require('../debug')('bridge');
const defer = require('spotify-deferred');

const cosmosBaseFunction = require('./cosmos');

// NOTE: Implicit global state.
let scheduledCoreFlush = false;
let cosmosState = null;

exports.cosmos = cosmos;
exports.cosmosJSON = cosmosJSON;
exports.request = request;
exports._request = _request;

function cosmos() {
  if (!cosmosState) cosmosState = {};

  const baseArguments = [cosmosState, request];
  const cancelFunction = cosmosBaseFunction.apply(null, baseArguments.concat(Array.prototype.slice.call(arguments)));
  return cancelFunction;
}

function _createCallbackWrapper(callback) {
  return function callbackWrapper(err, response) {
    let newErr = err;
    if (!newErr) {
      if (response && !response.body && response.status >= 400) {
        newErr = new Error(`${response.uri} responded with status ${response.status}`);
        callback(newErr, response);
        return;
      }
      let parsedResponse;
      try {
        parsedResponse = JSON.parse(response.body);
      } catch (e) {
        e.message = `Failed to parse cosmos response: ${e.message}`;
        callback(e);
        return;
      }
      callback(null, parsedResponse);
    } else {
      callback(newErr, response);
    }
  };
}

function cosmosJSON(opts, callback) {
  if (opts.body) {
    opts.body = JSON.stringify(opts.body);
  }
  const callbackWrapper = callback ? _createCallbackWrapper(callback) : null;
  const cancelFunction = cosmos(opts, callbackWrapper);
  return cancelFunction;
}

function request(name, optArgs, optCallback) {
  const args = optArgs || [];
  const callback = getCallback(name, args, optCallback);

  debug(`req:${name}`, args);

  exports._request(name, args, callback);

  if (name.endsWith('_metadata') && !scheduledCoreFlush) {
    scheduledCoreFlush = true;
    defer(flushCore);
  }

  return exports;
}

function _request(name, args, callback) {
  if (global && typeof global._getSpotifyModule === 'function') {
    global._getSpotifyModule('bridge').executeRequest(JSON.stringify({
      name: name,
      args: args
    }), {
      onSuccess: getSuccessHandler(callback),
      onFailure: getFailureHandler(callback, name, args)
    });
  }
}

function getCallback(name, args, optUserCallback) {
  const userCallback = optUserCallback || function () {};

  return function (error, data) {
    if (error) {
      if (error.name === 'timeout') {
        // Set the delay between 300ms and 400ms
        const delay = 300 + Math.floor(Math.random() * 100);

        debug('timeout', error.message);

        // Retry the request
        setTimeout(function () {
          request(name, args, userCallback);
        }, delay);
        return;
      }
    }

    debug(`res:${name}`, args, data);

    userCallback(error, data);
  };
}

function getSuccessHandler(requestCallback) {
  return function (data) {
    let parsed;

    debug('success', data);

    try {
      parsed = JSON.parse(data);
    } catch (error) {
      requestCallback(error);
    }

    if (parsed) {
      requestCallback(null, parsed);
    }
  };
}

function getFailureHandler(requestCallback, name, args) {
  return function (data) {
    let parsed;

    debug('failure', data);
    try {
      parsed = JSON.parse(data);
    } catch (error) {
      if (data instanceof Error) {
        requestCallback(data);
      } else {
        error.message += `\nResponse Data: ${data}`;
        requestCallback(error);
      }
    }

    if (parsed) {
      requestCallback(createError(name, args, parsed));
    }
  };
}

function createError(name, args, response) {
  const argsString = JSON.stringify(args);
  const innerDebug = ` (bridge message: '${name}', args: ${argsString})`;
  const msg = response.message + innerDebug;
  const error = new Error(msg);
  error.name = response.error;

  return error;
}

function flushCore() {
  scheduledCoreFlush = false;
  request('core_flush');
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../debug":90,"./cosmos":85,"spotify-deferred":724}],87:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
const operationCanceledError = {
  name: 'OperationCanceledError',
  message: 'An async operation was cancelled'
};

class CancellationToken {
  // Internal constructor: only a CancellationTokenSource should create
  // a CancellationToken.
  constructor(source) {
    this.source = source;
    this.requestId = source.requestId;
  }

  isCanceled() {
    return this.requestId !== this.source.requestId;
  }

  throwIfCanceled() {
    if (this.isCanceled()) {
      throw operationCanceledError;
    }
  }

  errorIfCanceled() {
    if (this.isCanceled()) {
      return operationCanceledError;
    }
    return undefined;
  }

  operationCanceledError() {
    return operationCanceledError;
  }
}

class CancellationTokenSource {
  constructor() {
    this.requestId = 0;
  }

  // Create a new token that can be cancelled by canlling cancel() in the
  // CancellationTokenSource.
  token() {
    return new CancellationToken(this);
  }

  // Cancel all the tokens created so far.
  cancel() {
    this.requestId++;
  }
}
exports.default = CancellationTokenSource;

},{}],88:[function(require,module,exports){
(function (global){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
const hasFlag = exports.hasFlag = name => {
  return !!(global.__spotify && global.__spotify.product_state && global.__spotify.product_state.hasOwnProperty(name));
};

const hasValue = exports.hasValue = (name, value) => {
  return hasFlag(name) && global.__spotify.product_state[name] === value;
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],89:[function(require,module,exports){
'use strict';

const parser = require('../live/util/parser');

const sortMap = {
  track: {
    _replace: '',
    artists: {
      _replace: 'artist'
    },
    disc: {
      _replace: 'discNumber'
    },
    number: {
      _replace: 'trackNumber'
    },
    duration: {
      _replace: 'length'
    }
  },
  timeSinceAdded: {
    _reverse: true,
    _replace: 'addTime'
  },
  addedBy: {
    _replace: '',
    name: {
      _replace: 'addedByDisplayName'
    }
  }
};

function reverse(direction) {
  return direction === 'ASC' ? 'DESC' : 'ASC';
}

function walk(query, mapping, optDirection, incomingCollector) {
  const results = [];
  const collector = incomingCollector && incomingCollector.slice() || [];

  query.mask.forEach(item => {
    const itemCollector = collector.slice();

    if (item.key) {
      const hasReplace = mapping && mapping[item.key] && mapping[item.key]._replace !== null && mapping[item.key]._replace !== undefined;

      let value = hasReplace ? mapping[item.key]._replace : item.key;
      if (value !== '') {
        // Only add the direction if there's not another sub object
        if (!item.mask) {
          const doReverse = !!(mapping && mapping[item.key] && mapping[item.key]._reverse);
          if (optDirection) {
            const newOptDirection = optDirection.toUpperCase();
            const direction = doReverse ? reverse(newOptDirection) : newOptDirection;
            value += ` ${direction}`;
          }
        }
        itemCollector.push(value);
      }
    }

    if (item.mask) {
      const subLookUp = walk(item, mapping[item.key], optDirection, itemCollector);
      if (subLookUp.length) {
        results.push(subLookUp);
      }
    } else {
      if (itemCollector.length) {
        results.push(itemCollector.join('.'));
      }
    }
  });
  return results;
}

function getParams(query, optDirection, optMap) {
  const parsed = parser(query);
  if (!query) return null;

  const map = optMap || sortMap;
  const result = walk(parsed, map, optDirection);

  return result.join(',');
}

module.exports = getParams;

},{"../live/util/parser":213}],90:[function(require,module,exports){
'use strict';

let initialized = false;
let debug;

/**
 * This module is needed so that the debug module can be enabled before it's used
 * via the 'debugEnabled' product state flag or the 'data-debug' iframe attribute
 * assigned by zlink. If debug is 'import'ed instead of required it gets evaluated
 * and potentially used by other 'import'ed modules before getting enabled.
 *
 * This works exactly the same as the debug module except we dynamically
 * require 'debug' only the first time a debug namespace is created.
 * @param {String} namespace
 * @return {Function}
 */
const spDebug = function spDebug(namespace) {
  if (!initialized) {
    debug = require('debug');
    spDebug.enable = debug.enable.bind(debug);
    spDebug.disable = debug.disable.bind(debug);
    /**
     * This attribute is updated by zlink when it loads an app's iframe
     */
    if (typeof window !== 'undefined' && window.frameElement) {
      const enabled = window.frameElement.getAttribute('data-debug');
      if (enabled) debug.enable(enabled);
    }

    const productState = typeof __spotify !== 'undefined' && __spotify.product_state ? __spotify.product_state : {};
    const debugEnable = productState.debugEnable || productState.debugenable;
    if (debugEnable) {
      debug.enable(debugEnable);
    }

    if (typeof __spotify !== 'undefined' && __spotify.product_state && __spotify.product_state['ta-environment'] === '1') {
      /**
        * Normal CEF object-formatting results in missing data in Selenium logs, so we use
        * JSON.stringify objects to force a string representation.
        * Also, colors are not supported in Selenium-exported logs, and attempted use will result in junk characters.
        */
      debug.useColors = () => false;
      debug.formatters.o = obj => {
        try {
          return JSON.stringify(obj);
        } catch (e) {
          console.error('Unable to stringify object', e);
          return '';
        }
      };
    }
    initialized = true;
  }

  return debug(namespace);
};

module.exports = spDebug;

},{"debug":383}],91:[function(require,module,exports){
'use strict';

exports.expose = function (global, name, object, output) {
  if (global.__spotify && global.__spotify.developer_mode) {
    Object.defineProperty(global, name, {
      get: function () {
        (output || console.warn.bind(console))(`window.${name} should only be accessed from the ` + 'console! If you see this and did not use the console something ' + 'is misbehaving.');
        return object;
      },
      enumerable: true,
      configurable: true
    });
  }
};

},{}],92:[function(require,module,exports){
(function (global){
'use strict';

exports.init = function () {
  require('./').expose(global, 'live', require('../live'));
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../live":210,"./":91}],93:[function(require,module,exports){
(function (global){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.addDebouncedScrollListener = addDebouncedScrollListener;
exports.removeDebouncedScrollListener = removeDebouncedScrollListener;
exports.requestFrame = requestFrame;
exports.cancelFrame = cancelFrame;
exports._reset = _reset;
let scrollNodeToListenerInfoList = new global.Map();
let idToScrollNode = {};
let frameListenerInfoList = [];
let hasQueuedScroll = false;
let lastScrollEvent = null;
let lastFrameRequestId = 0;
let globalIdCounter = 0;

function onScroll(event) {
  lastScrollEvent = event;

  if (!hasQueuedScroll) {
    hasQueuedScroll = true;

    const listenerInfoList = scrollNodeToListenerInfoList.get(event.target);
    if (listenerInfoList) {
      let list;
      requestFrame(() => {
        hasQueuedScroll = false;

        // Make a copy so that a potential handler that removes a handler
        // doesn't disturb the loop. This same copy will also be used in the
        // write handler, to prevent disturbing the write loop when handlers are
        // removed in the read loop.
        list = listenerInfoList.slice();

        callReadHandlers(list, lastScrollEvent);
      }, () => {
        callWriteHandlers(list, lastScrollEvent);
      });
    }
  }
}

function onFrame(timestamp) {
  lastFrameRequestId = 0;

  // Remove all current listeners as they are only valid for one frame. Just
  // like the regular requestAnimationFrame the handler needs to request a new
  // frame if it needs one.
  const listenerInfoList = frameListenerInfoList;
  frameListenerInfoList = [];

  callReadHandlers(listenerInfoList, timestamp);
  callWriteHandlers(listenerInfoList, timestamp);
}

function callReadHandlers(listenerInfoList, handlerArgument) {
  listenerInfoList.forEach(listenerInfo => {
    if (listenerInfo.readFunction) {
      listenerInfo.readFunction(handlerArgument);
    }
  });
}

function callWriteHandlers(listenerInfoList, handlerArgument) {
  listenerInfoList.forEach(listenerInfo => {
    if (typeof listenerInfo.writeFunction === 'function') {
      listenerInfo.writeFunction(handlerArgument);
    }
  });
}

function addDebouncedScrollListener(scrollNode, readFunction, writeFunction) {
  if (readFunction !== null && typeof readFunction !== 'function') {
    throw new TypeError('The callback provided to addDebouncedScrollListener as parameter 2 is ' + 'not a function.');
  }
  if (writeFunction !== undefined && typeof writeFunction !== 'function') {
    throw new TypeError('The callback provided to addDebouncedScrollListener as parameter 3 is ' + 'not a function.');
  }

  if (!scrollNodeToListenerInfoList.has(scrollNode)) {
    scrollNode.addEventListener('scroll', onScroll);
    scrollNodeToListenerInfoList.set(scrollNode, []);
  }

  const id = ++globalIdCounter;
  const listenerInfo = {
    id,
    readFunction,
    writeFunction
  };

  idToScrollNode[id] = scrollNode;
  scrollNodeToListenerInfoList.get(scrollNode).push(listenerInfo);

  return id;
}

function removeDebouncedScrollListener(id) {
  const scrollNode = idToScrollNode[id];
  if (scrollNode) {
    delete idToScrollNode[id];

    const listenerInfoList = scrollNodeToListenerInfoList.get(scrollNode);
    if (listenerInfoList) {
      for (let i = 0; i < listenerInfoList.length; i++) {
        if (listenerInfoList[i].id === id) {
          listenerInfoList.splice(i, 1);
          break;
        }
      }
    }

    if (listenerInfoList.length === 0) {
      scrollNode.removeEventListener('scroll', onScroll);
      scrollNodeToListenerInfoList.delete(scrollNode);
    }
  }
}

function requestFrame(readFunction, writeFunction) {
  if (readFunction !== null && typeof readFunction !== 'function') {
    throw new TypeError('The callback provided to requestFrame as parameter 1 is not a function.');
  }
  if (writeFunction !== undefined && typeof writeFunction !== 'function') {
    throw new TypeError('The callback provided to requestFrame as parameter 2 is not a function.');
  }

  if (lastFrameRequestId === 0) {
    lastFrameRequestId = window.requestAnimationFrame(onFrame);
  }

  const id = ++globalIdCounter;
  const listenerInfo = {
    id,
    readFunction,
    writeFunction
  };

  frameListenerInfoList.push(listenerInfo);

  return id;
}

function cancelFrame(id) {
  for (let i = 0; i < frameListenerInfoList.length; i++) {
    if (frameListenerInfoList[i].id === id) {
      frameListenerInfoList.splice(i, 1);
      break;
    }
  }

  if (lastFrameRequestId !== 0 && frameListenerInfoList.length === 0) {
    window.cancelAnimationFrame(lastFrameRequestId);
    lastFrameRequestId = 0;
  }
}

// Use only for testing, to be able to reset the state for each test
function _reset() {
  scrollNodeToListenerInfoList = new global.Map();
  idToScrollNode = {};
  frameListenerInfoList = [];
  hasQueuedScroll = false;
  lastScrollEvent = null;
  lastFrameRequestId = 0;
  globalIdCounter = 0;
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],94:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * The Top Bar sits at the top of the main content area and contains the navigation
 * arrows, search field and profile menu. This fixed height value is used for a number
 * of calculations across the client.
 *
 * This constant needs to be kept in sync with $header-height-new-headers
 * from `libs/glue/sass/reference/variables.scss`
 */
const TOP_BAR_HEIGHT = exports.TOP_BAR_HEIGHT = 48;

/**
 * Breakpoints are used to control the responsive behaviour of views within the client.
 * These values are currently mirrored from `libs/glue/sass/reference/variables.scss`
 */
const BREAKPOINTS = exports.BREAKPOINTS = {
  'glue-min': 376,
  'glue-sm': 592,
  'glue-md': 820,
  'glue-lg': 1280,
  'glue-max': 1496
};

},{}],95:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class GlueHandlebarsTemplate extends _react2.default.Component {
  shouldComponentUpdate() {
    return this.props.shouldUpdate;
  }

  render() {
    const { template, data } = this.props;

    return _react2.default.createElement('div', { dangerouslySetInnerHTML: { __html: template(data) } });
  }
}

exports.default = GlueHandlebarsTemplate;
GlueHandlebarsTemplate.propTypes = {
  template: _propTypes2.default.func,
  data: _propTypes2.default.object,
  shouldUpdate: _propTypes2.default.bool
};

GlueHandlebarsTemplate.defaultProps = {
  template() {
    return '';
  },
  data: {},
  shouldUpdate: true
};

},{"prop-types":495,"react":697}],96:[function(require,module,exports){
module.exports={
  "Album": "Album",
  "AndMore": "a {0} další(ch)",
  "Artist": "Umělec",
  "By": "od",
  "ByLabel": "Od",
  "Create Similar Playlist": "Vytvořit podobný playlist",
  "DateAdded": "Datum přidání",
  "Duration": "Délka",
  "Recommended Songs": "Doporučené skladby",
  "Filter": "Filtr",
  "Follow": "Sledovat",
  "Follower": "Sledující",
  "FollowersLabel": {
    "one": "Sledující",
    "other": "sledujících"
  },
  "FollowersCount": {
    "one": "{0} sledující",
    "other": "{0} sledujících"
  },
  "Following": "Sleduješ",
  "FollowingLabel": "Sleduješ",
  "ListenersLabel": "Posluchačů měsíčně",
  "FollowsYou": "Sleduje tě",
  "HoldToPreview": "Pro náhled klikni a podrž",
  "ListenCount": {
    "one": "1 přehrání",
    "other": "{0} přehrání"
  },
  "ListenReactionMulti": "{0} posluchačů ve tvé síti",
  "ListenReactionSingle": "{0} uživatelů tohle poslouchá",
  "LocalFile": "Místní soubory",
  "More": "dalších",
  "MoreSongsLoad": "Během přehrávání se načtou další skladby.",
  "Pause": "Pozastavit",
  "Play": "Přehrát",
  "Playlist": "Playlist",
  "PressEnterToPlay": "Přehrávání spustíš stisknutím klávesy Enter",
  "Popularity": "Popularita",
  "Progress": "Postup",
  "Remove": "Odstranit",
  "RemoveYourMusic": "Odstranit ze sbírky Tvoje knihovna",
  "Save": "Uložit",
  "SaveYourMusic": "Uložit do sbírky Tvoje knihovna",
  "Saved": "Uloženo",
  "StartRadio": "Spustit rádio",
  "Time": "Čas",
  "Title": "Název",
  "Toplist": "Top skladby",
  "Track": "Skladba",
  "Unfollow": "Přestat sledovat",
  "User": "Uživatel",
  "ViewAll": "Zobrazit vše",
  "HoursShort": "{0} h",
  "MinutesShort": "{0} min",
  "SecondsShort": "{0} s",
  "ErrorTitle": "Při zobrazování této stránky došlo k problému!",
  "ErrorMessage": "Tato stránka buď neexistuje, nebo došlo k chybě.",
  "OfflineTitle": "Tato stránka není dostupná offline!",
  "OfflineMessage": "Pro načtení přejdi prosím online.",
  "MadeFor": "Speciálně pro uživatele {0}",
  "heart_label": "Líbí se mi",
  "undo_heart_label": "Líbilo se mi",
  "ban_label": "Odstranit",
  "format_list.ban_label-like": "Nelíbí se mi",
  "format_list.ban_label-rec": "Toto mi nedoporučujte",
  "format_list.undo_ban_label-like": "Tohle se ti nelíbí",
  "format_list.undo_ban_label-rec": "Toto nebudeme doporučovat"
}
},{}],97:[function(require,module,exports){
module.exports={
  "Album": "Album",
  "AndMore": "und {0} weitere",
  "Artist": "Künstler",
  "By": "von",
  "ByLabel": "Von",
  "Create Similar Playlist": "Ähnliche Playlist erstellen",
  "DateAdded": "Datum hinzugefügt",
  "Duration": "Dauer",
  "Recommended Songs": "Empfohlene Songs",
  "Filter": "Filter",
  "Follow": "Folgen",
  "Follower": "Follower",
  "FollowersLabel": {
    "one": "Follower",
    "other": "Follower"
  },
  "FollowersCount": {
    "one": "{0} Follower",
    "other": "{0} Follower"
  },
  "Following": "Folge ich",
  "FollowingLabel": "Folge ich",
  "ListenersLabel": "Monatliche Hörer",
  "FollowsYou": "Folgt dir",
  "HoldToPreview": "Zum Reinhören gedrückt halten",
  "ListenCount": {
    "one": "1 Wiedergabe",
    "other": "{0} Mal abgespielt"
  },
  "ListenReactionMulti": "{0} Hörer in Deinem Netzwerk",
  "ListenReactionSingle": "{0} hört sich das an",
  "LocalFile": "Lokale Datei",
  "More": "Mehr",
  "MoreSongsLoad": "Während du Musik hörst, werden weitere Songs geladen.",
  "Pause": "Pause",
  "Play": "Play",
  "Playlist": "Playlist",
  "PressEnterToPlay": "Drück die Eingabetaste zum Abspielen",
  "Popularity": "Beliebtheit",
  "Progress": "Fortschritt",
  "Remove": "Entfernen",
  "RemoveYourMusic": "Aus Bibliothek entfernen",
  "Save": "Speichern",
  "SaveYourMusic": "In Bibliothek speichern",
  "Saved": "Gespeichert",
  "StartRadio": "Radio starten",
  "Time": "Dauer",
  "Title": "Titel",
  "Toplist": "Top-Songs",
  "Track": "Song",
  "Unfollow": "Nicht mehr folgen",
  "User": "Benutzer",
  "ViewAll": "Mehr Darstellung",
  "HoursShort": "{0} Std.",
  "MinutesShort": "{0} Min.",
  "SecondsShort": "{0} Sek.",
  "ErrorTitle": "Bei der Anzeige dieser Seite ist ein Fehler aufgetreten.",
  "ErrorMessage": "Diese Seite ist entweder nicht vorhanden oder es ist ein Fehler aufgetreten.",
  "OfflineTitle": "Diese Seite ist offline nicht verfügbar.",
  "OfflineMessage": "Geh zum Laden online.",
  "MadeFor": "Für {0}",
  "heart_label": "Gefällt mir",
  "undo_heart_label": "Gefällt mir",
  "ban_label": "Entfernen",
  "format_list.ban_label-like": "Gefällt dir nicht",
  "format_list.ban_label-rec": "Nicht mehr empfehlen",
  "format_list.undo_ban_label-like": "Das gefällt dir nicht",
  "format_list.undo_ban_label-rec": "Diese Empfehlung wird nicht mehr angezeigt."
}
},{}],98:[function(require,module,exports){
module.exports={
  "Album": "Άλμπουμ",
  "AndMore": "και άλλοι {0}",
  "Artist": "Καλλιτέχνης",
  "By": "από",
  "ByLabel": "Από",
  "Create Similar Playlist": "Δημιουργία παρόμοιας playlist",
  "DateAdded": "Προστέθηκε ημερομηνία",
  "Duration": "Διάρκεια",
  "Recommended Songs": "Προτεινόμενα τραγούδια",
  "Filter": "Φίλτρο",
  "Follow": "Ακολούθησε",
  "Follower": "Οπαδός",
  "FollowersLabel": {
    "one": "Οπαδός",
    "other": "Ακόλουθοι"
  },
  "FollowersCount": {
    "one": "{0} οπαδός",
    "other": "{0} οπαδοί"
  },
  "Following": "Aκολουθείται",
  "FollowingLabel": "Aκολουθείται",
  "ListenersLabel": "Μηνιαίοι ακροατές",
  "FollowsYou": "Σε ακολουθεί",
  "HoldToPreview": "Πάτησε και κράτησε πατημένο για προεπισκόπηση",
  "ListenCount": {
    "one": "1 αναπαραγωγή",
    "other": "{0} αναπαραγωγές"
  },
  "ListenReactionMulti": "{0} ακροατές στο δίκτυό σου",
  "ListenReactionSingle": "Ο χρήστης {0} ακούει αυτό",
  "LocalFile": "Τοπικό αρχείο",
  "More": "Περισσότερα",
  "MoreSongsLoad": "Περισσότερα τραγούδια φορτώνουν ενώ ακούς",
  "Pause": "Παύση",
  "Play": "Αναπαραγωγή",
  "Playlist": "Λίστα",
  "PressEnterToPlay": "Πάτησε Enter για αναπαραγωγή",
  "Popularity": "Δημοφιλία",
  "Progress": "Πρόοδος",
  "Remove": "Αφαίρεση",
  "RemoveYourMusic": "Αφαίρεση από τη Βιβλιοθήκη",
  "Save": "Αποθήκευση",
  "SaveYourMusic": "Αποθήκευση στη Βιβλιοθήκη",
  "Saved": "Αποθηκεύτηκε",
  "StartRadio": "Έναρξη ράδιο",
  "Time": "Διάρκεια",
  "Title": "Τίτλος",
  "Toplist": "Κορυφαία τραγούδια",
  "Track": "Τραγούδι",
  "Unfollow": "Άρση ακολούθησης",
  "User": "Χρήστης",
  "ViewAll": "Δες τα όλα",
  "HoursShort": "{0} ώρα",
  "MinutesShort": "{0} λεπ.",
  "SecondsShort": "{0} δευτ.",
  "ErrorTitle": "Παρουσιάστηκε πρόβλημα κατά την προβολή αυτής της σελίδας!",
  "ErrorMessage": "Αυτή η σελίδα δεν υπάρχει ή προέκυψε κάποιο σφάλμα.",
  "OfflineTitle": "Αυτή η σελίδα δεν είναι διαθέσιμη εκτός σύνδεσης!",
  "OfflineMessage": "Συνδέσου στο διαδίκτυο για να πραγματοποιηθεί φόρτωση.",
  "MadeFor": "Ειδικά για: {0}",
  "heart_label": "Μου αρέσει",
  "undo_heart_label": "Αρέσει σε",
  "ban_label": "Αφαίρεση",
  "format_list.ban_label-like": "Δεν μου αρέσει",
  "format_list.ban_label-rec": "Μη μου το προτείνετε αυτό",
  "format_list.undo_ban_label-like": "Δεν σου αρέσει αυτό",
  "format_list.undo_ban_label-rec": "Δεν θα προτείνουμε αυτό"
}
},{}],99:[function(require,module,exports){
module.exports={
  "Album": "Album",
  "AndMore": "and {0} more",
  "Artist": "Artist",
  "By": "by",
  "ByLabel": "By",
  "Create Similar Playlist": "Create Similar Playlist",
  "DateAdded": "Date Added",
  "Duration": "Duration",
  "Recommended Songs": "Recommended Songs",
  "Filter": "Filter",
  "Follow": "Follow",
  "Follower": "Follower",
  "FollowersLabel": {
    "one": "Follower",
    "other": "Followers"
  },
  "FollowersCount": {
    "one": "{0} follower",
    "other": "{0} followers"
  },
  "Following": "Following",
  "FollowingLabel": "Following",
  "ListenersLabel": "Monthly Listeners",
  "FollowsYou": "Follows You",
  "HoldToPreview": "Click and Hold to Preview",
  "ListenCount": {
    "one": "1 play",
    "other": "{0} plays"
  },
  "ListenReactionMulti": "{0} listeners in your network",
  "ListenReactionSingle": "{0} listens to this",
  "LocalFile": "Local File",
  "More": "More",
  "MoreSongsLoad": "More songs load as you listen",
  "Pause": "Pause",
  "Play": "Play",
  "Playlist": "Playlist",
  "PressEnterToPlay": "Press Enter to play",
  "Popularity": "Popularity",
  "Progress": "Progress",
  "Remove": "Remove",
  "RemoveYourMusic": "Remove from Your Library",
  "Save": "Save",
  "SaveYourMusic": "Save to Your Library",
  "Saved": "Saved",
  "StartRadio": "Start Radio",
  "Time": "Time",
  "Title": "Title",
  "Toplist": "Top songs",
  "Track": "Song",
  "Unfollow": "Unfollow",
  "User": "User",
  "ViewAll": "View All",
  "HoursShort": "{0} hr",
  "MinutesShort": "{0} min",
  "SecondsShort": "{0} sec",
  "ErrorTitle": "There was a problem displaying this page!",
  "ErrorMessage": "This page either does not exist or an error occurred.",
  "OfflineTitle": "This page is not available offline!",
  "OfflineMessage": "Please go online to load.",
  "MadeFor": "Made for {0}",
  "heart_label": "Like",
  "undo_heart_label": "Liked",
  "ban_label": "Remove",
  "format_list.ban_label-like": "Don't like",
  "format_list.ban_label-rec": "Don't recommend this to me",
  "format_list.undo_ban_label-like": "You don't like this",
  "format_list.undo_ban_label-rec": "We won't recommend this"
}
},{}],100:[function(require,module,exports){
module.exports={
  "Album": "Álbum",
  "AndMore": "y {0} más",
  "Artist": "Artista",
  "By": "por",
  "ByLabel": "De",
  "Create Similar Playlist": "Crear playlist similar",
  "DateAdded": "Fecha agregada",
  "Duration": "Duración",
  "Recommended Songs": "Canciones recomendadas",
  "Filter": "Filtrar",
  "Follow": "Seguir",
  "Follower": "Seguidor",
  "FollowersLabel": {
    "one": "Seguidor",
    "other": "Seguidores"
  },
  "FollowersCount": {
    "one": "{0} seguidor",
    "other": "{0} seguidores"
  },
  "Following": "Siguiendo",
  "FollowingLabel": "Siguiendo",
  "ListenersLabel": "Oyentes mensuales",
  "FollowsYou": "Te sigue",
  "HoldToPreview": "Haz clic y mantén pulsado para oír la muestra preliminar",
  "ListenCount": {
    "one": "1 reproducción",
    "other": "{0} reproducciones"
  },
  "ListenReactionMulti": "{0} oyentes en tu red",
  "ListenReactionSingle": "{0} escucha esto",
  "LocalFile": "Archivo local",
  "More": "Más",
  "MoreSongsLoad": "Se cargarán más canciones a medida que escuchas",
  "Pause": "Pausa",
  "Play": "Reproducir",
  "Playlist": "Lista",
  "PressEnterToPlay": "Presiona Enter para reproducir",
  "Popularity": "Popularidad",
  "Progress": "Progreso",
  "Remove": "Eliminar",
  "RemoveYourMusic": "Eliminar de Tu Biblioteca",
  "Save": "Guardar",
  "SaveYourMusic": "Guardar en Tu Biblioteca",
  "Saved": "Guardado",
  "StartRadio": "Comenzar Radio",
  "Time": "Tiempo",
  "Title": "Título",
  "Toplist": "Canciones más reproducidas",
  "Track": "Canción",
  "Unfollow": "Dejar de seguir",
  "User": "Usuario",
  "ViewAll": "Ver todos",
  "HoursShort": "{0} hr",
  "MinutesShort": "{0} min",
  "SecondsShort": "{0} seg",
  "ErrorTitle": "Hubo un problema al mostrar esta página.",
  "ErrorMessage": "Puede ser que esta página no exista o que haya ocurrido un error.",
  "OfflineTitle": "Esta página no se encuentra disponible sin conexión.",
  "OfflineMessage": "Conéctate a la red para cargar.",
  "MadeFor": "Hecho para {0}",
  "heart_label": "Me gusta",
  "undo_heart_label": "Les gusta esto",
  "ban_label": "Eliminar",
  "format_list.ban_label-like": "No me gusta",
  "format_list.ban_label-rec": "No recomendarme esto",
  "format_list.undo_ban_label-like": "No te gusta esto",
  "format_list.undo_ban_label-rec": "No te recomendaremos esto"
}
},{}],101:[function(require,module,exports){
module.exports={
  "Album": "Álbum",
  "AndMore": "y {0} más",
  "Artist": "Artista",
  "By": "por",
  "ByLabel": "De",
  "Create Similar Playlist": "Crear playlist similar",
  "DateAdded": "Fecha en la que se añadió",
  "Duration": "Duración",
  "Recommended Songs": "Canciones recomendadas",
  "Filter": "Filtrar",
  "Follow": "Seguir",
  "Follower": "Seguidor",
  "FollowersLabel": {
    "one": "Seguidor",
    "other": "Seguidores"
  },
  "FollowersCount": {
    "one": "{0} seguidor",
    "other": "{0} seguidores"
  },
  "Following": "Siguiendo",
  "FollowingLabel": "Siguiendo",
  "ListenersLabel": "Oyentes mensuales",
  "FollowsYou": "Te sigue",
  "HoldToPreview": "Pulsa y mantén pulsado para oír la muestra preliminar",
  "ListenCount": {
    "one": "1 reproducción",
    "other": "{0} reproducciones"
  },
  "ListenReactionMulti": "{0} oyentes en tu red",
  "ListenReactionSingle": "{0} escucha esto",
  "LocalFile": "Archivo local",
  "More": "Más",
  "MoreSongsLoad": "Se cargarán más canciones mientras escuchas",
  "Pause": "Pausar",
  "Play": "Reproducir",
  "Playlist": "Lista",
  "PressEnterToPlay": "Pulsa Intro para reproducir",
  "Popularity": "Popularidad",
  "Progress": "Completado",
  "Remove": "Retirar",
  "RemoveYourMusic": "Eliminar de Tu biblioteca",
  "Save": "Guardar",
  "SaveYourMusic": "Guardar en Tu biblioteca",
  "Saved": "Guardada",
  "StartRadio": "Comenzar radio",
  "Time": "Tiempo",
  "Title": "Título",
  "Toplist": "Canciones más escuchadas",
  "Track": "Canción",
  "Unfollow": "Dejar de seguir",
  "User": "Usuario",
  "ViewAll": "Ver todos",
  "HoursShort": "{0} hr",
  "MinutesShort": "{0} min",
  "SecondsShort": "{0} seg",
  "ErrorTitle": "Se ha producido un problema al mostrar esta página.",
  "ErrorMessage": "Esta página no existe o se ha producido un error.",
  "OfflineTitle": "Esta página no está disponible sin conexión.",
  "OfflineMessage": "Por favor, conéctate para cargar.",
  "MadeFor": "Hecha para {0}",
  "heart_label": "Me gusta",
  "undo_heart_label": "Te gusta",
  "ban_label": "Retirar",
  "format_list.ban_label-like": "No me gusta",
  "format_list.ban_label-rec": "No recomendarme esto",
  "format_list.undo_ban_label-like": "No te gusta esto",
  "format_list.undo_ban_label-rec": "No te recomendaremos esto"
}
},{}],102:[function(require,module,exports){
module.exports={
  "Album": "Albumi",
  "AndMore": "ja {0} muuta",
  "Artist": "Artisti",
  "By": "tekijältä",
  "ByLabel": "tekijältä",
  "Create Similar Playlist": "Luo samankaltainen soittolista",
  "DateAdded": "Lisäyspäivä",
  "Duration": "Kesto",
  "Recommended Songs": "Suositellut kappaleet",
  "Filter": "Suodatin",
  "Follow": "Seuraa",
  "Follower": "Seuraaja",
  "FollowersLabel": {
    "one": "Seuraaja",
    "other": "Seuraajat"
  },
  "FollowersCount": {
    "one": "{0} seuraaja",
    "other": "{0} seuraajaa"
  },
  "Following": "Seurataan",
  "FollowingLabel": "Seurataan",
  "ListenersLabel": "Kuuntelijat kuukauden aikana",
  "FollowsYou": "Seuraa sinua",
  "HoldToPreview": "Kuuntele pätkä pitämällä tätä painettuna",
  "ListenCount": {
    "one": "1 toisto",
    "other": "{0} toistoa"
  },
  "ListenReactionMulti": "{0} kuuntelijaa verkostossasi",
  "ListenReactionSingle": "{0} kuuntelee tätä",
  "LocalFile": "Paikallinen tiedosto",
  "More": "Lisää",
  "MoreSongsLoad": "Lisää kappaleita ladataan kuuntelun aikana",
  "Pause": "Tauko",
  "Play": "Toista",
  "Playlist": "Soittolista",
  "PressEnterToPlay": "Toista painamalla Enter-näppäintä",
  "Popularity": "Suosio",
  "Progress": "Edistyminen",
  "Remove": "Poista",
  "RemoveYourMusic": "Poista omasta kirjastosta",
  "Save": "Tallenna",
  "SaveYourMusic": "Tallenna omaan kirjastoon",
  "Saved": "Tallennettu",
  "StartRadio": "Käynnistä radio",
  "Time": "Kesto",
  "Title": "Nimi",
  "Toplist": "Suosituimmat kappaleet",
  "Track": "Kappale",
  "Unfollow": "Lopeta seuraaminen",
  "User": "Käyttäjä",
  "ViewAll": "Näytä kaikki",
  "HoursShort": "{0} h",
  "MinutesShort": "{0} min",
  "SecondsShort": "{0} s",
  "ErrorTitle": "Sivun näyttämisessä ilmeni ongelma!",
  "ErrorMessage": "Sivua ei ole, tai tapahtui virhe.",
  "OfflineTitle": "Sivu ei ole saatavilla offline-tilassa!",
  "OfflineMessage": "Siirry online-tilaan, jotta voit ladata.",
  "MadeFor": "Luotu käyttäjälle {0}",
  "heart_label": "Tykkää",
  "undo_heart_label": "Tykätty",
  "ban_label": "Poista",
  "format_list.ban_label-like": "En tykkää",
  "format_list.ban_label-rec": "Älä suosittele tätä minulle",
  "format_list.undo_ban_label-like": "Et tykkää tästä",
  "format_list.undo_ban_label-rec": "Emme suosittele tätä jatkossa"
}
},{}],103:[function(require,module,exports){
module.exports={
  "Album": "Album",
  "AndMore": "et {0} autres",
  "Artist": "Artiste",
  "By": "par",
  "ByLabel": "Par",
  "Create Similar Playlist": "Créer une liste de lecture semblable",
  "DateAdded": "Ajouté le",
  "Duration": "Durée",
  "Recommended Songs": "Chansons recommandées",
  "Filter": "Filtrer",
  "Follow": "Suivre",
  "Follower": "Abonné",
  "FollowersLabel": {
    "one": "Abonné",
    "other": "Abonné"
  },
  "FollowersCount": {
    "one": "{0} abonné",
    "other": "{0} abonnés"
  },
  "Following": "Suivis",
  "FollowingLabel": "Suivis",
  "ListenersLabel": "Auditeurs mensuels",
  "FollowsYou": "Vous suit",
  "HoldToPreview": "Cliquez longuement pour avoir un aperçu",
  "ListenCount": {
    "one": "1 lecture",
    "other": "{0} écoutes"
  },
  "ListenReactionMulti": "{0} auditeurs dans votre réseau",
  "ListenReactionSingle": "{0} écoute ceci",
  "LocalFile": "Fichier local",
  "More": "Plus",
  "MoreSongsLoad": "D'autres chansons se chargent pendant que vous écoutez",
  "Pause": "Pause",
  "Play": "Lecture",
  "Playlist": "Playlist",
  "PressEnterToPlay": "Appuyez sur Entrée pour faire la lecture",
  "Popularity": "Popularité",
  "Progress": "Progression",
  "Remove": "Supprimer",
  "RemoveYourMusic": "Supprimer de la Bibliothèque",
  "Save": "Sauvegarder",
  "SaveYourMusic": "Enregistrer dans la Bibliothèque",
  "Saved": "Sauvegardé",
  "StartRadio": "Lancer la radio",
  "Time": "Durée",
  "Title": "Titre",
  "Toplist": "Meilleures chansons",
  "Track": "Titre",
  "Unfollow": "Ne plus suivre",
  "User": "Utilisateur",
  "ViewAll": "Voir tout",
  "HoursShort": "{0} h",
  "MinutesShort": "{0} min",
  "SecondsShort": "{0} s",
  "ErrorTitle": "Un problème est survenu lors de l'affichage de cette page!",
  "ErrorMessage": "Cette page n'existe pas ou une erreur s'est produite.",
  "OfflineTitle": "Cette page n'est pas accessible hors ligne!",
  "OfflineMessage": "Veuillez accéder à Internet pour charger le contenu.",
  "MadeFor": "Créée pour {0}",
  "heart_label": "J'aime",
  "undo_heart_label": "A aimé",
  "ban_label": "Supprimer",
  "format_list.ban_label-like": "Je n'aime pas",
  "format_list.ban_label-rec": "Ne me recommandez pas cela",
  "format_list.undo_ban_label-like": "Vous n’aimez pas cela",
  "format_list.undo_ban_label-rec": "Nous ne recommanderons pas cela"
}
},{}],104:[function(require,module,exports){
module.exports={
  "Album": "Album",
  "AndMore": "et {0} autres",
  "Artist": "Artiste",
  "By": "par",
  "ByLabel": "Par",
  "Create Similar Playlist": "Créer une playlist similaire",
  "DateAdded": "Ajouté le",
  "Duration": "Durée",
  "Recommended Songs": "Titres recommandés",
  "Filter": "Filtre",
  "Follow": "S'abonner",
  "Follower": "Abonné",
  "FollowersLabel": {
    "one": "Abonné",
    "other": "Abonnés"
  },
  "FollowersCount": {
    "one": "{0} abonné",
    "other": "{0} abonnés"
  },
  "Following": "Abonné",
  "FollowingLabel": "Abonné",
  "ListenersLabel": "Nombres de personnes qui écoutent par mois",
  "FollowsYou": "Est abonné à vous",
  "HoldToPreview": "Cliquez longuement pour avoir un aperçu",
  "ListenCount": {
    "one": "1 lecture",
    "other": "{0} écoutes"
  },
  "ListenReactionMulti": "{0} auditeurs dans votre réseau",
  "ListenReactionSingle": "{0} écoute ceci.",
  "LocalFile": "Fichier local",
  "More": "Plus",
  "MoreSongsLoad": "D'autres titres se chargent pendant que vous écoutez.",
  "Pause": "Pause",
  "Play": "Lire",
  "Playlist": "Playlist",
  "PressEnterToPlay": "Appuyez sur Entrée pour écouter",
  "Popularity": "Popularité",
  "Progress": "Progression",
  "Remove": "Supprimer",
  "RemoveYourMusic": "Supprimer de Bibliothèque",
  "Save": "Sauvegarder",
  "SaveYourMusic": "Sauvegarder dans Bibliothèque",
  "Saved": "Sauvegardé",
  "StartRadio": "Ecouter la radio",
  "Time": "Durée",
  "Title": "Titre",
  "Toplist": "Top titres",
  "Track": "Titre",
  "Unfollow": "Se désabonner",
  "User": "Utilisateur",
  "ViewAll": "Présentation tout",
  "HoursShort": "{0} h",
  "MinutesShort": "{0} min",
  "SecondsShort": "{0} s",
  "ErrorTitle": "Problème d'affichage !",
  "ErrorMessage": "Cette page n'existe pas, ou une erreur s'est produite.",
  "OfflineTitle": "Cette page n'est pas disponible hors connexion !",
  "OfflineMessage": "Connectez-vous pour procéder au chargement.",
  "MadeFor": "Concocté pour {0}",
  "heart_label": "J'aime",
  "undo_heart_label": "A aimé",
  "ban_label": "Supprimer",
  "format_list.ban_label-like": "Je n'aime pas",
  "format_list.ban_label-rec": "Ne pas me recommander cela",
  "format_list.undo_ban_label-like": "Vous n'aimez pas ce contenu",
  "format_list.undo_ban_label-rec": "Nous ne vous recommanderons pas cela"
}
},{}],105:[function(require,module,exports){
module.exports={
  "Album": "Album",
  "AndMore": "és még {0} felhasználó",
  "Artist": "Előadó",
  "By": "tőle:",
  "ByLabel": "Tőle:",
  "Create Similar Playlist": "Hasonló műsorlista létrehozása",
  "DateAdded": "Dátum hozzáadva",
  "Duration": "Időtartam",
  "Recommended Songs": "Ajánlott dalok",
  "Filter": "Szűrő",
  "Follow": "Követés",
  "Follower": "Követő",
  "FollowersLabel": {
    "one": "Követő",
    "other": "Követők"
  },
  "FollowersCount": {
    "one": "{0} követő",
    "other": "{0} követő"
  },
  "Following": "Követések",
  "FollowingLabel": "Követések",
  "ListenersLabel": "Hallgatók havonta",
  "FollowsYou": "Téged követ",
  "HoldToPreview": "Tartsd nyomva a belehallgatáshoz",
  "ListenCount": {
    "one": "1 lejátszás",
    "other": "{0} lejátszás"
  },
  "ListenReactionMulti": "{0} ismerősöd hallgatta meg",
  "ListenReactionSingle": "{0} már meghallgatta",
  "LocalFile": "Helyi fájl",
  "More": "Több",
  "MoreSongsLoad": "Lesz még szám, csak hallgasd tovább",
  "Pause": "Szünet",
  "Play": "Lejátszás",
  "Playlist": "Lejátszási lista",
  "PressEnterToPlay": "Lejátszás az Enterrel",
  "Popularity": "Népszerűség",
  "Progress": "Állapot",
  "Remove": "Eltávolítás",
  "RemoveYourMusic": "Törlés a Gyűjteményemből",
  "Save": "Mentés",
  "SaveYourMusic": "Mentés a Gyűjteményedbe",
  "Saved": "Mentett",
  "StartRadio": "Rádió bekapcsolása",
  "Time": "Idő",
  "Title": "Cím",
  "Toplist": "Toplista",
  "Track": "Dal",
  "Unfollow": "Nem követem",
  "User": "Felhasználó",
  "ViewAll": "Mindent mutat",
  "HoursShort": "{0} óra",
  "MinutesShort": "{0} perc",
  "SecondsShort": "{0} mp",
  "ErrorTitle": "Hiba történt az oldal megjelenítésekor.",
  "ErrorMessage": "Az oldal nem létezik, vagy hiba történt.",
  "OfflineTitle": "Ez az oldal offline módban nem érhető el.",
  "OfflineMessage": "Csatlakozz az internethez, majd indítsd el.",
  "MadeFor": "{0} felhasználónak készült",
  "heart_label": "Tetszik",
  "undo_heart_label": "Kedvelted",
  "ban_label": "Eltávolítás",
  "format_list.ban_label-like": "Nem tetszik",
  "format_list.ban_label-rec": "Nem kérem ezt az ajánlást",
  "format_list.undo_ban_label-like": "Ez nem tetszett neked",
  "format_list.undo_ban_label-rec": "Nem fogjuk ajánlani"
}
},{}],106:[function(require,module,exports){
module.exports={
  "Album": "Album",
  "AndMore": "dan {0} lagi",
  "Artist": "Artis",
  "By": "menurut",
  "ByLabel": "Dari",
  "Create Similar Playlist": "Buat Playlist Serupa",
  "DateAdded": "Tanggal Dimuat",
  "Duration": "Durasi",
  "Recommended Songs": "Lagu yang Direkomendasikan",
  "Filter": "Filter",
  "Follow": "Ikuti",
  "Follower": "Pengikut",
  "FollowersLabel": {
    "one": "Pengikut",
    "other": "Pengikut"
  },
  "FollowersCount": {
    "one": "{0} pengikut",
    "other": "{0} pengikut"
  },
  "Following": "Mengikuti",
  "FollowingLabel": "Mengikuti",
  "ListenersLabel": "Pendengar Bulanan",
  "FollowsYou": "Mengikutimu",
  "HoldToPreview": "Klik dan Tahan untuk Pratinjau",
  "ListenCount": {
    "one": "1 pemutaran",
    "other": "{0} permainan"
  },
  "ListenReactionMulti": "{0} pendengar di jaringanmu",
  "ListenReactionSingle": "{0} mendengarkan ini",
  "LocalFile": "File Lokal",
  "More": "Lainnya",
  "MoreSongsLoad": "Lebih banyak lagu dimuat saat kamu mendengarkan",
  "Pause": "Jeda",
  "Play": "Play",
  "Playlist": "Playlist",
  "PressEnterToPlay": "Tekan Enter untuk memainkan",
  "Popularity": "Popularitas",
  "Progress": "Kemajuan",
  "Remove": "Hapus",
  "RemoveYourMusic": "Hapus dari Koleksi Kamu",
  "Save": "Simpan",
  "SaveYourMusic": "Simpan ke Koleksi Kamu",
  "Saved": "Tersimpan",
  "StartRadio": "Mulai Radio",
  "Time": "Waktu",
  "Title": "Judul",
  "Toplist": "Lagu teratas",
  "Track": "Lagu",
  "Unfollow": "Berhenti mengikuti",
  "User": "Pengguna",
  "ViewAll": "Lihat Semua",
  "HoursShort": "{0} jam",
  "MinutesShort": "{0} mnt",
  "SecondsShort": "{0} dtk",
  "ErrorTitle": "Ada masalah saat menampilkan halaman ini!",
  "ErrorMessage": "Halaman ini tidak ada atau terjadi kesalahan.",
  "OfflineTitle": "Halaman ini tidak tersedia secara offline!",
  "OfflineMessage": "Alihkan ke online untuk memuat.",
  "MadeFor": "Dibuat untuk {0}",
  "heart_label": "Suka",
  "undo_heart_label": "Disukai",
  "ban_label": "Hapus",
  "format_list.ban_label-like": "Tidak suka",
  "format_list.ban_label-rec": "Jangan rekomendasikan ini kepadaku",
  "format_list.undo_ban_label-like": "Kamu tidak suka ini",
  "format_list.undo_ban_label-rec": "Kami tidak akan merekomendasikan ini"
}
},{}],107:[function(require,module,exports){
module.exports={
  "Album": "Album",
  "AndMore": "e altri {0}",
  "Artist": "Artista",
  "By": "per",
  "ByLabel": "di",
  "Create Similar Playlist": "Crea playlist simile",
  "DateAdded": "Aggiunto il",
  "Duration": "Durata",
  "Recommended Songs": "Brani consigliati",
  "Filter": "Filtra",
  "Follow": "Segui",
  "Follower": "Follower",
  "FollowersLabel": {
    "one": "Follower",
    "other": "Follower"
  },
  "FollowersCount": {
    "one": "{0} follower",
    "other": "{0} follower"
  },
  "Following": "Following",
  "FollowingLabel": "Following",
  "ListenersLabel": "Ascoltatori questo mese",
  "FollowsYou": "Ti segue",
  "HoldToPreview": "Tieni premuto per un'anteprima",
  "ListenCount": {
    "one": "1 riproduzione",
    "other": "{0} riproduzioni"
  },
  "ListenReactionMulti": "{0} ascoltatori nella tua rete",
  "ListenReactionSingle": "{0} ascolta questo",
  "LocalFile": "File locale",
  "More": "Più",
  "MoreSongsLoad": "Durante l'ascolto vengono caricati altri brani",
  "Pause": "Pausa",
  "Play": "Play",
  "Playlist": "Playlist",
  "PressEnterToPlay": "Premi Invio per riprodurre",
  "Popularity": "Popolarità",
  "Progress": "Progress",
  "Remove": "Rimuovi",
  "RemoveYourMusic": "Elimina da La tua libreria",
  "Save": "Salva",
  "SaveYourMusic": "Salva in La tua libreria",
  "Saved": "Salvato",
  "StartRadio": "Crea una radio",
  "Time": "Durata",
  "Title": "Titolo",
  "Toplist": "Brani top",
  "Track": "Brano",
  "Unfollow": "Non seguire più",
  "User": "Utente",
  "ViewAll": "Visualizza tutto",
  "HoursShort": "{0} ore",
  "MinutesShort": "{0} min.",
  "SecondsShort": "{0} sec",
  "ErrorTitle": "Si è verificato un errore nella visualizzazione di questa pagina.",
  "ErrorMessage": "Questa pagina non esiste o si è verificato un errore.",
  "OfflineTitle": "Questa pagina non è disponibile offline.",
  "OfflineMessage": "Passa online per caricare.",
  "MadeFor": "Realizzata per {0}",
  "heart_label": "Preferiti",
  "undo_heart_label": "Preferiti",
  "ban_label": "Rimuovi",
  "format_list.ban_label-like": "Non mi piace",
  "format_list.ban_label-rec": "Non consigliarmelo",
  "format_list.undo_ban_label-like": "Questo elemento non ti piace",
  "format_list.undo_ban_label-rec": "Non te lo consiglieremo"
}
},{}],108:[function(require,module,exports){
module.exports={
  "Album": "アルバム",
  "AndMore": "その他{0}人",
  "Artist": "アーティスト",
  "By": "/",
  "ByLabel": "/",
  "Create Similar Playlist": "同様のプレイリストを作成",
  "DateAdded": "追加日",
  "Duration": "期間",
  "Recommended Songs": "おすすめの曲",
  "Filter": "フィルター",
  "Follow": "フォロー",
  "Follower": "フォロワー",
  "FollowersLabel": {
    "one": "フォロワー",
    "other": "フォロワー"
  },
  "FollowersCount": {
    "one": "{0}人のフォロワー",
    "other": "{0}人のフォロワー"
  },
  "Following": "フォロー中",
  "FollowingLabel": "フォロー中",
  "ListenersLabel": "今月のリスナー",
  "FollowsYou": "あなたをフォローしています",
  "HoldToPreview": "プレビューするには、クリックを押しします",
  "ListenCount": {
    "one": "1回再生",
    "other": "{0}回再生"
  },
  "ListenReactionMulti": "ネットワーク内で{0}人が聴いています",
  "ListenReactionSingle": "{0}さんはこれを聴いています",
  "LocalFile": "ローカルファイル",
  "More": "詳細",
  "MoreSongsLoad": "再生すると、さらに曲がロードされます",
  "Pause": "一時停止",
  "Play": "曲の再生",
  "Playlist": "プレイリスト",
  "PressEnterToPlay": "再生するにはEnterキーを押します",
  "Popularity": "人気",
  "Progress": "進捗",
  "Remove": "削除",
  "RemoveYourMusic": "My Musicから削除",
  "Save": "保存",
  "SaveYourMusic": "My Musicに保存",
  "Saved": "保存済み",
  "StartRadio": "Radioを開始",
  "Time": "時間",
  "Title": "タイトル",
  "Toplist": "トップ曲",
  "Track": "ソング",
  "Unfollow": "フォローをやめる",
  "User": "ユーザー",
  "ViewAll": "すべて表示",
  "HoursShort": "{0} 時間",
  "MinutesShort": "{0} 分",
  "SecondsShort": "{0} 秒",
  "ErrorTitle": "このページの表示中に問題が発生しました。",
  "ErrorMessage": "このページは存在しないか、表示中にエラーが発生しました。",
  "OfflineTitle": "このページはオフラインでは利用できません。",
  "OfflineMessage": "ロードするには、インターネットに接続してください。",
  "MadeFor": " {0}さんのために作られたプレイリスト",
  "heart_label": "いいね！",
  "undo_heart_label": "お気に入り",
  "ban_label": "削除",
  "format_list.ban_label-like": "この曲を削除する",
  "format_list.ban_label-rec": "この曲は好みではない",
  "format_list.undo_ban_label-like": "この曲を削除する",
  "format_list.undo_ban_label-rec": "今後、お勧めしません"
}
},{}],109:[function(require,module,exports){
module.exports={
  "Album": "Album",
  "AndMore": "en {0} meer",
  "Artist": "Artiest",
  "By": "van",
  "ByLabel": "Van",
  "Create Similar Playlist": "Vergelijkbare afspeellijst maken",
  "DateAdded": "Datum toegevoegd",
  "Duration": "Duur",
  "Recommended Songs": "Aanbevolen nummers",
  "Filter": "Filter",
  "Follow": "Volgen",
  "Follower": "Volger",
  "FollowersLabel": {
    "one": "Volger",
    "other": "Volger"
  },
  "FollowersCount": {
    "one": "{0} volger",
    "other": "{0} volgers"
  },
  "Following": "Volgend",
  "FollowingLabel": "Volgend",
  "ListenersLabel": "Luisteraars per maand",
  "FollowsYou": "Volgt jou",
  "HoldToPreview": "Klikken en vasthouden om een stukje te horen",
  "ListenCount": {
    "one": "1 keer afgespeeld",
    "other": "{0} keer afgespeeld"
  },
  "ListenReactionMulti": "{0} luisteraars in jouw netwerk",
  "ListenReactionSingle": "{0} luistert hiernaar",
  "LocalFile": "Lokaal bestand",
  "More": "Meer",
  "MoreSongsLoad": "Meer nummers worden geladen terwijl je luistert",
  "Pause": "Pauze",
  "Play": "Afspelen",
  "Playlist": "Afspeellijst",
  "PressEnterToPlay": "Druk op Enter om af te spelen",
  "Popularity": "Populariteit",
  "Progress": "Voortgang",
  "Remove": "Verwijderen",
  "RemoveYourMusic": "Verwijderen uit Bibliotheek",
  "Save": "Opslaan",
  "SaveYourMusic": "Opslaan in Bibliotheek",
  "Saved": "Opgeslagen",
  "StartRadio": "Radio starten",
  "Time": "Tijd",
  "Title": "Titel",
  "Toplist": "Topnummers",
  "Track": "Nummer",
  "Unfollow": "Niet meer volgen",
  "User": "Gebruiker",
  "ViewAll": "Alles bekijken",
  "HoursShort": "{0} uur",
  "MinutesShort": "{0} min",
  "SecondsShort": "{0} sec",
  "ErrorTitle": "Er is een fout opgetreden bij het weergeven van deze pagina.",
  "ErrorMessage": "Deze weergave bestaat niet of er is een fout opgetreden.",
  "OfflineTitle": "Deze pagina is niet offline beschikbaar.",
  "OfflineMessage": "Ga online om te laden.",
  "MadeFor": "Gemaakt voor {0}",
  "heart_label": "Vind ik leuk",
  "undo_heart_label": "Geliked",
  "ban_label": "Verwijderen",
  "format_list.ban_label-like": "Niet leuk",
  "format_list.ban_label-rec": "Dit niet aanbevelen",
  "format_list.undo_ban_label-like": "Je vindt dit niet leuk",
  "format_list.undo_ban_label-rec": "We zullen dit niet aanbevelen"
}
},{}],110:[function(require,module,exports){
module.exports={
  "Album": "Album",
  "AndMore": "i {0} więcej",
  "Artist": "Wykonawca",
  "By": "według",
  "ByLabel": "-",
  "Create Similar Playlist": "Utwórz podobną playlistę",
  "DateAdded": "Data dodania",
  "Duration": "Czas trwania",
  "Recommended Songs": "Polecane utwory",
  "Filter": "Filtruj",
  "Follow": "Obserwuj",
  "Follower": "Obserwujący",
  "FollowersLabel": {
    "one": "Obserwujący",
    "other": "Obserwatorzy"
  },
  "FollowersCount": {
    "one": "{0} obserwujący",
    "other": "{0} obserwujących"
  },
  "Following": "Obserwujesz",
  "FollowingLabel": "Obserwujesz",
  "ListenersLabel": "Słuchacze w tym miesiącu",
  "FollowsYou": "Obserwuje Cię",
  "HoldToPreview": "Aby odsłuchać, kliknij i przytrzymaj.",
  "ListenCount": {
    "one": "1 odtworzenie",
    "other": "Liczba odtworzeń: {0}"
  },
  "ListenReactionMulti": "Liczba słuchaczy w Twojej sieci: {0}",
  "ListenReactionSingle": "Użytkownik {0} słucha tego",
  "LocalFile": "Plik lokalny",
  "More": "Więcej",
  "MoreSongsLoad": "Więcej utworów będzie się pojawiać w miarę słuchania",
  "Pause": "Pauza",
  "Play": "Odtwórz",
  "Playlist": "Playlista",
  "PressEnterToPlay": "Naciśnij Enter, aby odtworzyć",
  "Popularity": "Popularność",
  "Progress": "Postęp",
  "Remove": "Usuń",
  "RemoveYourMusic": "Usuń z Biblioteki",
  "Save": "Zapisz",
  "SaveYourMusic": "Zapisz w Bibliotece",
  "Saved": "Zapisany",
  "StartRadio": "Włącz radio",
  "Time": "Czas",
  "Title": "Tytuł",
  "Toplist": "Najpopularniejsze utwory",
  "Track": "Utwór",
  "Unfollow": "Przestań obserwować",
  "User": "Użytkownik",
  "ViewAll": "Wyświetl wszystko",
  "HoursShort": "{0} godz.",
  "MinutesShort": "{0} min",
  "SecondsShort": "{0} s",
  "ErrorTitle": "Wystąpił błąd podczas wyświetlania tej strony!",
  "ErrorMessage": "Ta strona nie istnieje lub wystąpił błąd.",
  "OfflineTitle": "Ta strona nie jest dostępna w trybie offline!",
  "OfflineMessage": "Przejdź do trybu online, aby załadować.",
  "MadeFor": "Przygotowana dla {0}",
  "heart_label": "Lubię to",
  "undo_heart_label": "Polubiono",
  "ban_label": "Usuń",
  "format_list.ban_label-like": "Nie lubię",
  "format_list.ban_label-rec": "Nie proponuj więcej",
  "format_list.undo_ban_label-like": "Nie podoba Ci się",
  "format_list.undo_ban_label-rec": "Nie będziemy więcej proponować"
}
},{}],111:[function(require,module,exports){
module.exports={
  "Album": "Álbum",
  "AndMore": "e mais {0}",
  "Artist": "Artista",
  "By": "de",
  "ByLabel": "De",
  "Create Similar Playlist": "Criar playlist similar",
  "DateAdded": "Adicionado em",
  "Duration": "Duração",
  "Recommended Songs": "Músicas recomendadas",
  "Filter": "Filtrar",
  "Follow": "Seguir",
  "Follower": "Seguidor",
  "FollowersLabel": {
    "one": "Seguidor",
    "other": "Seguidores"
  },
  "FollowersCount": {
    "one": "{0} seguidor",
    "other": "{0} seguidores"
  },
  "Following": "Seguindo",
  "FollowingLabel": "Seguindo",
  "ListenersLabel": "Ouvintes mensais",
  "FollowsYou": "Segue você",
  "HoldToPreview": "Clique e segure para a prévia",
  "ListenCount": {
    "one": "1 reprodução",
    "other": "{0} reproduções"
  },
  "ListenReactionMulti": "{0} ouvintes na sua rede",
  "ListenReactionSingle": "{0} ouvem isso",
  "LocalFile": "Arquivo local",
  "More": "Mais",
  "MoreSongsLoad": "Mais músicas serão carregadas à medida que você for escutando",
  "Pause": "Pause",
  "Play": "Play",
  "Playlist": "Playlist",
  "PressEnterToPlay": "Pressione Enter para tocar",
  "Popularity": "Popularidade",
  "Progress": "Progresso",
  "Remove": "Remover",
  "RemoveYourMusic": "Remover da Sua Biblioteca",
  "Save": "Salvar",
  "SaveYourMusic": "Salvar na Sua Biblioteca",
  "Saved": "Salvo",
  "StartRadio": "Abrir rádio",
  "Time": "Tempo",
  "Title": "Título",
  "Toplist": "Músicas mais tocadas",
  "Track": "Música",
  "Unfollow": "Deixar de seguir",
  "User": "Usuário",
  "ViewAll": "Ver tudo",
  "HoursShort": "{0} h",
  "MinutesShort": "{0} m",
  "SecondsShort": "{0} s",
  "ErrorTitle": "Tivemos um problema ao mostrar esta página!",
  "ErrorMessage": "Essa página não existe ou ocorreu um erro.",
  "OfflineTitle": "Essa página não está disponível offline!",
  "OfflineMessage": "Fique online para carregar.",
  "MadeFor": "Feito para {0}",
  "heart_label": "Curtir",
  "undo_heart_label": "Curtiu",
  "ban_label": "Remover",
  "format_list.ban_label-like": "Não curto",
  "format_list.ban_label-rec": "Não me recomende isso",
  "format_list.undo_ban_label-like": "Você não curte isso",
  "format_list.undo_ban_label-rec": "Não vamos recomendar isso"
}
},{}],112:[function(require,module,exports){
module.exports={
  "Album": "Album",
  "AndMore": "och {0} till",
  "Artist": "Artist",
  "By": "av",
  "ByLabel": "Av",
  "Create Similar Playlist": "Skapa en liknande spellista",
  "DateAdded": "Tillagd",
  "Duration": "Längd",
  "Recommended Songs": "Rekommenderade låtar",
  "Filter": "Filtrera",
  "Follow": "Följ",
  "Follower": "Följare",
  "FollowersLabel": {
    "one": "Följare",
    "other": "Följare"
  },
  "FollowersCount": {
    "one": "{0} följare",
    "other": "{0} följare"
  },
  "Following": "Följer",
  "FollowingLabel": "Följer",
  "ListenersLabel": "Lyssnare per månad",
  "FollowsYou": "Följer dig",
  "HoldToPreview": "Klicka och håll kvar för att förhandslyssna",
  "ListenCount": {
    "one": "1 uppspelning",
    "other": "{0} uppspelningar"
  },
  "ListenReactionMulti": "{0} lyssnare i ditt nätverk",
  "ListenReactionSingle": "{0} lyssnar på detta",
  "LocalFile": "Lokal fil",
  "More": "Mer",
  "MoreSongsLoad": "Fler låtar läses in medan du lyssnar",
  "Pause": "Pausa",
  "Play": "Spela upp",
  "Playlist": "Spellista",
  "PressEnterToPlay": "Tryck på Retur om du vill lyssna",
  "Popularity": "Popularitet",
  "Progress": "Lyssnat",
  "Remove": "Ta bort",
  "RemoveYourMusic": "Ta bort från Ditt bibliotek",
  "Save": "Spara",
  "SaveYourMusic": "Spara i Ditt bibliotek",
  "Saved": "Sparade",
  "StartRadio": "Starta radio",
  "Time": "Tid",
  "Title": "Titel",
  "Toplist": "Topplåtar",
  "Track": "Låt",
  "Unfollow": "Sluta följa",
  "User": "Användare",
  "ViewAll": "Visa alla",
  "HoursShort": "{0} tim",
  "MinutesShort": "{0} min",
  "SecondsShort": "{0} sek",
  "ErrorTitle": "Det uppstod ett fel när den här sidan skulle visas!",
  "ErrorMessage": "Den här sidan finns inte eller så uppstod ett fel.",
  "OfflineTitle": "Den här sidan är inte tillgänglig offline!",
  "OfflineMessage": "Anslut till internet om du vill läsa in appen.",
  "MadeFor": "Skapad för {0}",
  "heart_label": "Gilla",
  "undo_heart_label": "Gillar",
  "ban_label": "Ta bort",
  "format_list.ban_label-like": "Gillar inte",
  "format_list.ban_label-rec": "Rekommendera inte det här åt mig",
  "format_list.undo_ban_label-like": "Du gillar inte det här",
  "format_list.undo_ban_label-rec": "Vi kommer inte att rekommendera det här"
}
},{}],113:[function(require,module,exports){
module.exports={
  "Album": "อัลบั้ม",
  "AndMore": "และอีก {0} คน",
  "Artist": "ศิลปิน",
  "By": "โดย",
  "ByLabel": "จาก",
  "Create Similar Playlist": "สร้างเพลย์ลิสต์ที่คล้ายกัน",
  "DateAdded": "เพิ่มวันที่แล้ว",
  "Duration": "ระยะเวลา",
  "Recommended Songs": "เพลงที่แนะนำ",
  "Filter": "ตัวกรอง",
  "Follow": "ติดตาม",
  "Follower": "ผู้ติดตาม",
  "FollowersLabel": {
    "one": "ผู้ติดตาม",
    "other": "ผู้ติดตาม"
  },
  "FollowersCount": {
    "one": "ผู้ติดตาม {0} คน",
    "other": "ผู้ติดตาม {0} คน"
  },
  "Following": "กำลังติดตาม",
  "FollowingLabel": "กำลังติดตาม",
  "ListenersLabel": "ผู้ฟังรายเดือน",
  "FollowsYou": "ติดตามคุณ",
  "HoldToPreview": "คลิกค้างไว้เพื่อฟังตัวอย่าง",
  "ListenCount": {
    "one": "เล่น 1 ครั้ง",
    "other": "เล่น {0} ครั้ง"
  },
  "ListenReactionMulti": "ผู้ฟัง {0} คนในเครือข่ายของคุณ",
  "ListenReactionSingle": "{0} ฟังรายการนี้",
  "LocalFile": "ไฟล์ในเครื่อง",
  "More": "เพิ่มเติม",
  "MoreSongsLoad": "เราจะโหลดเพลงเพิ่มระหว่างที่คุณฟัง",
  "Pause": "หยุดชั่วคราว",
  "Play": "เล่น",
  "Playlist": "เพลย์ลิสต์",
  "PressEnterToPlay": "กด Enter เพื่อเล่น",
  "Popularity": "ความนิยม",
  "Progress": "ความคืบหน้า",
  "Remove": "ลบ",
  "RemoveYourMusic": "ลบจากคอลเลกชันของคุณ",
  "Save": "บันทึก",
  "SaveYourMusic": "บันทึกในคอลเลกชันของคุณ",
  "Saved": "บันทึกแล้ว",
  "StartRadio": "เริ่มต้นวิทยุ",
  "Time": "เวลา",
  "Title": "ชื่อ",
  "Toplist": "เพลงยอดนิยม",
  "Track": "เพลง",
  "Unfollow": "เลิกติดตาม",
  "User": "ผู้ใช้",
  "ViewAll": "ดูทั้งหมด",
  "HoursShort": "{0} ชั่วโมง",
  "MinutesShort": "{0} นาที",
  "SecondsShort": "{0} วินาที",
  "ErrorTitle": "เกิดปัญหาในการแสดงผลหน้านี้!",
  "ErrorMessage": "ไม่มีหน้านี้หรือเกิดข้อผิดพลาดขึ้น",
  "OfflineTitle": "ไม่สามารถใช้งานหน้านี้ขณะออฟไลน์ได้!",
  "OfflineMessage": "โปรดใช้งานแบบออนไลน์เพื่อโหลด",
  "MadeFor": "จัดทำเพื่อ {0}",
  "heart_label": "ถูกใจ",
  "undo_heart_label": "ถูกใจแล้ว",
  "ban_label": "ลบ",
  "format_list.ban_label-like": "ไม่ชอบ",
  "format_list.ban_label-rec": "อย่าแนะนำเนื้อหานี้กับฉัน",
  "format_list.undo_ban_label-like": "คุณไม่ชอบเนื้อหานี้",
  "format_list.undo_ban_label-rec": "เราจะไม่แนะนำเนื้อหานี้"
}
},{}],114:[function(require,module,exports){
module.exports={
  "Album": "Albüm",
  "AndMore": "ve {0} daha",
  "Artist": "Sanatçı",
  "By": "-",
  "ByLabel": "-",
  "Create Similar Playlist": "Benzer Çalma Listesi Oluştur",
  "DateAdded": "Tarih Eklendi",
  "Duration": "Süre",
  "Recommended Songs": "Önerilen Şarkılar",
  "Filter": "Filtrele",
  "Follow": "Takip Et",
  "Follower": "Takipçi",
  "FollowersLabel": {
    "one": "Takipçi",
    "other": "Takipçi"
  },
  "FollowersCount": {
    "one": "{0} takipçi",
    "other": "{0} takipçi"
  },
  "Following": "Takip Ediliyor",
  "FollowingLabel": "Takip Ediliyor",
  "ListenersLabel": "Aylık Dinleyici",
  "FollowsYou": "Seni Takip Ediyor",
  "HoldToPreview": "Basılı Tut ve Önizle",
  "ListenCount": {
    "one": "1 çalma",
    "other": "{0} dinleme"
  },
  "ListenReactionMulti": "Ağında {0} dinleyici",
  "ListenReactionSingle": "{0} bunu dinliyor",
  "LocalFile": "Yerel Dosya",
  "More": "Daha fazla",
  "MoreSongsLoad": "Sen dinledikçe daha fazla şarkı yüklenir",
  "Pause": "Duraklat",
  "Play": "Çal",
  "Playlist": "Çalma listesi",
  "PressEnterToPlay": "Çalmak için Enter'a bas",
  "Popularity": "Popülerlik",
  "Progress": "Progress",
  "Remove": "Çıkar",
  "RemoveYourMusic": "Kitaplığın'dan kaldır",
  "Save": "Kaydet",
  "SaveYourMusic": "Kitaplığın'a kaydet",
  "Saved": "Kaydedildi",
  "StartRadio": "Radyoyu Başlat",
  "Time": "Saat",
  "Title": "Başlık",
  "Toplist": "En çok dinlenen şarkılar",
  "Track": "Şarkı",
  "Unfollow": "Takip Etmeyi Bırak",
  "User": "Kullanıcı",
  "ViewAll": "Tümünü Görüntüle",
  "HoursShort": "{0} sa",
  "MinutesShort": "{0} dk",
  "SecondsShort": "{0} sn",
  "ErrorTitle": "Bu sayfa görüntülenirken bir sorun oluştu!",
  "ErrorMessage": "Bu sayfa yok veya bir hata oluştu.",
  "OfflineTitle": "Bu sayfa çevrimdışı kullanılamaz!",
  "OfflineMessage": "Yüklemek için lütfen çevrimiçi ol.",
  "MadeFor": "{0} İçin Yapıldı",
  "heart_label": "Beğen",
  "undo_heart_label": "Beğenildi",
  "ban_label": "Çıkar",
  "format_list.ban_label-like": "Beğenme",
  "format_list.ban_label-rec": "Bunu bana önerme",
  "format_list.undo_ban_label-like": "Bunu beğenmedin",
  "format_list.undo_ban_label-rec": "Bunu önermeyeceğiz"
}
},{}],115:[function(require,module,exports){
module.exports={
  "Album": "Album",
  "AndMore": "và thêm {0}",
  "Artist": "Nghệ sĩ",
  "By": "của",
  "ByLabel": "Của",
  "Create Similar Playlist": "Tạo Danh sách phát Tương tự",
  "DateAdded": "Đã Thêm Ngày",
  "Duration": "Thời lượng",
  "Recommended Songs": "Bài hát Gợi ý",
  "Filter": "Bộ lọc",
  "Follow": "Theo dõi",
  "Follower": "Người theo dõi",
  "FollowersLabel": {
    "one": "Người theo dõi",
    "other": "Người theo dõi"
  },
  "FollowersCount": {
    "one": "{0} người theo dõi",
    "other": "{0} người theo dõi"
  },
  "Following": "Đang theo dõi",
  "FollowingLabel": "Đang theo dõi",
  "ListenersLabel": "Người nghe Hàng tháng",
  "FollowsYou": "Theo dõi Bạn",
  "HoldToPreview": "Nhấp và Giữ để Xem trước",
  "ListenCount": {
    "one": "1 lượt phát",
    "other": "{0} phát"
  },
  "ListenReactionMulti": "{0} người nghe trong mạng lưới của bạn",
  "ListenReactionSingle": "{0} nghe bản này",
  "LocalFile": "Tệp Trên máy",
  "More": "Thêm nữa...",
  "MoreSongsLoad": "Tải được nhiều bài hát hơn khi bạn nghe",
  "Pause": "Tạm dừng",
  "Play": "Phát",
  "Playlist": "Danh sách phát",
  "PressEnterToPlay": "Nhấn Enter để phát",
  "Popularity": "Mức độ phổ biến",
  "Progress": "Tiến độ",
  "Remove": "Xóa",
  "RemoveYourMusic": "Xóa khỏi Thư viện",
  "Save": "Lưu",
  "SaveYourMusic": "Lưu vào Thư viện",
  "Saved": "Đã lưu",
  "StartRadio": "Bắt đầu Radio",
  "Time": "Thời gian",
  "Title": "Tiêu đề",
  "Toplist": "Các bài hát hàng đầu",
  "Track": "Bài hát",
  "Unfollow": "Hủy theo dõi",
  "User": "Người dùng",
  "ViewAll": "Xem Tất cả",
  "HoursShort": "{0} giờ",
  "MinutesShort": "{0} phút",
  "SecondsShort": "{0} giây",
  "ErrorTitle": "Đã có sự cố xảy ra khi hiển thị trang này!",
  "ErrorMessage": "Nội dung này hoặc không tồn tại hoặc đã có lỗi xảy ra.",
  "OfflineTitle": "Trang này không có ở chế độ ngoại tuyến!",
  "OfflineMessage": "Vui lòng truy cập trực tuyến để tải.",
  "MadeFor": "Dành cho {0}",
  "heart_label": "Thích",
  "undo_heart_label": "Đã thích",
  "ban_label": "Xóa",
  "format_list.ban_label-like": "Không thích",
  "format_list.ban_label-rec": "Không đề xuất nội dung này cho tôi nữa",
  "format_list.undo_ban_label-like": "Bạn không thích điều này",
  "format_list.undo_ban_label-rec": "Chúng tôi sẽ không đề xuất nội dung này nữa"
}
},{}],116:[function(require,module,exports){
module.exports={
  "Album": "專輯",
  "AndMore": "還有 {0} 首",
  "Artist": "藝人",
  "By": "－",
  "ByLabel": "來自",
  "Create Similar Playlist": "建立相似的播放清單",
  "DateAdded": "已加入日期",
  "Duration": "長度",
  "Recommended Songs": "推薦歌曲",
  "Filter": "篩選",
  "Follow": "關注",
  "Follower": "粉絲",
  "FollowersLabel": {
    "one": "粉絲",
    "other": "粉絲"
  },
  "FollowersCount": {
    "one": "{0} 粉絲",
    "other": "{0} 位粉絲"
  },
  "Following": "正在關注",
  "FollowingLabel": "正在關注",
  "ListenersLabel": "每月聽眾",
  "FollowsYou": "關注你",
  "HoldToPreview": "按住即可預覽",
  "ListenCount": {
    "one": "1 個播放項目",
    "other": "播放了 {0} 次"
  },
  "ListenReactionMulti": "在你的社群網路中有 {0} 名聽眾",
  "ListenReactionSingle": "{0} 收聽了這首歌曲",
  "LocalFile": "本機檔案",
  "More": "更多",
  "MoreSongsLoad": "聆聽時載入更多歌曲",
  "Pause": "暫停",
  "Play": "播放",
  "Playlist": "播放列表",
  "PressEnterToPlay": "請按 Enter 播放",
  "Popularity": "流行",
  "Progress": "進度",
  "Remove": "移除",
  "RemoveYourMusic": "從你的音樂庫中移除",
  "Save": "儲存",
  "SaveYourMusic": "儲存至你的音樂庫",
  "Saved": "已儲存",
  "StartRadio": "啟用電臺",
  "Time": "時間",
  "Title": "標題",
  "Toplist": "當紅歌曲",
  "Track": "歌曲",
  "Unfollow": "取消關注",
  "User": "使用者",
  "ViewAll": "檢視全部",
  "HoursShort": "{0} 小時",
  "MinutesShort": "{0} 分鐘",
  "SecondsShort": "{0} 秒鐘",
  "ErrorTitle": "顯示這個頁面時出現問題！",
  "ErrorMessage": "這個頁面可能不存在或發生錯誤。",
  "OfflineTitle": "離線時無法進入這個頁面！",
  "OfflineMessage": "請上網以載入。",
  "MadeFor": "專為 {0} 精心打造",
  "heart_label": "讚",
  "undo_heart_label": "已按讚",
  "ban_label": "移除",
  "format_list.ban_label-like": "不喜歡",
  "format_list.ban_label-rec": "別推薦這個給我",
  "format_list.undo_ban_label-like": "你不喜歡這個",
  "format_list.undo_ban_label-rec": "我們不會推薦這個"
}
},{}],117:[function(require,module,exports){
module.exports={
  "Album": "Album",
  "AndMore": "dan {0} lagi",
  "Artist": "Artis",
  "By": "oleh",
  "ByLabel": "Lebih banyak lagi oleh",
  "Create Similar Playlist": "Cipta Senarai Main Serupa",
  "DateAdded": "Tarikh Ditambah",
  "Duration": "Tempoh",
  "Recommended Songs": "Lagu yang Dicadangkan",
  "Filter": "Penapis",
  "Follow": "Ikut",
  "Follower": "Pengikut",
  "FollowersLabel": {
    "one": "Pengikut",
    "other": "Pengikut"
  },
  "FollowersCount": {
    "one": "{0} pengikut",
    "other": "{0} pengikut"
  },
  "Following": "Mengikuti",
  "FollowingLabel": "Mengikuti",
  "ListenersLabel": "Pendengar Bulanan",
  "FollowsYou": "Megikuti Anda",
  "HoldToPreview": "Klik dan Tahan untuk Pratonton",
  "ListenCount": {
    "one": "1 main",
    "other": "{0} main"
  },
  "ListenReactionMulti": "{0} pendengar dalam rangkaian anda",
  "ListenReactionSingle": "{0} mendengar ini",
  "LocalFile": "Fail Setempat",
  "More": "Lebih banyak",
  "MoreSongsLoad": "Lebih banyak lagu dimuatkan semasa anda mendengar",
  "Pause": "Jeda",
  "Play": "Main",
  "Playlist": "Senarai main",
  "PressEnterToPlay": "Tekan Enter untuk main",
  "Popularity": "Populariti",
  "Progress": "Perkembangan",
  "Remove": "Keluarkan",
  "RemoveYourMusic": "Keluarkan daripada Pustaka Anda",
  "Save": "Simpan",
  "SaveYourMusic": "Simpan ke Pustaka Anda",
  "Saved": "Disimpan",
  "StartRadio": "Mulakan Radio",
  "Time": "Masa",
  "Title": "Tajuk",
  "Toplist": "Lagu popular",
  "Track": "Lagu",
  "Unfollow": "Nyahikut",
  "User": "Pengguna",
  "ViewAll": "Lihat Semua",
  "HoursShort": "{0} jam",
  "MinutesShort": "{0} min",
  "SecondsShort": "{0} saat",
  "ErrorTitle": "Terdapat masalah untuk memaparkan laman ini!",
  "ErrorMessage": "Laman ini sama ada tidak wujud atau ralat telah berlaku.",
  "OfflineTitle": "Laman ini tidak tersedia di luar talian!",
  "OfflineMessage": "Sila ke online untuk memuatkan.",
  "MadeFor": "Dibuat untuk {0}",
  "heart_label": "Suka",
  "undo_heart_label": "Disukai",
  "ban_label": "Keluarkan",
  "format_list.ban_label-like": "Tidak suka",
  "format_list.ban_label-rec": "Jangan syorkan ini kepada saya",
  "format_list.undo_ban_label-like": "Anda tidak sukakannya",
  "format_list.undo_ban_label-rec": "Kami tidak akan mengesyorkannya"
}
},{}],118:[function(require,module,exports){
'use strict';

var _gridOverlay = require('./src/gridOverlay');

var gridOverlay = _interopRequireWildcard(_gridOverlay);

var _responsiveTitleType = require('./src/responsiveTitleType');

var responsiveTitleType = _interopRequireWildcard(_responsiveTitleType);

var _attentionHighlight = require('./src/attentionHighlight');

var attentionHighlight = _interopRequireWildcard(_attentionHighlight);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

exports.gridOverlay = gridOverlay;
exports.responsiveTitleType = responsiveTitleType;
exports.attentionHighlight = attentionHighlight;

},{"./src/attentionHighlight":119,"./src/gridOverlay":120,"./src/responsiveTitleType":121}],119:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
const HIDE_DELAY = exports.HIDE_DELAY = 2000;

},{}],120:[function(require,module,exports){
(function (global){
'use strict';

const cosmos = require('spotify-cosmos-api');

const DEFAULT_GRID_COLOR = 'rgba(251, 74, 131, 0.22)';
const DEFAULT_GRID_COLOR_HIGHLIGHT = 'rgba(251, 74, 131, 0.8)';
const GRID_BASELINE = 8;

let overlayElement = null;
let baselineHighlightElement = null;
let gridColor = '';
let highlightGridColor = '';
const gridModes = ['off', 'column', 'baseline'];
let currentModeIndex = 0;

/**
 * Listen for control messages to toggle the grid when a menu item is clicked
 * or a keyboard shortcut is pressed. This only happens if the user is a global
 * app developer.
 */
function listen() {
  const spotify = global.__spotify;
  const productState = spotify && spotify.product_state;
  const appDeveloperFlag = productState && productState['app-developer'];

  if (appDeveloperFlag === '3' || appDeveloperFlag === '7') {
    cosmos.resolver.subscribe({
      url: 'sp://messages/v1/container/control'
    }, function (error, response) {
      if (error) return;
      const data = response.getJSONBody();
      if (data && data.type === 'toggle_grid') {
        toggle();
      }
    });
  }
}

/**
 * Toggle the grid overlay.
 */
function toggle() {
  let newIndex = currentModeIndex + 1;
  if (newIndex > gridModes.length - 1) {
    newIndex = 0;
  }

  const mode = gridModes[newIndex];

  if (mode === 'off') {
    disable();
  } else {
    enable(mode);
  }
}

/**
 * Enable the grid overlay.
 *
 * @param {string} mode The grid mode to enable, 'column' or 'baseline'.
 */
function enable(mode) {
  if (!mode) {
    return;
  }

  if (gridModes[currentModeIndex] === mode) {
    return;
  }

  currentModeIndex = gridModes.indexOf(mode);

  if (overlayElement && overlayElement.parentNode) {
    overlayElement.parentNode.removeChild(overlayElement);
  }

  if (mode === 'baseline') {
    document.addEventListener('mousemove', onMouseMove, false);
  }

  overlayElement = createOverlayElement();

  document.body.appendChild(overlayElement);
}

/**
 * Disable the grid overlay.
 */
function disable() {
  if (gridModes[currentModeIndex] === 'off') {
    return;
  }

  if (overlayElement && overlayElement.parentNode) {
    overlayElement.parentNode.removeChild(overlayElement);
  }

  currentModeIndex = gridModes.indexOf('off');
  overlayElement = null;
  baselineHighlightElement = null;

  document.removeEventListener('mousemove', onMouseMove, false);
}

/**
 * Set the color used for each grid column or baseline line.
 *
 * @param {string} color Any valid CSS color.
 * @param {string=} highlightColor Any valid CSS color. Can be omitted for
 *     column grid.
 */
function setColor(color, highlightColor) {
  gridColor = color;
  highlightGridColor = highlightColor;
}

/**
 * Reset all state in this module.
 */
function reset() {
  overlayElement = null;
  baselineHighlightElement = null;
  gridColor = '';
  highlightGridColor = '';
  currentModeIndex = 0;
}

/**
 * Mouse move handler that highlights the hovered baseline line.
 *
 * @param {Event} event A mousemove event object.
 *
 * @private
 */
function onMouseMove(event) {
  if (!baselineHighlightElement) {
    baselineHighlightElement = document.createElement('div');
    baselineHighlightElement.className = 'grid-overlay-baseline-highlight';
    baselineHighlightElement.style.backgroundColor = highlightGridColor || DEFAULT_GRID_COLOR_HIGHLIGHT;
    overlayElement.appendChild(baselineHighlightElement);
  }

  // Calculate the Y position for the baseline line closest to the pointer
  const pointerPos = event.clientY + window.scrollY;
  const yLineAbove = Math.floor(pointerPos / GRID_BASELINE) * GRID_BASELINE;
  const y = yLineAbove + (pointerPos % GRID_BASELINE > 4 ? GRID_BASELINE : 0);

  baselineHighlightElement.style.top = `${y - 1}px`;
}

/**
 * Create the DOM nodes needed for the overlay, with the correct class names
 * and styles.
 *
 * @return {HTMLElement} The container element for the overlay.
 *
 * @private
 */
function createOverlayElement() {
  const color = gridColor || DEFAULT_GRID_COLOR;

  const container = document.createElement('div');
  container.className = 'grid-overlay container';

  if (gridModes[currentModeIndex] === 'column') {
    const row = document.createElement('div');
    row.className = 'grid-overlay-row row';
    container.appendChild(row);

    const sizeLabel = createSizeLabel();
    container.appendChild(sizeLabel);

    const columnClassNames = 'col-xs-1 col-sm-1 col-md-1 col-lg-1';

    for (let i = 0; i < 12; i++) {
      const column = document.createElement('div');
      column.className = `grid-overlay-col-${i + 1} ${columnClassNames}`;

      column.style.backgroundColor = color;

      row.appendChild(column);
    }
  } else if (gridModes[currentModeIndex] === 'baseline') {
    container.classList.add('grid-overlay-baseline');

    const baselinePercentage = `${(GRID_BASELINE - 1) / GRID_BASELINE * 100}%`;

    const backgroundImage = ['linear-gradient(', 'to bottom, ', 'transparent, ', `transparent ${baselinePercentage}, `, `${color} ${baselinePercentage}`, ')'].join('');

    container.style.backgroundImage = backgroundImage;

    // Because JSDOM is using the package 'cssstyle', which is stupid and
    // doesn't support gradients as values...
    container.style._backgroundImage = backgroundImage;
  }

  return container;
}

/**
 * Create the DOM nodes needed for the grid size label.
 *
 * @return {HTMLElement} A DOM node.
 *
 * @private
 */
function createSizeLabel() {
  const sizes = [{ name: 'Extra Small', id: 'xs' }, { name: 'Small', id: 'sm' }, { name: 'Medium', id: 'md' }, { name: 'Large', id: 'lg' }];

  const labelContainer = document.createElement('div');
  labelContainer.className = 'grid-overlay-label';

  sizes.forEach(function (size) {
    const label = document.createElement('span');
    label.className = `visible-${size.id}`;
    label.textContent = `${size.name} (${size.id})`;
    labelContainer.appendChild(label);
  });

  return labelContainer;
}

exports.listen = listen;
exports.toggle = toggle;
exports.enable = enable;
exports.disable = disable;
exports.setColor = setColor;
exports.reset = reset;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"spotify-cosmos-api":720}],121:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.loadFont = loadFont;
exports.setSizeForTitle = setSizeForTitle;
/**
 * Usage:
 *
 * loadFont().then(() => {
 *   setSizeForTitle(titleNode, {
 *     useLargeTitle: true,
 *   });
 * });
 */

// There is a bottom padding in the title element, to allow the bottom border
// of links to be rendered correctly. This number here is specified as a
// percentage of the height of a single line.
const PADDING_BOTTOM_PERCENTAGE = 0.07;
function getSizeSpecs() {
  // Some characters in Thai are too big and get cropped at the top.
  if (window.__spotify.locale === 'th') {
    return {
      default: {
        fontSizes: [[48, 36], [36, 28]],
        lineHeights: [[75, 58], [58, 44]]
      },
      large: {
        fontSizes: [[96, 72, 48], [48, 36, 28]],
        lineHeights: [[148, 111, 75], [75, 58, 44]]
      }
    };
  }
  return {
    default: {
      fontSizes: [[48, 36], [36, 28]],
      lineHeights: [[56, 44], [44, 36]]
    },
    large: {
      fontSizes: [[96, 72, 48], [48, 36, 28]],
      lineHeights: [[110, 82, 56], [56, 44, 36]]
    }
  };
}

/**
 * The font must be loaded before any sizing can be done.
 *
 * @return {Promise}
 */
function loadFont() {
  return document.fonts.load('500 48px spotify-circular');
}

/**
 * Set the type size for the provided title node. The font must be loaded
 * before calling this function.
 *
 * @param {HTMLElement} node The title node.
 * @param {Object=} options An optional object with options:
 *   - useLargeTitle: true/false (default: false)
 */
function setSizeForTitle(node, options = {}) {
  const sizeSpecId = options.useLargeTitle ? 'large' : 'default';
  const { fontSizes, lineHeights } = getSizeSpecs()[sizeSpecId];

  let lineCount = 1;
  let sizeIndex = 0;
  let fontSize = fontSizes[0][0];
  let lineHeight = lineHeights[0][0];
  let renderedLineCount = lineCount + 1;
  let lastBottomPadding = Math.ceil(PADDING_BOTTOM_PERCENTAGE * lineHeight);

  // Set initial values (largest type, one line, but clamped to two lines to
  // allow for the text to wrap so we can detect that it doesn't fit).
  node.style.webkitLineClamp = renderedLineCount;
  node.style.fontSize = `${fontSize}px`;
  node.style.lineHeight = `${lineHeight}px`;
  node.style.paddingBottom = `${lastBottomPadding}px`;
  node.style.marginBottom = `-${lastBottomPadding}px`;
  node.removeAttribute('title');

  while (lineCount <= fontSizes.length && node.offsetHeight - lastBottomPadding > lineHeight * lineCount) {
    sizeIndex++;

    if (!fontSizes[lineCount - 1][sizeIndex]) {
      sizeIndex = 0;
      lineCount++;
    }

    if (lineCount <= fontSizes.length) {
      fontSize = fontSizes[lineCount - 1][sizeIndex];
      lineHeight = lineHeights[lineCount - 1][sizeIndex];
      renderedLineCount = lineCount + 1;
      lastBottomPadding = Math.ceil(PADDING_BOTTOM_PERCENTAGE * lineHeight);

      node.style.webkitLineClamp = renderedLineCount;
      node.style.fontSize = `${fontSize}px`;
      node.style.lineHeight = `${lineHeight}px`;
      node.style.paddingBottom = `${lastBottomPadding}px`;
      node.style.marginBottom = `-${lastBottomPadding}px`;
    }
  }

  if (lineCount > fontSizes.length) {
    // Add title attribute if the text still doesn't fit and gets truncated
    node.setAttribute('title', node.textContent.trim());
  }

  node.style.webkitLineClamp = renderedLineCount - 1;
}

},{}],122:[function(require,module,exports){
'use strict';

module.exports = {
  'cs': require('../i18n/json/cs.json'),
  'de': require('../i18n/json/de.json'),
  'el': require('../i18n/json/el.json'),
  'en': require('../i18n/json/en.json'),
  'es': require('../i18n/json/es.json'),
  'es-419': require('../i18n/json/es-419.json'),
  'fi': require('../i18n/json/fi.json'),
  'fr': require('../i18n/json/fr.json'),
  'fr-CA': require('../i18n/json/fr-CA.json'),
  'hu': require('../i18n/json/hu.json'),
  'id': require('../i18n/json/id.json'),
  'it': require('../i18n/json/it.json'),
  'ja': require('../i18n/json/ja.json'),
  'nl': require('../i18n/json/nl.json'),
  'pl': require('../i18n/json/pl.json'),
  'pt-BR': require('../i18n/json/pt-BR.json'),
  'sv': require('../i18n/json/sv.json'),
  'th': require('../i18n/json/th.json'),
  'tr': require('../i18n/json/tr.json'),
  'vi': require('../i18n/json/vi.json'),
  'zh-Hant': require('../i18n/json/zh-Hant.json'),
  'zsm': require('../i18n/json/zsm.json')
};

},{"../i18n/json/cs.json":96,"../i18n/json/de.json":97,"../i18n/json/el.json":98,"../i18n/json/en.json":99,"../i18n/json/es-419.json":100,"../i18n/json/es.json":101,"../i18n/json/fi.json":102,"../i18n/json/fr-CA.json":103,"../i18n/json/fr.json":104,"../i18n/json/hu.json":105,"../i18n/json/id.json":106,"../i18n/json/it.json":107,"../i18n/json/ja.json":108,"../i18n/json/nl.json":109,"../i18n/json/pl.json":110,"../i18n/json/pt-BR.json":111,"../i18n/json/sv.json":112,"../i18n/json/th.json":113,"../i18n/json/tr.json":114,"../i18n/json/vi.json":115,"../i18n/json/zh-Hant.json":116,"../i18n/json/zsm.json":117}],123:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
var partial$0 = require('./internal/image.hbs');
HandlebarsCompiler.registerPartial('./internal/image.hbs', partial$0);
var partial$1 = require('./internal/controls-play-button.hbs');
HandlebarsCompiler.registerPartial('./internal/controls-play-button.hbs', partial$1);
module.exports = HandlebarsCompiler.template({"1":function(container,depth0,helpers,partials,data) {
    var helper;

  return "card-horizontal-size-"
    + container.escapeExpression(((helper = (helper = helpers.size || (depth0 != null ? depth0.size : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : {},{"name":"size","hash":{},"data":data}) : helper)));
},"3":function(container,depth0,helpers,partials,data) {
    return "      card-video\n";
},"5":function(container,depth0,helpers,partials,data) {
    return "card-type-station-"
    + container.escapeExpression((helpers.type || (depth0 && depth0.type) || helpers.helperMissing).call(depth0 != null ? depth0 : {},(depth0 != null ? depth0.seedUri : depth0),{"name":"type","hash":{},"data":data}));
},"7":function(container,depth0,helpers,partials,data) {
    return "      card-show-attention-highlight\n";
},"9":function(container,depth0,helpers,partials,data) {
    return "no-image-url";
},"11":function(container,depth0,helpers,partials,data) {
    return "card-hidden-image";
},"13":function(container,depth0,helpers,partials,data) {
    return "card--with-remove-button";
},"15":function(container,depth0,helpers,partials,data) {
    return "data-context";
},"17":function(container,depth0,helpers,partials,data) {
    var stack1, helper, alias1=depth0 != null ? depth0 : {}, alias2=helpers.helperMissing;

  return "    <div\n      class=\"card-image-wrapper\"\n      data-contextmenu-spy\n      data-ta-id=\"card-image-wrapper\"\n    >\n      <div class=\"card-image-hit-area\">\n        <a\n          href=\""
    + ((stack1 = helpers["if"].call(alias1,(depth0 != null ? depth0.targetUri : depth0),{"name":"if","hash":{},"fn":container.program(18, data, 0),"inverse":container.program(20, data, 0),"data":data})) != null ? stack1 : "")
    + "\"\n          data-log-click=\"media-image\"\n          data-drag-text=\""
    + container.escapeExpression(((helper = (helper = helpers.dragText || (depth0 != null ? depth0.dragText : depth0)) != null ? helper : alias2),(typeof helper === "function" ? helper.call(alias1,{"name":"dragText","hash":{},"data":data}) : helper)))
    + "\"\n          draggable=\"true\"\n          class=\"card-image-link "
    + ((stack1 = helpers.unless.call(alias1,(depth0 != null ? depth0.imageUrl : depth0),{"name":"unless","hash":{},"fn":container.program(9, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
    + "\"\n          data-interaction-target=\"image\"\n        >\n          <div class=\"card-hit-area-counter-scale\"></div>\n"
    + ((stack1 = container.invokePartial(partials["./internal/image.hbs"],depth0,{"name":"./internal/image.hbs","data":data,"indent":"          ","helpers":helpers,"partials":partials,"decorators":container.decorators})) != null ? stack1 : "")
    + "        </a>\n"
    + ((stack1 = (helpers.compare || (depth0 && depth0.compare) || alias2).call(alias1,(depth0 != null ? depth0.size : depth0),"small",{"name":"compare","hash":{"operator":"!="},"fn":container.program(22, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
    + "      </div>\n    </div>\n";
},"18":function(container,depth0,helpers,partials,data) {
    var helper;

  return container.escapeExpression(((helper = (helper = helpers.targetUri || (depth0 != null ? depth0.targetUri : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : {},{"name":"targetUri","hash":{},"data":data}) : helper)));
},"20":function(container,depth0,helpers,partials,data) {
    var helper;

  return container.escapeExpression(((helper = (helper = helpers.uri || (depth0 != null ? depth0.uri : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : {},{"name":"uri","hash":{},"data":data}) : helper)));
},"22":function(container,depth0,helpers,partials,data) {
    var stack1;

  return ((stack1 = helpers.unless.call(depth0 != null ? depth0 : {},(depth0 != null ? depth0.noPlayButton : depth0),{"name":"unless","hash":{},"fn":container.program(23, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "");
},"23":function(container,depth0,helpers,partials,data) {
    var stack1;

  return "            <div class=\"card-overlay\"></div>\n"
    + ((stack1 = container.invokePartial(partials["./internal/controls-play-button.hbs"],depth0,{"name":"./internal/controls-play-button.hbs","data":data,"indent":"            ","helpers":helpers,"partials":partials,"decorators":container.decorators})) != null ? stack1 : "");
},"25":function(container,depth0,helpers,partials,data) {
    var stack1, helper;

  return "              "
    + ((stack1 = ((helper = (helper = helpers.titleHTML || (depth0 != null ? depth0.titleHTML : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : {},{"name":"titleHTML","hash":{},"data":data}) : helper))) != null ? stack1 : "")
    + "\n";
},"27":function(container,depth0,helpers,partials,data) {
    var helper;

  return "              "
    + container.escapeExpression(((helper = (helper = helpers.title || (depth0 != null ? depth0.title : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : {},{"name":"title","hash":{},"data":data}) : helper)))
    + "\n";
},"29":function(container,depth0,helpers,partials,data) {
    var stack1;

  return "          <div class=\"card-info-subtitle-links\">\n"
    + ((stack1 = helpers.each.call(depth0 != null ? depth0 : {},(depth0 != null ? depth0.subtitleLinks : depth0),{"name":"each","hash":{},"fn":container.program(30, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
    + "          </div>\n";
},"30":function(container,depth0,helpers,partials,data) {
    var stack1, helper, alias1=depth0 != null ? depth0 : {};

  return "            <span>"
    + container.escapeExpression(((helper = (helper = helpers.name || (depth0 != null ? depth0.name : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(alias1,{"name":"name","hash":{},"data":data}) : helper)))
    + "</span>"
    + ((stack1 = helpers.unless.call(alias1,(data && data.last),{"name":"unless","hash":{},"fn":container.program(31, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
    + "\n";
},"31":function(container,depth0,helpers,partials,data) {
    return ", ";
},"33":function(container,depth0,helpers,partials,data) {
    var stack1;

  return ((stack1 = (helpers.compare || (depth0 && depth0.compare) || helpers.helperMissing).call(depth0 != null ? depth0 : {},(depth0 != null ? depth0.size : depth0),"small",{"name":"compare","hash":{"operator":"!="},"fn":container.program(34, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "");
},"34":function(container,depth0,helpers,partials,data) {
    var stack1;

  return ((stack1 = helpers["if"].call(depth0 != null ? depth0 : {},(depth0 != null ? depth0.description : depth0),{"name":"if","hash":{},"fn":container.program(35, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "");
},"35":function(container,depth0,helpers,partials,data) {
    var helper;

  return "              <div class=\"card-info-subtitle-description\" data-ta-id=\"card-description\">\n                "
    + container.escapeExpression(((helper = (helper = helpers.description || (depth0 != null ? depth0.description : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : {},{"name":"description","hash":{},"data":data}) : helper)))
    + "\n              </div>\n";
},"37":function(container,depth0,helpers,partials,data) {
    var stack1, helper;

  return "          <div class=\"card-info-subtitle-links\">\n            "
    + ((stack1 = ((helper = (helper = helpers.subtitleHTML || (depth0 != null ? depth0.subtitleHTML : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : {},{"name":"subtitleHTML","hash":{},"data":data}) : helper))) != null ? stack1 : "")
    + "\n          </div>\n";
},"39":function(container,depth0,helpers,partials,data) {
    var stack1;

  return ((stack1 = (helpers.compare || (depth0 && depth0.compare) || helpers.helperMissing).call(depth0 != null ? depth0 : {},(depth0 != null ? depth0.size : depth0),"small",{"name":"compare","hash":{"operator":"!="},"fn":container.program(40, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "");
},"40":function(container,depth0,helpers,partials,data) {
    var helper;

  return "            <div class=\"card-info-subtitle-metadata\" data-ta-id=\"card-metadata\">\n              "
    + container.escapeExpression(((helper = (helper = helpers.metadata || (depth0 != null ? depth0.metadata : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : {},{"name":"metadata","hash":{},"data":data}) : helper)))
    + "\n            </div>\n";
},"42":function(container,depth0,helpers,partials,data) {
    var stack1;

  return "        <button\n          type=\"button\"\n          class=\"card__remove-button button button-icon-only spoticon-x-16\"\n          data-card-remove-button\n"
    + ((stack1 = helpers["if"].call(depth0 != null ? depth0 : {},(depth0 != null ? depth0.removeButtonTooltip : depth0),{"name":"if","hash":{},"fn":container.program(43, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
    + "          data-interaction-target=\"remove-button\"\n          data-interaction-intent=\"remove-card\"\n        >\n        </button>\n";
},"43":function(container,depth0,helpers,partials,data) {
    var helper;

  return "          data-tooltip=\""
    + container.escapeExpression(((helper = (helper = helpers.removeButtonTooltip || (depth0 != null ? depth0.removeButtonTooltip : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : {},{"name":"removeButtonTooltip","hash":{},"data":data}) : helper)))
    + "\"\n";
},"compiler":[7,">= 4.0.0"],"main":function(container,depth0,helpers,partials,data) {
    var stack1, helper, options, alias1=depth0 != null ? depth0 : {}, alias2=helpers.helperMissing, alias3=container.escapeExpression, alias4="function", buffer = 
  "<div\n  class=\"\n    card\n    card-horizontal\n    "
    + ((stack1 = helpers["if"].call(alias1,(depth0 != null ? depth0.size : depth0),{"name":"if","hash":{},"fn":container.program(1, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
    + "\n    card-type-"
    + alias3((helpers.type || (depth0 && depth0.type) || alias2).call(alias1,(depth0 != null ? depth0.uri : depth0),{"name":"type","hash":{},"data":data}))
    + "\n"
    + ((stack1 = (helpers.compare || (depth0 && depth0.compare) || alias2).call(alias1,(depth0 != null ? depth0.isVideo : depth0),true,{"name":"compare","hash":{},"fn":container.program(3, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
    + "    "
    + ((stack1 = helpers["if"].call(alias1,(depth0 != null ? depth0.seedUri : depth0),{"name":"if","hash":{},"fn":container.program(5, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
    + "\n"
    + ((stack1 = helpers["if"].call(alias1,(depth0 != null ? depth0.showAttentionHighlight : depth0),{"name":"if","hash":{},"fn":container.program(7, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
    + "    "
    + ((stack1 = helpers.unless.call(alias1,(depth0 != null ? depth0.imageUrl : depth0),{"name":"unless","hash":{},"fn":container.program(9, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
    + "\n    "
    + ((stack1 = helpers["if"].call(alias1,(depth0 != null ? depth0.noImage : depth0),{"name":"if","hash":{},"fn":container.program(11, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
    + "\n    "
    + ((stack1 = helpers["if"].call(alias1,(depth0 != null ? depth0.removeButton : depth0),{"name":"if","hash":{},"fn":container.program(13, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
    + "\n  \"\n  data-log-context=\"media-object\"\n  data-log-data='{ \"name\": \""
    + alias3(((helper = (helper = helpers.title || (depth0 != null ? depth0.title : depth0)) != null ? helper : alias2),(typeof helper === alias4 ? helper.call(alias1,{"name":"title","hash":{},"data":data}) : helper)))
    + "\", \"target_uri\": \""
    + alias3(((helper = (helper = helpers.uri || (depth0 != null ? depth0.uri : depth0)) != null ? helper : alias2),(typeof helper === alias4 ? helper.call(alias1,{"name":"uri","hash":{},"data":data}) : helper)))
    + "\" }'\n  data-uri=\""
    + alias3(((helper = (helper = helpers.uri || (depth0 != null ? depth0.uri : depth0)) != null ? helper : alias2),(typeof helper === alias4 ? helper.call(alias1,{"name":"uri","hash":{},"data":data}) : helper)))
    + "\"\n  data-contextmenu\n  ";
  stack1 = ((helper = (helper = helpers.noContext || (depth0 != null ? depth0.noContext : depth0)) != null ? helper : alias2),(options={"name":"noContext","hash":{},"fn":container.noop,"inverse":container.program(15, data, 0),"data":data}),(typeof helper === alias4 ? helper.call(alias1,options) : helper));
  if (!helpers.noContext) { stack1 = helpers.blockHelperMissing.call(depth0,stack1,options)}
  if (stack1 != null) { buffer += stack1; }
  return buffer + "\n  data-contextmenu-spy\n  data-card-pressed-container\n  data-card-trigger-pressed-state\n  data-ta-id=\"card\"\n  data-interaction-context=\"card\"\n>\n  <div class=\"card-attention-highlight-box\">\n  </div>\n  <div class=\"card-horizontal-interior-wrapper\">\n"
    + ((stack1 = helpers.unless.call(alias1,(depth0 != null ? depth0.noImage : depth0),{"name":"unless","hash":{},"fn":container.program(17, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
    + "\n    <div class=\"card-info-wrapper\">\n      <a\n        href=\""
    + ((stack1 = helpers["if"].call(alias1,(depth0 != null ? depth0.targetUri : depth0),{"name":"if","hash":{},"fn":container.program(18, data, 0),"inverse":container.program(20, data, 0),"data":data})) != null ? stack1 : "")
    + "\"\n        data-log-click=\"media-title\"\n        data-drag-text=\""
    + alias3(((helper = (helper = helpers.dragText || (depth0 != null ? depth0.dragText : depth0)) != null ? helper : alias2),(typeof helper === alias4 ? helper.call(alias1,{"name":"dragText","hash":{},"data":data}) : helper)))
    + "\"\n        draggable=\"true\"\n        data-interaction-target=\"title\"\n      >\n        <div class=\"card-hit-area-counter-scale\"></div>\n        <div class=\"card-info-content-wrapper\">\n          <div class=\"card-info-title\">\n"
    + ((stack1 = helpers["if"].call(alias1,(depth0 != null ? depth0.titleHTML : depth0),{"name":"if","hash":{},"fn":container.program(25, data, 0),"inverse":container.program(27, data, 0),"data":data})) != null ? stack1 : "")
    + "          </div>\n\n"
    + ((stack1 = helpers["if"].call(alias1,(depth0 != null ? depth0.subtitleLinks : depth0),{"name":"if","hash":{},"fn":container.program(29, data, 0),"inverse":container.program(33, data, 0),"data":data})) != null ? stack1 : "")
    + "\n"
    + ((stack1 = helpers["if"].call(alias1,(depth0 != null ? depth0.subtitleHTML : depth0),{"name":"if","hash":{},"fn":container.program(37, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
    + "\n"
    + ((stack1 = helpers["if"].call(alias1,(depth0 != null ? depth0.metadata : depth0),{"name":"if","hash":{},"fn":container.program(39, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
    + "        </div>\n"
    + ((stack1 = helpers["if"].call(alias1,(depth0 != null ? depth0.removeButton : depth0),{"name":"if","hash":{},"fn":container.program(42, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
    + "      </a>\n    </div>\n  </div>\n</div>\n";
},"usePartial":true,"useData":true});

},{"./internal/controls-play-button.hbs":125,"./internal/image.hbs":128,"hbsfy/runtime":429}],124:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
var partial$0 = require('./internal/image-with-overlay.hbs');
HandlebarsCompiler.registerPartial('./internal/image-with-overlay.hbs', partial$0);
var partial$1 = require('./internal/controls.hbs');
HandlebarsCompiler.registerPartial('./internal/controls.hbs', partial$1);
var partial$2 = require('./internal/linked-image.hbs');
HandlebarsCompiler.registerPartial('./internal/linked-image.hbs', partial$2);
var partial$3 = require('./internal/controls.hbs');
HandlebarsCompiler.registerPartial('./internal/controls.hbs', partial$3);
module.exports = HandlebarsCompiler.template({"1":function(container,depth0,helpers,partials,data) {
    return "      card-video\n";
},"3":function(container,depth0,helpers,partials,data) {
    return "card-type-station-"
    + container.escapeExpression((helpers.type || (depth0 && depth0.type) || helpers.helperMissing).call(depth0 != null ? depth0 : {},(depth0 != null ? depth0.seedUri : depth0),{"name":"type","hash":{},"data":data}));
},"5":function(container,depth0,helpers,partials,data) {
    return "      card-show-attention-highlight\n";
},"7":function(container,depth0,helpers,partials,data) {
    return "added";
},"9":function(container,depth0,helpers,partials,data) {
    return "no-image-url";
},"11":function(container,depth0,helpers,partials,data) {
    return "data-context";
},"13":function(container,depth0,helpers,partials,data) {
    var stack1;

  return "      <div class=\"card-image-hit-area\" data-log-click=\"media-image\">\n"
    + ((stack1 = container.invokePartial(partials["./internal/image-with-overlay.hbs"],depth0,{"name":"./internal/image-with-overlay.hbs","data":data,"indent":"        ","helpers":helpers,"partials":partials,"decorators":container.decorators})) != null ? stack1 : "")
    + "\n"
    + ((stack1 = helpers.unless.call(depth0 != null ? depth0 : {},(depth0 != null ? depth0.noPlayButton : depth0),{"name":"unless","hash":{},"fn":container.program(14, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
    + "      </div>\n";
},"14":function(container,depth0,helpers,partials,data) {
    var stack1;

  return ((stack1 = container.invokePartial(partials["./internal/controls.hbs"],depth0,{"name":"./internal/controls.hbs","data":data,"indent":"          ","helpers":helpers,"partials":partials,"decorators":container.decorators})) != null ? stack1 : "");
},"16":function(container,depth0,helpers,partials,data) {
    var stack1;

  return "      <div class=\"card-image-hit-area\" data-card-trigger-pressed-state>\n"
    + ((stack1 = container.invokePartial(partials["./internal/linked-image.hbs"],depth0,{"name":"./internal/linked-image.hbs","data":data,"indent":"        ","helpers":helpers,"partials":partials,"decorators":container.decorators})) != null ? stack1 : "")
    + "\n"
    + ((stack1 = helpers.unless.call(depth0 != null ? depth0 : {},(depth0 != null ? depth0.noPlayButton : depth0),{"name":"unless","hash":{},"fn":container.program(14, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
    + "      </div>\n";
},"18":function(container,depth0,helpers,partials,data) {
    var helper;

  return "      <div class=\"card-progress\">\n        <div class=\"card-progress__bar\" style=\"--progress: "
    + container.escapeExpression(((helper = (helper = helpers.progress || (depth0 != null ? depth0.progress : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : {},{"name":"progress","hash":{},"data":data}) : helper)))
    + "\"></div>\n      </div>\n";
},"20":function(container,depth0,helpers,partials,data,blockParams,depths) {
    var stack1, alias1=depth0 != null ? depth0 : {};

  return "  <div\n    class=\"\n      card-info-wrapper\n"
    + ((stack1 = helpers["if"].call(alias1,(depth0 != null ? depth0.subtitleLinks : depth0),{"name":"if","hash":{},"fn":container.program(21, data, 0, blockParams, depths),"inverse":container.program(23, data, 0, blockParams, depths),"data":data})) != null ? stack1 : "")
    + ((stack1 = helpers["if"].call(alias1,(depth0 != null ? depth0.metadata : depth0),{"name":"if","hash":{},"fn":container.program(26, data, 0, blockParams, depths),"inverse":container.noop,"data":data})) != null ? stack1 : "")
    + "    \"\n  >\n    <div class=\"card-info-title\">\n"
    + ((stack1 = helpers["if"].call(alias1,(depth0 != null ? depth0.noLink : depth0),{"name":"if","hash":{},"fn":container.program(28, data, 0, blockParams, depths),"inverse":container.program(30, data, 0, blockParams, depths),"data":data})) != null ? stack1 : "")
    + "    </div>\n\n"
    + ((stack1 = helpers["if"].call(alias1,(depth0 != null ? depth0.subtitleLinks : depth0),{"name":"if","hash":{},"fn":container.program(35, data, 0, blockParams, depths),"inverse":container.program(43, data, 0, blockParams, depths),"data":data})) != null ? stack1 : "")
    + "\n"
    + ((stack1 = helpers["if"].call(alias1,(depth0 != null ? depth0.metadata : depth0),{"name":"if","hash":{},"fn":container.program(46, data, 0, blockParams, depths),"inverse":container.noop,"data":data})) != null ? stack1 : "")
    + "  </div>\n";
},"21":function(container,depth0,helpers,partials,data) {
    return "        card-info-with-subtitle-links\n";
},"23":function(container,depth0,helpers,partials,data) {
    var stack1;

  return ((stack1 = helpers["if"].call(depth0 != null ? depth0 : {},(depth0 != null ? depth0.description : depth0),{"name":"if","hash":{},"fn":container.program(24, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "");
},"24":function(container,depth0,helpers,partials,data) {
    return "          card-info-with-description\n";
},"26":function(container,depth0,helpers,partials,data) {
    return "        card-info-with-metadata\n";
},"28":function(container,depth0,helpers,partials,data) {
    var helper;

  return "        <span data-log-click=\"media-title\">\n          "
    + container.escapeExpression(((helper = (helper = helpers.title || (depth0 != null ? depth0.title : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : {},{"name":"title","hash":{},"data":data}) : helper)))
    + "\n        </span>\n";
},"30":function(container,depth0,helpers,partials,data) {
    var stack1, helper, alias1=depth0 != null ? depth0 : {}, alias2=helpers.helperMissing, alias3="function", alias4=container.escapeExpression;

  return "      <a\n        href=\""
    + ((stack1 = helpers["if"].call(alias1,(depth0 != null ? depth0.targetUri : depth0),{"name":"if","hash":{},"fn":container.program(31, data, 0),"inverse":container.program(33, data, 0),"data":data})) != null ? stack1 : "")
    + "\"\n        data-uri=\""
    + alias4(((helper = (helper = helpers.uri || (depth0 != null ? depth0.uri : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"uri","hash":{},"data":data}) : helper)))
    + "\"\n        data-log-click=\"media-title\"\n        data-ta-id=\"card-title-link\"\n        title=\""
    + alias4(((helper = (helper = helpers.title || (depth0 != null ? depth0.title : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"title","hash":{},"data":data}) : helper)))
    + "\"\n        data-interaction-target=\"title\"\n      >\n        "
    + alias4(((helper = (helper = helpers.title || (depth0 != null ? depth0.title : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"title","hash":{},"data":data}) : helper)))
    + "\n      </a>\n";
},"31":function(container,depth0,helpers,partials,data) {
    var helper;

  return container.escapeExpression(((helper = (helper = helpers.targetUri || (depth0 != null ? depth0.targetUri : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : {},{"name":"targetUri","hash":{},"data":data}) : helper)));
},"33":function(container,depth0,helpers,partials,data) {
    var helper;

  return container.escapeExpression(((helper = (helper = helpers.uri || (depth0 != null ? depth0.uri : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : {},{"name":"uri","hash":{},"data":data}) : helper)));
},"35":function(container,depth0,helpers,partials,data,blockParams,depths) {
    var stack1;

  return "    <div class=\"card-info-subtitle-links\" data-interaction-context=\"subtitle-links\">\n"
    + ((stack1 = helpers.each.call(depth0 != null ? depth0 : {},(depth0 != null ? depth0.subtitleLinks : depth0),{"name":"each","hash":{},"fn":container.program(36, data, 0, blockParams, depths),"inverse":container.noop,"data":data})) != null ? stack1 : "")
    + "    </div>\n";
},"36":function(container,depth0,helpers,partials,data,blockParams,depths) {
    var stack1, helper, alias1=depth0 != null ? depth0 : {}, alias2=helpers.helperMissing, alias3="function", alias4=container.escapeExpression;

  return "      <a\n        title=\""
    + alias4(((helper = (helper = helpers.name || (depth0 != null ? depth0.name : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"name","hash":{},"data":data}) : helper)))
    + "\"\n        href=\""
    + alias4(((helper = (helper = helpers.uri || (depth0 != null ? depth0.uri : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"uri","hash":{},"data":data}) : helper)))
    + "\"\n        data-uri=\""
    + alias4(((helper = (helper = helpers.uri || (depth0 != null ? depth0.uri : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"uri","hash":{},"data":data}) : helper)))
    + "\"\n        data-ta-id=\"card-subtitle-link\"\n        data-interaction-target=\""
    + alias4(((helper = (helper = helpers.index || (data && data.index)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"index","hash":{},"data":data}) : helper)))
    + "\"\n"
    + ((stack1 = (helpers.compare || (depth0 && depth0.compare) || alias2).call(alias1,(helpers.type || (depth0 && depth0.type) || alias2).call(alias1,(depths[1] != null ? depths[1].uri : depths[1]),{"name":"type","hash":{},"data":data}),"album",{"name":"compare","hash":{"operator":"=="},"fn":container.program(37, data, 0, blockParams, depths),"inverse":container.noop,"data":data})) != null ? stack1 : "")
    + ((stack1 = (helpers.compare || (depth0 && depth0.compare) || alias2).call(alias1,(helpers.type || (depth0 && depth0.type) || alias2).call(alias1,(depths[1] != null ? depths[1].uri : depths[1]),{"name":"type","hash":{},"data":data}),"playlist",{"name":"compare","hash":{"operator":"=="},"fn":container.program(39, data, 0, blockParams, depths),"inverse":container.noop,"data":data})) != null ? stack1 : "")
    + "      >"
    + alias4(((helper = (helper = helpers.name || (depth0 != null ? depth0.name : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"name","hash":{},"data":data}) : helper)))
    + "</a>"
    + ((stack1 = helpers.unless.call(alias1,(data && data.last),{"name":"unless","hash":{},"fn":container.program(41, data, 0, blockParams, depths),"inverse":container.noop,"data":data})) != null ? stack1 : "")
    + "\n";
},"37":function(container,depth0,helpers,partials,data) {
    return "          data-log-click=\"artist-name\"\n";
},"39":function(container,depth0,helpers,partials,data) {
    return "          data-log-click=\"owner-name\"\n";
},"41":function(container,depth0,helpers,partials,data) {
    return ", ";
},"43":function(container,depth0,helpers,partials,data) {
    var stack1;

  return ((stack1 = helpers["if"].call(depth0 != null ? depth0 : {},(depth0 != null ? depth0.description : depth0),{"name":"if","hash":{},"fn":container.program(44, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "");
},"44":function(container,depth0,helpers,partials,data) {
    var helper;

  return "      <div class=\"card-info-subtitle-description\" data-ta-id=\"card-description\">\n        "
    + container.escapeExpression(((helper = (helper = helpers.description || (depth0 != null ? depth0.description : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : {},{"name":"description","hash":{},"data":data}) : helper)))
    + "\n      </div>\n";
},"46":function(container,depth0,helpers,partials,data) {
    var stack1, helper, alias1=depth0 != null ? depth0 : {};

  return "    <div class=\"card-info-subtitle-metadata\" data-ta-id=\"card-metadata\">\n"
    + ((stack1 = helpers["if"].call(alias1,(depth0 != null ? depth0.isNew : depth0),{"name":"if","hash":{},"fn":container.program(47, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
    + "      "
    + container.escapeExpression(((helper = (helper = helpers.metadata || (depth0 != null ? depth0.metadata : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(alias1,{"name":"metadata","hash":{},"data":data}) : helper)))
    + "\n    </div>\n";
},"47":function(container,depth0,helpers,partials,data) {
    return "      <div class=\"card-info-subtitle-new-mark\"></div>\n";
},"compiler":[7,">= 4.0.0"],"main":function(container,depth0,helpers,partials,data,blockParams,depths) {
    var stack1, helper, options, alias1=depth0 != null ? depth0 : {}, alias2=helpers.helperMissing, alias3=container.escapeExpression, alias4="function", buffer = 
  "<div\n  class=\"\n    card\n    card-type-"
    + alias3((helpers.type || (depth0 && depth0.type) || alias2).call(alias1,(depth0 != null ? depth0.uri : depth0),{"name":"type","hash":{},"data":data}))
    + "\n"
    + ((stack1 = (helpers.compare || (depth0 && depth0.compare) || alias2).call(alias1,(depth0 != null ? depth0.isVideo : depth0),true,{"name":"compare","hash":{},"fn":container.program(1, data, 0, blockParams, depths),"inverse":container.noop,"data":data})) != null ? stack1 : "")
    + "    "
    + ((stack1 = helpers["if"].call(alias1,(depth0 != null ? depth0.seedUri : depth0),{"name":"if","hash":{},"fn":container.program(3, data, 0, blockParams, depths),"inverse":container.noop,"data":data})) != null ? stack1 : "")
    + "\n"
    + ((stack1 = helpers["if"].call(alias1,(depth0 != null ? depth0.showAttentionHighlight : depth0),{"name":"if","hash":{},"fn":container.program(5, data, 0, blockParams, depths),"inverse":container.noop,"data":data})) != null ? stack1 : "")
    + "    "
    + ((stack1 = helpers["if"].call(alias1,(depth0 != null ? depth0.added : depth0),{"name":"if","hash":{},"fn":container.program(7, data, 0, blockParams, depths),"inverse":container.noop,"data":data})) != null ? stack1 : "")
    + "\n    "
    + ((stack1 = helpers.unless.call(alias1,(depth0 != null ? depth0.imageUrl : depth0),{"name":"unless","hash":{},"fn":container.program(9, data, 0, blockParams, depths),"inverse":container.noop,"data":data})) != null ? stack1 : "")
    + "\n  \"\n  data-log-context=\"media-object\"\n  data-interaction-context=\"card\"\n  data-log-data='{ \"name\": \""
    + alias3(((helper = (helper = helpers.title || (depth0 != null ? depth0.title : depth0)) != null ? helper : alias2),(typeof helper === alias4 ? helper.call(alias1,{"name":"title","hash":{},"data":data}) : helper)))
    + "\", \"target_uri\": \""
    + alias3(((helper = (helper = helpers.uri || (depth0 != null ? depth0.uri : depth0)) != null ? helper : alias2),(typeof helper === alias4 ? helper.call(alias1,{"name":"uri","hash":{},"data":data}) : helper)))
    + "\" }'\n  data-uri=\""
    + alias3(((helper = (helper = helpers.uri || (depth0 != null ? depth0.uri : depth0)) != null ? helper : alias2),(typeof helper === alias4 ? helper.call(alias1,{"name":"uri","hash":{},"data":data}) : helper)))
    + "\"\n  data-contextmenu\n  ";
  stack1 = ((helper = (helper = helpers.noContext || (depth0 != null ? depth0.noContext : depth0)) != null ? helper : alias2),(options={"name":"noContext","hash":{},"fn":container.noop,"inverse":container.program(11, data, 0, blockParams, depths),"data":data}),(typeof helper === alias4 ? helper.call(alias1,options) : helper));
  if (!helpers.noContext) { stack1 = helpers.blockHelperMissing.call(depth0,stack1,options)}
  if (stack1 != null) { buffer += stack1; }
  return buffer + "\n  data-card-pressed-container\n  data-ta-id=\"card\"\n>\n  <div class=\"card-attention-highlight-box\">\n  </div>\n  <div class=\"card-image-wrapper\" data-contextmenu-spy data-ta-id=\"card-image-wrapper\">\n"
    + ((stack1 = helpers["if"].call(alias1,(depth0 != null ? depth0.noLink : depth0),{"name":"if","hash":{},"fn":container.program(13, data, 0, blockParams, depths),"inverse":container.program(16, data, 0, blockParams, depths),"data":data})) != null ? stack1 : "")
    + ((stack1 = helpers["if"].call(alias1,(depth0 != null ? depth0.progress : depth0),{"name":"if","hash":{},"fn":container.program(18, data, 0, blockParams, depths),"inverse":container.noop,"data":data})) != null ? stack1 : "")
    + "  </div>\n\n"
    + ((stack1 = helpers["if"].call(alias1,(depth0 != null ? depth0.title : depth0),{"name":"if","hash":{},"fn":container.program(20, data, 0, blockParams, depths),"inverse":container.noop,"data":data})) != null ? stack1 : "")
    + "\n</div>\n";
},"usePartial":true,"useData":true,"useDepths":true});

},{"./internal/controls.hbs":126,"./internal/image-with-overlay.hbs":127,"./internal/linked-image.hbs":129,"hbsfy/runtime":429}],125:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template({"1":function(container,depth0,helpers,partials,data) {
    var stack1;

  return "  <button\n    type=\"button\"\n    class=\"button button-play button-icon-with-stroke card-button-play\"\n    data-ta-id=\"card-button-play\"\n    data-log-click=\"play-button\"\n    data-interaction-target=\"play-pause-button\"\n    data-interaction-intent=\"play\"\n"
    + ((stack1 = helpers["if"].call(depth0 != null ? depth0 : {},(depth0 != null ? depth0.range : depth0),{"name":"if","hash":{},"fn":container.program(2, data, 0),"inverse":container.program(5, data, 0),"data":data})) != null ? stack1 : "")
    + "  >\n  </button>\n";
},"2":function(container,depth0,helpers,partials,data) {
    var stack1, helper, options, buffer = 
  "      data-button=\"play\"\n      ";
  stack1 = ((helper = (helper = helpers.range || (depth0 != null ? depth0.range : depth0)) != null ? helper : helpers.helperMissing),(options={"name":"range","hash":{},"fn":container.program(3, data, 0),"inverse":container.noop,"data":data}),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : {},options) : helper));
  if (!helpers.range) { stack1 = helpers.blockHelperMissing.call(depth0,stack1,options)}
  if (stack1 != null) { buffer += stack1; }
  return buffer + "\n";
},"3":function(container,depth0,helpers,partials,data) {
    var helper, alias1=depth0 != null ? depth0 : {}, alias2=helpers.helperMissing, alias3="function", alias4=container.escapeExpression;

  return "data-range=\""
    + alias4(((helper = (helper = helpers.start || (depth0 != null ? depth0.start : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"start","hash":{},"data":data}) : helper)))
    + ","
    + alias4(((helper = (helper = helpers.end || (depth0 != null ? depth0.end : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"end","hash":{},"data":data}) : helper)))
    + "\"";
},"5":function(container,depth0,helpers,partials,data) {
    var stack1;

  return ((stack1 = helpers["if"].call(depth0 != null ? depth0 : {},(depth0 != null ? depth0.contextPage : depth0),{"name":"if","hash":{},"fn":container.program(6, data, 0),"inverse":container.program(9, data, 0),"data":data})) != null ? stack1 : "");
},"6":function(container,depth0,helpers,partials,data) {
    var stack1, helper, options, buffer = 
  "        data-button=\"play\"\n        ";
  stack1 = ((helper = (helper = helpers.contextPage || (depth0 != null ? depth0.contextPage : depth0)) != null ? helper : helpers.helperMissing),(options={"name":"contextPage","hash":{},"fn":container.program(7, data, 0),"inverse":container.noop,"data":data}),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : {},options) : helper));
  if (!helpers.contextPage) { stack1 = helpers.blockHelperMissing.call(depth0,stack1,options)}
  if (stack1 != null) { buffer += stack1; }
  return buffer + "\n";
},"7":function(container,depth0,helpers,partials,data) {
    return "data-context-page=\""
    + container.escapeExpression(container.lambda(depth0, depth0))
    + "\"";
},"9":function(container,depth0,helpers,partials,data) {
    var stack1;

  return ((stack1 = helpers["if"].call(depth0 != null ? depth0 : {},(depth0 != null ? depth0.trackUri : depth0),{"name":"if","hash":{},"fn":container.program(10, data, 0),"inverse":container.program(13, data, 0),"data":data})) != null ? stack1 : "");
},"10":function(container,depth0,helpers,partials,data) {
    var stack1, helper, options, buffer = 
  "          ";
  stack1 = ((helper = (helper = helpers.trackUri || (depth0 != null ? depth0.trackUri : depth0)) != null ? helper : helpers.helperMissing),(options={"name":"trackUri","hash":{},"fn":container.program(11, data, 0),"inverse":container.noop,"data":data}),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : {},options) : helper));
  if (!helpers.trackUri) { stack1 = helpers.blockHelperMissing.call(depth0,stack1,options)}
  if (stack1 != null) { buffer += stack1; }
  return buffer + "\n          data-button=\"play\"\n";
},"11":function(container,depth0,helpers,partials,data) {
    return "data-track-uri=\""
    + container.escapeExpression(container.lambda(depth0, depth0))
    + "\"";
},"13":function(container,depth0,helpers,partials,data) {
    return "          data-button=\"play-context\"\n";
},"compiler":[7,">= 4.0.0"],"main":function(container,depth0,helpers,partials,data) {
    var stack1;

  return ((stack1 = (helpers.type || (depth0 && depth0.type) || helpers.helperMissing).call(depth0 != null ? depth0 : {},(depth0 != null ? depth0.uri : depth0),"playlist","track","album","station","artist","episode","collection-album","collection-artist","show",{"name":"type","hash":{},"fn":container.program(1, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "");
},"useData":true});

},{"hbsfy/runtime":429}],126:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
var partial$0 = require('./controls-play-button.hbs');
HandlebarsCompiler.registerPartial('./controls-play-button.hbs', partial$0);
module.exports = HandlebarsCompiler.template({"1":function(container,depth0,helpers,partials,data) {
    var stack1;

  return ((stack1 = (helpers.type || (depth0 && depth0.type) || helpers.helperMissing).call(depth0 != null ? depth0 : {},(depth0 != null ? depth0.uri : depth0),"playlist","track","album","station","artist","show","collection-album","collection-artist",{"name":"type","hash":{},"fn":container.program(2, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "");
},"2":function(container,depth0,helpers,partials,data) {
    var stack1, alias1=depth0 != null ? depth0 : {}, alias2=helpers.helperMissing;

  return ((stack1 = (helpers.type || (depth0 && depth0.type) || alias2).call(alias1,(depth0 != null ? depth0.uri : depth0),"track","album","collection-album",{"name":"type","hash":{},"fn":container.program(3, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
    + ((stack1 = (helpers.type || (depth0 && depth0.type) || alias2).call(alias1,(depth0 != null ? depth0.uri : depth0),"playlist","artist","show","collection-artist",{"name":"type","hash":{},"fn":container.program(5, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
    + ((stack1 = (helpers.type || (depth0 && depth0.type) || alias2).call(alias1,(depth0 != null ? depth0.uri : depth0),"station",{"name":"type","hash":{},"fn":container.program(8, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "");
},"3":function(container,depth0,helpers,partials,data) {
    var alias1=depth0 != null ? depth0 : {}, alias2=helpers.helperMissing, alias3=container.escapeExpression;

  return "      <button\n        type=\"button\"\n        data-button=\"add\"\n        class=\"button button-add card-button-add\"\n        data-ta-id=\"card-button-add\"\n        data-tooltip=\""
    + alias3((helpers.loc || (depth0 && depth0.loc) || alias2).call(alias1,"Save",{"name":"loc","hash":{},"data":data}))
    + "\"\n        data-tooltip-add=\""
    + alias3((helpers.loc || (depth0 && depth0.loc) || alias2).call(alias1,"Save",{"name":"loc","hash":{},"data":data}))
    + "\"\n        data-tooltip-remove=\""
    + alias3((helpers.loc || (depth0 && depth0.loc) || alias2).call(alias1,"Remove",{"name":"loc","hash":{},"data":data}))
    + "\"\n        data-log-click=\"add-button\"\n        data-interaction-target=\"save-remove-button\"\n        data-interaction-intent=\"save\"></button>\n";
},"5":function(container,depth0,helpers,partials,data) {
    var stack1, helper, options, buffer = "";

  stack1 = ((helper = (helper = helpers.currentUserPlaylist || (depth0 != null ? depth0.currentUserPlaylist : depth0)) != null ? helper : helpers.helperMissing),(options={"name":"currentUserPlaylist","hash":{},"fn":container.noop,"inverse":container.program(6, data, 0),"data":data}),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : {},options) : helper));
  if (!helpers.currentUserPlaylist) { stack1 = helpers.blockHelperMissing.call(depth0,stack1,options)}
  if (stack1 != null) { buffer += stack1; }
  return buffer;
},"6":function(container,depth0,helpers,partials,data) {
    var alias1=depth0 != null ? depth0 : {}, alias2=helpers.helperMissing, alias3=container.escapeExpression;

  return "      <button\n        type=\"button\"\n        data-button=\"add\"\n        class=\"button button-add card-button-add\"\n        data-ta-id=\"card-button-add\"\n        data-tooltip=\""
    + alias3((helpers.loc || (depth0 && depth0.loc) || alias2).call(alias1,"Follow",{"name":"loc","hash":{},"data":data}))
    + "\"\n        data-tooltip-add=\""
    + alias3((helpers.loc || (depth0 && depth0.loc) || alias2).call(alias1,"Follow",{"name":"loc","hash":{},"data":data}))
    + "\"\n        data-tooltip-remove=\""
    + alias3((helpers.loc || (depth0 && depth0.loc) || alias2).call(alias1,"Unfollow",{"name":"loc","hash":{},"data":data}))
    + "\"\n        data-log-click=\"follow-button\"\n        data-interaction-target=\"toggle-follow-state-button\"\n        data-interaction-intent=\"follow\"></button>\n";
},"8":function(container,depth0,helpers,partials,data) {
    var stack1, alias1=depth0 != null ? depth0 : {}, alias2=helpers.helperMissing;

  return ((stack1 = (helpers.compare || (depth0 && depth0.compare) || alias2).call(alias1,(helpers.type || (depth0 && depth0.type) || alias2).call(alias1,(depth0 != null ? depth0.seedUri : depth0),{"name":"type","hash":{},"data":data}),"cluster",{"name":"compare","hash":{"operator":"!="},"fn":container.program(6, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "");
},"10":function(container,depth0,helpers,partials,data) {
    var stack1;

  return ((stack1 = (helpers.type || (depth0 && depth0.type) || helpers.helperMissing).call(depth0 != null ? depth0 : {},(depth0 != null ? depth0.uri : depth0),"playlist","track","album","station","artist","collection-album","collection-artist",{"name":"type","hash":{},"fn":container.program(11, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "");
},"11":function(container,depth0,helpers,partials,data) {
    return "    <button\n      type=\"button\"\n      data-button=\"contextmenu\"\n      class=\"button button-more button-no-border card-button-more\"\n      data-ta-id=\"card-button-context-menu\"\n      data-tooltip=\""
    + container.escapeExpression((helpers.loc || (depth0 && depth0.loc) || helpers.helperMissing).call(depth0 != null ? depth0 : {},"More",{"name":"loc","hash":{},"data":data}))
    + "\"\n      data-log-click=\"context-menu-button\"\n      data-interaction-target=\"context-menu-button\"\n      data-interaction-intent=\"show-options\"></button>\n";
},"compiler":[7,">= 4.0.0"],"main":function(container,depth0,helpers,partials,data) {
    var stack1, alias1=depth0 != null ? depth0 : {};

  return ((stack1 = helpers.unless.call(alias1,(depth0 != null ? depth0.playButtonOnly : depth0),{"name":"unless","hash":{},"fn":container.program(1, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
    + "\n"
    + ((stack1 = container.invokePartial(partials["./controls-play-button.hbs"],depth0,{"name":"./controls-play-button.hbs","data":data,"helpers":helpers,"partials":partials,"decorators":container.decorators})) != null ? stack1 : "")
    + "\n"
    + ((stack1 = helpers.unless.call(alias1,(depth0 != null ? depth0.playButtonOnly : depth0),{"name":"unless","hash":{},"fn":container.program(10, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "");
},"usePartial":true,"useData":true});

},{"./controls-play-button.hbs":125,"hbsfy/runtime":429}],127:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
var partial$0 = require('./image.hbs');
HandlebarsCompiler.registerPartial('./image.hbs', partial$0);
module.exports = HandlebarsCompiler.template({"1":function(container,depth0,helpers,partials,data) {
    return "  <div class=\"card-overlay\"></div>\n";
},"compiler":[7,">= 4.0.0"],"main":function(container,depth0,helpers,partials,data) {
    var stack1;

  return ((stack1 = container.invokePartial(partials["./image.hbs"],depth0,{"name":"./image.hbs","data":data,"helpers":helpers,"partials":partials,"decorators":container.decorators})) != null ? stack1 : "")
    + "\n"
    + ((stack1 = helpers.unless.call(depth0 != null ? depth0 : {},(depth0 != null ? depth0.noPlayButton : depth0),{"name":"unless","hash":{},"fn":container.program(1, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "");
},"usePartial":true,"useData":true});

},{"./image.hbs":128,"hbsfy/runtime":429}],128:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
var partial$0 = require('./placeholder.hbs');
HandlebarsCompiler.registerPartial('./placeholder.hbs', partial$0);
module.exports = HandlebarsCompiler.template({"1":function(container,depth0,helpers,partials,data) {
    var helper;

  return "style=\"background-image: url('"
    + container.escapeExpression(((helper = (helper = helpers.imageUrl || (depth0 != null ? depth0.imageUrl : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : {},{"name":"imageUrl","hash":{},"data":data}) : helper)))
    + "')\"";
},"3":function(container,depth0,helpers,partials,data) {
    var helper;

  return "      data-image-url=\""
    + container.escapeExpression(((helper = (helper = helpers.imageUrl || (depth0 != null ? depth0.imageUrl : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : {},{"name":"imageUrl","hash":{},"data":data}) : helper)))
    + "\"\n";
},"5":function(container,depth0,helpers,partials,data) {
    var stack1, alias1=depth0 != null ? depth0 : {}, alias2=helpers.helperMissing;

  return ((stack1 = (helpers.compare || (depth0 && depth0.compare) || alias2).call(alias1,(helpers.type || (depth0 && depth0.type) || alias2).call(alias1,(depth0 != null ? depth0.seedUri : depth0),{"name":"type","hash":{},"data":data}),"cluster",{"name":"compare","hash":{"operator":"!="},"fn":container.program(6, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "");
},"6":function(container,depth0,helpers,partials,data) {
    var stack1, alias1=depth0 != null ? depth0 : {};

  return ((stack1 = helpers["if"].call(alias1,(depth0 != null ? depth0.dominantColor : depth0),{"name":"if","hash":{},"fn":container.program(7, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
    + "      <div class=\"card-station-layer card-station-mask\"></div>\n"
    + ((stack1 = helpers["if"].call(alias1,(depth0 != null ? depth0.imageUrl : depth0),{"name":"if","hash":{},"fn":container.program(9, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "");
},"7":function(container,depth0,helpers,partials,data) {
    var helper;

  return "        <div class=\"card-station-layer card-station-highlight\" style=\"background-color:"
    + container.escapeExpression(((helper = (helper = helpers.dominantColor || (depth0 != null ? depth0.dominantColor : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : {},{"name":"dominantColor","hash":{},"data":data}) : helper)))
    + "\"></div>\n";
},"9":function(container,depth0,helpers,partials,data) {
    var helper;

  return "        <div class=\"card-station-overlay\" style=\"background-image: url("
    + container.escapeExpression(((helper = (helper = helpers.imageUrl || (depth0 != null ? depth0.imageUrl : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : {},{"name":"imageUrl","hash":{},"data":data}) : helper)))
    + ")\"></div>\n";
},"compiler":[7,">= 4.0.0"],"main":function(container,depth0,helpers,partials,data) {
    var stack1, alias1=depth0 != null ? depth0 : {};

  return ((stack1 = container.invokePartial(partials["./placeholder.hbs"],depth0,{"name":"./placeholder.hbs","data":data,"helpers":helpers,"partials":partials,"decorators":container.decorators})) != null ? stack1 : "")
    + "\n<div class=\"card-image-content-wrapper\">\n  <div\n    class=\"card-image\"\n    "
    + ((stack1 = helpers["if"].call(alias1,(depth0 != null ? depth0.imageUrl : depth0),{"name":"if","hash":{},"fn":container.program(1, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
    + "\n    data-ta-id=\"card-image\"\n"
    + ((stack1 = helpers["if"].call(alias1,(depth0 != null ? depth0.imageUrl : depth0),{"name":"if","hash":{},"fn":container.program(3, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
    + "  >\n  </div>\n\n"
    + ((stack1 = (helpers.type || (depth0 && depth0.type) || helpers.helperMissing).call(alias1,(depth0 != null ? depth0.uri : depth0),"station",{"name":"type","hash":{},"fn":container.program(5, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
    + "</div>\n";
},"usePartial":true,"useData":true});

},{"./placeholder.hbs":130,"hbsfy/runtime":429}],129:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
var partial$0 = require('./image-with-overlay.hbs');
HandlebarsCompiler.registerPartial('./image-with-overlay.hbs', partial$0);
module.exports = HandlebarsCompiler.template({"1":function(container,depth0,helpers,partials,data) {
    var helper;

  return container.escapeExpression(((helper = (helper = helpers.dragText || (depth0 != null ? depth0.dragText : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : {},{"name":"dragText","hash":{},"data":data}) : helper)));
},"3":function(container,depth0,helpers,partials,data) {
    var helper;

  return container.escapeExpression(((helper = (helper = helpers.title || (depth0 != null ? depth0.title : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : {},{"name":"title","hash":{},"data":data}) : helper)));
},"5":function(container,depth0,helpers,partials,data) {
    return "no-image-url";
},"compiler":[7,">= 4.0.0"],"main":function(container,depth0,helpers,partials,data) {
    var stack1, helper, alias1=depth0 != null ? depth0 : {}, alias2=helpers.helperMissing, alias3="function", alias4=container.escapeExpression;

  return "<a\n  href=\""
    + alias4(((helper = (helper = helpers.uri || (depth0 != null ? depth0.uri : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"uri","hash":{},"data":data}) : helper)))
    + "\"\n  data-uri=\""
    + alias4(((helper = (helper = helpers.uri || (depth0 != null ? depth0.uri : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"uri","hash":{},"data":data}) : helper)))
    + "\"\n  data-log-click=\"media-image\"\n  draggable=\"true\"\n  data-drag-text=\""
    + ((stack1 = helpers["if"].call(alias1,(depth0 != null ? depth0.dragText : depth0),{"name":"if","hash":{},"fn":container.program(1, data, 0),"inverse":container.program(3, data, 0),"data":data})) != null ? stack1 : "")
    + "\"\n  class=\"card-image-link "
    + ((stack1 = helpers.unless.call(alias1,(depth0 != null ? depth0.imageUrl : depth0),{"name":"unless","hash":{},"fn":container.program(5, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
    + "\"\n  data-interaction-target=\"image\"\n>\n  <div class=\"card-hit-area-counter-scale\"></div>\n"
    + ((stack1 = container.invokePartial(partials["./image-with-overlay.hbs"],depth0,{"name":"./image-with-overlay.hbs","data":data,"indent":"  ","helpers":helpers,"partials":partials,"decorators":container.decorators})) != null ? stack1 : "")
    + "</a>\n";
},"usePartial":true,"useData":true});

},{"./image-with-overlay.hbs":127,"hbsfy/runtime":429}],130:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template({"compiler":[7,">= 4.0.0"],"main":function(container,depth0,helpers,partials,data) {
    return "<div class=\"card-placeholder-wrapper\">\n  <svg class=\"card-placeholder\" viewBox=\"0 0 10 10\" preserveAspectRatio=\"xMidYMid meet\">\n    <text class=\"playlist-placeholder\" x=\"5\" y=\"9.8\">&#xf135;</text>\n    <text class=\"playlist-folder-placeholder\" x=\"5\" y=\"9.8\">&#xf137;</text>\n    <text class=\"album-placeholder\" x=\"5\" y=\"9.8\">&#xf101;</text>\n    <text class=\"track-placeholder\" x=\"5\" y=\"9.8\">&#xf157;</text>\n    <text class=\"artist-placeholder\" x=\"5\" y=\"9.8\">&#xf103;</text>\n    <text class=\"user-placeholder\" x=\"5\" y=\"9.8\">&#xf15d;</text>\n    <text class=\"genre-placeholder\" x=\"5\" y=\"9.8\">&#xf109;</text>\n    <text class=\"collection-placeholder\" x=\"5\" y=\"9.8\">&#xf157;</text>\n    <text class=\"local-files-placeholder\" x=\"5\" y=\"9.8\">&#xf1fb;</text>\n    <text class=\"episode-placeholder\" x=\"5\" y=\"9.8\">&#xf26C;</text>\n  </svg>\n</div>\n";
},"useData":true});

},{"hbsfy/runtime":429}],131:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
var partial$0 = require('./tracklist/row-start.hbs');
HandlebarsCompiler.registerPartial('./tracklist/row-start.hbs', partial$0);
var partial$1 = require('./tracklist/play.hbs');
HandlebarsCompiler.registerPartial('./tracklist/play.hbs', partial$1);
var partial$2 = require('./tracklist/save.hbs');
HandlebarsCompiler.registerPartial('./tracklist/save.hbs', partial$2);
var partial$3 = require('./tracklist/name.hbs');
HandlebarsCompiler.registerPartial('./tracklist/name.hbs', partial$3);
var partial$4 = require('./tracklist/artists.hbs');
HandlebarsCompiler.registerPartial('./tracklist/artists.hbs', partial$4);
var partial$5 = require('./tracklist/album.hbs');
HandlebarsCompiler.registerPartial('./tracklist/album.hbs', partial$5);
var partial$6 = require('./tracklist/local.hbs');
HandlebarsCompiler.registerPartial('./tracklist/local.hbs', partial$6);
var partial$7 = require('./tracklist/more.hbs');
HandlebarsCompiler.registerPartial('./tracklist/more.hbs', partial$7);
var partial$8 = require('./tracklist/time.hbs');
HandlebarsCompiler.registerPartial('./tracklist/time.hbs', partial$8);
var partial$9 = require('./tracklist/popularity.hbs');
HandlebarsCompiler.registerPartial('./tracklist/popularity.hbs', partial$9);
module.exports = HandlebarsCompiler.template({"compiler":[7,">= 4.0.0"],"main":function(container,depth0,helpers,partials,data) {
    var stack1;

  return ((stack1 = container.invokePartial(partials["./tracklist/row-start.hbs"],depth0,{"name":"./tracklist/row-start.hbs","data":data,"helpers":helpers,"partials":partials,"decorators":container.decorators})) != null ? stack1 : "")
    + ((stack1 = container.invokePartial(partials["./tracklist/play.hbs"],depth0,{"name":"./tracklist/play.hbs","data":data,"indent":"  ","helpers":helpers,"partials":partials,"decorators":container.decorators})) != null ? stack1 : "")
    + ((stack1 = container.invokePartial(partials["./tracklist/save.hbs"],depth0,{"name":"./tracklist/save.hbs","data":data,"indent":"  ","helpers":helpers,"partials":partials,"decorators":container.decorators})) != null ? stack1 : "")
    + ((stack1 = container.invokePartial(partials["./tracklist/name.hbs"],depth0,{"name":"./tracklist/name.hbs","data":data,"indent":"  ","helpers":helpers,"partials":partials,"decorators":container.decorators})) != null ? stack1 : "")
    + ((stack1 = container.invokePartial(partials["./tracklist/artists.hbs"],depth0,{"name":"./tracklist/artists.hbs","data":data,"indent":"  ","helpers":helpers,"partials":partials,"decorators":container.decorators})) != null ? stack1 : "")
    + ((stack1 = container.invokePartial(partials["./tracklist/album.hbs"],depth0,{"name":"./tracklist/album.hbs","data":data,"indent":"  ","helpers":helpers,"partials":partials,"decorators":container.decorators})) != null ? stack1 : "")
    + ((stack1 = container.invokePartial(partials["./tracklist/local.hbs"],depth0,{"name":"./tracklist/local.hbs","data":data,"indent":"  ","helpers":helpers,"partials":partials,"decorators":container.decorators})) != null ? stack1 : "")
    + ((stack1 = container.invokePartial(partials["./tracklist/more.hbs"],depth0,{"name":"./tracklist/more.hbs","data":data,"indent":"  ","helpers":helpers,"partials":partials,"decorators":container.decorators})) != null ? stack1 : "")
    + ((stack1 = container.invokePartial(partials["./tracklist/time.hbs"],depth0,{"name":"./tracklist/time.hbs","data":data,"indent":"  ","helpers":helpers,"partials":partials,"decorators":container.decorators})) != null ? stack1 : "")
    + ((stack1 = container.invokePartial(partials["./tracklist/popularity.hbs"],depth0,{"name":"./tracklist/popularity.hbs","data":data,"indent":"  ","helpers":helpers,"partials":partials,"decorators":container.decorators})) != null ? stack1 : "")
    + "</tr>\n";
},"usePartial":true,"useData":true});

},{"./tracklist/album.hbs":133,"./tracklist/artists.hbs":134,"./tracklist/local.hbs":146,"./tracklist/more.hbs":147,"./tracklist/name.hbs":148,"./tracklist/play.hbs":149,"./tracklist/popularity.hbs":150,"./tracklist/row-start.hbs":151,"./tracklist/save.hbs":152,"./tracklist/time.hbs":155,"hbsfy/runtime":429}],132:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
var partial$0 = require('./tracklist/table-attributes.hbs');
HandlebarsCompiler.registerPartial('./tracklist/table-attributes.hbs', partial$0);
var partial$1 = require('./tracklist/header/play.hbs');
HandlebarsCompiler.registerPartial('./tracklist/header/play.hbs', partial$1);
var partial$2 = require('./tracklist/header/save.hbs');
HandlebarsCompiler.registerPartial('./tracklist/header/save.hbs', partial$2);
var partial$3 = require('./tracklist/header/name.hbs');
HandlebarsCompiler.registerPartial('./tracklist/header/name.hbs', partial$3);
var partial$4 = require('./tracklist/header/premium.hbs');
HandlebarsCompiler.registerPartial('./tracklist/header/premium.hbs', partial$4);
var partial$5 = require('./tracklist/header/explicit.hbs');
HandlebarsCompiler.registerPartial('./tracklist/header/explicit.hbs', partial$5);
var partial$6 = require('./tracklist/header/artists.hbs');
HandlebarsCompiler.registerPartial('./tracklist/header/artists.hbs', partial$6);
var partial$7 = require('./tracklist/header/album.hbs');
HandlebarsCompiler.registerPartial('./tracklist/header/album.hbs', partial$7);
var partial$8 = require('./tracklist/header/local.hbs');
HandlebarsCompiler.registerPartial('./tracklist/header/local.hbs', partial$8);
var partial$9 = require('./tracklist/header/more.hbs');
HandlebarsCompiler.registerPartial('./tracklist/header/more.hbs', partial$9);
var partial$10 = require('./tracklist/header/time.hbs');
HandlebarsCompiler.registerPartial('./tracklist/header/time.hbs', partial$10);
var partial$11 = require('./tracklist/header/popularity.hbs');
HandlebarsCompiler.registerPartial('./tracklist/header/popularity.hbs', partial$11);
var partial$12 = require('./tracklist/table-body-attributes.hbs');
HandlebarsCompiler.registerPartial('./tracklist/table-body-attributes.hbs', partial$12);
var partial$13 = require('./tracklist-search-row.hbs');
HandlebarsCompiler.registerPartial('./tracklist-search-row.hbs', partial$13);
module.exports = HandlebarsCompiler.template({"1":function(container,depth0,helpers,partials,data) {
    var helper;

  return "aria-labelledby=\""
    + container.escapeExpression(((helper = (helper = helpers.ariaLabel || (depth0 != null ? depth0.ariaLabel : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : {},{"name":"ariaLabel","hash":{},"data":data}) : helper)))
    + "\"";
},"3":function(container,depth0,helpers,partials,data) {
    var stack1;

  return ((stack1 = container.invokePartial(partials["./tracklist-search-row.hbs"],depth0,{"name":"./tracklist-search-row.hbs","data":data,"indent":"      ","helpers":helpers,"partials":partials,"decorators":container.decorators})) != null ? stack1 : "");
},"compiler":[7,">= 4.0.0"],"main":function(container,depth0,helpers,partials,data) {
    var stack1, helper, alias1=depth0 != null ? depth0 : {}, alias2=helpers.helperMissing;

  return "<table\n  class=\"tracklist-search "
    + container.escapeExpression(((helper = (helper = helpers.modifiers || (depth0 != null ? depth0.modifiers : depth0)) != null ? helper : alias2),(typeof helper === "function" ? helper.call(alias1,{"name":"modifiers","hash":{},"data":data}) : helper)))
    + "\"\n  "
    + ((stack1 = helpers["if"].call(alias1,(depth0 != null ? depth0.ariaLabel : depth0),{"name":"if","hash":{},"fn":container.program(1, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
    + "\n"
    + ((stack1 = container.invokePartial(partials["./tracklist/table-attributes.hbs"],depth0,{"name":"./tracklist/table-attributes.hbs","data":data,"indent":"  ","helpers":helpers,"partials":partials,"decorators":container.decorators})) != null ? stack1 : "")
    + ">\n  <thead class=\"tl-header\">\n    <tr>\n"
    + ((stack1 = container.invokePartial(partials["./tracklist/header/play.hbs"],depth0,{"name":"./tracklist/header/play.hbs","data":data,"indent":"      ","helpers":helpers,"partials":partials,"decorators":container.decorators})) != null ? stack1 : "")
    + ((stack1 = container.invokePartial(partials["./tracklist/header/save.hbs"],depth0,{"name":"./tracklist/header/save.hbs","data":data,"indent":"      ","helpers":helpers,"partials":partials,"decorators":container.decorators})) != null ? stack1 : "")
    + ((stack1 = container.invokePartial(partials["./tracklist/header/name.hbs"],depth0,{"name":"./tracklist/header/name.hbs","data":data,"indent":"      ","helpers":helpers,"partials":partials,"decorators":container.decorators})) != null ? stack1 : "")
    + ((stack1 = container.invokePartial(partials["./tracklist/header/premium.hbs"],depth0,{"name":"./tracklist/header/premium.hbs","data":data,"indent":"      ","helpers":helpers,"partials":partials,"decorators":container.decorators})) != null ? stack1 : "")
    + ((stack1 = container.invokePartial(partials["./tracklist/header/explicit.hbs"],depth0,{"name":"./tracklist/header/explicit.hbs","data":data,"indent":"      ","helpers":helpers,"partials":partials,"decorators":container.decorators})) != null ? stack1 : "")
    + ((stack1 = container.invokePartial(partials["./tracklist/header/artists.hbs"],depth0,{"name":"./tracklist/header/artists.hbs","data":data,"indent":"      ","helpers":helpers,"partials":partials,"decorators":container.decorators})) != null ? stack1 : "")
    + ((stack1 = container.invokePartial(partials["./tracklist/header/album.hbs"],depth0,{"name":"./tracklist/header/album.hbs","data":data,"indent":"      ","helpers":helpers,"partials":partials,"decorators":container.decorators})) != null ? stack1 : "")
    + ((stack1 = container.invokePartial(partials["./tracklist/header/local.hbs"],depth0,{"name":"./tracklist/header/local.hbs","data":data,"indent":"      ","helpers":helpers,"partials":partials,"decorators":container.decorators})) != null ? stack1 : "")
    + ((stack1 = container.invokePartial(partials["./tracklist/header/more.hbs"],depth0,{"name":"./tracklist/header/more.hbs","data":data,"indent":"      ","helpers":helpers,"partials":partials,"decorators":container.decorators})) != null ? stack1 : "")
    + ((stack1 = container.invokePartial(partials["./tracklist/header/time.hbs"],depth0,{"name":"./tracklist/header/time.hbs","data":data,"indent":"      ","helpers":helpers,"partials":partials,"decorators":container.decorators})) != null ? stack1 : "")
    + ((stack1 = container.invokePartial(partials["./tracklist/header/popularity.hbs"],depth0,{"name":"./tracklist/header/popularity.hbs","data":data,"indent":"      ","helpers":helpers,"partials":partials,"decorators":container.decorators})) != null ? stack1 : "")
    + "    </tr>\n  </thead>\n  <tbody "
    + ((stack1 = container.invokePartial(partials["./tracklist/table-body-attributes.hbs"],depth0,{"name":"./tracklist/table-body-attributes.hbs","data":data,"helpers":helpers,"partials":partials,"decorators":container.decorators})) != null ? stack1 : "")
    + ">\n"
    + ((stack1 = (helpers.list || (depth0 && depth0.list) || alias2).call(alias1,(depth0 != null ? depth0.rows : depth0),{"name":"list","hash":{},"fn":container.program(3, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
    + "  </tbody>\n</table>\n";
},"usePartial":true,"useData":true});

},{"./tracklist-search-row.hbs":131,"./tracklist/header/album.hbs":135,"./tracklist/header/artists.hbs":136,"./tracklist/header/explicit.hbs":137,"./tracklist/header/local.hbs":138,"./tracklist/header/more.hbs":139,"./tracklist/header/name.hbs":140,"./tracklist/header/play.hbs":141,"./tracklist/header/popularity.hbs":142,"./tracklist/header/premium.hbs":143,"./tracklist/header/save.hbs":144,"./tracklist/header/time.hbs":145,"./tracklist/table-attributes.hbs":153,"./tracklist/table-body-attributes.hbs":154,"hbsfy/runtime":429}],133:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template({"1":function(container,depth0,helpers,partials,data) {
    var stack1;

  return ((stack1 = helpers["if"].call(depth0 != null ? depth0 : {},(depth0 != null ? depth0.local : depth0),{"name":"if","hash":{},"fn":container.program(2, data, 0),"inverse":container.program(4, data, 0),"data":data})) != null ? stack1 : "");
},"2":function(container,depth0,helpers,partials,data) {
    var helper;

  return "      "
    + container.escapeExpression(((helper = (helper = helpers.name || (depth0 != null ? depth0.name : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : {},{"name":"name","hash":{},"data":data}) : helper)))
    + "\n";
},"4":function(container,depth0,helpers,partials,data) {
    var stack1;

  return ((stack1 = helpers["if"].call(depth0 != null ? depth0 : {},(depth0 != null ? depth0.uri : depth0),{"name":"if","hash":{},"fn":container.program(5, data, 0),"inverse":container.program(7, data, 0),"data":data})) != null ? stack1 : "");
},"5":function(container,depth0,helpers,partials,data) {
    var helper, alias1=depth0 != null ? depth0 : {}, alias2=helpers.helperMissing, alias3="function", alias4=container.escapeExpression;

  return "        <a title=\""
    + alias4(((helper = (helper = helpers.name || (depth0 != null ? depth0.name : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"name","hash":{},"data":data}) : helper)))
    + "\" href=\""
    + alias4(((helper = (helper = helpers.uri || (depth0 != null ? depth0.uri : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"uri","hash":{},"data":data}) : helper)))
    + "\" data-uri=\""
    + alias4(((helper = (helper = helpers.uri || (depth0 != null ? depth0.uri : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"uri","hash":{},"data":data}) : helper)))
    + "\" data-log-click=\"album-name\" data-interaction-target=\"album-name\">"
    + alias4(((helper = (helper = helpers.name || (depth0 != null ? depth0.name : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"name","hash":{},"data":data}) : helper)))
    + "</a>\n";
},"7":function(container,depth0,helpers,partials,data) {
    var helper;

  return "        "
    + container.escapeExpression(((helper = (helper = helpers.name || (depth0 != null ? depth0.name : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : {},{"name":"name","hash":{},"data":data}) : helper)))
    + "\n";
},"compiler":[7,">= 4.0.0"],"main":function(container,depth0,helpers,partials,data) {
    var stack1;

  return "<td class=\"tl-cell tl-albums\" data-log-context=\"album-cell\">\n"
    + ((stack1 = helpers.blockHelperMissing.call(depth0,container.lambda(((stack1 = (depth0 != null ? depth0.track : depth0)) != null ? stack1.album : stack1), depth0),{"name":"track.album","hash":{},"fn":container.program(1, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
    + "</td>\n";
},"useData":true});

},{"hbsfy/runtime":429}],134:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template({"1":function(container,depth0,helpers,partials,data) {
    var stack1;

  return ((stack1 = helpers["if"].call(depth0 != null ? depth0 : {},(depth0 != null ? depth0.local : depth0),{"name":"if","hash":{},"fn":container.program(2, data, 0),"inverse":container.program(4, data, 0),"data":data})) != null ? stack1 : "");
},"2":function(container,depth0,helpers,partials,data) {
    var helper;

  return container.escapeExpression(((helper = (helper = helpers.name || (depth0 != null ? depth0.name : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : {},{"name":"name","hash":{},"data":data}) : helper)));
},"4":function(container,depth0,helpers,partials,data) {
    var helper, alias1=depth0 != null ? depth0 : {}, alias2=helpers.helperMissing, alias3="function", alias4=container.escapeExpression;

  return "<a title=\""
    + alias4(((helper = (helper = helpers.name || (depth0 != null ? depth0.name : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"name","hash":{},"data":data}) : helper)))
    + "\" href=\""
    + alias4(((helper = (helper = helpers.uri || (depth0 != null ? depth0.uri : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"uri","hash":{},"data":data}) : helper)))
    + "\" data-uri=\""
    + alias4(((helper = (helper = helpers.uri || (depth0 != null ? depth0.uri : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"uri","hash":{},"data":data}) : helper)))
    + "\" data-log-click=\"artist-name\" data-interaction-target=\""
    + alias4(((helper = (helper = helpers.index || (data && data.index)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"index","hash":{},"data":data}) : helper)))
    + "\">"
    + alias4(((helper = (helper = helpers.name || (depth0 != null ? depth0.name : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"name","hash":{},"data":data}) : helper)))
    + "</a>";
},"compiler":[7,">= 4.0.0"],"main":function(container,depth0,helpers,partials,data) {
    var stack1;

  return "<td class=\"tl-cell tl-artists\" data-log-context=\"artist-cell\" data-interaction-context=\"artists\">\n  "
    + ((stack1 = (helpers.slice || (depth0 && depth0.slice) || helpers.helperMissing).call(depth0 != null ? depth0 : {},((stack1 = (depth0 != null ? depth0.track : depth0)) != null ? stack1.artists : stack1),", ",{"name":"slice","hash":{},"fn":container.program(1, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
    + "\n</td>\n";
},"useData":true});

},{"hbsfy/runtime":429}],135:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template({"1":function(container,depth0,helpers,partials,data) {
    var stack1;

  return ((stack1 = (helpers.compare || (depth0 && depth0.compare) || helpers.helperMissing).call(depth0 != null ? depth0 : {},(depth0 != null ? depth0.sortDirection : depth0),"asc",{"name":"compare","hash":{},"fn":container.program(2, data, 0),"inverse":container.program(4, data, 0),"data":data})) != null ? stack1 : "");
},"2":function(container,depth0,helpers,partials,data) {
    return "    tl-sort-asc\n";
},"4":function(container,depth0,helpers,partials,data) {
    return "    tl-sort-desc\n";
},"6":function(container,depth0,helpers,partials,data) {
    return "data-sort=\"track(album(name),disc,number)\" data-interaction-target=\"header-album\" data-interaction-intent=\"sort-by-album\"";
},"compiler":[7,">= 4.0.0"],"main":function(container,depth0,helpers,partials,data) {
    var stack1, alias1=depth0 != null ? depth0 : {}, alias2=helpers.helperMissing;

  return "<th class=\"tl-albums\n"
    + ((stack1 = (helpers.compare || (depth0 && depth0.compare) || alias2).call(alias1,"track(album(name),disc,number)",(depth0 != null ? depth0.sortQuery : depth0),{"name":"compare","hash":{},"fn":container.program(1, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
    + "\" "
    + ((stack1 = helpers["if"].call(alias1,(depth0 != null ? depth0.sortable : depth0),{"name":"if","hash":{},"fn":container.program(6, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
    + ">"
    + container.escapeExpression((helpers.loc || (depth0 && depth0.loc) || alias2).call(alias1,"Album",{"name":"loc","hash":{},"data":data}))
    + "</th>\n";
},"useData":true});

},{"hbsfy/runtime":429}],136:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template({"1":function(container,depth0,helpers,partials,data) {
    var stack1;

  return ((stack1 = (helpers.compare || (depth0 && depth0.compare) || helpers.helperMissing).call(depth0 != null ? depth0 : {},(depth0 != null ? depth0.sortDirection : depth0),"asc",{"name":"compare","hash":{},"fn":container.program(2, data, 0),"inverse":container.program(4, data, 0),"data":data})) != null ? stack1 : "");
},"2":function(container,depth0,helpers,partials,data) {
    return "    tl-sort-asc\n";
},"4":function(container,depth0,helpers,partials,data) {
    return "    tl-sort-desc\n";
},"6":function(container,depth0,helpers,partials,data) {
    return "data-sort=\"track(artists[0:1](name),album(name),disc,number)\" data-interaction-target=\"header-artist\" data-interaction-intent=\"sort-by-artist\"";
},"compiler":[7,">= 4.0.0"],"main":function(container,depth0,helpers,partials,data) {
    var stack1, alias1=depth0 != null ? depth0 : {}, alias2=helpers.helperMissing;

  return "<th class=\"tl-artists\n"
    + ((stack1 = (helpers.compare || (depth0 && depth0.compare) || alias2).call(alias1,"track(artists[0:1](name),album(name),disc,number)",(depth0 != null ? depth0.sortQuery : depth0),{"name":"compare","hash":{},"fn":container.program(1, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
    + "\" "
    + ((stack1 = helpers["if"].call(alias1,(depth0 != null ? depth0.sortable : depth0),{"name":"if","hash":{},"fn":container.program(6, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
    + ">"
    + container.escapeExpression((helpers.loc || (depth0 && depth0.loc) || alias2).call(alias1,"Artist",{"name":"loc","hash":{},"data":data}))
    + "</th>\n";
},"useData":true});

},{"hbsfy/runtime":429}],137:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template({"1":function(container,depth0,helpers,partials,data) {
    return "data-sort-previous";
},"compiler":[7,">= 4.0.0"],"main":function(container,depth0,helpers,partials,data) {
    var stack1;

  return "<th class=\"tl-explicit\" "
    + ((stack1 = helpers["if"].call(depth0 != null ? depth0 : {},(depth0 != null ? depth0.sortable : depth0),{"name":"if","hash":{},"fn":container.program(1, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
    + "></th>\n";
},"useData":true});

},{"hbsfy/runtime":429}],138:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template({"1":function(container,depth0,helpers,partials,data) {
    return "data-sort-previous";
},"compiler":[7,">= 4.0.0"],"main":function(container,depth0,helpers,partials,data) {
    var stack1;

  return "<th class=\"tl-local\" "
    + ((stack1 = helpers["if"].call(depth0 != null ? depth0 : {},(depth0 != null ? depth0.sortable : depth0),{"name":"if","hash":{},"fn":container.program(1, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
    + "></th>";
},"useData":true});

},{"hbsfy/runtime":429}],139:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template({"1":function(container,depth0,helpers,partials,data) {
    return "data-sort-previous";
},"compiler":[7,">= 4.0.0"],"main":function(container,depth0,helpers,partials,data) {
    var stack1;

  return "<th class=\"tl-more\" "
    + ((stack1 = helpers["if"].call(depth0 != null ? depth0 : {},(depth0 != null ? depth0.sortable : depth0),{"name":"if","hash":{},"fn":container.program(1, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
    + "></th>\r";
},"useData":true});

},{"hbsfy/runtime":429}],140:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template({"1":function(container,depth0,helpers,partials,data) {
    var stack1;

  return ((stack1 = (helpers.compare || (depth0 && depth0.compare) || helpers.helperMissing).call(depth0 != null ? depth0 : {},(depth0 != null ? depth0.sortDirection : depth0),"asc",{"name":"compare","hash":{},"fn":container.program(2, data, 0),"inverse":container.program(4, data, 0),"data":data})) != null ? stack1 : "");
},"2":function(container,depth0,helpers,partials,data) {
    return "    tl-sort-asc\n";
},"4":function(container,depth0,helpers,partials,data) {
    return "    tl-sort-desc\n";
},"6":function(container,depth0,helpers,partials,data) {
    return "data-sort=\"track(name)\" data-interaction-target=\"header-name\" data-interaction-intent=\"sort-by-name\"";
},"compiler":[7,">= 4.0.0"],"main":function(container,depth0,helpers,partials,data) {
    var stack1, alias1=depth0 != null ? depth0 : {}, alias2=helpers.helperMissing;

  return "<th class=\"tl-name\n"
    + ((stack1 = (helpers.compare || (depth0 && depth0.compare) || alias2).call(alias1,"track(name)",(depth0 != null ? depth0.sortQuery : depth0),{"name":"compare","hash":{},"fn":container.program(1, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
    + "\" "
    + ((stack1 = helpers["if"].call(alias1,(depth0 != null ? depth0.sortable : depth0),{"name":"if","hash":{},"fn":container.program(6, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
    + ">"
    + container.escapeExpression((helpers.loc || (depth0 && depth0.loc) || alias2).call(alias1,"Title",{"name":"loc","hash":{},"data":data}))
    + "</th>\n";
},"useData":true});

},{"hbsfy/runtime":429}],141:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template({"compiler":[7,">= 4.0.0"],"main":function(container,depth0,helpers,partials,data) {
    return "<th class=\"tl-play\"></th>\n";
},"useData":true});

},{"hbsfy/runtime":429}],142:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template({"1":function(container,depth0,helpers,partials,data) {
    var stack1;

  return ((stack1 = (helpers.compare || (depth0 && depth0.compare) || helpers.helperMissing).call(depth0 != null ? depth0 : {},(depth0 != null ? depth0.sortDirection : depth0),"asc",{"name":"compare","hash":{},"fn":container.program(2, data, 0),"inverse":container.program(4, data, 0),"data":data})) != null ? stack1 : "");
},"2":function(container,depth0,helpers,partials,data) {
    return "    tl-sort-asc\n";
},"4":function(container,depth0,helpers,partials,data) {
    return "    tl-sort-desc\n";
},"6":function(container,depth0,helpers,partials,data) {
    return "  data-sort=\"track(negPopularity)\"\n  data-interaction-target=\"header-name\"\n  data-interaction-intent=\"sort-by-popularity\"\n";
},"compiler":[7,">= 4.0.0"],"main":function(container,depth0,helpers,partials,data) {
    var stack1, alias1=depth0 != null ? depth0 : {};

  return "<th class=\"tl-popularity\n"
    + ((stack1 = (helpers.compare || (depth0 && depth0.compare) || helpers.helperMissing).call(alias1,"track(negPopularity)",(depth0 != null ? depth0.sortQuery : depth0),{"name":"compare","hash":{},"fn":container.program(1, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
    + "\"\n"
    + ((stack1 = helpers["if"].call(alias1,(depth0 != null ? depth0.sortable : depth0),{"name":"if","hash":{},"fn":container.program(6, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
    + "></th>\n";
},"useData":true});

},{"hbsfy/runtime":429}],143:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template({"1":function(container,depth0,helpers,partials,data) {
    return "data-sort-previous";
},"compiler":[7,">= 4.0.0"],"main":function(container,depth0,helpers,partials,data) {
    var stack1;

  return "<th class=\"tl-premium\" "
    + ((stack1 = helpers["if"].call(depth0 != null ? depth0 : {},(depth0 != null ? depth0.sortable : depth0),{"name":"if","hash":{},"fn":container.program(1, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
    + "></th>\n";
},"useData":true});

},{"hbsfy/runtime":429}],144:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template({"compiler":[7,">= 4.0.0"],"main":function(container,depth0,helpers,partials,data) {
    return "<th class=\"tl-save\"></th>\n";
},"useData":true});

},{"hbsfy/runtime":429}],145:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template({"1":function(container,depth0,helpers,partials,data) {
    var stack1;

  return ((stack1 = (helpers.compare || (depth0 && depth0.compare) || helpers.helperMissing).call(depth0 != null ? depth0 : {},(depth0 != null ? depth0.sortDirection : depth0),"asc",{"name":"compare","hash":{},"fn":container.program(2, data, 0),"inverse":container.program(4, data, 0),"data":data})) != null ? stack1 : "");
},"2":function(container,depth0,helpers,partials,data) {
    return "    tl-sort-asc\n";
},"4":function(container,depth0,helpers,partials,data) {
    return "    tl-sort-desc\n";
},"6":function(container,depth0,helpers,partials,data) {
    return "data-sort=\"track(duration)\" data-interaction-target=\"header-duration\" data-interaction-intent=\"sort-by-duration\"";
},"compiler":[7,">= 4.0.0"],"main":function(container,depth0,helpers,partials,data) {
    var stack1, alias1=depth0 != null ? depth0 : {};

  return "<th class=\"tl-time\n"
    + ((stack1 = (helpers.compare || (depth0 && depth0.compare) || helpers.helperMissing).call(alias1,"track(duration)",(depth0 != null ? depth0.sortQuery : depth0),{"name":"compare","hash":{},"fn":container.program(1, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
    + "\" "
    + ((stack1 = helpers["if"].call(alias1,(depth0 != null ? depth0.sortable : depth0),{"name":"if","hash":{},"fn":container.program(6, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
    + "></th>\n";
},"useData":true});

},{"hbsfy/runtime":429}],146:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template({"1":function(container,depth0,helpers,partials,data) {
    return "  <span class=\"tl-item-local spoticon-localfile-16\" data-tooltip=\""
    + container.escapeExpression((helpers.loc || (depth0 && depth0.loc) || helpers.helperMissing).call(depth0 != null ? depth0 : {},"LocalFile",{"name":"loc","hash":{},"data":data}))
    + "\"></span>\n";
},"compiler":[7,">= 4.0.0"],"main":function(container,depth0,helpers,partials,data) {
    var stack1;

  return "<td class=\"tl-cell tl-local\">\n"
    + ((stack1 = helpers["if"].call(depth0 != null ? depth0 : {},((stack1 = (depth0 != null ? depth0.track : depth0)) != null ? stack1.local : stack1),{"name":"if","hash":{},"fn":container.program(1, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
    + "</td>\n";
},"useData":true});

},{"hbsfy/runtime":429}],147:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template({"compiler":[7,">= 4.0.0"],"main":function(container,depth0,helpers,partials,data) {
    var helper, alias1=depth0 != null ? depth0 : {}, alias2=helpers.helperMissing, alias3=container.escapeExpression, alias4="function";

  return "<td class=\"tl-cell tl-more\">\n  <button\n    type=\"button\"\n    data-button=\"contextmenu\"\n    class=\"button button-icon-only button-more\"\n    data-tooltip=\""
    + alias3((helpers.loc || (depth0 && depth0.loc) || alias2).call(alias1,"More",{"name":"loc","hash":{},"data":data}))
    + "\"\n    data-log-click=\"more-button\"\n    data-log-data='{ \"index\": "
    + alias3(((helper = (helper = helpers.index || (data && data.index)) != null ? helper : alias2),(typeof helper === alias4 ? helper.call(alias1,{"name":"index","hash":{},"data":data}) : helper)))
    + ", \"target_uri\": \""
    + alias3(((helper = (helper = helpers.uri || (depth0 != null ? depth0.uri : depth0)) != null ? helper : alias2),(typeof helper === alias4 ? helper.call(alias1,{"name":"uri","hash":{},"data":data}) : helper)))
    + "\" }'\n    data-interaction-target=\"context-menu-button\"\n    data-interaction-intent=\"show-options\"></button>\n</td>\n";
},"useData":true});

},{"hbsfy/runtime":429}],148:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template({"1":function(container,depth0,helpers,partials,data) {
    var stack1;

  return ((stack1 = helpers["if"].call(depth0 != null ? depth0 : {},((stack1 = (depth0 != null ? depth0.track : depth0)) != null ? stack1.premium : stack1),{"name":"if","hash":{},"fn":container.program(2, data, 0),"inverse":container.program(4, data, 0),"data":data})) != null ? stack1 : "");
},"2":function(container,depth0,helpers,partials,data) {
    return "    <td class=\"tl-cell tl-name\" colspan=\"1\" data-log-context=\"name-cell\">\n";
},"4":function(container,depth0,helpers,partials,data) {
    return "    <td class=\"tl-cell tl-name\" colspan=\"2\" data-log-context=\"name-cell\">\n";
},"6":function(container,depth0,helpers,partials,data) {
    var stack1;

  return ((stack1 = helpers["if"].call(depth0 != null ? depth0 : {},((stack1 = (depth0 != null ? depth0.track : depth0)) != null ? stack1.premium : stack1),{"name":"if","hash":{},"fn":container.program(4, data, 0),"inverse":container.program(7, data, 0),"data":data})) != null ? stack1 : "");
},"7":function(container,depth0,helpers,partials,data) {
    return "    <td class=\"tl-cell tl-name\" colspan=\"3\" data-log-context=\"name-cell\">\n";
},"9":function(container,depth0,helpers,partials,data) {
    return "    <span class=\"tl-status-indicator tl-status-indicator--in-progress\"></span>\n";
},"11":function(container,depth0,helpers,partials,data) {
    var stack1;

  return ((stack1 = helpers["if"].call(depth0 != null ? depth0 : {},(depth0 != null ? depth0["new"] : depth0),{"name":"if","hash":{},"fn":container.program(12, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "");
},"12":function(container,depth0,helpers,partials,data) {
    return "      <span class=\"tl-status-indicator tl-status-indicator--new\"></span>\n";
},"14":function(container,depth0,helpers,partials,data) {
    return "</td><td class=\"tl-cell tl-premium\"><span class=\"label\" data-log-click=\"premium\">PREMIUM</span>";
},"16":function(container,depth0,helpers,partials,data) {
    return "</td><td class=\"tl-cell tl-explicit\"><span class=\"label\" data-log-click=\"explicit\">EXPLICIT</span>";
},"compiler":[7,">= 4.0.0"],"main":function(container,depth0,helpers,partials,data) {
    var stack1, alias1=depth0 != null ? depth0 : {}, alias2=container.lambda, alias3=helpers.blockHelperMissing;

  return ((stack1 = helpers["if"].call(alias1,((stack1 = (depth0 != null ? depth0.track : depth0)) != null ? stack1.explicit : stack1),{"name":"if","hash":{},"fn":container.program(1, data, 0),"inverse":container.program(6, data, 0),"data":data})) != null ? stack1 : "")
    + "<div class=\"tl-highlight\" data-log-click=\"name\">\n"
    + ((stack1 = helpers["if"].call(alias1,(depth0 != null ? depth0.inProgress : depth0),{"name":"if","hash":{},"fn":container.program(9, data, 0),"inverse":container.program(11, data, 0),"data":data})) != null ? stack1 : "")
    + "\n  "
    + container.escapeExpression(alias2(((stack1 = (depth0 != null ? depth0.track : depth0)) != null ? stack1.name : stack1), depth0))
    + "\n</div>\n"
    + ((stack1 = alias3.call(depth0,alias2(((stack1 = (depth0 != null ? depth0.track : depth0)) != null ? stack1.premium : stack1), depth0),{"name":"track.premium","hash":{},"fn":container.program(14, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
    + "\n"
    + ((stack1 = alias3.call(depth0,alias2(((stack1 = (depth0 != null ? depth0.track : depth0)) != null ? stack1.explicit : stack1), depth0),{"name":"track.explicit","hash":{},"fn":container.program(16, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
    + "\n</td>\n";
},"useData":true});

},{"hbsfy/runtime":429}],149:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template({"compiler":[7,">= 4.0.0"],"main":function(container,depth0,helpers,partials,data) {
    return "<td class=\"tl-cell tl-play\">\n  <button\n    type=\"button\"\n    data-button=\"play\"\n    class=\"button button-icon-with-stroke button-play\"\n    data-ta-id=\"play-button\"\n    data-interaction-target=\"play-pause-button\"\n    data-interaction-intent=\"play\"\n    data-log-click=\"play-button\"></button>\n</td>\n";
},"useData":true});

},{"hbsfy/runtime":429}],150:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template({"1":function(container,depth0,helpers,partials,data) {
    var stack1;

  return " data-tooltip=\""
    + container.escapeExpression((helpers.loc || (depth0 && depth0.loc) || helpers.helperMissing).call(depth0 != null ? depth0 : {},"ListenCount",((stack1 = (depth0 != null ? depth0.track : depth0)) != null ? stack1.listenCount : stack1),{"name":"loc","hash":{},"data":data}))
    + "\" data-tooltip-instant";
},"compiler":[7,">= 4.0.0"],"main":function(container,depth0,helpers,partials,data) {
    var stack1;

  return "<td class=\"tl-cell tl-popularity\""
    + ((stack1 = helpers["if"].call(depth0 != null ? depth0 : {},((stack1 = (depth0 != null ? depth0.track : depth0)) != null ? stack1.listenCount : stack1),{"name":"if","hash":{},"fn":container.program(1, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
    + ">\n  <div class=\"pop-meter\">\n    <div class=\"pop-meter-background\"></div>\n    <div class=\"pop-meter-overlay\" style=\"width: "
    + container.escapeExpression(container.lambda(((stack1 = (depth0 != null ? depth0.track : depth0)) != null ? stack1.popularity : stack1), depth0))
    + "%\"></div>\n  </div>\n</td>\n";
},"useData":true});

},{"hbsfy/runtime":429}],151:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template({"1":function(container,depth0,helpers,partials,data) {
    var helper;

  return container.escapeExpression(((helper = (helper = helpers.name || (depth0 != null ? depth0.name : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : {},{"name":"name","hash":{},"data":data}) : helper)));
},"3":function(container,depth0,helpers,partials,data) {
    var helper;

  return container.escapeExpression(((helper = (helper = helpers.index || (depth0 != null ? depth0.index : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : {},{"name":"index","hash":{},"data":data}) : helper)));
},"5":function(container,depth0,helpers,partials,data) {
    var helper;

  return container.escapeExpression(((helper = (helper = helpers.index || (data && data.index)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : {},{"name":"index","hash":{},"data":data}) : helper)));
},"7":function(container,depth0,helpers,partials,data) {
    var helper;

  return container.escapeExpression(((helper = (helper = helpers.contextIndex || (depth0 != null ? depth0.contextIndex : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : {},{"name":"contextIndex","hash":{},"data":data}) : helper)));
},"9":function(container,depth0,helpers,partials,data) {
    var stack1;

  return ((stack1 = helpers["if"].call(depth0 != null ? depth0 : {},(depth0 != null ? depth0.index : depth0),{"name":"if","hash":{},"fn":container.program(3, data, 0),"inverse":container.program(5, data, 0),"data":data})) != null ? stack1 : "");
},"11":function(container,depth0,helpers,partials,data) {
    var helper;

  return "data-uid=\""
    + container.escapeExpression(((helper = (helper = helpers.uid || (depth0 != null ? depth0.uid : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : {},{"name":"uid","hash":{},"data":data}) : helper)))
    + "\"";
},"13":function(container,depth0,helpers,partials,data) {
    var stack1;

  return ((stack1 = helpers["if"].call(depth0 != null ? depth0 : {},((stack1 = (depth0 != null ? depth0.track : depth0)) != null ? stack1.offlineProgress : stack1),{"name":"if","hash":{},"fn":container.program(14, data, 0),"inverse":container.program(19, data, 0),"data":data})) != null ? stack1 : "");
},"14":function(container,depth0,helpers,partials,data) {
    var stack1;

  return ((stack1 = (helpers.compare || (depth0 && depth0.compare) || helpers.helperMissing).call(depth0 != null ? depth0 : {},((stack1 = (depth0 != null ? depth0.track : depth0)) != null ? stack1.offlineProgress : stack1),1,{"name":"compare","hash":{},"fn":container.program(15, data, 0),"inverse":container.program(17, data, 0),"data":data})) != null ? stack1 : "");
},"15":function(container,depth0,helpers,partials,data) {
    return "            offline-downloaded\n";
},"17":function(container,depth0,helpers,partials,data) {
    return "            offline-downloading\n";
},"19":function(container,depth0,helpers,partials,data) {
    return "          offline-waiting\n";
},"21":function(container,depth0,helpers,partials,data) {
    return "playing";
},"23":function(container,depth0,helpers,partials,data) {
    return "selected";
},"25":function(container,depth0,helpers,partials,data) {
    return "added";
},"27":function(container,depth0,helpers,partials,data) {
    return "unavailable";
},"29":function(container,depth0,helpers,partials,data) {
    return "local";
},"31":function(container,depth0,helpers,partials,data) {
    return "local-file-available";
},"33":function(container,depth0,helpers,partials,data) {
    var stack1;

  return "thumbs-"
    + container.escapeExpression(container.lambda(((stack1 = (depth0 != null ? depth0.track : depth0)) != null ? stack1.thumb : stack1), depth0));
},"35":function(container,depth0,helpers,partials,data) {
    return "thumbs-none";
},"37":function(container,depth0,helpers,partials,data) {
    return "tl-row--episode";
},"compiler":[7,">= 4.0.0"],"main":function(container,depth0,helpers,partials,data) {
    var stack1, helper, alias1=container.lambda, alias2=container.escapeExpression, alias3=depth0 != null ? depth0 : {}, alias4=helpers.helperMissing;

  return "<tr tabindex=\"0\"\n    aria-label=\""
    + alias2(alias1(((stack1 = (depth0 != null ? depth0.track : depth0)) != null ? stack1.name : stack1), depth0))
    + " "
    + alias2((helpers.loc || (depth0 && depth0.loc) || alias4).call(alias3,"By",{"name":"loc","hash":{},"data":data}))
    + " "
    + ((stack1 = (helpers.slice || (depth0 && depth0.slice) || alias4).call(alias3,((stack1 = (depth0 != null ? depth0.track : depth0)) != null ? stack1.artists : stack1),", ",{"name":"slice","hash":{},"fn":container.program(1, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
    + ". "
    + alias2((helpers.loc || (depth0 && depth0.loc) || alias4).call(alias3,"PressEnterToPlay",{"name":"loc","hash":{},"data":data}))
    + ".\"\n    data-list-item=\"true\" data-uri=\""
    + alias2(alias1(((stack1 = (depth0 != null ? depth0.track : depth0)) != null ? stack1.uri : stack1), depth0))
    + "\"\n    data-index=\""
    + ((stack1 = helpers["if"].call(alias3,(depth0 != null ? depth0.index : depth0),{"name":"if","hash":{},"fn":container.program(3, data, 0),"inverse":container.program(5, data, 0),"data":data})) != null ? stack1 : "")
    + "\"\n    data-context-index=\""
    + ((stack1 = helpers["if"].call(alias3,(depth0 != null ? depth0.contextIndex : depth0),{"name":"if","hash":{},"fn":container.program(7, data, 0),"inverse":container.program(9, data, 0),"data":data})) != null ? stack1 : "")
    + "\"\n    "
    + ((stack1 = helpers["if"].call(alias3,(depth0 != null ? depth0.uid : depth0),{"name":"if","hash":{},"fn":container.program(11, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
    + "\n    data-scroll-page-item=\""
    + alias2(((helper = (helper = helpers.scrollPageItem || (depth0 != null ? depth0.scrollPageItem : depth0)) != null ? helper : alias4),(typeof helper === "function" ? helper.call(alias3,{"name":"scrollPageItem","hash":{},"data":data}) : helper)))
    + "\" draggable=\"true\"\n    data-interaction-context=\""
    + ((stack1 = helpers["if"].call(alias3,(depth0 != null ? depth0.index : depth0),{"name":"if","hash":{},"fn":container.program(3, data, 0),"inverse":container.program(5, data, 0),"data":data})) != null ? stack1 : "")
    + "\"\n    data-ta-id=\"tracklist-row\"\n    data-log-data='{\n      \"index\": "
    + ((stack1 = helpers["if"].call(alias3,(depth0 != null ? depth0.index : depth0),{"name":"if","hash":{},"fn":container.program(3, data, 0),"inverse":container.program(5, data, 0),"data":data})) != null ? stack1 : "")
    + ",\n      \"target_uri\": \""
    + alias2(alias1(((stack1 = (depth0 != null ? depth0.track : depth0)) != null ? stack1.uri : stack1), depth0))
    + "\",\n      \"name\": \""
    + alias2(alias1(((stack1 = (depth0 != null ? depth0.track : depth0)) != null ? stack1.name : stack1), depth0))
    + "\"\n    }'\n    data-contextmenu-spy\n    class=\"tl-row\n"
    + ((stack1 = helpers["if"].call(alias3,((stack1 = (depth0 != null ? depth0.track : depth0)) != null ? stack1.shouldBeOffline : stack1),{"name":"if","hash":{},"fn":container.program(13, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
    + "      "
    + ((stack1 = helpers["if"].call(alias3,((stack1 = (depth0 != null ? depth0.track : depth0)) != null ? stack1.playing : stack1),{"name":"if","hash":{},"fn":container.program(21, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
    + "\n      "
    + ((stack1 = helpers["if"].call(alias3,((stack1 = (depth0 != null ? depth0.track : depth0)) != null ? stack1.selected : stack1),{"name":"if","hash":{},"fn":container.program(23, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
    + "\n      "
    + ((stack1 = helpers["if"].call(alias3,((stack1 = (depth0 != null ? depth0.track : depth0)) != null ? stack1.added : stack1),{"name":"if","hash":{},"fn":container.program(25, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
    + "\n      "
    + ((stack1 = helpers["if"].call(alias3,((stack1 = (depth0 != null ? depth0.track : depth0)) != null ? stack1.unavailable : stack1),{"name":"if","hash":{},"fn":container.program(27, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
    + "\n      "
    + ((stack1 = helpers["if"].call(alias3,((stack1 = (depth0 != null ? depth0.track : depth0)) != null ? stack1.local : stack1),{"name":"if","hash":{},"fn":container.program(29, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
    + "\n      "
    + ((stack1 = helpers["if"].call(alias3,((stack1 = (depth0 != null ? depth0.track : depth0)) != null ? stack1.localFileAvailable : stack1),{"name":"if","hash":{},"fn":container.program(31, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
    + "\n      "
    + ((stack1 = helpers["if"].call(alias3,((stack1 = (depth0 != null ? depth0.track : depth0)) != null ? stack1.thumb : stack1),{"name":"if","hash":{},"fn":container.program(33, data, 0),"inverse":container.program(35, data, 0),"data":data})) != null ? stack1 : "")
    + "\n      "
    + ((stack1 = helpers["if"].call(alias3,((stack1 = (depth0 != null ? depth0.track : depth0)) != null ? stack1.isEpisode : stack1),{"name":"if","hash":{},"fn":container.program(37, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
    + "\n    \"\n    data-contextmenu>\n";
},"useData":true});

},{"hbsfy/runtime":429}],152:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template({"1":function(container,depth0,helpers,partials,data) {
    var stack1;

  return ((stack1 = helpers["if"].call(depth0 != null ? depth0 : {},((stack1 = (depth0 != null ? depth0.track : depth0)) != null ? stack1.added : stack1),{"name":"if","hash":{},"fn":container.program(2, data, 0),"inverse":container.program(4, data, 0),"data":data})) != null ? stack1 : "");
},"2":function(container,depth0,helpers,partials,data) {
    return "";
},"4":function(container,depth0,helpers,partials,data) {
    return "            disabled\n";
},"compiler":[7,">= 4.0.0"],"main":function(container,depth0,helpers,partials,data) {
    var stack1, alias1=depth0 != null ? depth0 : {}, alias2=helpers.helperMissing, alias3=container.escapeExpression;

  return "<td class=\"tl-cell tl-save\">\n  <button type=\"button\" data-button=\"add\"\n    class=\"button button-icon-only button-add\"\n"
    + ((stack1 = (helpers.compare || (depth0 && depth0.compare) || alias2).call(alias1,((stack1 = (depth0 != null ? depth0.track : depth0)) != null ? stack1.thumb : stack1),"down",{"name":"compare","hash":{},"fn":container.program(1, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
    + "    data-tooltip=\""
    + alias3((helpers.loc || (depth0 && depth0.loc) || alias2).call(alias1,"SaveYourMusic",{"name":"loc","hash":{},"data":data}))
    + "\"\n    data-tooltip-add=\""
    + alias3((helpers.loc || (depth0 && depth0.loc) || alias2).call(alias1,"SaveYourMusic",{"name":"loc","hash":{},"data":data}))
    + "\"\n    data-tooltip-remove=\""
    + alias3((helpers.loc || (depth0 && depth0.loc) || alias2).call(alias1,"RemoveYourMusic",{"name":"loc","hash":{},"data":data}))
    + "\"\n    data-log-click=\"save-button\"\n    data-interaction-target=\"save-remove-button\"\n    data-interaction-intent=\"save\"></button>\n</td>\n";
},"useData":true});

},{"hbsfy/runtime":429}],153:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template({"1":function(container,depth0,helpers,partials,data) {
    var helper, alias1=depth0 != null ? depth0 : {}, alias2=helpers.helperMissing, alias3="function", alias4=container.escapeExpression;

  return "data-insert=\""
    + alias4(((helper = (helper = helpers.insertTracks || (depth0 != null ? depth0.insertTracks : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"insertTracks","hash":{},"data":data}) : helper)))
    + "\"\ndata-remove=\""
    + alias4(((helper = (helper = helpers.removeTracks || (depth0 != null ? depth0.removeTracks : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"removeTracks","hash":{},"data":data}) : helper)))
    + "\"\n";
},"3":function(container,depth0,helpers,partials,data) {
    return "data-context=\"true\"\n";
},"5":function(container,depth0,helpers,partials,data) {
    return "data-list-quick-jump=\"true\"\n";
},"compiler":[7,">= 4.0.0"],"main":function(container,depth0,helpers,partials,data) {
    var stack1, helper, options, alias1=depth0 != null ? depth0 : {}, alias2=helpers.helperMissing, alias3="function", alias4=helpers.blockHelperMissing, buffer = 
  "data-uri=\""
    + container.escapeExpression(((helper = (helper = helpers.uri || (depth0 != null ? depth0.uri : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"uri","hash":{},"data":data}) : helper)))
    + "\"\ndata-list=\"true\"\n";
  stack1 = ((helper = (helper = helpers.allows || (depth0 != null ? depth0.allows : depth0)) != null ? helper : alias2),(options={"name":"allows","hash":{},"fn":container.program(1, data, 0),"inverse":container.noop,"data":data}),(typeof helper === alias3 ? helper.call(alias1,options) : helper));
  if (!helpers.allows) { stack1 = alias4.call(depth0,stack1,options)}
  if (stack1 != null) { buffer += stack1; }
  stack1 = ((helper = (helper = helpers.noContext || (depth0 != null ? depth0.noContext : depth0)) != null ? helper : alias2),(options={"name":"noContext","hash":{},"fn":container.noop,"inverse":container.program(3, data, 0),"data":data}),(typeof helper === alias3 ? helper.call(alias1,options) : helper));
  if (!helpers.noContext) { stack1 = alias4.call(depth0,stack1,options)}
  if (stack1 != null) { buffer += stack1; }
  return buffer + ((stack1 = helpers["if"].call(alias1,(depth0 != null ? depth0.quickJump : depth0),{"name":"if","hash":{},"fn":container.program(5, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
    + "data-interaction-context=\"tracklist\"\ndata-ta-id=\"tracklist\"\n";
},"useData":true});

},{"hbsfy/runtime":429}],154:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template({"compiler":[7,">= 4.0.0"],"main":function(container,depth0,helpers,partials,data) {
    return "data-list-items=\"true\"\ndata-scroll-container\n";
},"useData":true});

},{"hbsfy/runtime":429}],155:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template({"compiler":[7,">= 4.0.0"],"main":function(container,depth0,helpers,partials,data) {
    var stack1;

  return "<td class=\"tl-cell tl-time\" data-log-context=\"time-cell\">\n  <span data-log-click=\"duration\">"
    + container.escapeExpression((helpers.duration || (depth0 && depth0.duration) || helpers.helperMissing).call(depth0 != null ? depth0 : {},((stack1 = (depth0 != null ? depth0.track : depth0)) != null ? stack1.duration : stack1),{"name":"duration","hash":{},"data":data}))
    + "</span>\n</td>\n";
},"useData":true});

},{"hbsfy/runtime":429}],156:[function(require,module,exports){
'use strict';

const base = 'spotify:internal:filterlist';
const regExp = /^spotify:internal:filterlist:([^:]*):(.*)$/;

/**
 * Create a URI representing a filtered variant of a list.
 *
 * @param {string} originUri The original list URI.
 * @param {string} query The query string (compatible with Core). Filter
 *     implementations might not look at all values.
 *
 * @return {string} URI of the filtered variant of the list. The URI will have
 *     the query string URL encoded.
 */
exports.create = function (originUri, query) {
  const newOriginUri = originUri.replace(/^spotify:/, '');

  const newQuery = encodeURIComponent(query);

  return [base, newQuery, newOriginUri].join(':');
};

/**
 * Get the query string from a filter URI.
 *
 * @param {string} filterUri The URI of the filtered list.
 *
 * @return {string} The query string, URL decoded. If URI is
 *     invalid, this returns an empty string.
 */
exports.getQuery = function (filterUri) {
  const matches = filterUri.match(regExp);
  if (!matches) return '';

  return decodeURIComponent(matches[1]);
};

/**
 * Get the URI of the original list.
 *
 * @param {string} filterUri The URI of the filtered list.
 *
 * @return {string} The URI of the original list. If the filter URI is invalid,
 *     this returns an empty string.
 */
exports.getOriginUri = function (filterUri) {
  const matches = filterUri.match(regExp);
  if (!matches) return '';

  return `spotify:${matches[2]}`;
};

/**
 * Parse and return all parts of the filter URI.
 *
 * @param {string} filterUri The URI of the filtered list.
 *
 * @return {Object?} An object with properties `direction`, `query` and `originUri`,
 *     or null if the URI is not valid.
 */
exports.parse = function (filterUri) {
  const matches = filterUri.match(regExp);
  if (!matches) return null;

  return {
    query: decodeURIComponent(matches[1]),
    originUri: `spotify:${matches[2]}`
  };
};

/**
 * Test if the provided URI is a valid filter URI.
 *
 * @param {string} filterUri The URI of the filtered list.
 *
 * @return {boolean} True if it's valid, false otherwise.
 */
exports.isValid = function (filterUri) {
  return regExp.test(filterUri);
};

/**
 * The regular expression that matches filter URIs.
 */
exports.regExp = regExp;

},{}],157:[function(require,module,exports){
'use strict';

const Range = require('../range2');

/**
 * Get the needed operations for inserting items at a specific index.
 *
 * @param {Array} items Array of items to insert.
 * @param {number} index Index to insert the items at, relative to the list
 *     before the operations.
 *
 * @return {Array.<Object>} Array of operation objects.
 */
function getInsertOperations(items, index) {
  return [{ type: 'insert', index: index, values: items }];
}

/**
 * Get the needed operations for removing items from the specified indices.
 *
 * @param {Array.<number>} indices Array of indices relative to the list before
 *     the operations.
 *
 * @return {Array.<Object>} Array of operation objects.
 */
function getRemoveOperations(indices) {
  const ranges = Range.fromIndices(indices);

  let removed = 0;
  const operations = [];

  for (let r = 0, range; ranges[r]; r++) {
    range = ranges[r];
    operations.push({
      type: 'remove',
      index: range.start - removed,
      length: range.length
    });
    removed += range.length;
  }

  return operations;
}

/**
 * Get the needed operations for moving items from a set of indices to a
 * target index.
 *
 * @param {Array.<number>} fromIndices Array of indices relative to the list
 *     before the operations.
 * @param {number} toIndex Index to move the items to, relative to the list
 *     before the operations.
 *
 * @return {Array.<Object>} Array of operation objects.
 */
function getMoveOperations(fromIndices, toIndex) {
  // We're going through one range at a time, and when a range is moved down,
  // we need to decrease the start of the next range to account for the
  // range we moved down (since each operation is based on the result of
  // the previous operation).
  let movedAbove = 0;

  // The maximum index starts at the index we want to move to.
  // When operations are created to move ranges, this maximum index
  // is increased to always point to the bottom index of the moved
  // items. If five items are moved from far down up to the 'to' index,
  // the new maxIndex will be toIndex + 5.
  let maxIndex = toIndex;

  const ranges = Range.fromIndices(fromIndices);
  let r;
  let range;
  let toRange;

  // Find any range that intersects with the 'to' index. Referred below as
  // the 'to' range. This range can't be split, so we need to move items to
  // positions above or below this range if it exists.
  for (r = 0; ranges[r]; r++) {
    range = ranges[r];
    if (range.start <= toIndex && range.end >= toIndex) {
      toRange = range;
      break;
    }
  }

  const operations = [];

  for (r = 0; ranges[r]; r++) {
    range = ranges[r];
    const length = range.length;
    let to;
    let from = range.start - movedAbove;

    // If the 'to' index is inside a range
    if (toRange) {
      // Range is above the 'to' range, so move it to right above that range.
      if (range.end < toRange.start) {
        from = range.start - movedAbove;
        to = toRange.start - length;
        movedAbove += length;

        // Range is the 'to' range, which means it will not move anywhere.
      } else if (range === toRange) {
        maxIndex = Math.max(maxIndex, range.end);
        continue;

        // Range is below the 'to' range, so move it to the maximum index
        // we've reached so far.
      } else {
        from = range.start;
        to = maxIndex;
        maxIndex = Math.max(maxIndex, to + length);
      }
      // If the 'to' index is not inside a range
    } else {
      // Range is above the 'to' index, so move it to right above the maximum index.
      if (range.end < toIndex) {
        from = range.start - movedAbove;
        to = maxIndex - length;
        movedAbove += length;

        // Range is below the 'to' index, so move it to the maximum index we've
        // reached so far.
      } else {
        from = range.start;
        to = maxIndex;
        maxIndex = Math.max(maxIndex, to + length);
      }
    }

    operations.push({ type: 'move', from: from, length: length, to: to });
  }

  return operations;
}

exports.getInsertOperations = getInsertOperations;
exports.getRemoveOperations = getRemoveOperations;
exports.getMoveOperations = getMoveOperations;

},{"../range2":245}],158:[function(require,module,exports){
(function (global){
'use strict';

const live = require('../../live');
const cosmos = require('../util/cosmos');
const Collection = require('./collection');

const endpoints = {
  isInCollection: 'sp://core-collection/v1/contains',
  updateIsInCollection: 'sp://core-collection/v1/items',
  changes: 'hm://collection-web/v1/@/changes',
  broadcast: 'sp://messages/v1/collectionstate',
  pubsub: 'hm://collection/collection/@/json'
};

const onCollectionPublish = function (error, response) {
  if (error) {
    if (global.console) console.error(error);
    return;
  }

  // Currently, we only store tracks in collection2, and derive albums from
  // these. Because of this, we only get tracks in the pubsub events, but
  // adding/removing a track might have altered the calculated Collection state
  // of its album. To check this, we pass the change set down to
  // the changes endpoint and will receive a list of objects with
  // uri and isInCollection properties that we can forward to live.
  cosmos.sanitizeURL(endpoints.changes, function (sanitizeError, url) {
    if (sanitizeError) {
      if (global.console) console.error(sanitizeError);
      return;
    }

    // FIXME: Hack alert
    // Because of enum weirdness in Java, we need to
    // uppercase the value in the type field.
    // Remove this map once FESK-1921 is fixed.
    response.body.items = response.body.items.map(function (item) {
      item.type = item.type.toUpperCase();
      return item;
    });
    // End hack alert

    cosmos.post({ url: url, body: response.body }, function (cosmosError, cosmosResponse) {
      if (cosmosError) {
        if (global.console) console.error(cosmosError);
        return;
      }
      cosmosResponse.body.items.forEach(function (item) {
        if (item.hasOwnProperty('isInCollection') && !item.hasOwnProperty('added')) {
          // Patch items to contain added
          item.added = item.isInCollection;
        }
      });
      live(cosmosResponse.body.items);
    });
  });
};

let albumCollection;
let broadcastSubscription;
let collectionSubscription;

const regExp = exports.matches = /^spotify:album:[^:]+$/;
let registered = false;
exports.register = function () {
  if (registered) return;
  registered = true;

  albumCollection = new Collection(endpoints);

  live.subscribe(regExp, 'publish', albumCollection.onPublish);
  live.subscribe(regExp, 'wait', albumCollection.onWait);

  broadcastSubscription = cosmos.subscribe({ url: endpoints.broadcast }, Collection.onBroadcast);
  collectionSubscription = cosmos.subscribe({ url: endpoints.pubsub }, onCollectionPublish);
};

exports.unregister = function () {
  if (!registered) return;
  registered = false;

  live.unsubscribe(regExp, 'publish', albumCollection.onPublish);
  live.unsubscribe(regExp, 'wait', albumCollection.onWait);

  albumCollection = null;

  if (broadcastSubscription) {
    broadcastSubscription.cancel();
    broadcastSubscription = null;
  }

  if (collectionSubscription) {
    collectionSubscription.cancel();
    collectionSubscription = null;
  }
};

exports._endpoints = endpoints;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../live":210,"../util/cosmos":206,"./collection":160}],159:[function(require,module,exports){
'use strict';

const profile = require('./profile');

const regExp = exports.matches = /^spotify:artist:/;
let registered;
exports.register = function () {
  if (registered) return;
  registered = true;

  profile.register(regExp);
};

exports.unregister = function () {
  if (!registered) return;
  registered = false;

  profile.unregister(regExp);
};

},{"./profile":164}],160:[function(require,module,exports){
(function (global){
'use strict';

// This model will take a URI and create a live model for that URI.
//
//
// It will listen for publish events on the live model. The publish
// events are only triggered when someone actually wants to update
// something on the backend.
// When a publish event is detected, it will:
//
// * If the changed property was "added", it will contact
//   the backend to update the stored collection state. If this
//   fails, it will set it to the opposite of what was pusblished.
//
// * On success, broadcast the changes to the rest of the client via
//   cosmos, as "isInCollection" / "isFollowing" and as "added".
//
// This model will also listen for update events on the live model.
// The update event will be triggered when someone changes the data
// on the live model, without an intention to update the backend.
// When an update event is detected, it will:
//
// This model will also listen for broadcast events from the rest
// of the client. When a broadcast event is received, this happens:
//
// * If the URI for the broadcast message does not match this model,
//   do nothing.
//
// * It will then update the live model with the data it received
//   from the broadcast event. This will trigger the update listener
//   described above, but it won't run the code because all properties
//   are there.

const prime = require('../../../libs/prime');
const defer = require('../../../libs/prime/defer');

const live = require('../../live');
const contains = require('mout/array/contains');

const cosmos = require('../util/cosmos');

const INSUFFICIENT_STORAGE = 507;

// COLLECTION

const Collection = prime({
  constructor: function (endpoints) {
    this.endpoints = endpoints;
    this.onPublish = this.onPublish.bind(this);
    this.waitQueue = [];
    this.onWait = this.onWait.bind(this);
    this.fetch = this.fetch.bind(this);
  },

  onPublish: function (model, data) {
    // If the property is "added", update the backend with the new value
    // If the update fails, revert the state
    // If the update does not fail, broadcast the new state, as "isInCollection" and "added"
    if ('added' in data) {
      const endpoints = this.endpoints;
      const state = !!data.added;

      // optimistic
      model.update({ added: state });

      const method = state ? 'post' : 'delete';
      this._publish(method, [model], function (error, publishData) {
        if (error) {
          // that's what being optimistic gets you
          model.update({ added: !state });
          if (error.response && error.response.getStatusCode() === INSUFFICIENT_STORAGE) {
            cosmos.post({
              url: 'sp://messages/v1/container/user-message',
              body: { id: 'collection-limit-exceeded' }
            });
          }
        } else {
          cosmos.post({ url: endpoints.broadcast, body: { uri: model.uri, isInCollection: state, added: state } });
          if (publishData && publishData.items) {
            publishData.items.forEach(function (item) {
              // Patch items to contain added
              item.added = item.isInCollection;
              cosmos.post({ url: endpoints.broadcast, body: item });
            });
          }
        }
      });
    }
  },

  onWait: function (model, properties) {
    if (contains(properties, 'added')) {
      this.fetch(model);
    }
  },

  fetch: function (model) {
    const queue = this.waitQueue;

    queue.push(model);

    // The first thing that gets added to the queue should defer a batch fetch
    // for the next tick. On the next tick, it will batch fetch status for all
    // models added to the queue.
    if (queue.length === 1) {
      defer.immediate(this._fetchBatch, this);
    }
  },

  _fetchBatch: function () {
    const queue = this.waitQueue;
    if (queue.length === 0) return;

    // Create a new queue for requests coming after this
    this.waitQueue = [];

    this._contains(queue, function (error, result) {
      // Collection returns 404 for a user without a collection. This is sent as an error,
      // but we will just interpret that as `isInCollection` is false. All other errors
      // we just throw.
      if (error && (!error.response || error.response && error.response.getStatusCode() !== 404)) {
        if (global.console) console.error(error);
        return;
      }

      queue.forEach(function (model, i) {
        let added = false;
        if (!error) added = result[i];
        model.update({ added: added });
      });
    });
  },

  _contains: function (models, callback) {
    const url = this.endpoints.isInCollection;
    const body = this._getRequestBody(models);

    cosmos.post({ url: url, body: body }, function (error, result) {
      callback(error, result && result.body && result.body.found);
    });
  },

  _publish: function (method, models, callback) {
    const url = this.endpoints.updateIsInCollection;
    const body = this._getRequestBody(models);

    cosmos[method]({ url: url, body: body }, function (error, result) {
      callback(error, result && result.body);
    });
  },

  _getRequestBody: function (models) {
    return {
      items: models.map(function (model) {
        return model.uri;
      }),
      source: global.__spotify && global.__spotify.app_uri || null
    };
  }
});

// ----------------------

Collection.onBroadcast = function (error, response) {
  if (error) {
    if (global.console) console.error(error);
    return;
  }

  let value;
  if ('added' in response.body) value = response.body.added;else if ('isInCollection' in response.body) {
    // Deal with older versions of this package that send isInCollection / isFollowing
    value = response.body.isInCollection;
  }

  live(response.body.uri).update({
    added: value
  });
};

module.exports = Collection;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../../libs/prime":243,"../../../libs/prime/defer":241,"../../live":210,"../util/cosmos":206,"mout/array/contains":443}],161:[function(require,module,exports){
'use strict';

const album = require('./album');
const artist = require('./artist');
const playlist = require('./playlist');
const track = require('./track');
const user = require('./user');
const local = require('./local');
const show = require('./show');

exports.register = function () {
  album.register();
  artist.register();
  playlist.register();
  track.register();
  user.register();
  local.register();
  show.register();
};

exports.unregister = function () {
  album.unregister();
  artist.unregister();
  playlist.unregister();
  track.unregister();
  user.unregister();
  local.unregister();
  show.unregister();
};

},{"./album":158,"./artist":159,"./local":162,"./playlist":163,"./show":165,"./track":166,"./user":167}],162:[function(require,module,exports){
'use strict';

const live = require('../../live');
const contains = require('mout/array/contains');

const onWait = function (model, properties) {
  if (contains(properties, 'added')) {
    // Neither tracks nor albums or artists can ever be added to YM.
    model.update({ added: false });
  }
};

// Matches local track, albums and artists.
const regExp = exports.matches = /^spotify:local:[^:]*:[^:]*:[^:]*:\d*$|^spotify:local:[^:]*:[^:]*$|^spotify:local:[^:]*$/;
let registered = false;
exports.register = function () {
  if (registered) return;
  registered = true;

  live.subscribe(regExp, 'wait', onWait);
};

exports.unregister = function () {
  if (!registered) return;
  registered = false;

  live.unsubscribe(regExp, 'wait', onWait);
};

},{"../../live":210,"mout/array/contains":443}],163:[function(require,module,exports){
(function (global){
'use strict';

// The 'playlist' function will be called when a new live object is
// created for the pattern in playlist.matches. We use this function
// to automatically add data to the live model when requested, and to
// push any needed updates to the backend.
//
//
// It will listen for publish events on the live model. The publish
// events are only triggered when someone actually wants to update
// something on the backend.
// When a publish event is detected, it will:
//
// * Broadcast the changes to the rest of the client via cosmos.
//
// * If the changed property was `added`, it will contact
//   the backend to update the stored collection state for the
//   currently logged in user. If this fails, it will revert the
//   state for the live model and broadcast the reverted state.
//
// This function will also listen for update events on the live model.
// The update event will be triggered when someone changes the data
// on the live model, without an intention to update the backend.
// When an update event is detected, it will:
//
// This function will also listen for broadcast events from the rest
// of the client. When a broadcast event is received, this happens:
//
// * If the URI for the broadcast message does not match this model,
//   do nothing.
//
// * It will then update the live model with the data it received
//   from the broadcast event. This will trigger the update listener
//   described above, but it won't run the code because all properties
//   are there.

const contains = require('mout/array/contains');

const live = require('../../live');
const liburi = require('spotify-liburi');

const cosmos = require('../util/cosmos');
const bridge = require('../util/bridge').request;

const endpoints = {
  broadcast: 'sp://messages/v1/followstate'
};

function onPublish(model, data) {
  // If the property is "added", update the backend with the new
  // value. If the update fails somewhere along the way, revert the state
  // and broadcast the reverted state to the rest of the client.
  if ('added' in data) {
    model.update({ added: data.added });

    if (model.get('followersCount') !== null) {
      model.update({
        followersCount: model.get('followersCount') + (data.added ? 1 : -1)
      });
    }

    updateBackend(model, !!data.added, function (error) {
      if (error) {
        // Revert optimistic change
        model.update({ added: !data.added });

        if (model.get('followersCount') !== null) {
          model.update({
            followersCount: model.get('followersCount') + (!data.added ? 1 : -1)
          });
        }
      } else {
        broadcast(model);
      }
    });
  }
}

function onBroadcast(error, response) {
  if (error) {
    if (global.console) console.error(error);
    return;
  }
  let value;
  if ('added' in response.body) {
    value = response.body.added;
  } else if ('isFollowing' in response.body) {
    value = response.body.isFollowing;
  }

  if (value !== undefined) {
    live(response.body.uri).update({
      added: value
    });
  }
}

function fetchAdded(model) {
  cosmos.get({
    url: `sp://core-playlist/v1/playlist/${encodeURIComponent(model.uri)}/metadata`,
    body: {
      policy: {
        followed: true
      }
    }
  }, function (error, response) {
    if (error) {
      if (global.console) console.error(error);
      return;
    }
    model.update({
      added: response.body.metadata.followed
    });
  });
}

function fetchFollowersCount(model) {
  cosmos.get({
    url: `sp://core-playlist/v1/playlist/${encodeURIComponent(model.uri)}/metadata`,
    body: {
      policy: {
        followers: true
      }
    }
  }, function (error, response) {
    if (error) {
      if (global.console) console.error(error);
      return;
    }
    model.update({
      followersCount: response.body.metadata.followers
    });
  });
}

function broadcast(model) {
  const value = model.get('added');
  cosmos.post({
    url: endpoints.broadcast,
    body: {
      uri: model.uri,
      isFollowing: value,
      added: value
    }
  });
}

function updateBackend(model, added, callback) {
  if (added) {
    cosmos.post({
      url: 'sp://core-playlist/v1/rootlist',
      body: {
        operation: 'add',
        uris: [model.uri],
        before: 'start'
      }
    }, function (error) {
      if (error) {
        callback(error);
      } else {
        model.update({
          added: true
        });
        callback(null);
      }
    });
  } else {
    // Removing using Core needs the `rowId`, which we don't necessarily have,
    // so stick with old bridge message for now. It's only adding that needs to
    // be done using Core to fix KM-8804.
    bridge('library_unsubscribe', [liburi.profileURI(__spotify.username).toURI(), model.uri], function (error, data) {
      if (error) {
        callback(error, data);
      } else {
        callback(null, data);
      }
    });
  }
}

const onWait = function (model, properties) {
  const needsAdded = contains(properties, 'added');
  const needsFollowersCount = contains(properties, 'followersCount');
  if (needsAdded) {
    const subscribed = model.get('subscribed');
    if (subscribed !== undefined) {
      model.update({ added: subscribed });
    } else {
      fetchAdded(model);
    }
  }
  if (needsFollowersCount) {
    fetchFollowersCount(model);
  }
};

const regExp = exports.matches = /^spotify:user:[^:]+:playlist:[^:]+$/;

let broadcastSubscription;
let registered;
exports.register = function () {
  if (registered) return;
  registered = true;

  live.subscribe(regExp, 'publish', onPublish);
  live.subscribe(regExp, 'wait', onWait);
  broadcastSubscription = cosmos.subscribe({ url: endpoints.broadcast }, onBroadcast);
};

exports.unregister = function () {
  if (!registered) return;
  registered = false;

  live.unsubscribe(regExp, 'publish', onPublish);
  live.unsubscribe(regExp, 'wait', onWait);

  broadcastSubscription.cancel();
  broadcastSubscription = null;
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../live":210,"../util/bridge":204,"../util/cosmos":206,"mout/array/contains":443,"spotify-liburi":730}],164:[function(require,module,exports){
(function (global){
'use strict';

// This model will, when registered to live, listen for publish
// events on the live model. The publish events are only triggered
// when someone actually wants to update something on the backend.
// When a publish event is detected, it will:
//
// * Broadcast the changes to the rest of the client via cosmos.
//
// * If the changed property was isFollowing, it will contact
//   the backend to update the stored following state for the
//   currently logged in user. If this fails, it will revert the
//   state for the live model and broadcast the reverted state.
//
// This function will also listen for update events on the live model.
// The update event will be triggered when someone changes the data
// on the live model, without an intention to update the backend.
// When an update event is detected, it will:
//
// * If the changed property was isFollowing, it will automatically
//   update followersCount on the live model.
//
// This function will also listen for broadcast events from the rest
// of the client. When a broadcast event is received, this happens:
//
// * If the URI for the broadcast message does not match this model,
//   do nothing.
//
// * It will then update the live model with the data it received
//   from the broadcast event. This will trigger the update listener
//   described above, but it won't run the code because all properties
//   are there.
//

const intersection = require('mout/array/intersection');
const live = require('../../live');
const cosmos = require('../util/cosmos');
let requestsInProgress = {};

const endpoints = {
  isFollowing: 'hm://socialgraph/v2/is_following?format=json',
  followCounts: 'hm://socialgraph/v2/counts?format=json',
  updateIsFollowing: 'hm://socialgraph/v2/following?format=json',
  broadcast: 'sp://messages/v1/followstate'
};

function onUpdate(model, data) {
  // Only update followers count if that data was not present in the changed data
  if ('added' in data && !('followersCount' in data)) {
    const followersCount = model.get('followersCount');
    if (followersCount !== undefined) {
      const newFollowersCount = followersCount + (data.added ? 1 : -1);
      model.update({ followersCount: newFollowersCount });
    }
  }
}

function onPublish(model, data) {
  // If the property is added, update the backend with the new value.
  // If the update fails, revert the model state.
  // If the update is successful, broadcast the state to the client.
  if ('added' in data) {
    // if there is a request in course, do not launch a new request
    // as this can mess up with the Backend
    if (requestsInProgress[model.uri]) {
      return;
    }
    requestsInProgress[model.uri] = true;

    // we're optimistic this will work
    model.update({ added: data.added });

    updateBackend(model, !!data.added, function (error) {
      // request finished, we can accept more requests now
      delete requestsInProgress[model.uri];
      if (error) {
        // such is life.
        model.update({ added: !data.added });
      } else {
        model.update({ added: data.added });
        broadcast(model);
      }
    });
  }
}

function onBroadcast(error, response) {
  if (error) {
    if (global.console) console.error(error);
    return;
  }

  const body = response.body;
  const data = {};

  if ('added' in body) data.added = body.added;else if ('isFollowing' in body) {
    // Also accept broadcast from older versions that only send "isFollowing"
    data.added = body.isFollowing;
  }

  if ('followersCount' in body) data.followersCount = body.followersCount;
  if ('followingCount' in body) data.followingCount = body.followingCount;

  live(body.uri).update(data);
}

const followProperties = ['added', 'followersCount', 'followingCount'];

function onWait(model, properties) {
  if (intersection(properties, followProperties).length) {
    getRequestData(model, function (error, data) {
      if (error) {
        if (global.console) console.error(error);
        return;
      }
      updateIsFollowing(model, data);
      updateCounts(model, data);
    });
  }
}

function updateIsFollowing(model, requestData, callback) {
  const options = {
    url: endpoints.isFollowing,
    body: requestData
  };
  cosmos.get(options, function (error, response) {
    if (error) {
      if (global.console) console.error(error);
      if (callback) {
        callback(error);
      }
    } else {
      const value = response.body[0].is_following;
      model.update({ added: value });

      if (callback) callback();
    }
  });
}

function updateCounts(model, requestData, callback) {
  const options = {
    url: endpoints.followCounts,
    body: requestData
  };
  cosmos.get(options, function (error, response) {
    if (error) {
      if (global.console) console.error(error);
      if (callback) {
        callback(error);
      }
    } else {
      const body = response.body[0];

      model.update({
        followersCount: body.followers_count,
        followingCount: body.following_count
      });

      if (callback) callback();
    }
  });
}

function getRequestData(model, callback) {
  // Assumes that the client live object either already has the data about the current user,
  // or that there is code included for getting this data on request.
  live('spotify:client').query('currentUser(uri)', function (error, data) {
    if (error) {
      callback(error);
    } else {
      callback(null, {
        // Social graph v2 expects decoded uris (i.e. spotify:user:someone!
        // rather than spotify:user:someone%21). `currentUser(uri)` returns a
        // uri-encoded user name.
        source_uri: decodeURIComponent(data.currentUser.uri),
        target_uris: [decodeURIComponent(model.uri)]
      });
    }
  });
}

function updateBackend(model, isFollowing, callback) {
  getRequestData(model, function (error, data) {
    if (error) {
      callback(error);
    } else {
      const requestMethod = isFollowing ? 'post' : 'delete';
      cosmos[requestMethod]({ url: endpoints.updateIsFollowing, body: data }, function (cosmosError) {
        if (cosmosError) {
          callback(cosmosError);
        } else {
          callback(null);
        }
      });
    }
  });
}

function broadcast(model) {
  const added = model.get('added');
  cosmos.post({
    url: endpoints.broadcast,
    body: {
      uri: model.uri,
      isFollowing: added,
      added: added,
      followersCount: model.get('followersCount'),
      followingCount: model.get('followingCount')
    }
  });
}

let broadcastSubscription;

exports.register = function (regExp) {
  live.subscribe(regExp, 'wait', onWait);
  live.subscribe(regExp, 'update', onUpdate);
  live.subscribe(regExp, 'publish', onPublish);

  // reset the requestsInProgress variable
  requestsInProgress = {};

  if (!broadcastSubscription) {
    broadcastSubscription = cosmos.subscribe({ url: endpoints.broadcast }, onBroadcast);
  }
};

exports.unregister = function (regExp) {
  live.unsubscribe(regExp, 'wait', onWait);
  live.unsubscribe(regExp, 'update', onUpdate);
  live.unsubscribe(regExp, 'publish', onPublish);

  if (broadcastSubscription) {
    broadcastSubscription.cancel();
    broadcastSubscription = null;
  }
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../live":210,"../util/cosmos":206,"mout/array/intersection":450}],165:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.register = register;
exports.unregister = unregister;

var _live = require('../../live');

var _live2 = _interopRequireDefault(_live);

var _collection = require('./collection');

var _collection2 = _interopRequireDefault(_collection);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const regExp = /^spotify:show:[^:]+$/;
let showCollection;
let registered = false;

function register() {
  if (registered) return;
  registered = true;

  showCollection = new _collection2.default({
    isInCollection: 'sp://core-collection/v1/contains',
    updateIsInCollection: 'sp://core-collection/v1/items',
    broadcast: 'sp://messages/v1/collectionstate',
    pubsub: 'hm://collection/collection/@/json'
  });

  _live2.default.subscribe(regExp, 'publish', showCollection.onPublish);
  _live2.default.subscribe(regExp, 'wait', showCollection.onWait);
}

function unregister() {
  if (!registered) return;
  registered = false;

  _live2.default.unsubscribe(regExp, 'publish', showCollection.onPublish);
  _live2.default.unsubscribe(regExp, 'wait', showCollection.onWait);
}

},{"../../live":210,"./collection":160}],166:[function(require,module,exports){
(function (global){
'use strict';

const live = require('../../live');
const cosmos = require('../util/cosmos');
const Collection = require('./collection');

const endpoints = {
  isInCollection: 'sp://core-collection/v1/contains',
  updateIsInCollection: 'sp://core-collection/v1/items',
  broadcast: 'sp://messages/v1/collectionstate',
  pubsub: 'hm://collection/collection/@/json'
};

const onCollectionPublish = function (error, response) {
  if (error) {
    if (global.console) console.error(error);
    return;
  }

  const items = response.body.items;
  items.forEach(function (item) {
    // FIXME: Hack alert
    // Because of enum weirdness in Java, we need to
    // uppercase the value in the type field.
    // Remove this once FESK-1921 is fixed.
    if (item.type.toUpperCase() === 'TRACK') {
      const uri = `spotify:track:${item.identifier}`;
      live(uri).update({ added: !item.removed });
    }
  });
};

let trackCollection;
let broadcastSubscription;
let collectionSubscription;

const regExp = exports.matches = /^spotify:track:[^:]+$/;
let registered = false;
exports.register = function () {
  if (registered) return;
  registered = true;

  trackCollection = new Collection(endpoints);

  live.subscribe(regExp, 'publish', trackCollection.onPublish);
  live.subscribe(regExp, 'wait', trackCollection.onWait);

  broadcastSubscription = cosmos.subscribe({ url: endpoints.broadcast }, Collection.onBroadcast);
  collectionSubscription = cosmos.subscribe({ url: endpoints.pubsub }, onCollectionPublish);
};

exports.unregister = function () {
  if (!registered) return;
  registered = false;

  live.unsubscribe(regExp, 'publish', trackCollection.onPublish);
  live.unsubscribe(regExp, 'wait', trackCollection.onWait);

  trackCollection = null;

  if (broadcastSubscription) {
    broadcastSubscription.cancel();
    broadcastSubscription = null;
  }

  if (collectionSubscription) {
    collectionSubscription.cancel();
    collectionSubscription = null;
  }
};

exports._endpoints = endpoints;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../live":210,"../util/cosmos":206,"./collection":160}],167:[function(require,module,exports){
'use strict';

const profile = require('./profile');

const regExp = exports.matches = /^spotify:user:[^:]+$/;
let registered;
exports.register = function () {
  if (registered) return;
  registered = true;

  profile.register(regExp);
};

exports.unregister = function () {
  if (!registered) return;
  registered = false;

  profile.unregister(regExp);
};

},{"./profile":164}],168:[function(require,module,exports){
(function (global){
/**
 * @module live-models/album
 */
'use strict';

const live = require('../live');

const liburi = require('spotify-liburi');

const intersection = require('mout/array/intersection');
const contains = require('mout/array/contains');
const mixIn = require('mout/object/mixIn');

const bridge = require('./util/bridge').request;

function isLocalAlbum(uri) {
  return liburi.from(uri).type === liburi.Type.LOCAL_ALBUM;
}

function isLocalArtist(uri) {
  return liburi.from(uri).type === liburi.Type.LOCAL_ARTIST;
}

function updateMetadata(model) {
  if (isLocalAlbum(model.uri)) {
    const uriObject = liburi.from(model.uri);
    if (uriObject) {
      const data = {
        local: true,
        name: uriObject.album,
        artists: [{
          uri: 'spotify:local:',
          name: '',
          local: true
        }]
      };
      if (uriObject.artist) {
        data.artists[0].uri = liburi.localArtistURI(uriObject.artist).toURI();
        data.artists[0].name = uriObject.artist;
        data.artists[0].local = true;
      }
      model.update(data);
    }
  } else {
    bridge('album_metadata', [model.uri], function (error, payload) {
      if (error) {
        if (global.console) console.error(error);
        return;
      }
      model.update(payload);
    });
  }
}

function updateLocal(model) {
  model.update({
    local: isLocalAlbum(model.uri)
  });
}

let idCounter = 1000;

function getRowUri(trackUri) {
  return trackUri.replace('spotify:', `spotify:row:${(++idCounter).toString(36)}:`);
}

function updateRows(model) {
  const descriptor = { type: 'list', uri: model.uri };

  bridge('album_tracks_snapshot', [descriptor, 0, 0, false], function (error, payload) {
    if (error) {
      if (global.console) console.error(error);
      return;
    }

    bridge('album_tracks_snapshot', [descriptor, 0, payload.length, false], function (bridgeError, bridgePayload) {
      if (bridgeError) {
        if (global.console) console.error(bridgeError);
      } else {
        const discs = [];
        const uriId = liburi.from(model.uri).id;

        const rows = bridgePayload.metadata && bridgePayload.metadata.map(function (trackdata, i) {
          const track = mixIn({ uri: bridgePayload.array[i] }, trackdata);
          const discNum = track.disc ? track.disc - 1 : 0;
          track.unavailable = !track.playable;
          setLocalProperty(track);
          if (!discs[discNum]) {
            discs[discNum] = {
              rows: [],
              uri: uriId ? liburi.albumURI(uriId, discNum + 1).toURI() : ''
            };
          }
          const uri = getRowUri(track.uri);
          const trackObject = {
            track: track,
            uri: uri
          };
          discs[discNum].rows.push(trackObject);
          return trackObject;
        });

        model.update({ rows: rows, discs: discs });
      }
    });
  });
}

function setLocalProperty(track) {
  if (track.album && track.album.uri) {
    track.album.local = isLocalAlbum(track.album.uri);
  }
  if (track.artists) {
    for (let i = 0, l = track.artists.length; i < l; i++) {
      const artist = track.artists[i];
      if (artist.uri) {
        artist.local = isLocalArtist(artist.uri);
      }
    }
  }
}

function onWait(model, properties) {
  const hasLocal = contains(properties, 'local');
  const hasRows = contains(properties, 'rows');
  const hasDiscs = contains(properties, 'discs');

  const metaFields = ['artists', 'image', 'images', 'name', 'playable', 'type', 'availability', 'date', 'label', 'copyrights'];

  const hasMetadata = !!intersection(properties, metaFields).length;

  if (hasMetadata) updateMetadata(model);
  if (hasRows || hasDiscs) updateRows(model);
  if (hasLocal) updateLocal(model);
}

const regExp = exports.matches = /^spotify:album:[0-9a-zA-Z]+$|^spotify:local:[^:]*:[^:]*$/;
let registered;
exports.register = function () {
  if (registered) return;
  registered = true;

  live.subscribe(regExp, 'wait', onWait);
};

exports.unregister = function () {
  if (!registered) return;
  registered = false;

  live.unsubscribe(regExp, 'wait', onWait);
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../live":210,"./util/bridge":204,"mout/array/contains":443,"mout/array/intersection":450,"mout/object/mixIn":480,"spotify-liburi":730}],169:[function(require,module,exports){
(function (global){
/**
 * @module live-models/application
 */
'use strict';

const live = require('../live');
const bridge = require('./util/bridge').request;
const AppState = require('../navigation/app-state');

function onMessage(message) {
  if (message.data && message.data.name) {
    if (message.data.name === 'set_active') {
      live('spotify:application').update({
        active: message.data.active
      });
    } else if (message.data.name === 'set_arguments') {
      // Arguments come as an array of un-encoded values, but we need to
      // concatenate them to a single colon-separated string for the
      // current design of the API. This is incorrect, as arguments should
      // be encoded if they are joined in a string. We should fix this, but
      // not without a breaking change.
      // https://jira.spotify.net/browse/KM-2353
      live('spotify:application').update({
        arguments: message.data.arguments.join(':')
      });
    } else if (message.data.name === 'set_state') {
      live('spotify:application').update({
        state: AppState.unserialize(message.data.state)
      });
    }
  }
}

function onRegister(model) {
  model.update({
    version: global.__spotify && global.__spotify.app_version || '0.0.0'
  });

  bridge('application_query', [], function (error, payload) {
    if (error) {
      if (global.console) console.error(error);
      return;
    }

    const data = {};
    if (payload.uri) data.appURI = payload.uri;
    if (payload.arguments) data.arguments = payload.arguments.join(':');
    if ('active' in payload) data.active = payload.active;

    model.update(data);
  });
}

exports.matches = /^spotify:application$/;
let registered;
exports.register = function () {
  if (registered) return;
  registered = true;

  global.addEventListener('message', onMessage);
  onRegister(live('spotify:application'));
};

exports.unregister = function () {
  if (!registered) return;
  registered = false;

  global.removeEventListener('message', onMessage);
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../live":210,"../navigation/app-state":230,"./util/bridge":204}],170:[function(require,module,exports){
(function (global){
/**
 * @module live-models/artist
 */
'use strict';

const liburi = require('spotify-liburi');
const contains = require('mout/array/contains');
const live = require('../live');
const bridge = require('./util/bridge').request;

function isLocalArtist(uri) {
  return liburi.from(uri).type === liburi.Type.LOCAL_ARTIST;
}

function updateMetadata(model) {
  if (isLocalArtist(model.uri)) {
    const uriObject = liburi.from(model.uri);
    if (uriObject) {
      model.update({
        local: true,
        name: uriObject.artist
      });
    }
  } else {
    bridge('artist_metadata', [model.uri], function (error, payload) {
      if (error) {
        if (global.console) console.error(error);
        return;
      }
      if (!payload.image && !model.get('image')) payload.image = '';
      if (!payload.images && !model.get('images')) payload.images = [];
      model.update(payload);
    });
  }
}

function updateLocal(model) {
  model.update({
    local: isLocalArtist(model.uri)
  });
}

function onWait(model, properties) {
  const hasLocal = contains(properties, 'local');
  let hasMetadata = false;
  const metaFields = ['image', 'images', 'name'];
  for (let i = 0, l = properties.length; i < l; i++) {
    if (contains(metaFields, properties[i])) {
      hasMetadata = true;
      break;
    }
  }

  if (hasMetadata) updateMetadata(model);
  if (hasLocal) updateLocal(model);
}

const regExp = exports.matches = /^spotify:artist:|^spotify:local:[^:]*$/;
let registered;
exports.register = function () {
  if (registered) return;
  registered = true;

  live.subscribe(regExp, 'wait', onWait);
};

exports.unregister = function () {
  if (!registered) return;
  registered = false;

  live.unsubscribe(regExp, 'wait', onWait);
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../live":210,"./util/bridge":204,"mout/array/contains":443,"spotify-liburi":730}],171:[function(require,module,exports){
(function (global){
/**
 * @module live-models/client-storage
 */
'use strict';

const forOwn = require('mout/object/forOwn');
const combine = require('mout/array/combine');
const remove = require('mout/array/remove');
const contains = require('mout/array/contains');

const URI = 'spotify:client-storage';
const live = require('../live');
const cosmos = require('./util/cosmos');
const endpoints = {
  broadcast: 'sp://messages/v1/client-storage'
};

let waiting = [];

function onInit(model) {
  // Set a flag for showing that the model has been implemented and
  // registered. This is so that we can check this in player without
  // making a breaking change. Would be great with a future live API
  // to see if someone has implemented a specific model.
  model.update({ implemented: true });
}

function onWait(model, properties) {
  // Ask the top frame to broadcast the properties.
  // Values will be null when they weren't stored.
  waiting = combine(waiting, properties);
  global.top.postMessage({
    type: 'client_storage',
    name: 'broadcast_client_storage',
    data: properties
  }, '*');
}

function onPublish(model, properties) {
  // Tell the top frame to persist and broadcast
  global.top.postMessage({
    type: 'client_storage',
    name: 'set_client_storage',
    data: properties
  }, '*');

  // Optimistic update
  model.update(properties);
}

function onBroadcast(error, event) {
  const update = {};
  const model = live(URI);
  forOwn(event.body, function (value, key) {
    // Update model if this instance of storage knows that the model waits for it
    const isWaiting = contains(waiting, key);

    // Or if the model has a potentially outdated value in the live cache
    const hasKey = model.get(key) !== undefined;

    if (isWaiting || hasKey) update[key] = value;
    if (isWaiting) remove(waiting, key);
  });
  model.update(update);
}

let broadcastSubscription;
const regExp = exports.matches = new RegExp(`^${URI}$`);
let registered;

exports.register = function () {
  if (registered) return;
  registered = true;

  live.subscribe(regExp, 'init', onInit);
  live.subscribe(regExp, 'wait', onWait);
  live.subscribe(regExp, 'publish', onPublish);
  broadcastSubscription = cosmos.subscribe({ url: endpoints.broadcast }, onBroadcast);
};

exports.unregister = function () {
  if (!registered) return;
  registered = false;

  live.unsubscribe(regExp, 'init', onInit);
  live.unsubscribe(regExp, 'wait', onWait);
  live.unsubscribe(regExp, 'publish', onPublish);

  if (broadcastSubscription) {
    broadcastSubscription.cancel();
    broadcastSubscription = null;
  }
  waiting.length = 0;
};

exports._endpoints = endpoints;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../live":210,"./util/cosmos":206,"mout/array/combine":442,"mout/array/contains":443,"mout/array/remove":452,"mout/object/forOwn":477}],172:[function(require,module,exports){
(function (global){
/**
 * @module live-models/client
 */
'use strict';

const live = require('../live');
const bridge = require('./util/bridge').request;
const liburi = require('spotify-liburi');

const BACKOFF = 100;

function updateCurrentUser(model) {
  const username = global.__spotify && global.__spotify.username;
  const userUri = liburi.profileURI(username).toURI();
  bridge('user_metadata', [userUri], function (error, payload) {
    if (error) {
      if (username) {
        model.update({
          currentUser: {
            uri: userUri,
            username: username
          }
        });
      }

      if (global.console) console.error(error);
      return;
    }

    model.update({
      currentUser: {
        uri: userUri,
        name: payload.name,
        username: payload.username
      }
    });
  });
}

function updateSessionData(model) {
  bridge('session_query', [], function (error, payload) {
    if (error) {
      if (global.console) console.error(error);
      return;
    }

    // Not all the clients expose employee property so it needs to be set if it does not exist
    if (payload.employee === undefined) {
      if (global.__spotify && global.__spotify.product_state && global.__spotify.product_state.employee) {
        // For Zelda
        payload.employee = global.__spotify.product_state.employee === '1' ? true : false;
      } else {
        // Clients older than 0.9.16 do not expose employee flag.
        payload.employee = false;
      }
    }

    model.update({ session: payload });

    // Initiate session subscription since data has been requested once.
    bridgeWaitSession(model);
  });
}

let registered;

function bridgeWaitSession(model) {
  bridge('session_event_wait', [], function (error, event) {
    if (!registered) return;
    if (error) {
      setTimeout(function () {
        bridgeWaitSession(model);
      }, BACKOFF);
      if (global.console) console.error(error);
      return;
    }

    if (event.type === 'change') {
      model.get('session').update(event.data);
    }

    bridgeWaitSession(model);
  });
}

function showContextMenu(model, data) {
  if (global === window && window.top && window.top.postMessage) {
    window.top.postMessage({
      type: 'client_show_context_ui',
      data: data
    }, '*');
  }
}

function onWait(model, properties) {
  if (properties.indexOf('currentUser') > -1) {
    updateCurrentUser(model);
  }

  if (properties.indexOf('session') > -1) {
    updateSessionData(model);
  }
}

function onInit(model) {
  // Get container_features and put it into it's own place on the client model.
  const __spotify = global.__spotify || {};
  const containerFeatures = live(__spotify.container_features || {});
  containerFeatures.on('wait', function (properties) {
    const update = {};
    for (let i = 0; i < properties.length; i++) {
      const property = properties[i];
      update[property] = false;
    }
    containerFeatures.update(update);
  });

  model.update({
    containerFeatures: containerFeatures
  });

  // Grab the username from __spotify where available
  if (global.__spotify && global.__spotify.username) {
    const username = global.__spotify.username;
    model.update({
      currentUser: {
        uri: liburi.profileURI(username).toURI(),
        username: username
      }
    });
  }

  // Async fetch from bridge to complete currentUser to a user model
  // while we don't have all the info available elsewhere.
  updateCurrentUser(model);
}

const regExp = exports.matches = /^spotify:client$/;

exports.register = function () {
  if (registered) return;
  registered = true;

  live.subscribe(regExp, 'wait', onWait);
  live.subscribe(regExp, 'init', onInit);
  live.subscribe(regExp, 'show-context-menu', showContextMenu);
};

exports.unregister = function () {
  if (!registered) return;
  registered = false;

  live.unsubscribe(regExp, 'wait', onWait);
  live.unsubscribe(regExp, 'init', onInit);
  live.unsubscribe(regExp, 'show-context-menu', showContextMenu);
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../live":210,"./util/bridge":204,"spotify-liburi":730}],173:[function(require,module,exports){
'use strict';

const live = require('../live');
const cosmos = require('./util/cosmos');

function onWait(model) {
  cosmos.get({
    url: 'sp://core-show/unstable/decorate',
    body: { items: [model.uri] }
  }, function (error, data) {
    if (error) throw error;

    const items = data.body.items[model.uri];
    items.show.uri = items.show.link;
    model.update(items);
  });
}

const regExp = exports.matches = /^spotify:episode:[^:]+$/;
let registered;
exports.register = function () {
  if (registered) return;
  registered = true;

  live.subscribe(regExp, 'wait', onWait);
};

exports.unregister = function () {
  if (!registered) return;
  registered = false;

  live.unsubscribe(regExp, 'wait', onWait);
};

},{"../live":210,"./util/cosmos":206}],174:[function(require,module,exports){
'use strict';

const album = require('./album');
const application = require('./application');
const artist = require('./artist');
const client = require('./client');
const clientStorage = require('./client-storage');
const sessionStorage = require('./session-storage');
const player = require('./player');
const playlist = require('./playlist');
const sortlist = require('./sortlist');
const track = require('./track');
const user = require('./user');
const add = require('./add');
const localFiles = require('./local-files');
const listVariant = require('./list-variant');
const episode = require('./episode');
const show = require('./show');

exports.register = function () {
  album.register();
  application.register();
  artist.register();
  client.register();
  clientStorage.register();
  sessionStorage.register();
  player.register();
  playlist.register();
  sortlist.register();
  track.register();
  user.register();
  add.register();
  localFiles.register();
  listVariant.register();
  episode.register();
  show.register();
};

exports.unregister = function () {
  album.unregister();
  application.unregister();
  artist.unregister();
  client.unregister();
  clientStorage.unregister();
  sessionStorage.unregister();
  player.unregister();
  playlist.unregister();
  sortlist.unregister();
  track.unregister();
  user.unregister();
  add.unregister();
  localFiles.unregister();
  listVariant.unregister();
  episode.unregister();
  show.unregister();
};

},{"./add":161,"./album":168,"./application":169,"./artist":170,"./client":172,"./client-storage":171,"./episode":173,"./list-variant":175,"./local-files":176,"./player":181,"./playlist":185,"./session-storage":186,"./show":187,"./sortlist":195,"./track":202,"./user":203}],175:[function(require,module,exports){
/**
 * @module live-models/list-variant
 */
'use strict';

const contains = require('mout/array/contains');
const showUnplayableTracks = require('./util/unplayable-tracks-playlist-setting.js');
const legacySortUris = require('./sorting/legacy-sort-uris');

const live = require('../live');
const sortUriUtils = require('../live-sort-uri');
const filterUriUtils = require('../live-filter-uri');
const URI = require('spotify-liburi');

const SESSION_STORAGE = 'spotify:session-storage';
const CLIENT_STORAGE = 'spotify:client-storage';
const SORT_VARIANT_KEY = 'list-variant-';
const STRING_FILTER_KEY = 'list-filter-string-';

function onWait(model, properties) {
  if (!contains(properties, 'listVariant')) {
    return;
  }

  const uri = getOriginUri(model.uri);

  // listVariant objects are shared amongst all variants.
  let listVariant = live(uri).get('listVariant');
  if (!listVariant) {
    listVariant = live({
      origin: {
        uri: uri
      }
    });
    listVariant.on('wait', onVariantWait.bind(null, listVariant));
  }

  model.update({ listVariant: listVariant });

  // If the model is a variant, set that list variant on the origin too
  // so it can be accessed there for the next variant to ask.
  if (uri !== model.uri) {
    live(uri).update({ listVariant: listVariant });
  }
}

function onVariantWait(model, properties) {
  if (contains(properties, 'currentUri')) {
    addAndWatchCurrentUri(model);
    // This will fulfill and watch all other properties
    return;
  }

  if (contains(properties, 'filterString')) {
    addAndWatchFilterString(model);
  }
  if (contains(properties, 'sortQuery') || contains(properties, 'sortDirection') || contains(properties, 'sortUri')) {
    addAndWatchSortQuery(model);
  }
  if (contains(properties, 'showUnplayable')) {
    addAndWatchUnplayable(model);
  }
}

function addAndWatchCurrentUri(model) {
  model.on('update', update);
  update();

  function update() {
    const props = 'filterString, sortQuery, sortDirection, sortUri, showUnplayable, origin(uri)';
    model.query(props, function (error, data) {
      if (error) {
        console.error('Error when getting', props, ':', Error);
        return;
      }

      let result = data.origin.uri;
      const filters = [];

      if (data.filterString) {
        filters.push(`text contains ${encodeURIComponent(data.filterString)}`);
      }

      if (!data.showUnplayable) {
        filters.push('playable eq true');
      }

      if (filters.length) {
        result = filterUriUtils.create(result, filters.join(','));
      }

      const sortUriParams = data.sortUri && sortUriUtils.parse(data.sortUri);

      if (sortUriParams) {
        result = sortUriUtils.create(result, sortUriParams.direction, sortUriParams.query);
      }

      model.update({
        currentUri: result
      });
    });
  }
}

function addAndWatchUnplayable(model) {
  const uri = model.get('origin').uri;
  const type = URI.fromString(uri).type;

  if (type !== URI.Type.PLAYLIST) {
    model.update({ showUnplayable: true });
    return;
  }

  live(uri).get('formatListType', function (error, formatListType) {
    if (error || formatListType !== 'chart') {
      subscribeToUnplayablePref(model);
    } else {
      model.update({ showUnplayable: true });
    }
  });
}

let showUnplayablePref;
let updateUnavailablePrefOn = [];

function subscribeToUnplayablePref(model) {
  updateUnavailablePrefOn.push(model);
  if (showUnplayablePref) {
    model.update({ showUnplayable: showUnplayablePref });
    return;
  }

  showUnplayableTracks.subscribe(function (error, showUnplayable) {
    let newShowUnplayable = showUnplayable;

    // Cache this globally as we will never cancel this subscribe here.
    // The same setting is valid for all models.
    if (error) {
      console.error(error);
      newShowUnplayable = false; // Should default to hide unplayable.
    }

    showUnplayablePref = newShowUnplayable;
    for (let i = 0; i < updateUnavailablePrefOn.length; i++) {
      updateUnavailablePrefOn[i].update({ showUnplayable: newShowUnplayable });
    }
  });
}

function addAndWatchSortQuery(model) {
  const uri = model.get('origin').uri;

  const clientStorage = live(CLIENT_STORAGE);
  const key = SORT_VARIANT_KEY + uri;
  if (clientStorage.get('implemented')) {
    updateSortParams(model, uri, key);
    clientStorage.on('update', function (changed) {
      if (changed.hasOwnProperty(key)) {
        updateSortParams(model, uri, key);
      }
    });
  } else {
    // There is no clientStorage. Update the model with defaults.
    const update = getDefaultQueryParams(uri);
    model.update(update);
  }
}

function updateSortParams(model, uri, key) {
  const clientStorage = live(CLIENT_STORAGE);

  clientStorage.get(key, function (error, variant) {
    // Respond with the sort variant if it's a valid sort URI
    const sortParams = variant && sortUriUtils.parse(variant);
    if (!error && sortParams) {
      // Check for legacy sort URIs and convert them by publishing
      // the updated version on client-storage
      const convertedFromLegacy = legacySortUris.legacyQueries[sortParams.query];

      if (convertedFromLegacy && convertedFromLegacy !== sortParams.query) {
        // Fix the legacy query on storage
        const fixedUri = sortUriUtils.create(uri, sortParams.direction, convertedFromLegacy);
        const publish = {};
        publish[key] = fixedUri;
        clientStorage.publish(publish);
        // This will trigger another update which will then set the sort params.
        return;
      }

      model.update({
        sortQuery: sortParams.query,
        sortDirection: sortParams.direction, // this is 'asc' or 'desc'
        sortUri: variant
      });
    } else if (variant === uri) {
      // This was unsorted.
      model.update({
        sortQuery: null,
        sortDirection: null,
        sortUri: null
      });
    } else {
      // There was nothing valid in store. Update the model with defaults.
      const update = getDefaultQueryParams(uri);
      model.update(update);
    }
  });
}

function getDefaultQueryParams(uri) {
  let sortQuery = null;
  let sortDirection = null;
  let sortUri = null;

  const isLocalFiles = uri === 'spotify:internal:local-files';
  if (isLocalFiles) {
    // Local files should be sorted by trackname by default
    sortQuery = 'track(name)';
    sortDirection = 'asc';
    sortUri = sortUriUtils.create(uri, sortDirection, sortQuery);
  }

  return {
    sortQuery: sortQuery,
    sortDirection: sortDirection,
    sortUri: sortUri
  };
}

function addAndWatchFilterString(model) {
  const uri = model.get('origin').uri; // The variant object itself doesn't have a uri, this is the one for the list it's about
  const sessionStorage = live(SESSION_STORAGE);
  const key = STRING_FILTER_KEY + uri;

  if (sessionStorage.get('implemented')) {
    updateFilterString(model, uri, key);
    sessionStorage.on('update', function (changed) {
      if (changed.hasOwnProperty(key)) {
        updateFilterString(model, uri, key);
      }
    });
  } else {
    model.update({ filterString: '' });
  }
}

function updateFilterString(model, uri, key) {
  const sessionStorage = live(SESSION_STORAGE);

  sessionStorage.get(key, function (error, value) {
    model.update({ filterString: value || '' });
  }, live.ASAP);
}

function getOriginUri(uri) {
  let newUri = uri;
  const sorted = sortUriUtils.parse(newUri);
  if (sorted) newUri = sorted.originUri;

  const filtered = filterUriUtils.parse(newUri);
  if (filtered) newUri = filtered.originUri;

  return newUri;
}

let registered;

function updateRegisteredStatus(status) {
  registered = status;
  live('spotify:list-variant').update({ implemented: status });
}

const regExp = exports.matches = /^spotify:/;
exports.register = function () {
  if (registered) return;

  live.subscribe(regExp, 'wait', onWait);
  updateRegisteredStatus(true);
};

exports.unregister = function () {
  if (!registered) return;

  updateUnavailablePrefOn = [];
  showUnplayablePref = null;

  live.unsubscribe(regExp, 'wait', onWait);
  updateRegisteredStatus(false);
};

},{"../live":210,"../live-filter-uri":156,"../live-sort-uri":208,"./sorting/legacy-sort-uris":189,"./util/unplayable-tracks-playlist-setting.js":207,"mout/array/contains":443,"spotify-liburi":730}],176:[function(require,module,exports){
(function (global){
/**
 * @module live-models/local-files
 */
'use strict';

const contains = require('mout/array/contains');

const live = require('../live');
const listOperations = require('../live-list-operations');
const liburi = require('spotify-liburi');
const Range = require('../range2');
const cosmos = require('./util/cosmos');

const regExp = /^spotify:internal:local-files$/;

function onWait(model, properties) {
  if (contains(properties, 'allows')) getAllows(model);
  if (contains(properties, 'rows')) getRows(model);
}

function getAllows(model) {
  model.update({
    allows: {
      insertTracks: false,
      removeTracks: false
    }
  });
}

function createRows(data) {
  const rows = new Array(data.length);

  for (let i = 0, l = data.length; i < l; i++) {
    const track = data[i];

    setLocalProperty(track);

    // We want timestamp in milliseconds, but the client gives it in seconds.
    const dateAdded = track.dateAdded * 1000;

    const row = {
      uri: getRowUri(track.uri),
      track: track,
      dateAdded: dateAdded
    };

    rows[i] = row;

    delete track.dateAdded;
    delete track.addedBy;
  }

  return rows;
}

function setLocalProperty(track) {
  if (track.album && track.album.uri) {
    const albumType = liburi.from(track.album.uri).type;
    track.album.local = albumType === liburi.Type.LOCAL_ALBUM;
  }
  if (track.artists) {
    for (let i = 0, l = track.artists.length; i < l; i++) {
      const artist = track.artists[i];
      if (artist.uri) {
        const artistType = liburi.from(artist.uri).type;
        artist.local = artistType === liburi.Type.LOCAL_ARTIST;
      }
    }
  }
}

function getRows(model) {
  cosmos.get({ url: 'sp://local-files/v1/tracks' }, function (error, response) {
    if (error) {
      if (global.console) console.error(error);
      return;
    }

    model.update({
      rows: createRows(response.body)
    });

    cosmos.subscribe({ url: 'sp://local-files/v1/changes' }, function (subError, subResponse) {
      if (subError) {
        if (global.console) console.error(subError);
      } else {
        onChange(model, subResponse.body);
      }
    });
  });
}

function onChange(model, event) {
  switch (event.type) {
    case 'removed':
      onTracksRemoved(model, event.data);
      break;
    case 'added':
      onTracksAdded(model, event.data);
      break;
    case 'moved':
      onTracksMoved(model, event.data);
      break;
    case 'changed':
      onMetadataChanged(model, event.data);
      break;
    default:
      console.error('Unexpected event type', event.type);
      break;
  }
}

function onMetadataChanged(model, data) {
  // The positions we get could in some cases be for multiple ranges.
  //
  // We need to remove each range individually, so that we can re-add
  // the same range with updated data right after removing the range.
  // The reason we can't just update rows with new data is that the
  // metadata might cause the row to get a new URI (since local files
  // contain the metadata in the URI).

  const ranges = Range.fromIndices(data.positions);

  let startOfRangeInChangeset = 0;

  for (let rangeIndex = 0; rangeIndex < ranges.length; rangeIndex++) {
    const range = ranges[rangeIndex];
    const indices = range.toIndices();
    const rangeLength = range.length;
    const tracks = new Array(indices.length);

    for (let i = 0; i < rangeLength; i++) {
      tracks[i] = data.tracks[startOfRangeInChangeset + i];
    }

    // Remove range and re-add it with new data
    const removeOperations = listOperations.getRemoveOperations(indices);
    model.get('rows').update(removeOperations);
    addTracksToList(model, tracks, indices[0]);

    startOfRangeInChangeset += rangeLength;
  }
}

function onTracksMoved(model, data) {
  const moveOperations = listOperations.getMoveOperations(data.positions, data.position);
  model.get('rows').update(moveOperations);
}

function onTracksRemoved(model, data) {
  const removeOperations = listOperations.getRemoveOperations(data.positions);
  model.get('rows').update(removeOperations);
}

function onTracksAdded(model, data) {
  addTracksToList(model, data.tracks, data.position);
}

function addTracksToList(model, tracks, index) {
  const rows = createRows(tracks);

  const insertOperations = listOperations.getInsertOperations(rows, index);
  model.get('rows').update(insertOperations);
}

let idCounter = 1000;
function getRowUri(trackUri) {
  return trackUri.replace('spotify:', `spotify:row:${(++idCounter).toString(36)}:`);
}

let registered = false;

exports.register = function () {
  if (registered) return;
  registered = true;
  live.subscribe(regExp, 'wait', onWait);
};

exports.unregister = function () {
  if (!registered) return;
  registered = false;
  live.unsubscribe(regExp, 'wait', onWait);
};

exports.matches = regExp;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../live":210,"../live-list-operations":157,"../range2":245,"./util/cosmos":206,"mout/array/contains":443,"spotify-liburi":730}],177:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.play = play;
const cosmos = require('../util/cosmos');
const liburi = require('spotify-liburi');

function play(contextUri, options, callback) {
  const uriObject = liburi.from(contextUri);

  const type = {
    [liburi.Type.COLLECTION_ALBUM]: 'album',
    [liburi.Type.COLLECTION_ARTIST]: 'artist'
  }[uriObject.type];

  const id = uriObject.getBase62Id();

  const sort = {
    [liburi.Type.COLLECTION_ALBUM]: 'discNumber,trackNumber',
    [liburi.Type.COLLECTION_ARTIST]: 'addTime DESC,discNumber,trackNumber'
  }[uriObject.type];

  const resolverUrl = `sp://core-collection/unstable/@/list/tracks/${type}/${id}/play?sort=${sort}`;
  const postObject = { url: resolverUrl };
  if (options) {
    postObject.body = options;
  }

  cosmos.post(postObject, callback);
}

},{"../util/cosmos":206,"spotify-liburi":730}],178:[function(require,module,exports){
(function (global){
'use strict';

var _liveWrappedUri = require('../../live-wrapped-uri');

var _liveWrappedUri2 = _interopRequireDefault(_liveWrappedUri);

var _cosmosPlayer = require('./cosmos-player');

var _cosmosPlayer2 = _interopRequireDefault(_cosmosPlayer);

var _playerApi = require('./player-api');

var _playerApi2 = _interopRequireDefault(_playerApi);

var _playlistResolver = require('./playlist-resolver');

var playlistResolver = _interopRequireWildcard(_playlistResolver);

var _collectionResolver = require('./collection-resolver');

var collectionResolver = _interopRequireWildcard(_collectionResolver);

var _data = require('./data');

var _data2 = _interopRequireDefault(_data);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Request to play a list of track URIs.
 *
 * @param {Array.<string>} trackUris Array of track URIs.
 * @param {Object} playOptions An object with play options.
 * @param {Function=} callback Callback function.
 */
/**
 * @module live-models/player/control
 * @private
 */
function playTrackUris(tracks, playOptions, callback) {
  _playerApi2.default.play(tracks, playOptions, callback);
}

/**
 * Request to play a context through the cosmos track resolver.
 *
 * @param {string} contextUri Context URI.
 * @param {Object} playOptions An object with play options.
 * @param {Function=} callback Optional callback function.
 */
function playFromResolver(contextUri, playOptions, callback) {
  _playerApi2.default.playFromResolver(contextUri, playOptions, callback);
}

/**
 * Play a context directly, only supported on context player
 *
 * @param {Object} context Context object that CP can deal with.
 * @param {Object} playOptions An object with play options.
 * @param {Function=} callback Optional callback function.
 */
function playContext(context, playOptions, callback) {
  _playerApi2.default.playContext(context, playOptions, callback);
}

/**
 * Update the player with a new context without changing what is currently
 * playing.
 *
 * @param {Object} context Context object that CP can deal with.
 * @param {Function=} callback Optional callback function.
 */
function updateContext(context, callback) {
  _playerApi2.default.updateContext(context, callback);
}

/**
 * Request to play a context through the playlist resolver.
 *
 * @param {string} contextUri Context URI.
 * @param {Object} playOptions An object with play options.
 * @param {Function=} callback Optional callback function.
 */
function playFromPlaylistResolver(contextUri, playOptions, callback) {
  // For playlist playback we don't need to support ranges, so we'll
  // always just pick the first.
  const skipToIndex = {};

  // Todo: This should be cleaned up, we don't need a list of uids because we
  // never need ranges now. We do that stuff using pages.
  if (playOptions.uids) {
    skipToIndex.track_uid = playOptions.uids[0];
  } else if (playOptions.uid) {
    skipToIndex.track_uid = playOptions.uid;
  }

  // Todo: This should be cleaned up, we don't need a list of uids because we
  // never need ranges now. We do that stuff using pages.
  if (playOptions.uris) {
    skipToIndex.track_uri = playOptions.uris[0];
  } else if (playOptions.trackUri) {
    skipToIndex.track_uri = playOptions.trackUri;
  }

  const preparePlayOptions = {};
  if (Object.keys(skipToIndex).length) {
    preparePlayOptions.skip_to_index = skipToIndex;
  }

  const playOrigin = {
    view_uri: _liveWrappedUri2.default.getOriginUri(playOptions.context) || playOptions.context,

    // fills in source_start & source_end
    // example values: browse, playlist-owned-by-self-non-collaborative
    feature_identifier: playOptions.source,

    // fills in referer
    // example values: spotify:app:browse
    referrer_identifier: playOptions.contextPlayerReferrer,

    // fills in referrer version
    feature_version: playOptions.referrerVersion
  };

  const options = {
    prepare_play_options: preparePlayOptions,
    play_origin: playOrigin
  };

  playlistResolver.play(contextUri, options, callback);
}

/**
 * Request to play a context through the collection resolver.
 *
 * @param {string} contextUri Context URI.
 * @param {Object} playOptions An object with play options.
 * @param {Function=} callback Optional callback function.
 */
function playFromCollectionResolver(contextUri, playOptions, callback) {
  const playOrigin = {
    view_uri: _liveWrappedUri2.default.getOriginUri(playOptions.context) || playOptions.context,

    // fills in source_start & source_end
    // example values: browse, playlist-owned-by-self-non-collaborative
    feature_identifier: playOptions.source,

    // fills in referer
    // example values: spotify:app:browse
    referrer_identifier: playOptions.contextPlayerReferrer,

    // fills in referrer version
    feature_version: playOptions.referrerVersion
  };

  const preparePlayOptions = {};
  if (playOptions.index !== null) {
    preparePlayOptions.skip_to = {
      track_index: playOptions.index
    };
  }

  const options = {
    prepare_play_options: preparePlayOptions,
    play_origin: playOrigin
  };

  collectionResolver.play(contextUri, options, callback);
}

/**
 * Request to play a single track.
 *
 * @param {string} uri The track URI.
 * @param {Object} playOptions An object with play options.
 * @param {Function=} callback Optional callback function.
 */
function playTrack(uri, playOptions, callback) {
  playOptions.context = uri;
  playOptions.track = uri;
  playOptions.index = 0;
  playTrackUris([{ uri }], playOptions, callback);
}

/**
 * Request to play tracks found in the list of rows.
 *
 * @param {LiveList} rows A live list of rows with tracks.
 * @param {Object} playOptions An object with play options.
 * @param {Function=} callback Optional callback function.
 */
function playRows(rows, playOptions, callback) {
  const { index, range } = playOptions;

  if (index === null && range) {
    _data2.default.getFirstPlayableRow(rows, range, (error, rowIndex) => {
      if (error) {
        if (global.console) console.error(error);
        if (callback) {
          callback(error);
        }
      } else {
        const tracks = _data2.default.getTracksFromRows(rows);
        playOptions.index = rowIndex;

        playTrackUris(tracks, playOptions, callback);
      }
    });
  } else {
    const tracks = _data2.default.getTracksFromRows(rows);
    playTrackUris(tracks, playOptions, callback);
  }
}

/**
 * Request to play artist context.
 *
 * @param {string} contextUri Context URI.
 * @param {Function=} callback Optional callback function.
 */
function playFromArtist(uri, playOptions, callback) {
  playFromResolver(uri, playOptions, callback);
}

/**
 * Request to update the player with tracks from the provided rows list.
 * This will update the player silently without interrupting playback.
 *
 * @param {LiveList} rows A live list of rows with tracks.
 * @param {Object} playOptions An object with play options.
 * @param {Function=} callback Optional callback function.
 */
function updateWithRows(rows, playOptions, callback) {
  const tracks = _data2.default.getTracksFromRows(rows);

  // Context Player matches on UIDs so let's not provide index
  delete playOptions.index;
  _playerApi2.default.update(tracks, playOptions, callback);
}

/**
 * Request to pause the playback.
 *
 * @param {Function=} callback Optional callback function.
 */
function pause(callback) {
  _playerApi2.default.pause(callback);
}

/**
 * Request to resume the playback.
 *
 * @param {Function=} callback Optional callback function.
 */
function resume(callback) {
  _playerApi2.default.resume(callback);
}

/**
 * Request to skip to the previous track.
 *
 * @param {Function=} callback Optional callback function.
 */
function skipPrev(callback) {
  _cosmosPlayer2.default.skipPrev(callback);
}

/**
 * Request to skip to the next track.
 *
 * @param {Function=} callback Optional callback function.
 */
function skipNext(callback) {
  _cosmosPlayer2.default.skipNext(callback);
}

exports.playTrack = playTrack;
exports.playRows = playRows;
exports.playFromResolver = playFromResolver;
exports.playContext = playContext;
exports.playFromArtist = playFromArtist;
exports.updateContext = updateContext;
exports.updateWithRows = updateWithRows;
exports.pause = pause;
exports.resume = resume;
exports.skipPrev = skipPrev;
exports.skipNext = skipNext;
exports.playFromPlaylistResolver = playFromPlaylistResolver;
exports.playFromCollectionResolver = playFromCollectionResolver;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../live-wrapped-uri":209,"./collection-resolver":177,"./cosmos-player":179,"./data":180,"./player-api":182,"./playlist-resolver":183}],179:[function(require,module,exports){
/**
 * @module live-models/player/cosmos-player
 * @private
 */
'use strict';

const cosmos = require('../util/cosmos');

const PLAYER_URI = 'sp://player/v2/main';

const ACTIONS = {
  PLAY: 'play',
  PAUSE: 'pause',
  RESUME: 'resume',
  UPDATE: 'update',
  SKIP_PREV: 'skip_prev',
  SKIP_NEXT: 'skip_next'
};

/**
 * Request to pause the playback.
 *
 * @param {Function=} callback Optional callback function.
 */
function pause(callback) {
  cosmos.post({ url: PLAYER_URI, body: { action: ACTIONS.PAUSE } }, callback);
}

/**
 * Request to resume the playback.
 *
 * @param {Function=} callback Optional callback function.
 */
function resume(callback) {
  cosmos.post({ url: PLAYER_URI, body: { action: ACTIONS.RESUME } }, callback);
}

/**
 * Request to skip playback back.
 *
 * @param {Function=} callback Optional callback function.
 */
function skipPrev(callback) {
  cosmos.post({ url: PLAYER_URI, body: { action: ACTIONS.SKIP_PREV } }, callback);
}

/**
 * Request to skip playback forward.
 *
 * @param {Function=} callback Optional callback function.
 */
function skipNext(callback) {
  cosmos.post({ url: PLAYER_URI, body: { action: ACTIONS.SKIP_NEXT } }, callback);
}

/**
 * Request to get the current state of the cosmos player.
 *
 * @param {Function} callback Callback function.
 */
function getState(callback) {
  cosmos.get({ url: PLAYER_URI }, function (error, response) {
    if (error) {
      callback(error);
    } else {
      callback(null, response.body);
    }
  });
}

/**
 * Request to get the current state of the cosmos player whenever the player
 * changes.
 *
 * @param {Function} callback Callback function.
 *
 * @return {Object} An object with a method to unsubscribe.
 */
function subscribe(callback) {
  let subscription = cosmos.subscribe({ url: PLAYER_URI }, function (error, response) {
    if (error) {
      callback(error);
    } else {
      callback(null, response.body);
    }
  });

  return {
    unsubscribe: function () {
      if (!subscription) return;
      subscription.cancel();
      subscription = null;
    }
  };
}

exports.pause = pause;
exports.resume = resume;
exports.skipPrev = skipPrev;
exports.skipNext = skipNext;
exports.getState = getState;
exports.subscribe = subscribe;

},{"../util/cosmos":206}],180:[function(require,module,exports){
/**
 * @module live-models/player/data
 * @private
 */
'use strict';

const live = require('../../live');
const Range = require('../../range2');

const playerApi = require('./player-api');

/**
 * Default values for play options.
 */
const PLAY_OPTIONS_DEFAULTS = {
  page: null,
  uid: null,
  trackUri: null,
  index: null,
  source: 'unknown',
  reason: 'unknown'
};

/**
 * Get the first playable row from range in a list of rows.
 *
 * @param {LiveList} rows A live list of rows.
 * @param {Range} range A range object.
 * @param {Function} callback A callback where the second argument is the
 *     index of the first playable row. If no playable track is found, the
 *     index will be the first index in the range.
 */
function getFirstPlayableRow(rows, range, callback) {
  let index = range.start;

  isRowPlayable(rows.get(index), function playableCallback(error, playable) {
    if (playable) {
      callback(null, index);
    } else {
      if (index === range.end - 1) {
        callback(null, range.start);
      } else {
        isRowPlayable(rows.get(++index), playableCallback);
      }
    }
  });
}

/**
 * Check if the row is playable.
 *
 * @param {LiveObject?} row A row live object. If this is falsy, the callback
 *     is returned with false immediately.
 * @param {Function} callback A callback where the second argument is the
 *     boolean flag for playable. The callback may run synchronously or
 *     asynchronously.
 */
function isRowPlayable(row, callback) {
  if (!row) {
    callback(null, false);
  } else {
    row.query('track(playable)', function (error, data) {
      if (error) {
        callback(error);
      } else {
        callback(null, data.track.playable);
      }
    }, live.ASAP);
  }
}

/**
 * Get options for play actions based on a data object and other state
 * like referrer set on the player or application object.
 *
 * @param {Object} data A data object.
 * @param {Function} callback A callback, where the second argument is a data
 *     object with the options.
 */
function getPlayOptions(data, callback) {
  getReferrer(function (error, viewUri, baseUri) {
    if (error) {
      callback(error);
    } else {
      Object.keys(PLAY_OPTIONS_DEFAULTS).forEach(function (key) {
        if (data[key] === undefined) {
          data[key] = PLAY_OPTIONS_DEFAULTS[key];
        }
      });

      if (data.range) {
        data.range = new Range(data.range[0], data.range[1]);
      }

      data.referrer = viewUri;
      data.contextPlayerReferrer = baseUri;
      data.referrerVersion = getReferrerVersion();

      callback(null, data);
    }
  });
}

/**
 * Get a list of track objects from a live list of rows.
 *
 * @param {LiveList} rows A live list of rows.
 *
 * @return {Array.<Object>} Array of track objects. If a row is not set in the
 *     list, or if the row doesn't have a track object with a URI, an
 *     null value will be put in that position in the output array.
 */
function getTracksFromRows(rows) {
  return rows.map((row, index) => {
    const trackLiveObject = row && row.get('track');
    if (trackLiveObject) {
      const trackData = trackLiveObject.serialize(1);

      const metadata = {};

      if (trackData.manifestId) {
        metadata['media.manifest_id'] = trackData.manifestId;
      }

      if (trackData.mediaTypeEnum) {
        metadata['media.type'] = trackData.mediaTypeEnum === 2 ? 'video' : 'audio';
      }

      return {
        uri: trackData.uri,
        uid: rows.keys[index],
        metadata: metadata
      };
    }

    return null;
  });
}

/**
 * Get the latest player state, in the format of the player live model.
 *
 * @param {Function} callback Callback function.
 */
function getPlayerState(callback) {
  playerApi.getState(callback);
}

/**
 * Subscribe to the cosmos player to get the latest player state,
 * in the format of the player live model.
 *
 * @param {Function} callback Callback function.
 * @return {Object} An object with a method to unsubscribe.
 */
function subscribeForPlayerState(callback) {
  return playerApi.subscribe(callback);
}

/**
 * Get the referrer for the player. This is usually the path back to the app in
 * the state where the playback started. It can be set by the user in the `referrer`
 * property of the player live object. If nothing is set there, it will generate
 * the referrer by combining the app URI with the app arguments.
 *
 * @param {Function} callback A callback where the second argument is the referrer.
 */
function getReferrer(callback) {
  // 'referrer' corresponds to fullURI below
  const referrer = live('spotify:player').get('referrer');
  const referrerBaseUri = live('spotify:player').get('referrerBaseUri');
  if (referrer) {
    if (!referrerBaseUri) {
      console.warn(`referrer field is set on the player model (${referrer}), but referrerBaseUri isn't`);
    }
    callback(null, referrer, referrerBaseUri || '');
  } else {
    live('spotify:application').get('appURI', 'arguments', function (error, uri, args) {
      if (error) {
        callback(error);
      } else {
        const fullUri = args ? `${uri}:${args}` : uri;
        callback(null, fullUri, uri);
      }
    });
  }
}

/**
 * Get the referrer version. This is usually the version of the app. It can be set
 * by the user in the `version` property of the application live object. If nothing
 * is set there, it will use the default version '0.0.0'.
 *
 * @return {string} The version string.
 */
function getReferrerVersion() {
  return live('spotify:application').get('version') || '0.0.0';
}

exports.getReferrer = getReferrer;
exports.getReferrerVersion = getReferrerVersion;
exports.getFirstPlayableRow = getFirstPlayableRow;
exports.isRowPlayable = isRowPlayable;
exports.getPlayOptions = getPlayOptions;
exports.getTracksFromRows = getTracksFromRows;
exports.getPlayerState = getPlayerState;
exports.subscribeForPlayerState = subscribeForPlayerState;

},{"../../live":210,"../../range2":245,"./player-api":182}],181:[function(require,module,exports){
(function (global){
/**
 * @module live-models/player
 */
'use strict';

var _messageProxy = require('../../../libs/message-proxy');

var _formatLists = require('../../../libs/playlist-utils/format-lists');

const live = require('../../live');
const URI = require('spotify-liburi');
const abba = require('../../../libs/abba');
const CancellationTokenSource = require('../../../libs/cancellation-token-source').default;

const playerApi = require('./player-api');
const playbackControl = require('./control');
const dataUtils = require('./data');
const updatesUtils = require('./updates');
const playlistResolver = require('./playlist-resolver');
const sortUriUtils = require('../../live-sort-uri');
const filterUriUtils = require('../../live-filter-uri');
const createStationPlayContext = require('../station/create-play-context');
const createStationPlayOptions = require('../station/create-play-options');
const isStationUri = require('../station').isStationUri;

const TYPE_TRACK = 'track';
const TYPE_ROWS = 'rows';
const TYPE_CP_RESOLVER_PLAYLIST = 'context-player-resolver-playlist';
const TYPE_CP_RESOLVER_COLLECTION = 'context-player-resolver-collection';
const TYPE_CP_CONTEXT = 'context-player-context';
const TYPE_CONTEXT_OBJECT = 'context-object';
const TYPE_STATION_CONTEXT = 'context-station-context';
const TYPE_CP_ARTIST_CONTEXT = 'context-player-artist';
const TYPE_CP_ALBUM_CONTEXT = 'context-player-album';
const TYPE_CONTEXT_EPISODE = 'context-episode';
const TYPE_CONTEXT_SHOW = 'context-show';

const cancellationTokenSource = new CancellationTokenSource();

// This data store will keep context objects keyed by context URI. The values
// are context objects in the format of spotify-player Context:
// https://ghe.spotify.net/spotify-sdk/spotify-player/blob/master/lib/v2/types.js#L164
const contextDataStore = {};

/**
 * Handler for when properties are requested from the model.
 *
 * @param {LiveObject} model The player live object.
 */
function onWait(model) {
  updateState(model);
}

/**
 * Handler for when the model needs to be updated by polling the player.
 *
 * @param {LiveObject} model The player live object.
 */
function onSync(model) {
  updateState(model);
}

/**
 * Handler for when the real player is updated.
 *
 * @param {Error?} error An error object, or null.
 * @param {Object} data Data object in the format of this live model.
 */
function onPlayerStateUpdate(error, data) {
  if (error) {
    if (global.console) console.error(error);
    return;
  }
  const model = live('spotify:player');
  if (model.get('pending')) return;
  model.update(data);
}

/**
 * Handler for when the model receives the 'update' event.
 *
 * @param {LiveObject} model The player live object.
 */
function onUpdate(model) {
  const index = model.get('index') && model.get('index').get('track');
  if (index !== null) {
    updatesUtils.setPlayingIndex(index);
  }

  updatesUtils.clean(model);
}

/**
 * Handler for when the model receives the 'play' event.
 *
 * @param {LiveObject} model The player live object.
 * @param {Object} event The event object with data about what to play.
 *     Can contain the following properties:
 *       `context` (string, context URI)
 *       `index` (number, index within context to play)
 *       `uid` (string, uid within context to play)
 *       `page` (number, index for the context player page)
 *       `range` (array of two values, start and end index)
 *       `uids` (array of uids representing an index or a range)
 *       `uris` (array of uris connected to the uids)
 *       `source` (string)
 *       `reason` (string)
 */
function onPlay(model, event) {
  const context = event.context;
  if (!context) return;

  // The `index` property might be `null`, which should mean that no specific
  // index should be played.
  if (typeof event.index !== 'number') {
    delete event.index;
  }

  // Cancel all previous play/update context requests
  cancellationTokenSource.cancel();
  const cancellationToken = cancellationTokenSource.token();

  // Update the model optimistically
  model.update(playerApi.addContext({
    isPlaying: true,
    isPaused: false,
    index: event.index === undefined ? null : { page: 0, track: event.index },
    track: event.trackUri === undefined ? null : { uri: event.trackUri },
    contextUpdatedCrossFrame: false
  }, context));

  // Get options for the play action based on event data and other state
  // Todo: getPlayOptions creates options that fit the cosmos/v1 implementation.
  // We could probably do this a bit later from cosmos-player.js
  dataUtils.getPlayOptions(event, function (error, options) {
    if (error || !options.context) {
      updateState(model); // Revert state
    } else {
      // Canonical contexts can have sorted and/or filtered state that needs
      // to be respected client-wide. We therefore query for the correct variant
      // to be played.
      // For spotify:internal uris on the other hand, we don't look for variants.
      // This would also be the case for contexts that already represent variants.
      // Please see docs for details.
      if (/^spotify:internal:/.test(options.context)) {
        playWithOptions(model, cancellationToken, options);
      } else {
        if (live('spotify:list-variant').get('implemented')) {
          live(options.context).query('listVariant(currentUri, sortUri)', function (queryError, data) {
            if (queryError) {
              updateState(model); // Revert state
            } else {
              // Abort if a new play request has happened since this request started
              if (!cancellationToken.isCanceled()) {
                options.context = data.listVariant.currentUri;
                playWithOptions(model, cancellationToken, options);
              }
            }
          });
        } else {
          playWithOptions(model, cancellationToken, options);
        }
      }
    }
  });
}

/**
 * Handler for when the model receives the 'pause' event.
 *
 * @param {LiveObject} model The player live object.
 */
function onPause(model) {
  if (model.get('isPlaying') === false || model.get('isPaused') === true) {
    return;
  }

  model.update({ isPaused: true });

  playbackControl.pause(function (error) {
    if (error) {
      model.update({ isPaused: false });
    }
  });
}

/**
 * Handler for when the model receives the 'resume' event.
 *
 * @param {LiveObject} model The player live object.
 */
function onResume(model) {
  if (model.get('isPlaying') === true && model.get('isPaused') === false) {
    return;
  }

  model.update({ isPaused: false });

  playbackControl.resume(function (error) {
    if (error) {
      model.update({ isPaused: true });
    }
  });
}

/**
 * Handler for when the model receives the 'skip-previous' event.
 *
 * @param {LiveObject} model The player live object.
 */
function onSkipPrev() {
  // Skip prev often starts playback, but not when you're on the first track.
  // Therefor no optimistic update of 'playing' here.
  playbackControl.skipPrev();
}

/**
 * Handler for when the model receives the 'skip-next' event.
 *
 * @param {LiveObject} model The player live object.
 */
function onSkipNext() {
  // Skip next often starts playback, but not when you're on the last track.
  // Therefor no optimistic update of 'playing' here.
  playbackControl.skipNext();
}

/**
 * Handler for when the model receives the 'update-context' event.
 *
 * @param {LiveObject} model The player live object.
 * @param {Object} event An event object with a `context` property (string).
 */
function onUpdateContext(model, event) {
  const contextUri = event.context;
  if (!contextUri) return;

  // Cancel all previous play/update context requests
  cancellationTokenSource.cancel();
  const cancellationToken = cancellationTokenSource.token();

  const currentIndex = model.get('index') && model.get('index').get('track');
  const currentContext = model.get('variant');

  // Update player model optimistically with context and no index.
  // We can't know the index yet, so we must set it to nothing to
  // not get wrong highlights.
  model.update(playerApi.addContext({
    index: null,
    pending: true,
    contextUpdatedCrossFrame: false
  }, contextUri));

  // We need the rows list to be able to get the index and play the list.
  live(contextUri).get('rows', function (error, rowsList) {
    if (error) {
      model.update({ pending: false });
      if (global.console) console.error(error);
      return;
    }

    const options = { context: contextUri };
    dataUtils.getPlayOptions(options, function (playOptionsError, playOptions) {
      // Abort if a new play request has happened since this request started
      if (cancellationToken.isCanceled()) {
        return;
      }

      // Store which row is currently playing, so that we can get the index
      // of the playing row in another list.
      updatesUtils.setPlayingIndex(currentIndex, currentContext.get('rows'));

      // Find the index of the currently playing track in new list, to do an
      // optimistic update. This is not optional, since the actual player only appends
      // the next context and will not send an update until the next skip.
      // (If it does, because of play/pause for example, it will still report the old
      // list that we're not showing in the UI)

      // At the same time, find the index that we will use to actually update the playback
      const updateIndices = updatesUtils.getPlayingAndUpdateIndicesInList(rowsList);
      playOptions.index = updateIndices.update;
      if (updateIndices.playing !== null) model.update({ index: { page: 0, track: updateIndices.playing } });

      if (model.get('playOrigin') && model.get('playOrigin').get('referrerIdentifier') !== playOptions.referrer) {
        model.update({ contextUpdatedCrossFrame: true });
      }

      playbackControl.updateWithRows(rowsList, playOptions, function () {
        model.update({ pending: false });
        // The state is updated both for success and error cases.
        updateState(model);
      });

      updatesUtils.listen(rowsList, playOptions, function (updateOptions) {
        playbackControl.updateWithRows(rowsList, updateOptions, function (updateError) {
          if (updateError) {
            updateState(model); // Revert state
          }
        });
      });
    });
  });
}

/**
 * Handler for when the model receives the 'update-show-context' event.
 *
 * @param {LiveObject} model The player live object.
 * @param {Object} event An event object with a `context` property (string).
 */
function onUpdateShowContext(model, event) {
  const contextUri = event.context;
  if (!contextUri) return;

  // Cancel all previous play/update context requests
  cancellationTokenSource.cancel();
  const cancellationToken = cancellationTokenSource.token();

  // Update player model optimistically with context and no index.
  // We can't know the index yet, so we must set it to nothing to
  // not get wrong highlights.
  model.update(playerApi.addContext({}, contextUri));

  const showQueryTimeout = 3000;
  live(contextUri).query('show(name, uri), rows(track(uri, name, mediaTypeEnum))', (error, data) => {
    // Abort if a new play request has happened since this request started
    if (cancellationToken.isCanceled()) {
      return;
    } else if (error) {
      updateState(model); // Revert state
    } else {
      const context = {
        uri: data.show.uri,
        pages: [{
          tracks: data.rows.map(({ track }) => ({
            uri: track.uri,
            uid: track.uri,
            metadata: {
              'title': track.name,
              'album_title': data.show.name,
              'media.type': track.mediaTypeEnum === 1 ? 'audio' : 'video',
              // manifestId is not specifically queried above, since audio
              // tracks don't have that property, so it would then just stall on
              // that query. Querying for anything for the show will request all
              // the show data, so it should be available anyway.
              'media.manifest_id': live(track.uri).get('manifestId') || ''
            }
          }))
        }],
        metadata: {
          'zelda.context_uri': contextUri
        }
      };

      playbackControl.updateContext(context, updateContextError => {
        if (updateContextError) {
          updateState(model); // Revert state
        }
      });
    }
  }, showQueryTimeout);
}

/**
 * Request to start playback based on passed options.
 * If the request fails, it will revert the player model to the latest
 * state.
 *
 * @param {LiveObject} model The player live object.
 * @param {CancellationToken} cancellationToken
 * @param {Object} options Object with options and data of what to play.
 */
function playWithOptions(model, cancellationToken, options) {
  const contextUri = options.context;
  const resolverType = getPlaybackResolverType(contextUri);

  if (resolverType === TYPE_TRACK) {
    playbackControl.playTrack(contextUri, options, function (error) {
      if (error) {
        updateState(model); // Revert state
      }
    });
  } else if (resolverType === TYPE_CP_ALBUM_CONTEXT) {
    playbackControl.playFromResolver(contextUri, options, function (error) {
      if (error) {
        updateState(model); // Revert state
      }
    });
  } else if (resolverType === TYPE_ROWS) {
    const isSortedList = sortUriUtils.isValid(contextUri);

    // If it's a sorted list that is played by rows, we want to request all the track
    // URIs of the sorted list and then play that list of tracks. We will wait for all
    // tracks to be fetched and sorted, to allow clicking play on a media object in
    // Browse for example and have it play the stored sorted variant of the playlist.
    if (isSortedList) {
      getSortedRows(contextUri, function (error, rowsList) {
        if (error) {
          updateState(model); // Revert state
        } else {
          // Abort if a new play request has happened since this request started
          if (!cancellationToken.isCanceled()) {
            playRows(model, rowsList, options);
          }
        }
      });

      // Play any other context from the rows list
    } else {
      live(contextUri).query('rows(track(uri))', function (err) {
        if (!err && !cancellationToken.isCanceled()) {
          playRows(model, live(contextUri).get('rows'), options);
        }
      });
    }
  } else if (resolverType === TYPE_CP_RESOLVER_PLAYLIST) {
    playbackControl.playFromPlaylistResolver(contextUri, options, function (error) {
      if (error) {
        updateState(model); // Revert state
      }
    });
  } else if (resolverType === TYPE_CP_RESOLVER_COLLECTION) {
    playbackControl.playFromCollectionResolver(contextUri, options, function (error) {
      if (error) {
        updateState(model); // Revert state
      }
    });
  } else if (resolverType === TYPE_CONTEXT_OBJECT) {
    const context = contextDataStore[contextUri];
    playbackControl.playContext(context, options, function (error) {
      if (error) {
        updateState(model); // Revert state
      }
    });
  } else if (resolverType === TYPE_CP_CONTEXT) {
    const context = {
      url: `context://${contextUri}`,
      entity_uri: contextUri
    };

    playbackControl.playContext(context, options, function (error) {
      if (error) {
        updateState(model); // Revert state
      }
    });
  } else if (resolverType === TYPE_STATION_CONTEXT) {
    const station = live(contextUri);
    station.query('rows', function (err) {
      if (!err) {
        playbackControl.playContext(createStationPlayContext(station), createStationPlayOptions(station, options), function (error) {
          if (error) {
            updateState(model); // Revert state
          }
        });
        // Post message to create station in zlink
        (0, _messageProxy.messageProxy)({
          method: 'POST',
          uri: 'station-create',
          target: 'top',
          body: { stationUri: contextUri }
        });
      }
    });
  } else if (resolverType === TYPE_CP_ARTIST_CONTEXT) {
    playbackControl.playFromArtist(contextUri, options, function (error) {
      if (error) {
        updateState(model); // Revert state
      }
    });
  } else if (resolverType === TYPE_CONTEXT_EPISODE) {
    const episodeQueryTimeout = 3000;

    live(contextUri).query('name, mediaTypeEnum, show(name)', function (error, data) {
      if (error) {
        updateState(model); // Revert state
      } else {
        const context = {
          uri: contextUri,
          pages: [{
            tracks: [{
              uri: contextUri,
              metadata: {
                'title': data.name,
                'album_title': data.show.name,
                'media.type': data.mediaTypeEnum === 1 ? 'audio' : 'video',
                'media.manifest_id': live(contextUri).get('manifestId') || ''
              }
            }]
          }],
          restrictions: {
            disallow_toggling_repeat_context_reasons: ['disallow-video'],
            disallow_toggling_repeat_track_reasons: ['disallow-video'],
            disallow_toggling_shuffle_reasons: ['disallow-video']
          }
        };

        if (!options.player_options_override) {
          options.player_options_override = {};
        }
        // Avoid repeating context when playing episode
        // This might be removed in future when we have proper shows support
        options.player_options_override.repeating_context = false;
        options.player_options_override.repeating_track = false;

        playbackControl.playContext(context, options, function (playContextError) {
          if (playContextError) {
            updateState(model); // Revert state
          }
        });
      }
    }, episodeQueryTimeout);
  } else if (resolverType === TYPE_CONTEXT_SHOW) {
    const showQueryTimeout = 3000;
    live(contextUri).query('show(name, uri), rows(track(uri, name, mediaTypeEnum))', (error, data) => {
      if (error) {
        updateState(model); // Revert state
      } else {
        const context = {
          uri: data.show.uri,
          pages: [{
            tracks: data.rows.map(({ track }) => ({
              uri: track.uri,
              uid: track.uri,
              metadata: {
                'title': track.name,
                'album_title': data.show.name,
                'media.type': track.mediaTypeEnum === 1 ? 'audio' : 'video',

                // manifestId is not specifically queried above, since audio
                // tracks don't have that property, so it would then just stall on
                // that query. Querying for anything for the show will request all
                // the show data, so it should be available anyway.
                'media.manifest_id': live(track.uri).get('manifestId') || ''
              }
            }))
          }],
          restrictions: {
            disallow_toggling_repeat_context_reasons: ['disallow-show'],
            disallow_toggling_repeat_track_reasons: ['disallow-show'],
            disallow_toggling_shuffle_reasons: ['disallow-show']
          },
          metadata: {
            'zelda.context_uri': contextUri
          }
        };

        if (!options.player_options_override) {
          options.player_options_override = {};
        }

        options.player_options_override.repeating_context = false;
        options.player_options_override.repeating_track = false;
        options.player_options_override.shuffling_context = false;

        playbackControl.playContext(context, options, playContextError => {
          if (playContextError) {
            updateState(model); // Revert state
          }
        });
      }
    }, showQueryTimeout);
  }
}

/**
 * Request to start playback based on passed rows list and options.
 * If the request fails, it will revert the player model to the latest
 * state.
 *
 * @param {LiveObject} model The player live object.
 * @param {LiveList} rowsList The rows live list.
 * @param {Object} options Object with options and data of what to play.
 */
function playRows(model, rowsList, options) {
  playbackControl.playRows(rowsList, options, function (error) {
    if (error) {
      updateState(model); // Revert state
    }

    updatesUtils.listen(rowsList, options, function (updateOptions) {
      playbackControl.updateWithRows(rowsList, updateOptions, function (updateError) {
        if (updateError) {
          updateState(model); // Revert state
        }
      });
    });
  });
}

/**
 * Get the type of playback resolver to use for a certain context URI.
 *
 * @param {string} contextUri Context URI.
 *
 * @return {string} A resolver type.
 */
function getPlaybackResolverType(contextUri) {
  const contextType = URI.from(contextUri).type;

  const isTrack = contextType === URI.Type.TRACK;
  const isLocal = contextType === URI.Type.LOCAL;
  const isPlaylist = contextType === URI.Type.PLAYLIST;
  const isCollectionAlbum = contextType === URI.Type.COLLECTION_ALBUM;
  const isCollectionArtist = contextType === URI.Type.COLLECTION_ARTIST;
  const isPlaylistFolder = contextType === URI.Type.FOLDER;
  const isArtist = contextType === URI.Type.ARTIST;
  const isAlbum = contextType === URI.Type.ALBUM;
  const isSortedList = sortUriUtils.isValid(contextUri);
  const isFilteredList = filterUriUtils.isValid(contextUri);
  const isStation = isStationUri(contextUri);
  const isEpisode = contextType === URI.Type.EPISODE;
  const isShow = contextType === URI.Type.SHOW;

  if (isTrack || isLocal) {
    return TYPE_TRACK;
  }

  if (isPlaylist) {
    return TYPE_CP_RESOLVER_PLAYLIST;
  }

  if (isCollectionAlbum || isCollectionArtist) {
    return TYPE_CP_RESOLVER_COLLECTION;
  }

  if (isPlaylistFolder) {
    return TYPE_CP_CONTEXT;
  }

  if (isStation) return TYPE_STATION_CONTEXT;

  let originContextType;
  let originUri;

  if (isSortedList) {
    originUri = sortUriUtils.parse(contextUri).originUri;

    // If the sorted URI is in fact a filtered URI, the origin URI that _that_ is based on
    // needs to be taken into account when judging the originContextType.
    if (filterUriUtils.isValid(originUri)) originUri = filterUriUtils.parse(originUri).originUri;

    originContextType = URI.from(originUri).type;

    if (originContextType === URI.Type.PLAYLIST) {
      return TYPE_CP_RESOLVER_PLAYLIST;
    }

    if (originContextType === URI.Type.SHOW) {
      return TYPE_CONTEXT_SHOW;
    }

    return TYPE_ROWS;
  }

  if (isFilteredList) {
    // If the sorted URI is in fact a filtered URI, the origin URI that _that_ is based on
    // needs to be taken into account when judging the originContextType.
    originUri = filterUriUtils.parse(contextUri).originUri;
    originContextType = URI.from(originUri).type;

    if (originContextType === URI.Type.PLAYLIST) {
      return TYPE_CP_RESOLVER_PLAYLIST;
    }

    return TYPE_ROWS;
  }

  if (isEpisode) {
    return TYPE_CONTEXT_EPISODE;
  }

  if (isShow) {
    return TYPE_CONTEXT_SHOW;
  }

  const contextData = contextDataStore[contextUri];
  if (contextData) {
    return TYPE_CONTEXT_OBJECT;
  }

  // If it's a different URI, check if we have rows
  const rowsList = live(contextUri).get('rows');
  if (rowsList && rowsList.length) {
    return TYPE_ROWS;
  }

  // If it's an artist context but context object or rows were not defined
  if (isArtist) {
    return TYPE_CP_ARTIST_CONTEXT;
  }

  if (isAlbum) {
    return TYPE_CP_ALBUM_CONTEXT;
  }

  // This should not happen ;)
  return null;
}

/**
 * Get the live list for the rows of the sorted URI.
 *
 * @param {string} sortUri The URI of the sorted list.
 * @param {Function} callback Callback function where second argument is the
 *     sorted live list.
 */
function getSortedRows(sortUri, callback) {
  const playlistUri = sortUriUtils.getOriginUri(sortUri);

  // Get the rows list for the regular playlist.
  // We could have queried for the track of every row, but by not querying we
  // avoid the conversions from live objects to plain objects.
  live(playlistUri).get('rows', function (error, rows) {
    if (error) {
      callback(error);
    } else {
      // Get the live models for all rows.
      rows.get(0, rows.length, function (rowError) {
        if (rowError) {
          callback(error);
        } else {
          // When we know we have the rows, we can safely sort the list
          live(sortUri).get('rows', function (liveError, rowsList) {
            if (liveError) {
              callback(liveError);
            } else {
              // Finally return the sorted rows list
              callback(null, rowsList);
            }
          });
        }
      });
    }
  });
}

/**
 * Update the player model with the current data of the cosmos player model.
 *
 * @param {LiveObject} model The player live object.
 */
function updateState(model) {
  dataUtils.getPlayerState(function (error, data) {
    if (error) {
      if (global.console) console.error(error);
      return;
    }
    model.update(data);
  });
}

const regExp = exports.matches = /^spotify:player$/;
let registered;
let playerSubscription;
let cancelPlayerErrorSubscription;
let abbaSubscription;

exports.register = function () {
  if (registered) return;
  registered = true;

  if (!abbaSubscription) {
    abbaSubscription = abba.subscribe('windowed-playlist-show-tracklist', function (err, cell) {
      if (err) return;
      playlistResolver.setWindowedPlaylistShowTracklistCell(cell);
    });
  }
  (0, _formatLists.init)();

  live.subscribe(regExp, 'play', onPlay);
  live.subscribe(regExp, 'pause', onPause);
  live.subscribe(regExp, 'resume', onResume);
  live.subscribe(regExp, 'skip-previous', onSkipPrev);
  live.subscribe(regExp, 'skip-next', onSkipNext);
  live.subscribe(regExp, 'update-context', onUpdateContext);
  live.subscribe(regExp, 'update-show-context', onUpdateShowContext);
  live.subscribe(regExp, 'update', onUpdate);
  live.subscribe(regExp, 'wait', onWait);
  live.subscribe(regExp, 'sync-position', onSync);

  playerSubscription = dataUtils.subscribeForPlayerState(onPlayerStateUpdate);

  // This is a workaround the fact that some errors aren't reported to the
  // callbacks passed to Player API when we intereact normally with it.
  //
  // Here we observe all errors. If we know, by means of observation, that an
  // error is not being handled properly elsewhere, we revert the live-model
  // state when the error is reported here.
  cancelPlayerErrorSubscription = playerApi.onError(function (error, response) {
    if (error) {
      console.error(error);
      return;
    }
    const body = response.getJSONBody();
    switch (body.error) {
      case 'one_track_unplayable':
      case 'one_track_unplayable_auto_stopped':
      case 'all_tracks_unplayable_auto_stopped':
        // Revert state
        exports._syncPlayerModelState();
        break;
      default:
        break;
    }
  });
};

exports._syncPlayerModelState = function () {
  const model = live('spotify:player');
  updateState(model);
};

exports.unregister = function () {
  if (!registered) return;
  registered = false;

  live.unsubscribe(regExp, 'play', onPlay);
  live.unsubscribe(regExp, 'pause', onPause);
  live.unsubscribe(regExp, 'resume', onResume);
  live.unsubscribe(regExp, 'skip-previous', onSkipPrev);
  live.unsubscribe(regExp, 'skip-next', onSkipNext);
  live.unsubscribe(regExp, 'update-context', onUpdateContext);
  live.unsubscribe(regExp, 'update-show-context', onUpdateShowContext);
  live.unsubscribe(regExp, 'update', onUpdate);
  live.unsubscribe(regExp, 'wait', onWait);
  live.unsubscribe(regExp, 'sync-position', onSync);

  playerSubscription.unsubscribe();
  if (cancelPlayerErrorSubscription) {
    cancelPlayerErrorSubscription();
  }
  if (abbaSubscription) {
    abbaSubscription.cancel();
    abbaSubscription = null;
  }
  playerSubscription = null;
};

exports.setContextData = function (contextUri, contextData) {
  contextDataStore[contextUri] = contextData;
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../../libs/abba":74,"../../../libs/cancellation-token-source":87,"../../../libs/message-proxy":228,"../../../libs/playlist-utils/format-lists":235,"../../live":210,"../../live-filter-uri":156,"../../live-sort-uri":208,"../station":196,"../station/create-play-context":197,"../station/create-play-options":198,"./control":178,"./data":180,"./player-api":182,"./playlist-resolver":183,"./updates":184,"spotify-liburi":730}],182:[function(require,module,exports){
(function (global){
'use strict';

var _data = require('./data');

var _data2 = _interopRequireDefault(_data);

var _cosmos = require('../util/cosmos');

var _cosmos2 = _interopRequireDefault(_cosmos);

var _live = require('../../live');

var _live2 = _interopRequireDefault(_live);

var _liveSortUri = require('../../live-sort-uri');

var _liveSortUri2 = _interopRequireDefault(_liveSortUri);

var _liveFilterUri = require('../../live-filter-uri');

var _liveFilterUri2 = _interopRequireDefault(_liveFilterUri);

var _v = require('spotify-player/lib/v2');

var _v2 = _interopRequireDefault(_v);

var _spotifyCosmosApi = require('spotify-cosmos-api');

var _spotifyCosmosApi2 = _interopRequireDefault(_spotifyCosmosApi);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

let player; /**
             * @module live-models/player/player-api
             * @private
             */

const playerConstructedCallbacks = [];

function onPlayerConstructed() {
  let callback = playerConstructedCallbacks.pop();
  while (callback) {
    callback(player);
    callback = playerConstructedCallbacks.pop();
  }
}

function getPlayer(callback) {
  playerConstructedCallbacks.push(callback);
  if (player) {
    onPlayerConstructed();
    return;
  }

  if (playerConstructedCallbacks.length > 1) {
    // We're already busy producing a player
    return;
  }

  // One of a fixed list of features, since this is used for logging. It should
  // be the readable name of the feature, for example "radio", "album", "playlist"
  // and it should be the same for a given feature across platforms.
  // The list is probably this:
  // https://ghe.spotify.net/datainfra/log-parser/blob/master/spotify/log_parser/messages_specs.py#L29
  let featureIdentifier;

  // The version of the feature itself
  let featureVersion;

  const appManifest = global.__spotify && global.__spotify.app_manifest;
  if (appManifest) {
    featureVersion = appManifest.BundleVersion || null;
    featureIdentifier = appManifest.BundleIdentifier || null;
  }

  // Hard coded overwrites for apps where we needed to choose a new
  // BundleIdentifier for compat reasons
  // Todo: This is incomplete and would better be fixed by letting features
  // provide values specifically for this. See KM-6973.
  const radioFeatureIdentifier = 'radio';
  const overwrites = {
    'station': radioFeatureIdentifier,
    'stations': radioFeatureIdentifier,
    'radio-hub': radioFeatureIdentifier,
    'daily-mix-hub': radioFeatureIdentifier
  };

  if (featureIdentifier && overwrites[featureIdentifier]) featureIdentifier = overwrites[featureIdentifier];

  // The uri of the view that's supposed to show the context where the track is
  // playing, including arguments. That's called referrer in terms of the
  // player live model.
  _data2.default.getReferrer(function (error, viewUri, baseUri) {
    if (error && console) {
      console.error('The player API could not be initialized due to a missing referrer!', error);
      return;
    }

    const options = baseUri ? { referrerIdentifier: baseUri } : null;

    player = new _v2.default.Player(_spotifyCosmosApi2.default.resolver, viewUri, featureIdentifier, featureVersion, options);
    onPlayerConstructed();

    // The viewUri on this player instance can't ever change, so since we cache
    // it we have to destroy it when arguments change.
    (0, _live2.default)('spotify:application').on('update', function (data) {
      if ('arguments' in data) {
        player = null;
      }
    });
  });
}

function play(tracks, playOptions, callback) {
  getPlayer(function (p) {
    const context = {
      pages: [{ tracks }],
      metadata: {
        'zelda.context_uri': playOptions.context
      },
      entity_uri: getOriginUri(playOptions.context)
    };

    const options = {};
    if (typeof playOptions.index === 'number') {
      options.skip_to_index = {
        page: 0,
        track: playOptions.index
      };
    } else if (playOptions.uid || playOptions.uri) {
      options.skip_to = {};
      if (playOptions.uid) {
        options.skip_to.track_uid = playOptions.uid;
      } else if (playOptions.uri) {
        options.skip_to.track_uri = playOptions.uri;
      }
    }

    p.play(context, options, callback);
  });
}

function playContext(context, playOptions, callback) {
  if (playOptions.uid || playOptions.uri || playOptions.page) {
    playOptions.skip_to = {};
    if (playOptions.uid) {
      playOptions.skip_to.track_uid = playOptions.uid;
    } else if (playOptions.uri) {
      playOptions.skip_to.track_uri = playOptions.uri;
    }

    // Together with UID send page_index property, so Connect can
    // figure out where to look for a track that needs to
    // be played. (Connect doesn't support UIDs at the moment).
    if (playOptions.page) {
      playOptions.skip_to.page_index = playOptions.page;
    }
  } else if (playOptions.range) {
    playOptions.skip_to_index = {
      page: 0,
      track: playOptions.range.start
    };
  } else if (typeof playOptions.index === 'number') {
    playOptions.skip_to_index = {
      page: 0,
      track: playOptions.index
    };
  }

  getPlayer(function (p) {
    p.play(context, playOptions || {}, callback);
  });
}

function updateContext(context, callback) {
  getPlayer(function (p) {
    p.update(context, callback);
  });
}

function update(tracks, playOptions, callback) {
  getPlayer(function (p) {
    // Todo: When currently playing from the new playlist and folder resolver,
    // uids provided by the core resolver need to be used.

    const context = {
      pages: [{ tracks }],
      metadata: {
        'zelda.context_uri': playOptions.context
      },
      entity_uri: getOriginUri(playOptions.context)
    };

    p.update(context, callback);
  });
}

function playFromResolver(contextUri, playOptions, callback) {
  getPlayer(p => {
    _cosmos2.default.sanitizeURL(contextUri, (error, uri) => {
      if (error) {
        if (callback) callback(error);
        return;
      }

      const context = {
        uri,
        url: `context://${encodeURI(uri)}`
      };

      let options = null;
      if (typeof playOptions.index === 'number') {
        options = {
          skip_to_index: {
            page: 0,
            track: playOptions.index
          }
        };
      } else if (playOptions.trackUri) {
        options = {
          skip_to_index: {
            track_uri: playOptions.trackUri
          }
        };
      }

      if (typeof playOptions.seekTo === 'number') {
        options.seek_to = playOptions.seekTo;
      }

      p.play(context, options, callback);
    });
  });
}

let cancelSubscribe;

function subscribe(callback, options = {}) {
  cancelSubscribe = false;

  let subscription;
  getPlayer(p => {
    if (cancelSubscribe) return;
    subscription = p.subscribe((error, response) => {
      if (error) {
        callback(error);
      } else {
        callback(null, addContext(response.getJSONBody()));
      }
    }, options);
  });

  return {
    unsubscribe: () => {
      cancelSubscribe = true;
      if (!subscription) return;
      subscription.cancel();
      subscription = null;
    }
  };
}

let onErrorSubscription;

function onError(callback) {
  getPlayer(p => {
    onErrorSubscription = p.onError(callback);
  });

  return () => {
    if (onErrorSubscription) {
      onErrorSubscription.cancel();
      onErrorSubscription = null;
    }
  };
}

function getState(callback) {
  getPlayer(p => {
    p.getState((error, response) => {
      if (error) {
        callback(error, null);
      } else {
        callback(null, addContext(response.getJSONBody()));
      }
    });
  });
}

function pause(callback) {
  getPlayer(p => {
    p.pause(callback);
  });
}

function resume(callback) {
  getPlayer(p => {
    p.resume(callback);
  });
}

function clear() {
  player = null;
}

/**
 * Adds the context to a given player state.
 *
 * @param {Object} data Input data in the format of the cosmos player live model (v2).
 * @param {string?} optUri Optional URI to be used in first place.
 * @return {Object} Data object.
 */
function addContext(data, optUri) {
  const uri = optUri || // We provide the URI of the context.
  data.context_metadata['zelda.context_uri'] || // Best case scenario.
  data.context_uri || // No special context, use the standard one.
  data.track && data.track.uri || // If a track is present, use it.
  null; // Nothing found; there's nothing being played.

  const context = getOriginUri(uri);

  // Avoid writing it into the context. People should always use the context object.
  delete data.context_uri;

  if (uri) {
    data.variant = { uri };
    data.context = { uri: context };
  } else {
    data.variant = null;
    data.context = null;
  }

  // Track and index are flagged as "optional", meaning that when the player is stopped
  // will not be returned. Because of the way "live" works (waiting for properties until
  // they're set), it could happen that we wait forever for "track" and "index". For
  // aoviding this, we set them both to "null".
  data.track = data.track || null;
  data.index = data.index || null;

  if (data.track) {
    data.uid = data.track.uid;
    delete data.track.uid;
  } else {
    data.uid = null;
  }

  return removeUnderscores(data);
}

/**
 * Returns the original URI from a given filtered & sorted URI. For example, given
 * this URL:
 *
 * spotify:internal:sortlist:desc:track(name):internal:filterlist:playable%20eq%20true:user:myuser:playlist:7h5o3lf1ithsxec0wgjznj
 *
 * This method would return:
 *
 * spotify:user:myuser:playlist:7h5o3lf1ithsxec0wgjznj
 *
 * @param {string} uri An internal URI format with sort and/or query parts.
 * @return {string} The original URI.
 */
function getOriginUri(uri) {
  if (!uri) {
    return uri;
  }

  const sorted = _liveSortUri2.default.parse(uri);
  let newUri = uri;
  if (sorted) {
    newUri = sorted.originUri;
  }

  const filtered = _liveFilterUri2.default.parse(newUri);
  if (filtered) {
    newUri = filtered.originUri;
  }

  return newUri;
}

/**
 * Transforms C++ syntax for variable names and keys (underscore_names) to the JS format
 * (camelCase).
 */
function removeUnderscores(data) {
  let transformedKey;

  for (const key in data) {
    if (!data.hasOwnProperty(key)) continue;

    transformedKey = key.replace(/_(.)/g, (str, chr) => chr.toUpperCase());

    if (data[key] instanceof Object) {
      data[transformedKey] = removeUnderscores(data[key]);
    } else {
      data[transformedKey] = data[key];
    }

    if (transformedKey !== key) {
      delete data[key];
    }
  }

  return data;
}

exports.play = play;
exports.playFromResolver = playFromResolver;
exports.playContext = playContext;
exports.pause = pause;
exports.resume = resume;
exports.update = update;
exports.subscribe = subscribe;
exports.onError = onError;
exports.getState = getState;
exports.clear = clear;
exports.addContext = addContext;
exports.updateContext = updateContext;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../live":210,"../../live-filter-uri":156,"../../live-sort-uri":208,"../util/cosmos":206,"./data":180,"spotify-cosmos-api":720,"spotify-player/lib/v2":731}],183:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.setWindowedPlaylistShowTracklistCell = setWindowedPlaylistShowTracklistCell;
exports.play = play;
const playlistData = require('../../../libs/playlist-utils/playlist-data');
const isPlaylist2Shows = require('../../../libs/playlist-utils').isPlaylist2Shows;
const cosmos = require('../util/cosmos');
let windowedPlaylistShowTracklistCell = 'Control';
const live = require('../../../libs/live');
const wrappedUri = require('../../../libs/live-wrapped-uri');

function setWindowedPlaylistShowTracklistCell(cell) {
  windowedPlaylistShowTracklistCell = cell;
}

function play(contextUri, options, callback) {
  checkIfPlaylistsToShowsContext(contextUri).then(includeEpisodes => {
    const resolverUrl = playlistData.getCorePlaylistUrl(contextUri, {
      includeEpisodes,
      type: 'play'
    }, windowedPlaylistShowTracklistCell);

    const postObject = { url: resolverUrl };
    if (options) {
      postObject.body = options;
    }

    cosmos.post(postObject, callback);
  });
}

function checkIfPlaylistsToShowsContext(contextUri) {
  return new Promise(resolve => {
    const parsedUri = wrappedUri.parse(contextUri);
    const originUri = parsedUri ? parsedUri.originUri : contextUri;
    live(originUri).query('formatListType', (error, { formatListType }) => {
      resolve(isPlaylist2Shows(formatListType));
    });
  });
}

},{"../../../libs/live":210,"../../../libs/live-wrapped-uri":209,"../../../libs/playlist-utils":236,"../../../libs/playlist-utils/playlist-data":239,"../util/cosmos":206}],184:[function(require,module,exports){
/**
 * @module live-models/player/updates
 * @private
 */
'use strict';

let lastRowsList;
let lastRowsListUri;
let lastRowsListHandler;
let lastRowsListReferrer;
let playerRowKey;
let playerKeys;

/**
 * Listen for updates on a rows list and update the player when
 * changes happen.
 *
 * @param {LiveList} rowsList A live list of rows.
 * @param {Object} options Object with options and data of what to play.
 * @param {Function} handler A handler function that gets called whenever
 *     the list is updated. Gets called with one argument: an options object.
 */
function listen(rowsList, options, handler) {
  if (lastRowsList) {
    removeRowsListener();
  }

  lastRowsList = rowsList;
  lastRowsListUri = options.context;
  lastRowsListReferrer = options.contextPlayerReferrer;

  lastRowsListHandler = function () {
    // Todo: Only add this for TPM.
    options.index = getPlayingAndUpdateIndicesInList(rowsList).update;
    handler(options);
  };

  rowsList.on('update', lastRowsListHandler);
}

/**
 * Check if the last added rows listener is still valid for the current
 * player state, and clean up the update handler if it's not valid.
 *
 * @param {LiveObject} model The player live object.
 */
function clean(model) {
  if (!lastRowsListHandler) return;

  const context = model.get('variant');

  // Remove listener if the player context is no longer the same
  if ((context && context.uri) !== lastRowsListUri) {
    removeRowsListener();

    // Remove listener if the player referrer is no longer the same
  } else {
    const origin = model.get('playOrigin');
    const playerReferrer = origin && origin.get('referrerIdentifier');

    if (playerReferrer !== lastRowsListReferrer && !model.get('contextUpdatedCrossFrame')) {
      removeRowsListener();
    }
  }
}

/**
 * Save which item is currently playing.
 *
 * @param {number} index The index for the playing row.
 */
function setPlayingIndex(index, optRowsList) {
  if (!lastRowsList && !optRowsList) {
    return;
  }

  // If the index is out of bounds (e.g. is -1 because the track is not found),
  // then just keep the old playerRowKey.
  if (index < 0) {
    return;
  }

  const list = optRowsList || lastRowsList;

  playerRowKey = list.keys[index] || null;
  playerKeys = list.keys.slice();
}

/**
 * Remove the saved rows listener data.
 */
function removeRowsListener() {
  if (lastRowsList) {
    lastRowsList.off('update', lastRowsListHandler);
  }

  lastRowsList = null;
  lastRowsListUri = '';
  lastRowsListHandler = null;
  lastRowsListReferrer = '';
}

/**
 * Get the index of the playing row in the provided list.
 *
 * @param {LiveList} rowsList A live list of rows.
 *
 * @return {number} The index of the playing row, or -1 if not found.
 */
function getPlayingAndUpdateIndicesInList(rowsList) {
  if (!playerRowKey) return { update: -1, playing: -1 };

  // Find the currently playing row in the new list
  const playingIndexInNewList = rowsList.keys.indexOf(playerRowKey);
  let updateIndex = playingIndexInNewList;

  // If the playing row was not found in the new list, loop through the row
  // keys of the list that the player is currently playing from, and try to
  // find the next row key that exist both in the currently playing list and
  // the new list.
  if (playingIndexInNewList === -1) {
    const indexInPlayerList = playerKeys.indexOf(playerRowKey);
    for (let i = indexInPlayerList, l = playerKeys.length; i < l; i++) {
      updateIndex = rowsList.keys.indexOf(playerKeys[i]);
      if (updateIndex > -1) {
        // Index must be -1 since we've moved down several rows. The cosmos
        // player wants the index of the next row, so before passing it to
        // cosmos, the index will be incremented again.
        updateIndex--;

        break;
      }
    }
  }

  return {
    update: updateIndex,
    playing: playingIndexInNewList
  };
}

/**
 * Check if the player is currently playing from a rows list.
 *
 * @param {string} uri Context URI. If passed, it checks for that specific URI.
 *
 * @return {boolean} True if it is playing from a rows list, false otherwise.
 */
function isPlayingFromRowsContext(uri) {
  if (uri) return lastRowsListUri === uri;

  return !!lastRowsList;
}

exports.setPlayingIndex = setPlayingIndex;
exports.listen = listen;
exports.clean = clean;
exports.getPlayingAndUpdateIndicesInList = getPlayingAndUpdateIndicesInList;
exports.isPlayingFromRowsContext = isPlayingFromRowsContext;

},{}],185:[function(require,module,exports){
(function (global){
'use strict';

var _live = require('../live');

var _live2 = _interopRequireDefault(_live);

var _offlineStatus = require('../playlist-utils/offline-status');

var _bridge = require('../bridge');

var _playlistUtils = require('../playlist-utils');

var _messageProxy = require('../message-proxy');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function onBroadcast(error, body) {
  if (error) {
    if (global.console) console.error(error);
    return;
  }

  (0, _live2.default)(body.uri).update(body);
}

function onWait(model, properties) {
  const policy = {};
  if (properties.includes('name')) policy.name = true;
  if (properties.includes('description')) policy.description = true;
  if (properties.includes('image') || properties.includes('annotatedImage')) policy.picture = true;
  if (properties.includes('added')) policy.followed = true;
  if (properties.includes('formatListType')) policy.formatListType = true;
  if (properties.includes('annotatedImage')) policy.pictureFromAnnotate = true;
  if (properties.includes('owner')) policy.owner = { link: true, username: true, name: true };
  if (Object.keys(policy).length === 0) return;

  (0, _playlistUtils.subscribeToMetadata)(model.uri, policy, (error, data) => {
    if (error) {
      console.error(error);
      return;
    }

    if (data && 'picture' in data) {
      data.image = data.picture;
      delete data.picture;
    }

    if (data && 'pictureFromAnnotate' in data) {
      data.annotatedImage = data.pictureFromAnnotate && data.image || null;
      delete data.pictureFromAnnotate;
    }

    if (data && 'offline' in data) {
      data.offlineStatus = data.offline;
      data.shouldBeOffline = (0, _offlineStatus.shouldBeOffline)(data.offline);
      delete data.offline;
    }

    if (properties.includes('formatListType')) {
      data.formatListType = data.formatListType || 'playlist';
    }

    model.update(data);
  });
}

function onHeart(model, trackUri) {
  const entityUri = _playlistUtils.formatListUtils.originalPlaylistUri(model.get('uri'));
  (0, _live2.default)(entityUri).get('formatListAttributes', function (err, res) {
    if (err) {
      console.error(err);
      return;
    }

    if (res.get('like-feedback-available') === '1') {
      (0, _messageProxy.messageProxy)({
        method: 'POST',
        uri: 'format-list-heart',
        body: {
          entityUri,
          trackUri
        }
      });
    }
  });
}

function onUndoFeedback(model, trackUri) {
  const entityUri = _playlistUtils.formatListUtils.originalPlaylistUri(model.get('uri'));
  (0, _live2.default)(entityUri).get('formatListAttributes', function (err, res) {
    if (err) {
      console.error(err);
      return;
    }

    if (res.get('like-feedback-available') === '1') {
      (0, _messageProxy.messageProxy)({
        method: 'POST',
        uri: 'format-list-undo-feedback',
        body: {
          entityUri,
          trackUri
        }
      });
    }
  });
}

const matches = exports.matches = /^spotify:(.*)user:(.*):playlist/;

let broadcastSubscriptionCancel;
let registered;
exports.register = function () {
  if (registered) return;
  registered = true;

  _live2.default.subscribe(matches, 'wait', onWait);
  _live2.default.subscribe(matches, 'heart', onHeart);
  _live2.default.subscribe(matches, 'undo-heart', onUndoFeedback);
  _live2.default.subscribe(matches, 'undo-ban', onUndoFeedback);

  broadcastSubscriptionCancel = (0, _bridge.cosmosJSON)({ method: 'SUB', uri: 'sp://messages/v1/playliststate' }, onBroadcast);
};

exports.unregister = function () {
  if (!registered) return;
  registered = false;

  _live2.default.unsubscribe(matches, 'wait', onWait);

  broadcastSubscriptionCancel();
  broadcastSubscriptionCancel = null;
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../bridge":86,"../live":210,"../message-proxy":228,"../playlist-utils":236,"../playlist-utils/offline-status":237}],186:[function(require,module,exports){
(function (global){
/**
 * @module live-models/session-storage
 */
'use strict';

const forOwn = require('mout/object/forOwn');
const combine = require('mout/array/combine');
const remove = require('mout/array/remove');
const contains = require('mout/array/contains');

const URI = 'spotify:session-storage';
const live = require('../live');
const cosmos = require('./util/cosmos');
const endpoints = {
  broadcast: 'sp://messages/v1/session-storage'
};

let waiting = [];

function onInit(model) {
  // Set a flag for showing that the model has been implemented and
  // registered. This is so that we can check this in player without
  // making a breaking change.
  model.update({ implemented: true });
}

function onWait(model, properties) {
  // Ask the top frame to broadcast the properties.
  // Values will be null when they weren't stored.
  waiting = combine(waiting, properties);
  global.top.postMessage({
    type: 'session_storage',
    name: 'broadcast_session_storage',
    data: properties
  }, '*');
}

function onPublish(model, properties) {
  // Tell the top frame to persist and broadcast
  global.top.postMessage({
    type: 'session_storage',
    name: 'set_session_storage',
    data: properties
  }, '*');

  // Optimistic update
  model.update(properties);
}

function onBroadcast(error, event) {
  const update = {};
  const model = live(URI);

  forOwn(event.body, function (value, key) {
    // Update model if this instance of storage knows that the model waits for it
    const isWaiting = contains(waiting, key);

    // Or if the model has a potentially outdated value in the live cache
    const hasKey = model.get(key) !== undefined;

    if (isWaiting || hasKey) update[key] = value;
    if (isWaiting) remove(waiting, key);
  });
  model.update(update);
}

let broadcastSubscription;
const regExp = exports.matches = new RegExp(`^${URI}$`);
let registered;

exports.register = function () {
  if (registered) return;
  registered = true;

  live.subscribe(regExp, 'init', onInit);
  live.subscribe(regExp, 'wait', onWait);
  live.subscribe(regExp, 'publish', onPublish);
  broadcastSubscription = cosmos.subscribe({ url: endpoints.broadcast }, onBroadcast);
};

exports.unregister = function () {
  if (!registered) return;
  registered = false;

  live.unsubscribe(regExp, 'init', onInit);
  live.unsubscribe(regExp, 'wait', onWait);
  live.unsubscribe(regExp, 'publish', onPublish);

  if (broadcastSubscription) {
    broadcastSubscription.cancel();
    broadcastSubscription = null;
  }
  waiting.length = 0;
};

exports._endpoints = endpoints;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../live":210,"./util/cosmos":206,"mout/array/combine":442,"mout/array/contains":443,"mout/array/remove":452,"mout/object/forOwn":477}],187:[function(require,module,exports){
'use strict';

var _live = require('../live');

var _live2 = _interopRequireDefault(_live);

var _cosmos = require('./util/cosmos');

var _cosmos2 = _interopRequireDefault(_cosmos);

var _spotifyLiburi = require('spotify-liburi');

var _spotifyLiburi2 = _interopRequireDefault(_spotifyLiburi);

var _liveWrappedUri = require('../live-wrapped-uri');

var _liveWrappedUri2 = _interopRequireDefault(_liveWrappedUri);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const regExp = exports.matches = /^spotify:((internal:sortlist:(asc|desc):([^:]*):(internal:filterlist:[^:]*):)|(internal:sortlist:(asc|desc):([^:]*):)|(internal:filterlist:[^:]*):)?show:[^:]+$/;
let registered;
const subscribingForUris = [];

exports.register = () => {
  if (registered) return;
  registered = true;

  subscribingForUris.length = 0;

  _live2.default.subscribe(regExp, 'wait', onWait);
};

exports.unregister = () => {
  if (!registered) return;
  registered = false;

  subscribingForUris.length = 0;

  _live2.default.unsubscribe(regExp, 'wait', onWait);
};

function onWait(model, properties) {
  if (!properties.includes('show') && !properties.includes('rows')) {
    return;
  }

  if (subscribingForUris.includes(model.uri)) {
    return;
  }

  subscribingForUris.push(model.uri);

  let showUri = model.uri;
  let additionalFilter = '';
  let sort = 'number,publishDate,name';

  const parsed = _liveWrappedUri2.default.parse(model.uri);

  if (parsed) {
    showUri = parsed.originUri;

    if (parsed.sort && parsed.sort.query) {
      sort = sortToString(parsed.sort);
    }

    if (parsed.filter && parsed.filter.query) {
      additionalFilter = filterQueryToString(parsed.filter.query);
    }
  }

  const showId = _spotifyLiburi2.default.from(showUri).getBase62Id();

  _cosmos2.default.subscribe({
    url: `sp://core-show/unstable/show/${showId}?filter=available eq true${additionalFilter}&sort=${sort}`
  }, (error, data) => {
    if (error) throw error;
    const { show, items } = data.body;

    // Add a URI property so the data is put into the live cache
    show.uri = show.link;
    items.forEach(item => {
      item.uri = item.link;
      item.show.uri = item.show.link;
    });

    // we have to map the items array this way to enable row selection
    model.update({
      show,
      rows: items.map(item => ({ track: item })),

      // This timestamp will cause an 'update' event to be sent out even when
      // the real diff was just something nested.
      lastUpdateTimestamp: Date.now()
    });
  });
}

/**
 * @param  {Object} parsedSort Object with .direction and .query
 * @return {String}
 */
function sortToString(parsedSort) {
  const direction = parsedSort.direction.toUpperCase();
  let sort = 'number,publishDate,name';

  switch (parsedSort.query) {
    case 'track(name)':
      sort = `name ${direction}`;
      break;
    case 'track(duration)':
      sort = `length ${direction}`;
      break;
    case 'track(timeLeft)':
      {
        sort = `progress ${direction}`;
        break;
      }
    case 'timeSinceAdded,track(album(name),disc,number)':
      sort = `number ${direction},publishDate ${direction},name ${direction}`;
      break;
    default:
      console.error('Invalid query', parsedSort.query);
      break;
  }

  return sort;
}

/**
 * @param  {String} parsedFilterQuery
 * @return {String}
 */
function filterQueryToString(parsedFilterQuery) {
  if (parsedFilterQuery.length > 0) {
    return `,${parsedFilterQuery}`;
  }
  return '';
}

},{"../live":210,"../live-wrapped-uri":209,"./util/cosmos":206,"spotify-liburi":730}],188:[function(require,module,exports){
"use strict";

/**
 * This module splits up a list into many chunks.
 *
 * @module live-models/sorting/chunker
 * @private
 */

/**
 * Splits up an array of data into smaller chunks.
 *
 * @param {Array} list The array to be split up.
 * @param {number=} size Optional size of each chunk.
 *
 * @return {Array} Array of chunks, where each chunk is an array of data.
 */
module.exports = function (list, size = 50) {
  function split(array, segments = 2) {
    const results = [];
    if (array === null) {
      return results;
    }

    const minLength = Math.floor(array.length / segments);
    const remainder = array.length % segments;
    let i = 0;
    const len = array.length;
    let segmentIndex = 0;
    let segmentLength;

    while (i < len) {
      segmentLength = minLength;
      if (segmentIndex < remainder) {
        segmentLength++;
      }

      results.push(array.slice(i, i + segmentLength));

      segmentIndex++;
      i += segmentLength;
    }

    return results;
  }

  const chunkCount = Math.ceil(list.length / size);
  const chunks = split(list, chunkCount);

  return chunks;
};

},{}],189:[function(require,module,exports){
/**
 * This file contains transformations from legacy sort queries to new sort
 * queries. We need this because when a user sorts by a certain column, we store
 * the full URI for that list and the sort query is part of the URI. Whenever
 * we change the sort query of a column, we will break sorting for users who
 * have a stored sort state with the old query. That's why we need to maintain
 * this conversion from old to new to make the right list load for all users.
 *
 * When to remove a conversion needs to be weighed case by case I guess. If a
 * user sorts by a certain column and doesn't launch the client for three months
 * and we change the query during that time, it's expected to still work for
 * that user when logging in the next time.
 *
 * History of this file is in the play-desktop app,
 * https://ghe.spotify.net/zelda/client-zelda-js/blob/master/apps/playlist/src/legacy-sort-uris.js
 */
'use strict';

exports.legacyQueries = {
  // Change date: 2015-03-16
  'track(album(name))': 'track(album(name),disc,number)',
  // Change date: 2015-03-16
  'track(artists(name))': 'track(artists[0:1](name),album(name),disc,number)',
  // Change date: 2015-03-17, value changed 2015-07-14 because we introduced the conversion below.
  'track(addedBy)': 'addedBy(name)',
  // Change date: 2015-07-14
  'track(addedBy(name))': 'addedBy(name)',
  // Change date: 2015-06-26
  'timeSinceAdded': 'timeSinceAdded,track(album(name),disc,number)'
};

},{}],190:[function(require,module,exports){
'use strict';

/**
 * This module helps posting chunked data to/from a worker.
 *
 * @module live-models/sorting/poster
 * @private
 */

/**
 * Posts data from/to a worker.
 *
 * @param {Object} worker A web worker.
 * @param {Array} chunks Array of split up data.
 * @param {number} index Index of the current chunk to post. Initiate the
 *     poster with 0, and it posts all data sequentially until all data
 *     is posted.
 * @param {string} id An ID for the full payload.
 */
module.exports = function poster(worker, chunks, index, id) {
  'use strict';

  const data = {
    items: chunks[index],
    id: id
  };

  if (index === chunks.length - 1) {
    data.last = true;
  }

  worker.postMessage(data);

  if (!data.last) {
    poster(worker, chunks, index + 1, id);
  }
};

},{}],191:[function(require,module,exports){
(function (global){
'use strict';

/**
 * This module sorts an array of data in the best possible way.
 * If Web Workers are supported, it will spawn new workers and
 * sort on different threads to speed it up.
 *
 * @module live-models/sorting/sort
 * @private
 */

const chunker = require('./chunker');
const poster = require('./poster');
const sorter = require('./sorter');
const sortWorker = require('./sortworker');
const defer = require('../../../libs/prime/defer');

let workerFile;
const workers = {};
const callbacks = {};
const waitingForReset = {};

// A generated ID will be stored here for each sorted list. Whenever a sorted
// list is asked to resort, a new ID will be generated and set here for that
// list. That allows us to cancel a previous sort if a newer one has started
// before the old one finished.
let idCounter = 0;
const lastIds = {};

/**
 * The local sorter that sorts on the main thread.
 *
 * @param {string} sortUri URI of the sorted list.
 * @param {Array.<Object>} items Array of items to sort. Each item is
 *     an object with the properties `data` and `key`. The `data`
 *     property is an array of values to sort on. The `key` property
 *     is a string for the row ID.
 * @param {Function} callback Async callback where the data is the array of
 *     sorted items.
*/
function localSorter(sortUri, items, callback) {
  const sortedItems = sorter(items);

  // Saving the callback as the latest callback for this sorted list
  // will allow us to only respond with the latest sorted values (if
  // multiple sort calls were made at the same time).
  callbacks[sortUri] = callback;

  // Make the callback async
  defer.immediate(function () {
    // Only allow the latest callback to run
    if (callback === callbacks[sortUri]) {
      delete callbacks[sortUri];

      callback(null, sortedItems);
    }
  });
}

/**
 * The Web Worker sorter.
 *
 * @param {string} sortUri URI of the sorted list.
 * @param {Array.<Object>} items Array of items to sort. Each item is
 *     an object with the properties `data` and `key`. The `data`
 *     property is an array of values to sort on. The `key` property
 *     is a string for the row ID.
 * @param {Function} callback Async callback where the data is the array of
 *     sorted items.
 */
function workerSorter(sortUri, items, callback) {
  let worker = workers[sortUri];

  // If we already have a worker for this sorted list, reset that worker
  // and tell it to sort the new data. By saving the callback we make sure
  // that the original worker event handler will run the latest callback
  // when the sorting is done.
  if (worker) {
    callbacks[sortUri] = callback;
    waitingForReset[sortUri] = (waitingForReset[sortUri] || 0) + 1;
    const id = (++idCounter).toString(36);
    lastIds[sortUri] = id;
    worker.postMessage({ reset: true, newId: id });
    sendItemsToWorker(items, worker, id);
    return;
  }

  worker = new Worker(workerFile);
  workers[sortUri] = worker;
  callbacks[sortUri] = callback;

  const id = (++idCounter).toString(36);
  lastIds[sortUri] = id;
  sendItemsToWorker(items, worker, id);

  const result = { items: [] };

  worker.addEventListener('message', function (event) {
    onWorkerMessage(event, result, sortUri);
  }, false);
}

/**
 * Event handler for receiving a message from a worker.
 * This will handle collecting all chunks of data and post it to the latest
 * callback when all chunks have been received.
 *
 * @param {Event} event An event object from the worker 'message' event.
 * @param {Object} result An object with a property `items` for the sorted items.
 * @param {string} sortUri The sort URI for the current sort.
 */
function onWorkerMessage(event, result, sortUri) {
  // When the main thread tells the worker to reset, the worker will respond with
  // a message to reset the array of already sorted items.
  if (event.data.reset) {
    waitingForReset[sortUri]--;
    result.items.length = 0;
    return;
  }

  // Skip messages that don't belong to the latest sort
  if (event.data.id !== lastIds[sortUri]) {
    return;
  }

  // If we are still waiting for reset messages, don't continue to add more items
  // to the list of sorted items.
  if (waitingForReset[sortUri]) {
    return;
  }

  // If we are not waiting for any resets, just save the chunk of sorted items.
  result.items = result.items.concat(event.data.items);

  // When all data has been passed over from the worker, kill the worker and run
  // the latest registered callback for this sorted list.
  if (event.data.last) {
    workers[sortUri].terminate();

    const callback = callbacks[sortUri];
    delete callbacks[sortUri];
    delete workers[sortUri];

    callback(null, result.items);
  }
}

/**
 * Create the Web Worker file path.
 * Since the worker can't share objects with the main thead, we can't share
 * dependencies. To solve this, we convert the dependencies to strings and pass
 * them as arguments to the worker file.
 * To circumvent the need of a separate file for the worker, we make the worker
 * itself and the passed dependencies a single string and make a blob out of it.
 * From the blob we can get a URL that we can pass to the worker constructor.
 *
 * @return {string} Blob URL that can be passed to the worker.
 */
function createWorkerFile() {
  const workerStr = sortWorker.toString();
  const sortStr = sorter.toString();
  const chunkerStr = chunker.toString();
  const posterStr = poster.toString();
  const argsStr = [sortStr, chunkerStr, posterStr].join(', ');
  const stringWorker = `(${workerStr})(${argsStr})`;

  const blob = new Blob([stringWorker], { type: 'text/javascript' });
  const url = URL.createObjectURL(blob);

  return url;
}

/**
 * Send the provided items to the provided worker. It will do this by splitting
 * the items into chunks and sending the chunks.
 *
 * @param {Array} items An array of items.
 * @param {Worker} worker A worker instance.
 * @param {string} id The ID for the payload.
 */
function sendItemsToWorker(data, worker, id) {
  const chunks = chunker(data);
  poster(worker, chunks, 0, id);
}

/**
 * Get the sort function to use.
 * If Web Workers are supported, it will use that, otherwise it will use the
 * default sorter on the main thread.
 * Having the code in a function allows for testing where worker support can
 * be removed and added while running the tests.
 *
 * @return {Function} The sorter function.
 */
function getSorter() {
  if (global.Worker && global.Blob && global.URL) {
    if (!workerFile) {
      workerFile = createWorkerFile();
    }
    return workerSorter;
  }
  return localSorter;
}

/**
 * Sort the data using the best supported method.
 *
 * @param {string} sortUri URI of the sorted list.
 * @param {Array.<Object>} items Array of items to sort. Each item is
 *     an object with the properties `data` and `key`. The `data`
 *     property is an array of values to sort on. The `key` property
 *     is a string for the row ID.
 * @param {Function} callback Async callback where the data is the array of
 *     sorted items.
 */
module.exports = function (sortUri, items, callback) {
  const sort = getSorter();
  sort(sortUri, items, callback);
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../../libs/prime/defer":241,"./chunker":188,"./poster":190,"./sorter":192,"./sortworker":193}],192:[function(require,module,exports){
'use strict';

/**
 * Sorts an array of data. Supports multiple levels of values
 * (if two items are the same, it tests the values in the next level).
 *
 * @param {Array.<Object>} data Array of items to sort. Each item is
 *     an object with the properties `data` and `key`. The `data`
 *     property is an array of values to sort on. The `key` property
 *     is a string for the row ID.
 *
 * @return {Array.<Object>} A new array of the same objects that were
 *     passed in, but sorted.
 */
module.exports = function (data) {
  'use strict';

  data.sort(function (a, b) {
    const length = a.data.length;

    for (let i = 0; i < length; i++) {
      const aValue = a.data[i];
      const bValue = b.data[i];

      const aNumber = parseInt(aValue, 10);
      const bNumber = parseInt(bValue, 10);

      const aStartsWithNumber = !isNaN(aNumber);
      const bStartsWithNumber = !isNaN(bNumber);

      if (aStartsWithNumber && bStartsWithNumber) {
        if (aNumber < bNumber) return -1;
        if (aNumber > bNumber) return 1;
      } else if (aStartsWithNumber) {
        return -1;
      } else if (bStartsWithNumber) {
        return 1;
      }

      if (aValue.localeCompare) {
        const value = aValue.localeCompare(bValue);
        if (value !== 0) return value;
      } else {
        if (aValue < bValue) return -1;
        if (aValue > bValue) return 1;
      }
    }

    return -1;
  });

  return data;
};

},{}],193:[function(require,module,exports){
'use strict';

/**
 * This is the Web Worker file that sorts the data and passes it back again.
 * The file cannot be passed directly to new Worker(), as it needs some
 * dependencies. These dependencies are required before creating the worker,
 * and then serialized together with this file into a single blob, which is
 * used to create the worker.
 *
 * @module live-models/sorting/sortworker
 * @private
 */

/**
 * Sort worker.
 *
 * @param {Function} sort Function that sorts an array of data based on a
 *     property.
 * @param {Function} chunk Function that splits up data into chunks.
 * @param {Function} post Function that posts chunks of data back to main
 *     thread.
 * @param {Object} optWorker Optional worker instance (mainly for testability).
 */
module.exports = function (sort, chunk, post, optWorker) {
  'use strict';

  const worker = optWorker || self;

  let itemsToSort = [];
  let id = null;

  worker.addEventListener('message', function (event) {
    // When the main thread tells the worker to reset, the worker will respond with
    // a message to reset the array of already sorted items.
    if (event.data.reset) {
      itemsToSort.length = 0;
      id = event.data.newId;
      worker.postMessage({ reset: true, newId: id });
      return;
    }

    // Only set the stored id for the first message
    if (id === null) {
      id = event.data.id;
    }

    // If the event id does not match the stored id, don't do anything.
    // This allows a sort to be aborted in the middle.
    if (id !== event.data.id) {
      return;
    }

    itemsToSort = itemsToSort.concat(event.data.items);

    if (event.data.last) {
      const sortedItems = sort(itemsToSort);
      const chunks = chunk(sortedItems);
      post(worker, chunks, 0, id);
    }
  }, false);
};

},{}],194:[function(require,module,exports){
'use strict';

/**
 * Get the row values used for sorting.
 *
 * @module live-models/sorting/values
 * @private
 */

/**
 * Get the values from the row based on the passed mask.
 * String values will be sanitized (lowercase, removing articles like 'the' etc).
 * The values can then be used for sorting.
 *
 * @param {Object} mask A mask object from the query parser.
 * @param {Object} row Row data object.
 *
 * @return {Array>} Array of values to sort on.
 *
 * @example
 * var parse = require('../../live/util/parser');
 * var mask = parse('track(name), track(artists(name))').mask;
 * var row = {track: {name: 'Track', artists: [{name: 'Artist'}]}};
 * var values = getValues(mask, row);
 * console.log(values);
 * // ['track', 'artist']
 */
function getValues(mask, row) {
  let result = [];
  mask.forEach(function (m) {
    const k = m.key;
    const value = row[k];

    // If the value is an array, we will concatenate all the
    // values with a comma in between, so that sorting takes
    // all values into account. An example is sorting tracks
    // based on 'artists(name)', where there can be many
    // artists for a track. We will in that case concatenate
    // all artists with comma in between and use a string with
    // all the artists when we compare in the sort function.
    if (Array.isArray(value)) {
      if (m.mask) {
        let values = [];
        for (let i = 0, l = value.length; i < l; i++) {
          values = values.concat(getValues(m.mask, value[i]));
        }
        result.push(values.join(', '));
      } else {
        result.push(value.join(', '));
      }
    } else {
      if (m.mask) result.push.apply(result, getValues(m.mask, value));else result.push(value);
    }
  });

  result = sanitizeStrings(result);

  return result;
}

/**
 * Sanitize string values. This includes trimming whitespace, converting
 * the string to lower case and removing common articles like 'the'.
 *
 * @param {Array} values Array of values.
 *
 * @return {Array} A new array of sanitized values.
 */
function sanitizeStrings(values) {
  const numberRe = /\b[0-9]+\b/g;
  const pad = '000000';

  return values.map(function (value) {
    if (typeof value !== 'string') return value;

    let newValue = value.toLowerCase();

    // Remove the first article
    const articles = ['the ', '(the) '];
    for (let i = 0; i < articles.length; i++) {
      const article = articles[i];

      if (newValue.indexOf(article) === 0) {
        newValue = newValue.replace(article, '');
        break;
      }
    }

    // Zero-pad numbers for natural numeric sorting (i.e. 2 before 10)
    newValue = newValue.replace(numberRe, function (match) {
      if (match.length >= pad.length) return match;
      return pad.substr(0, pad.length - match.length) + match;
    });

    return newValue.trim();
  });
}

module.exports = getValues;

},{}],195:[function(require,module,exports){
(function (global){
/**
 * @module live-models/sortlist
 */
'use strict';

const live = require('../live');
const mixIn = require('mout/object/mixIn');

const parse = require('../live/util/parser');
const sortUriUtils = require('../live-sort-uri');
const listOperations = require('../live-list-operations');

const sort = require('./sorting/sort');
const getValues = require('./sorting/values');

// A generated ID will be stored here for each sorted list. Whenever a sorted
// list is asked to resort, a new ID will be generated and set here for that
// list. That allows us to cancel a previous sort if a newer one has started
// before the old one finished.
let idCounter = 0;
const lastIds = {};

/**
 * Event handler for the live 'init' event on sorted models. Keeps sorted model
 * and tracking model in sync (properties, not rows).
 *
 * This will set up an update listener for the tracking model, so that any
 * changes to the tracking model are also applied to the sort model.
 *
 * This also sets up a publish listener for the sorted model, so that anything
 * that is published on the sorted model gets published on the tracking model,
 * which can then update backend with the data and then update the tracking
 * model with the correct data, which will then trickle back down to the
 * sorted model.
 *
 * @param {LiveObject} sortModel The sorted live model.
 */
function onInit(sortModel) {
  const trackingModel = getTrackingModel(sortModel.uri);

  lastIds[sortModel.uri] = (++idCounter).toString(36);

  // Update the sorted model when any property on the tracking model changes (except rows)
  trackingModel.on('update', function (properties) {
    const updateObject = mixIn({}, properties);
    delete updateObject.rows;
    sortModel.update(updateObject);
  });

  // Update the tracking model when any property on the sort model changes (except rows)
  sortModel.on('publish', function (properties) {
    const updateObject = mixIn({}, properties);
    delete updateObject.rows;
    trackingModel.publish(updateObject);
  });
}

/**
 * Event handler for the live 'wait' event on sorted models.
 * This will fetch any requested property from the tracking model, or if
 * rows are requested, it will perform a sort of the rows from the tracking
 * model.
 *
 * It will also listen for changes. If a change is published on the sorted list,
 * it will be republished on the tracking list. When the tracking list is updated
 * with the new data (maybe after a save on the backend), the sorted list will be
 * updated and resorted if needed.
 *
 * @param {LiveObject} sortModel The sorted live model.
 * @param {Array} properties Array of properties that the model is waiting for.
 */
function onWait(sortModel, properties) {
  const trackingModel = getTrackingModel(sortModel.uri);

  properties.forEach(function (key) {
    // Requesting rows will create a live list of rows, perform sorting,
    // fill the list with the sorted items and also start to listen for changes.
    if (key === 'rows') {
      setRowsProperty(sortModel, trackingModel);

      // Requesting any other property than rows will just get that property from
      // the tracking model.
    } else {
      trackingModel.get(key, function (error, value) {
        if (error) {
          if (global.console) console.error(error);
          return;
        }
        const obj = {};
        obj[key] = value;
        sortModel.update(obj);
      });
    }
  });
}

/**
 * Set the `rows` property on the sort model. It will create a new live list
 * and perform sorting based on the rows of the tracking model. It will also
 * set up listeners for any changes to the lists to automatically keep
 * everything in sync.
 *
 * @param {LiveObject} sortModel The live object for the sorted list.
 * @param {LiveObject} trackingModel The live object for the list the sorted
 *     list is tracking.
 */
function setRowsProperty(sortModel, trackingModel) {
  const sortParams = sortUriUtils.parse(sortModel.uri);
  const direction = sortParams.direction;
  const query = sortParams.query;

  // Start the first sort
  performRowSorting(trackingModel, sortModel, query, direction);

  // Whenever a publish call happens on the sorted list, publish it to the
  // tracking list.
  sortModel.get('rows', function (error, sortList) {
    if (error) {
      if (global.console) console.error(error);
      return;
    }
    sortList.on('publish', function (operations) {
      const trackingList = trackingModel.get('rows');
      if (!trackingList) return;
      syncRows(trackingList, operations, 'publish');
    });
  });

  // We need to get the rows list of the tracking model to be able to know the
  // length of the list, so that we can create the rows list for the sorted list.
  trackingModel.get('rows', function (error, trackingList) {
    if (error) {
      if (global.console) console.error(error);
      return;
    }

    // Listen for updates on the tracking list and apply the changes (and
    // maybe resort if needed) on the sorted list.
    trackingList.on('update', function (operations) {
      const sortList = sortModel.get('rows');
      if (!sortList) return;
      const mustSort = syncRows(sortList, operations, 'update');
      if (mustSort) performRowSorting(trackingModel, sortModel, query, direction);
    });
  });
}

/**
 * Get the tracking model for a sort URI.
 * For an ascending sort URI, the tracking model would be the original list.
 * For a descending sort URI, the tracking model would be the ascending sort list.
 *
 * @param {string} sortUri The sort URI.
 *
 * @return {LiveObject} The live object for the tracking model.
 */
function getTrackingModel(sortUri) {
  const parsed = sortUriUtils.parse(sortUri);
  const direction = parsed.direction;
  const originUri = parsed.originUri;
  const query = parsed.query;

  // We can use the sorting from the ascending list when requesting the
  // descending list, by just depending on the ascending list. Asking for
  // data from the ascending list will make that list ask for the data
  // from the original list and then sort it, and then the descending list
  // will reverse that.
  if (direction === 'desc') {
    return live(sortUriUtils.create(originUri, 'asc', query));
  }
  return live(originUri);
}

/**
 * Get data that is needed for performing a sort.
 *
 * @param {Array.<Object>} rows Array of objects of metadata about the rows.
 * @param {Object} mask A mask object from the query parser.
 * @param {LiveList} trackingList The live list for the list the sorted
 *     list is tracking.
 *
 * @return {Array.<Object>} A new array of items used for sorting. Each item is
 *     an object with the properties `data` and `key`. The `data`
 *     property is an array of values to sort on. The `key` property
 *     is a string for the row ID.
 *
 * @example
 * {
 *   data: ['Name of Song', 'Whatever', 100, 0],
 *   key: '0'
 * }
 */
function getSortData(rows, mask, trackingList) {
  return rows.map(function (row, i) {
    const array = getValues(mask, row);
    array.push(i);
    return { data: array, key: trackingList.keys[i] };
  });
}

/**
 * Perform sorting of all rows in a list.
 *
 * @param {LiveObject} trackingModel The model that the sort model is tracking.
 *     For ascending lists, this is the original model. For descending lists,
 *     this is the ascending sort model.
 * @param {LiveObject} sortModel The model to perform the sort on.
 * @param {string} sortQuery The sort query (live compatible query).
 * @param {string} sortDirection The sort direction ('asc' or 'desc').
 */
function performRowSorting(trackingModel, sortModel, sortQuery, sortDirection) {
  lastIds[sortModel.uri] = (++idCounter).toString(36);
  const sortId = lastIds[sortModel.uri];

  // Querying the rows of the tracking model might perform a sort. An example is when
  // getting the sort for a descending list, it will query the rows from the ascending
  // list, which will in turn query the rows from the original list and then perform a
  // sort. When the ascending sort is done, the query will be done and the descending
  // list can just use the ascending list and reverse it.
  trackingModel.get('rows', function (error, rows) {
    if (error) {
      if (global.console) console.error(error);
      return;
    }

    // Create a list of loaded rows. This allows partial loading of a list,
    // and the sorted version will only contain the loaded rows.
    const rowsToSort = [];
    const keys = [];
    for (let i = 0, l = rows.length; i < l; i++) {
      if (rows.get(i)) {
        rowsToSort.push(rows.get(i));
        keys.push(rows.keys[i]);
      }
    }

    // Empty lists won't sort anyway, so quit here, but empty the sorted list
    // to make it up to date.
    if (rowsToSort.length === 0) {
      const sortList = sortModel.get('rows');
      if (sortList) {
        sortList.update([{
          type: 'remove',
          index: 0,
          length: sortList.length
        }]);
      } else {
        sortModel.update({ rows: [] });
      }
      return;
    }

    const partialTrackingList = live([]);

    partialTrackingList.update([{
      type: 'insert',
      index: 0,
      values: rowsToSort,
      keys: keys
    }]);

    // Now we have a list containing only the loaded rows
    partialTrackingList.query(sortQuery, function (queryError, queryRows) {
      if (queryError) {
        if (global.console) console.error(queryError);
      } else {
        // If direction is descending, the tracking model is ascending. Simply reverse that.
        if (sortDirection === 'desc') {
          updateListWithReversedData(sortModel, partialTrackingList);

          // For an ascending sort, perform a real sort.
        } else {
          const mask = parse(sortQuery).mask;
          const sortData = getSortData(queryRows, mask, partialTrackingList);

          sort(sortModel.uri, sortData, function (sortError, sortedData) {
            if (sortError) {
              if (global.console) console.error(sortError);
              return;
            }
            if (lastIds[sortModel.uri] !== sortId) return;
            updateListWithSortedData(sortModel, partialTrackingList, sortedData);
          });
        }
      }
    });
  });
}

/**
 * Update the sorted live list with the right data after a sort.
 *
 * @param {LiveObject} sortModel The live object for the sorted list.
 * @param {LiveList} trackingList The live list for the list the sorted
 *     list is tracking.
 * @param {Array.<Object>} sortedItems Array of sorted items. Each item is
 *     an object with a property `key`, which is a string for the row ID.
 */
function updateListWithSortedData(sortModel, trackingList, sortedItems) {
  let sortList = sortModel.get('rows');

  // Copy the rows from the list that the sorted list is tracking,
  // if the sorted list has no tracks yet. Only for the first time.
  if (!sortList) {
    sortList = new live.List();
    sortModel.update({ rows: sortList });
  }

  const length = sortedItems.length;
  const keys = new Array(length);
  const values = new Array(length);

  for (let i = 0, l = sortedItems.length; i < l; i++) {
    keys[i] = sortedItems[i].key;
    values[i] = trackingList.valueOf(keys[i]);
  }

  sortList.update([{
    type: 'remove',
    index: 0,
    length: sortList.length
  }, {
    type: 'insert',
    index: 0,
    keys: keys,
    values: values
  }]);
}

/**
 * Update the sorted live list with the data of the list it is tracking,
 * but reversed.
 *
 * @param {LiveObject} sortModel The live object for the sorted list.
 * @param {LiveList} trackingList The live list for the list the sorted
 *     list is tracking.
 */
function updateListWithReversedData(sortModel, trackingList) {
  let sortList = sortModel.get('rows');

  if (!sortList) {
    sortList = new live.List();
    sortModel.update({ rows: sortList });
  }

  sortList.update([{
    type: 'remove',
    index: 0,
    length: sortList.length
  }, {
    type: 'insert',
    index: 0,
    length: trackingList.length,
    values: trackingList.values.slice().reverse(),
    keys: trackingList.keys.slice().reverse()
  }]);
}

/**
 * Converting the passed in operations to be relative to the list that was
 * passed in. Passing operations for a sorted list can convert the operations
 * to be used for the original list. This also updates (or publishes) the list
 * with the converted operations.
 *
 * @param {LiveList} rows The list to sync operations to.
 * @param {Array.<Object>} operations Array of operation objects.
 * @param {string} mode The mode for updates. 'update' or 'publish'.
 *
 * @return {boolean} True if a resort must happen after applying the operations.
 */
function syncRows(rows, operations, mode) {
  let mustSort = false;

  operations.forEach(function (operation) {
    let newOperations = [];

    switch (operation.type) {
      // If rows are removed from the tracking list, we can "simply" remove
      // the same rows from the sorted model.
      case 'remove':
        newOperations = convertRemoveOperationForList(rows, operation);
        break;

      // If rows are inserted in the tracking list, we must add the rows to
      // the sorted list and resort. Where we insert doesn't matter as we will
      // perform a new sort anyway.
      case 'insert':
        newOperations = [{
          type: 'insert',
          index: 0,
          values: operation.values,
          keys: operation.keys
        }];
        mustSort = true;
        break;

      // If rows are moved in the tracking list, we don't need to perform any
      // new moves directly, but we will need to perform a resort, as sorting
      // uses stable sort (falls back on index in original list if compared
      // values are the same).
      case 'move':
        mustSort = true;
        break;

      default:
        console.error('Invalid operation type', operation.type);
        break;
    }

    if (mode === 'publish') {
      rows.publish(newOperations);
    } else if (mode === 'update') {
      rows.update(newOperations);
    }
  });

  return mustSort;
}

/**
 * Convert a remove operation from one list to an operation that can
 * be used in another list. An example is when we have an operation that
 * happened in the original list, we need to convert that to operations
 * that can be applied to the sorted list.
 *
 * @param {LiveList} list The live list to create the operations for.
 * @param {Object} operation The input 'remove' operation.
 *
 * @return {Array.<Object>} Array of remove operation objects.
 */
function convertRemoveOperationForList(list, operation) {
  const indices = [];
  const operationKeys = operation.keys;

  list.keys.forEach(function (key, i) {
    if (operationKeys.indexOf(key) > -1) indices.push(i);
  });

  return listOperations.getRemoveOperations(indices);
}

const regExp = exports.matches = /^spotify:internal:sortlist:(asc|desc):([^:]*):(.*)$/;

let registered = false;
exports.register = function () {
  if (registered) return;
  registered = true;

  live.subscribe(regExp, 'init', onInit);
  live.subscribe(regExp, 'wait', onWait);
};

exports.unregister = function () {
  if (!registered) return;
  registered = false;

  live.unsubscribe(regExp, 'init', onInit);
  live.unsubscribe(regExp, 'wait', onWait);
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../live":210,"../live-list-operations":157,"../live-sort-uri":208,"../live/util/parser":213,"./sorting/sort":191,"./sorting/values":194,"mout/object/mixIn":480}],196:[function(require,module,exports){
'use strict';

var _messageProxy = require('../../libs/message-proxy');

/**
 * @module live-models/station
 */

const live = require('../live');

// Utilities
const trackToRow = require('./station/track-to-row');
const contains = require('mout/array/contains');
const spotifyURI = require('spotify-liburi');
const thumbActions = require('./station/thumb-actions');

const URI = exports.URI = 'spotify:station:';
const regExp = exports.matches = new RegExp(`^${URI}(` + '((artist:|album:|track:)[a-zA-Z0-9]{22})' + '|' + '(user:[^:]+:' + '(playlist:[a-zA-Z0-9]{22}|top:tracks|toplist))' + '|' + '(user:[^:]+:cluster:[a-zA-Z0-9]{22})' + '|' + '(genre:[a-zA-Z0-9]*)' + ')');
const isStationUri = exports.isStationUri = regExp.test.bind(regExp);

const clusterRegExp = new RegExp(`^${URI}(` + '(user:[^:]+:cluster:[a-zA-Z0-9]{22})' + ')');
exports.isClusterStationUri = regExp.test.bind(clusterRegExp);

const DEFAULT_FETCH_COUNT = 15;

// Station Types
const PLAYLIST = 'playlist';
const TRACK = 'track';
const ALBUM = 'album';
const ARTIST = 'artist';
const GENRE = 'genre';
const CLUSTER = 'cluster';
const UNKNOWN = 'unknown';

let registered = false;
let metadataUpdateUnsubscribe;

let trackingRows = []; // A list of stations that need row updates.
let trackingMetadata = []; // A list of stations that need metadata updates.

/**
 * Get the station's base seed from the live model uri
 * @param {Object} model
 * @return {String}
 */
function getBaseSeedFromUri(model) {
  const seed = model.uri.replace(/^spotify:station:/, 'spotify:');
  return decodeURIComponent(seed);
}

/**
 * Get the station type
 * @param {String} seed
 * @return {String}
 */
function getType(seed) {
  const uri = spotifyURI.from(seed);
  if (!uri) {
    return UNKNOWN;
  }
  const contextType = uri.type;
  if (contextType === spotifyURI.Type.PLAYLIST) {
    return PLAYLIST;
  } else if (contextType === spotifyURI.Type.ARTIST) {
    return ARTIST;
  } else if (contextType === spotifyURI.Type.ALBUM) {
    return ALBUM;
  } else if (contextType === spotifyURI.Type.TRACK) {
    return TRACK;
  } else if (seed.indexOf('spotify:genre:') === 0) {
    return GENRE;
  } else if (seed.indexOf(':cluster:') > 0) {
    return CLUSTER;
  }
  return UNKNOWN;
}

/**
 * Thumb up a track
 * @param {Object} model
 * @param {String} trackUID
 */
function onThumbUp(model, trackUri) {
  (0, _messageProxy.messageProxy)({
    method: 'POST',
    uri: 'station-thumb',
    body: {
      stationUri: model.get('uri'),
      trackUri: trackUri,
      thumb: thumbActions.UP
    }
  });
}

/**
 * Thumb down a track
 * @param {Object} model
 * @param {String} trackUID
 */
function onThumbDown(model, trackUri) {
  (0, _messageProxy.messageProxy)({
    method: 'POST',
    uri: 'station-thumb',
    body: {
      stationUri: model.get('uri'),
      trackUri: trackUri,
      thumb: thumbActions.DOWN
    }
  });
}

/**
 * Heart a track
 * @param {Object} model
 * @param {String} trackUID
 */
function onHeart(model, trackUri) {
  if (!isStationUri(model.get('uri'))) {
    return;
  }

  (0, _messageProxy.messageProxy)({
    method: 'POST',
    uri: 'station-heart',
    body: {
      stationUri: model.get('uri'),
      trackUri: trackUri
    }
  });
}

function onUndoHeart(model, trackUri) {
  if (!isStationUri(model.get('uri'))) {
    return;
  }

  (0, _messageProxy.messageProxy)({
    method: 'POST',
    uri: 'station-undo-feedback',
    body: {
      stationUri: model.get('uri'),
      trackUri: trackUri,
      thumbAction: thumbActions.UNDO_HEART
    }
  });
}

/**
 * Post a request for data from the container (station-manager in zlink).
 * @param {Object} model
 * @param {Array} properties
 * @param {Boolean} needsRows
 * @param {Integer} fetchCount
 */
function requestStationData(model, properties, needsRows, fetchCount) {
  const count = needsRows ? fetchCount || model.get('fetchCount') : false;
  (0, _messageProxy.messageProxy)({
    method: 'GET',
    uri: 'station',
    target: 'top',
    body: {
      stationUri: model.get('uri'),
      metadata: properties,
      trackCount: count
    }
  }, function onStationGet(err, opts) {
    if (err) {
      (0, _messageProxy.messageProxy)({
        method: 'POST',
        uri: 'station-error',
        body: { stationUri: model.get('uri'), message: err }
      });
      return;
    }
    const stationUri = opts.stationUri;
    const station = opts.station;
    if (station.hasOwnProperty('tracks')) {
      if (trackingRows.indexOf(stationUri) !== -1) {
        const timeStamp = new Date().getTime();
        station.rows = station.tracks.map(trackToRow.bind(null, timeStamp));
      }
      // Never keep a tracks object in the station (needs to be rows).
      delete station.tracks;
    }
    live(stationUri).update(station);
  });
}

/**
 * Callback for rows wait event.
 * @param {Object} model
 * @param {Array} ranges
 */
function onRowsWait(model, ranges) {
  if (ranges && ranges.length > 0) {
    let fetchCount = 0;
    let largestTrack = 0;
    ranges.forEach(function (a) {
      if (a.end > largestTrack) {
        largestTrack = a.end;
      }
    });
    fetchCount = largestTrack - model.get('rows').length;
    requestStationData(model, [], true, fetchCount);
  }
}

/**
 * Subscriber for updateMetadata messages
 * @param {Object} opts
 */
function onUpdateMetadata(opts) {
  const stationUri = opts.stationUri;
  const metadata = opts.metadata;
  if (trackingMetadata.indexOf(stationUri) === -1) {
    return;
  }
  if (metadata.hasOwnProperty('tracks')) {
    if (trackingRows.indexOf(stationUri) !== -1) {
      const timeStamp = new Date().getTime();
      metadata.rows = metadata.tracks.map(trackToRow.bind(null, timeStamp));
    }
    // Never keep a tracks object in the station (needs to be rows).
    delete metadata.tracks;
  }
  live(stationUri).update(metadata);
}

/**
 * When the model intializes
 * @param {Object} model
 */
function onInit(model) {
  const baseSeed = getBaseSeedFromUri(model);
  if (!baseSeed) {
    return;
  }
  model.update({
    baseSeed: baseSeed,
    type: getType(baseSeed),
    fetchCount: DEFAULT_FETCH_COUNT
  });
  model.on('update', function onModelUpdate(properties) {
    if (properties.hasOwnProperty('rows')) {
      model.get('rows').on('wait', onRowsWait.bind(null, model));
      model.off('update', onModelUpdate);
    }
  });
  trackingMetadata.push(model.get('uri'));
}

/**
 * Model publish listener
 * @param {Object} model station
 * @param {Object} properties
 */
function onPublish(model, properties) {
  if (properties.hasOwnProperty('added')) {
    const added = properties.added;
    if (typeof added === 'boolean') {
      model.update({ added: added });
      (0, _messageProxy.messageProxy)({
        method: 'POST',
        uri: 'station-add',
        body: {
          stationUri: model.get('uri'),
          add: added
        }
      });
    } else {
      console.error('Added can only be a boolean');
    }
  }
}

/**
 * Unset props listener
 * @param {Object} model station
 * @param {Object} properties
 */
function onWait(model, properties) {
  let rowsIndex = -1;
  let needsMetadata;
  const metaFields = ['added', 'name', 'subtitles', 'relatedArtists', 'image', 'nextPageUrl'];

  properties.forEach(function (key, index) {
    if (key === 'rows') {
      rowsIndex = index;
    }
    if (!needsMetadata && contains(metaFields, key)) {
      needsMetadata = true;
    }
  });

  if (rowsIndex !== -1) {
    trackingRows.push(model.get('uri'));
    properties.splice(rowsIndex, 1);
    requestStationData(model, properties, true);
  } else if (needsMetadata) {
    requestStationData(model, properties);
  }
}

exports.register = function () {
  if (registered) {
    return;
  }
  registered = true;

  live.subscribe(regExp, 'wait', onWait);
  live.subscribe(regExp, 'init', onInit);
  live.subscribe(regExp, 'thumb-up', onThumbUp);
  live.subscribe(regExp, 'thumb-down', onThumbDown);
  live.subscribe(regExp, 'heart', onHeart);
  live.subscribe(regExp, 'undo-heart', onUndoHeart);
  live.subscribe(regExp, 'publish', onPublish);
  metadataUpdateUnsubscribe = (0, _messageProxy.messageProxy)({
    method: 'SUB',
    uri: 'station-metadata'
  }, onUpdateMetadata);
};

exports.unregister = function () {
  if (!registered) {
    return;
  }
  registered = false;

  live.unsubscribe(regExp, 'wait', onWait);
  live.unsubscribe(regExp, 'init', onInit);
  live.unsubscribe(regExp, 'thumb-up', onThumbUp);
  live.unsubscribe(regExp, 'thumb-down', onThumbDown);
  live.unsubscribe(regExp, 'heart', onHeart);
  live.unsubscribe(regExp, 'publish', onPublish);
  metadataUpdateUnsubscribe();
  trackingRows = [];
  trackingMetadata = [];
};

},{"../../libs/message-proxy":228,"../live":210,"./station/thumb-actions":200,"./station/track-to-row":201,"mout/array/contains":443,"spotify-liburi":730}],197:[function(require,module,exports){
'use strict';

const rowToPlayerTrack = require('./row-to-player-track');

const PLAYER_RESTRICTIONS = {
  disallow_toggling_repeat_context_reasons: ['disallow-radio'],
  disallow_toggling_repeat_track_reasons: ['disallow-radio'],
  disallow_toggling_shuffle_reasons: ['disallow-radio']
};

/**
 * Create an array of tracks formatted for the context player
 * @param {Object} model
 * @return {Array} tracks array
 */
function createPlayerTracks(model) {
  const rows = model.get('rows');
  if (!rows) {
    return [];
  }
  return rows.values.map(rowToPlayerTrack);
}

/**
 * Construct a context object for context-player
 * @param {Object} model station live model
 * @return {Object} context
 */
module.exports = function createPlayContext(model) {
  return {
    entity_uri: model.get('uri'),
    pages: [{
      tracks: createPlayerTracks(model),
      next_page_url: model.get('nextPageUrl')
    }],
    metadata: {
      context_description: model.get('name')
    },
    restrictions: PLAYER_RESTRICTIONS
  };
};

},{"./row-to-player-track":199}],198:[function(require,module,exports){
'use strict';

const PLAYER_OPTIONS = {
  shuffling_context: false,
  repeating_context: false,
  repeating_track: false
};

/**
 * This is neccesary because you dont get pages back from the context-player.
 * So if you want to resume a station with a set of rows (not pages)
 * you have to know the index of the last played row,
 * which you can get by comparing currentTrackUid with the row's Uid.
 * @param {Object} model station live model
 * @return {Int} index
 */
function getLastIndex(model) {
  const rows = model.get('rows');
  const currentTrackUid = model.get('currentTrackUid');

  if (!rows || !currentTrackUid) {
    return 0;
  }

  let currentIndex;

  const foundRow = rows.values.some(function (row, index) {
    if (row.get('uid') === currentTrackUid) {
      currentIndex = index;
      return true;
    }
    return false;
  });

  return foundRow ? currentIndex : 0;
}

/**
 * Creates the context-player options for a station context
 * @param {Object} model station model
 * @param {Object} options optional
 * @return {Object} playOptions
 */
module.exports = function createPlayOptions(model, options) {
  let trackIndex;
  if (options && (options.index || options.index === 0)) {
    trackIndex = options.index;
  } else {
    trackIndex = getLastIndex(model);
  }
  const playOptions = {
    skip_to_index: {
      page: 0,
      track: trackIndex
    },
    player_options_override: PLAYER_OPTIONS
  };
  if (options && options.uid) {
    playOptions.uid = options.uid;
  }
  return playOptions;
};

},{}],199:[function(require,module,exports){
'use strict';

/**
 * Converts a station row into a track for the context-player
 * @param {Object} row station row
 * @return {Object} track
 */

module.exports = function rowToPlayerTrack(row) {
  return {
    uid: row.get('uid'),
    uri: row.get('track').get('uri'),
    album_uri: row.get('track').get('albumUri'),
    artist_uri: row.get('track').get('artistUri'),
    metadata: {
      'image_url': row.get('track').get('image'),
      'radio.thumb': row.get('track').get('thumb')
    }
  };
};

},{}],200:[function(require,module,exports){
'use strict';

module.exports = {
  UP: 'ups',
  DOWN: 'downs',
  UNDO_HEART: 'undo-heart',
  UNDO_BAN_ARTIST: 'undo-ban-artist',
  UNDO_BAN_TRACK: 'undo-ban-track'
};

},{}],201:[function(require,module,exports){
'use strict';

/**
 * Convert track objects coming from station-manager into a row.
 * @param {Object} track
 * @return {Object} row
 */

module.exports = function trackToRow(timeStamp, track, index) {
  const metadata = track.metadata || {};
  const albumUri = track.album_uri || metadata.album_uri;
  let uid = track.uid;

  if (!track.uid) {
    const id = track.uri.replace('spotify:track:', '');
    uid = timeStamp + id + index;
  }

  return {
    uid: uid,
    uri: uid,
    track: {
      uri: track.uri,
      name: metadata.title,
      image: metadata.image_url,
      albumUri: albumUri,
      artists: transformArtists(track.metadata),
      album: { name: metadata.album_title, uri: albumUri },
      thumb: metadata['radio.thumb'] || ''
    }
  };
};

function transformArtists(metadata) {
  const artists = [];

  for (let i = 0;; i++) {
    const suffix = i > 0 ? `:${i}` : '';
    const uri = metadata[`artist_uri${suffix}`];
    const name = metadata[`artist_name${suffix}`];
    if (uri && name) {
      artists.push({ uri: uri, name: name });
    } else {
      break;
    }
  }

  return artists;
}

},{}],202:[function(require,module,exports){
(function (global){
/**
 * @module live-models/track
 */
'use strict';

const live = require('../live');
const liburi = require('spotify-liburi');
const intersection = require('mout/array/intersection');
const contains = require('mout/array/contains');
const bridge = require('./util/bridge').request;
const cosmos = require('./util/cosmos');
const util = require('./util/common');

const BACKOFF = 100;
let localFilesRequest = null;

const metaFields = ['album', 'artists', 'availability', 'disc', 'duration', 'explicit', 'image', 'local', 'name', 'number', 'placeholder', 'playable', 'linkedTrack'];

function onWait(model, properties) {
  // Set the 'unavailable' property based on the 'playable' property
  if (contains(properties, 'unavailable')) {
    model.get('playable', function (error, playable) {
      if (error) {
        if (global.console) console.error(error);
        return;
      }
      model.update({ unavailable: !playable });
    });
  }

  const hasMetadata = !!intersection(properties, metaFields).length;

  if (hasMetadata) updateMetadata(model);

  const needsShouldBeOffline = contains(properties, 'shouldBeOffline');
  const needsOfflineProgress = contains(properties, 'offlineProgress');
  if (needsShouldBeOffline || needsOfflineProgress) {
    updateOffline(model);
  }
}

function updateMetadata(model) {
  bridge('track_metadata', [model.uri], function (error, payload) {
    if (error) {
      if (global.console) console.error(error);
      return;
    }
    util.setLocalProperties(payload);
    payload.image = largestImage(payload);

    // The linkedTrack is not available everywhere, so do fallback
    if (payload.linkedTrack) {
      payload.linkedTrack = { uri: payload.linkedTrack };
    } else {
      payload.linkedTrack = null;
    }

    model.update(payload);
  });
}

function largestImage(trackMetadata) {
  let imageURI = trackMetadata.image;
  let largestSize;

  if (trackMetadata.images) {
    for (let i = 0; i < trackMetadata.images.length; i++) {
      const currentImage = trackMetadata.images[i];
      if (!largestSize || currentImage[0] > largestSize) {
        largestSize = currentImage[0];
        imageURI = currentImage[1];
      }
    }
  }

  return imageURI;
}

function updateOffline(model) {
  // Local tracks are available offline if they are playable
  if (liburi.fromString(model.uri).type === liburi.Type.LOCAL) {
    model.get('playable', function (error, playable) {
      if (error) {
        if (global.console) console.error(error);
        return;
      }
      model.update({
        shouldBeOffline: playable,
        offlineProgress: playable ? 1 : 0
      });
    });
    return;
  }

  cosmos.subscribe({ url: `sp://offline/v1/resources?uri=${model.uri}` }, function (error, response) {
    if (!error) {
      const resource = response.body.resources;
      updateModelWithOfflineData(model, resource);
    } else {
      // Status -104 (or 404 in web player) means 'No endpoint resolver that could handle the request was found'.
      // If that's the case, we handle it like the client doesn't support offline.
      const statusCode = error.response && error.response.getStatusCode();
      if (statusCode === -104 || statusCode === 404) {
        updateModelWithOfflineData(model, { offline_availability: 'no' });
      } else {
        if (global.console) console.error(error);
        return;
      }
    }
  });
}

function updateModelWithOfflineData(model, resource) {
  let shouldBeOffline = false;
  let offlineProgress = 0;

  switch (resource.offline_availability) {
    case 'waiting':
      shouldBeOffline = true;
      offlineProgress = 0;
      break;
    case 'downloading':
      shouldBeOffline = true;
      offlineProgress = 0.5;
      break;
    case 'yes':
      shouldBeOffline = true;
      offlineProgress = 1;
      break;
    case 'no':
      shouldBeOffline = false;
      offlineProgress = 0;
      break;
    default:
      console.error('Unexpected resource.offline_availability', resource.offline_availability);
      break;
  }

  model.update({
    shouldBeOffline: shouldBeOffline,
    offlineProgress: offlineProgress
  });
}

let registered;

function waitForLocalFilesChange() {
  localFilesRequest = cosmos.subscribe({ url: 'sp://local-files/v1/changes' }, function (error, response) {
    if (!registered) return;

    if (error) {
      // Status -104 (or 404 in web player) means 'No endpoint resolver that could handle the request was found'.
      // If that's the case, we bail out and don't do anything.
      const statusCode = error.response && error.response.getStatusCode();
      if (statusCode === -104 || statusCode === 404) {
        return;
      }
      if (global.console) console.error(error);
      return;
    }

    const event = response.body;
    const data = event.data;
    const type = event.type;
    const isAdded = type === 'added';
    const isRemoved = type === 'removed';

    if (isAdded || isRemoved) {
      data.tracks.forEach(function (track) {
        live(track.uri).update({
          shouldBeOffline: isAdded,
          offlineProgress: isAdded ? 1 : 0,
          playable: isAdded
        });
      });
    }
  });
}

function waitForTrackChange() {
  bridge('track_event_wait_any', [], function (error, event) {
    if (!registered) return;

    if (error) {
      setTimeout(function () {
        waitForTrackChange();
      }, BACKOFF);
      if (global.console) console.error(error);
      return;
    }

    waitForTrackChange();

    if (event.type === 'change') {
      if (event.data.playable !== undefined) {
        event.data.unavailable = !event.data.playable;
      }
      live(event.data.uri).update(event.data);
    }
  });
}

const regExp = exports.matches = /^spotify:track:|^spotify:local:[^:]*:[^:]*:[^:]*:\d*$/;
exports.register = function () {
  if (registered) return;
  registered = true;

  live.subscribe(regExp, 'wait', onWait);

  waitForLocalFilesChange();

  // Only desktop has support for track relinking
  if (global._getSpotifyModule) {
    waitForTrackChange();
  }
};

exports.unregister = function () {
  if (!registered) return;
  registered = false;

  live.unsubscribe(regExp, 'wait', onWait);

  if (localFilesRequest) {
    localFilesRequest.cancel();
    localFilesRequest = null;
  }
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../live":210,"./util/bridge":204,"./util/common":205,"./util/cosmos":206,"mout/array/contains":443,"mout/array/intersection":450,"spotify-liburi":730}],203:[function(require,module,exports){
(function (global){
/**
 * @module live-models/user
 */
'use strict';

const live = require('../live');
const liburi = require('spotify-liburi');
const contains = require('mout/array/contains');
const intersection = require('mout/array/intersection');
const bridge = require('./util/bridge').request;

function updateMetadata(model) {
  bridge('user_metadata', [model.uri], function (error, payload = {}) {
    if (error && global.console) console.error(error);

    payload.username = payload.username || liburi.from(model.uri).username;
    payload.name = payload.name || payload.username;
    payload.image = payload.image || '';
    payload.images = payload.images || [];

    // Has to be truthy check
    // because can be undefined or null
    if (!payload.subscribed) {
      payload.subscribed = false;
    }

    // Has to be truthy check
    // because can be undefined or null
    if (!payload.currentUser) {
      live('spotify:client').query('currentUser(uri)', function (innerError, data) {
        if (innerError) {
          if (global.console) console.error(innerError);
        } else {
          model.update({ currentUser: model.uri === data.currentUser.uri });
        }
      });
    }

    model.update(payload);
  });
}

function updateArtist(model) {
  bridge('user_associated_artist', [model.uri], function (error, payload) {
    if (error) {
      if (global.console) console.error(error);
      return;
    }
    const artist = payload.artist ? { uri: payload.artist } : null;
    model.update({ artist: artist });
  });
}

function onWait(model, properties) {
  const hasArtist = contains(properties, 'artist');
  const metaFields = ['currentUser', 'name', 'username', 'image', 'images', 'subscribed'];
  const hasMetadata = !!intersection(properties, metaFields).length;

  if (hasMetadata) updateMetadata(model);
  if (hasArtist) updateArtist(model);
}

const regExp = exports.matches = /^spotify:user:[^:]+$/;
let registered;
exports.register = function () {
  if (registered) return;
  registered = true;

  live.subscribe(regExp, 'wait', onWait);
};

exports.unregister = function () {
  if (!registered) return;
  registered = false;

  live.unsubscribe(regExp, 'wait', onWait);
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../live":210,"./util/bridge":204,"mout/array/contains":443,"mout/array/intersection":450,"spotify-liburi":730}],204:[function(require,module,exports){
/**
 * @module live-models/util/bridge
 * @private
 */

'use strict';

const bridge = require('../../bridge');

module.exports = {
  request: bridge.request
};

},{"../../bridge":86}],205:[function(require,module,exports){
'use strict';

const liburi = require('spotify-liburi');

function setLocalProperties(track) {
  if (track.album && track.album.uri) {
    const albumType = liburi.from(track.album.uri).type;
    track.album.local = albumType === liburi.Type.LOCAL_ALBUM;
  }
  if (track.artists) {
    for (let i = 0, l = track.artists.length; i < l; i++) {
      const artist = track.artists[i];
      if (artist.uri) {
        const artistType = liburi.from(artist.uri).type;
        artist.local = artistType === liburi.Type.LOCAL_ARTIST;
      }
    }
  }
}

module.exports = {
  setLocalProperties: setLocalProperties
};

},{"spotify-liburi":730}],206:[function(require,module,exports){
(function (global){
/**
 * @module live-models/util/cosmos
 * @private
 */

'use strict';

const cosmos = require('spotify-cosmos-api');

function DELETE(options, callback) {
  options.method = exports.cosmos.Action.DELETE;
  return request(options, callback);
}

function GET(options, callback) {
  options.method = exports.cosmos.Action.GET;
  return request(options, callback);
}

function SUB(options, callback) {
  options.method = exports.cosmos.Action.SUB;
  return request(options, callback);
}

function POST(options, callback) {
  options.method = exports.cosmos.Action.POST;
  return request(options, callback);
}

function PUT(options, callback) {
  options.method = exports.cosmos.Action.PUT;
  return request(options, callback);
}

function HEAD(options, callback) {
  options.method = exports.cosmos.Action.HEAD;
  return request(options, callback);
}

function request(options, callback) {
  const method = options.method;
  delete options.method;

  let subscription;
  let canceled;

  sanitizeURL(options.url, function (error, url) {
    if (error) {
      if (callback) {
        callback(error);
      }
    } else {
      // if you don't cancel before the userName is replaced.
      if (!canceled) {
        const innerRequest = new exports.cosmos.Request(method || exports.cosmos.Action.GET, url, options.headers, options.body);
        subscription = exports.cosmos.resolver.resolve(innerRequest, function (innerError, response) {
          if (!callback) return;
          if (callback && innerError) {
            callback(innerError);
          } else {
            try {
              callback(null, {
                body: JSON.parse(response.getBody() || '{}'),
                headers: response.getHeaders(),
                status: response.getStatusCode()
              });
            } catch (parseError) {
              parseError.response = response;
              callback(parseError);
            }
          }
        });
      }
    }
  });

  return {
    cancel: function () {
      if (subscription && subscription.cancel) {
        // we already subscribed, cancel it.
        subscription.cancel();
        subscription = null;
      } else if (!canceled) {
        // not subscribed yet, don't even subscribe.
        canceled = true;
      }
      return null;
    }
  };
}

function sanitizeURL(url, callback) {
  if (url.indexOf('@') > -1) {
    callback(null, url.replace('@', encodeURIComponent(global.__spotify.username)));
  } else {
    callback(null, url);
  }
}

exports.request = request;
exports.get = GET;
exports.post = POST;
exports.subscribe = SUB;
exports.delete = DELETE;
exports.put = PUT;
exports.head = HEAD;
exports.cosmos = cosmos;

exports.sanitizeURL = sanitizeURL;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"spotify-cosmos-api":720}],207:[function(require,module,exports){
'use strict';

const Preferences = require('../../preferences');

/**
 * Subscribe for changes of the 'Show Unplayable Tracks' preference.
 *
 * @param {Function} callback Callback function that gets called for
 *                            each change.
 *
 * @return {Object} An object with a `cancel` method.
 */
function subscribe(callback) {
  const preferences = new Preferences('ui');

  return preferences.subscribe('show_unplayable_tracks', function (error, value) {
    if (error) {
      callback(error);
    } else {
      callback(null, !!value);
    }
  });
}

exports.subscribe = subscribe;

},{"../../preferences":240}],208:[function(require,module,exports){
'use strict';

const base = 'spotify:internal:sortlist';
const regExp = /^spotify:internal:sortlist:(asc|desc):([^:]*):(.*)$/;

/**
 * Create a URI representing a sorted variant of a list.
 *
 * @param {string} originUri The original list URI.
 * @param {string} direction The direction of the sorted list ('asc' or 'desc').
 * @param {string} query The query string (compatible with live). Sorting
 *     implementations might not look at all values. The list of produced values
 *     from the query will be tried in order from left to right. If two items have
 *     the same value, it will look at the next produced value from this query.
 *     Any spaces in the query will be removed.
 *
 * @return {string} URI of the sorted variant of the list. The URI will have
 *     the query string URL encoded.
 */
exports.create = function (originUri, direction, query) {
  const newOriginUri = originUri.replace(/^spotify:/, '');

  const newQuery = encodeURIComponent(query).replace(/%20/g, '');

  return [base, direction, newQuery, newOriginUri].join(':');
};

/**
 * Get the direction of the sorted list.
 *
 * @param {string} sortUri The URI of the sorted list.
 *
 * @return {string} The direction of the sort ('asc' or 'desc'). If URI is
 *     invalid, this returns an empty string.
 */
exports.getDirection = function (sortUri) {
  const matches = sortUri.match(regExp);
  if (!matches) return '';

  return matches[1];
};

/**
 * Get the query string from a sort URI.
 *
 * @param {string} sortUri The URI of the sorted list.
 *
 * @return {string} The query string, URL decoded. If URI is
 *     invalid, this returns an empty string.
 */
exports.getQuery = function (sortUri) {
  const matches = sortUri.match(regExp);
  if (!matches) return '';

  return decodeURIComponent(matches[2]);
};

/**
 * Get the URI of the original list.
 *
 * @param {string} sortUri The URI of the sorted list.
 *
 * @return {string} The URI of the original list. If the sort URI is invalid,
 *     this returns an empty string.
 */
exports.getOriginUri = function (sortUri) {
  const matches = sortUri.match(regExp);
  if (!matches) return '';

  return `spotify:${matches[3]}`;
};

/**
 * Parse and return all parts of the sort URI.
 *
 * @param {string} sortUri The URI of the sorted list.
 *
 * @return {Object?} An object with properties `direction`, `query` and `originUri`,
 *     or null if the URI is not valid.
 */
exports.parse = function (sortUri) {
  const matches = sortUri.match(regExp);
  if (!matches) return null;

  return {
    direction: matches[1],
    query: decodeURIComponent(matches[2]),
    originUri: `spotify:${matches[3]}`
  };
};

/**
 * Test if the provided URI is a valid sort URI.
 *
 * @param {string} sortUri The URI of the sorted list.
 *
 * @return {boolean} True if it's valid, false otherwise.
 */
exports.isValid = function (sortUri) {
  return regExp.test(sortUri);
};

/**
 * The regular expression that matches sort URIs.
 */
exports.regExp = regExp;

},{}],209:[function(require,module,exports){
'use strict';

const sortUriUtils = require('../live-sort-uri');
const filterUriUtils = require('../live-filter-uri');

/**
 * Create a URI representing a wrapped variant of a list.
 *
 * @param {object} opts The options.
 * @param {string} opts.originUri The origin uri.
 * @param {object?} opts.filter The filter, if any
 * @param {object?} opts.sort The sorting, if any
 *
 * @return {string} URI of the wrapped variant of the list.
 */
exports.create = function (opts) {
  let uri = opts.originUri;
  if (opts.filter) {
    uri = filterUriUtils.create(uri, opts.filter.query);
  }
  if (opts.sort) {
    uri = sortUriUtils.create(uri, opts.sort.direction, opts.sort.query);
  }
  return uri;
};

/**
 * Get the URI of the original list.
 *
 * @param {string} sortUri The URI of the wrapped list.
 *
 * @return {string} The URI of the original list. If the wrapped URI is invalid,
 *     this returns an empty string.
 */
exports.getOriginUri = function (wrappedUri) {
  const parsed = exports.parse(wrappedUri);
  return parsed && parsed.originUri || '';
};

/**
 * Parse and return all parts of the wrapped URI.
 *
 * @param {string} wrappedUri The URI of the wrapped list.
 *
 * @return {object} An object with properties `originUri`, `sort` and `filter`.
 */
exports.parse = function (wrappedUri) {
  const sort = sortUriUtils.parse(wrappedUri);
  const filter = filterUriUtils.parse(sort && sort.originUri || wrappedUri);
  if (!(sort || filter)) return null;

  return {
    originUri: filter && filter.originUri || sort && sort.originUri,
    sort: sort,
    filter: filter
  };
};

/**
 * Test if the provided URI is a valid wrapped URI.
 *
 * @param {string} wrappedUri The URI of the wrapped list.
 *
 * @return {boolean} True if it's valid, false otherwise.
 */
exports.isValid = function (wrappedUri) {
  return !!exports.parse(wrappedUri);
};

},{"../live-filter-uri":156,"../live-sort-uri":208}],210:[function(require,module,exports){
(function (global){
/* eslint-disable no-use-before-define */

/**
 * @module live
 */'use strict';

// prime

const prime = require('../../libs/prime');
const defer = require('../../libs/prime/defer');
const Emitter = require('../../libs/prime/emitter');

// mout
const isPlainObject = require('mout/lang/isPlainObject');
const isRegExp = require('mout/lang/isRegExp');
const isNumber = function (n) {
  return typeof n === 'number';
};
const isString = function (s) {
  return typeof s === 'string';
};

const escapeRegExp = require('mout/string/escapeRegExp');

const _difference = require('mout/array/difference');
const filter = require('mout/array/filter');
const combine = require('mout/array/combine');
const map = require('mout/array/map');

const deepMixIn = require('mout/object/deepMixIn');
const pick = require('mout/object/pick');

function parallel(tasks, cb) {
  const results = [];
  let pending = tasks.length;

  if (!pending) cb(null, results);else {
    tasks.forEach((task, i) => {
      task((err, result) => {
        results[i] = result;
        if (--pending === 0 || err) cb(err, results);
      });
    });
  }
}

// util
const OrderedSet = require('./util/ordered-set');
const Range = require('../range2');
const parse = require('./util/parser');
const throttle = require('./util/throttle');

// debugging
const debug = require('../debug')('live');

// methods

const isLiveList = function (item) {
  return item instanceof LiveList;
};

const isLiveObject = function (item) {
  return item instanceof LiveObject;
};

const simpleClone = function (object) {
  return Object.assign({}, object);
};

const difference = function (a, b) {
  return a.length === 0 ? [] : _difference.call(this, a, b);
};

const values = function (object, keys) {
  const newValues = [];
  let key;
  for (let i = 0, len = keys.length; i < len; i++) {
    key = keys[i];
    if (key in object) newValues.push(object[key]);else newValues.length++;
  }
  return newValues;
};

// subtract ranges2 from ranges1
const rdifference = function (ranges1, ranges2) {
  if (!ranges1.length) return [];

  let resultingRanges = [];

  for (let i = 0, len = ranges1.length; i < len; i++) {
    const range = ranges1[i];
    resultingRanges = resultingRanges.concat(range.subtract(ranges2));
  }

  // Make sure we don't have overlapping ranges
  resultingRanges = new Range(0, 0).merge(resultingRanges);

  // Remove any empty ranges
  resultingRanges = filter(resultingRanges, function (range) {
    return !!range.length;
  });

  return resultingRanges;
};

// merge ranges1 into ranges2
const rcombine = function (ranges1, ranges2) {
  let newRanges2 = ranges2;
  for (let i = 0, len = ranges1.length; i < len; i++) {
    const range = ranges1[i];
    newRanges2 = range.merge(newRanges2);
  }
  return newRanges2;
};

// util
let IDX = 0;

const slice_ = Array.prototype.slice;

const transform = function (item, method) {
  if (isPlainObject(item)) {
    // plain objects need to be liveified
    if ('operations' in item) return new LiveList().update(item.operations);
    return live(item.uri)._update(item, method);
  }

  if (Array.isArray(item)) {
    // arrays need to be liveified
    return new LiveList()._update([{
      type: 'insert',
      index: 0,
      length: item.length,
      values: item
    }], method);
  }
  return item;
};

// Creates a callback with a timeout.
function createTimedCallback(callback, timeout) {
  let called;
  const timeoutId = setTimeout(function () {
    called = true;
    callback(new Error(`Timeout Expired: ${timeout} milliseconds`));
  }, timeout);
  return function () {
    if (!called) {
      clearTimeout(timeoutId);
      callback.apply(this, arguments);
    }
  };
}

const LiveList = prime(
/** @lends LiveList.prototype */{
  mixin: Emitter,

  /**
  * A representation of an array which may be observed for changes
  * @constructs
  * @mixes Emitter
  * @param {Number} [length] - A number representing the length of the liveList.
  */
  constructor: function LiveList(length) {
    this._data = new OrderedSet(length);
    this._mergeThrottled = throttle(this._merge, this);
    this._waiting = [];

    let lastWait = '';

    if (live.debug) {
      setInterval(() => {
        const thisWait = this._waiting.toString();
        if (lastWait === thisWait) return;
        lastWait = thisWait;

        if (this._waiting.length) {
          debug(this, 'waiting for', this._waiting);
        } else {
          debug(this, 'all done');
        }
      }, 2000);
    }
  },

  get index() {
    return this._data.index;
  },

  get length() {
    return this._data.length;
  },

  get keys() {
    return this._data.keys;
  },

  get values() {
    return this._data.values;
  },

  indexOf: function (key) {
    return this._data.indexOf(key);
  },

  indexOfMany: function (keys) {
    return this._data.indexOfMany(keys);
  },

  valueOf: function (key) {
    return this._data.valueOf(key);
  },

  hasKey: function (key) {
    return this._data.hasKey(key);
  },

  forEach: function (fn, ctx) {
    this._data.forEach(fn, ctx);
    return this;
  },

  map: function (fn, ctx) {
    return this._data.map(fn, ctx);
  },

  _merge: function () {
    const data = this._data; // actual data
    const publish = this._publish; // new items on top of a copy of data || null
    const before = this._before; // an old copy of data || null

    if (publish) {
      delete this._publish;
      if (this._listeners && this._listeners.publish) {
        const publishDiff = data.diff(publish);
        if (publishDiff.length) this.emit('publish', publishDiff, EMIT_SYNC);
      }
    } else if (before) {
      delete this._before;
      if (this._listeners && this._listeners.update) {
        const updateDiff = before.diff(data);
        if (updateDiff.length) this.emit('update', updateDiff, EMIT_SYNC);
      }
    }
    return this;
  },

  _update: function (operations, method) {
    let branch;
    if (method === PUBLISH) {
      // it was receiving, cannot publish.
      if (this._before) return this;
      branch = this._publish || (this._publish = this._data.clone());
    } else if (method === UPDATE) {
      // it was publishing, delete it.
      if (this._publish) delete this._publish;
      if (!this._before) this._before = this._data.clone();
      branch = this._data;
    }

    let op;
    for (let opIndex = 0, opLen = operations.length; opIndex < opLen; opIndex++) {
      op = operations[opIndex];
      const newValues = [];
      const keys = op.keys || [];

      switch (op.type) {
        case 'length':
          branch.length = op.length;
          break;
        case 'sort':
          branch.sort(op.compareFunction);
          break;
        case 'move':
          branch.move(op.from, op.to, op.length);
          break;
        case 'remove':
          branch.remove(op.index, op.length);
          break;
        case 'insert':
          for (let i = 0, len = op.values.length; i < len; i++) {
            if (!op.keys || !op.keys[i]) keys[i] = (IDX++).toString(36);
            newValues[i] = transform(op.values[i], method);
          }
          branch.insert(op.index, keys, newValues);
          break;
        default:
          console.error('Invalid operation type', op.type);
          break;
      }
    }

    if (method === UPDATE) {
      this._waiting = rdifference(this._waiting, this.index);
    }

    this._mergeThrottled();
    return this;
  },

  publish: function (operations) {
    return this._update(operations, PUBLISH);
  },

  update: function (operations) {
    return this._update(operations, UPDATE);
  },

  /**
  * Serialize the data in this list into a plain object.
  *
  * @param {number=} limit Optional limit parameter. Controls how many levels
  *     deep to serialize.
  *
  * @return {Array} The data array.
  */
  serialize: function (limit) {
    if (limit === 0) return [];

    const array = [];
    const nextLimit = limit === undefined ? undefined : limit - 1;

    for (let i = 0; i < this.length; i++) {
      const value = this.values[i];
      let serializedValue = value;
      if (value && value.serialize) {
        serializedValue = value.serialize(nextLimit);
      }
      array.push(serializedValue);
    }

    return array;
  },

  _getDataFromMask: function (mask) {
    const items = [];

    if (mask.length > 0) {
      // The provided mask to a list is the mask for each list item, so we need
      // to loop through all the items and get the data from each item based on
      // the mask.
      for (let i = 0, l = this.length; i < l; i++) {
        const item = this.get(i);
        let parsedItem;
        const isObjectOrList = item && item._getDataFromMask;
        if (isObjectOrList) {
          parsedItem = item._getDataFromMask(mask);
        }
        items.push(parsedItem);
      }
    }

    return items;
  },

  _query: function (selector, callback, mode) {
    const query = () => {
      queryList(this, selector, (error, data, wasSync) => {
        if (error) {
          callback(error);
        } else {
          if (!wasSync) {
            this._query(selector, callback, mode);
          } else {
            callback(null, data);
          }
        }
      });
    };

    if (mode === ASYNC) defer.immediate(query);else query();
  },

  /**
  * Query properties in this list.
  * This can be called in two different ways: with a callback or without. When
  * calling it with a callback, it will wait for any missing data and always
  * return the data you queried for. When calling it without a callback, it
  * will return an array structure with only the data that was found in the
  * object at the moment. It will not kick off any events for waiting for
  * properties.
  *
  * @param {String} selector - The query selector. Only selectors without
  *     filters are supported when not providing a callback.
  * @param {Array} params - The query replace parameters.
  * @param {LiveList~queryCallback} callback - The callback that handles the response.
  * @param {Object} [mode] live.SYNC: Force sync, 2: live.ASAP: Don't force async
  * @param {Number} timeout - optional timeout in milliseconds
  *
  * @return {LiveList|Array} If no callback is passed it returns an array with
  *                             the data matching the query, that was found at
  *                             the moment in the list.
  *                             If a callback is passed it returns the instance.
  */
  query: function (selector, params, callback, mode, timeout) {
    let newParams = params;
    let newCallback = callback;
    let newMode = mode;
    let newTimeout = timeout;

    /**
    * @callback LiveList~queryCallback
    * @param {Error|Null} error - An error that you can throw, or null.
    * @param {Array} [data] - The response as an array.
    */
    if (typeof newParams === 'function') {
      // shift for empty params
      newTimeout = newMode;
      newMode = newCallback;
      newCallback = newParams;
      newParams = [];
    }

    if (!newCallback) {
      return this._getDataFromMask(parse(selector, newParams).mask);
    }

    if (!newMode) {
      newMode = ASYNC;
    } else if (isNumber(newMode)) {
      // shift once again
      newTimeout = newMode;
      newMode = ASYNC;
    }

    if (newTimeout) {
      newCallback = createTimedCallback(newCallback, newTimeout);
    }

    this._query(parse(selector, newParams), newCallback, newMode);
    return this;
  },

  _wait: function (ranges) {
    if (!this._required) {
      // if _required is set, it was deferred already
      this._required = [];
      defer.immediate(function () {
        const missingFromIndex = this.missing(this._required);
        const missingFromWaiting = rdifference(missingFromIndex, this._waiting);
        this._waiting = rcombine(this._waiting, missingFromWaiting);
        delete this._required;
        if (missingFromWaiting.length) {
          this.emit('wait', missingFromWaiting, EMIT_SYNC);
        }
      }, this);
    }
    this._required = rcombine(this._required, ranges);
  },

  missing: function (ranges) {
    return rdifference(ranges, this.index);
  },

  // the raw, unbeautified get
  // this can callback sync or async
  _get: function (ranges, callback) {
    if (this.missing(ranges).length) {
      // has missing stuff (no matter what)
      this._wait(ranges);

      const check = function () {
        const needed = this.missing(ranges);
        if (!needed.length) {
          this.off('update', check);
          callback.call(this);
        }
      };

      this.on('update', check);
    } else {
      // the callback is called with 'true' when syncronous.
      callback.call(this, null, true);
    }
  },

  /**
  * Checks if the range has been set with values in the list.
  *
  * @param {number} fromIndex The index to start from.
  * @param {number=} toIndex Optional index to stop at (non-inclusive). If no
  *     toIndex is specified, it will default to the index after fromIndex, to
  *     check for the single item at fromIndex.
  *
  * @return {Boolean} True if the range has been set.
  */
  has: function (fromIndex, toIndex) {
    const hasToIndex = toIndex !== undefined;
    let range;
    if (!hasToIndex) {
      range = new Range(fromIndex, fromIndex + 1);
    } else {
      range = new Range(fromIndex, toIndex);
    }

    return range.contained(this.index);
  },

  /**
  * Gets items from the list between the specified indices.
  * @param {Number} what - The index to start from.
  * @param {Number} [toIndex=fromIndex + 1] - The index to stop at (non-inclusive).
  * @param {LiveList~getCallback} [callback] - Optional callback function. If no toIndex
  *     is specified, the callback can be placed as the second argument.
  * @param {Object} [mode] live.SYNC: Force sync, 2: live.ASAP: Don't force async
  * @param {Number} timeout - optional timeout in milliseconds
  * @return {LiveList|Array} If no callback is specified, returns the requested items in an array.
  *                          If a callback is specified, the method returns the instance.
  */
  get: function (fromIndex, toIndex) {
    /**
    * @callback LiveList~getCallback
    * @param {Error|Null} error - An error that you can throw, or null.
    * @param {Array|*} [data] - The response as an array.
    *                           If toIndex is not specified a single item on the list is passed.
    */

    // fast, get one
    if (arguments.length === 1) {
      if (isNumber(fromIndex)) return this.values[fromIndex];
      if (isString(fromIndex)) return this.valueOf(fromIndex);
    }

    const args = slice_.call(arguments);
    let callback;
    let mode;
    let requested;

    for (let i = 0, len = args.length; i < len; i++) {
      const arg = args[i];
      if (typeof arg === 'function') {
        const split = args.splice(i, 3);
        len = args.length;
        callback = split[0];
        if (split[1]) {
          if (split[1] === SYNC || split[1] === ASYNC || split[1] === ASAP) {
            mode = split[1];
          } else {
            // assume this arg is a timeout
            mode = ASYNC;
            callback = createTimedCallback(callback, split[1]);
            break;
          }
          // is there a timeout ?
          if (split[2] && mode !== SYNC) {
            callback = createTimedCallback(callback, split[2]);
          }
        } else {
          mode = ASYNC;
        }
        break;
      }
    }

    let asArray = false;
    let asSingleValue = false;

    if (fromIndex instanceof Range) {
      // one range
      requested = args;
      asArray = !callback && requested.length > 1;
    } else if (Array.isArray(fromIndex)) {
      // array of ranges
      asArray = true;
      requested = fromIndex;
    } else {
      // numbers ?
      const hasToIndex = !isNaN(toIndex);
      if (!hasToIndex) {
        requested = [new Range(fromIndex, fromIndex + 1)];
      } else {
        requested = [new Range(fromIndex, toIndex)];
      }
      asSingleValue = !hasToIndex;
    }

    const result = () => {
      return map(requested, range => {
        return this.values.slice(range.start, range.end);
      });
    };

    const done = () => {
      if (asArray) callback.call(this, null, result());else if (asSingleValue) {
        callback.call(this, null, this.values[fromIndex]);
      } else callback.apply(this, [null].concat(result()));
    };

    if (!callback) {
      if (asArray) return result();
      return result()[0];
    } else if (mode === SYNC) {
      done();
    } else {
      if (mode === ASYNC && !this.missing(requested).length) {
        // it has all the data but needs to be ASYNC
        defer.immediate(function () {
          this._get(requested, done);
        }, this);
      } else {
        this._get(requested, done);
      }
    }
    return this;
  }
});

const LiveObject = prime(
/** @lends LiveObject.prototype */{
  mixin: Emitter,

  /**
  * A representation of an object which may be observed for changes
  * @constructs
  * @mixes Emitter
  */
  constructor: function LiveObject(_uri) {
    this.uri = _uri;
    this._data = { uri: _uri };
    this._mergeThrottled = throttle(this._merge, this);
    this.index = [];
    this._waiting = [];
    this.emit('init', EMIT_SYNC);

    let lastWait = '';

    if (live.debug) {
      setInterval(() => {
        const thisWait = this._waiting.toString();
        if (lastWait === thisWait) return;
        lastWait = thisWait;

        if (this._waiting.length) {
          debug(this, this._waiting);
        } else {
          debug(this, 'all done');
        }
      }, 2000);
    }
  },

  emit: function () {
    const uri = this.uri;
    if (uri) {
      const keys = emitters.keys;
      const innerValues = emitters.values;
      let key;
      let args;

      for (let i = 0, len = keys.length; i < len; i++) {
        key = keys[i];
        if (uri.match(key)) {
          if (!args) {
            args = new Array(arguments.length);
            for (let j = 0; j < arguments.length; ++j) {
              args[j] = arguments[j];
            }
            args.splice(1, 0, this);
          }
          const emitter = innerValues[i];
          emitter.emit.apply(emitter, args);
        }
      }
    }

    Emitter.prototype.emit.apply(this, arguments);
  },

  _merge: function () {
    const data = this._data; // the data
    const before = this._before; // an old copy of data
    const publish = this._publish; // published data
    let value;
    let key;

    // published changes
    if (publish) {
      delete this._publish;

      // emit change events if the object has a uri that can be subscribed too,
      // or the object in itself has listeners
      if (this.uri || this._listeners && this._listeners.publish) {
        const publishEvent = {};

        for (key in publish) {
          if (!publish.hasOwnProperty(key)) continue;
          value = publish[key];
          if (data[key] !== value) publishEvent[key] = value;
        }

        if (Object.keys(publishEvent).length) {
          this.emit('publish', publishEvent, EMIT_SYNC);
        }
      }
    }

    // if there are changes
    if (before) {
      delete this._before;

      const updateEvent = {};

      // emit change events if the object has a uri that can be subscribed too,
      // or the object in itself has listeners
      if (this.uri || this._listeners && this._listeners.update) {
        // check changed and added keys
        for (key in data) {
          if (!data.hasOwnProperty(key)) continue;
          value = data[key];
          // there was no key, or value is different
          if (!(key in before) || before[key] !== value) {
            updateEvent[key] = value;
          }
        }

        // check deleted keys
        for (key in before) {
          if (!before.hasOwnProperty(key)) continue;
          value = before[key];
          // there is no key so it was deleted
          if (!(key in data)) updateEvent[key] = undefined;
        }

        if (Object.keys(updateEvent).length) {
          this.emit('update', updateEvent, EMIT_SYNC);
        }
      }
    }

    return this;
  },

  _update: function (object, method) {
    let branch;

    if (method === PUBLISH) {
      branch = this._publish || (this._publish = simpleClone(this._data));
    } else if (method === UPDATE) {
      if (!this._before) this._before = simpleClone(this._data);
      branch = this._data;
    }

    let value;
    for (const key in object) {
      if (!object.hasOwnProperty(key)) continue;
      value = object[key];
      const previous = !(key in branch) ? undefined : branch[key];

      if (isLiveList(previous)) {
        // updating lists with an array will keep the reference but replace every item.
        if (Array.isArray(value)) {
          previous._update([{
            type: 'remove',
            index: 0,
            length: previous.length
          }, {
            type: 'insert',
            index: 0,
            values: value
          }], method);
          continue;
        } else if (isPlainObject(value) && 'operations' in value) {
          previous._update(value.operations, method);
          continue;
        }
      }

      if (method === UPDATE && value === undefined) delete branch[key];else branch[key] = transform(value, method);
    }

    if (method === UPDATE) {
      this.index = Object.keys(branch);
      this._waiting = difference(this._waiting, this.index);
    }

    this._mergeThrottled();
    return this;
  },

  delete: function (key) {
    const object = {};
    object[key] = undefined;
    return this.update(object);
  },

  update: function (object) {
    return this._update(object, UPDATE);
  },

  publish: function (object) {
    return this._update(object, PUBLISH);
  },

  /**
  * Serialize the data in this object into a plain object.
  *
  * @param {number=} limit Optional limit parameter. Controls how many levels
  *     deep to serialize.
  *
  * @return {Object} The data object.
  */
  serialize: function (limit) {
    if (limit === 0) return {};

    const object = {};
    const data = this._data;
    const nextLimit = limit === undefined ? undefined : limit - 1;

    for (const key in data) {
      if (!data.hasOwnProperty(key)) continue;
      const value = data[key];
      if (value === undefined) continue;
      let serializedValue = value;
      if (value && value.serialize) {
        serializedValue = value.serialize(nextLimit);
      }
      object[key] = serializedValue;
    }

    return object;
  },

  _getDataFromMask: function (mask) {
    const data = {};

    for (let i = 0, l = mask.length; i < l; i++) {
      const thisMask = mask[i];
      const nextMask = thisMask.mask;
      const key = thisMask.key;

      const realValue = this.get(key);
      let value = realValue;

      // Set the value to an empty object or array, and then it will be filled
      // in with the found data in the next step.
      if (isLiveObject(realValue)) value = {};
      if (isLiveList(realValue)) value = [];

      if (nextMask) {
        if (isLiveObject(realValue)) {
          const innerData = realValue._getDataFromMask(nextMask);
          deepMixIn(value, innerData);
        } else if (isLiveList(realValue)) {
          value = realValue._getDataFromMask(nextMask);
        }
      }

      data[key] = value;
    }

    return data;
  },

  _query: function (selector, callback, mode) {
    const query = () => {
      queryObject(this, selector, (error, data, wasSync) => {
        if (error) {
          callback.call(this, error);
        } else {
          if (!wasSync) {
            this._query(selector, callback, mode);
          } else {
            callback.call(this, null, data);
          }
        }
      });
    };

    if (mode === ASYNC) defer.immediate(query);else query();
  },

  /**
  * Query properties in this object.
  * This can be called in two different ways: with a callback or without. When
  * calling it with a callback, it will wait for any missing properties and
  * always return the data you queried for. When calling it without a callback,
  * it will return an object structure with only the data that was found in the
  * object at the moment. It will not kick off any events for waiting for
  * properties.
  *
  * @param {String} selector - The query selector. Only selectors without
  *     filters are supported when not providing a callback.
  * @param {Array} params - The query replace parameters. Optional.
  * @param {LiveObject~queryCallback} callback - The callback function.
  * @param {Object} [mode] live.SYNC: Force sync, 2: live.ASAP: Don't force async
  * @param {Number} timeout - optional timeout in milliseconds
  *
  * @return {LiveObject|Object} If no callback is passed it returns an object
  *                             with the data matching the query, that was found
  *                             at the moment in the object.
  *                             If a callback is passed it returns the instance.
  */
  query: function (selector, params, callback, mode, timeout) {
    let newParams = params;
    let newCallback = callback;
    let newMode = mode;
    let newTimeout = timeout;

    /**
    * @callback LiveObject~queryCallback
    * @param {Error|Null} error - An error that you can throw, or null.
    * @param {LiveObject} [data] - The response as a plain object.
    */
    if (typeof newParams === 'function') {
      // shift for empty params
      newTimeout = newMode;
      newMode = newCallback;
      newCallback = newParams;
      newParams = [];
    }

    if (!newCallback) {
      return this._getDataFromMask(parse(selector, newParams).mask);
    }

    if (!newMode) {
      newMode = ASYNC;
    } else if (isNumber(newMode)) {
      // shift once again
      newTimeout = newMode;
      newMode = ASYNC;
    }

    if (newTimeout) {
      newCallback = createTimedCallback(newCallback, newTimeout);
    }

    this._query(parse(selector, newParams), newCallback, newMode);
    return this;
  },

  _wait: function (keys) {
    if (!this._required) {
      // if _required is set, it was deferred already
      this._required = [];
      defer.immediate(function () {
        const missingFromIndex = this.missing(this._required);
        const missingFromWaiting = difference(missingFromIndex, this._waiting);
        this._waiting = combine(this._waiting, missingFromWaiting);
        delete this._required;
        if (missingFromWaiting.length) {
          this.emit('wait', missingFromWaiting, EMIT_SYNC);
        }
      }, this);
    }
    this._required = combine(this._required, keys);
  },

  missing: function (keys) {
    return difference(keys, this.index);
  },

  /**
  * Checks if the key has been set in the object.
  *
  * @param {string} key The name of the key.
  *
  * @return {Boolean} True if the key has been set.
  */
  has: function (key) {
    return this.index.indexOf(key) > -1;
  },

  // the raw, unbeautified get
  // this can callback sync or async
  _get: function (keys, callback) {
    if (this.missing(keys).length) {
      this._wait(keys);

      const check = function () {
        const needed = this.missing(keys);
        if (!needed.length) {
          this.off('update', check);
          callback.call(this);
        }
      };
      this.on('update', check);
    } else {
      // the callback is called with 'true' when syncronous.
      callback.call(this, null, true);
    }
  },

  /**
  * Gets values from the object.
  * @param {...String|Array} keys - An array of strings as arguments.
  * @param {LiveObject~getCallback} [callback] - Optional callback function.
  * @param {Object} [mode] live.SYNC: Force sync, 2: live.ASAP: Don't force async
  * @param {Number} timeout - optional timeout in milliseconds
  * @return {LiveObject|Array|*} If no callback is passed and keys is either an array or multiple arguments
  *                             returns the values in an array.
  *                             If no callback is passed and keys is a single parameter it
  *                             returns the requested value (any type).
  *                             If a callback is passed it returns the instance.
  */
  get: function (key) {
    /**
    * @callback LiveObject~getCallback
    * @param {Error|Null} error - An error that you can throw, or null.
    * @param {Array|...*} [data] - If keys are requested as arguments (any #)
    *                              it will return many results as arguments.
    *                              If keys are requested as an array (any #), it will return data as an array
    * @param {Number} [mode] 1: FORCE SYNC, 2: DON'T FORCE ASYNC
    */

    // fast, get one
    const data = this._data;
    if (arguments.length === 1 && isString(key)) return data[key];

    const args = slice_.call(arguments);
    let callback;
    let mode;
    let keys;

    for (let i = 0, len = args.length; i < len; i++) {
      const arg = args[i];
      if (typeof arg === 'function') {
        const split = args.splice(i, 3);
        len = args.length;
        callback = split[0];
        if (split[1]) {
          if (split[1] === SYNC || split[1] === ASYNC || split[1] === ASAP) {
            mode = split[1];
          } else {
            // assume this arg is a timeout
            mode = ASYNC;
            callback = createTimedCallback(callback, split[1]);
            break;
          }
          // is there a timeout ?
          if (split[2] && mode !== SYNC) {
            callback = createTimedCallback(callback, split[2]);
          }
        } else {
          mode = ASYNC;
        }
        break;
      }
    }

    let asArray = false;

    if (Array.isArray(key)) {
      keys = key;
      asArray = true;
    } else {
      keys = args;
    }

    const done = () => {
      const vals = values(data, keys);
      if (asArray) {
        callback.call(this, null, vals);
      } else {
        vals.unshift(null); // unshift no error
        callback.apply(this, vals);
      }
    };

    if (!callback) {
      return values(data, keys);
    } else if (mode === SYNC) {
      done();
    } else {
      if (mode === ASYNC && !this.missing(keys).length) {
        // it has all the data but needs to be ASYNC
        defer.immediate(() => {
          this._get(keys, done);
        });
      } else {
        this._get(keys, done);
      }
    }

    return this;
  }
});

const queryAny = function (object, selector, callback) {
  if (isPlainObject(object) || isLiveObject(object)) {
    return queryObject(object, selector, callback);
  } else if (Array.isArray(object) || isLiveList(object)) {
    return queryList(object, selector, callback);
  }
  return callback(null, object, true);
};

const queryObject = function (object, selector, callback) {
  const data = {};
  let isSync = true;

  if (!selector) callback(null, data, isSync);

  const keys = map(selector.mask, 'key');

  const done = function (innerValues) {
    parallel(innerValues.map(function (objectValue, i) {
      return function (innerCallback) {
        queryAny(objectValue, selector.mask[i], function (error, dataValue, wasSync) {
          if (error) {
            innerCallback(error);
            return;
          }
          if (!wasSync) {
            isSync = false;
          }
          if (data[keys[i]]) {
            deepMixIn(data[keys[i]], dataValue);
          } else {
            data[keys[i]] = dataValue;
          }
          innerCallback();
        });
      };
    }), function (error) {
      callback(error, data, isSync);
    });
  };

  if (isLiveObject(object)) {
    object._get(keys, function (error, wasSync) {
      if (error) {
        callback(error);
      } else {
        if (!wasSync) isSync = false;
        const innerValues = map(keys, function (key) {
          return object._data[key];
        });
        done(innerValues);
      }
    });
  } else {
    const innerValues = pick(object, keys);
    done(innerValues);
  }
};

const satisfies = function (value, op, right) {
  if (!op) return !!value;
  if (isRegExp(right)) return right.test(value);

  if (op === '=') return value === right;
  if (op === '!=') return value !== right;

  if (isNumber(right)) {
    if (op === '>') return value > right;
    if (op === '>=') return value >= right;
    if (op === '<') return value < right;
    if (op === '<=') return value <= right;
  }

  if (isString(right)) {
    const escapedRight = escapeRegExp(right);
    // starts with
    if (op === '^=') return new RegExp(`^${escapedRight}`).test(value);
    // ends with
    if (op === '$=') return new RegExp(`${escapedRight}$`).test(value);
    // contains separated by space e.g. 'list of things to look for' ~= 'list'
    if (op === '~=') {
      return new RegExp(`(^|\\s)${escapedRight}(\\s|$)`).test(value);
    }
    // contains separated by - e.g. 'list-of-things-to-look-for' ~= 'things'
    if (op === '|=') return new RegExp(`^${escapedRight}(-|$)`).test(value);
    // contains e.g. 'listofthingstolookfor' ~= 'look'
    if (op === ' *=') return value.toString().indexOf(right) !== -1;
  }

  return false;
};

const filterArray = function (array, left, op, right, callback) {
  let isSync = true;
  const filtered = [];

  let todo = array.length;
  let failed = false;
  function done(error) {
    if (error) {
      if (!failed) {
        failed = true;
        callback(error);
      }
      return;
    }
    if (failed || --todo > 0) {
      return;
    }
    const clean = [];
    for (let i = 0; i < filtered.length; i++) {
      if (i in filtered) {
        clean.push(filtered[i]);
      }
    }
    callback(null, clean, isSync);
  }

  for (let i = 0; i < array.length; i++) {
    const item = array[i];

    if (isLiveObject(item)) {
      /* eslint-disable */
      item._get([left], function (error, wasSync) {
        if (error) {
          done(error);
          return;
        }
        if (!wasSync) {
          isSync = false;
        }
        let value = item._data[left];
        if (satisfies(value, op, right)) {
          filtered[i] = item;
        }
        done();
      });
      /* eslint-enable */
    } else {
      if (isPlainObject(item)) {
        // filter objects only
        if (satisfies(item[left], op, right)) {
          filtered[i] = item;
        }
      }
      done();
    }
  }
};

// default filter that filters the whole list.
const defaultFilters = [[{
  left: 0,
  op: ':'
}]];

function runSeriallyOnArray(array, startAtIndex, asyncFn, callback) {
  if (startAtIndex >= array.length) {
    callback();
    return;
  }
  asyncFn(array[startAtIndex], function (error) {
    if (error) {
      callback(error);
      return;
    }
    runSeriallyOnArray(array, startAtIndex + 1, asyncFn, callback);
  });
}

const queryList = function (list, selector, callback) {
  let isSync = true;
  // if there are no filters we need to query the full length
  if (!selector.filters) selector.filters = defaultFilters;

  function processConditions(conditions, serialTaskCallback) {
    let ref = [];

    function processCondition(condition, parallelTaskCallback) {
      let left = condition.left;
      let right = condition.right;
      let op = condition.op;

      if ('left' in condition && !('right' in condition) && isNumber(left)) {
        if (!op) right = left + 1;else if (op === ':') right = list.length;
        op = ':';
      }

      if ('right' in condition && !('left' in condition) && isNumber(right) && op === ':') {
        left = 0;
      }

      // filter by range.
      if (isNumber(left) && isNumber(right) && op === ':') {
        // if the list is an array it means it has already been filtered.
        if (Array.isArray(list)) {
          const filtered = slice_.call(list, left, right);
          ref = ref.concat(filtered);
          parallelTaskCallback();
        } else {
          list._get([new Range(left, right)], function (error, wasSync) {
            if (error) {
              parallelTaskCallback(error);
            } else {
              for (let i = left; i < right; i++) ref.push(list.values[i]);
              if (!wasSync) isSync = false;
              parallelTaskCallback();
            }
          });
        }
      } else {
        const done = function (array) {
          filterArray(array, left, op, right, function (error, filtered, wasSync) {
            if (error) {
              parallelTaskCallback(error);
            } else {
              if (!wasSync) isSync = false;
              ref = ref.concat(filtered);
              parallelTaskCallback();
            }
          });
        };

        if (Array.isArray(list)) {
          done(list);
        } else {
          // the list is not an array, never been filtered.
          // assume full length.
          // call a function that filters an array once you arraify it.
          list._get([new Range(0, list.length)], function (error, wasSync) {
            if (error) {
              parallelTaskCallback(error);
            } else {
              const array = [];
              for (let i = 0; i < list.length; i++) array.push(list.values[i]);
              if (!wasSync) isSync = false;
              done(array);
            }
          });
        }
      }
    }

    // list of conditions in a single filter.
    // can be parallel.
    parallel(conditions.map(function (condition) {
      return function (parallelTaskCallback) {
        processCondition(condition, parallelTaskCallback);
      };
    }), function (error) {
      if (error) {
        serialTaskCallback(error);
        return;
      }

      // eslint-disable-next-line no-param-reassign
      list = ref;
      serialTaskCallback();
    });
  }

  // single filter.
  // must be sequential.
  runSeriallyOnArray(selector.filters, 0, processConditions, function (error) {
    if (error) {
      callback(error);
    } else {
      const data = [];

      parallel(list.map(function (item, i) {
        return function (parallelTaskCallback) {
          queryAny(item, selector, function (err, res, wasSync) {
            if (!wasSync) isSync = false;
            if (data[i]) deepMixIn(data[i], res);else data[i] = res;
            parallelTaskCallback(err);
          });
        };
      }), function (err) {
        callback(err, data, isSync);
      });
    }
  });
};

let cache = {};

/**
 * Create a new instance of a object, based on an unique identifier.
 * @function
 * @static
 * @param {String|LiveObject} item - An object with an uri property, or an uri as a string.
 * @return {LiveObject|LiveList} An instance of LiveObject or LiveList.
 */
const live = function (item) {
  if (Array.isArray(item)) {
    return new LiveList().update([{
      type: 'insert',
      index: 0,
      length: item.length,
      values: item
    }]);
  } else if (isNumber(item)) {
    return new LiveList(item);
  } else if (isString(item)) {
    return cache[item] || (cache[item] = new LiveObject(item));
  } else if (isPlainObject(item)) {
    return live(item.uri).update(item);
  } else if (isLiveList(item) || isLiveObject(item)) {
    return item;
  }

  return new LiveObject();
};

// Allow localStorage.debug to also control live.debug.
if (global.localStorage && global.localStorage.debug && (global.localStorage.debug.indexOf('live') > -1 || global.localStorage.debug.indexOf('*') > -1)) {
  live.debug = true;
}

const emitters = {
  keys: [],
  values: []
};

/**
 * Subscribe to the specific event of objects matching the pattern.
 * @function
 * @static
 * @param {RegExp} match - Regular expression for matching uris.
 * @param {String} name - The name of the event to listen for.
 * @param {Function} handle - The event handle.
 * @return {Function} The live function.
 */
live.subscribe = function (match, name, handle) {
  let newMatch = match;
  if (match.matches) {
    newMatch = newMatch.matches;
  }

  const string = newMatch.toString();

  const keys = emitters.keys;
  const innerValues = emitters.values;

  let emitter;
  for (let i = 0, len = keys.length; i < len; i++) {
    const key = keys[i];
    if (key.toString() === string) {
      emitter = innerValues[i];
      if (emitter) break;
    }
  }

  if (!emitter) {
    keys.push(match);
    innerValues.push(emitter = new Emitter());
  }

  emitter.on(name, handle);

  return this;
};

/**
 * Unsubscribe to the specific event of objects matching the pattern.
 * @function
 * @static
 * @param {RegExp} match - Regular expression for matching uris.
 * @param {String} name - The name of the event to unsubscribe from.
 * @param {Function} handle - The event handle.
 * @return {Function} The live function.
 */
live.unsubscribe = function (match, name, handle) {
  let newMatch = match;
  if (newMatch.matches) {
    newMatch = newMatch.matches;
  }

  const string = match.toString();

  const keys = emitters.keys;
  const innerValues = emitters.values;

  let emitter;
  for (let i = 0, len = keys.length; i < len; i++) {
    const key = keys[i];
    if (key.toString() === string) {
      emitter = innerValues[i];
      if (emitter) break;
    }
  }

  if (emitter) emitter.off(name, handle);

  return this;
};

/**
 * Delete a model from the live cache.
 *
 * @param {string} uri A uri.
 *
 * @return {Function} The live function.
 */
live.delete = function (uri) {
  delete cache[uri];
  return this;
};

/**
 * Purge the entire cache.
 *
 * @return {Function} The live function.
 */
live.purge = function () {
  cache = {};
  return this;
};

/**
 * Check if live has an object for the URI in the cache.
 *
 * @param {string} uri A uri.
 *
 * @return {Boolean} True if the object is in the cache.
 */
live.has = function (uri) {
  return !!cache[uri];
};

const EMIT_SYNC = live.EMIT_SYNC = Emitter.EMIT_SYNC;

const ASYNC = live.ASYNC = 'ASYNC';
const SYNC = live.SYNC = 'SYNC';
const ASAP = live.ASAP = 'ASAP';

const PUBLISH = 3;
const UPDATE = 4;

/**
 * @static
 * @see LiveObject
 */
live.Object = LiveObject;

/**
 * @static
 * @see LiveList
 */
live.List = LiveList;

module.exports = live;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../libs/prime":243,"../../libs/prime/defer":241,"../../libs/prime/emitter":242,"../debug":90,"../range2":245,"./util/ordered-set":212,"./util/parser":213,"./util/throttle":214,"mout/array/combine":442,"mout/array/difference":444,"mout/array/filter":447,"mout/array/map":451,"mout/lang/isPlainObject":468,"mout/lang/isRegExp":469,"mout/object/deepMixIn":473,"mout/object/pick":481,"mout/string/escapeRegExp":483}],211:[function(require,module,exports){
/**
 * @module live/diff
 */
'use strict';

// Original code from: https://github.com/codeparty/arraydiff
// License: MIT
// This has been forked to allow for optimizations and patching operations.

// Based on some rough benchmarking, this algorithm is about O(n^2) worst case,
// and it can compute diffs on random arrays of length 1024 in about 34ms,
// though just a few changes on an array of length 1024 takes about 0.5ms

const splice_ = Array.prototype.splice;
const slice_ = Array.prototype.slice;

const annotate = function annotate(before, after) {
  // Find all items in both the before and after array, and represent them
  // as moves. Many of these "moves" may end up being discarded in the last
  // pass if they are from an index to the same index, but we don't know this
  // up front, since we haven't yet offset the indices.
  //
  // Also keep a map of all the indicies accounted for in the before and after
  // arrays. These maps are used next to create insert and remove diffs.
  const beforeLength = before.length;
  const afterLength = after.length;
  const moves = [];
  const beforeMarked = {};
  const afterMarked = {};
  for (let beforeIndex = 0; beforeIndex < beforeLength; beforeIndex++) {
    const beforeItem = before[beforeIndex];
    for (let afterIndex = 0; afterIndex < afterLength; afterIndex++) {
      if (afterMarked[afterIndex]) continue;
      if (beforeItem !== after[afterIndex]) continue;
      const from = beforeIndex;
      const to = afterIndex;
      let length = 0;
      do {
        beforeMarked[beforeIndex++] = afterMarked[afterIndex++] = true;
        length++;
      } while (beforeIndex < beforeLength && afterIndex < afterLength && before[beforeIndex] === after[afterIndex] && !afterMarked[afterIndex]);
      const moveDiff = {
        type: 'move',
        from: from,
        to: to,
        length: length
      };
      moves.push(moveDiff);
      beforeIndex--;
      break;
    }
  }

  // Create a remove for all of the items in the before array that were
  // not marked as being matched in the after array as well
  const removes = [];
  for (let beforeIndex = 0; beforeIndex < beforeLength;) {
    if (beforeMarked[beforeIndex]) {
      beforeIndex++;
      continue;
    }
    const index = beforeIndex;
    let length = 0;
    while (beforeIndex < beforeLength && !beforeMarked[beforeIndex++]) {
      length++;
    }
    const removeDiff = {
      type: 'remove',
      index: index,
      length: length,
      values: slice_.call(before, index, index + length)
    };
    removes.push(removeDiff);
  }

  // Create an insert for all of the items in the after array that were
  // not marked as being matched in the before array as well
  const inserts = [];
  for (let afterIndex = 0; afterIndex < afterLength;) {
    if (afterMarked[afterIndex]) {
      afterIndex++;
      continue;
    }
    const index = afterIndex;
    let length = 0;
    while (afterIndex < afterLength && !afterMarked[afterIndex++]) {
      length++;
    }
    const values = slice_.call(after, index, index + length);
    inserts.push({ type: 'insert', index: index, length: length, values: values });
  }

  return [removes, moves, inserts];
};

const reduceMoves = function reduceMoves(moves) {
  for (let i = 0; i < moves.length; i++) {
    // if we detect a move operation of a lots of items to a near position, we
    // can swap it by a move operation of less items to a farther position
    // (which is going to be much more performant).
    //
    // Example:
    // [1, 2, 3, 4, 5, 6, 7] => [2, 3, 4, 5, 6, 7, 1]
    // We could move [2, 3, 4, 5, 6, 7] one position ahead, but it's better to
    // move [1] six positions behind.
    if (moves[i].length > Math.abs(moves[i].to - moves[i].from)) {
      const to = moves[i].to;
      const length = moves[i].length;

      moves[i].length = Math.abs(moves[i].to - moves[i].from);
      moves[i].from = to;
      moves[i].to = to + length;
    }
  }
};

const offset = function offset(removes, moves, inserts) {
  const insertsLength = inserts.length;
  const removesLength = removes.length;
  const movesLength = moves.length;

  // Offset subsequent removes and moves by removes
  let count = 0;
  for (let i = 0; i < removesLength; i++) {
    const remove = removes[i];
    remove.index -= count;
    count += remove.length;
    for (let j = 0; j < movesLength; j++) {
      const move = moves[j];
      if (move.from >= remove.index) move.from -= remove.length;
    }
  }

  // Offset moves by inserts
  for (let i = insertsLength; i--;) {
    const insert = inserts[i];
    const length = insert.length;
    for (let j = movesLength; j--;) {
      const move = moves[j];
      if (move.to >= insert.index) move.to -= length;
    }
  }

  // Offset the to of moves by later moves
  for (let i = movesLength; i-- > 1;) {
    const move = moves[i];
    if (move.to === move.from) continue;
    for (let j = i; j--;) {
      const earlier = moves[j];
      if (earlier.to >= move.to) earlier.to -= move.length;
      if (earlier.to >= move.from) earlier.to += move.length;
    }
  }

  // Only output moves that end up having an effect after offsetting
  const outputMoves = [];

  // Offset the from of moves by earlier moves
  for (let i = 0; i < movesLength; i++) {
    const move = moves[i];
    if (move.to === move.from) continue;
    outputMoves.push(move);
    for (let j = i + 1; j < movesLength; j++) {
      const later = moves[j];
      if (later.from >= move.from) later.from -= move.length;
      if (later.from >= move.to) later.from += move.length;
    }
  }

  // try to reduce the number of move events
  reduceMoves(outputMoves);

  return removes.concat(outputMoves, inserts);
};

const insert = function insert(array, index, values) {
  for (let i = 0; i < values.length; i++) {
    if (i in values) {
      const idx = index + i;
      if (array.length < idx) array.length = idx;
      array.splice(idx, 0, values[i]);
    }
  }
  return values;
};

const remove = function remove(array, index, length) {
  return splice_.call(array, index, length);
};

const move = function move(array, from, to, length) {
  const moved = remove(array, from, length);
  insert(array, to, moved);
  return moved;
};

const patch = function patch(array, operations) {
  for (let i = 0; i < operations.length; i++) {
    const operation = operations[i];
    switch (operation.type) {
      case 'move':
        move(array, operation.from, operation.to, operation.length);
        break;
      case 'remove':
        remove(array, operation.index, operation.length);
        break;
      case 'insert':
        insert(array, operation.index, operation.values);
        break;
      default:
        console.error('Unexpected operation type', operation.type);
        break;
    }
  }
  return array;
};

const diff = function diff(before, after) {
  const operations = annotate(before, after);
  return offset.apply(this, operations);
};

diff.annotate = annotate;
diff.offset = offset;

diff.remove = remove;
diff.insert = insert;
diff.move = move;
diff.patch = patch;

module.exports = diff;

},{}],212:[function(require,module,exports){
/**
 * @module live/util/ordered-set
 * @private
 */
'use strict';

// prime

const prime = require('../../../libs/prime');

// mout
const forEach = require('mout/array/forEach');

const Range = require('../../range2');
const diff = require('./diff');

const OrderedSet = prime({
  constructor: function (length = 0) {
    this.index = [];
    this.keys = new Array(length);
    this.values = new Array(length);
    this.objectStorage = {};
  },

  get length() {
    return this.keys.length;
  },

  set length(value) {
    this.keys.length = value;
    this.values.length = value;
  },

  forEach: function (fn, ctx) {
    const index = this.index;
    for (let k = 0; k < index.length; k++) {
      const range = index[k];
      for (let i = range.start; i < range.end; i++) {
        if (fn.call(ctx, this.values[i], i, this.keys[i], this) === false) {
          break;
        }
      }
    }
    return this;
  },

  map: function (fn, ctx) {
    const values = new Array(this.length);
    this.forEach(function (value, index, key) {
      values[index] = fn.call(ctx, value, index, key, this);
    }, this);
    return values;
  },

  copy: function (set) {
    this.index = set.index.slice();
    this.keys = set.keys.slice();
    this.values = set.values.slice();
    const length = this.keys.length;
    this.objectStorage = {};
    for (let i = 0; i < length; i++) {
      this.objectStorage[this.keys[i]] = this.values[i];
    }
    return this;
  },

  clone: function () {
    return new OrderedSet().copy(this);
  },

  indexOf: function (key) {
    let index = -1;
    this.forEach(function (v, i, k) {
      if (key === k) {
        index = i;
      }
    });
    return index;
  },

  indexOfMany: function (keys) {
    const indexedKeys = {};
    const output = [];

    // create a hash with the keys that are going to be searched, so we can
    // access them really fast later
    for (let i = 0; i < keys.length; i++) {
      indexedKeys[keys[i]] = -1;
    }

    this.forEach(function (v, i, k) {
      // If the element one that is being searched, add its position
      // to the output array
      if (k in indexedKeys) {
        indexedKeys[k] = i;
      }
    });

    for (let i = 0; i < keys.length; i++) {
      output[i] = indexedKeys[keys[i]];
    }

    return output;
  },

  valueOf: function (key) {
    return this.objectStorage[key] || null;
  },

  hasKey: function (key) {
    return this.objectStorage.hasOwnProperty(key);
  },

  sort: function (fn) {
    const keys = this.keys;
    const values = this.values;
    const operations = diff(values.slice(), values.sort(fn));

    forEach(operations, function (op) {
      // unless something is broken, a sort only produces moves.
      diff.move(keys, op.from, op.to, op.length);
    });

    return this;
  },

  move: function (from, to, length) {
    let newLength = length;
    let newTo = to;

    if (from > this.length) {
      return [];
    }
    if (from + newLength > this.length) {
      newLength = from - this.length;
    }
    if (newTo > this.length) {
      newTo = this.length;
    }
    if (from === newTo) {
      return [];
    }

    diff.move(this.keys, from, newTo, newLength);
    diff.move(this.values, from, newTo, newLength);

    return this;
  },

  insert: function (index, keys, values) {
    if (keys.length !== values.length) throw new Error('length mismatch');

    const range = new Range(index, index + keys.length);
    this.index = range.insert(this.index);

    diff.insert(this.keys, index, keys);
    diff.insert(this.values, index, values);

    for (let i = 0, length = keys.length; i < length; i++) {
      this.objectStorage[keys[i]] = values[i];
    }

    return this;
  },

  remove: function (index, length) {
    let newLength = length;

    if (index >= this.length) {
      return [];
    }
    if (index + newLength > this.length) {
      newLength = this.length;
    }

    const range = new Range(index, index + newLength);
    this.index = range.extract(this.index);

    for (let i = 0; i < newLength; i++) {
      delete this.objectStorage[this.keys[i + index]];
    }
    diff.remove(this.keys, index, newLength);
    diff.remove(this.values, index, newLength);

    return this;
  },

  diff: function (target) {
    const operations = diff.annotate(this.keys, target.keys);

    forEach(operations[0], function (op) {
      // remove
      op.keys = op.values;
      op.values = this.values.slice(op.index, op.index + op.length);
    }, this);

    forEach(operations[1], function (op) {
      // move
      op.keys = op.values;
      op.values = this.values.slice(op.from, op.from + op.length);
    }, this);

    forEach(operations[2], function (op) {
      // insert
      op.keys = op.values;
      op.values = target.values.slice(op.index, op.index + op.length);
    });

    return diff.offset.apply(diff, operations);
  },

  patch: function (operations) {
    forEach(operations, function (op) {
      switch (op.type) {
        case 'move':
          this.move(op.from, op.to, op.length);
          break;
        case 'remove':
          this.remove(op.index, op.length);
          break;
        case 'insert':
          this.insert(op.index, op.keys, op.values);
          break;
        default:
          console.error('Invalid patch operation type', op.type);
          break;
      }
    }, this);
    return this;
  }
});

module.exports = OrderedSet;

},{"../../../libs/prime":243,"../../range2":245,"./diff":211,"mout/array/forEach":448}],213:[function(require,module,exports){
/**
 * @module live/util/parser
 */
'use strict';

const normalize = function (value) {
  if (value !== '' && !isNaN(value)) return +value;else if (value === 'true') return true;else if (value === 'false') return false;else if (value === 'null') return null;else if (value === 'undefined') return undefined;
  return value;
};

function escapeForRegExp(str) {
  return str.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&');
}

const COMMA = ',';
const BMASK = '(';
const EMASK = ')';
const BFILTER = '[';
const EFILTER = ']';
const EQUALS = '=';
const WHITESPACE = '\\s';

const operators = ['=', '!=', '>=', '<=', '>', '<', '^=', '$=', '~=', '|=', '*='];

const keyBlacklist = COMMA + BMASK + EMASK + escapeForRegExp(BFILTER) + escapeForRegExp(EFILTER) + EQUALS + WHITESPACE;
const keyBlacklistCharacterClass = `[^${keyBlacklist}]`;

const KEY_CHARACTER_REG_EXP = new RegExp(keyBlacklistCharacterClass);
const EXACT_KEY_REG_EXP = new RegExp(`^${keyBlacklistCharacterClass}+$`);

const OPERATORS_REG_EXP = new RegExp(operators.map(escapeForRegExp).join('|'));
const REPLACE_REG_EXP = /\$([\d]+)/;
const RANGE_FILTER_REG_EXP = /^(\d*):(\d*)$/;

const parse = function (string, params = []) {
  let selector = { mask: [] };
  const history = [selector];

  let key = '';
  let filter;

  let filterStr = '';
  let left = '';
  let right = '';
  let op = '';

  for (let i = 0; i < string.length + 1; i++) {
    const c = string.charAt(i);

    if (filter) {
      // parse the filter
      filterStr = filterStr.trim();
      if (c === COMMA || c === EFILTER) {
        const match1 = filterStr.match(RANGE_FILTER_REG_EXP);
        const match2 = filterStr.match(OPERATORS_REG_EXP);
        const match3 = filterStr.match(EXACT_KEY_REG_EXP);
        if (match1) {
          left = match1[1];
          op = ':';
          right = match1[2];
        } else if (match2) {
          left = filterStr.substring(0, match2.index);
          op = match2[0];
          right = filterStr.substring(match2.index + op.length);
        } else if (match3) {
          left = match3[0];
        } else {
          throw new SyntaxError(`syntax error: \`${filterStr}\` contains characters not valid in a filter`);
        }

        filterStr = '';

        const condition = {};

        if (left) {
          const leftMatch = left.match(REPLACE_REG_EXP);
          left = leftMatch ? params[+leftMatch[1]] : normalize(left);
          condition.left = left;
        }

        if (op) condition.op = op;

        if (right) {
          const rightMatch = right.match(REPLACE_REG_EXP);
          right = rightMatch ? params[+rightMatch[1]] : normalize(right);
          condition.right = right;
        }

        if ('left' in condition || 'right' in condition) filter.push(condition);

        right = '';
        left = '';
        op = '';

        if (c === EFILTER) {
          if (filter.length) {
            const filters = selector.filters || (selector.filters = []);
            filters.push(filter);
          }

          filter = null;
        }
        continue;
      }

      filterStr += c;
    } else {
      // parse the key

      if (c && KEY_CHARACTER_REG_EXP.test(c)) {
        // key
        key += c;
      } else if (key && (!c || c === COMMA || c === BMASK || c === BFILTER || c === EMASK)) {
        // end key
        // end word is "a!" or "b(a!)" or "a!,c" or "a!(" or "a!["
        const keyMatch = key.match(REPLACE_REG_EXP);
        // begin a new selector
        history[0].mask.push(selector = { key: keyMatch ? params[+keyMatch[1]] : normalize(key) });
        key = '';
      } else if (c && key) {
        throw new SyntaxError(`syntax error: \`${c}\` is not a valid character in a key`);
      }

      if (c === BMASK) {
        selector.mask = [];
        history.unshift(selector);
      } else if (c === EMASK) {
        history.shift();
      }

      if (c === BFILTER) {
        filter = [];
      }
    }
  }

  if (history.length !== 1) throw new SyntaxError('syntax error');

  return history[0];
};

/** exports */
module.exports = parse;

},{}],214:[function(require,module,exports){
/**
 * @module live/util/throttle
 * @private
 */
'use strict';

const defer = require('../../../libs/prime/defer');
const isInteger = function (n) {
  return typeof n === 'number' && n % 1 === 0;
};

const slice = Array.prototype.slice;

const _throttle = function (fn, method, context) {
  let queued;
  let args;
  let cancel;

  return function () {
    args = arguments;
    if (!queued) {
      queued = true;
      cancel = method(function (time) {
        queued = false;
        fn.apply(context, slice.call(args).concat(time));
      });
    }
    return cancel;
  };
};

const throttle = function (callback, argument, context) {
  if (isInteger(argument)) return throttle.timeout(callback, argument, context);
  return throttle.immediate(callback, argument);
};

throttle.timeout = function (callback, ms, context) {
  return _throttle(callback, function (run) {
    return defer.timeout(run, ms, context);
  }, context);
};

throttle.immediate = function (callback, context) {
  return _throttle(callback, function (run) {
    return defer.immediate(run, context);
  }, context);
};

module.exports = throttle;

},{"../../../libs/prime/defer":241}],215:[function(require,module,exports){
(function (global){
'use strict';

let namespace;
let windowSpace = global;

function getNamespace() {
  if (!namespace) {
    namespace = `${windowSpace.__spotify.app_uri.split(':')[2]}:${encodeURIComponent(windowSpace.__spotify.username)}:`;
  }
  return namespace;
}

function set(key, value) {
  return windowSpace.localStorage.setItem(getNamespace() + key, value);
}

function get(key) {
  return windowSpace.localStorage.getItem(getNamespace() + key);
}

function remove(key) {
  return windowSpace.localStorage.removeItem(getNamespace() + key);
}

function clear() {
  namespace = getNamespace();
  Object.keys(windowSpace.localStorage).forEach(key => {
    if (key.startsWith(namespace)) {
      delete windowSpace.localStorage[key];
    }
  });
}

function _setNamespace(value) {
  namespace = value;
}

function useTopLocalStorage(isTopWindow) {
  windowSpace = isTopWindow ? global.top : global;
  namespace = null;
}

const storage = {
  set: set,
  get: get,
  remove: remove,
  clear: clear,
  _setNamespace: _setNamespace,
  useTopLocalStorage: useTopLocalStorage
};

module.exports = storage;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],216:[function(require,module,exports){
'use strict';

const languages = require('./languages.json');

function lookup(language, to) {
  const lang = languages[language];
  if (lang && lang[to]) {
    return lang[to];
  }
  return language;
}

module.exports = lookup;
module.exports.all = function () {
  return Object.keys(languages);
};

},{"./languages.json":217}],217:[function(require,module,exports){
module.exports={
  "cs": {
    "smartling": "cs-CZ"
  },
  "de": {
    "smartling": "de-DE"
  },
  "el": {
    "smartling": "el-GR"
  },
  "en": {
    "smartling": "en-GB"
  },
  "es": {
    "smartling": "es-ES"
  },
  "es-419": {
    "moment": "es",
    "smartling": "es-LA"
  },
  "fi": {
    "smartling": "fi-FI"
  },
  "fr": {
    "smartling": "fr-FR"
  },
  "fr-CA": {
    "smartling": "fr-CA",
    "moment": "fr-ca"
  },
  "hu": {
    "smartling": "hu-HU"
  },
  "id": {
    "smartling": "id-ID"
  },
  "it": {
    "smartling": "it-IT"
  },
  "ja": {
    "smartling": "ja-JP"
  },
  "nl": {
    "smartling": "nl-NL"
  },
  "pl": {
    "smartling": "pl-PL"
  },
  "pt-BR": {
    "moment": "pt-br",
    "smartling": "pt-BR"
  },
  "sv": {
    "smartling": "sv-SE"
  },
  "th": {
    "smartling": "th-TH"
  },
  "tr": {
    "smartling": "tr-TR"
  },
  "vi": {
    "smartling": "vi-VN"
  },
  "zh-Hant": {
    "moment": "zh-tw",
    "smartling": "zh-TW"
  },
  "zsm": {
    "moment": "ms-my",
    "smartling": "ms-MY",
    "spotify-numeral": "ms-MY"
  }
}

},{}],218:[function(require,module,exports){
'use strict';

const schemer = require('./schemer');
const cosmos = require('spotify-cosmos-api');
const debug = require('../../debug');

let id = 0;

module.exports = function log(schema, data) {
  const body = schemer(schema, Object.assign({}, {
    message_name: schema.name,
    message_version: schema.schema_version
  }, data));

  // Logging cosmos endpoint requires all values to be strings.
  body.fields = body.fields.map(function (f) {
    if (typeof f === 'string') return f;
    if (f === null) return '';
    return JSON.stringify(f);
  });

  const qualifiedName = schema.name + schema.schema_version;

  const messageDebug = debug(`logger:${qualifiedName}`);
  const requestId = ++id;

  messageDebug('REQ %s#%s %s', qualifiedName, requestId, JSON.stringify(body));

  cosmos.resolver.post({
    url: 'sp://logging/v3/log',
    body: body
  }, function (error, response) {
    if (error) {
      console.error(error, body);
    } else {
      messageDebug('RES %s#%s %d', qualifiedName, requestId, response.getStatusCode());
    }
  });
};

},{"../../debug":90,"./schemer":219,"spotify-cosmos-api":720}],219:[function(require,module,exports){
'use strict';

const validation = require('../../../vendor/avro-validator');
const debug = require('../../debug')('logger:');

module.exports = function (schema, data) {
  debug(schema.name);

  const name = data.message_name;
  const version = data.message_version;
  const copy = Object.assign({}, data);

  if (version !== schema.schema_version) {
    throw new Error(`${'' + 'Invalid message version: received Message with message_version '}${version} but the Schema requires version ${schema.schema_version}`);
  }

  // Create positional array of field values as required by cosmos and
  // log-parser, and also create an avro Field for each value to allow
  // validation.
  const fields = schema.fields.map(function (f) {
    const type = f.type;
    const value = copy[f.name];

    // If field is a union, attempt to infer the type by grabbing the first
    // non-null type from the schema.
    if (Array.isArray(f.type)) {
      copy[f.name] = {};
      const firstNoneNullType = type.filter(function (t) {
        return t !== 'null';
      })[0];
      copy[f.name][firstNoneNullType] = value;
      debug('union `%s` (%s) : `%s`', f.name, firstNoneNullType, value);
    } else {
      copy[f.name] = value;
      debug('field `%s` : `%s`', f.name, value);
    }
    return value === undefined ? f.default : value;
  })
  // remove name, version
  .slice(2);

  validation.Validator.validate(schema, copy);

  return {
    message: name,
    version: version,
    fields: fields
  };
};

module.exports.Validator = validation.Validator;
module.exports.ProtocolValidator = validation.ProtocolValidator;

},{"../../../vendor/avro-validator":759,"../../debug":90}],220:[function(require,module,exports){
'use strict';

const schema = require('../schemas/AddToPlaylist3.json');
const log = require('../lib/log');

module.exports = {
  schema: schema,
  log: log.bind(null, schema)
};

},{"../lib/log":218,"../schemas/AddToPlaylist3.json":224}],221:[function(require,module,exports){
'use strict';

const schema = require('../schemas/ClientEvent3.json');
const log = require('../lib/log');

module.exports = {
  schema: schema,
  log: log.bind(null, schema)
};

},{"../lib/log":218,"../schemas/ClientEvent3.json":225}],222:[function(require,module,exports){
'use strict';

const schema = require('../schemas/UIInteraction5.json');
const log = require('../lib/log');

module.exports = {
  schema: schema,
  log: log.bind(null, schema)
};

},{"../lib/log":218,"../schemas/UIInteraction5.json":226}],223:[function(require,module,exports){
'use strict';

const schema = require('../schemas/UserDragAndDropInteraction1.json');
const log = require('../lib/log');

module.exports = {
  schema: schema,
  log: log.bind(null, schema)
};

},{"../lib/log":218,"../schemas/UserDragAndDropInteraction1.json":227}],224:[function(require,module,exports){
module.exports={
  "namespace": "com.spotify.Message",
  "type": "record",
  "name": "AddToPlaylist",
  "fields": [
    {
      "type": "string",
      "name": "message_name"
    },
    {
      "type": "int",
      "name": "message_version"
    },
    {
      "default": null,
      "doc": "Create playlist, save to collection, save to existing playlist etc.",
      "type": [
        "null",
        "string"
      ],
      "name": "intent"
    },
    {
      "default": null,
      "doc": "URI of item that was added and only the first if multiple.",
      "type": [
        "null",
        "string"
      ],
      "name": "item_uri"
    },
    {
      "default": null,
      "doc": "Number of items added.",
      "type": [
        "null",
        "string"
      ],
      "name": "number_items"
    },
    {
      "default": null,
      "doc": "What section the item where added from.",
      "type": [
        "null",
        "string"
      ],
      "name": "section"
    },
    {
      "default": null,
      "doc": "The view uri which led to add to playlist.",
      "type": [
        "null",
        "string"
      ],
      "name": "source"
    },
    {
      "default": null,
      "doc": "The action which led to add to playlist.",
      "type": [
        "null",
        "string"
      ],
      "name": "source_action"
    },
    {
      "default": null,
      "doc": "The position of playlist added to or null.",
      "type": [
        "null",
        "int"
      ],
      "name": "playlist_index"
    },
    {
      "default": null,
      "doc": "The uri of playlist added to or null.",
      "type": [
        "null",
        "string"
      ],
      "name": "playlist_uri"
    },
    {
      "default": null,
      "doc": "The total number of items displayed.",
      "type": [
        "null",
        "int"
      ],
      "name": "total_number_playlists"
    },
    {
      "default": null,
      "doc": "Unix timestamp",
      "type": [
        "null",
        "long"
      ],
      "name": "time"
    }
  ],
  "doc": "User interacted with add to playlist.",
  "schema_version": 3
}
},{}],225:[function(require,module,exports){
module.exports={
  "type": "record",
  "name": "ClientEvent",
  "namespace": "com.spotify.Message",
  "doc": "A generic client event primarily used by Stitch Apps",
  "fields": [
    {
      "name": "message_name",
      "type": "string"
    },
    {
      "name": "message_version",
      "type": "int"
    },
    {
      "name": "source",
      "type": [
        "null",
        "string"
      ],
      "doc": "Source which generated the event, will mostly be set to the App-ID",
      "default": null
    },
    {
      "name": "context",
      "type": [
        "null",
        "string"
      ],
      "doc": "Optional context within the app",
      "default": null
    },
    {
      "name": "event",
      "type": [
        "null",
        "string"
      ],
      "doc": "Event name",
      "default": null
    },
    {
      "name": "event_version",
      "type": [
        "null",
        "string"
      ],
      "doc": "Optional event version, can be used as a version or sub-type",
      "default": null
    },
    {
      "name": "test_version",
      "type": [
        "null",
        "string"
      ],
      "doc": "Optional test case if A/B testing",
      "default": null
    },
    {
      "name": "source_version",
      "type": [
        "null",
        "string"
      ],
      "doc": "The version of the app",
      "default": null
    },
    {
      "name": "source_vendor",
      "type": [
        "null",
        "string"
      ],
      "doc": "The app vendor",
      "default": null
    },
    {
      "name": "json_data",
      "type": [
        "null",
        "string"
      ],
      "doc": "Additional JSON data specific to the event being sent",
      "default": null
    }
  ],
  "schema_version": 3
}
},{}],226:[function(require,module,exports){
module.exports={
  "type": "record",
  "name": "UIInteraction",
  "namespace": "com.spotify.Message",
  "doc": "A UI interaction log",
  "fields": [
    {
      "name": "message_name",
      "type": "string"
    },
    {
      "name": "message_version",
      "type": "int"
    },
    {
      "name": "request_id",
      "type": [
        "null",
        "string"
      ],
      "doc": "Request ID from Spaces Log",
      "default": null
    },
    {
      "name": "feature_id",
      "type": [
        "null",
        "string"
      ],
      "doc": "A name for a feature (e.g., browse-new-releases, collection, etc.)",
      "default": null
    },
    {
      "name": "pageuri",
      "type": [
        "null",
        "string"
      ],
      "doc": "Uri of the page within the feature (e.g., spotify:hub:music, etc.)",
      "default": null
    },
    {
      "name": "section_id",
      "type": [
        "null",
        "string"
      ],
      "doc": "Section or block of the page (e.g., Early Morning)",
      "default": null
    },
    {
      "name": "item_index",
      "type": [
        "null",
        "int"
      ],
      "doc": "Index of item in block",
      "default": null
    },
    {
      "name": "target_uri",
      "type": [
        "null",
        "string"
      ],
      "doc": "Destination of interaction",
      "default": null
    },
    {
      "name": "interaction_type",
      "type": [
        "null",
        "string"
      ],
      "doc": "Type of interaction (e.g., hit, swipe, hold, hover, etc.)",
      "default": null
    },
    {
      "name": "user_intent",
      "type": [
        "null",
        "string"
      ],
      "doc": "Grouping of interactions based on user intent (e.g., play, navigate-forward, navigate-back)",
      "default": null
    },
    {
      "name": "timestamp",
      "type": [
        "null",
        "double"
      ],
      "doc": "Unix timestamp of event",
      "default": null
    }
  ],
  "schema_version": 5
}
},{}],227:[function(require,module,exports){
module.exports={
  "type": "record",
  "name": "UserDragAndDropInteraction",
  "namespace": "com.spotify.Message",
  "doc": "Logged whenever a user drags and drops (currently desktop only) an item in the client. Only completed drag and drops are logged and not canceled/failed ones.",
  "fields": [
    {
      "name": "message_name",
      "type": "string"
    },
    {
      "name": "message_version",
      "type": "int"
    },
    {
      "name": "item_type",
      "type": [
        "null",
        "string"
      ],
      "doc": "Type of item, eg \"track\".",
      "default": null
    },
    {
      "name": "item_uri",
      "type": [
        "null",
        "string"
      ],
      "doc": "Uri of item that was dropped and only the first if multiple.",
      "default": null
    },
    {
      "name": "number_items",
      "type": [
        "null",
        "long"
      ],
      "doc": "Number of items dropped.",
      "default": null
    },
    {
      "name": "source_view_uri",
      "type": [
        "null",
        "string"
      ],
      "doc": "View uri from where the drag started, eg \"spotify:app:playlist\".",
      "default": null
    },
    {
      "name": "source_uri",
      "type": [
        "null",
        "string"
      ],
      "doc": "Uri of the context from where the drag started, eg: \"spotify:user:spotify:playlist:1m6DKwKNM1YLcm3OX6RzJg\".",
      "default": null
    },
    {
      "name": "source_index",
      "type": [
        "null",
        "long"
      ],
      "doc": "Index of the item from where the drag started.",
      "default": null
    },
    {
      "name": "source_component",
      "type": [
        "null",
        "string"
      ],
      "doc": "Id of the component from where the drag started, eg: \"header/title\" if the user dragged a playlist via the playlist title in the header.",
      "default": null
    },
    {
      "name": "target_view_uri",
      "type": [
        "null",
        "string"
      ],
      "doc": "View uri where the drop ended, eg \"spotify:app:zlink\".",
      "default": null
    },
    {
      "name": "target_uri",
      "type": [
        "null",
        "string"
      ],
      "doc": "Uri of the context where the drop ended, \"spotify:user:spotify:rootlist\".",
      "default": null
    },
    {
      "name": "target_index",
      "type": [
        "null",
        "long"
      ],
      "doc": "Index where dropped.",
      "default": null
    },
    {
      "name": "target_component",
      "type": [
        "null",
        "string"
      ],
      "doc": "Id of the component where the drop ended, eg: \"player/queue\" if dropped on the Queue button in the player component.",
      "default": null
    },
    {
      "name": "ms_duration",
      "type": [
        "null",
        "long"
      ],
      "doc": "The duration in milliseconds from the start of the drag until the end of the drop.",
      "default": null
    }
  ],
  "schema_version": 1
}
},{}],228:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.messageProxy = messageProxy;

var _debug = require('../debug');

var _debug2 = _interopRequireDefault(_debug);

var _uris = require('./uris.json');

var _uris2 = _interopRequireDefault(_uris);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * This module is to be included in zlink
 */

const METHODS = ['POST', 'SUB', 'GET', 'REPLY'];
const BASE_URI = 'message-proxy';
const debug = (0, _debug2.default)('message-proxy');

function messageProxy(requestObj, callback) {
  if (typeof window === 'undefined' || !window.top || !window.top.postMessage) {
    return false;
  }

  const uri = requestObj.uri;

  // Validate Request
  if (!requestObj) throw new Error('Need a request object.');
  if (METHODS.indexOf(requestObj.method) === -1) {
    throw new Error('Need a valid method:', METHODS);
  }
  if (!callback && !requestObj.method === 'POST') {
    throw new Error('Callback needed');
  }
  if (!_uris2.default.hasOwnProperty(uri)) {
    throw new Error('Uri need to be one of these: ', Object.keys(_uris2.default));
  }

  const data = {};
  const requiredKeys = _uris2.default[uri][requestObj.method] || [];

  // GET
  if (requestObj.method === 'GET') {
    requiredKeys.forEach(requiredKey => {
      if (!requestObj.body.hasOwnProperty(requiredKey)) {
        throw new Error(`Uri 'GET' request body missing
                        a required key: ${requiredKey}`);
      }
      data[requiredKey] = requestObj.body[requiredKey];
    });

    const getListener = event => {
      if (!isEventValid(event, `${BASE_URI}-${uri}-reply`)) {
        return;
      }
      debug('getListener', uri, event.data);
      if (event.data.error) {
        callback(event.data.error);
      } else {
        delete event.data.uri;
        callback(null, event.data);
      }
      window.removeEventListener('message', getListener);
    };
    window.addEventListener('message', getListener);

    data.uri = `${BASE_URI}-${uri}-get`;
    debug('get', uri, data);
    const messagePosted = postMessageToFrame(requestObj.target, data);
    if (!messagePosted) {
      window.removeEventListener('message', getListener);
      callback('No frame found to post to.');
    }
    return true;
  }

  // REPLY
  if (requestObj.method === 'REPLY') {
    const replyListener = event => {
      if (!isEventValid(event, `${BASE_URI}-${uri}-get`)) {
        return;
      }
      debug('reply listener', uri, event.data);
      delete event.data.uri;
      callback(event.data, function reply(replyErr, rawData) {
        const replyData = {};
        if (replyErr) {
          replyData.error = replyErr;
        } else {
          requiredKeys.forEach(requiredKey => {
            if (!rawData.hasOwnProperty(requiredKey)) {
              throw new Error(`Reply data missing
                              a required key: ${requiredKey}`);
            }
            replyData[requiredKey] = rawData[requiredKey];
          });
        }
        replyData.uri = `${BASE_URI}-${uri}-reply`;
        debug('reply post', uri, replyData);
        event.source.postMessage(replyData, event.origin);
      });
    };
    window.addEventListener('message', replyListener, false);

    return () => {
      window.removeEventListener('message', replyListener);
    };
  }

  // POST
  if (requestObj.method === 'POST') {
    requiredKeys.forEach(requiredKey => {
      if (!requestObj.body.hasOwnProperty(requiredKey)) {
        throw new Error(`Uri 'POST' request body missing
                        a required key: ${requiredKey}`);
      }
      data[requiredKey] = requestObj.body[requiredKey];
    });

    data.uri = `${BASE_URI}-${uri}`;
    debug('post', uri, data);
    const messagePosted = postMessageToFrame(requestObj.target, data);
    if (callback) {
      if (!messagePosted) {
        callback('No frame found to post to.');
      } else {
        callback(null);
      }
    }
    return true;
  }
  // Subscription
  const sub = event => {
    if (!isEventValid(event, `${BASE_URI}-${uri}`)) {
      return;
    }
    debug('subscription event', uri, event.data);
    callback(event.data);
  };

  debug('subscription', uri);
  window.addEventListener('message', sub, false);
  return () => {
    window.removeEventListener('message', sub);
  };
}

const originRegex = new RegExp('^https?://[a-zA-Z-]*.app.spotify.com');

function isEventValid(event, uri) {
  if (!originRegex.test(event.origin)) {
    return false;
  }
  if (event.data.uri !== uri) {
    return false;
  }
  return true;
}

function postMessageToFrame(target, data) {
  if (target === 'top' || !target) {
    debug('postMessageToFrame target=top data=%o', data);
    window.top.postMessage(data, '*');
    // no need to continue
    if (target === 'top') {
      return true;
    }
  }
  let frames;
  let frameFound;
  if (window === window.top) {
    frames = window.top.frames;
  } else {
    const topFrames = Array.prototype.slice.call(window.top.frames, 0, window.top.frames.length);
    const thisFrames = Array.prototype.slice.call(window.frames, 0, window.frames.length);
    frames = topFrames.concat(thisFrames);
  }

  const len = frames.length;
  for (let i = 0; i < len; i++) {
    if (target && target !== frames[i].frameElement.src) {
      continue;
    }
    debug('postMessageToFrame target=%o data=%o', frames[i].frameElement.target, data);
    frames[i].postMessage(data, '*');
    frameFound = true;
  }

  debug('postMessageToFrame framesLength=%o frameFound=%o', len, frameFound);
  return frameFound;
}

},{"../debug":90,"./uris.json":229}],229:[function(require,module,exports){
module.exports={
  "unit-test": {
    "GET": ["key1"],
    "POST": ["key2"],
    "REPLY": ["key3"]
  },
  "client-state": {
    "SUB": [],
    "POST": ["state"],
    "GET": [],
    "REPLY": ["state"]
  },
  "history": {
    "GET": ["count"],
    "REPLY": ["history"]
  },
  "hpto": {
    "REPLY": ["ad"],
    "GET": []
  },
  "hpto-refresh": {
    "SUB": [],
    "POST": []
  },
  "station": {
    "GET": ["stationUri", "metadata", "trackCount"],
    "REPLY": ["stationUri", "station"]
  },
  "station-add": {
    "POST": ["stationUri", "add"]
  },
  "station-autoplay": {
    "POST": ["contextUri", "playerPlaybackId", "prevTracks"],
    "SUB": []
  },
  "station-create": {
    "POST": ["stationUri"],
    "SUB": []
  },
  "station-error": {
    "POST": ["stationUri", "message"],
    "SUB": []
  },
  "station-metadata": {
    "POST": ["stationUri", "metadata"]
  },
  "station-last-played": {
    "POST": ["stationUri"]
  },
  "station-thumb": {
    "POST": ["stationUri", "trackUri", "thumb"]
  },
  "station-heart": {
    "POST": ["stationUri", "trackUri"]
  },
  "station-undo-feedback": {
    "POST": ["stationUri", "trackUri", "thumbAction"]
  },
  "stations-all": {
    "GET": [],
    "REPLY": ["user_stations", "genre_stations", "recommended_stations"]
  },
  "stations-saved": {
    "GET": [],
    "REPLY": ["saved_stations"]
  },
  "format-list-heart": {
    "POST": ["entityUri", "trackUri"]
  },
  "format-list-undo-feedback": {
    "POST": ["entityUri", "trackUri"]
  }
}

},{}],230:[function(require,module,exports){
'use strict';

var _pageIdentifiers = require('./page-identifiers.js');

var _pageIdentifiers2 = require('./page-identifiers.json');

var _pageIdentifiers3 = _interopRequireDefault(_pageIdentifiers2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const UUID = require('uuid-js');

/**
 * Object representing state of an app.
 *
 * @param {String} uri Spotify URI of app.
 * @constructor
 */
function AppState(uri) {
  /**
   * Spotify URI.
   *
   * @type {String}
   */
  this._uri = undefined;

  if (uri !== undefined) {
    this.setURI(uri);
  }

  /**
   *  Unique ID of this Application.
   *
   *  @type {String}
   */
  this._uuid = UUID.create().toString();
}

/**
 * Create new instance of AppState based on JSON string.
 *
 * @param {String} json Serialized representation of AppState object.
 * @return {AppState} Instance of AppState.
 */
AppState.unserialize = function (json) {
  const s = JSON.parse(json);
  const a = new AppState();
  a.setURI(s.uri);
  return a;
};

/**
 * Test if another object is considered equal to this.
 *
 * @param {AppState} state AppState instance to compare.
 */
AppState.prototype.equals = function (state) {
  return typeof this._uri === 'string' && state instanceof AppState && this._uri === state._uri;
};

/**
 * Test if another app state is for the same app.
 *
 * @param {AppState} state AppState instance to compare.
 */
AppState.prototype.equalsApp = function (state) {
  const id = this.getAppId();
  return state && id && state.getAppId() === id || false;
};

/**
 * Get App identifier.
 *
 * @return {String} Id of app contained in URI.
 */
AppState.prototype.getAppId = function () {
  const uri = this.getURI();
  const parts = uri.split(':');
  if (parts.length < 3) {
    return undefined;
  }
  if (parts[1] !== 'app') {
    return undefined;
  }
  if (parts[2] === '') {
    return undefined;
  }
  return parts[2];
};

/**
 * Get App URI without arguments.
 *
 * @return {String} URI of app without arguments.
 */
AppState.prototype.getAppURI = function () {
  return this.getURI().split(':').slice(0, 3).join(':');
};

/**
 * Get App arguments
 *
 * @return {Array} List of app arguments.
 */
AppState.prototype.getArgs = function () {
  return this.getURI().split(':').slice(3).map(function (a) {
    return decodeURIComponent(a);
  });
};

/**
 * Get URI value.
 *
 * @return {String} URI as string.
 */
AppState.prototype.getURI = function () {
  if (this._uri === undefined) {
    throw new Error('URI not set');
  }
  return this._uri;
};

/**
 * Create serialized representation of this instance.
 *
 * @return {String} Serialized representation of AppState object.
 */
AppState.prototype.serialize = function () {
  return JSON.stringify({
    uri: this.getURI()
  });
};

/**
 * Set arguments for state.
 *
 * @param {Array} args Arguments as array.
 */
AppState.prototype.setArgs = function (args) {
  if (!Array.isArray(args)) {
    throw new TypeError('Args must be array');
  }

  this._uri = this.getAppURI().split(':').concat(args.map(function (a) {
    return encodeURIComponent(a);
  })).join(':');
};

/**
 * Set URI value.
 *
 * @param {String} uri Spotify URI for app.
 */
AppState.prototype.setURI = function (uri) {
  if (typeof uri !== 'string') {
    throw new TypeError('URI must be string');
  }
  this._uri = uri;
};

/**
 * Get UUID value.
 *
 * @return {String} UUID as string.
 */
AppState.prototype.getUUID = function () {
  return this._uuid;
};

/**
 * Get Page ID.
 *
 * @return {String} Page ID as string.
 */
AppState.prototype.getPageID = function () {
  return (0, _pageIdentifiers.getPageIdFromUri)(this.getAppId(), this.getURI());
};

/**
 * Check if page is covered
 *
 * @return {Boolean} True if page ID is known.
 */
AppState.prototype.isPageCovered = function () {
  return this.getPageID() !== _pageIdentifiers3.default.unknownUncovered;
};

module.exports = AppState;

},{"./page-identifiers.js":234,"./page-identifiers.json":233,"uuid-js":738}],231:[function(require,module,exports){
'use strict';

module.exports = {
  AppState: require('./app-state'),
  Navigator: require('./navigator')
};

},{"./app-state":230,"./navigator":232}],232:[function(require,module,exports){
(function (global){
'use strict';

const inherit = require('spotify-inheritance/inherit');
const EventEmitter = require('spotify-eventemitter');
const AppState = require('./app-state');

/**
 * Class containing methods for navigating.
 *
 * @constructor
 */
function Navigator() {
  this._global = global.top || global;

  EventEmitter.call(this);

  /**
   * Locally bound handler function for message event on global.
   *
   * @type {Function}
   */
  this._messageHandler = this._messageHandler.bind(this);
}

inherit(Navigator, EventEmitter);

/**
 * Maps constants to string values of supported events.
 */
Navigator.prototype.EVENTS = Navigator.EVENTS = {
  REQUEST_STATE: 'navigation_request_state'
};

/**
 * Maps constants to string values of supported methods.
 */
Navigator.prototype.METHOD = Navigator.METHOD = {
  OPEN: 'open',
  TOGGLE: 'toggle'
};

/**
 * Identify posted message and trigger relevant callbacks
 * based on the message contents.
 *
 * @param {Object} message Message object caused by postMessage.
 */
Navigator.prototype._messageHandler = function (message) {
  if (!message.data.type) {
    return;
  }
  const type = message.data.type;
  if (type === Navigator.EVENTS.REQUEST_STATE) {
    const appState = AppState.unserialize(message.data.state);
    const syncEvent = {
      state: appState,
      method: message.data.method
    };
    if (message.data.extra) {
      syncEvent.extra = JSON.parse(message.data.extra);
    }
    this.emitSync(type, syncEvent);
  }
};

/**
 * Start listening to messages.
 */
Navigator.prototype.attachListener = function () {
  this._global.addEventListener('message', this._messageHandler);
};

/**
 * Stop listening to messages.
 */
Navigator.prototype.detachListener = function () {
  this._global.removeEventListener('message', this._messageHandler);
};

/**
 * Short hand method for requesting open AppState with URI only.
 *
 * @param {string} uri URI to open.
 */
Navigator.prototype.openURI = function (uri, options = {}) {
  this.requestOpenState(new AppState(uri), options);
};

/**
 * Short hand method for requesting toggle of AppState with URI only.
 *
 * @param {string} uri URI to open.
 */
Navigator.prototype.toggleURI = function (uri) {
  this.requestToggleState(new AppState(uri));
};

/**
 * Send an open request message.
 *
 * @param {AppState} state AppState instance to base open action on.
 */
Navigator.prototype.requestOpenState = function (state, options = {}) {
  this.requestState(state, this.METHOD.OPEN, options);
};

/**
 * Send a toggle request message.
 *
 * @param {AppState} state AppState instance to base open action on.
 */
Navigator.prototype.requestToggleState = function (state) {
  this.requestState(state, this.METHOD.TOGGLE);
};

/**
 * Send an request for an app state.
 *
 * @param {AppState} state AppState object representing state to request.
 * @param {string} method Method to use.
 */
Navigator.prototype.requestState = function (state, method, options = null) {
  if (!state) {
    throw new TypeError('AppState not set');
  }
  if (!method) {
    throw new TypeError('Method not set');
  }

  const message = {
    type: this.EVENTS.REQUEST_STATE,
    method: method,
    state: state.serialize()
  };

  if (options) {
    message.extra = JSON.stringify(options);
  }

  this._global.postMessage(message, '*');
};

module.exports = Navigator;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./app-state":230,"spotify-eventemitter":726,"spotify-inheritance/inherit":729}],233:[function(require,module,exports){
module.exports={
  "album": "album",
  "artist": "artist",
  "artistAbout": "artist/about",
  "artistAlbums": "artist/albums",
  "artistBio": "artist/bio",
  "artistConcerts": "artist/concerts",
  "artistGallery": "artist/gallery",
  "artistPlaylists": "artist/playlists",
  "artistRelated": "artist/related",
  "browse": "browse",
  "browseCharts": "browse/charts",
  "browseDiscover": "browse/discover",
  "browseGenres": "browse/genres",
  "browseNewReleases": "browse/newreleases",
  "browsePodcasts": "browse/podcasts",
  "browseVideos": "browse/videos",
  "charts": "charts",
  "chartsChart": "charts/chart",
  "chartsRegional": "charts/regional",
  "chartsSocial": "charts/social",
  "chartsViral": "charts/viral",
  "collection": "collection",
  "collectionAlbums": "collection/albums",
  "collectionAlbumsAlbum": "collection/albums/album",
  "collectionArtists": "collection/artists",
  "collectionArtistsArtist": "collection/artists/artist",
  "collectionPlaylists": "collection/playlists",
  "collectionRadio": "collection/radio",
  "collectionRecentlyPlayed": "collection/recently-played",
  "collectionShows": "collection/shows",
  "collectionSongs": "collection/songs",
  "concert": "concert",
  "concerts": "concerts",
  "concertsCitysearch": "concerts/citysearch",
  "concertsConcert": "concerts/concert",
  "debug": "debug",
  "lyrics": "lyrics",
  "moments": "moments",
  "momentsCategory": "moments/category",
  "music": "music",
  "musicCategory": "music/category",
  "now": "now",
  "nowplaying": "nowplaying",
  "nowplayingDevicepicker": "connect/devicepicker",
  "nowplayingHistory": "nowplaying/history",
  "nowplayingQueue": "nowplaying/queue",
  "party": "party",
  "partyAddFriends": "party/add-friends",
  "partyEnableBluetooth": "party/enable-bluetooth",
  "partyEnableNearby": "party/enable-nearby",
  "partyPreset": "party/preset",
  "partyQueue": "party/queue",
  "playlist": "playlist",
  "playlistFolder": "playlist/folder",
  "profile": "profile",
  "profileActivity": "profile/activity",
  "profileArtists": "profile/artists",
  "profileFollowers": "profile/followers",
  "profileFollowing": "profile/following",
  "profilePlaylists": "profile/playlists",
  "radio": "radio",
  "radioDailyMixes": "radio/daily-mixes",
  "radioStation": "radio/station",
  "running": "running",
  "runningCategory": "running/category",
  "runningSetup": "running/setup",
  "search": "search",
  "searchAlbums": "search/albums",
  "searchArtists": "search/artists",
  "searchGenres": "search/genres",
  "searchPlaylists": "search/playlists",
  "searchProfiles": "search/profiles",
  "searchRadio": "search/radio",
  "searchShows": "search/shows",
  "searchSongs": "search/songs",
  "searchVideos": "search/videos",
  "settings": "settings",
  "show": "show",
  "shows": "shows",
  "showsAudio": "shows/audio",
  "showsCategory": "shows/category",
  "showsNetwork": "shows/network",
  "showsVideo": "shows/video",
  "unknown": "unknown",
  "unknownUncovered": "unknown/uncovered"
}

},{}],234:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getPageIdFromUri = getPageIdFromUri;
exports.getPageIdFromAppArguments = getPageIdFromAppArguments;

var _pageIdentifiers = require('./page-identifiers.json');

var _pageIdentifiers2 = _interopRequireDefault(_pageIdentifiers);

var _spotifyLiburi = require('spotify-liburi');

var _spotifyLiburi2 = _interopRequireDefault(_spotifyLiburi);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const extractArg = argNumber => args => args.length > argNumber && args[argNumber] || null;
const extractHubArg = uri => {
  if (extractArg(0)(uri) === 'charts') {
    // For charts uris: spotify:app:hub:*charts*:*viral*
    return `charts-${extractArg(1)(uri)}`;
  }

  // Everything else can be treated as genre
  return 'genre';
};

/**
 * Maps the name of the app with the name of the identifier that has to be used
 * for logging the page view.
 */
const PAGE_LOGGER_MAP = {
  'album': 'album',
  'app-manager': 'debug',
  'artist-concerts': 'concerts',
  'artist-creator-about': 'artistAbout',
  'artist-overview': 'artist',
  'artist-related': 'artistRelated',
  'artist': 'artist',
  'boilerplate': 'debug',
  'browse-charts': 'charts',
  'browse-discover': 'browseDiscover',
  'browse-genres': 'browseGenres',
  'browse-home': 'browse',
  'browse-releases': 'browseNewReleases',
  'browse-podcasts': 'browsePodcasts',
  'browse-videos': 'browseVideos',
  'browse': 'browse',
  'chart': 'chartsChart',
  'charts': 'charts',
  'collection-album': 'collectionAlbumsAlbum',
  'collection-albums': 'collectionAlbums',
  'collection-artist': 'collectionArtistsArtist',
  'collection-artists': 'collectionArtists',
  'collection-podcasts': 'collectionShows',
  'collection-songs': 'collectionSongs',
  'collection-videos': 'collectionShows',
  'collection': 'collection',
  'concert': 'concert',
  'concerts': 'concerts',
  'daily-mix-hub': 'radioDailyMixes',
  'diag': 'debug',
  'discover': 'browseDiscover',
  'friends-mix': 'friendsMix',
  'genre': 'browseGenres',
  'glue-header-demo': 'debug',
  'glue-reference': 'debug',
  'glue-grid-demo': 'debug',
  'hub-charts-regional': 'chartsRegional',
  'hub-charts-viral': 'chartsViral',
  'hub-genre': 'browseGenres',
  'lyrics': 'lyrics',
  'neo-search': 'search',
  'neo-search-albums': 'searchAlbums',
  'neo-search-artists': 'searchArtists',
  'neo-search-genres': 'searchGenres',
  'neo-search-playlists': 'searchPlaylists',
  'neo-search-profiles': 'searchProfiles',
  'neo-search-shows': 'searchShows',
  'neo-search-tracks': 'searchSongs',
  'neo-search-videoepisodes': 'searchVideos',
  'playlist': 'playlist',
  'playlist-folder': 'playlistFolder',
  'profile-followers': 'profileFollowers',
  'profile-following': 'profileFollowing',
  'profile-overview': 'profile',
  'profile-public-playlists': 'profilePlaylists',
  'profile-recently-played-artists': 'profileArtists',
  'profile': 'profile',
  'radio-hub': 'radio',
  'radio': 'radio',
  'recently-played': 'collectionRecentlyPlayed',
  'search-albums': 'searchAlbums',
  'search-artists': 'searchArtists',
  'search-genres': 'searchGenres',
  'search-playlists': 'searchPlaylists',
  'search-profiles': 'searchProfiles',
  'search-tracks': 'searchSongs',
  'search': 'search',
  'settings': 'settings',
  'show': 'show',
  'station': 'radioStation',
  'stations': 'collectionRadio',
  'video-debug': 'debug',
  'queue-history': 'nowplayingHistory',
  'queue-queue': 'nowplayingQueue',
  'queue': 'nowplayingQueue'
};

const EXTRACT_SECTION = {
  // Browse section is the first app argument (i.e.: spotify:app:browse:*releases*)
  'browse': extractArg(0),
  // Artist and profile have the argument after the id (i.e.: spotify:user:spotify:*followers*)
  'artist': extractArg(1),
  'profile': extractArg(1),
  // Queue (spotify:app:queue and spotify:app:queue:history)
  'queue': extractArg(0),
  // Search section is the argument after the search query (spotify:app:search:<query>:*albums*)
  // or for neo-search (spotify:app:neo-search:<query>:*albums*)
  'search': extractArg(1),
  'neo-search': extractArg(1),
  // Hub (spotify:app:hub:*charts*:*viral* or spotify:app:hub:*special*:*thebeatles*)
  'hub': extractHubArg,
  // Collection (spotify:app:collection for albums and artists)
  'collection': extractArg(0)
};

function getPageIdFromUri(appId, inputUri) {
  if (appId in EXTRACT_SECTION) {
    const uri = _spotifyLiburi2.default.from(inputUri);
    const section = EXTRACT_SECTION[appId](uri.args);
    return getPageIdFromAppIdAndSection(appId, section);
  }
  return getPageIdFromAppIdAndSection(appId);
}

function getPageIdFromAppArguments(appId, appArguments) {
  if (appId in EXTRACT_SECTION) {
    const section = EXTRACT_SECTION[appId](appArguments);
    return getPageIdFromAppIdAndSection(appId, section);
  }
  return getPageIdFromAppIdAndSection(appId);
}

function getPageIdFromAppIdAndSection(inputAppId, section) {
  let appId = inputAppId;
  if (section) {
    // The appId of an app with sections should be APP-SECTION,
    // such as 'browse-genres'
    appId = `${appId}-${section}`;
  }
  const normalizedAppId = PAGE_LOGGER_MAP[appId];
  return _pageIdentifiers2.default[normalizedAppId] || _pageIdentifiers2.default.unknownUncovered;
}

},{"./page-identifiers.json":233,"spotify-liburi":730}],235:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.fetchMadeFors = fetchMadeFors;
exports.fetchMadeFor = fetchMadeFor;
exports.buildMadeFor = buildMadeFor;
exports.originalPlaylistUri = originalPlaylistUri;
exports.init = init;
exports.getFeedbackAbbaEnabled = getFeedbackAbbaEnabled;
exports.getFeedbackAbbaCell = getFeedbackAbbaCell;
exports.allowsFeedback = allowsFeedback;
exports.getFeedback = getFeedback;

var _spotifyLiburi = require('spotify-liburi');

var _spotifyLiburi2 = _interopRequireDefault(_spotifyLiburi);

var _bridge = require('../bridge');

var _bridge2 = _interopRequireDefault(_bridge);

var _liveWrappedUri = require('../live-wrapped-uri');

var _liveWrappedUri2 = _interopRequireDefault(_liveWrappedUri);

var _abba = require('../abba');

var _abba2 = _interopRequireDefault(_abba);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Fetch madeFor objects for an array of formatListAttributes
 *
 * @param  {Array} formatLists        Array of `formatListAttributes`
 * @param  {String} viewerUsername
 * @return {Promise}                  The result of Promise.all resolves
 *                                    to a list of `madeFor` objects
 */
function fetchMadeFors(formatLists, viewerUsername) {
  const promiseList = formatLists.map(formatList => fetchMadeFor(formatList, viewerUsername));
  return Promise.all(promiseList);
}

/**
 * Fetch madeFor object based on a playlist's formatListAttributes
 * @param  {Object} formatListAttributes
 * @param  {String} viewerUsername
 * @return {Promise}                      Promise that resolves
 *                                        to a madeFor object
 */
function fetchMadeFor(formatListAttributes, viewerUsername) {
  if (!formatListAttributes) {
    return Promise.resolve(null);
  }

  const username = formatListAttributes['madeFor.username'];
  if (!username) {
    return Promise.resolve(null);
  }

  let name = formatListAttributes['madeFor.name'];
  if (name) {
    return Promise.resolve(buildMadeFor(name, username, viewerUsername));
  }

  // FormatList does not yet return a name when current user views their own.
  // It may someday. In the meantime, we fetch the name via a Bridge call.
  return new Promise(resolve => {
    const userUri = _spotifyLiburi2.default.profileURI(username).toURI();
    _bridge2.default.request('user_metadata', [userUri], (bridgeError, userMetadata) => {
      if (bridgeError) {
        name = username;
      } else {
        name = userMetadata.name || username;
      }
      resolve(buildMadeFor(name, username, viewerUsername));
    });
  });
}

/**
 * Returns an object with data for templates
 *
 * @param  {String} fullName          Playlist was made for a user
 *                                    with this name (fallsback to
 *                                    username if they have no name)
 * @param  {String} username          Playlist was made for this
 *                                    username
 * @param  {String} viewerUsername    The username who is viewing
 *                                    this playlist
 * @return {Object}
 */
function buildMadeFor(name, username, viewerUsername) {
  const isCurrentUser = username === viewerUsername;
  const shortName = name.split(' ').shift();

  // We try to avoid rendering names and usernames that contain only numbers.
  // If that's the case and we can show "You", we will do it.
  const numbers = /^\d+$/;
  const renderAsYou = isCurrentUser && username === name && numbers.test(username);

  return {
    isCurrentUser,
    name,
    shortName,
    username,
    renderAsYou,
    uri: _spotifyLiburi2.default.profileURI(username).toURI()
  };
}

/**
 * Turns a filterlist URI into a regular playlist URI.
 */
function originalPlaylistUri(playlistUri) {
  return _liveWrappedUri2.default.getOriginUri(playlistUri) || playlistUri;
}

let initialized = false;
let feedbackAbbaEnabled = false;
let feedbackAbbaCell = null;

function init() {
  if (initialized) {
    return;
  }
  initialized = true;

  const handleAbbaFeedback = (error, cell) => {
    if (!error && cell) {
      feedbackAbbaEnabled = cell !== 'Control';
      feedbackAbbaCell = cell;
    }
  };

  // update immediately when the app launches so that we can show
  // a player state that reflects the ABBA test cell, then subscribe to changes
  _abba2.default.get('discover-weekly-feedback-desktop', handleAbbaFeedback);
  _abba2.default.subscribe('discover-weekly-feedback-desktop', handleAbbaFeedback);
}

function getFeedbackAbbaEnabled() {
  return feedbackAbbaEnabled;
}

function getFeedbackAbbaCell() {
  return feedbackAbbaCell;
}

function allowsFeedback(formatListAttributes) {
  return feedbackAbbaEnabled && formatListAttributes && formatListAttributes['like-feedback-available'] === '1';
}

/**
 * Parse track-level formatListAttributes related to feedback
 * into one value: 'up', 'down' or null
 */
function getFeedback(formatListAttributes) {
  if (!formatListAttributes) {
    return null;
  } else if (formatListAttributes['like-feedback-selected'] === '1') {
    return 'up';
  } else if (formatListAttributes['dislike-feedback-selected'] === '1') {
    return 'down';
  }
  return null;
}

},{"../abba":74,"../bridge":86,"../live-wrapped-uri":209,"spotify-liburi":730}],236:[function(require,module,exports){
(function (global){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.formatListUtils = exports.subscribeToMetadata = exports.fetchPlaylistMetadata = exports.offlineSyncPlaylist = exports.logAddToPlaylist = exports.setPlaylistPublished = exports.createNewPlaylist = exports.addTracksToPlaylist = exports.OfflineStatus = undefined;
exports.addAlbumToPlaylist = addAlbumToPlaylist;
exports.addStationToPlaylist = addStationToPlaylist;
exports.addStuffToPlaylist = addStuffToPlaylist;
exports.getRefreshedPlaylistData = getRefreshedPlaylistData;
exports.createRefreshedPlaylist = createRefreshedPlaylist;
exports.setPlaylistCollaborative = setPlaylistCollaborative;
exports.shouldPlaylistBeOffline = shouldPlaylistBeOffline;
exports.getPlaylist2ShowsCell = getPlaylist2ShowsCell;
exports.isPlaylist2Shows = isPlaylist2Shows;
exports.resyncPlaylist = resyncPlaylist;

var _spotifyLiburi = require('spotify-liburi');

var _spotifyLiburi2 = _interopRequireDefault(_spotifyLiburi);

var _bridge = require('../../libs/bridge');

var _bridge2 = _interopRequireDefault(_bridge);

var _live = require('../../libs/live');

var _live2 = _interopRequireDefault(_live);

var _playlistActions = require('./playlist-actions');

var _playlistData = require('./playlist-data');

var _offlineStatus = require('./offline-status');

var OfflineStatus = _interopRequireWildcard(_offlineStatus);

var _formatLists = require('./format-lists');

var formatListUtils = _interopRequireWildcard(_formatLists);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.OfflineStatus = OfflineStatus;
exports.addTracksToPlaylist = _playlistActions.addTracksToPlaylist;
exports.createNewPlaylist = _playlistActions.createNewPlaylist;
exports.setPlaylistPublished = _playlistActions.setPlaylistPublished;
exports.logAddToPlaylist = _playlistActions.logAddToPlaylist;
exports.offlineSyncPlaylist = _playlistActions.offlineSyncPlaylist;
exports.fetchPlaylistMetadata = _playlistData.fetchPlaylistMetadata;
exports.subscribeToMetadata = _playlistData.subscribeToMetadata;
exports.formatListUtils = formatListUtils;
// Work around transpiler non-sense

exports.getCollaborativeStatus = _playlistData.getCollaborativeStatus;

function addAlbumToPlaylist(playlistUri, albumUri, cb) {
  const args = [albumUri.toString(), 0, -1];

  return _bridge2.default.request('album_tracks_snapshot', args, (err, resp) => {
    if (err) {
      cb(err);
      return;
    }
    (0, _playlistActions.addTracksToPlaylist)(playlistUri, resp.array, cb);
  });
}

function addStationToPlaylist(playlistUri, stationURI, cb) {
  (0, _live2.default)(stationURI.toString()).query('rows(track(uri))', (err, data) => {
    if (err) {
      cb(err);
      return;
    }
    const trackURIs = data.rows.map(radioTrack => radioTrack.track.uri);
    (0, _playlistActions.addTracksToPlaylist)(playlistUri, trackURIs, cb);
  });
}

function addStuffToPlaylist(playlistUri, uris, cb) {
  if (uris[0].type === _spotifyLiburi2.default.Type.ALBUM) {
    addAlbumToPlaylist(playlistUri, uris[0], cb);
    if (uris.length > 1) {
      console.warn('Passed more than a single album to addStuffToPlaylist(). Adding only one.');
    }
  } else if (uris[0].type === _spotifyLiburi2.default.Type.STATION) {
    addStationToPlaylist(playlistUri, uris[0], cb);
  } else {
    const urisStr = uris.map(uri => uri.toString());
    (0, _playlistActions.addTracksToPlaylist)(playlistUri, urisStr, cb);
  }
}

function fetchPlaylistName(playlistUri, cb) {
  const policy = {
    name: true
  };

  (0, _playlistData.fetchPlaylistMetadata)(playlistUri, policy, (error, data) => {
    if (data && data.name) {
      cb(error, data.name);
      return;
    }
    cb(error);
  });
}

function getRefreshedPlaylistData(playlistUri, cb) {
  fetchPlaylistName(playlistUri, (nameError, oldName) => {
    if (nameError) {
      cb(nameError);
      return;
    }

    const name = (0, _playlistActions.refreshedPlaylistName)(oldName);

    _bridge2.default.cosmosJSON({
      method: 'POST',
      uri: 'hm://playlistfreshener/freshen',
      body: {
        playlistURI: playlistUri.toString(),
        type: 'W2V_freshener'
      }
    }, (error, body) => {
      if (error) {
        cb(error);
        return;
      }

      const tracks = body.recommendedTracks.map(r => `spotify:track:${r.id}`);

      cb(null, {
        name,
        tracks
      });
    });
  });
}

function createRefreshedPlaylist(playlistUri, cb) {
  getRefreshedPlaylistData(playlistUri, (error, { name, tracks } = {}) => {
    if (error) {
      cb(error);
      return;
    }

    (0, _playlistActions.createNewPlaylist)(name, (createNewPlaylistError, newPlaylistUri) => {
      if (createNewPlaylistError) {
        cb(createNewPlaylistError);
        return;
      }

      (0, _playlistActions.addTracksToPlaylist)(newPlaylistUri, tracks, addTracksToPlaylistError => {
        cb(addTracksToPlaylistError, newPlaylistUri);
      });
    });
  });
}

function setPlaylistCollaborative(uri, collaborative, cb) {
  _bridge2.default.request('playlist_set_collaborative', [uri.toString(), collaborative], err => {
    if (err) {
      cb(err);
      return;
    }

    if (collaborative) {
      // when we set a playlist as collaborative, check if
      // it's public and make it private
      (0, _playlistData.getCollaborativeStatus)(uri, (error, data) => {
        if (error || data.published === null) {
          cb(error || new Error('`published` property unexpectedly missing'));
          return;
        }

        if (data.published) {
          (0, _playlistActions.setPlaylistPublished)(uri, false, cb);
          return;
        }
        cb();
      });
    } else {
      cb();
    }
  });
}

function shouldPlaylistBeOffline(uri, cb) {
  const policy = {
    offline: true
  };

  (0, _playlistData.fetchPlaylistMetadata)(uri, policy, (error, data) => {
    if (data && data.offline) {
      const shouldBeOffline = OfflineStatus.shouldBeOffline(data.offline);
      cb(error, shouldBeOffline);
      return;
    }
    cb(error, data);
  });
}

// A synchronous way to "fetch" the playlist2shows ABBA flag.
function getPlaylist2ShowsCell() {
  // initialState.playlist2ShowsCell is initialized on
  // apps/script/zlink/pre-init.js.
  const initialState = global.initialState || global.top && global.top.initialState || {};
  return initialState.playlist2ShowsCell || null;
}

function isPlaylist2Shows(formatListType) {
  const isCellEnabled = getPlaylist2ShowsCell() === 'Enabled';
  if (!isCellEnabled) {
    return false;
  }

  const validFormatListTypes = ['format-shows', 'format-shows-shuffle'];

  return validFormatListTypes.includes(formatListType);
}

function resyncPlaylist(uri, callback) {
  const opts = {
    method: 'POST',
    uri: `sp://core-playlist/v1/playlist/${uri}/resync`
  };

  return _bridge2.default.cosmos(opts, (err, body) => {
    if (callback) {
      if (err) {
        callback(err);
      } else if (body.status !== 200 && body.status !== 204) {
        const e = new Error(`Cosmos Request Error. Status: ${body.status}`);
        e.status = body.status;
        callback(e);
      } else {
        callback(null, body);
      }
    }
  });
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../libs/bridge":86,"../../libs/live":210,"./format-lists":235,"./offline-status":237,"./playlist-actions":238,"./playlist-data":239,"spotify-liburi":730}],237:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.YES = exports.DOWNLOADING = exports.WAITING_SYNC_NOT_ALLOWED = exports.WAITING_NO_CONNECTION = exports.WAITING_OFFLINE_MODE = exports.WAITING = exports.NO = undefined;
exports.isDownloading = isDownloading;
exports.shouldBeOffline = shouldBeOffline;
exports.progressFromStatus = progressFromStatus;
exports.getLabelForStatus = getLabelForStatus;
exports.sendUserMessageForStatus = sendUserMessageForStatus;

var _bridge = require('../../libs/bridge');

var _bridge2 = _interopRequireDefault(_bridge);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const NO = exports.NO = 'no';
const WAITING = exports.WAITING = 'waiting';
const WAITING_OFFLINE_MODE = exports.WAITING_OFFLINE_MODE = 'waitingOfflineMode';
const WAITING_NO_CONNECTION = exports.WAITING_NO_CONNECTION = 'waitingNoConnection';
const WAITING_SYNC_NOT_ALLOWED = exports.WAITING_SYNC_NOT_ALLOWED = 'waitingSyncNotAllowed';
const DOWNLOADING = exports.DOWNLOADING = 'downloading';
const YES = exports.YES = 'yes';

function isDownloading(offlineStatus) {
  return offlineStatus === DOWNLOADING;
}

function shouldBeOffline(offlineStatus) {
  switch (offlineStatus) {
    case WAITING:
    case WAITING_OFFLINE_MODE:
    case WAITING_NO_CONNECTION:
    case DOWNLOADING:
    case WAITING_SYNC_NOT_ALLOWED:
    case YES:
      return true;
    case NO:
    default:
      return false;
  }
}

// Returns 0 or 1 if able to derive
// progress from the offlineStatus,
// otherwise will return undefined.
function progressFromStatus(offlineStatus) {
  switch (offlineStatus) {
    case WAITING:
    case WAITING_OFFLINE_MODE:
    case WAITING_NO_CONNECTION:
    case WAITING_SYNC_NOT_ALLOWED:
    case NO:
      return 0;
    case YES:
      return 1;
    case DOWNLOADING:
    default:
      return undefined;
  }
}

function getLabelForStatus(offlineStatus, isFormatShows) {
  switch (offlineStatus) {
    case DOWNLOADING:
      return 'Downloading';
    case WAITING_OFFLINE_MODE:
    case WAITING_NO_CONNECTION:
    case WAITING_SYNC_NOT_ALLOWED:
      return 'WaitingForConnection';
    case WAITING:
      return 'WaitingForDownload';
    case YES:
      return isFormatShows ? 'DownloadedSongs' : 'Downloaded';
    case NO:
    default:
      return isFormatShows ? 'DownloadSongs' : 'Download';
  }
}

function sendUserMessageForStatus(offlineStatus) {
  switch (offlineStatus) {
    case WAITING_OFFLINE_MODE:
      // Tell the user to turn off offline mode
      _bridge2.default.cosmosJSON({
        method: 'POST',
        uri: 'sp://messages/v1/container/user-message',
        body: {
          id: 'cant-offline-sync-playlist-in-offline-mode'
        }
      });
      return true;
    default:
      return false;
  }
}

},{"../../libs/bridge":86}],238:[function(require,module,exports){
(function (global){
// Playlist Actions: functions that mutate playlists in some way
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.addTracksToPlaylist = addTracksToPlaylist;
exports.setPlaylistPublished = setPlaylistPublished;
exports.createNewPlaylist = createNewPlaylist;
exports.logAddToPlaylist = logAddToPlaylist;
exports.refreshedPlaylistName = refreshedPlaylistName;
exports.offlineSyncPlaylist = offlineSyncPlaylist;
const cosmos = require('spotify-cosmos-api');
const liburi = require('spotify-liburi');

const AddToPlaylist3 = require('../../libs/logger/messages/AddToPlaylist3');
const live = require('../../libs/live');
const bridge = require('../../libs/bridge');

const DUPLICATE_ACTIONS = exports.DUPLICATE_ACTIONS = {
  ADD_ALL: 'add_all',
  ADD_UNIQUE: 'add_unique',
  CANCEL: 'cancel'
};

function getDuplicates(playlistURI, trackURIs, callback) {
  cosmos.resolver.post({
    url: `sp://core-playlist/v1/playlist/${encodeURIComponent(playlistURI)}/contains`,
    body: {
      items: trackURIs
    }
  }, function (error, response) {
    if (error) {
      callback([]);
      return;
    }

    const body = response.getJSONBody();
    const foundByIndex = body.found;

    const duplicates = [];
    const uniques = [];

    trackURIs.forEach((uri, index) => {
      if (foundByIndex[index]) {
        duplicates.push(trackURIs[index]);
      } else {
        uniques.push(trackURIs[index]);
      }
    });

    callback(duplicates, uniques);
  });
}

function maybeFilterDuplicates(playlistURI, trackURIs, callback) {
  getDuplicates(playlistURI, trackURIs, function (duplicates, uniques) {
    if (!duplicates.length) {
      callback(trackURIs);
      return;
    }

    cosmos.resolver.post({
      url: 'sp://messages/v1/avoidduplicates',
      body: {
        action: 'confirm',
        source: global.__spotify.app_uri,
        playlistUri: playlistURI,
        numItems: trackURIs.length,
        numDuplicates: duplicates.length
      }
    }, function (postError) {
      if (postError) {
        callback(trackURIs);
        return;
      }

      // Subscribe for the dialog response
      const subscription = cosmos.resolver.subscribe({
        url: 'sp://messages/v1/avoidduplicates'
      }, function (error, response) {
        subscription.cancel();
        if (error) {
          callback(trackURIs);
          return;
        }
        switch (response.getJSONBody().action) {
          case DUPLICATE_ACTIONS.ADD_ALL:
            callback(trackURIs);
            break;

          case DUPLICATE_ACTIONS.ADD_UNIQUE:
            callback(uniques);
            break;

          case DUPLICATE_ACTIONS.CANCEL:
            callback([]);
            break;

          default:
            throw new Error('Invalid DUPLICATE_ACTION.');
        }
      });
    });
  });
}

function addTracksToPlaylist(playlistURI, trackURIs, cb) {
  maybeFilterDuplicates(playlistURI, trackURIs, function (filteredTrackURIs) {
    if (!filteredTrackURIs.length) {
      cb();
      return;
    }

    cosmos.resolver.post({
      url: `sp://core-playlist/v1/playlist/${encodeURIComponent(playlistURI)}`,
      body: {
        operation: 'add',
        uris: filteredTrackURIs,
        after: 'end'
      }
    }, function (error, response) {
      // TODO(jaco): Move over to status code checking when CORE-1638 is done.
      const trackLimitExceeded = error && response && response.getJSONBody() && /exceed the maximum playlist size/i.test(response.getJSONBody().error);
      if (trackLimitExceeded) {
        cosmos.resolver.post({
          url: 'sp://messages/v1/container/user-message',
          body: { id: 'playlist-limit-exceeded' }
        });
      }

      if (error) {
        cb(error);
        return;
      }
      cb();
    });
  });
}

function setPlaylistPublished(uri, publish, cb) {
  const uriStr = uri.toString();

  bridge.request(publish ? 'library_publish' : 'library_unpublish', [liburi.profileURI(global.__spotify.username).toURI(), uriStr], (err, data) => {
    if (!err) {
      live(uriStr).update({
        published: publish
      });
    }
    return cb(err, data);
  });
}

function createNewPlaylist(name, cb) {
  bridge.request('playlist_create', [name], (err, data) => {
    if (err) {
      cb(err);
      return;
    }
    cb(null, data.uri);
  });
}

function logAddToPlaylist(data) {
  let intent;
  if (data.isNew) {
    intent = 'create-new-playlist';
  } else if (data.isInFolder) {
    intent = 'add-to-playlist-in-folder';
  } else {
    intent = 'add-to-playlist';
  }

  AddToPlaylist3.log({
    /* eslint-disable */
    intent: intent,
    item_uri: data.uris[0].toURI(),
    number_items: data.uris.length.toString(),
    section: 'all-playlists',
    source: data.appUri,
    source_action: 'add-to-playlist',
    playlist_index: data.playlistIndex,
    playlist_uri: data.playlistUri,
    total_number_playlists: data.numberOfVisibleItems,
    time: Math.round(Date.now() / 1000)
    /* eslint-enable */
  });
}

function refreshedPlaylistName(oldName) {
  if (!oldName) {
    // TODO(jaco): Should be localised, but since the name is still very much up
    // in the air and this will only go out to employees, we don't want to send
    // it off for translation yet since it will likely change a couple of times
    // before we're happy with it.
    return 'Similar Playlist';
  }

  const nextInt = function (intStr) {
    return parseInt(intStr, 10) + 1;
  };

  // Parenthesized number suffix: "Playlist (2)"
  const matches = oldName.match(new RegExp('(.*)\\((\\d+)\\)$'));
  if (matches) {
    return `${matches[1].trim()} (${nextInt(matches[2])})`;
  }

  return `${oldName} (2)`;
}

function offlineSyncPlaylist(uri, shouldBeOffline, cb) {
  bridge.cosmos({
    method: shouldBeOffline ? 'POST' : 'DELETE',
    uri: `sp://offline/v1/resources?uri=${uri}`
  }, cb);
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../libs/bridge":86,"../../libs/live":210,"../../libs/logger/messages/AddToPlaylist3":220,"spotify-cosmos-api":720,"spotify-liburi":730}],239:[function(require,module,exports){
(function (global){
// Playlist Data: playlist data fetching and data subscription.
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.fetchPlaylistMetadata = fetchPlaylistMetadata;
exports.subscribeToMetadata = subscribeToMetadata;
exports.getCollaborativeStatus = getCollaborativeStatus;
exports.playlistFiltersToReturn = playlistFiltersToReturn;
exports.replaceFiltersToReturn = replaceFiltersToReturn;
exports.getCorePlaylistUrl = getCorePlaylistUrl;
const liburi = require('spotify-liburi');

const bridge = require('../../libs/bridge');
const wrappedUriUtils = require('../../libs/live-wrapped-uri');
const coreSortParams = require('../../libs/core-sort-params');

/**
 * Possible policy fields (may not be an exhaustive list):
 *
 * {
 *   link: true,
 *   loaded: true,
 *   published: true,
 *   browsableOffline: true,
 *   totalLength: true,
 *   name: true,
 *   picture: true,
 *   pictureFromAnnotate: true,
 *   canReportAnnotationAbuse: true,
 *   description: true,
 *   descriptionFromAnnotate: true,
 *   collaborative: true,
 *   formatListAttributes: true,
 *   length: true,
 *   duration: true,
 *   lastModification: true,
 *   allows: {
 *     insert: true,
 *     remove: true
 *   },
 *   followed: true,
 *   offline: true,
 *   followers: true,
 *   owner: {
 *     link: true,
 *     username: true,
 *     name: true
 *   },
 *   ownedBySelf: true
 * }
 */
function fetchPlaylistMetadata(playlistUri, policy, cb) {
  bridge.cosmosJSON({
    method: 'GET',
    uri: `sp://core-playlist/v1/playlist/${encodeURIComponent(playlistUri)}/metadata`,
    body: {
      policy: policy
    }
  }, (error, data) => cb(error, data && data.metadata));
}

function subscribeToMetadata(playlistUri, policy, cb) {
  return bridge.cosmosJSON({
    method: 'SUB',
    uri: `sp://core-playlist/v1/playlist/${encodeURIComponent(playlistUri)}/metadata`,
    body: { policy: policy }
  }, (subError, body) => cb(subError, body && body.metadata));
}

function getCollaborativeStatus(uri, cb) {
  const policy = {
    collaborative: true,
    published: true
  };
  fetchPlaylistMetadata(uri.toString(), policy, cb);
}

function playlistFiltersToReturn(returnUnplayableTracks, returnPremiumOnlyTracks) {
  if (returnUnplayableTracks) {
    if (returnPremiumOnlyTracks) {
      // Return all the tracks. No filters. No restrictions!
      return [];
    }
    // Return unplayable tracks without the premium-only tracks.
    // Equivalent to: return all the tracks, except premium-only tracks.
    // Equivalent to: don't return premium-only tracks.
    return ['isPremiumOnly eq false'];
  }

  // returnUnplayableTracks=false

  if (returnPremiumOnlyTracks) {
    // Don't return "regular unplayable" tracks, but return premium-only tracks.
    // A track can be returned if it used to be defined as playable or if it's
    // premium-only.
    const availabilityFlags = 'available|cappingReached|' + 'inPremium'; // regular (pre-premiere) definition of playable // available (playable) only in Premium

    // Availability flags are based on the ResourceAvailabilityType enum defined
    // in core (spotify/metadata/cpp/include/spotify/metadata/resource_availability.h).
    return [`availability in ${availabilityFlags}`];
  }
  // Don't return regular unplayable tracks and don't return premium-only
  // tracks.
  // Equivalent to: don't return any non-playable track.
  return ['playable eq true'];
}

function replaceFiltersToReturn(filters, returnUnplayableTracks, returnPremiumOnlyTracks) {
  const newFilters = filters.filter(filter => {
    return !filter.startsWith('playable') && !filter.startsWith('isPremiumOnly') && !filter.startsWith('availability');
  });
  const filtersToAdd = playlistFiltersToReturn(returnUnplayableTracks, returnPremiumOnlyTracks);
  return newFilters.concat(filtersToAdd);
}

function isLocalFilesUri(uri) {
  return (/:internal:local-files.*/.test(uri)
  );
}

function getCorePlaylistUrl(uri, options, windowedPlaylistShowTracklistCell) {
  let parsed = wrappedUriUtils.parse(uri);
  if (!parsed) {
    parsed = {
      originUri: uri,
      sort: null,
      filter: null
    };
  }
  const originUri = parsed.originUri;

  let url;
  if (isLocalFilesUri(uri)) {
    url = 'sp://local-files/v2';
    if (options.type === 'rows') {
      options.type = 'tracks';
    }
  } else {
    const version = options.version || 'v1';
    url = `sp://core-playlist/${version}/playlist/${encodeURIComponent(originUri)}`;
  }

  let filters = parsed.filter ? parsed.filter.query.split(',') : [];
  if (!isLocalFilesUri(uri)) {
    const playlistOwnerUsername = liburi.from(originUri).username;
    const isOwnPlaylist = playlistOwnerUsername === global.__spotify.username;
    // Project Premiere "redefined" what is considered 'playable' in the context
    // of the "Show Unavailable(Unplayable) Tracks in Playlists" setting.
    // We do the proper translation to core URIs here assuming this filter ended
    // up here due to the user setting.
    const returnUnplayableTracks = !filters.includes('playable eq true');

    let returnPremiumOnlyTracks;
    if (isOwnPlaylist) {
      returnPremiumOnlyTracks = true;
    } else if (windowedPlaylistShowTracklistCell === 'Enabled') {
      returnPremiumOnlyTracks = returnUnplayableTracks;
    } else {
      returnPremiumOnlyTracks = false;
    }

    filters = replaceFiltersToReturn(filters, returnUnplayableTracks, returnPremiumOnlyTracks);
  }

  const query = [];
  if (parsed.sort && options.type !== 'metadata') {
    const direction = parsed.sort.direction === 'desc' ? 'DESC' : 'ASC';
    query.push(`sort=${encodeURIComponent(coreSortParams(parsed.sort.query, direction))}`);
  }
  if (typeof options.start === 'number') {
    query.push(`start=${options.start}`);
  }
  if (typeof options.length === 'number') {
    query.push(`length=${options.length}`);
  }
  if (options.includeEpisodes === true) {
    query.push('includeEpisodes=true');
  }

  if (options.type) {
    url += `/${options.type}`;
  }
  if (filters.length) {
    query.push(`filter=${filters.map(encodeURIComponent).join(',')}`);
  }
  if (options.type === 'play') {
    // Include a context URI that is then reflected as the context in the player state
    query.push(`uri=${encodeURIComponent(uri)}`);
  }
  if (query.length) {
    // TODO(felipec): remove the extra & and fix tests
    url += `?${query.join('&')}`;
  }
  return url;
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../libs/bridge":86,"../../libs/core-sort-params":89,"../../libs/live-wrapped-uri":209,"spotify-liburi":730}],240:[function(require,module,exports){
'use strict';

/**
 * Module dependencies
 */

const extend = require('extend');
const bridge = require('../bridge');
const batch = require('spotify-batch');

/**
 * Bridge methods
 */

const PREF_ALL = 'preferences_all';
const PREF_GET = 'preferences_get';
const PREF_SET = 'preferences_set';
const PREF_SUB = 'preferences_event_wait';

/**
 * Converts a string with dot notation into
 * a nested object where the last key is
 * set to value
 *
 *  eg: f('foo.bar', 123) = {foo: {bar: 123}}
 *
 * @api private
 * @param {String} string
 * @param {Mixed} value
 * @param {String} delimiter - optional
 */

function transformStringIntoObjectAndSetValue(string, value, delimiter) {
  const object = {};
  string.split(delimiter || '.').reduce(function (o, c, i, a) {
    if (i < a.length - 1) {
      o[c] = {};
    } else {
      o[c] = value;
    }

    return o[c];
  }, object);

  return object;
}

/**
 * Converts an object with nest objects into a flat object
 *
 *  eg: f({foo: {bar: 123}}) = {'foo.bar': 123}
 *
 * @api private
 * @param {String} string
 * @param {String} delimiter - optional
 */

function transformObjectIntoFlatObject(object, delimiter) {
  const flattened = {};
  const newDelimiter = delimiter || '.';
  function traverse(o, key) {
    let tmp = null;
    for (const p in o) {
      if (typeof o[p] === 'object') {
        const newKey = key ? [key, p].join(newDelimiter) : p;
        traverse(o[p], newKey);
      } else {
        tmp = key ? [key, p].join(newDelimiter) : p;
        flattened[tmp] = o[p];
      }
    }
  }

  traverse(object);
  return flattened;
}

/**
 * Normalizes data from bridge responses
 *
 * @api private
 * @param {String} key
 * @param {Object} data
 * @param {Boolean} preserve - optional (Default: false)
 */

function normalizeData(key, data, preserve) {
  const out = {};
  const regex = key === '*' ? null : RegExp(`^${key}`);
  let targets = null;

  if (typeof data !== 'object') {
    return data;
  }

  targets = Object.keys(data).map(function (innerkey) {
    if (regex === null || regex.test(innerkey)) {
      return [innerkey, data[innerkey]];
    }
    return false;
  }).filter(Boolean).reduce(function (t, c) {
    t[c[0]] = c[1];
    return t;
  }, {});

  Object.keys(targets).forEach(function (innerkey) {
    // extend output object with transformed properties
    extend(true, out, transformStringIntoObjectAndSetValue(innerkey, targets[innerkey]));
  });

  if (key === '*' || preserve === true) {
    return out;
  }
  return key.split('.').reduce(function (o, k) {
    return o[k];
  }, out);
}

/**
 * Subscribes to a key.
 *
 * @api private
 * @param {Function} rpc The RPC to use.
 * @param {String} key The key (including path).
 * @param {*} lastValue The last value of the key (used for comparing).
 * @param {Function} fn Subscribe handler.
 * @param {Object=} sub Subscription object, optional.
 */

function subscribeToKey(rpc, key, lastValue, fn, sub) {
  const newSub = sub || {
    isCancelled: false,
    cancel: function () {
      this.isCancelled = true;
    }
  };

  rpc(PREF_SUB, [], function (err, res) {
    if (newSub.isCancelled) return;

    let didValueChange = false;

    let newLastValue = lastValue;
    if (res) {
      const value = normalizeData(key, res);
      if (value !== newLastValue) {
        newLastValue = value;
        didValueChange = true;
      }
    }

    // Resubscribe since one subscription is only for one response
    subscribeToKey(rpc, key, newLastValue, fn, newSub);

    if (didValueChange) {
      fn(null, newLastValue);
    }
  });

  return newSub;
}

/**
 * `Preferences' constructor
 *
 * @api public
 * @param {String} path - optional (Default: '*')
 * @param {Function} rpc - optional
 */

module.exports = Preferences;
function Preferences(path, rpc) {
  if (!(this instanceof Preferences)) {
    return new Preferences(path, rpc);
  }

  this.path = path || '*';
  this.rpc = rpc || bridge.request.bind(bridge);
}

/**
 * Retrieves all preferences at path.
 * If path is '*' then all preferences
 * are retrieved.
 *
 * @api public
 * @param {Function} fn
 */

Preferences.prototype.all = function (fn) {
  const path = this.path;

  this.rpc(PREF_ALL, [], function (err, res) {
    if (err) {
      fn(err);
    } else if (path === '*') {
      fn(null, res);
    } else {
      fn(null, normalizeData(path, res, true));
    }
  });

  return this;
};

/**
 * Sets a preference at key at path
 * with value
 *
 * @api public
 * @param {String} key
 * @param {Mixed} value
 * @param {Function} fn
 */

Preferences.prototype.set = function (key, value, fn) {
  const path = this.path;
  let map = null;
  let jobs = null;

  // handle batch jobs to extend bridge preferences
  if (typeof key === 'object') {
    const newFn = value;

    map = transformObjectIntoFlatObject(key);
    jobs = batch().concurrency(1);
    Object.keys(map).forEach(k => {
      jobs.push(next => {
        this.set(k, map[k], next);
      });
    });

    jobs.run(newFn);
  } else {
    const newKey = path === '*' ? key : [path, key].join('.');
    this.rpc(PREF_SET, [newKey, value], fn);
  }
  return this;
};

/**
 * Sets a preference bitflag at path, based on the inputs.
 *
 * @api public
 * @param {String} key
 * @param {Array} flagBoolPairs
 * @param {Function} fn
 */

Preferences.prototype.setAtomicFlags = function (key, flagBoolPairs, fn) {
  this.get(key, (err, value) => {
    if (err) {
      fn(err);
    } else {
      let newValue = value;
      flagBoolPairs.forEach(function (pair) {
        const flag = pair[0];
        const bool = pair[1];
        if (bool === undefined || bool === null) return;
        if (bool) newValue |= flag;else newValue &= ~flag;
      });

      this.set(key, newValue, fn);
    }
  });
};

/**
 * Gets a preference at key at path
 *
 * @api public
 * @param {String} key
 * @param {Function} fn
 */

Preferences.prototype.get = function (key, fn) {
  const newKey = this.path === '*' ? key : [this.path, key].join('.');

  // try to get property first
  this.rpc(PREF_GET, [newKey], (err, res) => {
    const value = res ? normalizeData(newKey, res) : null;
    if (value === null) {
      this.rpc(PREF_ALL, [], function (innererr, innerres) {
        if (innererr) {
          fn(innererr);
        } else {
          fn(null, normalizeData(newKey, innerres));
        }
      });
    } else {
      fn(null, normalizeData(newKey, res));
    }
  });
  return this;
};

/**
 * Subscribes to a preference at key at path
 *
 * @api public
 * @param {String} key
 * @param {Function} fn
 */

Preferences.prototype.subscribe = function (key, fn) {
  let sub = null;
  let cancelled = false;

  // Get initial value and then subscribe for changes
  this.get(key, (err, res) => {
    if (cancelled) return;
    const keyWithPath = this.path === '*' ? key : [this.path, key].join('.');
    sub = subscribeToKey(this.rpc, keyWithPath, res, fn);

    // Respond to the GET (initial value for SUB)
    fn(err, res);
  });

  return {
    cancel: function () {
      cancelled = true;
      if (sub) {
        sub.cancel();
      }
    }
  };
};

},{"../bridge":86,"extend":386,"spotify-batch":714}],241:[function(require,module,exports){
(function (process,global){
/*
defer
*/'use strict';

const now = require('mout/time/now');
const forEach = require('mout/array/forEach');
const indexOf = require('mout/array/indexOf');

const callbacks = {
  timeout: {},
  frame: [],
  immediate: []
};

const iterate = function (collection) {
  const time = now();

  forEach(collection.splice(0), function (entry) {
    entry.callback.call(entry.context, time);
  });
};

const push = function (collection, callback, context, defer) {
  const iterator = function () {
    iterate(collection);
  };

  if (!collection.length) defer(iterator);

  const entry = {
    callback: callback,
    context: context
  };

  collection.push(entry);

  return function () {
    const io = indexOf(collection, entry);
    if (io > -1) collection.splice(io, 1);
  };
};

const defer = {};

if (global.process && process.nextTick) {
  defer.immediate = function (callback, context) {
    return push(callbacks.immediate, callback, context, process.nextTick);
  };
} else if (global.setImmediate) {
  defer.immediate = function (callback, context) {
    return push(callbacks.immediate, callback, context, setImmediate);
  };
} else if (global.postMessage && global.addEventListener) {
  addEventListener('message', function (event) {
    if (event.source === global && event.data === '@deferred') {
      event.stopPropagation();
      iterate(callbacks.immediate);
    }
  }, true);

  defer.immediate = function (callback, context) {
    return push(callbacks.immediate, callback, context, function () {
      postMessage('@deferred', '*');
    });
  };
} else {
  defer.immediate = function (callback, context) {
    return push(callbacks.immediate, callback, context, function (iterator) {
      setTimeout(iterator, 0);
    });
  };
}

let clear;

defer.timeout = function (callback, ms, context) {
  const ct = callbacks.timeout;

  if (!clear) {
    clear = defer.immediate(function () {
      clear = null;
      callbacks.timeout = {};
    });
  }

  return push(ct[ms] || (ct[ms] = []), callback, context, function (iterator) {
    setTimeout(iterator, ms);
  });
};

module.exports = defer;

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"_process":490,"mout/array/forEach":448,"mout/array/indexOf":449,"mout/time/now":487}],242:[function(require,module,exports){
/*
Emitter
*/'use strict';

const indexOf = require('mout/array/indexOf');
const forEach = require('mout/array/forEach');

const prime = require('./index');
const defer = require('./defer');

const slice = Array.prototype.slice;

let resetCount = 0;

const Emitter = prime({
  constructor: function (stoppable) {
    this._stoppable = stoppable;
  },

  on: function (event, fn) {
    const listeners = this._listeners || (this._listeners = {});
    const events = listeners[event] || (listeners[event] = []);

    if (indexOf(events, fn) === -1) {
      events.push(fn);
    }

    return this;
  },

  off: function (event, fn) {
    const listeners = this._listeners;
    if (listeners) {
      const events = listeners[event];
      if (events) {
        const io = indexOf(events, fn);
        if (io > -1) events.splice(io, 1);
        if (!events.length) delete listeners[event];
        for (const l in listeners) {
          if (!listeners.hasOwnProperty(l)) continue;
          return this;
        }
        delete this._listeners;
      }
    }
    return this;
  },

  emit: function (event) {
    const args = slice.call(arguments, 1);

    const emit = () => {
      const listeners = this._listeners;
      if (listeners) {
        const events = listeners[event];
        if (events) {
          forEach(events.slice(0), innerEvent => {
            const result = innerEvent.apply(this, args);
            if (this._stoppable) return result;
            return undefined;
          });
        }
      }
      if (this._promiseWaiters && this._promiseWaiters[event]) {
        const execute = this._promiseWaiters[event].slice();
        this._promiseWaiters[event] = [];
        execute.forEach(waiter => waiter(...args));
      }
    };

    if (args[args.length - 1] === Emitter.EMIT_SYNC) {
      args.pop();
      emit();
    } else {
      // Defer, and check that the emitter wasn't reset() in the same event loop iteration
      const currentReset = resetCount;
      defer.immediate(() => {
        if (currentReset === resetCount) {
          emit();
        }
      });
    }

    return this;
  },

  reset: function () {
    resetCount++;
    this._listeners = {};
  },

  whenNextEvent: function (event) {
    return new Promise(resolve => {
      this._promiseWaiters = this._promiseWaiters || {};
      this._promiseWaiters[event] = [...(this._promiseWaiters[event] || []), resolve];
    });
  }
});

Emitter.EMIT_SYNC = {};

module.exports = Emitter;

},{"./defer":241,"./index":243,"mout/array/forEach":448,"mout/array/indexOf":449}],243:[function(require,module,exports){
/*
prime
 - prototypal inheritance
*/'use strict';

const hasOwn = require('mout/object/hasOwn');
const mixIn = require('mout/object/mixIn');
const create = require('mout/lang/createObject');
const kindOf = require('mout/lang/kindOf');

let hasDescriptors = true;

try {
  Object.defineProperty({}, '~', {});
  Object.getOwnPropertyDescriptor({}, '~');
} catch (e) {
  hasDescriptors = false;
}

// we only need to be able to implement "toString" and "valueOf" in IE < 9
const hasEnumBug = !{ valueOf: 0 }.propertyIsEnumerable('valueOf');
const buggy = ['toString', 'valueOf'];

const verbs = /^constructor|inherits|mixin$/;

const implement = function (proto) {
  const prototype = this.prototype;

  for (const key in proto) {
    if (key.match(verbs)) continue;
    if (hasDescriptors) {
      const descriptor = Object.getOwnPropertyDescriptor(proto, key);
      if (descriptor) {
        Object.defineProperty(prototype, key, descriptor);
        continue;
      }
    }
    prototype[key] = proto[key];
  }

  if (hasEnumBug) {
    buggy.forEach(innerKey => {
      const value = proto[innerKey];
      if (value !== Object.prototype[innerKey]) prototype[innerKey] = value;
    });
  }

  return this;
};

const prime = function (proto) {
  let newProto = proto;
  if (kindOf(newProto) === 'Function') {
    newProto = { constructor: proto };
  }

  const superprime = newProto.inherits;

  // if our nice proto object has no own constructor property
  // then we proceed using a ghosting constructor that all it does is
  // call the parent's constructor if it has a superprime, else an empty constructor
  // newProto.constructor becomes the effective constructor

  let constructor;

  if (hasOwn(newProto, 'constructor')) {
    constructor = newProto.constructor;
  } else {
    if (superprime) {
      constructor = function () {
        return superprime.apply(this, arguments);
      };
    } else {
      constructor = function () {};
    }
  }

  if (superprime) {
    mixIn(constructor, superprime);

    const superproto = superprime.prototype;
    // inherit from superprime
    const cproto = constructor.prototype = create(superproto);

    // setting constructor.parent to superprime.prototype
    // because it's the shortest possible absolute reference
    constructor.parent = superproto;
    cproto.constructor = constructor;
  }

  if (!constructor.implement) constructor.implement = implement;

  let mixins = newProto.mixin;
  if (mixins) {
    if (kindOf(mixins) !== 'Array') mixins = [mixins];
    for (let i = 0; i < mixins.length; i++) {
      constructor.implement(create(mixins[i].prototype));
    }
  }

  // implement newProto and return constructor
  return constructor.implement(newProto);
};

module.exports = prime;

},{"mout/lang/createObject":460,"mout/lang/kindOf":470,"mout/object/hasOwn":478,"mout/object/mixIn":480}],244:[function(require,module,exports){
/*
Map
*/
'use strict';

const indexOf = require('mout/array/indexOf');

const prime = require('./index');

const Map = prime({
  constructor: function Map() {
    this.length = 0;
    this._values = [];
    this._keys = [];
  },

  set: function (key, value) {
    const index = indexOf(this._keys, key);

    if (index === -1) {
      this._keys.push(key);
      this._values.push(value);
      this.length++;
    } else {
      this._values[index] = value;
    }

    return this;
  },

  get: function (key) {
    const index = indexOf(this._keys, key);
    return index === -1 ? null : this._values[index];
  },

  count: function () {
    return this.length;
  },

  forEach: function (method, context) {
    for (let i = 0, l = this.length; i < l; i++) {
      if (method.call(context, this._values[i], this._keys[i], this) === false) {
        break;
      }
    }
    return this;
  },

  map: function (method, context) {
    const results = new Map();
    this.forEach(function (value, key) {
      results.set(key, method.call(context, value, key, this));
    }, this);
    return results;
  },

  filter: function (method, context) {
    const results = new Map();
    this.forEach(function (value, key) {
      if (method.call(context, value, key, this)) results.set(key, value);
    }, this);
    return results;
  },

  every: function (method, context) {
    let every = true;
    this.forEach(function (value, key) {
      if (!method.call(context, value, key, this)) {
        every = false;
      }
    }, this);
    return every;
  },

  some: function (method, context) {
    let some = false;
    this.forEach(function (value, key) {
      if (method.call(context, value, key, this)) {
        some = true;
      }
    }, this);
    return some;
  },

  indexOf: function (value) {
    const index = indexOf(this._values, value);
    return index > -1 ? this._keys[index] : null;
  },

  remove: function (value) {
    const index = indexOf(this._values, value);

    if (index !== -1) {
      this._values.splice(index, 1);
      this.length--;
      return this._keys.splice(index, 1)[0];
    }

    return null;
  },

  unset: function (key) {
    const index = indexOf(this._keys, key);

    if (index !== -1) {
      this._keys.splice(index, 1);
      this.length--;
      return this._values.splice(index, 1)[0];
    }

    return null;
  },

  keys: function () {
    return this._keys.slice();
  },

  values: function () {
    return this._values.slice();
  }
});

const map = function () {
  return new Map();
};

map.prototype = Map.prototype;

module.exports = map;

},{"./index":243,"mout/array/indexOf":449}],245:[function(require,module,exports){
/**
 * @module range2
 */
'use strict';

const prime = require('../../libs/prime');

const map = require('mout/array/map');

const push_ = Array.prototype.push;
const slice_ = Array.prototype.slice;

const Range = prime(
/** @lends Range.prototype */{
  /**
  * The representation of a range
  * @constructs
  * @param {Number} start The start of the range.
  * @param {Number} end The end of the range.
  */
  constructor: function Range(start, end) {
    this.update(start, end);
  },

  /** Update a range. */
  update: function (start, end) {
    if (start !== null) this.start = start;
    if (end !== null) this.end = end;
    if (this.start === null || this.end === null || this.start > this.end) {
      throw new Error(`invalid range: [${this.start}, ${this.end}]`);
    }
    this.length = this.end - this.start;
    return this;
  },

  /** Copy a range. */
  copy: function () {
    return new Range(this.start, this.end);
  },

  /** Range is above range. */
  above: function (range) {
    if (!range) return false;
    return this.start >= range.end;
  },

  /** Range is below range. */
  below: function (range) {
    if (!range) return false;
    return this.end <= range.start;
  },

  adjacent: function (range) {
    if (!range) return false;
    return this.end === range.start || this.start === range.end;
  },

  /** Range intersects range. */
  intersects: function (range) {
    if (!range) return false;
    return !this.above(range) && !this.below(range);
  },

  /** Range contains range. */
  contains: function (range) {
    if (!range) return false;
    return this.start <= range.start && this.end >= range.end;
  },

  /** Range is contained by ranges. */
  contained: function (range) {
    let ranges;
    if (range instanceof Range) ranges = arguments;else ranges = range;
    if (!ranges) return false;

    for (let i = 0; ranges[i] !== undefined; i++) {
      const r = ranges[i];
      if (r.start <= this.start && r.end >= this.end) {
        return true;
      }
    }
    return false;
  },

  /** Range fits two ranges. */
  fits: function (prev, next) {
    if (!prev && !next) return true;
    if (!prev) return this.end <= next.start;
    if (!next) return this.start >= prev.end;
    return this.start >= prev.end && this.end <= next.start;
  },

  // get the section of this range contained between two ranges
  // [0, 20] » [0, 8], [16, 20] » [8, 16]

  /** portion of a range between two ranges. */
  between: function (prev, next) {
    if (!prev && !next) return this.copy();
    if (!prev) {
      return this.start >= next.start ? null : new Range(this.start, Math.min(this.end, next.start));
    }
    if (!next) {
      return this.end <= prev.end ? null : new Range(Math.max(prev.end, this.start), this.end);
    }

    return this.end > prev.end && this.start < next.start ? new Range(Math.max(prev.end, this.start), Math.min(next.start, this.end)) : null;
  },

  // [0, 8] » [0, 2], [4, 5] = [0, 2], [4, 5]
  // [3, 6] » [5, 7] = [5, 6]
  // [6, 9] » [5, 7] = [6, 7]

  /** intersection of a range with many ranges */
  intersection: function (range) {
    const intersected = [];
    let ranges;
    if (range instanceof Range) ranges = arguments;else ranges = range;
    for (let k = 0; k < ranges.length; k++) {
      const r = ranges[k];
      if (this.below(r)) break;

      if (r.intersects(this)) {
        intersected.push(new Range(Math.max(this.start, r.start), Math.min(this.end, r.end)));
      }
    }
    return intersected;
  },

  // subtract ranges from this range
  // [0, 8] » [0, 2], [4, 5] = [2, 4], [5, 8]

  /** subtract many ranges from the range. */
  subtract: function (range) {
    const subtracted = [];
    let ranges;
    if (range instanceof Range) ranges = arguments;else ranges = range;
    for (let k = -1; k < ranges.length; k++) {
      const prev = ranges[k];
      const next = ranges[k + 1];
      const between = this.between(prev, next);
      if (between) subtracted.push(between);
    }
    return subtracted;
  },

  // extract this range from ranges
  // [0, 8] » [0, 2], [5, 8] = []
  // [8, 20] » [0, 2], [5, 8] = [0, 2], [5, 8]
  // [0, 10] » [5, 10], [15, 20] = [5, 10]
  // [10, 20] » [5, 80], [90, 100] = [5, 70] [80, 90]
  // [10, 20] » [0, 10], [20, 30] = [0, 20]

  /** extract the range from many ranges. */
  extract: function (range) {
    const ranges = range instanceof Range ? slice_.call(arguments) : range.slice();

    for (let k = 0; k < ranges.length; k++) {
      const prev = ranges[k - 1];
      const next = ranges[k];

      let newRange = null;

      if (this.below(next)) {
        newRange = new Range(next.start - this.length, next.end - this.length);
      } else if (this.intersects(next)) {
        const subtracted = next.subtract(this);
        if (subtracted.length === 2) {
          // is contained
          newRange = new Range(subtracted[0].start, subtracted[1].end - this.length);
        } else if (subtracted.length === 1) {
          if (next.end > this.end) {
            // second segment kept
            newRange = new Range(subtracted[0].start - this.length, subtracted[0].end - this.length);
          } else if (this.start > next.start) {
            // first segment kept
            newRange = new Range(subtracted[0].start, subtracted[0].end);
          }
        } else {
          // gets eaten
          ranges.splice(k--, 1); // decrease k
        }
      } else {
        ranges.splice(k, 1, next.copy());
      }

      if (newRange) {
        if (prev && prev.end === newRange.start) {
          // touches previous
          ranges.splice(k-- - 1, 2, new Range(prev.start, newRange.end)); // decrease k due to splicing
        } else {
          ranges.splice(k, 1, newRange);
        }
      }
    }

    return ranges;
  },

  // [2,3] » [0,1], [2,3] = [0,1], [2,4]
  // [1,2] » [0,6] = [0,7]
  // [0,1] » [0,1], [5,6] = [0,2], [6,7]
  // [4,6] » [0,1], [5,6] = [0,1], [4,6], [7,8]

  // TODO: this can be slightly better. merging can be done in one loop.

  /** insert the range in many ranges. */
  insert: function (range) {
    const ranges = range instanceof Range ? slice_.call(arguments) : range.slice();

    for (let k = 0; k < ranges.length; k++) {
      const next = ranges[k];

      if (this.start >= next.end) {
        ranges.splice(k, 1, next.copy());
      } else if (this.start > next.start && this.start < next.end) {
        ranges.splice(k, 1, new Range(next.start, this.start), new Range(this.start, next.end));
      } else {
        ranges.splice(k, 1, new Range(next.start + this.length, next.end + this.length));
      }
    }

    return this.merge(ranges);
  },

  // merge this range in ranges
  // [0, 8] » [0, 2], [5, 8] = [0, 8]
  // [8, 20] » [0, 2], [5, 8] = [0, 2], [5, 20]
  // [0, 10] » [5, 10], [15, 20] = [0, 10], [15, 20]

  /** merge many ranges to the range. */
  merge: function (range) {
    let ranges;
    if (range instanceof Range) ranges = arguments;else ranges = range;

    ranges = map(ranges, function (r) {
      return r.copy();
    });

    if (!ranges.length) return [this.copy()];

    let k;
    let l;

    for (k = -1, l = ranges.length; k < l; k++) {
      const prev = ranges[k];
      const next = ranges[k + 1];
      const between = this.between(prev, next);

      if (between) {
        if (!prev && next) {
          if (between.end === next.start) {
            next.update(between.start, next.end);
          } else {
            k++; // increase k since we had a push
            ranges.unshift(between);
          }
        } else if (prev && next) {
          if (prev.end === between.start && between.end === next.start) {
            prev.update(prev.start, next.end);
            ranges.splice(k-- + 1, 1); // remove the next, decrease k since we had a splice
          } else if (prev.end === between.start) {
            prev.update(prev.start, between.end);
          } else if (between.end === next.start) {
            next.update(between.start, next.end);
          } else {
            ranges.splice(k + 1, 0, between);
          }
        } else if (prev && !next) {
          if (prev.end === between.start) {
            prev.update(prev.start, between.end);
          } else {
            k++; // increase k since we had a push
            ranges.push(between);
          }
        }
      }
    }

    return ranges;
  },

  /** Remove range from many ranges
    - The range(s) you pass is what you remove from */
  remove: function (range) {
    let ranges;
    if (range instanceof Range) ranges = arguments;else ranges = range;
    const result = [];
    for (let i = 0; i < ranges.length; i++) {
      const remaining = ranges[i].subtract(this);
      if (remaining.length) push_.apply(result, remaining);
    }
    return result;
  },

  /** Range to an array of indices */
  toIndices: function () {
    const indices = [];
    for (let i = this.start; i < this.end; i++) indices.push(i);
    return indices;
  },

  /** Range to a string */
  toString: function () {
    return `${[this.start, this.end]}`;
  }
});

/**
 * Range from a string
 * @memberof Range
 * @static
 * @param {String} string - The string.
 * @return {Range} The range.
 */
Range.fromString = function (string) {
  const parts = string.split(',');
  return new Range(+parts[0], +parts[1]);
};

/**
 * Ranges from an array of indices
 * @memberof Range
 * @static
 * @param {Array} indices - An array of indices.
 * @return {Array} An array of Ranges.
 */
Range.fromIndices = function (indices) {
  indices.sort(function (a, b) {
    return a > b ? 1 : -1;
  });

  const ranges = [];
  let rstart;
  let rend;

  for (let i = 0; i < indices.length; i++) {
    rstart = indices[i];
    rend = rstart;
    while (indices[i + 1] - indices[i] === 1) {
      rend = indices[i + 1]; // increment the index if the numbers sequential
      i++;
    }
    ranges.push(new Range(rstart, rend + 1));
  }

  return ranges;
};

/**
 * A function that returns a range.
 * @function
 * @see Range
 * @param {Number} start The start of the range.
 * @param {Number} end The end of the range.
 */
module.exports = Range;

},{"../../libs/prime":243,"mout/array/map":451}],246:[function(require,module,exports){
(function (global){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.install = install;

var _ravenJs = require('raven-js');

var _ravenJs2 = _interopRequireDefault(_ravenJs);

var _abba = require('../abba');

var _abba2 = _interopRequireDefault(_abba);

var _productState = require('../client-state/src/product-state');

var _messageProxy = require('../message-proxy');

var _debug = require('../debug');

var _debug2 = _interopRequireDefault(_debug);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const debug = (0, _debug2.default)('sentry');
const dsn = 'https://29161b091d014a3e9abe8f73f325d46b@sentry.io/57674';
const SAMPLE_RATE_ABBA = 'sentry-desktop-sample-rate-v2';
const SAMPLE_RATE_FLAG = 'sentry-sample-rate';
const errorsDuringInstall = [];

function install() {
  window.addEventListener('error', onWindowError);

  function onWindowError(event) {
    errorsDuringInstall.push(event.error);
    return false;
  }

  return Promise.all([_getAbbaSampleRate(), _getSessionId()]).then(values => {
    let sampleRate = parseFloat(values[0]) * 0.1;
    const uuid = values[1];

    if ((0, _productState.hasFlag)(SAMPLE_RATE_FLAG)) {
      sampleRate = global.__spotify.product_state[SAMPLE_RATE_FLAG];
    }

    let environment = 'production';

    if ((0, _productState.hasValue)('ta-environment', 1)) {
      environment = 'ta';
    } else if (global.__spotify && global.__spotify.developer_mode) {
      environment = 'development';
    }

    const release = _getGlobal('app_version', '0.0.0');
    const locale = _getGlobal('locale', 'en');
    const gitRevision = _getGlobal('app_manifest', {}).GitRevision;
    const config = {
      sampleRate,
      environment,
      autoBreadcrumbs: {
        console: false
      },
      release,
      tags: {
        locale,
        gitRevision,
        uuid
      }
    };

    debug('config', config);
    _ravenJs2.default.config(dsn, config).install();

    // Report Errors that occured during the install.
    errorsDuringInstall.forEach(error => {
      debug('reporting queued error', error);
      _ravenJs2.default.captureException(error);
    });
    window.removeEventListener('error', onWindowError);

    window.addEventListener('unhandledrejection', event => {
      _ravenJs2.default.captureException(event.reason);
    });
  });
}

function _getGlobal(key, fallback) {
  return global.__spotify && global.__spotify.hasOwnProperty(key) ? global.__spotify[key] : fallback;
}

function _getAbbaSampleRate() {
  return _abba2.default.fetch([SAMPLE_RATE_ABBA]).then(cells => {
    return cells[SAMPLE_RATE_ABBA] || 0;
  }).catch(() => {
    return 0;
  });
}

function _getSessionId() {
  return new Promise(resolve => {
    (0, _messageProxy.messageProxy)({
      method: 'GET',
      uri: 'client-state',
      target: 'top'
    }, (err, data) => {
      if (!err) {
        resolve(data.state.session_uuid);
      } else {
        resolve(0);
      }
    });
  });
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../abba":74,"../client-state/src/product-state":88,"../debug":90,"../message-proxy":228,"raven-js":526}],247:[function(require,module,exports){
/*
attributes
*/
'use strict';

const $ = require('./base');

const trim = require('mout/string/trim');
const forEach = require('mout/array/forEach');
const filter = require('mout/array/filter');
const indexOf = require('mout/array/indexOf');

// attributes

$.implement({
  setAttribute: function (name, value) {
    return this.forEach(function (node) {
      node.setAttribute(name, value);
    });
  },

  getAttribute: function (name) {
    const attr = this[0].getAttributeNode(name);
    return attr && attr.specified ? attr.value : null;
  },

  hasAttribute: function (name) {
    const node = this[0];
    if (node.hasAttribute) return node.hasAttribute(name);
    const attr = node.getAttributeNode(name);
    return !!(attr && attr.specified);
  },

  removeAttribute: function (name) {
    return this.forEach(function (node) {
      const attr = node.getAttributeNode(name);
      if (attr) node.removeAttributeNode(attr);
    });
  }
});

const accessors = {};

forEach(['type', 'value', 'name', 'href', 'title', 'id'], function (name) {
  accessors[name] = function (value) {
    return value !== undefined ? this.forEach(function (node) {
      node[name] = value;
    }) : this[0][name];
  };
});

// booleans

forEach(['checked', 'disabled', 'selected'], function (name) {
  accessors[name] = function (value) {
    return value !== undefined ? this.forEach(function (node) {
      node[name] = !!value;
    }) : !!this[0][name];
  };
});

// className

const classes = function (className) {
  const classNames = trim(className).replace(/\s+/g, ' ').split(' ');
  const uniques = {};

  return filter(classNames, function (innerClassName) {
    if (innerClassName !== '' && !uniques[innerClassName]) {
      return uniques[innerClassName] = innerClassName;
    }
    return false;
  }).sort();
};

accessors.className = function (className) {
  return className !== undefined ? this.forEach(function (node) {
    node.className = classes(className).join(' ');
  }) : classes(this[0].className).join(' ');
};

// attribute

$.implement({
  attribute: function (name, value) {
    const accessor = accessors[name];
    let ret;
    if (accessor) ret = accessor.call(this, value);
    if (value) ret = this.setAttribute(name, value);
    if (value === null) ret = this.removeAttribute(name);
    if (value === undefined) ret = this.getAttribute(name);

    return ret;
  }
});

$.implement(accessors);

// shortcuts

$.implement({
  check: function () {
    return this.checked(true);
  },

  uncheck: function () {
    return this.checked(false);
  },

  disable: function () {
    return this.disabled(true);
  },

  enable: function () {
    return this.disabled(false);
  },

  select: function () {
    return this.selected(true);
  },

  deselect: function () {
    return this.selected(false);
  }
});

// classNames, has / add / remove Class

$.implement({
  classNames: function () {
    return classes(this[0].className);
  },

  hasClass: function (className) {
    return indexOf(this.classNames(), className) > -1;
  },

  addClass: function (className) {
    return this.forEach(function (node) {
      const nodeClassName = node.className;
      const classNames = classes(`${nodeClassName} ${className}`).join(' ');
      if (nodeClassName !== classNames) node.className = classNames;
    });
  },

  removeClass: function (className) {
    return this.forEach(function (node) {
      const classNames = classes(node.className);
      forEach(classes(className), function (innerClassName) {
        const index = indexOf(classNames, innerClassName);
        if (index > -1) classNames.splice(index, 1);
      });
      node.className = classNames.join(' ');
    });
  },

  toggleClass: function (className, force) {
    const add = force !== undefined ? force : !this.hasClass(className);
    if (add) this.addClass(className);else this.removeClass(className);
    return !!add;
  }
});

// toString

$.prototype.toString = function () {
  const tag = this.tag();
  const id = this.id();
  const innerClasses = this.classNames();

  let str = tag;
  if (id) str += `#${id}`;
  if (innerClasses.length) str += `.${innerClasses.join('.')}`;
  return str;
};

const textProperty = document.createElement('div').textContent === null ? 'innerText' : 'textContent';

// tag, html, text, data

$.implement({
  tag: function () {
    return this[0].tagName.toLowerCase();
  },

  html: function (html) {
    return html !== undefined ? this.forEach(function (node) {
      node.innerHTML = html;
    }) : this[0].innerHTML;
  },

  text: function (text) {
    return text !== undefined ? this.forEach(function (node) {
      node[textProperty] = text;
    }) : this[0][textProperty];
  },

  data: function (key, value) {
    switch (value) {
      case undefined:
        return this.getAttribute(`data-${key}`);
      case null:
        return this.removeAttribute(`data-${key}`);
      default:
        return this.setAttribute(`data-${key}`, value);
    }
  }
});

module.exports = $;

},{"./base":248,"mout/array/filter":447,"mout/array/forEach":448,"mout/array/indexOf":449,"mout/string/trim":486}],248:[function(require,module,exports){
(function (global){
/*
elements
*/'use strict';

const prime = require('../../libs/prime');

const forEach = require('mout/array/forEach');
const map = require('mout/array/map');
const filter = require('mout/array/filter');
const every = require('mout/array/every');
const some = require('mout/array/some');

// uniqueID
const doc = global.document || {};
let index = 0;
const __dc = doc.__counter;
const counter = doc.__counter = (__dc ? parseInt(__dc, 36) + 1 : 0).toString(36);
const key = `uid:${counter}`;

const uniqueID = function (n) {
  if (n === window) return 'window';
  if (n === document) return 'document';
  if (n === document.documentElement) return 'html';
  return n[key] || (n[key] = (index++).toString(36));
};

const instances = new WeakMap();

// elements prime

const $ = prime({
  constructor: function $(n, context) {
    // TODO: Fix this to use dependency injection and/or actual classes
    // eslint-disable-next-line no-use-before-define
    if (!n) return this && this.constructor === $ ? new Elements() : null;

    let self;
    let uid;

    // eslint-disable-next-line no-use-before-define
    if (n.constructor !== Elements) {
      // eslint-disable-next-line no-use-before-define
      self = new Elements();

      if (typeof n === 'string') {
        if (!self.search) return null;
        self[self.length++] = context || document;
        return self.search(n);
      }

      if (n.nodeType || n === window) {
        self[self.length++] = n;
      } else if (n.length) {
        // this could be an array, or any object with a length attribute,
        // including another instance of elements from another interface.

        const uniques = {};

        for (let i = 0, l = n.length; i < l; i++) {
          // perform elements flattening
          const nodes = $(n[i], context);
          if (nodes && nodes.length) {
            for (let j = 0, k = nodes.length; j < k; j++) {
              const node = nodes[j];
              uid = uniqueID(node);
              if (!uniques[uid]) {
                self[self.length++] = node;
                uniques[uid] = true;
              }
            }
          }
        }
      }
    } else {
      self = n;
    }

    if (!self.length) return null;

    // when length is 1 always use the same elements instance

    if (self.length === 1) {
      const instance = instances.get(self[0]);
      if (instance) {
        return instance;
      }
      instances.set(self[0], self);
    }

    return self;
  }
});

const Elements = prime({
  inherits: $,

  constructor: function Elements() {
    this.length = 0;
  },

  unlink: function () {
    return this.map(function (node) {
      instances.delete(node);
      return node;
    });
  },

  // methods

  forEach: function (method, context) {
    forEach(this, method, context);
    return this;
  },

  map: function (method, context) {
    return map(this, method, context);
  },

  filter: function (method, context) {
    return filter(this, method, context);
  },

  every: function (method, context) {
    return every(this, method, context);
  },

  some: function (method, context) {
    return some(this, method, context);
  }
});

module.exports = $;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../libs/prime":243,"mout/array/every":446,"mout/array/filter":447,"mout/array/forEach":448,"mout/array/map":451,"mout/array/some":454}],249:[function(require,module,exports){
/*
delegation
*/'use strict';

const Map = require('../../libs/prime/map');

const $ = require('./events');
require('./traversal');

$.implement({
  delegate: function (event, selector, handle) {
    return this.forEach(function (node) {
      const self = $(node);

      const delegation = self._delegation || (self._delegation = {});
      const events = delegation[event] || (delegation[event] = {});
      const map = events[selector] || (events[selector] = new Map());

      if (map.get(handle)) return;

      const action = function (e) {
        const target = $(e.target || e.srcElement);
        const match = target.matches(selector) ? target : target.parent(selector);

        let res;

        if (match) res = handle.call(self, e, match);

        return res;
      };

      map.set(handle, action);

      self.on(event, action);
    });
  },

  undelegate: function (event, selector, handle) {
    return this.forEach(function (node) {
      const self = $(node);
      const delegation = self._delegation;

      if (!delegation) {
        return;
      }

      const events = delegation[event];
      if (!events) {
        return;
      }

      const map = events[selector];
      if (!map) {
        return;
      }

      const action = map.get(handle);

      if (action) {
        self.off(event, action);
        map.remove(action);

        // if there are no more handles in a given selector, delete it
        if (!map.count()) delete events[selector];
        // var evc = evd = 0, x
        let e1 = true;
        let e2 = true;

        for (const x in events) {
          if (!events.hasOwnProperty(x)) continue;
          e1 = false;
          break;
        }
        // if no more selectors in a given event type, delete it
        if (e1) delete delegation[event];
        for (const x in delegation) {
          if (!delegation.hasOwnProperty(x)) continue;
          e2 = false;
          break;
        }
        // if there are no more delegation events in the element, delete the _delegation object
        if (e2) delete self._delegation;
      }
    });
  }
});

module.exports = $;

},{"../../libs/prime/map":244,"./events":250,"./traversal":253}],250:[function(require,module,exports){
/*
events
*/'use strict';

const Emitter = require('../../libs/prime/emitter');

const $ = require('./base');

$.implement({
  on: function (event, handle, useCapture) {
    return this.forEach(function (node) {
      const self = $(node);

      const internalEvent = event + (useCapture ? ':capture' : '');

      Emitter.prototype.on.call(self, internalEvent, handle);

      const domListeners = self._domListeners || (self._domListeners = {});
      if (!domListeners[internalEvent]) {
        const listener = function (e) {
          Emitter.prototype.emit.call(self, internalEvent, e || window.event, Emitter.EMIT_SYNC);
        };
        node.addEventListener(event, listener, useCapture || false);
        domListeners[internalEvent] = listener;
      }
    });
  },

  off: function (event, handle, useCapture) {
    return this.forEach(function (node) {
      const self = $(node);

      const internalEvent = event + (useCapture ? ':capture' : '');

      const domListeners = self._domListeners;
      const listeners = self._listeners;

      if (domListeners && listeners) {
        const domEvent = domListeners[internalEvent];

        if (domEvent) {
          Emitter.prototype.off.call(self, internalEvent, handle);

          if (!self._listeners || !self._listeners[event]) {
            node.removeEventListener(event, domEvent, false);
            delete domListeners[event];

            for (const l in domListeners) {
              if (domListeners.hasOwnProperty(l)) {
                return;
              }
            }
            delete self._domListeners;
          }
        }
      }
    });
  },

  emit: function () {
    const args = arguments;
    return this.forEach(function (node) {
      Emitter.prototype.emit.apply($(node), args);
    });
  }
});

module.exports = $;

},{"../../libs/prime/emitter":242,"./base":248}],251:[function(require,module,exports){
/*
elements
*/'use strict';

const $ = require('./base');
require('./attributes');
require('./events');
require('./insertion');
require('./traversal');
require('./delegation');

module.exports = $;

},{"./attributes":247,"./base":248,"./delegation":249,"./events":250,"./insertion":252,"./traversal":253}],252:[function(require,module,exports){
/*
insertion
*/'use strict';

const $ = require('./base');

// base insertion

$.implement({
  appendChild: function (child) {
    this[0].appendChild($(child)[0]);
    return this;
  },

  insertBefore: function (child, ref) {
    this[0].insertBefore($(child)[0], $(ref)[0]);
    return this;
  },

  removeChild: function (child) {
    this[0].removeChild($(child)[0]);
    return this;
  },

  replaceChild: function (child, ref) {
    this[0].replaceChild($(child)[0], $(ref)[0]);
    return this;
  }
});

// before, after, bottom, top

$.implement({
  before: function (element) {
    const innerElement = $(element)[0];
    const parent = innerElement.parentNode;
    if (parent) {
      this.forEach(function (node) {
        parent.insertBefore(node, innerElement);
      });
    }
    return this;
  },

  after: function (element) {
    const innerElement = $(element)[0];
    const parent = innerElement.parentNode;
    if (parent) {
      this.forEach(function (node) {
        parent.insertBefore(node, innerElement.nextSibling);
      });
    }
    return this;
  },

  bottom: function (element) {
    const innerElement = $(element)[0];
    return this.forEach(function (node) {
      innerElement.appendChild(node);
    });
  },

  top: function (element) {
    const innerElement = $(element)[0];
    return this.forEach(function (node) {
      innerElement.insertBefore(node, innerElement.firstChild);
    });
  }
});

// insert, replace

$.implement({
  insert: $.prototype.bottom,

  remove: function () {
    return this.forEach(function (node) {
      const parent = node.parentNode;
      if (parent) parent.removeChild(node);
    });
  },

  replace: function (element) {
    const innerElement = $(element)[0];
    innerElement.parentNode.replaceChild(this[0], innerElement);
    return this;
  }
});

module.exports = $;

},{"./base":248}],253:[function(require,module,exports){
/*
traversal
*/
'use strict';

var _slick = require('slick');

var _slick2 = _interopRequireDefault(_slick);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const map = require('mout/array/map');

const $ = require('./base');

const gen = function (combinator, expression) {
  return map(_slick2.default.parse(expression || '*'), function (part) {
    return `${combinator} ${part}`;
  }).join(', ');
};

const push_ = Array.prototype.push;

$.implement({
  search: function (expression) {
    if (this.length === 1) return $(_slick2.default.search(expression, this[0], new $()));

    let buffer = [];
    for (let i = 0; i < this.length; i++) {
      const node = this[i];
      push_.apply(buffer, _slick2.default.search(expression, node));
    }
    buffer = $(buffer);
    return buffer && buffer.sort();
  },

  find: function (expression) {
    if (this.length === 1) return $(_slick2.default.find(expression, this[0]));

    for (let i = 0; i < this.length; i++) {
      const node = this[i];
      const found = _slick2.default.find(expression, node);
      if (found) return $(found);
    }

    return null;
  },

  sort: function () {
    return _slick2.default.sort(this);
  },

  matches: function (expression) {
    return _slick2.default.matches(this[0], expression);
  },

  contains: function (node) {
    return _slick2.default.contains(this[0], node);
  },

  nextSiblings: function (expression) {
    return this.search(gen('~', expression));
  },

  nextSibling: function (expression) {
    return this.find(gen('+', expression));
  },

  previousSiblings: function (expression) {
    return this.search(gen('!~', expression));
  },

  previousSibling: function (expression) {
    return this.find(gen('!+', expression));
  },

  children: function (expression) {
    return this.search(gen('>', expression));
  },

  firstChild: function (expression) {
    return this.find(gen('^', expression));
  },

  lastChild: function (expression) {
    return this.find(gen('!^', expression));
  },

  parent: function (expression) {
    const buffer = [];
    for (let i = 0; i < this.length; i++) {
      let node = this[i].parentNode;
      while (node && node !== document) {
        if (!expression || _slick2.default.matches(node, expression)) {
          buffer.push(node);
          break;
        }

        node = node.parentNode;
      }
    }
    return $(buffer);
  },

  parents: function (expression) {
    const buffer = [];
    for (let i = 0; i < this.length; i++) {
      let node = this[i];
      while (node && node !== document) {
        if (!expression || _slick2.default.matches(node, expression)) buffer.push(node);
        node = node.parentNode;
      }
    }
    return $(buffer);
  }
});

module.exports = $;

},{"./base":248,"mout/array/map":451,"slick":712}],254:[function(require,module,exports){
'use strict';

const $ = require('../spotify-elements');
const live = require('../live');
const liburi = require('spotify-liburi');
const surroundMessages = require('../surround-messages');

const center = require('./center');

const IS_ADDED_PROPERTY = 'added';
const BUTTON_SELECTOR = '[data-button=add]';
const JUSTCHANGED_CLASSNAME = 'just-changed';
const ADDED_CLASSNAME = 'added';
const INTERACTION_INTENT_ATTR = 'data-interaction-intent';
const INTERACTION_INTENT_SAVE = 'save';
const INTERACTION_INTENT_ADD = 'add';
const INTERACTION_INTENT_REMOVE = 'remove';
const INTERACTION_INTENT_FOLLOW = 'follow';
const INTERACTION_INTENT_UNFOLLOW = 'unfollow';
const INTERACTION_TARGET_ATTR = 'data-interaction-target';
const TOGGLE_FOLLOW_STATE_BUTTON = 'toggle-follow-state-button';
const SAVE_REMOVE_BUTTON = 'save-remove-button';

const changeHandlers = {};
let isAttached = false;

function getAddedClass(node) {
  const addedClassNode = node[0].closest('data-class-added');
  return addedClassNode ? addedClassNode.getAttribute('data-class-added') : ADDED_CLASSNAME;
}

function getURIFromNode(node) {
  const stateNode = node[0].closest('[data-uri]');
  if (!stateNode) {
    return null;
  }
  return stateNode.getAttribute('data-uri');
}

const eventHandlers = {
  click: function (event, node) {
    const stateNode = $(node[0].closest('[data-uri]'));
    if (!stateNode) return;

    let uri = stateNode.data('uri');
    if (!uri) return;

    // Rewrite collection-(album|artist) to vanilla counterparts.
    const uriObject = liburi.from(uri);
    if (uriObject) {
      if (uriObject.type === liburi.Type.COLLECTION_ALBUM) {
        uri = liburi.albumURI(uriObject.id).toURI();
      } else if (uriObject.type === liburi.Type.COLLECTION_ARTIST) {
        uri = liburi.artistURI(uriObject.id).toURI();
      }
    }

    const addedClass = getAddedClass(node);
    const shouldBeAdded = !stateNode.hasClass(addedClass);
    const data = {
      added: shouldBeAdded
    };

    node.addClass(JUSTCHANGED_CLASSNAME);

    // using capture=true to handle buttons with inner divs (used for changing button text)
    node.on('mouseout', function mouseoutHandler(innerEvent) {
      if (innerEvent.target !== node[0]) return;
      node.off('mouseout', mouseoutHandler);
      node.removeClass(JUSTCHANGED_CLASSNAME);
    }, true);

    // Publish will trigger the update event, which will then update the UI
    live(uri).publish(data);

    // Inform Surround (for More-Like-This)
    surroundMessages.dispatchUriAdded(uri, data);
  },

  changeHandler: function (actions, key, value, uri) {
    if (key === IS_ADDED_PROPERTY) {
      const numAffectedButtons = actions.setStateForURI(uri, value);
      if (numAffectedButtons === 0) {
        live(uri).off('update', changeHandlers[uri]);
        delete changeHandlers[uri];
      }
    }
  }
};

const actions = {
  setStateForURI: function (uri, isAdded) {
    let numAffectedButtons = 0;

    const nodes = $(document).search(BUTTON_SELECTOR);
    if (!nodes) return numAffectedButtons;

    for (let i = 0, l = nodes.length; i < l; i++) {
      const node = $(nodes[i]);
      const buttonURI = getURIFromNode(node);
      if (uri === buttonURI) {
        numAffectedButtons++;
        actions.setStateForButtonNode(node, isAdded);
      }
    }

    return numAffectedButtons;
  },

  setStateForButtonNode: function (node, isAdded) {
    const stateNode = $(node[0].closest('[data-uri]'));
    if (!stateNode) return;

    const addedClass = getAddedClass(node);
    actions.setVisualState(isAdded, stateNode, node, addedClass);
  },

  setVisualState: function (isAdded, node, button, className) {
    if (isAdded) {
      if (!node.hasClass(className)) node.addClass(className);
      const tooltipRemove = button.data('tooltip-remove');
      if (tooltipRemove) {
        button.setAttribute('data-tooltip', tooltipRemove);
        button.setAttribute('aria-label', tooltipRemove);
      }
      button.setAttribute('data-log-click', 'remove-button');
      const interactionIntent = button.getAttribute(INTERACTION_TARGET_ATTR) === TOGGLE_FOLLOW_STATE_BUTTON ? INTERACTION_INTENT_UNFOLLOW : INTERACTION_INTENT_REMOVE;
      button.setAttribute(INTERACTION_INTENT_ATTR, interactionIntent);
    } else {
      if (node.hasClass(className)) node.removeClass(className);
      const tooltipAdd = button.data('tooltip-add');
      if (tooltipAdd) {
        button.setAttribute('data-tooltip', tooltipAdd);
        button.setAttribute('aria-label', tooltipAdd);
      }
      const interactionTarget = button.getAttribute(INTERACTION_TARGET_ATTR);
      switch (interactionTarget) {
        case SAVE_REMOVE_BUTTON:
          button.setAttribute(INTERACTION_INTENT_ATTR, INTERACTION_INTENT_SAVE);
          break;

        case TOGGLE_FOLLOW_STATE_BUTTON:
          button.setAttribute(INTERACTION_INTENT_ATTR, INTERACTION_INTENT_FOLLOW);
          break;

        default:
          button.setAttribute(INTERACTION_INTENT_ATTR, INTERACTION_INTENT_ADD);
          break;
      }
      button.setAttribute('data-log-click', 'add-button');
    }
  },

  addListenerForNode: function (node) {
    const uri = getURIFromNode(node);

    // If we have already added a change handler for this URI,
    // we don't want to add another one, so we cancel early.
    // Before cancelling though, we should update button states
    // with the current state from the live model, since there
    // might be new buttons in the DOM.
    if (changeHandlers[uri]) {
      live(uri).get('added', function (error, isAdded) {
        if (error) throw error;
        actions.setStateForButtonNode(node, isAdded);
      }, live.ASAP);
      return;
    }

    changeHandlers[uri] = function (properties) {
      for (const key in properties) {
        if (!properties.hasOwnProperty(key)) continue;
        const value = properties[key];
        eventHandlers.changeHandler(actions, key, value, uri);
      }
    };

    const model = live(uri);

    // Get the initial state and update the button
    model.get('added', function (error, isAdded) {
      if (error) throw error;
      actions.setStateForButtonNode(node, isAdded);

      // When the initial state is known, we listen for updates
      // so we can update all buttons for this URI later.
      model.on('update', changeHandlers[uri]);
    }, live.ASAP);
  }
};

const update = exports.update = function update(node, nodes) {
  if (!isAttached) return;

  // If the node passed in is a button node, just add listeners for that
  if (node && $(node).matches(BUTTON_SELECTOR)) {
    actions.addListenerForNode($(node));

    // Otherwise search all the children of the node (or the document
    // if node is not provided) for buttons.
  } else {
    const innerNodes = ($(nodes) || $(node) || $(document)).search(BUTTON_SELECTOR);
    if (!innerNodes) return;

    for (let i = 0, l = innerNodes.length; i < l; i++) {
      actions.addListenerForNode($(innerNodes[i]));
    }
  }
};

const handleScrollShow = function (data) {
  update(data.pageNode, data.nodes);
};

// Export for testing
exports._classNames = {
  ADDED: ADDED_CLASSNAME,
  JUSTCHANGED: JUSTCHANGED_CLASSNAME
};

exports.attach = function attach() {
  if (isAttached) return;
  isAttached = true;

  $(document).delegate('click', BUTTON_SELECTOR, eventHandlers.click);

  center.on('scroll-show-before', handleScrollShow);
};

exports.detach = function detach() {
  if (!isAttached) return;
  isAttached = false;

  $(document).undelegate('click', BUTTON_SELECTOR, eventHandlers.click);
  center.off('scroll-show-before', handleScrollShow);
};

},{"../live":210,"../spotify-elements":251,"../surround-messages":358,"./center":262,"spotify-liburi":730}],255:[function(require,module,exports){
'use strict';

const $ = require('../spotify-elements');
const Navigator = require('../navigation/navigator');

const SELECTOR = 'a';

const nav = new Navigator();

const handleAnchorClick = function (event, node) {
  const anchor = node[0];
  const href = anchor.getAttribute('href');
  if (!href || href[0] === '#') {
    return;
  }
  event.preventDefault();
  nav.openURI(href);
};

let isAttached = false;

exports.attach = function attach() {
  if (isAttached) {
    return;
  }
  isAttached = true;
  $(document).delegate('click', SELECTOR, handleAnchorClick);
};

exports.detach = function detach() {
  if (!isAttached) {
    return;
  }
  isAttached = false;
  $(document).undelegate('click', SELECTOR, handleAnchorClick);
};

exports.update = function () {};

},{"../navigation/navigator":232,"../spotify-elements":251}],256:[function(require,module,exports){
'use strict';

const modules = [require('./touch'), require('./pressed'), require('./loading'), require('./remove')];

exports.attach = function () {
  modules.forEach(function (module) {
    module.attach();
  });
};

exports.detach = function () {
  modules.forEach(function (module) {
    module.detach();
  });
};

exports.update = function () {
  modules.forEach(function (module) {
    module.update();
  });
};

},{"./loading":257,"./pressed":258,"./remove":259,"./touch":260}],257:[function(require,module,exports){
'use strict';

const CARD = '.card';
const IMAGE_LOADING_TRANSITION = 1000;

let currentCards = [];

function addCardImage(card) {
  let imageUri;
  const element = card.querySelector('[data-image-url]');
  if (element) {
    imageUri = element.getAttribute('data-image-url');
  }

  if (imageUri) {
    const onImageLoad = function (t) {
      return () => {
        card.classList.add('image-loaded');
        clearTimeout(t);
      };
    };

    const onImageError = function () {
      card.classList.add('image-error');
    };

    const timeout = setTimeout(function () {
      card.classList.add('image-delayed');
    }, IMAGE_LOADING_TRANSITION);

    const image = new Image();
    image.addEventListener('load', onImageLoad(timeout));
    image.addEventListener('error', onImageError);
    image.src = imageUri;
  }
}

let isAttached = false;

exports.attach = function () {
  if (isAttached) return;
  isAttached = true;
};

exports.detach = function () {
  if (!isAttached) return;
  isAttached = false;

  currentCards = [];
};

exports.update = function () {
  if (!isAttached) return;

  // Forget orphaned cards
  currentCards = currentCards.filter(function (card) {
    return card.closest('body');
  });

  const cards = document.querySelectorAll(CARD);
  cards.forEach(card => {
    const known = currentCards.indexOf(card) !== -1;
    if (known) {
      return;
    }
    currentCards.push(card);
    addCardImage(card);
  });
};

exports._reset = function () {
  currentCards = [];
};

},{}],258:[function(require,module,exports){
'use strict';

const $ = require('../../spotify-elements');
const CARD = '[data-card-pressed-container]';
const TRIGGER = '[data-card-trigger-pressed-state]';

const doc = $(document);
let pressedElement;

function handleMouseDown(event, element) {
  // The card shouldn't animate when pressing buttons inside of it.
  if (event.target.nodeName.toLowerCase() === 'button') {
    return;
  }
  // The card shouldn't animate when right clicking it
  if (event.button === 2) {
    return;
  }
  element[0].closest(CARD).classList.add('pressed');
  pressedElement = element[0];
}

function handleMouseUp(event, element) {
  element[0].closest(CARD).classList.remove('pressed');

  if (pressedElement === element[0]) {
    pressedElement = null;
  }
}

function handleDragEnd(event, element) {
  element[0].closest(CARD).classList.remove('pressed');

  if (pressedElement === element[0]) {
    pressedElement = null;
  }
}

function handleDocumentMouseUp() {
  if (pressedElement) {
    pressedElement.closest(CARD).classList.remove('pressed');
    pressedElement = null;
  }
}

let isAttached = false;

exports.attach = function () {
  if (isAttached) return;
  isAttached = true;

  doc.delegate('mousedown', TRIGGER, handleMouseDown);
  doc.delegate('mouseup', TRIGGER, handleMouseUp);
  doc.delegate('dragend', TRIGGER, handleDragEnd);
  doc.on('mouseup', handleDocumentMouseUp);
};

exports.detach = function () {
  if (!isAttached) return;
  isAttached = false;

  doc.undelegate('mousedown', TRIGGER, handleMouseDown);
  doc.undelegate('mouseup', TRIGGER, handleMouseUp);
  doc.undelegate('dragend', TRIGGER, handleDragEnd);
  doc.off('mouseup', handleDocumentMouseUp);
};

exports.update = function () {};

},{"../../spotify-elements":251}],259:[function(require,module,exports){
'use strict';

const center = require('../center');
const BUTTON = '[data-card-remove-button]';

function handleClick(event) {
  const element = event.target;
  if (!element.matches(BUTTON)) {
    return;
  }
  const uriElement = element.closest('[data-uri]');
  if (!uriElement) {
    return;
  }
  const uri = uriElement.getAttribute('data-uri');
  center.emit('card-remove', { uri, element });

  // Make sure CEF doesn't follow the link that the button is contained in.
  event.preventDefault();
  // Also make sure spotify-events/anchor doesn't act upon it and follows the link.
  event.stopPropagation();
}

let isAttached = false;

exports.attach = function () {
  if (isAttached) return;
  isAttached = true;
  // We need to get this before spotify-events/anchor.
  document.addEventListener('click', handleClick, true);
};

exports.detach = function () {
  if (!isAttached) return;
  isAttached = false;
  document.removeEventListener('click', handleClick, true);
};

exports.update = function () {};

},{"../center":262}],260:[function(require,module,exports){
'use strict';

const $ = require('../../spotify-elements');
const CARD = '.card';
const IMAGE_HIT_AREA = '.card-image-hit-area';

const doc = $(document);
let hoverActive = false;

let touchArray = [];
const addEvent = function (touchEvent) {
  touchArray.push(touchEvent);
};

function getCards() {
  return doc.search(CARD);
}

function isCard(element) {
  return typeof element.closest === 'function' && !!element.closest(CARD);
}

function handleEvent(e) {
  const target = e.target;
  if (isCard(target)) {
    switch (e.type) {
      case 'touchstart':
        addEvent(e);
        if (hoverActive) {
          disableHover();
        }
        break;

      case 'touchmove':
        addEvent(e);
        break;

      case 'touchend':
        if (target && touchArray.length === 1 && touchArray[0].type === 'touchstart') {
          e.preventDefault();
          target.click();
        }
        touchArray = [];
        break;

      case 'contextmenu':
        addEvent(e);
        break;

      case 'mousemove':
        if (!hoverActive) {
          enableHover();
        }
        break;

      default:
        break;
    }
  }
}

function disableHover() {
  const cards = getCards();
  if (cards) {
    cards.forEach(function (card) {
      const hitArea = $(card).find(IMAGE_HIT_AREA);
      if (hitArea) {
        hitArea.addClass('no-hover');
      }
    });
    hoverActive = false;
  }
}

function enableHover() {
  const cards = getCards();
  if (cards) {
    cards.forEach(function (card) {
      const hitArea = $(card).find(IMAGE_HIT_AREA);
      if (hitArea) {
        hitArea.removeClass('no-hover');
      }
    });
    hoverActive = true;
  }
}

let isAttached = false;

exports.attach = function () {
  if (isAttached) return;
  isAttached = true;

  doc.on('touchstart', handleEvent);
  doc.on('touchmove', handleEvent);
  doc.on('touchend', handleEvent);
  doc.on('mousemove', handleEvent);
  doc.on('contextmenu', handleEvent);
};

exports.detach = function () {
  if (!isAttached) return;
  isAttached = false;

  doc.off('touchstart', handleEvent);
  doc.off('touchmove', handleEvent);
  doc.off('touchend', handleEvent);
  doc.off('mousemove', handleEvent);
  doc.off('contextmenu', handleEvent);
};

exports.update = function () {};

exports._reset = function () {
  hoverActive = true;
};

},{"../../spotify-elements":251}],261:[function(require,module,exports){
(function (global){
'use strict';

const $ = require('../spotify-elements');
const doc = $(document);
const win = $(window);

// Decides how many pixels allowed between two touchmoves to determine if it is a swipe
const SWIPE_SENSITIVITY = 1;
// Constant that sets the amount of pixels allowed to move without locking the horizontal scroll
const SCROLL_LOCK_LIMIT = 10;
// The divider used to calculate the swipe speed. A larger number will make a slower swipe
const SWIPE_LAG = 14;

const carouselPosition = function (carouselInner) {
  return carouselInner.style.left || '0';
};

const getCarouselObjectsWidth = function (carouselInner) {
  const items = carouselInner.children;
  if (!items) {
    return null;
  }
  const itemWidth = parseFloat(global.getComputedStyle(items[0]).width);
  const carouselInnerWidth = parseFloat(global.getComputedStyle(carouselInner).width);
  const carouselTotalWidth = carouselInner.scrollWidth;

  return {
    itemWidth: itemWidth,
    carouselInnerWidth: carouselInnerWidth,
    carouselTotalWidth: carouselTotalWidth
  };
};

const calculateMinLeftPixels = function (carouselInner) {
  let minLeft = 0;
  // Determine number of pages based on numbers per page and total number of objects
  const carouselObjectsWidth = getCarouselObjectsWidth(carouselInner);
  if (!carouselObjectsWidth) {
    return minLeft;
  }

  const objectsPerPage = Math.round(carouselObjectsWidth.carouselInnerWidth / carouselObjectsWidth.itemWidth);
  const totalNrOfObjects = Math.round(carouselObjectsWidth.carouselTotalWidth / carouselObjectsWidth.itemWidth);
  const nrOfPages = Math.ceil(totalNrOfObjects / objectsPerPage);
  minLeft = -(carouselObjectsWidth.carouselInnerWidth * (nrOfPages - 1));
  return minLeft;
};

const getNextPageInPercent = function (positionLeft, carouselInner, isLeft) {
  const carouselInnerWidth = carouselInner.clientWidth;
  const minLeft = calculateMinLeftPixels(carouselInner);
  const isInPercent = positionLeft.endsWith('%');
  const newPositionLeft = parseInt(positionLeft, 10);
  // If current unit isn't %, change to %
  let nextPage;
  if (!isInPercent) {
    nextPage = Math.abs(newPositionLeft / carouselInnerWidth);
    if (newPositionLeft === 0 && !isLeft) {
      // If position is to the end left and button is right
      nextPage = -100;
    } else if (newPositionLeft === minLeft && isLeft) {
      // If position is to the end right and button is left
      nextPage = (nextPage - 1) * -100;
    } else {
      nextPage = isLeft ? Math.floor(nextPage) : Math.ceil(nextPage);
      nextPage = nextPage * -100;
    }
  } else {
    // If current unit already is in percent
    nextPage = isLeft ? newPositionLeft + 100 : newPositionLeft - 100;
  }
  return nextPage;
};

const resetTransitions = function (carouselInner) {
  if (!carouselInner) {
    return;
  }
  // Add click transition and remove drag + swipe transition
  $(carouselInner).removeClass('crsl-inner-drag').removeClass('crsl-inner-swipe');
};

const updateButtonStates = function (carouselId, optAdjust) {
  const carouselRight = $(`[data-carousel=${carouselId}][data-button=carousel-right]`);
  const carouselLeft = $(`[data-carousel=${carouselId}][data-button=carousel-left]`);
  const carousel = $(`[data-carousel=${carouselId}][data-carousel-main]`);
  const carouselInner = $(carousel).search('[data-carousel-inner]')[0];
  let leftAdjust;

  if (typeof optAdjust === 'number') {
    leftAdjust = optAdjust;
  } else {
    leftAdjust = carouselInner.style.left ? parseInt(carouselInner.style.left, 10) : 0;
  }

  const shouldRightButtonBeDisabled = carouselInner.clientWidth - leftAdjust / 100 * carouselInner.clientWidth + 10 > carouselInner.scrollWidth;

  // Scroll carousel to the begining if it's not possible to scroll
  if (carouselInner.clientWidth === carouselInner.scrollWidth) {
    carouselInner.style.left = '0%';
  }

  if (leftAdjust >= 0) {
    carouselLeft.setAttribute('disabled', 'disabled');
  } else {
    carouselLeft.removeAttribute('disabled');
  }

  if (shouldRightButtonBeDisabled) {
    carouselRight.setAttribute('disabled', 'disabled');
  } else {
    carouselRight.removeAttribute('disabled');
  }
};

const handleButtonClick = function (buttonNode, isLeft) {
  if (buttonNode.hasAttribute('disabled')) {
    return;
  }
  const carouselId = buttonNode.data('carousel');
  const carouselInner = $(`[data-carousel=${carouselId}][data-carousel-main] [data-carousel-inner]`)[0];
  const positionLeft = carouselPosition(carouselInner);

  let adjust;
  if (positionLeft) {
    // Get next page in %
    const nextPage = getNextPageInPercent(positionLeft, carouselInner, isLeft);
    adjust = nextPage;
  } else {
    adjust = isLeft ? 0 : -100;
  }
  // Reset transitions
  resetTransitions(carouselInner);
  updateButtonStates(carouselId, adjust);
  carouselInner.style.left = `${adjust}%`;
};

const handleClickLeft = function (event, node) {
  handleButtonClick(node, true);
};

const handleClickRight = function (event, node) {
  handleButtonClick(node, false);
};

const getCarouselInner = function (node) {
  return node.search('[data-carousel-inner]');
};

const handleTouchStart = function (event, node) {
  // Disable swiping the carousel if scrolling down/up the page
  let scrollBlocked = false;
  doc.on('scroll', handleScroll);

  function handleScroll(scrollEvent) {
    if (!scrollBlocked) {
      doc.undelegate('touchmove', '[data-carousel]', handleTouchMove);
      doc.undelegate('touchend', '[data-carousel]', handleTouchEnd);
    } else {
      scrollEvent.preventDefault();
    }
  }

  // Get carousel element
  let carouselInner = getCarouselInner(node);
  if (!carouselInner) {
    return;
  }
  carouselInner = carouselInner[0];
  let startX;
  let previousX;
  let deltaX;
  // minLeft is always a negative number or 0. This is the minimum LEFT position of the carousel.
  const minLeft = calculateMinLeftPixels(carouselInner);
  if (minLeft === 0) {
    return;
  }
  doc.delegate('touchmove', '[data-carousel]', handleTouchMove);
  doc.delegate('touchend', '[data-carousel]', handleTouchEnd);

  // Get start coordinates
  if (event.touches) {
    startX = event.touches[0].pageX;
    previousX = startX;
  }

  const addDragTransition = function () {
    if (!carouselInner) {
      return;
    }
    // Add drag transition and remove swipe + click transition
    $(carouselInner).addClass('crsl-inner-drag').removeClass('crsl-inner-swipe');
  };

  const getPositionInPixels = function (positionLeft) {
    const isInPx = positionLeft.endsWith('px');
    let newPositionLeft = parseFloat(positionLeft);
    // If current unit isn't px, change to px
    if (!isInPx) {
      const currentPage = Math.abs(positionLeft / 100);
      const carouselObjectsWidth = getCarouselObjectsWidth(carouselInner);

      if (carouselObjectsWidth) {
        newPositionLeft = -carouselObjectsWidth.carouselInnerWidth * currentPage;
      }
    }
    return newPositionLeft;
  };

  const checkLimitsPixels = function (adjust) {
    let newAdjust = Math.min(adjust, 0);
    newAdjust = Math.max(newAdjust, minLeft);
    return newAdjust;
  };

  function handleTouchMove() {
    if (!carouselInner) {
      return;
    }
    addDragTransition();

    if (event.touches) {
      const x = event.touches[0].pageX;
      deltaX = previousX - x;
      // Get position of carousel
      let positionLeft = carouselPosition(carouselInner);
      positionLeft = getPositionInPixels(positionLeft, carouselInner);
      // Set adjusted position
      let adjust = positionLeft - deltaX;
      // Check that carousel position doesn't exceed limits
      adjust = checkLimitsPixels(adjust, minLeft);
      carouselInner.style.left = `${adjust}px`;
      previousX = x;

      if (deltaX > SCROLL_LOCK_LIMIT) {
        scrollBlocked = true;
      }
      if (scrollBlocked) {
        event.preventDefault();
      }
    }
  }

  /* Touch swipe functions */

  const addSwipeTransition = function () {
    if (!carouselInner) {
      return;
    }
    // Add swipe transition and remove drag + click transition
    $(carouselInner).addClass('crsl-inner-swipe').removeClass('crsl-inner-drag');
  };

  const swipe = function (innerDeltaX) {
    addSwipeTransition();
    // Get position of carousel
    let leftValue = carouselPosition(carouselInner);
    leftValue = getPositionInPixels(leftValue, carouselInner);

    const carouselObjectsWidth = getCarouselObjectsWidth(carouselInner);
    // Get width of one mediaobject to us as an interval in the calculation for setting the swipe speed
    const itemWidth = carouselObjectsWidth ? parseInt(carouselObjectsWidth.itemWidth, 10) : null;
    if (!itemWidth) {
      return;
    }
    // Calculate position to swipe to based on value of deltaX (e.g. swipe acceleration) and SWIPE_LAG
    // SWIPE_LAG can be changed to a lower/higher value to increase/decrease speed.
    let adjust = leftValue + itemWidth * (-innerDeltaX / SWIPE_LAG);
    // Check that carousel position doesn't exceed limits
    adjust = checkLimitsPixels(adjust, minLeft);
    carouselInner.style.left = `${adjust}px`;
  };

  const updateButtonsOnTouch = function () {
    const carouselId = node.data('carousel');
    let positionLeft = carouselPosition(carouselInner);
    positionLeft = getPositionInPixels(positionLeft, carouselInner);
    const carouselRight = $(`[data-carousel=${carouselId}][data-button=carousel-right]`);
    const carouselLeft = $(`[data-carousel=${carouselId}][data-button=carousel-left]`);

    if (Math.round(positionLeft) <= Math.round(minLeft)) {
      carouselRight.setAttribute('disabled', 'disabled');
    } else {
      carouselRight.removeAttribute('disabled');
    }

    if (positionLeft >= 0) {
      carouselLeft.setAttribute('disabled', 'disabled');
    } else {
      carouselLeft.removeAttribute('disabled');
    }
  };

  function handleTouchEnd() {
    doc.undelegate('touchmove', '[data-carousel]', handleTouchMove);
    doc.undelegate('touchend', '[data-carousel]', handleTouchEnd);
    doc.off('scroll', handleScroll);
    if (!carouselInner) {
      return;
    }
    // If considered as a swipe, swipe
    if (Math.abs(deltaX) > SWIPE_SENSITIVITY) {
      swipe(deltaX);
    }
    updateButtonsOnTouch(node);
  }
};

const updateAllButtons = function (node) {
  if (node && node.ownerDocument && !node.ownerDocument.body.contains(node)) return;
  const newNode = $(node) || doc;
  const carousels = newNode.search('[data-carousel-main]');
  if (carousels) {
    carousels.forEach(function (carousel) {
      updateButtonStates($(carousel).data('carousel'));
    });
  }
};

let isAttached = false;

exports.update = function update(node) {
  if (!isAttached) return;

  updateAllButtons(node);
};

exports.attach = function () {
  if (isAttached) return;
  isAttached = true;

  doc.delegate('click', '[data-button=carousel-right]', handleClickRight);
  doc.delegate('click', '[data-button=carousel-left]', handleClickLeft);
  doc.delegate('touchstart', '[data-carousel][data-carousel-main]', handleTouchStart);

  win.on('resize', updateAllButtons);
};

exports.detach = function () {
  if (!isAttached) return;
  isAttached = false;

  doc.undelegate('click', '[data-button=carousel-right]', handleClickRight);
  doc.undelegate('click', '[data-button=carousel-left]', handleClickLeft);
  doc.undelegate('touchstart', '[data-carousel][data-carousel-main]', handleTouchStart);

  win.off('resize', updateAllButtons);
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../spotify-elements":251}],262:[function(require,module,exports){
/*
Event Center
*/'use strict';

const Emitter = require('../../libs/prime/emitter');

module.exports = new Emitter();

},{"../../libs/prime/emitter":242}],263:[function(require,module,exports){
(function (global){
'use strict';

const $ = require('../spotify-elements');
const live = require('../live');
const selection = require('./selection');
const wrappedUriUtils = require('../live-wrapped-uri');
const cosmos = require('spotify-cosmos-api');
const liburi = require('spotify-liburi');

// getMetadataForUris can be set by the app.
let getMetadataForUris;

const CONTEXTMENU = ['a[data-uri]', '[data-contextmenu]'].join(',');

const makeContextMenuData = function (selectionContexts, primaryIndex, uris, x, y) {
  const contexts = [];

  selectionContexts.forEach(selectionContext => {
    if (selectionContext !== undefined) {
      const keys = selectionContext.keys || [];
      const indices = selectionContext.indices || [];
      let newPrimaryIndex = primaryIndex || indices[0];
      newPrimaryIndex = newPrimaryIndex === undefined ? null : newPrimaryIndex;

      const contextUri = selectionContext.uri;

      const contextData = {
        uri: contextUri,
        keys: keys,
        indices: indices,
        primaryIndex: newPrimaryIndex
      };

      const origin = selectionContext.origin;
      if (origin) {
        if (newPrimaryIndex !== null) {
          const wrappedList = live(contextUri).get('rows');
          const originList = live(origin.uri).get('rows');
          if (wrappedList && originList) {
            const key = wrappedList.keys[newPrimaryIndex];
            origin.primaryIndex = originList.indexOf(key);
          }
        }
        contextData.origin = origin;
      }
      contexts.push(contextData);
    }
  });
  return {
    contexts: contexts,
    x: x,
    y: y,
    uris: uris
  };
};

const handleContextMenuActiveClass = function (node) {
  const subscribedParentNodes = node.parents('[data-contextmenu-spy]');
  const collection = $([node, subscribedParentNodes]);
  collection.addClass('contextmenu-active');

  // when a user right clicks while a context menu is already open,
  // there's a race condition because of the delay in the cosmos message.
  // the second right click both adds and then removes the active class
  // on the new target
  // right click -> post message -> addClass -> subscribe -> receive message -> removeClass
  // this can be avoided by pushing the subscription on the event loop
  // so that it happens after the message is received.
  // right click -> post message -> addClass -> receive message -> subscribe
  // doesn't work in the case of right click on the same target twice
  setTimeout(() => {
    const sub = cosmos.resolver.subscribe({
      url: 'sp://messages/v1/context_menu_state'
    }, function (error, response) {
      if (!error && response.getJSONBody().state === 'hide') {
        collection.removeClass('contextmenu-active');
        sub.cancel();
      }
    });
  }, 0);
};

const showContextMenu = function (data) {
  const appUri = global.__spotify.app_uri;
  const isCollectionApp = liburi.from(appUri).id === 'collection';
  data.appURI = appUri;

  // State is not set for neither zlink or buddy-list so we need to check
  // if it exists before getting URI
  data.entityURI = live('spotify:application').get('state') ? live('spotify:application').get('state').getURI() : null;

  // Rewrite collection-(album|artist) to vanilla counterparts.
  data.uris = data.uris.map(uri => {
    const uriObject = liburi.from(uri);
    if (uriObject) {
      if (uriObject.type === liburi.Type.COLLECTION_ALBUM) {
        return liburi.albumURI(uriObject.id).toURI();
      } else if (uriObject.type === liburi.Type.COLLECTION_ARTIST) {
        return liburi.artistURI(uriObject.id).toURI();
      }
    }
    return uri;
  });

  // If getMetadataForUris is set by the app, call it with uris to get metadata.
  if (getMetadataForUris) {
    getMetadataForUris(data.uris, response => {
      data.metadata = response;
      const client = live('spotify:client');
      client.emit('show-context-menu', data);
    });
  } else {
    data.metadata = [];
    data.uris.forEach(uri => {
      // The "Save to Your Library"/"Remove from Your Library" menu item needs to
      // know the "added" state of the items to be able to show the correct string.
      // The collection app doesn't use live to handle the collection state, but it
      // can safely be assumed that what's in the collection app, is in collection.
      const added = isCollectionApp ? true : live(uri).get('added');
      if (added !== undefined) {
        data.metadata.push({
          uri: uri,
          added
        });
      }
    });

    const client = live('spotify:client');
    client.emit('show-context-menu', data);
  }
};

const handleContextMenuEvent = function (event, node) {
  event.preventDefault();
  event.stopPropagation();

  const x = event.clientX;
  const y = event.clientY;

  handleContextMenuActiveClass(node);

  if (node[0].tagName.toLowerCase() === 'a') {
    const uri = node.data('uri');
    if (uri) {
      showContextMenu({
        uris: [uri],
        x: x,
        y: y
      });
    }
  } else {
    const contextNode = node.parent('[data-list]');

    const index = +node.data('index');

    let isSelected = false;
    const indices = selection.getIndicesPerList();

    if (contextNode) {
      isSelected = selection.isNodeSelected(node);

      if (!isSelected) {
        selection.clear();
        const contextURI = contextNode.getAttribute('data-uri');
        if (contextURI) {
          selection.add(contextURI, index);
        }
      }
    }
    const uris = isSelected ? selection.getUris() : [node.data('uri')];
    showContextMenu(makeContextMenuData(indices, index, uris, x, y));
  }
};

const handleContextMenuButton = function (event, node) {
  let parent;
  let uri = node.data('uri') || (parent = node.parent('[data-uri]')) && parent.data('uri');
  if (!uri) return;

  // The context menu can't know what to offer for a custom list.
  // In case of a sorted and/or filtered list, pass the origin list.
  uri = wrappedUriUtils.getOriginUri(uri) || uri;

  const contextURI = (parent = node.parent('[data-list][data-uri]')) && parent.data('uri');
  const contextIndex = (parent = node.parent('[data-index]')) && +parent.data('index');

  const contextMenuNode = $(node[0].closest('[data-button="contextmenu"]'));
  const relativeTo = contextMenuNode || parent || node;

  const rect = relativeTo[0].getBoundingClientRect();
  let x = rect.left + rect.width / 2;
  let y = rect.top + rect.height;

  // The coordinate must be within the app viewport
  if (y > window.innerHeight) y = window.innerHeight - 1;
  if (x > window.innerWidth) x = window.innerWidth - 1;

  const indices = contextIndex === null || contextIndex === undefined ? null : [contextIndex];

  let context;
  if (contextURI) {
    context = {
      uri: contextURI
    };

    if (indices) {
      context.indices = indices;

      const liveList = live(contextURI).get('rows');
      context.keys = liveList ? indices.map(function (selectedIndex) {
        return liveList.keys[selectedIndex];
      }) : [];
    }

    // Add originList
    const origin = wrappedUriUtils.getOriginUri(contextURI);
    if (origin) {
      context.origin = {
        uri: origin
      };

      if (indices) {
        const wrappedList = live(contextURI).get('rows');
        const originList = live(origin).get('rows');
        if (wrappedList && originList) {
          const originIndices = indices.map(function (index) {
            const key = wrappedList.keys[index];
            return originList.indexOf(key);
          });
          const originKeys = indices.map(function (index) {
            return wrappedList.keys[index];
          });
          context.origin.indices = originIndices;
          context.origin.keys = originKeys;
        }
      }
    }
  }
  showContextMenu(makeContextMenuData([context], contextIndex, [uri], x, y));
  handleContextMenuActiveClass(contextMenuNode);
};

let isAttached = false;

exports.attach = function attach() {
  if (isAttached) return;
  isAttached = true;

  $(document).delegate('contextmenu', CONTEXTMENU, handleContextMenuEvent);
  $(document).delegate('click', '[data-button=contextmenu]', handleContextMenuButton);
};

exports.detach = function detach() {
  if (!isAttached) return;
  isAttached = false;

  $(document).undelegate('contextmenu', CONTEXTMENU, handleContextMenuEvent);
  $(document).undelegate('click', '[data-button=contextmenu]', handleContextMenuButton);
};

exports.update = function () {};
exports.setMetadataRequestFunction = (func = null) => {
  getMetadataForUris = func;
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../live":210,"../live-wrapped-uri":209,"../spotify-elements":251,"./selection":319,"spotify-cosmos-api":720,"spotify-liburi":730}],264:[function(require,module,exports){
/**
 * @module spotify-events/dragndrop/custom/queue
 * @private
 */
'use strict';

const hooks = require('../util/hooks');
const QUEUE_URI = 'spotify:internal:queue:future';

/**
 * Hook handler for validating a list target.
 *
 * @param {Object} result Result object. Setting the `valid` property will
 *     affect whether the drop is allowed.
 * @param {HTMLElement} list A DOM node marked up as a list.
 */
function onListDropValidation(result, event, list, location, index) {
  const contextUri = list.getAttribute('data-uri');
  if (!contextUri || contextUri !== QUEUE_URI) return;

  // The "current" track in the queue is marked up as index -1. Disallow
  // dragging anything to that spot.
  if (index === -1) {
    result.valid = false;
    return;
  }
}

/**
 * Attach the module.
 */
function attach() {
  hooks.add('list-drop-validation', onListDropValidation);
}

/**
 * Detach the module.
 */
function detach() {
  hooks.remove('list-drop-validation', onListDropValidation);
}

exports.attach = attach;
exports.detach = detach;

},{"../util/hooks":273}],265:[function(require,module,exports){
/**
 * @module spotify-events/dragndrop/custom/rootlist
 * @private
 */
'use strict';

const $ = require('../../../spotify-elements');

const liburi = require('spotify-liburi');
const live = require('../../../live');
const intersection = require('mout/array/intersection');

const hooks = require('../util/hooks');
const eventModel = require('../util/eventmodel');
const selection = require('../../selection');

const SELECTOR_LIST = '[data-list]';
const SELECTOR_LIST_ITEM = '[data-list-item]';
const SELECTOR_DRAGGABLE = 'a, [draggable]';
const ATTR_TARGET = 'data-drop-target';

let dragFolderElement = null;

/**
 * Handler for the dragstart event.
 */
function onDragStart(event, node) {
  // Don't handle items that are specified with the new implementation.
  if (node.closest('[data-glue-draggable]')) {
    return;
  }

  dragFolderElement = null;

  const uris = selection.getUris();
  if (uris.length > 1) return;

  const uri = uris[0];
  const uriObject = uri && liburi.fromString(uri);
  if (!uriObject) return;

  // If dragging a folder, we need to temporarily save the folder DOM node,
  // so that while dragging over items we can check whether to show the drop
  // indicator. Dropping a folder inside itself should not be allowed.
  if (uriObject.type === liburi.Type.FOLDER) {
    const selectedNodes = selection.getNodes();
    for (let i = 0, l = selectedNodes.length; i < l; i++) {
      const selectedNode = selectedNodes[i];
      if (selectedNode.getAttribute('data-uri') === uri) {
        dragFolderElement = selectedNode;
        break;
      }
    }
  }
}

/**
 * Handler for ending a drag.
 */
function onDragEnd() {
  dragFolderElement = null;
}

/**
 * Hook handler for setting drag data.
 *
 * @param {MouseEvent} event Event object for a dragstart event.
 * @param {Array.<string>} uris Array of URIs being dragged.
 * @param {string=} optContext Optional context URI.
 */
function onSetDragData(event, uris, optContext) {
  if (optContext !== 'spotify:rootlist') {
    let followedPlaylistCount = 0;
    for (let i = 0, l = uris.length; i < l; i++) {
      const uriObject = liburi.from(uris[i]);
      const type = uriObject && uriObject.type;
      if (type === liburi.Type.PLAYLIST) {
        const isFollowing = live(uris[i]).get('added');
        if (isFollowing) followedPlaylistCount++;
      } else {
        // If the item is not a playlist, it means we are dragging either only
        // items of another type, or playlists as well as other types.
        break;
      }
    }

    // Dropping only playlists that you are following in the rootlist should
    // not be allowed. If multiple playlists are dragged and some of them are
    // not being followed, dropping is allowed (and the receiver should handle
    // only inserting the new ones). To allow telling these cases apart while
    // not having access to drag data, we set a special MIME type that can be
    // checked later.
    if (followedPlaylistCount === uris.length) {
      event.dataTransfer.setData('text/x-spotify-only-followed-playlists', '');
    }
  }
}

/**
 * Hook handler for validating a list drop.
 *
 * @param {Object} result Result object. Setting the `valid` property will
 *     affect whether the drop is allowed.
 * @param {MouseEvent} event Some kind of drag and drop event.
 * @param {HTMLElement} list A DOM node marked up as a list.
 * @param {string} location The location of the cursor in relation to the list.
 *     This can be either 'inside' or 'below'. The value 'below' means that the
 *     cursor was below the last list found in the DOM.
 */
function onListDropValidation(result, event, list, location) {
  const contextUri = list.getAttribute('data-uri');
  if (contextUri === 'spotify:rootlist') {
    // Dropping only already followed playlists into the rootlist should not
    // be allowed, since you can only have playlists once in the rootlist.
    if (hasOnlyFollowedPlaylists(event)) {
      result.valid = false;
      return;
    }

    // Dropping a folder inside or right below itself should not be allowed
    if (isInsideDraggedFolder(event, location)) {
      result.valid = false;
      return;
    }

    // Dropping on the bottom half of a folder should not be allowed as a list
    // target, but will be a regular target for the folder instead. However, if
    // the dragged items match the list target, dropping should be handled by
    // list code instead of target code (dragover should still not validate as
    // we want the active drop target style and not the list indicator).
    if (isInFolderBottomHalf(event)) {
      if (event.type !== 'drop' || !isMatchingTarget(event, list)) {
        result.valid = false;
        return;
      }
    }
  }
}

/**
 * Hook handler for validating a target.
 *
 * @param {Object} result Result object. Setting the `valid` property will
 *     affect whether the drop is allowed.
 * @param {MouseEvent} event Some kind of drag and drop event.
 * @param {HTMLElement} target DOM node for target that matches MIME types.
 */
function onTargetValidation(result, event, target) {
  const list = target.closest(SELECTOR_LIST);
  if (list) {
    const contextUri = list.getAttribute('data-uri');
    if (contextUri === 'spotify:rootlist') {
      // Dropping only already followed playlists into the rootlist should not
      // be allowed, since you can only have playlists once in the rootlist.
      if (hasOnlyFollowedPlaylists(event)) {
        result.valid = false;
        return;
      }

      // Dropping valid rootlist items on the top half of a folder should not
      // be allowed as a regular target, but will be a list drop target instead.
      // For leave events, we need to validate the whole row as valid, so that
      // the target styling is removed correctly.
      if (event.type !== 'dragleave' && isMatchingTarget(event, list)) {
        const folderNode = getFolderNode(event);
        if (folderNode) {
          if (isBelowMiddleOfNode(event.clientY, folderNode)) {
            result.valid = true;
          } else {
            result.valid = false;
          }
          return;
        }
      }
    }
  }
}

/**
 * Hook handler for getting the indices being moved.
 *
 * @param {string} contextUri The context URI.
 * @param {LiveList} liveList Live list to be changed.
 * @param {Array.<number>} indices Array of indices in the list.
 */
function onGetMoveIndices(contextUri, liveList, indices) {
  if (contextUri === 'spotify:rootlist') {
    const firstIndex = indices[0];
    const firstRow = liveList.get(firstIndex);
    const firstItem = firstRow && firstRow.get('playlist');
    const firstUri = firstItem && firstItem.uri;
    const firstUriType = firstUri && liburi.fromString(firstUri).type;
    const isFolder = firstUriType === liburi.Type.FOLDER;

    if (isFolder) {
      // Add all indices for the folder contents and the end marker
      if (indices.length === 1) {
        const length = getFolderLength(liveList, firstUri, firstIndex);
        for (let i = 1; i <= length; i++) {
          indices.push(firstIndex + i);
        }
      }

      // Abort the move operation if it only contains moving a folder start
      // marker, since moving folders should always move the entire folder.
      // Aborting by returning zero indices.
      if (indices.length === 1) {
        indices.length = 0;
        return;
      }

      const lastRow = liveList.get(indices[indices.length - 1]);
      const lastItem = lastRow && lastRow.get('playlist');
      const lastUri = lastItem && lastItem.uri;

      // Abort the move operation if moving a folder and the last item to move
      // is not the end marker for the folder. Aborting by returning zero
      // indices.
      if (lastUri !== `${firstUri}:end`) {
        indices.length = 0;
        return;
      }
    }
  }
}

/**
 * Check if only dragging playlists that are being followed already.
 *
 * @param {MouseEvent} event Some kind of drag and drop event.
 *
 * @return {boolean} True if only followed playlists are being dragged.
 */
function hasOnlyFollowedPlaylists(event) {
  const types = event.dataTransfer.types;
  if (types.indexOf('text/x-spotify-only-followed-playlists') > -1) {
    return true;
  }

  return false;
}

/**
 * Check if dragging a folder into (or below) itself.
 *
 * @param {MouseEvent} event Some kind of drag and drop event.
 * @param {string} location The location of the cursor in relation to the list.
 *     This can be either 'inside' or 'below'. The value 'below' means that the
 *     cursor was below the last list found in the DOM.
 *
 * @return {boolean} True if dragging into the same folder being dragged.
 */
function isInsideDraggedFolder(event, location) {
  if (dragFolderElement) {
    const rowNode = location === 'below' ? getLastRowNode() : getRowNode(event);
    if (rowNode) {
      let targetIndex = +rowNode.getAttribute('data-index');
      if (location === 'inside') {
        if (!isBelowMiddleOfNode(event.clientY, rowNode)) {
          targetIndex--;
        }
      }
      if (isIndexInsideDraggedFolder(targetIndex)) {
        return true;
      }
    }
  }

  return false;
}

/**
 * Check if dragging onto the bottom half of a folder.
 *
 * @param {MouseEvent} event Some kind of drag and drop event.
 *
 * @return {boolean} True if dragging onto the bottom half.
 */
function isInFolderBottomHalf(event) {
  const folderNode = getFolderNode(event);
  if (folderNode) {
    return isBelowMiddleOfNode(event.clientY, folderNode);
  }
  return false;
}

/**
 * Check if the position is below the middle of the node.
 *
 * @param {number} y The Y position relative to the viewport.
 * @param {HTMLElement} node DOM node to check against.
 *
 * @return {boolean} True if the position is below.
 */
function isBelowMiddleOfNode(y, node) {
  const rect = node.getBoundingClientRect();
  return y >= rect.top + rect.height / 2;
}

/**
 * Check if the index is inside (or right below) the folder being dragged.
 *
 * @param {number} index Current target index.
 *
 * @return {boolean} True if the target index is inside the folder.
 */
function isIndexInsideDraggedFolder(index) {
  if (!dragFolderElement) return false;

  const liveList = live('spotify:rootlist').get('rows');
  if (!liveList) return false;

  const folderUri = dragFolderElement.getAttribute('data-uri');
  if (!folderUri) return false;

  const start = +dragFolderElement.getAttribute('data-index');
  const end = start + getFolderLength(liveList, folderUri, start);

  if (start > -1 && end > start && index >= start && index <= end) {
    return true;
  }

  return false;
}

/**
 * Check if the MIME types in the drag event matches the MIME types for the
 * specified drop target.
 *
 * @param {MouseEvent} event Some kind of drag and drop event.
 * @param {HTMLElement} node A DOM node.
 *
 * @return {boolean} True if the element matches the event.
 */
function isMatchingTarget(event, node) {
  const eventTypes = event.dataTransfer.types;
  const nodeTypes = node.getAttribute(ATTR_TARGET);

  if (nodeTypes) {
    const matching = intersection(nodeTypes.split('|'), eventTypes);
    if (matching.length > 0) return true;
  }

  return false;
}

/**
 * Get the folder row node from the event.
 *
 * @param {MouseEvent} event Some kind of drag and drop event.
 *
 * @return {HTMLElement?} DOM node for the folder, or null if not found.
 */
function getFolderNode(event) {
  const rowNode = getRowNode(event);
  if (rowNode) {
    const uri = rowNode.getAttribute('data-uri');
    const uriObject = liburi.from(uri);
    if (uriObject && uriObject.type === liburi.Type.FOLDER) {
      return rowNode;
    }
  }

  return null;
}

/**
 * Get the list row element from the event target.
 * If the event target itself isn't a list row, it will step out in the parent
 * tree until it finds a row.
 *
 * @param {MouseEvent} event Some kind of drag and drop event.
 *
 * @return {HTMLElement?} The list row element, or null if not found.
 */
function getRowNode(event) {
  return event.target.closest(SELECTOR_LIST_ITEM);
}

/**
 * Get the last list row from the last list in the DOM.
 *
 * @return {HTMLElement?} The list row element, or null if not found.
 */
function getLastRowNode() {
  const lists = $(SELECTOR_LIST);
  const lastList = lists && lists[lists.length - 1];
  if (lastList) {
    const listItems = $(lastList).search(SELECTOR_LIST_ITEM);
    const lastItem = listItems && listItems[listItems.length - 1];
    if (lastItem) return lastItem;
  }

  return null;
}

/**
 * Get the length of a folder, including the contents and end marker, but not
 * the start marker.
 *
 * @param {LiveList} liveList Live list for the rootlist.
 * @param {string} folderUri The folder URI.
 * @param {number} index The index where the folder start marker is.
 *
 * @return {number} The length of the folder.
 */
function getFolderLength(liveList, folderUri, index) {
  let rowAtIndex = liveList.get(index);
  let itemAtIndex = rowAtIndex && rowAtIndex.get('playlist');
  let uriAtIndex = itemAtIndex && itemAtIndex.uri;
  if (uriAtIndex !== folderUri) return 0;

  const folderEndUri = `${folderUri}:end`;
  let amount = 0;

  for (let i = index + 1, l = liveList.length; i < l; i++) {
    amount++;

    rowAtIndex = liveList.get(i);
    itemAtIndex = rowAtIndex && rowAtIndex.get('playlist');
    uriAtIndex = itemAtIndex && itemAtIndex.uri;
    if (uriAtIndex === folderEndUri) break;
  }

  return amount;
}

/**
 * Attach the module.
 */
function attach() {
  eventModel.delegate('dragstart', SELECTOR_DRAGGABLE, onDragStart);
  eventModel.delegate('dragend', 'body', onDragEnd);

  hooks.add('set-drag-data', onSetDragData);
  hooks.add('list-drop-validation', onListDropValidation);
  hooks.add('target-validation', onTargetValidation);
  hooks.add('get-move-indices', onGetMoveIndices);
}

/**
 * Detach the module.
 */
function detach() {
  eventModel.undelegate('dragstart', SELECTOR_DRAGGABLE, onDragStart);
  eventModel.undelegate('dragend', 'body', onDragEnd);

  hooks.remove('set-drag-data', onSetDragData);
  hooks.remove('list-drop-validation', onListDropValidation);
  hooks.remove('target-validation', onTargetValidation);
  hooks.remove('get-move-indices', onGetMoveIndices);
}

exports.attach = attach;
exports.detach = detach;

},{"../../../live":210,"../../../spotify-elements":251,"../../selection":319,"../util/eventmodel":272,"../util/hooks":273,"mout/array/intersection":450,"spotify-liburi":730}],266:[function(require,module,exports){
/**
 * @module spotify-events/dragndrop/custom/sortlist
 * @private
 */
'use strict';

const liburi = require('spotify-liburi');
const sortUriUtils = require('../../../live-sort-uri');

const hooks = require('../util/hooks');
const eventModel = require('../util/eventmodel');
const selection = require('../../selection');

const SELECTOR_DRAGGABLE = 'a, [draggable]';

let dragSelectionState = null;

/**
 * Handler for the dragstart event.
 */
function onDragStart(event, node) {
  // Don't handle items that are specified with the new implementation.
  if (node.closest('[data-glue-draggable]')) {
    return;
  }

  dragSelectionState = selection.getIndicesPerList();
}

/**
 * Handler for ending a drag.
 */
function onDragEnd() {
  dragSelectionState = null;
}

/**
 * Hook handler for validating a list drop.
 *
 * @param {Object} result Result object. Setting the `valid` property will
 *     affect whether the drop is allowed.
 * @param {MouseEvent} event Some kind of drag and drop event.
 * @param {HTMLElement} list A DOM node marked up as a list.
 */
function onListDropValidation(result, event, list) {
  const contextUri = list.getAttribute('data-uri');
  if (!contextUri) return;

  // Dropping in sorted lists should not allow specific drop positions,
  if (sortUriUtils.isValid(contextUri) && event.type !== 'drop') {
    result.valid = false;
  }
}

/**
 * Hook handler for validating a list target.
 *
 * @param {Object} result Result object. Setting the `valid` property will
 *     affect whether the drop is allowed.
 * @param {HTMLElement} list A DOM node marked up as a list.
 */
function onListTargetValidation(result, list) {
  const contextUri = list.getAttribute('data-uri');
  if (!contextUri) return;

  // Bail on all invalid uris
  if (!sortUriUtils.isValid(contextUri)) return;

  // We should support incoming drag and drops as well, like from the
  // now playing view for example
  if (!dragSelectionState) {
    result.valid = true;
    return;
  }

  // Dropping in sorted lists should be allowed as a regular target
  if (dragSelectionState.length === 1) {
    if (dragSelectionState[0].uri !== contextUri) {
      result.valid = true;
    }
  }
}

/**
 * Hook handler for checking if a list is a track list.
 *
 * @param {Object} result Result object. Setting the `valid` property will
 *     affect the result.
 * @param {LiveList} liveList The live list.
 * @param {string} contextUri The context URI.
 */
function onIsListOfTracks(result, liveList, contextUri) {
  if (sortUriUtils.isValid(contextUri)) {
    const originUri = sortUriUtils.getOriginUri(contextUri);
    if (originUri) {
      const uriObject = liburi.from(originUri);
      const type = uriObject && uriObject.type;
      if (type === liburi.Type.PLAYLIST) {
        result.valid = true;
      }
    }
  }
}

/**
 * Attach the module.
 */
function attach() {
  eventModel.delegate('dragstart', SELECTOR_DRAGGABLE, onDragStart);
  eventModel.delegate('dragend', 'body', onDragEnd);

  hooks.add('list-drop-validation', onListDropValidation);
  hooks.add('list-target-validation', onListTargetValidation);
  hooks.add('is-list-of-tracks', onIsListOfTracks);
}

/**
 * Detach the module.
 */
function detach() {
  eventModel.undelegate('dragstart', SELECTOR_DRAGGABLE, onDragStart);
  eventModel.undelegate('dragend', 'body', onDragEnd);

  hooks.remove('list-drop-validation', onListDropValidation);
  hooks.remove('list-target-validation', onListTargetValidation);
  hooks.remove('is-list-of-tracks', onIsListOfTracks);
}

exports.attach = attach;
exports.detach = detach;

},{"../../../live-sort-uri":208,"../../selection":319,"../util/eventmodel":272,"../util/hooks":273,"spotify-liburi":730}],267:[function(require,module,exports){
(function (global){
/**
 * @module spotify-events/dragndrop/dragdata
 * @private
 */
'use strict';

const liburi = require('spotify-liburi');

const selection = require('../selection');
const hooks = require('./util/hooks');
const eventModel = require('./util/eventmodel');
const itemText = require('./util/itemtext');
const getLogContext = require('../util/get-log-context');

const SELECTOR_DRAGGABLE = 'a, [draggable]';

/**
 * Handler for the dragstart event.
 *
 * @param {MouseEvent} event Event object for a dragstart event.
 * @param {HTMLElement} target The target element.
 */
function onDragStart(event, target) {
  // Don't handle items that are specified with the new implementation.
  if (target.closest('[data-glue-draggable]')) {
    return;
  }

  const isSelected = selection.isNodeSelected(target);

  if (isSelected) {
    const uris = selection.getUris();
    if (uris.length > 0) {
      const state = selection.getIndicesPerList();
      const singleContext = state.length === 1;
      const context = singleContext ? state[0] && state[0].uri : null;
      if (context) {
        setEventData(event, uris, null, context, getLogContext(target));
      } else {
        setEventData(event, uris, null, null, getLogContext(target));
      }
    }
  } else {
    let uri = target.getAttribute('data-uri');
    if (!uri) {
      const uriObject = liburi.from(target.getAttribute('href'));
      uri = uriObject ? uriObject.toURI() : '';
    }
    const dragText = itemText.getForElement(target);

    if (uri) {
      setEventData(event, [uri], [dragText], null, getLogContext(target));
    }
  }
}

/**
 * Set drag data on the event.
 * This includes regular MIME types such as plain text and html, but also custom
 * Spotify MIME types that can be used to detect the dragged content while
 * dragging (you can't access data while dragging, so there is no other way
 * to detect what kind of items are being dragged).
 *
 * @param {MouseEvent} event Event object for a dragstart event.
 * @param {Array.<string>} uris Array of Spotify URIs.
 * @param {Array.<string>=} optDragTexts Optional drag texts for each URI.
 * @param {string=} optContext Optional context URI.
 * @param {string=} optLogContext Optional log context.
 */
function setEventData(event, uris, optDragTexts, optContext, optLogContext) {
  const urlsPerMimeType = getUrlsPerMimeType(uris);
  const urls = getUrlsForUris(uris);
  const urlList = urls.join('\n');
  const html = getLinkHTML(uris, urls, optDragTexts);

  // We set this before others because safari overrides any data that was set
  // before this particular mimetype was set.
  event.dataTransfer.setData('text/uri-list', urlList);

  for (const type in urlsPerMimeType) {
    if (!urlsPerMimeType.hasOwnProperty(type)) continue;
    const urlsForType = urlsPerMimeType[type];
    event.dataTransfer.setData(type, urlsForType.join('\n'));
  }

  event.dataTransfer.setData('text/plain', urlList);
  event.dataTransfer.setData('text/html', html);

  if (optContext) {
    // Provide the context as drag data. This can be used in the drop event to
    // know where it came from.
    event.dataTransfer.setData('text/x-spotify-data-context', optContext);
  }

  if (optLogContext) {
    event.dataTransfer.setData('text/x-spotify-data-log-context', optLogContext);
  }

  event.dataTransfer.setData('text/x-spotify-data-app-uri', global.__spotify && global.__spotify.app_uri || null);

  hooks.run('set-drag-data', event, uris, optContext);
}

/**
 * Get URLs for the URIs organized by MIME type.
 *
 * @param  {Array.<string>} uris Array of Spotify URIs.
 *
 * @return {Object.<string, Array.<string>>} Object of arrays of URLs.
 */
function getUrlsPerMimeType(uris) {
  const urlsPerMimeType = {};
  for (let i = 0, l = uris.length; i < l; i++) {
    const uri = uris[i];
    const type = getMimeType(uri);
    const urlsForType = urlsPerMimeType[type] || (urlsPerMimeType[type] = []);
    urlsForType.push(getShareLink(uri));
  }
  return urlsPerMimeType;
}

/**
 * Get URLs for the URIs.
 *
 * @param {Array.<string>} uris Array of Spotify URIs.
 *
 * @return {Array.<string>} Array of share URLs.
 */
function getUrlsForUris(uris) {
  const urls = new Array(uris.length);
  for (let i = 0, l = uris.length; i < l; i++) {
    urls[i] = getShareLink(uris[i]);
  }
  return urls;
}

/**
 * Get a share URL from a Spotify URI.
 *
 * @param {string} uri A Spotify URI.
 *
 * @return {string} The share URL.
 */
function getShareLink(uri) {
  const uriObject = liburi.from(uri);
  return uriObject ? uriObject.toOpenURL() : uri;
}

/**
 * Get the custom Spotify MIME type for a URI.
 *
 * @param {string} uri A Spotify URI.
 *
 * @return {string} The MIME type.
 */
function getMimeType(uri) {
  const type = 'text/x-spotify-';

  const uriObject = liburi.from(uri);
  if (uriObject) {
    const uriType = uriObject.type;

    if (uriType === liburi.Type.TRACK || uriType === liburi.Type.LOCAL) {
      return `${type}tracks`;
    }
    if (uriType === liburi.Type.ALBUM || uriType === liburi.Type.LOCAL_ALBUM) {
      return `${type}albums`;
    }
    if (uriType === liburi.Type.ARTIST || uriType === liburi.Type.LOCAL_ARTIST) {
      return `${type}artists`;
    }
    if (uriType === liburi.Type.USER || uriType === liburi.Type.PROFILE) {
      return `${type}users`;
    }
    if (uriType === liburi.Type.PLAYLIST) {
      return `${type}playlists`;
    }
    if (uriType === liburi.Type.FOLDER) {
      return `${type}folders`;
    }
    if (uriType === liburi.Type.STATION && !(uriObject.args.length > 2 && uriObject.args[2] === 'cluster')) {
      return `${type}stations`;
    }
    if (uriType === liburi.Type.EPISODE) {
      return `${type}episodes`;
    }
  }

  return `${type}unknown`;
}

/**
 * Get the HTML for links to the given URLs.
 *
 * @param {Array.<string>} uris Array of Spotify URIs.
 * @param {Array.<string>} urls Array of Spotify URLs used for sharing.
 * @param {Array.<string>=} optDragTexts Optional drag texts for each URI.
 *
 * @return {string} String of HTML.
 */
function getLinkHTML(uris, urls, optDragTexts) {
  let html = '';

  for (let i = 0, l = uris.length; i < l; i++) {
    const textFromArgs = optDragTexts && optDragTexts[i];
    const text = textFromArgs || itemText.getForUri(uris[i]);

    html += `<a href="${urls[i]}">${text}</a>`;

    if (i < uris.length - 1) {
      html += '<br>';
    }
  }

  return html;
}

/**
 * Attach the module.
 */
function attach() {
  eventModel.delegate('dragstart', SELECTOR_DRAGGABLE, onDragStart);
}

/**
 * Detach the module.
 */
function detach() {
  eventModel.undelegate('dragstart', SELECTOR_DRAGGABLE, onDragStart);
}

exports.attach = attach;
exports.detach = detach;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../selection":319,"../util/get-log-context":333,"./util/eventmodel":272,"./util/hooks":273,"./util/itemtext":274,"spotify-liburi":730}],268:[function(require,module,exports){
/**
 * @module spotify-events/dragndrop/dragimage
 * @private
 */
'use strict';

const liburi = require('spotify-liburi');
const defer = require('../../../libs/prime/defer');

const selection = require('../selection');
const eventModel = require('./util/eventmodel');
const itemText = require('./util/itemtext');

const i18n = require('../i18n/index');

const SELECTOR_DRAGGABLE = 'a, [draggable]';
const DRAGIMAGE_POS_X = -10;
const DRAGIMAGE_POS_Y = -5;

let dragImageElement = null;
let dragImageShelter = null;

/**
 * Handler for the dragstart event.
 *
 * @param {MouseEvent} event Event object for a dragstart event.
 * @param {HTMLElement} target The target element.
 */
function onDragStart(event, target) {
  // Don't handle items that are specified with the new implementation.
  if (target.closest('[data-glue-draggable]')) {
    return;
  }

  const isSelected = selection.isNodeSelected(target);

  let text = '';

  if (isSelected) {
    const uris = selection.getUris();
    if (uris.length === 1) {
      text = itemText.getForUri(uris[0]);
    } else {
      text = getLocalizedTypeFromUris(uris);
    }
  } else {
    text = itemText.getForElement(target);
  }

  const dragImage = getDragImage(text);

  event.dataTransfer.setDragImage(dragImage, DRAGIMAGE_POS_X, DRAGIMAGE_POS_Y);

  removeDragImage();
}

/**
 * Get the drag image element with the specified text set.
 *
 * @param {string} text The text to set.
 *
 * @return {HTMLElement} The drag image element.
 */
function getDragImage(text) {
  if (!dragImageElement) {
    dragImageElement = document.createElement('div');
    dragImageElement.className = 'dnd-image';
  }
  if (!dragImageShelter) {
    dragImageShelter = document.createElement('div');
    dragImageShelter.className = 'dnd-image-shelter';
  }

  dragImageElement.textContent = text;

  document.body.appendChild(dragImageElement);
  document.body.appendChild(dragImageShelter);

  return dragImageElement;
}

/**
 * Remove the drag image element and the shelter it hides behind.
 * This must be delayed a tick to let the native drag and drop handling
 * get the time to read the image.
 */
function removeDragImage() {
  defer.immediate(function () {
    if (dragImageElement && dragImageElement.parentNode) {
      dragImageElement.parentNode.removeChild(dragImageElement);
    }
    if (dragImageShelter && dragImageShelter.parentNode) {
      dragImageShelter.parentNode.removeChild(dragImageShelter);
    }
  });
}

/**
 * Get a localized type for a list of URIs.
 * This could be for example 'tracks', 'playlists' etc. Falls back to 'items'
 * if the URIs are of different type. As this is only called when we drag
 * multiple items, we don't need the singular form.
 *
 * @param {Array.<string>} uris Array of URIs.
 *
 * @return {string} The localized type.
 */
function getLocalizedTypeFromUris(uris) {
  let type = 'item';

  const uriObjectForFirst = liburi.from(uris[0]);
  const typeForFirst = uriObjectForFirst && uriObjectForFirst.type;

  if (typeForFirst) {
    type = typeForFirst;

    for (let i = 0, l = uris.length; i < l; i++) {
      const uriObject = liburi.from(uris[i]);
      if (!uriObject || uriObject.type !== typeForFirst) {
        type = 'item';
        break;
      }
    }
  }

  // User URIs are parsed with type 'profile' in liburi, but we want 'user'
  if (type === 'profile') {
    type = 'user';
  }

  const pluralType = `${type}s`;

  // Get the localized version of the plural type
  let localized = i18n.get(`drag_tooltip_many_${pluralType}`, uris.length);

  // If the type was not the generic 'items' type and no localization was found,
  // localize the generic type.
  if (localized === `drag_tooltip_many_${pluralType}` && pluralType !== 'items') {
    localized = i18n.get('drag_tooltip_many_items', uris.length);
  }

  // Return the localized type, or if nothing is found, fall back to the type
  return localized || pluralType;
}

/**
 * Attach the module.
 */
function attach() {
  eventModel.delegate('dragstart', SELECTOR_DRAGGABLE, onDragStart);
}

/**
 * Detach the module.
 */
function detach() {
  eventModel.undelegate('dragstart', SELECTOR_DRAGGABLE, onDragStart);
}

exports.attach = attach;
exports.detach = detach;

},{"../../../libs/prime/defer":241,"../i18n/index":278,"../selection":319,"./util/eventmodel":272,"./util/itemtext":274,"spotify-liburi":730}],269:[function(require,module,exports){
/**
 * @module spotify-events/dragndrop
 */
'use strict';

const dragDataModule = require('./dragdata');
const dragImageModule = require('./dragimage');
const targetModule = require('./target');
const listModule = require('./list');

// Custom behaviors
const sortlistModule = require('./custom/sortlist');
const rootlistModule = require('./custom/rootlist');
const queueModule = require('./custom/queue');

/**
 * Attach the module.
 */
function attach() {
  dragDataModule.attach();
  dragImageModule.attach();
  targetModule.attach();
  listModule.attach();
  queueModule.attach();

  sortlistModule.attach();
  rootlistModule.attach();
}

/**
 * Detach the module.
 */
function detach() {
  dragDataModule.detach();
  dragImageModule.detach();
  targetModule.detach();
  listModule.detach();
  queueModule.detach();

  sortlistModule.detach();
  rootlistModule.detach();
}

exports.attach = attach;
exports.detach = detach;
exports.update = function () {};

},{"./custom/queue":264,"./custom/rootlist":265,"./custom/sortlist":266,"./dragdata":267,"./dragimage":268,"./list":270,"./target":271}],270:[function(require,module,exports){
/**
 * @module spotify-events/dragndrop/list
 * @private
 */
'use strict';

const $ = require('../../spotify-elements');
const intersection = require('mout/array/intersection');
const Range = require('../../range2');
const live = require('../../live');
const liburi = require('spotify-liburi');
const listOperations = require('../../../libs/live-list-operations');

const hooks = require('./util/hooks');
const eventModel = require('./util/eventmodel');
const selection = require('../selection');

const SELECTOR_DROP_TARGET = '[data-drop-target]';
const SELECTOR_LIST = '[data-list]';
const SELECTOR_LIST_ITEM = '[data-list-item]';
const SELECTOR_LIST_TARGET = `${SELECTOR_DROP_TARGET}, body`;
const SELECTOR_DRAGGABLE = 'a, [draggable]';
const ATTR_TARGET = 'data-drop-target';

let dropIndicator = null;
let draggedLinkContext = null;
const disabledLists = {};

/**
 * Simple wrapper to cache calls to selection.getIndicesPerList()
 *
 * @return {Object} The result of selection.getIndicesPerList()
 */
const cachedSelectionState = function () {
  let cache = {
    lastTime: 0,
    lastValue: null
  };
  const CACHE_TIMEOUT = 500;

  return {
    get: function () {
      const now = Date.now();

      if (now - cache.lastTime > CACHE_TIMEOUT) {
        cache = {
          lastValue: selection.getIndicesPerList(),
          lastTime: now
        };
      }

      return cache.lastValue;
    },
    clear: function () {
      cache.lastTime = 0;
    }
  };
}();

/**
 * Handler for the dragstart event.
 *
 * @param {MouseEvent} event Event object for a dragstart event.
 * @param {HTMLElement} target The target element.
 */
function onDragStart(event, target) {
  // Don't handle items that are specified with the new implementation.
  if (target.closest('[data-glue-draggable]')) {
    return;
  }

  draggedLinkContext = null;

  // clear the selectionState cache
  cachedSelectionState.clear();

  const matchingTarget = getMatchingTarget(event);
  if (matchingTarget) {
    const isInList = $(matchingTarget).matches(SELECTOR_LIST);
    if (isInList) {
      const uri = matchingTarget.getAttribute('data-uri');

      // Dragging a link from inside a list needs to store the list context,
      // since it is not allowed to drop a dragged link inside the same list.
      if (target.tagName.toLowerCase() === 'a') {
        draggedLinkContext = uri;
      }

      // Dragging is disallowed for lists where we're waiting for a list move
      // to finish. This is to prevent multiple moves to be called before the
      // response from the first comes back.
      if (disabledLists[uri]) {
        event.preventDefault();
        return;
      }

      const rowNode = getRowNode(event);
      if (rowNode) {
        const index = getTargetIndex(event.clientY, rowNode);
        if (index !== -1) {
          event.dataTransfer.setData('text/x-spotify-data-log-source-index', index);
        }
      }
    }
  }
}

/**
 * Handler for dragging over a drop target.
 *
 * @param {MouseEvent} event A dragover event object.
 * @param {HTMLElement} target DOM element for the drop target. This can be the
 *     body element even if it's not a drop target.
 */
function onDragOver(event, target) {
  let positionedListDrop = false;
  let rowNode = null;

  const isBody = target === document.body;
  let list = null;
  if (isBody) list = getListTargetFromBody(event);else list = getMatchingListTarget(event);

  // If we found a list from the event, we must validate if it's allowed to drop
  // in the list.
  if (list) {
    const location = isBody ? 'below' : 'inside';

    let index = -1;
    rowNode = location === 'below' ? getLastRowFromLastList() : getRowNode(event);
    if (rowNode) {
      index = getTargetIndex(event.clientY, rowNode);
    }

    if (validateListDrop(event, list, location, index)) {
      if (isBody) {
        positionedListDrop = true;
      } else {
        if (rowNode) {
          positionedListDrop = true;
        }
      }
    }
  }

  if (positionedListDrop) {
    event.preventDefault();

    if (isBody) showDropIndicatorBelowList(list);else if (rowNode) showDropIndicatorForRow(rowNode, event.clientY);
  } else {
    hideDropIndicator();

    const listHookResult = { valid: false };
    if (list) {
      hooks.run('list-target-validation', listHookResult, list);
    }

    // The list might be accepted as a drop target even if dropping in a
    // specific position was not accepted. In that case we need to prevent the
    // default action to tell the browser that we accept drops here.
    if (listHookResult.valid) {
      event.preventDefault();
    } else if (!isBody && list) {
      const targetHookResult = { valid: false };
      hooks.run('target-validation', targetHookResult, event, target);

      // If we know that dropping is not allowed here at all, we need to remove
      // the drop effect from the cursor. This is mainly since the handler in
      // targets.js has already handled the event and accepted it, which sets
      // the drop effect.
      if (!targetHookResult.valid) {
        event.dataTransfer.dropEffect = 'none';
      }
    }
  }
}

/**
 * Handler for dragging out from a drop target.
 */
function onDragLeave() {
  hideDropIndicator();
}

/**
 * Handler for ending a drag.
 */
function onDragEnd() {
  hideDropIndicator();
  draggedLinkContext = null;
}

/**
 * Handler for dropping onto a drop target.
 *
 * @param {MouseEvent} event A drop event object.
 * @param {HTMLElement} target DOM element for the drop target.
 */
function onDrop(event, target) {
  hideDropIndicator();

  const isBody = target === document.body;
  let list = null;
  if (isBody) list = getListTargetFromBody(event);else list = getMatchingListTarget(event);

  if (list) {
    const location = isBody ? 'below' : 'inside';

    let index = -1;
    const rowNode = location === 'below' ? getLastRowFromLastList() : getRowNode(event);
    if (rowNode) {
      index = getTargetIndex(event.clientY, rowNode);
    }

    if (validateListDrop(event, list, location, index)) {
      const contextUri = list.getAttribute('data-uri');
      if (contextUri) {
        performListChangesForEvent(event, list, contextUri, location);
        event.handled = true;
      }
    }
  }
}

/**
 * Show the drop indicator below the provided list element.
 *
 * @param {HTMLElement} list A list element.
 */
function showDropIndicatorBelowList(list) {
  const listRect = list.getBoundingClientRect();
  showDropIndicator(listRect.left, listRect.bottom, listRect.width);
}

/**
 * Show the drop indicator above or below a list row.
 *
 * @param {HTMLElement} rowNode A list row element.
 * @param {number} cursorY The cursor Y position, relative to the viewport.
 */
function showDropIndicatorForRow(rowNode, cursorY) {
  const belowMiddle = isBelowMiddleOfNode(cursorY, rowNode);
  const rowRect = rowNode.getBoundingClientRect();
  const x = rowRect.left;
  const y = rowRect.top + (belowMiddle ? rowRect.height : 0);
  showDropIndicator(x, y, rowRect.width);
}

/**
 * Show the drop indicator line for the specified row and cursor position.
 * If the cursor position is below the middle of the row, the indicator will be
 * placed below the row, otherwise above the row.
 *
 * @param {number} x The X position relative to the viewport.
 * @param {number} y The Y position relative to the viewport.
 * @param {number} width The width of the indicator.
 */
function showDropIndicator(x, y, width) {
  // Don't use window.scroll X/Y because cross browser issues.
  // https://developer.mozilla.org/en-US/docs/Web/API/Window.scrollY
  const indicatorAbsX = window.pageXOffset + x;
  const indicatorAbsY = window.pageYOffset + y;
  const indicatorWidth = width;

  if (!dropIndicator) {
    dropIndicator = document.createElement('div');
    dropIndicator.className = 'tr-drag-indicator';
  }

  dropIndicator.style.left = `${indicatorAbsX}px`;
  dropIndicator.style.width = `${indicatorWidth}px`;
  dropIndicator.style.top = `${indicatorAbsY}px`;

  if (!dropIndicator.parentNode) {
    document.body.appendChild(dropIndicator);
  }
}

/**
 * Hide the drop indicator.
 */
function hideDropIndicator() {
  if (dropIndicator && dropIndicator.parentNode) {
    dropIndicator.parentNode.removeChild(dropIndicator);
  }
}

/**
 * Perform the list changes that are needed from the drop event.
 *
 * @param {MouseEvent} event A drop event.
 * @param {HTMLElement} list The list DOM node.
 * @param {string} contextUri The context URI for the list.
 * @param {string} location The location of the cursor in relation to the list.
 *     This can be either 'inside' or 'below'. The value 'below' means that the
 *     cursor was below the last list found in the DOM.
 */
function performListChangesForEvent(event, list, contextUri, location) {
  const liveList = live(contextUri).get('rows');
  if (!liveList) return;

  let targetIndex = 0;

  if (location === 'below') {
    const lastRowNode = getLastRowFromLastList();

    // Dropping below a list without rows will use target index 0
    if (lastRowNode) {
      targetIndex = getTargetIndex(event.clientY, lastRowNode);
    }
  } else {
    const rowNode = getRowNode(event);
    if (!rowNode) return;
    targetIndex = getTargetIndex(event.clientY, rowNode);
  }

  const sourceContext = event.dataTransfer.getData('text/x-spotify-data-context');
  const isSameContext = sourceContext && sourceContext === contextUri;

  if (isSameContext) {
    performMoveChanges(contextUri, liveList, targetIndex);
  } else {
    performInsertChanges(event, list, contextUri, liveList, targetIndex);
  }
  event.data = {
    targetIndex: targetIndex
  };
}

/**
 * Move the selected items to a target index in the list.
 *
 * @param {string} contextUri The context URI of the list.
 * @param {LiveList} liveList The live list for the context.
 * @param {number} targetIndex The target index in the list.
 */
function performMoveChanges(contextUri, liveList, targetIndex) {
  const indices = getMoveIndices(contextUri, liveList);

  // Selection can be nothing. This can happen if you select a row, drag it
  // and before dropping, the row is removed by something else (on another
  // device perhaps). Dropping should in that case not perform any action.
  // Similarly, if dragging multiple rows and some of the rows are removed
  // while dragging, only the rows that are still in the list will be moved.
  if (indices.length === 0) return;

  const operations = listOperations.getMoveOperations(indices, targetIndex);

  // If the list changed while dragging, it might happen that we end up
  // dropping at the same index as we're dragging from, which would give
  // us no operations to perform.
  if (operations.length === 0) return;

  liveList.publish(operations);

  temporarilyDisableList(contextUri, liveList);
}

/**
 * Insert items from the event into the list at the target index.
 *
 * @param {MouseEvent} event A drop event.
 * @param {HTMLElement} list The list DOM node.
 * @param {string} contextUri The context URI for the list.
 * @param {LiveList} liveList The live list for the context.
 * @param {number} targetIndex The target index in the list.
 */
function performInsertChanges(event, list, contextUri, liveList, targetIndex) {
  getInsertValues(event, list, liveList, contextUri, function (error, values) {
    if (error) return;
    if (values.length === 0) return;

    const operations = [{ type: 'insert', index: targetIndex, values: values }];

    liveList.publish(operations);

    temporarilyDisableList(contextUri, liveList);
  });
}

/**
 * Check if dropping at the current position in a list is allowed.
 *
 * @param {MouseEvent} event Some kind of drag and drop event.
 * @param {HTMLElement} list A DOM node marked up as a list.
 * @param {string} location The location of the cursor in relation to the list.
 *     This can be either 'inside' or 'below'. The value 'below' means that the
 *     cursor was below the last list found in the DOM.
 *
 * @return {boolean} True if it's a valid drop position.
 */
function validateListDrop(event, list, location, index) {
  // All positions are valid if we're not dragging from a context in the first
  // place. If we do have a context though, we need to validate the position.
  const types = event.dataTransfer.types;
  const isDraggingFromContext = types.indexOf('text/x-spotify-data-context') > -1;
  if (isDraggingFromContext) {
    if (!validatePotentialOperations(event, list, location)) {
      return false;
    }
  }

  const uri = list.getAttribute('data-uri');
  if (uri && draggedLinkContext === uri) {
    return false;
  }

  const result = { valid: true };
  hooks.run('list-drop-validation', result, event, list, location, index);

  return !!result.valid;
}

/**
 * Check if dropping at the current event position would actually result in
 * operations that would change the list.
 *
 * @param {MouseEvent} event Some kind of drag and drop event.
 * @param {HTMLElement} list A DOM node marked up as a list.
 * @param {string} location The location of the cursor in relation to the list.
 *     This can be either 'inside' or 'below'. The value 'below' means that the
 *     cursor was below the last list found in the DOM.
 *
 * @return {boolean} True if it would result in a change.
 */
function validatePotentialOperations(event, list, location) {
  // get a cached version of the selectionState
  const selectionState = cachedSelectionState.get();

  // Dropping inside the only selected range inside the only container that
  // has a selection is not allowed, as that would result in no change.
  if (selectionState.length === 1) {
    // Dropping inside a different context is always fine
    const contextUri = list.getAttribute('data-uri');
    if (contextUri !== selectionState[0].uri) {
      return true;
    }

    const selectedRanges = Range.fromIndices(selectionState[0].indicesWithHidden);

    if (selectedRanges.length === 1) {
      const selectedRange = selectedRanges[0];

      // Include the next row in the selected range to handle holding on the
      // top part of the next row, which would be a no-op. The bottom part of
      // the previous row will be taken care of by the code below.
      selectedRange.update(selectedRange.start, selectedRange.end + 1);

      const rowNode = location === 'below' ? getLastRowFromLastList() : getRowNode(event);
      if (rowNode) {
        const targetIndex = getTargetIndex(event.clientY, rowNode);
        if (targetIndex > -1) {
          const targetRange = new Range(targetIndex, targetIndex + 1);

          // If the target index is inside the selected range, it's not allowed
          // to drop, as that would be a no-op.
          if (targetRange.contained(selectedRange)) {
            return false;
          }
        }
      }
    }
  }

  return true;
}

/**
 * Get the drop target element that is matching the event target and the drag
 * MIME types of the event. This will start with the event target and step
 * outwards in the DOM tree to find the first matching element.
 *
 * @param {MouseEvent} event Some kind of drag and drop event.
 *
 * @return {HTMLElement?} The element or null if not found.
 */
function getMatchingTarget(event) {
  let currentNode = event.target;

  while (currentNode) {
    if (isMatchingTarget(event, currentNode)) {
      return currentNode;
    }
    currentNode = currentNode.parentElement;
  }

  return null;
}

/**
 * Get the list element that is matching the event target and the drag MIME
 * types of the event. This will start with the event target and step outwards
 * in the DOM tree to find the first matching element.
 *
 * @param {MouseEvent} event Some kind of drag and drop event.
 *
 * @return {HTMLElement?} The list element or null if not found.
 */
function getMatchingListTarget(event) {
  let currentNode = event.target;

  while (currentNode) {
    const isList = $(currentNode).matches(SELECTOR_LIST);
    if (isList && isMatchingTarget(event, currentNode)) {
      return currentNode;
    }
    currentNode = currentNode.parentElement;
  }

  return null;
}

/**
 * Get a valid list target from the end of body.
 *
 * @param {MouseEvent} event Some kind of drag and drop event.
 *
 * @return {HTMLElement?} The list element or null if not found.
 */
function getListTargetFromBody(event) {
  const lastList = getLastListNode();
  if (lastList) {
    const sameParent = event.target.contains(lastList);
    if (sameParent && isMatchingTarget(event, lastList)) {
      if (isBelowNode(event.clientX, event.clientY, lastList)) {
        return lastList;
      }
    }
  }

  return null;
}

/**
 * Get the list row element from the event target.
 * If the event target itself isn't a list row, it will step out in the parent
 * tree until it finds a row.
 *
 * @param {MouseEvent} event Some kind of drag and drop event.
 *
 * @return {HTMLElement?} The list row element, or null if not found.
 */
function getRowNode(event) {
  return event.target.closest(SELECTOR_LIST_ITEM);
}

/**
 * Get the last list row from the last list in the DOM.
 *
 * @return {HTMLElement?} The list row element, or null if not found.
 */
function getLastRowFromLastList() {
  const lastList = getLastListNode();
  if (lastList) {
    const listItems = $(lastList).search(SELECTOR_LIST_ITEM);
    const lastItem = listItems && listItems[listItems.length - 1];
    if (lastItem) return lastItem;
  }

  return null;
}

/**
 * Get the last list in the DOM.
 *
 * @return {HTMLElement?} The list element, or null if not found.
 */
function getLastListNode() {
  const lists = document.querySelectorAll(SELECTOR_LIST);
  const lastList = lists && lists[lists.length - 1];
  return lastList || null;
}

/**
 * Get the target index based on a cursor position and the row that the cursor
 * is on.
 *
 * @param {number} y The Y position relative to the viewport.
 * @param {HTMLElement} rowNode The DOM node for the row.
 *
 * @return {number} The target index or -1 if not found.
 */
function getTargetIndex(y, rowNode) {
  let index = rowNode.getAttribute('data-index');

  if (index === null) {
    index = -1;
  } else {
    index = parseInt(index, 10);

    if (isNaN(index)) {
      index = -1;
    } else {
      // If cursor is in the bottom part of the row, dropping will place items
      // after the row, so we need to increment the index.
      if (isBelowMiddleOfNode(y, rowNode)) {
        index++;
      }
    }
  }

  return index;
}

/**
 * Get the indices of the rows to move.
 *
 * @param {string} contextUri The context URI.
 * @param {LiveList} liveList The live list to be changed.
 *
 * @return {Array.<number>} Array of indices.
 */
function getMoveIndices(contextUri, liveList) {
  // As we need the indices, we must use the current selection state,
  // since the list might have changed since the start of the drag.
  // We are only in this function if we are dragging in the same
  // context, so the current selection state will always be valid.
  const selectionState = selection.getIndicesPerList();
  if (selectionState.length !== 1) return [];

  const firstContainer = selectionState[0];
  const selectedIndices = firstContainer.indices;
  const indices = selectedIndices.slice();

  if (indices.length === 0) return [];

  hooks.run('get-move-indices', contextUri, liveList, indices);

  // The indices must be sorted for the utility that creates the list operations
  indices.sort(function (a, b) {
    return a - b;
  });

  return indices;
}

/**
 * Get the values to use for insertion in the list. This will get the event data
 * for the matching MIME types.
 *
 * @param {MouseEvent} event A drop event.
 * @param {HTMLElement} list The list DOM node.
 * @param {LiveList} liveList The live list for the context.
 * @param {string} contextUri The context URI for the list.
 * @param {Function} callback A callback function. The data argument will be an
 *     array of object values.
 */
function getInsertValues(event, list, liveList, contextUri, callback) {
  const eventTypes = event.dataTransfer.types;
  const listTypes = list.getAttribute(ATTR_TARGET);
  if (!listTypes) {
    callback(null, []);
    return;
  }

  const matchingTypes = intersection(listTypes.split('|'), eventTypes);
  if (matchingTypes.length === 0) {
    callback(null, []);
    return;
  }

  const data = getDataFromTypes(event, matchingTypes);

  const isTrackList = isListOfTracks(liveList, contextUri);

  getRowsFromData(data, isTrackList, function (error, rows) {
    if (error) {
      callback(error);
      return;
    }

    callback(null, rows);
  });
}

/**
 * Get the event data associated with the provided MIME types.
 *
 * @param {MouseEvent} event Some kind of drag and drop event.
 * @param {Array.<string>} types Array of MIME types.
 *
 * @return {Object.<string, Array>} Object where key is MIME type and value is
 *     array of values (URIs).
 */
function getDataFromTypes(event, types) {
  const data = {};

  for (let i = 0, l = types.length; i < l; i++) {
    const type = types[i];
    const itemsInData = data[type] = [];

    // A MIME type that starts with text/x-spotify is always containing a list
    // of Open URLs separated by '\n'.
    const hasURIs = type.indexOf('text/x-spotify') === 0;

    const dataForType = event.dataTransfer.getData(type);
    const items = hasURIs ? dataForType.split('\n') : [dataForType];
    for (let n = 0, len = items.length; n < len; n++) {
      const item = items[n];
      if (hasURIs) {
        const uriObject = liburi.from(item);
        if (uriObject) {
          itemsInData.push(uriObject.toURI());
        }
      } else {
        itemsInData.push(item);
      }
    }
  }

  return data;
}

/**
 * Get list row data from the event data. This might expand items if the list
 * is a track list (dropping an album into a track list will expand the album
 * into its tracks and return track rows instead).
 *
 * @param {Object.<string, Array>} data Data from drop event.
 * @param {boolean} isTrackList True if the list is a track list.
 * @param {Function} callback A callback function. The data argument will be an
 *     array of object values.
 */
function getRowsFromData(data, isTrackList, callback) {
  const promised = [];

  if (data['text/x-spotify-tracks']) {
    promised.push(getRowObjects('track', data['text/x-spotify-tracks']));
  }

  if (data['text/x-spotify-albums']) {
    const albums = data['text/x-spotify-albums'];
    if (isTrackList) {
      promised.push(fetchListTrackRows(albums));
    } else {
      promised.push(getRowObjects('album', albums));
    }
  }

  if (data['text/x-spotify-playlists']) {
    const playlists = data['text/x-spotify-playlists'];
    if (isTrackList) {
      promised.push(fetchListTrackRows(playlists));
    } else {
      promised.push(getRowObjects('playlist', playlists));
    }
  }

  if (data['text/x-spotify-artists']) {
    promised.push(getRowObjects('artist', data['text/x-spotify-artists']));
  }

  if (data['text/x-spotify-users']) {
    promised.push(getRowObjects('user', data['text/x-spotify-users']));
  }

  Promise.all(promised).then(function (arrays) {
    let rows = [];
    rows = rows.concat.apply(rows, arrays);
    callback(null, rows);
  }, function (error) {
    callback(error);
  });
}

/**
 * Fetch the track rows from a set of list URIs. This is for the expansion of
 * for example an album into the tracks of the album.
 *
 * @param {Array.<string>} listUris Array of list URIs.
 */
function fetchListTrackRows(listUris) {
  const promised = listUris.map(function (listUri) {
    return new Promise(function (resolve, reject) {
      live(listUri).query('rows(track(uri))', function (error, data) {
        if (error) {
          reject(error);
          return;
        }
        const rows = data.rows.map(function (row) {
          return live(row);
        });
        resolve(rows);
      }, live.ASAP);
    });
  });

  return Promise.all(promised).then(function (arrays) {
    let rows = [];
    rows = rows.concat.apply(rows, arrays);
    return rows;
  });
}

/**
 * Fetch the live object for the row of an item.
 *
 * @param {string} itemType The type of an item (for example 'track').
 * @param {Array.<string>} uris Array of item URIs.
 *
 * @return {Array.<LiveObject>} Array of row live objects.
 */
function getRowObjects(itemType, uris) {
  return uris.map(function (uri) {
    const row = {};
    row[itemType] = { uri: uri };
    return live(row);
  });
}

/**
 * Check if the list is a track list.
 *
 * @param {LiveList} liveList The live list.
 * @param {string} contextUri The context URI for the list.
 *
 * @return {boolean} True if the list is a track list.
 */
function isListOfTracks(liveList, contextUri) {
  const uriObject = liburi.from(contextUri);
  const type = uriObject && uriObject.type;
  if (type === liburi.Type.PLAYLIST) return true;

  const result = { valid: false };
  hooks.run('is-list-of-tracks', result, liveList, contextUri);

  if (!result.valid) {
    const firstRow = liveList.get(0);
    const firstTrack = firstRow && firstRow.get('track');
    if (firstTrack) return true;
  }

  return !!result.valid;
}

/**
 * Check if the position is below the bottom edge of the node.
 *
 * @param {number} x The X position relative to the viewport.
 * @param {number} y The Y position relative to the viewport.
 * @param {HTMLElement} node DOM node to check against.
 *
 * @return {boolean} True if the position is below.
 */
function isBelowNode(x, y, node) {
  const rect = node.getBoundingClientRect();
  const below = y >= rect.bottom;
  const betweenX = x >= rect.left && x <= rect.right;
  return below && betweenX;
}

/**
 * Check if the position is below the middle of the node.
 *
 * @param {number} y The Y position relative to the viewport.
 * @param {HTMLElement} node DOM node to check against.
 *
 * @return {boolean} True if the position is below.
 */
function isBelowMiddleOfNode(y, node) {
  const rect = node.getBoundingClientRect();
  return y >= rect.top + rect.height / 2;
}

/**
 * Check if the MIME types in the drag event matches the MIME types for the
 * specified drop target.
 *
 * @param {MouseEvent} event Some kind of drag and drop event.
 * @param {HTMLElement} node A DOM node.
 *
 * @return {boolean} True if the element matches the event.
 */
function isMatchingTarget(event, node) {
  const eventTypes = event.dataTransfer.types;
  const nodeTypes = node.getAttribute(ATTR_TARGET);

  if (nodeTypes) {
    const matching = intersection(nodeTypes.split('|'), eventTypes);
    if (matching.length > 0) return true;
  }

  return false;
}

/**
 * Temporarily disable drag and dropping inside a list until the move or insert
 * is done. This is to prevent multiple operations to be called before the
 * response from the first comes back. We consider the operation done when we
 * receive the next update event, since it's very tricky to know when this
 * specific move is done. To prevent possible errors with being disabled
 * infinitely, we will enable it again after a certain timeout. This could
 * happen for example if the live list is switched out for a new list, in which
 * case we won't get the update event.
 *
 * @param {string} contextUri The context URI.
 * @param {LiveList} liveList The live list that was changed.
 */
function temporarilyDisableList(contextUri, liveList) {
  disabledLists[contextUri] = true;

  const handler = function (t) {
    return () => {
      clearTimeout(t);
      liveList.off('update', handler);

      // Wait slighly longer to allow the change to trickle down to DOM
      setTimeout(function () {
        delete disabledLists[contextUri];
      }, 100);
    };
  };

  const timer = setTimeout(() => {
    handler(timer);
  }, 500);

  liveList.on('update', handler(timer));
}

/**
 * Attach the module.
 */
function attach() {
  eventModel.delegate('dragstart', SELECTOR_DRAGGABLE, onDragStart);
  eventModel.delegate('dragover', SELECTOR_LIST_TARGET, onDragOver);
  eventModel.delegate('dragleave', SELECTOR_LIST_TARGET, onDragLeave);
  eventModel.delegate('dragend', 'body', onDragEnd);
  eventModel.delegate('drop', SELECTOR_LIST_TARGET, onDrop);
}

/**
 * Detach the module.
 */
function detach() {
  eventModel.undelegate('dragstart', SELECTOR_DRAGGABLE, onDragStart);
  eventModel.undelegate('dragover', SELECTOR_LIST_TARGET, onDragOver);
  eventModel.undelegate('dragleave', SELECTOR_LIST_TARGET, onDragLeave);
  eventModel.undelegate('dragend', 'body', onDragEnd);
  eventModel.undelegate('drop', SELECTOR_LIST_TARGET, onDrop);
}

exports.attach = attach;
exports.detach = detach;

},{"../../../libs/live-list-operations":157,"../../live":210,"../../range2":245,"../../spotify-elements":251,"../selection":319,"./util/eventmodel":272,"./util/hooks":273,"mout/array/intersection":450,"spotify-liburi":730}],271:[function(require,module,exports){
(function (global){
/**
 * @module spotify-events/dragndrop/target
 * @private
 */
'use strict';

const $ = require('../../spotify-elements');
const liburi = require('spotify-liburi');
const defer = require('../../../libs/prime/defer');

const center = require('../center');
const eventModel = require('./util/eventmodel');
const hooks = require('./util/hooks');
const getLogContext = require('../util/get-log-context');
const UserDragAndDropInteraction1 = require('../../logger/messages/UserDragAndDropInteraction1');

const SELECTOR_DROP_TARGET = '[data-drop-target]';
const SELECTOR_DRAGGABLE = 'a, [draggable]';
const ATTR_TARGET = 'data-drop-target';
const ATTR_TARGET_INCLUDE_TEXT = 'data-drop-target-include-text';
const ATTR_NO_CLASSNAME = 'data-drop-no-classname';
const CLASSNAME_ACTIVE = 'drop-target-active';
const TEXT_PLAIN = 'text/plain';

let longHoldTimerId = 0;
let longHoldTimerDuration = 1000;
let draggedElement = null;
let lastEnteredElement = null;

/**
 * Handler for starting to drag.
 *
 * @param {MouseEvent} event A dragstart event object.
 * @param {HTMLElement} node The draggable DOM element.
 */
function onDragStart(event, node) {
  // Don't handle items that are specified with the new implementation.
  if (node.closest('[data-glue-draggable]')) {
    return;
  }

  draggedElement = node;
  lastEnteredElement = null;
}

/**
 * Handler for ending a drag.
 */
function onDragEnd() {
  draggedElement = null;
  lastEnteredElement = null;

  stopLongHoldTimer();
  removeAnyActiveClass();
}

/**
 * Handler for dragging into a drop target.
 *
 * @param {MouseEvent} event A dragenter event object.
 * @param {HTMLElement} target DOM element for the drop target.
 */
function onDragEnter(event, target) {
  if (validateTarget(event, target)) {
    setEnter(event, target);
  }
}

/**
 * Handler for dragging out from a drop target.
 *
 * @param {MouseEvent} event A dragleave event object.
 * @param {HTMLElement} target DOM element for the drop target.
 */
function onDragLeave(event, target) {
  if (validateTarget(event, target)) {
    setLeave(event, target);
  }
}

/**
 * Handler for dragging over a drop target.
 *
 * @param {MouseEvent} event A dragover event object.
 * @param {HTMLElement} target DOM element for the drop target.
 */
function onDragOver(event, target) {
  if (validateTarget(event, target)) {
    // Tell the event that we are accepting drops on this target
    event.preventDefault();

    // Since other code might have set the dropEffect to something else,
    // we need to override that, since we're now accepting drops
    event.dataTransfer.dropEffect = 'copy';

    setEnter(event, target);

    // If the target is not valid, remove any styling for active drop target
  } else {
    setLeave(event, target);
  }
}

/**
 * Handler for dropping on a drop target.
 *
 * @param {MouseEvent} event A drop event object.
 * @param {HTMLElement} target DOM element for the drop target.
 */
function onDrop(event, target) {
  stopLongHoldTimer();

  // Dropping should remove active target class name.
  // Dropping outside of a target doesn't need this, as the target is only
  // active when hovering it.
  removeAnyActiveClass();

  if (validateTarget(event, target)) {
    const types = getMimeTypesForTarget(event, target);
    const dropData = getDropData(event, types);
    const sourceUri = event.dataTransfer.getData('text/x-spotify-data-context') || null;
    const sourceLogContext = event.dataTransfer.getData('text/x-spotify-data-log-context') || null;
    const sourceAppUri = event.dataTransfer.getData('text/x-spotify-data-app-uri') || null;
    let sourceIndex = parseInt(event.dataTransfer.getData('text/x-spotify-data-log-source-index'), 0);
    if (isNaN(sourceIndex)) sourceIndex = null;

    const targetUriNode = target.closest('[data-uri]');
    const targetUri = targetUriNode && targetUriNode.getAttribute('data-uri') || null;
    const targetLogContext = getLogContext(target);
    const targetAppUri = global.__spotify && global.__spotify.app_uri || null;

    // Give any other delegates a chance to handle the drop, and if so pass
    // that info along in the event.
    defer.immediate(function () {
      center.emit('drop', {
        handled: event.handled,
        node: target,
        sourceUri: sourceUri,
        targetUri: targetUri,
        data: dropData
      });

      const firstItem = dropData[Object.keys(dropData)[0]][0];
      const itemType = liburi.from(firstItem).type;
      const numberOfItems = Object.keys(dropData).reduce(function (sum, key) {
        return sum + dropData[key].length;
      }, 0);
      const targetIndex = event.data && event.data.targetIndex || null;

      UserDragAndDropInteraction1.log({
        item_type: itemType,
        item_uri: firstItem,
        number_items: numberOfItems,
        source_view_uri: sourceAppUri,
        source_uri: sourceUri,
        source_index: sourceIndex,
        source_component: sourceLogContext,
        target_view_uri: targetAppUri,
        target_uri: targetUri,
        target_index: targetIndex,
        target_component: targetLogContext
      });
    });
  }

  // Prevent navigation on drop
  event.preventDefault();

  // Reset here since our multi-frame architecture means we're not guaranteed
  // to have gotten a dragstart event in this frame prior to dropping.
  lastEnteredElement = null;
}

/**
 * Set target to be entered, including setting style and sending event.
 *
 * @param {MouseEvent} event A dragenter event object.
 * @param {HTMLElement} target DOM element for the drop target.
 */
function setEnter(event, target) {
  if (target === lastEnteredElement) {
    return;
  }

  lastEnteredElement = target;

  if (!target.hasAttribute(ATTR_NO_CLASSNAME)) {
    $(target).addClass(CLASSNAME_ACTIVE);
  }

  const types = getMimeTypesForTarget(event, target);
  center.emit('dragenter', { node: target, types: types });

  startLongHoldTimer(target, types);
}

/**
 * Set target to be left, including removing style and sending event.
 *
 * @param {MouseEvent} event A dragleave event object.
 * @param {HTMLElement} target DOM element for the drop target.
 */
function setLeave(event, target) {
  if (target !== lastEnteredElement) {
    return;
  }

  lastEnteredElement = null;

  if (!target.hasAttribute(ATTR_NO_CLASSNAME)) {
    $(target).removeClass(CLASSNAME_ACTIVE);
  }

  const types = getMimeTypesForTarget(event, target);
  center.emit('dragleave', { node: target, types: types });

  stopLongHoldTimer();
}

/**
 * Check if the drop target matches the MIME types for the event.
 *
 * @param {MouseEvent} event Some kind of drag and drop event.
 * @param {HTMLElement} target DOM element for the drop target.
 *
 * @return {boolean} True if the target is valid.
 */
function validateTarget(event, target) {
  // The element being dragged is not accepted as a drop target
  if (target === draggedElement) {
    return false;
  }

  const types = getMimeTypesForTarget(event, target);

  if (types.length) {
    const result = { valid: true };
    hooks.run('target-validation', result, event, target);

    if (result.valid) {
      return true;
    }
  }

  return false;
}

/**
 * Get the data associated with the drop, grouped by MIME type.
 * If the data contained Spotify URLs, they will be converted to Spotify URIs.
 *
 * @param {MouseEvent} event Event object for a drop event.
 * @param {Array.<string>} types Array of MIME types.
 *
 * @return {Object.<string, Array.<string>>} Data object of arrays of item
 *     URIs, grouped by MIME type.
 */
function getDropData(event, types) {
  const data = {};

  for (let i = 0, l = types.length; i < l; i++) {
    const itemsInData = data[types[i]] = [];
    const dataForType = event.dataTransfer.getData(types[i]);
    const hasURIs = types[i].indexOf('text/x-spotify') === 0;
    const items = hasURIs ? dataForType.split('\n') : [dataForType];

    for (let n = 0, len = items.length; n < len; n++) {
      let item = items[n];
      if (hasURIs) {
        const uriObject = liburi.from(item);
        if (uriObject) item = uriObject.toURI();
      }
      if (item) itemsInData.push(item);
    }
  }

  const hasContextData = types.indexOf('text/x-spotify-data-context') > -1;
  if (hasContextData) {
    data['text/x-spotify-data-context'] = [event.dataTransfer.getData('text/x-spotify-data-context')];
  }

  return data;
}

/**
 * Start a timer for emitting an event for long-hold on a target.
 * If one is already started, it will use the previous timer and not restart it.
 *
 * @param {HTMLElement} target A DOM element for the drop target.
 * @param {Array.<string>} types Array of MIME types.
 */
function startLongHoldTimer(target, types) {
  // Don't start a new timer if we already have one running
  if (longHoldTimerId) return;

  longHoldTimerId = setTimeout(function () {
    center.emit('dragover-long', { node: target, types: types });
  }, longHoldTimerDuration);
}

/**
 * Stop any running timer for emitting an event for long-hold on a target.
 */
function stopLongHoldTimer() {
  clearTimeout(longHoldTimerId);

  // Reset the timer ID so we can know that there is no timer running
  longHoldTimerId = 0;
}

/**
 * Remove the active class name from any element that has it.
 */
function removeAnyActiveClass() {
  const active = $(`.${CLASSNAME_ACTIVE}`);
  if (active) {
    active.removeClass(CLASSNAME_ACTIVE);
  }
}

/**
 * Get the MIME types that are matching both the drag event and the target.
 *
 * @param {MouseEvent} event Any kind of drag and drop event.
 * @param {HTMLElement} target A DOM element.
 *
 * @return {Array.<string>} Array of MIME types.
 */
function getMimeTypesForTarget(event, target) {
  const mimeTypes = [];
  const dataTypes = event.dataTransfer.types;

  let targetTypes = target.getAttribute(ATTR_TARGET);
  // Even though the target may not accept just text/plain data, in can still
  // opt to receive that data along side the ones it accepts.
  // For example to get a list of mixed data types in order.
  const includeText = target.hasAttribute(ATTR_TARGET_INCLUDE_TEXT);

  if (targetTypes) {
    targetTypes = targetTypes.split('|');

    for (let i = 0, l = dataTypes.length; i < l; i++) {
      const type = dataTypes[i];
      if (targetTypes.indexOf(type) > -1) {
        mimeTypes.push(type);
      }
    }

    if (includeText && mimeTypes.length) {
      if (mimeTypes.indexOf(TEXT_PLAIN) === -1) {
        mimeTypes.push(TEXT_PLAIN);
      }
    }
  }

  return mimeTypes;
}

/**
 * Attach the module.
 */
function attach() {
  eventModel.delegate('dragstart', SELECTOR_DRAGGABLE, onDragStart);
  eventModel.delegate('dragenter', SELECTOR_DROP_TARGET, onDragEnter);
  eventModel.delegate('dragleave', SELECTOR_DROP_TARGET, onDragLeave);
  eventModel.delegate('dragover', SELECTOR_DROP_TARGET, onDragOver);
  eventModel.delegate('dragend', 'body', onDragEnd);
  eventModel.delegate('drop', SELECTOR_DROP_TARGET, onDrop);
}

/**
 * Detach the module.
 */
function detach() {
  eventModel.undelegate('dragstart', SELECTOR_DRAGGABLE, onDragStart);
  eventModel.undelegate('dragenter', SELECTOR_DROP_TARGET, onDragEnter);
  eventModel.undelegate('dragleave', SELECTOR_DROP_TARGET, onDragLeave);
  eventModel.undelegate('dragover', SELECTOR_DROP_TARGET, onDragOver);
  eventModel.undelegate('dragend', 'body', onDragEnd);
  eventModel.undelegate('drop', SELECTOR_DROP_TARGET, onDrop);
}

exports.attach = attach;
exports.detach = detach;

// Exporting for testing
const originalDuration = longHoldTimerDuration;
exports.setLongHoldDuration = function setLongHoldDuration(duration) {
  longHoldTimerDuration = duration;
};
exports.resetLongHoldDuration = function resetLongHoldDuration() {
  longHoldTimerDuration = originalDuration;
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../../libs/prime/defer":241,"../../logger/messages/UserDragAndDropInteraction1":223,"../../spotify-elements":251,"../center":262,"../util/get-log-context":333,"./util/eventmodel":272,"./util/hooks":273,"spotify-liburi":730}],272:[function(require,module,exports){
/**
 * @module spotify-events/dragndrop/util/eventmodel
 * @private
 *
 * This module is made to be an abstraction of the event model for drag and
 * drop. It also exposes a delegation interface which allows you to only
 * listen for events for targets matching a certain selector.
 *
 * The need for this abstraction is to simplify the code listening to drag
 * and drop events.
 *
 * - The raw events we get from the browser are sometimes not that easy to
 *   work with. For example, when moving from one target to another, we get
 *   a dragenter event before the dragleave event, which can cause confusion.
 *   This abstraction flips that around, so that you always get the dragleave
 *   event before the dragenter event.
 *
 * - The raw events also trigger for children. For example, if moving the
 *   cursor from one element to one of its children, we get a dragenter event
 *   for the child element and a dragleave for the outer element. This makes
 *   it difficult to highlight drop targets based on dragenter/dragleave.
 *   This abstraction helps by making sure the handler is not called if moving
 *   to a child element inside an element that matches the selector. There
 *   is an exception though when moving to a child that is also matching a
 *   selector, the outer element is then left and the child is entered.
 *
 * @example
 * function onDragEnter(event, target) {
 *   event instanceof MouseEvent; // true
 *   target instanceof HTMLElement; // true
 *   target.matches('[data-drop-target]'); // true
 * }
 *
 * // Start listening
 * eventmodel.delegate('dragenter', '[data-drop-target]', onDragEnter);
 *
 * // Stop listening
 * eventmodel.undelegate('dragenter', '[data-drop-target]', onDragEnter);
 */
'use strict';

const $ = require('../../../spotify-elements');

const attached = {};
const delegations = {};
let movementHandlerCount = 0;

// State variables
let hasEntered = false;
let lastEnteredElement = null;
let lastEnterTarget = null;
let lastEnterEvent = null;
let wasLastEventEnter = false;

/**
 * Reset the temporary state variables used while dragging.
 */
function resetState() {
  hasEntered = false;
  lastEnteredElement = null;
  lastEnterTarget = null;
  lastEnterEvent = null;
  wasLastEventEnter = false;
}

/**
 * Generic handler for any event.
 * This function will look at the current delegations and run the handler
 * functions for the matching delegations.
 * Some events will be handled by calling a special handler, which in some cases
 * later will check for matching delegations.
 *
 * @param {Event} event Event object.
 */
function onEvent(event) {
  const handler = getPrimaryHandler(event.type);
  if (handler) {
    handler(event);
  } else {
    handleDelegationsForEvent(event);
  }
}

/**
 * Handler for a dragenter event.
 * Depending on state, this might save the event for later and call the
 * handler at a later point, to ensure that the dragenter event is sent
 * after the dragleave.
 *
 * @param {MouseEvent} event Event object for a dragenter event.
 */
function onPrimaryDragEnter(event) {
  wasLastEventEnter = true;

  if (hasEntered) {
    if (lastEnteredElement !== event.target) {
      lastEnterEvent = event;
    }
  } else {
    hasEntered = true;
    lastEnteredElement = event.target;
    handleDelegationsForEvent(event);
  }
}

/**
 * Handler for a dragleave event.
 * Depending on state, this might also trigger the handlers for a dragenter
 * event, if there was a saved event from before.
 *
 * @param {MouseEvent} event Event object for a dragleave event.
 */
function onPrimaryDragLeave(event) {
  wasLastEventEnter = false;
  lastEnteredElement = null;

  handleDelegationsForEvent(event);

  if (hasEntered) {
    if (lastEnterEvent) {
      lastEnteredElement = lastEnterEvent.target;
      handleDelegationsForEvent(lastEnterEvent);
      lastEnterEvent = null;
    } else {
      hasEntered = false;
    }
  }
}

/**
 * Handler for a drop event.
 * This is handled by a special handler only to reset some state.
 *
 * @param {MouseEvent} event Event object for a drop event.
 */
function onPrimaryDrop(event) {
  resetState();
  handleDelegationsForEvent(event);
}

/**
 * Handler for a dragend event.
 * This is handled by a special handler only to reset some state.
 *
 * @param {MouseEvent} event Event object for a drop event.
 */
function onPrimaryDragEnd(event) {
  resetState();
  handleDelegationsForEvent(event);
}

/**
 * Delegation handler for a dragenter event.
 * After matching against stored delegations, we need to do some final checking
 * before calling the user handler.
 *
 * @param {MouseEvent} event Event object for a dragenter event.
 * @param {HTMLElement} target A DOM element.
 * @param {Function} handler The user handler.
 */
function onDragEnter(event, target, handler) {
  if (target !== lastEnterTarget) {
    lastEnterTarget = target;
    callUserHandler(event, target, handler);
  }
}

/**
 * Delegation handler for a dragleave event.
 * After matching against stored delegations, we need to do some final checking
 * before calling the user handler.
 *
 * @param {MouseEvent} event Event object for a dragleave event.
 * @param {HTMLElement} target A DOM element.
 * @param {Function} handler The user handler.
 * @param {string} selector A CSS selector string.
 */
function onDragLeave(event, target, handler, selector) {
  let shouldCallUserHandler = false;

  const lastElement = lastEnterEvent && lastEnterEvent.target;
  if (lastElement) {
    const isSameElement = target === lastElement;
    const isEnteringChild = !isSameElement && target.contains(lastElement);
    const isEnteringMatchingElement = $(lastElement).matches(selector);
    if (!isSameElement && (!isEnteringChild || isEnteringMatchingElement)) {
      shouldCallUserHandler = true;
    }
  }

  // Most often the sequence of events will be dragenter->dragenter->dragleave
  // when moving into one element and then into another element. But if the
  // sequence is just dragenter->dragleave, we should also call the user
  // handler. This would happen if there is no new entered element.
  if (!wasLastEventEnter) {
    shouldCallUserHandler = true;
  }

  if (shouldCallUserHandler) {
    lastEnterTarget = null;
    callUserHandler(event, target, handler);
  }
}

/**
 * Find matching delegations and call the handlers.
 *
 * @param {Event} event Event object.
 */
function handleDelegationsForEvent(event) {
  const type = event.type;
  const delegationData = delegations[type];

  if (delegationData && delegationData.length > 0) {
    delegationData.forEach(function (data) {
      const selector = data.selector;
      // Check that the event.target is not the document element as it does not
      // have the closest function. This happens when dragging over scrollbars which
      // belong to the document.
      const matchingTarget = event.target !== document && event.target.closest(selector);

      if (matchingTarget) {
        const handler = getHandler(type) || callUserHandler;
        handler(event, matchingTarget, data.handler, selector);
      }
    });
  }
}

/**
 * Call the user handler for a delegation.
 *
 * @param {Event} event Event object.
 * @param {HTMLElement} target A DOM element.
 * @param {Function} handler The user handler.
 */
function callUserHandler(event, target, handler) {
  handler.call(exports, event, target);
}

/**
 * Get any handler that needs to be called for a raw event before looking
 * for any delegations.
 *
 * @param {string} type Event type.
 *
 * @return {Function?} The handler function or null if no special handler
 *     should be called.
 */
function getPrimaryHandler(type) {
  switch (type) {
    case 'dragenter':
      return onPrimaryDragEnter;
    case 'dragleave':
      return onPrimaryDragLeave;
    case 'dragend':
      return onPrimaryDragEnd;
    case 'drop':
      return onPrimaryDrop;
    default:
      break;
  }
  return null;
}

/**
 * Get any handler that needs to be called after matching delegations,
 * but before calling the user handler.
 *
 * @param {string} type Event type.
 *
 * @return {Function?} The handler function or null if no special handler
 *     should be called.
 */
function getHandler(type) {
  switch (type) {
    case 'dragenter':
      return onDragEnter;
    case 'dragleave':
      return onDragLeave;
    default:
      break;
  }
  return null;
}

/**
 * Check if the event type is one of the events that need special handling
 * for movement (enter/leave events).
 *
 * @param {string} type Event type.
 *
 * @return {boolean} True if the type is a movement type, false otherwise.
 */
function isMovementType(type) {
  switch (type) {
    case 'dragenter':
      return true;
    case 'dragleave':
      return true;
    case 'dragend':
      return true;
    case 'drop':
      return true;
    default:
      break;
  }
  return false;
}

/**
 * Attach a global event listener on document for the specified type.
 *
 * @param {string} type Event type.
 */
function attach(type) {
  if (attached[type]) return;
  attached[type] = true;
  document.addEventListener(type, onEvent, false);
}

/**
 * Detach a global event listener on document for the specified type.
 *
 * @param {string} type Event type.
 */
function detach(type) {
  if (!attached[type]) return;
  attached[type] = false;
  document.removeEventListener(type, onEvent, false);
}

/**
 * Start listening for an event via event delegation for the specified
 * selector.
 *
 * @example
 * var selector = '[data-drop-target]';
 * eventModel.delegate('dragenter', selector, function(event, target) {
 *   event instanceof MouseEvent; // true
 *   target instanceof HTMLElement; // true
 *   target.matches('[data-drop-target]'); // true
 * });
 */
function delegate(type, selector, handler) {
  if (isMovementType(type)) {
    movementHandlerCount++;
    if (movementHandlerCount === 1) {
      attach('dragenter');
      attach('dragleave');
      attach('dragend');
      attach('drop');
    }
  } else if (!attached[type]) {
    attach(type);
  }

  if (!delegations[type]) delegations[type] = [];

  delegations[type].push({ selector: selector, handler: handler });
}

/**
 * Stop listening for an event via event delegation for the specified
 * selector and handler.
 *
 * @example
 * eventModel.undelegate('dragenter', '[data-drop-target]', handler);
 */
function undelegate(type, selector, handler) {
  if (isMovementType(type)) {
    movementHandlerCount = Math.max(0, movementHandlerCount - 1);
    if (movementHandlerCount === 0) {
      detach('dragenter');
      detach('dragleave');
      detach('dragend');
      detach('drop');
    }
  }

  const delegationsForType = delegations[type];
  if (delegationsForType) {
    for (let i = 0, l = delegationsForType.length; i < l; i++) {
      const data = delegationsForType[i];
      if (data.selector === selector && data.handler === handler) {
        delegationsForType.splice(i, 1);
        break;
      }
    }

    if (!isMovementType && delegationsForType.length === 0) {
      detach(type);
    }
  }
}

exports.delegate = delegate;
exports.undelegate = undelegate;

},{"../../../spotify-elements":251}],273:[function(require,module,exports){
/**
 * Hooks
 *
 * Almost like an event emitter. You can add hooks for different ids, and when
 * a hook for an ID is run, the handlers are called.
 *
 * @module spotify-events/dragndrop/util/hooks
 * @private
 */
'use strict';

const hooks = {};

/**
 * Add a hook handler for a specific hook ID.
 *
 * @param {string} id The hook ID.
 * @param {function} handler The handler function. The hook sets the arguments.
 */
function add(id, handler) {
  if (!hooks[id]) hooks[id] = [];
  hooks[id].push(handler);
}

/**
 * Remove a hook handler for a specific hook ID.
 *
 * @param {string} id The hook ID.
 * @param {function} handler The handler function.
 */
function remove(id, handler) {
  if (hooks[id]) {
    const index = hooks[id].indexOf(handler);
    if (index > -1) {
      hooks[id].splice(index, 1);
    }
  }
}

/**
 * Run the hook handlers for a specific hook ID.
 *
 * @param {string} id The hook ID.
 */
function run(id) {
  const handlers = hooks[id];
  if (handlers && handlers.length > 0) {
    const args = Array.prototype.slice.call(arguments, 1);
    for (let i = 0, l = handlers.length; i < l; i++) {
      handlers[i].apply(null, args);
    }
  }
}

exports.add = add;
exports.remove = remove;
exports.run = run;

},{}],274:[function(require,module,exports){
/**
 * @module spotify-events/dragndrop/util/itemtext
 * @private
 */
'use strict';

const live = require('../../../live');
const liburi = require('spotify-liburi');

/**
 * Get the text for a URI.
 *
 * @param {string} uri Any URI.
 *
 * @return {string} The text.
 */
function getForUri(uri) {
  const uriObject = liburi.from(uri);
  if (!uriObject) return '';

  const type = uriObject.type;

  if (type === liburi.Type.TRACK || type === liburi.Type.LOCAL) {
    return getForTrack(uri);
  } else if (type === liburi.Type.ARTIST || type === liburi.Type.LOCAL_ARTIST) {
    return getForArtist(uri);
  } else if (type === liburi.Type.ALBUM || type === liburi.Type.LOCAL_ALBUM) {
    return getForAlbum(uri);
  } else if (type === liburi.Type.PLAYLIST) {
    return getForPlaylist(uri);
  } else if (type === liburi.Type.USER || type === liburi.Type.PROFILE) {
    return getForUser(uri);
  } else if (type === liburi.Type.FOLDER) {
    return getForFolder(uri);
  } else if (type === liburi.Type.STATION) {
    return getForStation(uri);
  } else if (type === liburi.Type.EPISODE) {
    return getForEpisode(uri);
  } else if (type === liburi.Type.SHOW) {
    return getForShow(uri);
  }

  return '';
}

/**
 * Get the text for a track URI.
 *
 * Examples:
 * Track Name – First Artist, Second Artist, Third Artist (and so on...)
 * Track Name
 *
 * @param {string} uri Track URI.
 *
 * @return {string} The text.
 */
function getForTrack(uri) {
  const object = live(uri);
  const itemName = object.get('name');
  if (!itemName) return '';

  const artists = object.get('artists');
  if (!artists || artists.length === 0) return itemName;

  const artistNames = artists.get(0, artists.length).map(function (artist) {
    return artist.get('name');
  }).join(', ');
  if (!artistNames) return itemName;

  return separateDragTextItems(itemName, artistNames);
}

/**
 * Get the text for an artist URI.
 *
 * Examples:
 * Artist Name
 *
 * @param {string} uri Artist URI.
 *
 * @return {string} The text.
 */
function getForArtist(uri) {
  return live(uri).get('name') || '';
}

/**
 * Get the text for an album URI.
 *
 * Examples:
 * Artist Name – Album Name
 * Album Name
 *
 * @param {string} uri Album URI.
 *
 * @return {string} The text.
 */
function getForAlbum(uri) {
  const object = live(uri);
  const itemName = object.get('name');
  if (!itemName) return '';

  const artists = object.get('artists');
  if (!artists || artists.length === 0) return itemName;

  const artistName = artists.get(0).get('name');
  if (!artistName) return itemName;

  return separateDragTextItems(artistName, itemName);
}

/**
 * Get the text for a playlist URI.
 *
 * Examples:
 * Playlist Name – Owner Name
 * Playlist Name – owner_username
 * Playlist Name
 *
 * @param {string} uri Playlist URI.
 *
 * @return {string} The text.
 */
function getForPlaylist(uri) {
  const object = live(uri);
  const itemName = object.get('name');
  if (!itemName) return '';

  const owner = object.get('owner');
  const ownerName = owner && (owner.get('name') || owner.get('username'));
  if (!ownerName) return itemName;

  return separateDragTextItems(itemName, ownerName);
}

/**
 * Get the text for a playlist URI.
 *
 * Examples:
 * User Name
 * username
 *
 * @param {string} uri Playlist URI.
 *
 * @return {string} The text.
 */
function getForUser(uri) {
  const object = live(uri);
  const itemName = object.get('name');
  if (itemName) return itemName;

  const uriObject = liburi.fromString(uri);
  const username = uriObject && uriObject.username;
  return username || '';
}

/**
 * Get the text for a folder URI.
 *
 * Examples:
 * Folder Name
 *
 * @param {string} uri Folder URI.
 *
 * @return {string} The text.
 */
function getForFolder(uri) {
  return live(uri).get('name');
}

/**
 * Get the text for a station URI.
 *
 * Examples:
 * Station Name
 *
 * @param {string} uri Station URI.
 *
 * @return {string} The text.
 */
function getForStation(uri) {
  return live(uri).get('name');
}

/**
 * Get the text for a episode URI.
 *
 * Examples:
 * The Making of "Day of the Dead"
 *
 * @param {string} uri Episode URI.
 *
 * @return {string} The text.
 */
function getForEpisode(uri) {
  return live(uri).get('name');
}

/**
 * Get the text for a show URI.
 *
 * Examples:
 * "Stuff You Should Know"
 *
 * @param {string} uri Show URI.
 *
 * @return {string} The text.
 */
function getForShow(uri) {
  return live(uri).get('name');
}

/**
 * Separate two strings by the special dash ('en dash', &#8211;) we use.
 *
 * @param {string} item1 First string.
 * @param {string} item2 Second string.
 *
 * @return {string} Final string.
 */
function separateDragTextItems(item1, item2) {
  return `${item1} – ${item2}`;
}

/**
 * Get the text for an element.
 *
 * @param {HTMLElement} target The target element being dragged.
 *
 * @return {string} The drag text.
 */
function getForElement(target) {
  let title = target.getAttribute('data-drag-text');
  if (title) return title;

  let uri = target.getAttribute('data-uri');
  if (!uri) {
    const uriObject = liburi.from(target.getAttribute('href'));
    uri = uriObject ? uriObject.toURI() : '';
  }
  if (uri) {
    title = getForUri(uri);
    if (title) return title;
  }

  title = target.getAttribute('title');
  if (title) return title;

  return target.textContent;
}

exports.getForUri = getForUri;
exports.getForElement = getForElement;

},{"../../../live":210,"spotify-liburi":730}],275:[function(require,module,exports){
'use strict';

const $ = require('../spotify-elements');
const live = require('../live');
const dom = require('./util/dom');
const center = require('./center');

const SELECTOR_FEEDBACK_BUTTON = '[data-button=feedback]';
const SELECTOR_HEART_BUTTON = '[data-button=heart]';
const SELECTOR_BAN_BUTTON = '[data-button=contextmenu]';
const SELECTOR_UNDO_HEART_BUTTON = '[data-button=undo-heart]';
const SELECTOR_UNDO_BAN_BUTTON = '[data-button=undo-ban]';
const HEART_CLASSNAME = 'spoticon-heart-16';
const BAN_CLASSNAME = 'spoticon-ban-16';
const ACTIVE_HEART_CLASSNAME = 'spoticon-heart-active-16';
const ACTIVE_BAN_CLASSNAME = 'spoticon-ban-active-16';

let isAttached = false;

/**
 * Handle the click on a Heart feedback button.
 *
 * @param {MouseEvent} event An event object for a click event.
 * @param {HTMLElement} button A button DOM node.
 *
 * @private
 */
function handleFeedbackClick(event, button) {
  const type = dom.getAttributeFromNodeOrParent(event.target, 'data-button');
  const trackUri = dom.getAttributeFromNodeOrParent(button[0], 'data-uri');
  const contextUri = dom.getContextFromNodeOrParent(button[0]);

  if (!trackUri || !contextUri) return;

  // Emit heart / undo-feedback event and update thumb to update UI
  if (type === 'heart') {
    live(contextUri).emit('heart', trackUri);
    live(trackUri).update({ thumb: 'up' });
  } else if (type === 'undo-heart' || type === 'undo-ban') {
    live(contextUri).emit(type, trackUri);
    live(trackUri).update({ thumb: null });
  }
}

function updateFeedbackUI(feedbackContainer, thumbState) {
  const heartBtn = feedbackContainer.querySelector(SELECTOR_HEART_BUTTON) || feedbackContainer.querySelector(SELECTOR_UNDO_HEART_BUTTON);
  const banBtn = feedbackContainer.querySelector(SELECTOR_BAN_BUTTON) || feedbackContainer.querySelector(SELECTOR_UNDO_BAN_BUTTON);
  const trackRow = feedbackContainer.parentNode.classList.contains('tl-row') ? feedbackContainer.parentNode : null;

  const shouldThumbUp = thumbState === 'up';
  const shouldThumbDown = thumbState === 'down';
  const shouldThumbNone = !shouldThumbUp && !shouldThumbDown;

  if (feedbackContainer) {
    feedbackContainer.classList.toggle('thumbs-up', shouldThumbUp);
    feedbackContainer.classList.toggle('thumbs-none', shouldThumbNone);
    feedbackContainer.classList.toggle('thumbs-down', shouldThumbDown);
  }

  if (heartBtn) {
    updateHeartUI(heartBtn, thumbState);
  }

  if (banBtn) {
    updateBanUI(banBtn, thumbState);
  }

  if (trackRow) {
    trackRow.classList.toggle('thumbs-up', shouldThumbUp);
    trackRow.classList.toggle('thumbs-none', shouldThumbNone);
    trackRow.classList.toggle('thumbs-down', shouldThumbDown);
  } else if (heartBtn) {
    // heart gets the active class (green) everywhere except track row
    heartBtn.classList.toggle('active', shouldThumbUp);
  }
}

function updateHeartUI(button, thumbState) {
  if (thumbState === 'up') {
    button.classList.remove(HEART_CLASSNAME);
    button.classList.add(ACTIVE_HEART_CLASSNAME);
    button.setAttribute('data-button', 'undo-heart');

    // update tooltips...
    const tooltipUndo = button.getAttribute('data-tooltip-undo');
    button.setAttribute('data-tooltip', tooltipUndo);
    button.setAttribute('aria-label', tooltipUndo);

    // update intent
    button.setAttribute('data-interaction-intent', 'undo-heart');
  } else if (thumbState === null) {
    button.classList.add(HEART_CLASSNAME);
    button.classList.remove(ACTIVE_HEART_CLASSNAME);
    button.setAttribute('data-button', 'heart');

    // update tooltips...
    const tooltipHeart = button.getAttribute('data-tooltip-heart');
    button.setAttribute('data-tooltip', tooltipHeart);
    button.setAttribute('aria-label', tooltipHeart);

    // update intent
    button.setAttribute('data-interaction-intent', 'heart');
  }
}

function updateBanUI(button, thumbState) {
  if (thumbState === 'down') {
    button.classList.remove(BAN_CLASSNAME);
    button.classList.add(ACTIVE_BAN_CLASSNAME);
    button.setAttribute('data-button', 'undo-ban');

    // update tooltips...
    const tooltipUndo = button.getAttribute('data-tooltip-undo');
    button.setAttribute('data-tooltip', tooltipUndo);
    button.setAttribute('aria-label', tooltipUndo);

    // update intent
    button.setAttribute('data-interaction-intent', 'undo-ban');
  } else if (thumbState === null) {
    button.classList.add(BAN_CLASSNAME);
    button.classList.remove(ACTIVE_BAN_CLASSNAME);
    button.setAttribute('data-button', 'contextmenu');

    // update tooltips...
    const tooltipBan = button.getAttribute('data-tooltip-ban');
    button.setAttribute('data-tooltip', tooltipBan);
    button.setAttribute('aria-label', tooltipBan);

    // update intent
    button.setAttribute('data-interaction-intent', 'show-ban-options');
  }
}

function getURIFromNode(node) {
  const stateNode = node[0].closest('[data-uri]');
  if (!stateNode) {
    return null;
  }
  return stateNode.getAttribute('data-uri');
}

const changeHandlers = {};

const eventHandlers = {
  changeHandler: function (actionsRef, key, value, uri) {
    if (key === 'thumb') {
      const numAffectedButtons = actionsRef.setStateForURI(uri, value);
      if (numAffectedButtons === 0) {
        live(uri).off('update', changeHandlers[uri]);
        delete changeHandlers[uri];
      }
    }
  }
};

const actions = {
  addListenerForNode: function (node) {
    const uri = getURIFromNode(node);

    // If we have already added a change handler for this URI,
    // we don't want to add another one, so we cancel early.
    // Before cancelling though, we should update button states
    // with the current state from the live model, since there
    // might be new buttons in the DOM.
    if (changeHandlers[uri]) {
      live(uri).get('thumb', function (error, thumbState) {
        if (error) throw error;
        actions.setStateForFeedbackNode(node, thumbState);
      }, live.ASAP);
      return;
    }

    changeHandlers[uri] = function (properties) {
      for (const key in properties) {
        if (!properties.hasOwnProperty(key)) continue;
        const value = properties[key];
        eventHandlers.changeHandler(actions, key, value, uri);
      }
    };

    const model = live(uri);

    model.get('thumb', function (error, thumbState) {
      if (error) throw error;
      actions.setStateForFeedbackNode(node, thumbState);

      // when the initial state is known, we listen for updates
      // so we can update all the buttons for this URI later
      model.on('update', changeHandlers[uri]);
    }, live.ASAP);
  },

  setStateForURI: function (uri, thumbState) {
    let numAffectedButtons = 0;

    const nodes = $(document).search(SELECTOR_FEEDBACK_BUTTON);
    if (!nodes) return numAffectedButtons;

    for (let i = 0, l = nodes.length; i < l; i++) {
      const node = $(nodes[i]);
      const buttonURI = getURIFromNode(node);
      if (uri === buttonURI) {
        numAffectedButtons++;
        actions.setStateForFeedbackNode(node, thumbState);
      }
    }

    return numAffectedButtons;
  },

  setStateForFeedbackNode: function (node, thumbState) {
    const feedbackNode = $(node[0].closest('[data-button="feedback"]'));
    if (!feedbackNode) return;
    updateFeedbackUI(feedbackNode[0], thumbState);
  }
};

const update = exports.update = function (node, nodes) {
  if (!isAttached) return;

  // If the node passed in is a button node, just add listeners for that
  if (node && $(node).matches(SELECTOR_FEEDBACK_BUTTON)) {
    actions.addListenerForNode($(node));

    // Otherwise search all the children of the node (or the document
    // if node is not provided) for buttons.
  } else {
    const innerNodes = $(nodes) || $(node) || $(document).search(SELECTOR_FEEDBACK_BUTTON);
    if (!innerNodes) return;

    for (let i = 0, l = innerNodes.length; i < l; i++) {
      actions.addListenerForNode($(innerNodes[i]));
    }
  }
};

const handleScrollShow = function (data) {
  update(data.pageNode, data.nodes);
};

/**
 * Attach the event listeners for the module.
 * Part of the spotify-events interface.
 */
exports.attach = function () {
  if (isAttached) return;
  isAttached = true;

  const doc = $(document);
  doc.delegate('click', SELECTOR_FEEDBACK_BUTTON, handleFeedbackClick);

  center.on('scroll-show-before', handleScrollShow);
};

/**
 * Detach the event listeners for the module.
 * Part of the spotify-events interface.
 */
exports.detach = function () {
  if (!isAttached) return;
  isAttached = false;

  const doc = $(document);
  doc.undelegate('click', SELECTOR_FEEDBACK_BUTTON, handleFeedbackClick);

  center.off('scroll-show-before', handleScrollShow);
};

},{"../live":210,"../spotify-elements":251,"./center":262,"./util/dom":332}],276:[function(require,module,exports){
'use strict';

const $ = require('../spotify-elements');
const live = require('../live');
const center = require('./center');
const stickyEvents = require('./sticky');
const cosmos = require('./util/cosmos');
const merge = require('mout/object/merge');
const deepEquals = require('mout/lang/deepEquals');
const getOriginUri = require('../live-wrapped-uri').getOriginUri;
const appUtil = require('./util/app');

const SCROLL_PADDING = 8;
const STRING_FILTER_KEY = 'list-filter-string-';
const SESSION_STORAGE = 'spotify:session-storage';

let isAttached = false;
let states;
let lastEmittedStates;

let controlMessageSubscription;

function update(node) {
  if (!isAttached) return;

  const newNode = $(node) || $(document);
  const nodes = newNode.matches('[data-filter]') ? [newNode[0]] : newNode.search('[data-filter]');
  if (!nodes) {
    return;
  }
  nodes.forEach(function (n) {
    const uri = getURI(n);
    if (!uri) {
      return;
    }

    // When no state is initialized for the uri, initialize it and set the string from the DOM.
    // This is the case when the playlist app loaded a URI that globally has a filter string set.
    const hasState = states[uri];
    if (!hasState) {
      const inputElement = $(n).find('input[type=text]')[0];
      const value = inputElement.value;
      if (value) {
        updateState(uri, {
          activated: true,
          enteredString: value
        });
      }
    }

    handleStale(uri);
  });
}

function handleStale(uri) {
  render(uri);
  logUsage(uri);

  const state = getState(uri);
  const stateHasBeenEmitted = deepEquals(state, lastEmittedStates[uri]);
  if (!stateHasBeenEmitted) {
    lastEmittedStates[uri] = state;
    const value = state.activated ? state.enteredString : '';
    emitFilterRequest(uri, value);
    persistFilterOnSessionStorage(uri, value);
  }
}

function render(uri) {
  const $candidateContainers = $(document).search('[data-uri] [data-filter]');
  if (!$candidateContainers) return;

  const $matchingCandidates = $candidateContainers.filter(function (container) {
    return getURI(container) === uri;
  });
  $matchingCandidates.forEach(function (mainElement) {
    const state = getState(uri);
    const inputElement = $(mainElement).find('input[type=text]')[0];
    const wrapperElement = $(mainElement).find('.h-search-wrapper')[0];
    if (state.activated) {
      if (!$(wrapperElement).hasClass('focus')) {
        $(wrapperElement).addClass('focus');

        mainElement.setAttribute('data-sticky', '');
        stickyEvents.update();
      }

      // NOTE: Setting input.value makes the cursor jump
      // which is annoying when changing typos in the
      // search field. Only set value if text ACTUALLY
      // changes:
      if (inputElement.value !== state.enteredString) {
        inputElement.value = state.enteredString;
      }
    } else {
      inputElement.blur();
      if ($(wrapperElement).hasClass('focus')) {
        $(wrapperElement).removeClass('focus');

        mainElement.removeAttribute('data-sticky');
        stickyEvents.update();
      }
      inputElement.value = '';
    }
  });
}

function focusAndSelectInput(inputElement) {
  // Only focus and select the input text if doesn't have focus already.
  if (document.activeElement !== inputElement) {
    inputElement.focus();
    inputElement.select();
  }
}

function scrollIntoView(inputElement) {
  const rect = inputElement.getBoundingClientRect();

  // Only scroll if the input is out of view
  const filterFieldOffset = rect.top - SCROLL_PADDING;
  if (filterFieldOffset < 0 || rect.bottom > window.innerHeight) {
    window.scrollTo(0, window.pageYOffset + filterFieldOffset);
  }
}

function logUsage(uri) {
  const state = getState(uri);
  if (state.enteredString && !getState(uri).usageLogged) {
    updateState(uri, { usageLogged: true });
    // Fields must be in the same order as in logparser
    // AND all fields MUST be present or logging wont happen
    // and will fail silently. https://ghe.spotify.net/datainfra/log-parser/blob/94e6a896efa5d781b0cac54f3dcf92c9c4ee3c73/spotify/log_parser/messages_specs.py#L777

    cosmos.post({
      url: 'sp://logging/v3/log',
      body: {
        message: 'ClientEvent',
        version: 3,
        fields: [window.__spotify.app_uri, // source
        'spotify-events-filter', // context
        'user:typing', // event
        'input-field', // event-version
        '', // test-version
        '', // source-version
        '', // source-vendor
        '']
      }
    });
  }
}

function emitFilterRequest(uri, value) {
  center.emit('filter-request', uri, value);
}

function persistFilterOnSessionStorage(uri, value) {
  const newUri = getOriginUri(uri) || uri;

  const key = STRING_FILTER_KEY + newUri;
  const publish = {};
  publish[key] = value;
  live(SESSION_STORAGE).publish(publish);
}

function handleCancelClick(e) {
  clear(getURI(e.target));
}

function handleInputInput(e) {
  updateState(getURI(e.target), { enteredString: e.target.value });
}

function handleInputKeyup(e) {
  const isEscape = e.keyCode === 27;
  if (isEscape) {
    clear(getURI(e.target));
  }
}

function handleInputFocus(e) {
  updateState(getURI(e.target), { activated: true });
}
function handleInputFocusOut(e) {
  const state = getState(getURI(e.target));
  if (state.enteredString === '') {
    updateState(getURI(e.target), { activated: false });
  }
}

function clear(uri) {
  updateState(uri, { activated: false, enteredString: '' });
}

function getState(uri) {
  return states[uri] || {
    activated: false,
    enteredString: ''
  };
}

function updateState(uri, newUpdateState) {
  states[uri] = merge(getState(uri), newUpdateState);
  handleStale(uri);
}

function getURI(element) {
  let uri = element.getAttribute('data-uri');
  if (!uri) {
    const parents = $(element).parents('[data-uri]');
    if (parents) {
      uri = parents[0].getAttribute('data-uri');
    }
  }
  uri = getOriginUri(uri) || uri;

  // We use the data-uri as a key for state, but the uri of the
  // container might change to the "sorted" versions of the
  // original uri. From a filter UX state standpoint, these are the
  // same, so we normalize it here.
  return uri || null;
}

const attach = function attach() {
  if (isAttached) {
    return;
  }
  isAttached = true;
  states = {};
  lastEmittedStates = {};
  controlMessageSubscription = cosmos.subscribe({
    url: 'sp://messages/v1/container/control'
  }, function (_, response) {
    if (!appUtil.isActive()) return;

    const isMessageOfTypeFind = response && response.body && response.body.type === 'filter';
    if (!isMessageOfTypeFind) return;
    $('[data-filter]').forEach(function (mainElement, i) {
      updateState(getURI(mainElement), {
        activated: true
      });

      const inputElement = $(mainElement).find('input[type=text]')[0];
      if (inputElement) {
        // Only scroll first filter into view.
        if (i === 0) {
          scrollIntoView(inputElement);
        }

        focusAndSelectInput(inputElement);
      }
    });
  });

  center.on('filter-reset', clear);

  $(document).delegate('click', '[data-filter] .h-search-close', handleCancelClick);
  $(document).delegate('click', '[data-filter-reset]', handleCancelClick);
  $(document).delegate('input', '[data-filter] input', handleInputInput);
  $(document).delegate('keyup', '[data-filter] input', handleInputKeyup);
  $(document).delegate('focusin', '[data-filter] input', handleInputFocus);
  $(document).delegate('focusout', '[data-filter] input', handleInputFocusOut);
};

const detach = function detach() {
  if (!isAttached) return;
  states = null;
  controlMessageSubscription.cancel();

  center.off('filter-reset', clear);

  $(document).undelegate('click', '[data-filter] .h-search-close', handleCancelClick);
  $(document).undelegate('click', '[data-filter-reset]', handleCancelClick);
  $(document).undelegate('input', '[data-filter] input', handleInputInput);
  $(document).undelegate('keyup', '[data-filter] input', handleInputKeyup);
  $(document).undelegate('focusin', '[data-filter] input', handleInputFocus);
  $(document).undelegate('focusout', '[data-filter] input', handleInputFocusOut);
  isAttached = false;
};

// Tells native container that the current app can handle filter
// commands. Enables filter commands in the native menu,
// along with corresponding keyboard shortcuts.
const broadcast = function broadcast(enabled) {
  if (enabled === undefined) {
    throw new Error('broadcast requires enabled argument');
  }
  cosmos.post({
    url: 'sp://messages/v1/container/control',
    body: {
      type: 'update_menu_state',
      enable_filter_item: enabled
    }
  });
};

module.exports = {
  attach: attach,
  detach: detach,
  update: update,
  broadcast: broadcast
};

},{"../live":210,"../live-wrapped-uri":209,"../spotify-elements":251,"./center":262,"./sticky":325,"./util/app":330,"./util/cosmos":331,"mout/lang/deepEquals":462,"mout/object/merge":479}],277:[function(require,module,exports){
(function (global){
'use strict';

var _glue = require('../glue');

var _glue2 = _interopRequireDefault(_glue);

var _frameUpdater = require('../frame-updater');

var _cancellationTokenSource = require('../cancellation-token-source');

var _cancellationTokenSource2 = _interopRequireDefault(_cancellationTokenSource);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Export _-prefixed functions for unit tests. This is so that we don't have to
// repeat all the tests for the contents of these functions in all situations
// it's run in and lets us test the functions as units and test that the various
// situations call these functions.

let isAttached = false;
let isFontLoaded = false;
let topBarHeight = 0;
let headerHeight = 0;
let lastHeaderHeight = 0;
let stickyHeight = 0;
let currentScrollY = 0;
let lastScrollY = 0;
let lastScrollYDiffs = [0, 0, 0, 0, 0];
let lastLoadedImageNode = null;
let scrollListenerId = 0;
let needsTitleSizeUpdate = true;
let lastUpdatedTitleNode = null;
let lastUpdatedTitleContent = '';
let fontPromise = null;
let cancellationTokenSource = null;
let frameRequestIds = [];
let lastHeaderNode = null;
let scrollNode = null;
let lastDescriptionNode = null;
let lastDescriptionMouseEnterHandler = null;
let lastDescriptionMouseLeaveHandler = null;
let fullDescriptionNode = null;

exports._updateHeader = function _updateHeader() {
  const header = document.querySelector('[data-glue-page-header]');

  // Optimize to only run header updates when scrolling within the header area
  // at the top of the page, and also when the current scroll event is below the
  // header but the previous event was within the header.
  if (header !== lastHeaderNode || currentScrollY < headerHeight || lastScrollY < headerHeight || headerHeight !== lastHeaderHeight) {
    lastHeaderNode = header;
    lastHeaderHeight = headerHeight;

    removeDescriptionHandlers();
    addDescriptionHandlers();

    updateHeaderBackgroundPosition();
    updateHeaderAlphaMask();
    updateHeaderBackgroundScrollOverlay();
    updateHeaderBackgroundScrollOverlayEllipse();
    updateHeaderImageScaling();
  }
};

// This function runs first in each update cycle and sets variables scoped to
// the module. Ideally each function would just read the value it needs, but for
// performance reasons we do this once at the start of each update.
exports._updateHeaderSizes = function _updateHeaderSizes() {
  const header = document.querySelector('[data-glue-page-header]');
  if (header) {
    const node = scrollNode === document ? document.documentElement : scrollNode;
    topBarHeight = parseInt(node.getAttribute('data-top-bar-height'), 10) || 0;
    headerHeight = header.offsetHeight;
    stickyHeight = parseInt(header.getAttribute('data-glue-page-header-sticky-height'), 10) || 0;
  } else {
    topBarHeight = 0;
    headerHeight = 0;
    stickyHeight = 0;
  }
};

function updateHeaderAlphaMask() {
  const headerContent = document.querySelector('[data-glue-page-header-content]');
  if (headerContent) {
    const maskHeight = 24;
    const offset1 = currentScrollY + topBarHeight;
    const offset2 = offset1 + maskHeight;

    headerContent.style.webkitMaskImage = `linear-gradient(to bottom, transparent ${offset1}px, black ${offset2}px)`;
  }
}

function updateHeaderBackgroundPosition() {
  const headerBackground = document.querySelector('[data-glue-page-header-background]');
  if (headerBackground) {
    const isSticky = currentScrollY > headerHeight - stickyHeight;
    headerBackground.style.position = isSticky ? 'fixed' : '';
    headerBackground.style.top = isSticky ? `-${headerHeight - stickyHeight}px` : '';
    // JSDom v3 doesn't seem to support the `auto` keyword as a value for bottom
    // so we set it on a different property to be able to test it in unit tests.
    headerBackground.style._bottom = isSticky ? 'auto' : '';
    headerBackground.style.bottom = headerBackground.style._bottom;
    headerBackground.style.height = isSticky ? `${headerHeight}px` : '';
  }

  const headerImage = document.querySelector('[data-glue-page-header-background-image]');
  if (headerImage) {
    const currentTransform = headerImage.style.transform || '';
    headerImage.style.transform = `${currentTransform.replace(/translateY\(.*?\)/, '')} translateY(${Math.min(currentScrollY, headerHeight - stickyHeight)}px)`.trim();
  }
}

function updateHeaderBackgroundScrollOverlay() {
  const scrollOverlay = document.querySelector('[data-glue-page-header-background-scroll-overlay]');
  if (scrollOverlay) {
    const maxOpacity = 0.4;
    scrollOverlay.style.opacity = Math.round(Math.min(1, currentScrollY / (headerHeight - stickyHeight)) * maxOpacity * 1000) / 1000;
  }
}

function updateHeaderBackgroundScrollOverlayEllipse() {
  const scrollPercentage = Math.min(1, currentScrollY / (headerHeight - stickyHeight));

  const scrollOverlay = document.querySelector('[data-glue-page-header-background-scroll-overlay-ellipse]');
  if (scrollOverlay) {
    scrollOverlay.style.opacity = Math.round(Math.min(1, scrollPercentage * 2) * 1000) / 1000;
  }

  const scrollOverlayBackdrop = document.querySelector('[data-glue-page-header-background-scroll-overlay-ellipse-backdrop]');
  if (scrollOverlayBackdrop) {
    scrollOverlayBackdrop.style.opacity = Math.round(scrollPercentage * 1000) / 1000;
  }
}

function updateHeaderImageScaling() {
  const headerImage = document.querySelector('[data-glue-page-header-background-image]');
  if (headerImage) {
    const loader = document.querySelector('[data-glue-page-header-background-image-loader]');
    const isImageLoaded = loader ? loader.classList.contains('glue-page-header__background-image-loader--is-loaded') : false;
    if (isImageLoaded) {
      const maxScale = 1.07;
      const minScale = 1;
      const scrollPercentage = Math.min(1, currentScrollY / (headerHeight - stickyHeight));
      const scale = Math.round((maxScale - scrollPercentage * (maxScale - minScale)) * 1000) / 1000;
      const currentTransform = headerImage.style.transform || '';
      headerImage.style.transform = `${currentTransform.replace(/scale\(.*?\)/, '')} scale(${scale})`.trim();
    }
  }
}

function addDescriptionHandlers() {
  const headerNode = document.querySelector('[data-glue-page-header]');
  const descriptionNode = document.querySelector('[data-glue-page-header-description]');
  if (!headerNode || !descriptionNode) {
    return;
  }

  lastDescriptionNode = descriptionNode;

  lastDescriptionMouseEnterHandler = event => {
    // Only show the full description if it doesn't fit already.
    if (event.target.scrollHeight !== event.target.clientHeight) {
      const rect = event.target.getBoundingClientRect();
      fullDescriptionNode = event.target.cloneNode(true);
      fullDescriptionNode.addEventListener('mouseleave', lastDescriptionMouseLeaveHandler);
      fullDescriptionNode.classList.add('glue-page-header__full-description-overlay');
      fullDescriptionNode.style.top = `${rect.top}px`;
      fullDescriptionNode.style.left = `${rect.left}px`;
      fullDescriptionNode.style.width = `${rect.width}px`;
      headerNode.appendChild(fullDescriptionNode);
    }
  };

  lastDescriptionMouseLeaveHandler = event => {
    // Hide the full description if leaving the description area, but only if
    // the user is not hovering the full description or any link inside of it.
    if (fullDescriptionNode && event.relatedTarget !== fullDescriptionNode && !fullDescriptionNode.contains(event.relatedTarget)) {
      fullDescriptionNode.parentNode.removeChild(fullDescriptionNode);
      fullDescriptionNode.removeEventListener('mouseleave', lastDescriptionMouseLeaveHandler);
      fullDescriptionNode = null;
    }
  };

  lastDescriptionNode.addEventListener('mouseenter', lastDescriptionMouseEnterHandler);
  lastDescriptionNode.addEventListener('mouseleave', lastDescriptionMouseLeaveHandler);
}

function removeDescriptionHandlers() {
  if (fullDescriptionNode) {
    fullDescriptionNode.removeEventListener('mouseleave', lastDescriptionMouseLeaveHandler);
    fullDescriptionNode.parentNode.removeChild(fullDescriptionNode);
    fullDescriptionNode = null;
  }

  if (lastDescriptionMouseEnterHandler) {
    lastDescriptionNode.removeEventListener('mouseenter', lastDescriptionMouseEnterHandler);
    lastDescriptionMouseEnterHandler = null;
  }

  if (lastDescriptionMouseLeaveHandler) {
    lastDescriptionNode.removeEventListener('mouseleave', lastDescriptionMouseLeaveHandler);
    lastDescriptionMouseLeaveHandler = null;
  }

  lastDescriptionNode = null;
}

exports._updateTitleTypeSize = function _updateTitleTypeSize() {
  const title = document.querySelector('[data-glue-page-header-content] [data-glue-page-header-title]');
  if (title) {
    // Optimize performance by only updating if specifically needed (triggered
    // by resize for example) or if the title node is different or if title
    // content changed.
    const isNewNode = title !== lastUpdatedTitleNode;
    const isNewContent = title.textContent !== lastUpdatedTitleContent;
    if (title && (needsTitleSizeUpdate || isNewNode || isNewContent)) {
      needsTitleSizeUpdate = false;
      lastUpdatedTitleNode = title;
      lastUpdatedTitleContent = title.textContent;

      _glue2.default.responsiveTitleType.setSizeForTitle(title, {
        useLargeTitle: title.hasAttribute('data-glue-page-header-use-large-title')
      });

      // Force an update of sizes since it might have changed due to title size
      exports._updateHeaderSizes();
    }
  }
};

exports._updateScrollClassNames = function _updateScrollClassNames() {
  const header = document.querySelector('[data-glue-page-header]');
  if (header) {
    const hasNewHeaderNode = !header._hasBeenSeen;

    // Disable header animations when the header node changes. This solves the
    // problem where the header content would otherwise animate when switching
    // between playlists.
    if (hasNewHeaderNode) {
      header._hasBeenSeen = true;
      header.classList.add('glue-page-header--with-no-animations');
    } else {
      frameRequestIds.push((0, _frameUpdater.requestFrame)(null, () => {
        header.classList.remove('glue-page-header--with-no-animations');
      }));
    }

    lastScrollYDiffs.push(Math.abs(currentScrollY - lastScrollY));
    lastScrollYDiffs.shift();

    const threshold = 30;
    const isScrollingFast = lastScrollYDiffs.reduce((isFast, diff) => {
      return isFast || diff > threshold;
    }, false);

    // This allows the header to go into a fast scroll mode where the header
    // animations are tweaked a bit.
    if (isScrollingFast) {
      header.classList.add('glue-page-header--with-fast-scrolling');
    } else {
      header.classList.remove('glue-page-header--with-fast-scrolling');
    }

    if (global.onPageHeaderToggleFastScrolling) {
      global.onPageHeaderToggleFastScrolling(isScrollingFast);
    }
  }
};

exports._updateHeaderImageLoading = function _updateHeaderImageLoading() {
  const headerImage = document.querySelector('[data-glue-page-header-background-image]');

  if (headerImage) {
    if (headerImage === lastLoadedImageNode) {
      return;
    }

    const imageUrl = headerImage.getAttribute('data-glue-page-header-background-image-url');

    lastLoadedImageNode = headerImage;

    if (imageUrl) {
      const image = new window.Image();
      image.onload = () => {
        const loader = document.querySelector('[data-glue-page-header-background-image-loader]');

        if (!loader.classList.contains('glue-page-header__background-image-loader--is-loaded')) {
          loader.classList.add('glue-page-header__background-image-loader--is-loaded');
          loader.classList.add('glue-page-header__background-image-loader--with-loading-animation');
          updateHeaderImageScaling();

          loader.addEventListener('transitionend', function handler() {
            loader.removeEventListener('transitionend', handler);
            loader.classList.remove('glue-page-header__background-image-loader--with-loading-animation');
          });
        }
      };
      image.src = imageUrl;
    }
  }
};

exports._updateScrollValue = function _updateScrollValue() {
  currentScrollY = scrollNode === document ? window.scrollY : scrollNode.scrollTop;
};

exports._updateLastScrollValue = function _updateLastScrollValue() {
  lastScrollY = currentScrollY;
};

function handleResize() {
  needsTitleSizeUpdate = true;

  exports._ensureFontIsLoaded(error => {
    if (error) {
      console.error(error);
      return;
    }
    exports._updateTitleTypeSize();
    exports._updateHeaderSizes();
    exports._updateHeader();
  });
}

exports._ensureFontIsLoaded = function _ensureFontIsLoaded(callback) {
  if (isFontLoaded) {
    callback(null);
    return;
  }
  if (!fontPromise) {
    fontPromise = _glue2.default.responsiveTitleType.loadFont();
  }
  const token = cancellationTokenSource.token();
  fontPromise.then(() => {
    if (token.isCanceled()) {
      callback(token.operationCanceledError());
      return;
    }
    isFontLoaded = true;
    callback(null);
  }, fontPromiseError => {
    callback(token.errorIfCanceled() || fontPromiseError);
  });
};

exports.attach = function attach() {
  if (!isAttached) {
    isAttached = true;
    cancellationTokenSource = new _cancellationTokenSource2.default();

    if (!scrollNode) {
      scrollNode = document;
    }

    exports._ensureFontIsLoaded(error => error && console.error(error));
    exports._updateHeaderSizes();

    scrollListenerId = (0, _frameUpdater.addDebouncedScrollListener)(scrollNode, () => {
      exports._updateScrollValue();
    }, () => {
      exports._updateScrollClassNames();
      exports._updateHeader();
      exports._updateLastScrollValue();
    });

    window.addEventListener('resize', handleResize);
  }
};

exports.detach = function detach() {
  if (isAttached) {
    cancellationTokenSource.cancel();
    cancellationTokenSource = null;

    frameRequestIds.forEach(id => {
      (0, _frameUpdater.cancelFrame)(id);
    });
    frameRequestIds = [];

    removeDescriptionHandlers();

    isAttached = false;
    isFontLoaded = false;
    fontPromise = null;
    headerHeight = 0;
    stickyHeight = 0;
    currentScrollY = 0;
    lastScrollY = 0;
    lastScrollYDiffs = [0, 0, 0, 0, 0];
    needsTitleSizeUpdate = true;
    lastUpdatedTitleNode = null;
    lastUpdatedTitleContent = '';
    scrollNode = null;
    lastDescriptionNode = null;
    lastDescriptionMouseEnterHandler = null;
    lastDescriptionMouseLeaveHandler = null;
    fullDescriptionNode = null;

    (0, _frameUpdater.removeDebouncedScrollListener)(scrollListenerId);
    window.removeEventListener('resize', handleResize);
  }
};

exports.update = function update() {
  if (!isAttached) {
    return;
  }

  frameRequestIds.push((0, _frameUpdater.requestFrame)(() => {
    exports._updateScrollValue();
  }, () => {
    exports._updateScrollClassNames();
    exports._updateHeaderImageLoading();
  }));

  exports._ensureFontIsLoaded(error => {
    if (error) {
      console.error(error);
      return;
    }
    frameRequestIds.push((0, _frameUpdater.requestFrame)(() => {
      exports._updateHeaderSizes();
    }, () => {
      exports._updateTitleTypeSize();
      exports._updateHeader();
    }));
  });
};

// A way to let an app override the node to listen for scroll events on.
// This has to be called before `attach` is called.
exports.setScrollNode = function setScrollNode(node) {
  scrollNode = node;
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../cancellation-token-source":87,"../frame-updater":93,"../glue":118}],278:[function(require,module,exports){
arguments[4][1][0].apply(exports,arguments)
},{"../../../libs/spotify-i18n":353,"./json/cs.json":279,"./json/de.json":280,"./json/el.json":281,"./json/en.json":282,"./json/es-419.json":283,"./json/es.json":284,"./json/fi.json":285,"./json/fr-CA.json":286,"./json/fr.json":287,"./json/hu.json":288,"./json/id.json":289,"./json/it.json":290,"./json/ja.json":291,"./json/nl.json":292,"./json/pl.json":293,"./json/pt-BR.json":294,"./json/sv.json":295,"./json/th.json":296,"./json/tr.json":297,"./json/vi.json":298,"./json/zh-Hant.json":299,"./json/zsm.json":300,"dup":1}],279:[function(require,module,exports){
module.exports={
  "drag_tooltip_many_items": {
    "one": "1 položka",
    "other": "Počet položek: {0}"
  },
  "drag_tooltip_many_tracks": {
    "one": "1 skladba",
    "other": "Počet skladeb: {0}"
  },
  "drag_tooltip_many_artists": {
    "one": "1 umělec",
    "other": "Počet umělců: {0}"
  },
  "drag_tooltip_many_albums": {
    "one": "1 album",
    "other": "Počet alb: {0}"
  },
  "drag_tooltip_many_playlists": {
    "one": "1 playlist",
    "other": "{0} playlistů"
  },
  "drag_tooltip_many_users": {
    "one": "1 uživatel",
    "other": "Počet uživatelů: {0}"
  }
}
},{}],280:[function(require,module,exports){
module.exports={
  "drag_tooltip_many_items": {
    "one": "1 Element",
    "other": "{0} Elemente"
  },
  "drag_tooltip_many_tracks": {
    "one": "1 Titel",
    "other": "{0} Titel"
  },
  "drag_tooltip_many_artists": {
    "one": "1 Künstler",
    "other": "{0} Künstler"
  },
  "drag_tooltip_many_albums": {
    "one": "1 Album",
    "other": "{0} Alben"
  },
  "drag_tooltip_many_playlists": {
    "one": "1 Playlist",
    "other": "{0} Playlists"
  },
  "drag_tooltip_many_users": {
    "one": "1 User",
    "other": "{0} User"
  }
}
},{}],281:[function(require,module,exports){
module.exports={
  "drag_tooltip_many_items": {
    "one": "1 στοιχείο",
    "other": "{0} στοιχεία"
  },
  "drag_tooltip_many_tracks": {
    "one": "1 κομμάτι",
    "other": "{0} κομμάτια"
  },
  "drag_tooltip_many_artists": {
    "one": "1 καλλιτέχνης",
    "other": "{0} καλλιτέχνες"
  },
  "drag_tooltip_many_albums": {
    "one": "1 άλμπουμ",
    "other": "{0} άλμπουμ"
  },
  "drag_tooltip_many_playlists": {
    "one": "1 playlist",
    "other": "{0} λίστες"
  },
  "drag_tooltip_many_users": {
    "one": "1 χρήστης",
    "other": "{0} χρήστες"
  }
}
},{}],282:[function(require,module,exports){
module.exports={
  "drag_tooltip_many_items": {
    "one": "1 item",
    "other": "{0} items"
  },
  "drag_tooltip_many_tracks": {
    "one": "1 track",
    "other": "{0} tracks"
  },
  "drag_tooltip_many_artists": {
    "one": "1 artist",
    "other": "{0} artists"
  },
  "drag_tooltip_many_albums": {
    "one": "1 album",
    "other": "{0} albums"
  },
  "drag_tooltip_many_playlists": {
    "one": "1 playlist",
    "other": "{0} playlists"
  },
  "drag_tooltip_many_users": {
    "one": "1 user",
    "other": "{0} users"
  }
}
},{}],283:[function(require,module,exports){
module.exports={
  "drag_tooltip_many_items": {
    "one": "1 elemento",
    "other": "{0} elementos"
  },
  "drag_tooltip_many_tracks": {
    "one": "1 canción",
    "other": "{0} canciones"
  },
  "drag_tooltip_many_artists": {
    "one": "1 artista",
    "other": "{0} artistas"
  },
  "drag_tooltip_many_albums": {
    "one": "1 álbum",
    "other": "{0} álbumes"
  },
  "drag_tooltip_many_playlists": {
    "one": "1 playlist",
    "other": "Playlists de {0}"
  },
  "drag_tooltip_many_users": {
    "one": "1 usuario",
    "other": "{0} usuarios"
  }
}
},{}],284:[function(require,module,exports){
module.exports={
  "drag_tooltip_many_items": {
    "one": "1 elemento",
    "other": "{0} elementos"
  },
  "drag_tooltip_many_tracks": {
    "one": "1 canción",
    "other": "{0} canciones"
  },
  "drag_tooltip_many_artists": {
    "one": "1 artista",
    "other": "{0} artistas"
  },
  "drag_tooltip_many_albums": {
    "one": "1 álbum",
    "other": "{0} álbumes"
  },
  "drag_tooltip_many_playlists": {
    "one": "1 playlist",
    "other": "{0} playlists"
  },
  "drag_tooltip_many_users": {
    "one": "1 usuario",
    "other": "{0} usuarios"
  }
}
},{}],285:[function(require,module,exports){
module.exports={
  "drag_tooltip_many_items": {
    "one": "1 kohde",
    "other": "{0} kohdetta"
  },
  "drag_tooltip_many_tracks": {
    "one": "1 kappale",
    "other": "{0} kappaletta"
  },
  "drag_tooltip_many_artists": {
    "one": "1 artisti",
    "other": "{0} artistia"
  },
  "drag_tooltip_many_albums": {
    "one": "1 albumi",
    "other": "{0} albumia"
  },
  "drag_tooltip_many_playlists": {
    "one": "1 soittolista",
    "other": "{0} soittolistaa"
  },
  "drag_tooltip_many_users": {
    "one": "1 käyttäjä",
    "other": "{0} käyttäjää"
  }
}
},{}],286:[function(require,module,exports){
module.exports={
  "drag_tooltip_many_items": {
    "one": "1 article",
    "other": "{0} articles"
  },
  "drag_tooltip_many_tracks": {
    "one": "1 chanson",
    "other": "{0} chansons"
  },
  "drag_tooltip_many_artists": {
    "one": "1 artiste",
    "other": "{0} artistes"
  },
  "drag_tooltip_many_albums": {
    "one": "1 album",
    "other": "{0} albums"
  },
  "drag_tooltip_many_playlists": {
    "one": "1 liste de lecture",
    "other": "{0} listes de lecture"
  },
  "drag_tooltip_many_users": {
    "one": "1 utilisateur",
    "other": "{0} utilisateur"
  }
}
},{}],287:[function(require,module,exports){
module.exports={
  "drag_tooltip_many_items": {
    "one": "1 élément",
    "other": "{0} éléments"
  },
  "drag_tooltip_many_tracks": {
    "one": "1 titre",
    "other": "{0} titres"
  },
  "drag_tooltip_many_artists": {
    "one": "1 artiste",
    "other": "{0} artistes"
  },
  "drag_tooltip_many_albums": {
    "one": "1 album",
    "other": "{0} albums"
  },
  "drag_tooltip_many_playlists": {
    "one": "1 playlist",
    "other": "{0} playlists"
  },
  "drag_tooltip_many_users": {
    "one": "1 utilisateur",
    "other": "{0} utilisateurs"
  }
}
},{}],288:[function(require,module,exports){
module.exports={
  "drag_tooltip_many_items": {
    "one": "1 elem",
    "other": "{0} elem"
  },
  "drag_tooltip_many_tracks": {
    "one": "1 dal",
    "other": " {0} dal"
  },
  "drag_tooltip_many_artists": {
    "one": "1 előadó",
    "other": "{0} előadó"
  },
  "drag_tooltip_many_albums": {
    "one": "1 album",
    "other": "{0} album"
  },
  "drag_tooltip_many_playlists": {
    "one": "1 műsorlista",
    "other": "{0} lejátszási lista"
  },
  "drag_tooltip_many_users": {
    "one": "1 felhasználó",
    "other": "{0} felhasználó"
  }
}
},{}],289:[function(require,module,exports){
module.exports={
  "drag_tooltip_many_items": {
    "one": "1 item",
    "other": "{0} item"
  },
  "drag_tooltip_many_tracks": {
    "one": "1 lagu",
    "other": "{0} lagu"
  },
  "drag_tooltip_many_artists": {
    "one": "1 artis",
    "other": "{0} artis"
  },
  "drag_tooltip_many_albums": {
    "one": "1 album",
    "other": "{0} album"
  },
  "drag_tooltip_many_playlists": {
    "one": "1 playlist",
    "other": "{0} playlist"
  },
  "drag_tooltip_many_users": {
    "one": "1 pengguna",
    "other": "{0} pengguna"
  }
}
},{}],290:[function(require,module,exports){
module.exports={
  "drag_tooltip_many_items": {
    "one": "1 elemento",
    "other": "{0} elementi"
  },
  "drag_tooltip_many_tracks": {
    "one": "1 brano",
    "other": "{0} brani"
  },
  "drag_tooltip_many_artists": {
    "one": "1 artista",
    "other": "{0} artisti"
  },
  "drag_tooltip_many_albums": {
    "one": "1 album",
    "other": "{0} album"
  },
  "drag_tooltip_many_playlists": {
    "one": "1 playlist",
    "other": "{0} playlist"
  },
  "drag_tooltip_many_users": {
    "one": "1 utente",
    "other": "{0} utenti"
  }
}
},{}],291:[function(require,module,exports){
module.exports={
  "drag_tooltip_many_items": {
    "one": "1個のアイテム",
    "other": "{0}個のアイテム"
  },
  "drag_tooltip_many_tracks": {
    "one": "1曲",
    "other": "{0}曲"
  },
  "drag_tooltip_many_artists": {
    "one": "1人のアーティスト",
    "other": "{0}人のアーティスト"
  },
  "drag_tooltip_many_albums": {
    "one": "1枚のアルバム",
    "other": "{0}枚のアルバム"
  },
  "drag_tooltip_many_playlists": {
    "one": "1つのプレイリスト",
    "other": "{0}個のプレイリスト"
  },
  "drag_tooltip_many_users": {
    "one": "1人のユーザー",
    "other": "{0}人のユーザー"
  }
}
},{}],292:[function(require,module,exports){
module.exports={
  "drag_tooltip_many_items": {
    "one": "1 item",
    "other": "{0} items"
  },
  "drag_tooltip_many_tracks": {
    "one": "1 nummer",
    "other": "{0} nummers"
  },
  "drag_tooltip_many_artists": {
    "one": "1 artist",
    "other": "{0} artiesten"
  },
  "drag_tooltip_many_albums": {
    "one": "1 album",
    "other": "{0} albums"
  },
  "drag_tooltip_many_playlists": {
    "one": "1 afspeellijst",
    "other": "{0} afspeellijsten"
  },
  "drag_tooltip_many_users": {
    "one": "1 gebruiker",
    "other": "{0} gebruikers"
  }
}
},{}],293:[function(require,module,exports){
module.exports={
  "drag_tooltip_many_items": {
    "one": "1 element",
    "other": "Elementy: {0}"
  },
  "drag_tooltip_many_tracks": {
    "one": "1utwór",
    "other": "Liczba utworów: {0}"
  },
  "drag_tooltip_many_artists": {
    "one": "1 wykonawca",
    "other": "Wykonawcy: {0}"
  },
  "drag_tooltip_many_albums": {
    "one": "1 album",
    "other": "Albumy: {0}"
  },
  "drag_tooltip_many_playlists": {
    "one": "1 playlista",
    "other": "{0} playlisty"
  },
  "drag_tooltip_many_users": {
    "one": "1 użytkownik",
    "other": "Użytkownicy: {0}"
  }
}
},{}],294:[function(require,module,exports){
module.exports={
  "drag_tooltip_many_items": {
    "one": "1 item",
    "other": "{0} itens"
  },
  "drag_tooltip_many_tracks": {
    "one": "1 faixa",
    "other": "{0} faixas"
  },
  "drag_tooltip_many_artists": {
    "one": "1 artista",
    "other": "{0} artistas"
  },
  "drag_tooltip_many_albums": {
    "one": "1 álbum",
    "other": "{0} álbuns"
  },
  "drag_tooltip_many_playlists": {
    "one": "1 playlist",
    "other": "{0} playlists"
  },
  "drag_tooltip_many_users": {
    "one": "1 usuário",
    "other": "{0} usuários"
  }
}
},{}],295:[function(require,module,exports){
module.exports={
  "drag_tooltip_many_items": {
    "one": "1 objekt",
    "other": "{0} objekt"
  },
  "drag_tooltip_many_tracks": {
    "one": "Ett spår",
    "other": "{0} spår"
  },
  "drag_tooltip_many_artists": {
    "one": "1 artist",
    "other": "{0} artister"
  },
  "drag_tooltip_many_albums": {
    "one": "1 album",
    "other": "{0} album"
  },
  "drag_tooltip_many_playlists": {
    "one": "1 spellista",
    "other": "{0} spellistor"
  },
  "drag_tooltip_many_users": {
    "one": "1 användare",
    "other": "{0} användare"
  }
}
},{}],296:[function(require,module,exports){
module.exports={
  "drag_tooltip_many_items": {
    "one": "1 รายการ",
    "other": "{0} รายการ"
  },
  "drag_tooltip_many_tracks": {
    "one": "1 แทร็ก",
    "other": "{0} แทร็ก"
  },
  "drag_tooltip_many_artists": {
    "one": "ศิลปิน 1 ราย",
    "other": "ศิลปิน {0} ราย"
  },
  "drag_tooltip_many_albums": {
    "one": "1 อัลบั้ม",
    "other": "{0} อัลบั้ม"
  },
  "drag_tooltip_many_playlists": {
    "one": "1 เพลย์ลิสต์",
    "other": "{0} เพลย์ลิสต์"
  },
  "drag_tooltip_many_users": {
    "one": "ผู้ใช้ 1 คน",
    "other": "ผู้ใช้ {0} คน"
  }
}
},{}],297:[function(require,module,exports){
module.exports={
  "drag_tooltip_many_items": {
    "one": "1 Öge",
    "other": "{0} öge"
  },
  "drag_tooltip_many_tracks": {
    "one": "1 parça",
    "other": "{0} parça"
  },
  "drag_tooltip_many_artists": {
    "one": "1 sanatçı",
    "other": "{0} sanatçı"
  },
  "drag_tooltip_many_albums": {
    "one": "1 albüm",
    "other": "{0} albüm"
  },
  "drag_tooltip_many_playlists": {
    "one": "1 çalma listesi",
    "other": "{0} çalma listesi"
  },
  "drag_tooltip_many_users": {
    "one": "1 kullanıcı",
    "other": "{0} kullanıcı"
  }
}
},{}],298:[function(require,module,exports){
module.exports={
  "drag_tooltip_many_items": {
    "one": "1 mục",
    "other": "{0} mục"
  },
  "drag_tooltip_many_tracks": {
    "one": "1 bản nhạc",
    "other": "{0} bản nhạc"
  },
  "drag_tooltip_many_artists": {
    "one": "1 nghệ sĩ",
    "other": "{0} nghệ sĩ"
  },
  "drag_tooltip_many_albums": {
    "one": "1 album",
    "other": "{0} album"
  },
  "drag_tooltip_many_playlists": {
    "one": "1 danh sách phát",
    "other": "{0} danh sách phát"
  },
  "drag_tooltip_many_users": {
    "one": "1 người dùng",
    "other": "{0} người dùng"
  }
}
},{}],299:[function(require,module,exports){
module.exports={
  "drag_tooltip_many_items": {
    "one": "1 個項目",
    "other": "{0} 個項目"
  },
  "drag_tooltip_many_tracks": {
    "one": "1 首歌曲",
    "other": "{0} 首歌曲"
  },
  "drag_tooltip_many_artists": {
    "one": "1 位藝人",
    "other": "{0} 位藝人"
  },
  "drag_tooltip_many_albums": {
    "one": "1 張專輯",
    "other": "{0} 張專輯"
  },
  "drag_tooltip_many_playlists": {
    "one": "1 個播放清單",
    "other": "{0} 個播放清單"
  },
  "drag_tooltip_many_users": {
    "one": "1 位使用者",
    "other": "{0} 位使用者"
  }
}
},{}],300:[function(require,module,exports){
module.exports={
  "drag_tooltip_many_items": {
    "one": "1 item",
    "other": "{0} item"
  },
  "drag_tooltip_many_tracks": {
    "one": "1 lagu",
    "other": "{0} lagu"
  },
  "drag_tooltip_many_artists": {
    "one": "1 artis",
    "other": "{0} artis"
  },
  "drag_tooltip_many_albums": {
    "one": "1 album",
    "other": "{0} album"
  },
  "drag_tooltip_many_playlists": {
    "one": "1 senarai main",
    "other": "{0} senarai main"
  },
  "drag_tooltip_many_users": {
    "one": "1 pengguna",
    "other": "{0} pengguna"
  }
}
},{}],301:[function(require,module,exports){
'use strict';

const modules = [require('./lang'), require('./anchor'), require('./player'), require('./dragndrop'), require('./add'), require('./selection'), require('./contextmenu'), require('./sticky'), require('./navbar'), require('./offline'), require('./filter'), require('./tooltip'), require('./list'), require('./menu'), require('./scroll'), require('./carousel'), require('./scrollbar'), require('./header'), require('./slider'), require('./select'), require('./sort'), require('./thumbs'), require('./feedback'), require('./list-quick-jump'), require('./cards')];

const events = {};

let isAttached = false;

events.update = function update(node) {
  if (!isAttached) return;

  modules.forEach(function (module) {
    module.update(node);
  });
};

events.attach = function attach() {
  if (isAttached) return;
  isAttached = true;

  modules.forEach(function (module) {
    module.attach();
  });
};

events.detach = function detach() {
  if (!isAttached) return;
  isAttached = false;

  modules.forEach(function (module) {
    module.detach();
  });
};

module.exports = events;

},{"./add":254,"./anchor":255,"./cards":256,"./carousel":261,"./contextmenu":263,"./dragndrop":269,"./feedback":275,"./filter":276,"./header":277,"./lang":302,"./list":304,"./list-quick-jump":303,"./menu":305,"./navbar":306,"./offline":307,"./player":309,"./scroll":314,"./scrollbar":315,"./select":316,"./selection":319,"./slider":323,"./sort":324,"./sticky":325,"./thumbs":326,"./tooltip":327}],302:[function(require,module,exports){
'use strict';

let isAttached = false;

exports.update = () => {};

exports.attach = () => {
  if (isAttached) return;
  isAttached = true;

  const locale = window.__spotify && window.__spotify.locale;
  if (locale) {
    document.documentElement.setAttribute('lang', locale);
  }
};

exports.detach = () => {
  if (!isAttached) return;
  isAttached = false;

  document.documentElement.removeAttribute('lang');
};

},{}],303:[function(require,module,exports){
(function (global){
'use strict';

const center = require('./center');
const cosmos = require('./util/cosmos');
const ClientEvent3 = require('../logger/messages/ClientEvent3');

const SPACE_KEYCODE = 32;
const BACKSPACE_KEYCODE = 8;
const DELETE_KEYCODE = 46;

exports.attach = function attach() {
  document.addEventListener('keypress', onKeyPress, false);
  document.addEventListener('keydown', onKeyDown, false);
};

exports.detach = function detach() {
  document.removeEventListener('keypress', onKeyPress, false);
  document.removeEventListener('keydown', onKeyDown, false);
};

exports.update = function () {};

const selector = ':not([data-sticky-active]) > [data-list-quick-jump]';
const SEARCH_STRING_CONCATENATION_TIMEOUT = 1000;

const searchStringsByUri = {};
const searchTimeoutsByUri = {};
const searchTimestampsByUri = {};

// onKeyPress is needed to read characters properly
function onKeyPress(event) {
  if (shouldEventBeIgnored(event)) return;
  processEvent(event);
}

// onKeyDown is needed to read <backspace>
function onKeyDown(event) {
  if (shouldEventBeIgnored(event)) return;

  const isBackspace = event.keyCode === BACKSPACE_KEYCODE;

  if (!isBackspace) return;
  processEvent(event);
}

function processEvent(event) {
  const isBackspace = event.keyCode === BACKSPACE_KEYCODE;

  const letter = event.keyCode === SPACE_KEYCODE ? ' ' : String.fromCharCode(event.keyCode).trim();
  if (!letter && !isBackspace) return;

  const listNode = getListNode(event.target);
  if (!listNode) return;

  const uri = getUri(listNode);
  if (!uri) return;

  // No need to do anything if there is no active search and user presses
  // BACKSPACE, since that would temporarily disable using SPACE for toggling
  // music, even though no quick-jump was actually made (KM-10204)
  if (isBackspace && !searchStringsByUri[uri]) return;

  if (!(uri in searchStringsByUri)) searchStringsByUri[uri] = '';

  if (isBackspace) {
    searchStringsByUri[uri] = searchStringsByUri[uri].slice(0, -1);
  } else if (letter) {
    searchStringsByUri[uri] += letter;
  }

  center.emit('list-quick-jump-request', uri, searchStringsByUri[uri] || null);

  if (searchTimeoutsByUri[uri]) clearTimeout(searchTimeoutsByUri[uri]);

  if (event.keyCode === SPACE_KEYCODE) {
    event.preventDefault(); // Prevent space from scrolling page
  }

  const shortcutsToIgnore = [{ keyCode: SPACE_KEYCODE }, { keyCode: BACKSPACE_KEYCODE }, { keyCode: DELETE_KEYCODE }];

  // Tell container to ignore <space>, <backspace> and <delete> shortcuts
  // until further notice
  cosmos.post({
    url: 'sp://messages/v1/ignoreshortcuts',
    body: {
      action: 'ignore',
      shortcuts: shortcutsToIgnore
    }
  });

  searchTimeoutsByUri[uri] = setTimeout(function () {
    // Tell container to stop ignoring <space>, <backspace> and <delete>
    // shortcuts
    cosmos.post({
      url: 'sp://messages/v1/ignoreshortcuts',
      body: {
        action: 'unignore',
        shortcuts: shortcutsToIgnore
      }
    });

    delete searchStringsByUri[uri];
    delete searchTimeoutsByUri[uri];
    delete searchTimestampsByUri[uri];
    center.emit('list-quick-jump-request', uri, null);
  }, SEARCH_STRING_CONCATENATION_TIMEOUT);

  if (searchStringsByUri[uri].length <= 20) {
    const timeSinceLastLetter = Date.now() - searchTimestampsByUri[uri] || null;
    ClientEvent3.log({
      source: global.__spotify && global.__spotify.app_uri || null,
      context: uri,
      event_version: 'list-quick-jump',
      event: 'user:type',
      json_data: JSON.stringify({
        str: searchStringsByUri[uri],
        letter: letter,
        was_backspace: isBackspace,
        time_since_last_letter: timeSinceLastLetter
      })
    });
  }

  searchTimestampsByUri[uri] = Date.now();
}

function shouldEventBeIgnored(event) {
  return event.metaKey || event.ctrlKey || event.target.matches('input, textarea, [contenteditable]');
}

function getListNode(target) {
  let listNode = target.closest(selector);
  if (!listNode) {
    const listNodes = document.querySelectorAll(selector);
    const hasOnlyOneListNode = listNodes && listNodes.length === 1;

    if (hasOnlyOneListNode) {
      listNode = listNodes[0];
    }
  }
  return listNode;
}

function getUri(listNode) {
  const uriParent = listNode.closest('[data-uri]');
  return uriParent && uriParent.getAttribute('data-uri');
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../logger/messages/ClientEvent3":221,"./center":262,"./util/cosmos":331}],304:[function(require,module,exports){
(function (global){
'use strict';

const $ = require('../spotify-elements');
const live = require('../live');
const center = require('./center');
const selection = require('./selection');
const cosmos = require('./util/cosmos');
const appUtil = require('./util/app');

const ROW_SELECTOR = '[data-list-item]';
const UNAVAILABLE_CLASS_NAME = 'unavailable';
const OFFLINE_DOWNLOADED_CLASS_NAME = 'offline-downloaded';
const OFFLINE_DOWNLOADING_CLASS_NAME = 'offline-downloading';
const OFFLINE_WAITING_CLASS_NAME = 'offline-waiting';

const storedTrackURIsForUnplayable = {};
const storedTrackURIsForOffline = {};

function updatePlayabilityForRows(uri, playable) {
  const rows = $(document).search(`${ROW_SELECTOR}[data-uri="${uri}"]`);
  if (rows) {
    updatePlayabilityForElements(rows, playable);
  }
}

function updatePlayabilityForElements(elements, playable) {
  if (playable) {
    elements.removeClass(UNAVAILABLE_CLASS_NAME);
  } else {
    elements.addClass(UNAVAILABLE_CLASS_NAME);
  }
}

function updateOfflineForRows(uri, shouldBeOffline, offlineProgress) {
  const rows = $(document).search(`${ROW_SELECTOR}[data-uri="${uri}"]`);
  if (rows) {
    // This will take an elements object as the first argument, so it can contain multiple rows
    updateOfflineForElements(rows, shouldBeOffline, offlineProgress);
  }
}

function updateOfflineForElements(elements, shouldBeOffline, offlineProgress) {
  // The track is either already downloaded or will be soon
  if (shouldBeOffline) {
    // Download done
    if (offlineProgress === 1) {
      elements.addClass(OFFLINE_DOWNLOADED_CLASS_NAME);
      elements.removeClass(OFFLINE_DOWNLOADING_CLASS_NAME);
      elements.removeClass(OFFLINE_WAITING_CLASS_NAME);

      // Waiting to be downloaded
    } else if (offlineProgress === 0) {
      elements.addClass(OFFLINE_WAITING_CLASS_NAME);
      elements.removeClass(OFFLINE_DOWNLOADED_CLASS_NAME);
      elements.removeClass(OFFLINE_DOWNLOADING_CLASS_NAME);

      // Downloading at the moment
    } else {
      elements.addClass(OFFLINE_DOWNLOADING_CLASS_NAME);
      elements.removeClass(OFFLINE_DOWNLOADED_CLASS_NAME);
      elements.removeClass(OFFLINE_WAITING_CLASS_NAME);
    }

    // The track is not supposed to be downloaded offline
  } else {
    elements.removeClass(OFFLINE_DOWNLOADED_CLASS_NAME);
    elements.removeClass(OFFLINE_DOWNLOADING_CLASS_NAME);
    elements.removeClass(OFFLINE_WAITING_CLASS_NAME);
  }
}

function updateUnplayableRows(node, optRows) {
  const rows = optRows || ($(node) || $(document)).search(ROW_SELECTOR);
  if (rows) {
    rows.forEach(function (row) {
      const uri = $(row).data('uri');

      const model = live(uri);
      const playable = model.get('playable');

      if (playable !== undefined) {
        updatePlayabilityForElements($(row), playable);
      }

      if (uri in storedTrackURIsForUnplayable) return;
      storedTrackURIsForUnplayable[uri] = true;

      model.on('update', function (properties) {
        if ('playable' in properties) {
          updatePlayabilityForRows(uri, properties.playable);
        }
      });
    });
  }
}

function updateOfflineSyncing(node, optRows) {
  const rows = optRows || ($(node) || $(document)).search(ROW_SELECTOR);
  if (rows) {
    rows.forEach(function (row) {
      const uri = $(row).data('uri');
      const model = live(uri);

      // Try to query the data sync if possible (live.ASAP), to try to set the
      // class names before adding the rows to the DOM (by the scroller), to
      // avoid flickering.
      model.query('shouldBeOffline, offlineProgress', function (error, data) {
        if (error) throw error;
        updateOfflineForElements($(row), data.shouldBeOffline, data.offlineProgress);

        if (uri in storedTrackURIsForOffline) return;
        storedTrackURIsForOffline[uri] = true;

        model.on('update', function (properties) {
          if ('shouldBeOffline' in properties || 'offlineProgress' in properties) {
            updateOfflineForRows(uri, model.get('shouldBeOffline'), model.get('offlineProgress'));
          }
        });
      }, live.ASAP);
    });
  }
}

const ignoredShortcuts = {};

function handleKeyDown(event) {
  if (!event.target.closest(ROW_SELECTOR) || ignoredShortcuts[JSON.stringify({ keyCode: event.keyCode })]) return;

  let shouldRemove = false;
  const isWindows = /Win/.test(global.window.navigator.userAgent);

  const isBackspace = event.keyCode === 8;
  const isDelete = event.keyCode === 46;

  if (isWindows) {
    shouldRemove = isDelete;
  } else {
    shouldRemove = isBackspace || isDelete;
  }

  if (shouldRemove) {
    removeCurrentlySelectedListItems();
  }
}

function removeCurrentlySelectedListItems() {
  const lists = selection.getIndicesPerList();
  if (lists.length > 0) {
    let firstIndex = null;
    lists.forEach(function (list) {
      let newList = list;
      // Delete from origin list where applicable
      // TODO: We could just remove from the list directly, without going
      // through the origin list. Removing from a sorted list will pass
      // the change on to the origin list automatically.
      if (newList.origin) {
        newList = newList.origin;
      }
      const model = live(newList.uri);

      const indices = newList.indices.sort(function (a, b) {
        return a - b;
      });

      model.query('allows(removeTracks)', function (error, data) {
        if (error) throw error;
        if (!data.allows.removeTracks) return;

        model.get('rows', function (rowError, liveList) {
          if (rowError) throw rowError;
          const operations = indices.map(function (index, indexInArray) {
            return { type: 'remove', index: index - indexInArray, length: 1 };
          });
          liveList.publish(operations);

          if (firstIndex === null) {
            firstIndex = indices[0];
          }
        });
      });
    });
  }
}

function handleScrollShow(data) {
  updateUnplayableRows(data.container, data.nodes);
  updateOfflineSyncing(data.container, data.nodes);
}

// Exported for testing
exports._classNames = {
  UNAVAILABLE: UNAVAILABLE_CLASS_NAME,
  OFFLINE_WAITING: OFFLINE_WAITING_CLASS_NAME,
  OFFLINE_DOWNLOADING: OFFLINE_DOWNLOADING_CLASS_NAME,
  OFFLINE_DOWNLOADED: OFFLINE_DOWNLOADED_CLASS_NAME
};

let isAttached = false;

exports.update = function update(node) {
  if (!isAttached) return;

  updateUnplayableRows(node);
  updateOfflineSyncing(node);
};

const doc = $(document);
let deleteSubscription;
let ignoredShortcutsSubscription;
exports.attach = function () {
  if (isAttached) return;
  isAttached = true;

  doc.on('keydown', handleKeyDown);
  center.on('scroll-show-before', handleScrollShow);

  deleteSubscription = cosmos.subscribe({ url: 'sp://messages/v1/container/control' }, function (error, response) {
    if (error) throw error;
    const data = response.body;
    if (data && data.type === 'delete' && appUtil.isActiveAndFocused()) {
      removeCurrentlySelectedListItems();
    }
  });

  ignoredShortcutsSubscription = cosmos.subscribe({
    url: 'sp://messages/v1/ignoreshortcuts'
  }, function (error, response) {
    if (response.body.action === 'ignore') {
      response.body.shortcuts.forEach(function (shortcut) {
        ignoredShortcuts[JSON.stringify(shortcut)] = 1;
      });
    } else if (response.body.action === 'unignore') {
      response.body.shortcuts.forEach(function (shortcut) {
        delete ignoredShortcuts[JSON.stringify(shortcut)];
      });
    }
  });
};
exports.detach = function () {
  if (!isAttached) return;
  isAttached = false;

  doc.off('keydown', handleKeyDown);
  center.off('scroll-show-before', handleScrollShow);

  if (deleteSubscription) {
    deleteSubscription.cancel();
    deleteSubscription = null;
  }

  if (ignoredShortcutsSubscription) {
    ignoredShortcutsSubscription.cancel();
    ignoredShortcutsSubscription = null;
  }
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../live":210,"../spotify-elements":251,"./center":262,"./selection":319,"./util/app":330,"./util/cosmos":331}],305:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.attach = attach;
exports.detach = detach;
exports.update = update;

var _throttle = require('./util/throttle');

var _throttle2 = _interopRequireDefault(_throttle);

var _center = require('./center');

var _center2 = _interopRequireDefault(_center);

var _navigation = require('../navigation');

var _navigation2 = _interopRequireDefault(_navigation);

var _appState = require('../navigation/app-state');

var _appState2 = _interopRequireDefault(_appState);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const SELECTOR_MENU = '[data-menu]';
const SELECTOR_MENU_ITEM = '[data-menu-item]';
const SELECTOR_MENU_ITEM_DISABLED = '[data-menu-item-disabled]';
const SELECTOR_MENU_ITEM_ENABLED = '[data-menu-item]:not([data-menu-item-disabled])';
const SELECTOR_SUBMENU = '[data-submenu="true"]';
const ATTRIBUTE_MENU = 'data-menu';
const ATTRIBUTE_MENU_ITEM = 'data-menu-item';

const navigator = new _navigation2.default.Navigator();

let isAttached = false;

// The state will take the following shape (a nested structure that can be any
// number of levels deep):
// {
//   menu: { // null if root menu is not open
//     node: menuNode,
//     selectedNode: menuItemNode, // or null
//     menu: { // null if a sub menu is not open
//       node: subMenuNode,
//       selectedNode: subMenuItemNode, // or null,
//       menu: null, // null if a sub menu is not open
//       parent: <back-reference>, // a reference to the object one level up
//     },
//     parent: null, // always null for the root menu
//   }
// }
const state = {
  menu: null
};

/**
 * Handler for when the mouse is moved over a menu.
 * This is only attached for the current menu (if there is a current menu).
 *
 * @param {MouseEvent} event A mouse event.
 */
function onMouseMove(event) {
  const isMenu = event.target.matches(SELECTOR_MENU);
  if (isMenu) {
    return;
  }

  const targetItem = event.target.closest(SELECTOR_MENU_ITEM);
  if (!targetItem) {
    return;
  }

  const targetMenu = targetItem.closest(SELECTOR_MENU);
  const targetMenuState = getStateForMenu(targetMenu);
  let activeMenuState = getStateForActiveMenu();

  if (targetItem === activeMenuState.selectedNode) {
    return;
  }

  if (targetItem.matches(SELECTOR_MENU_ITEM_DISABLED)) {
    deselectItemInMenu(activeMenuState);
  } else {
    selectItemInMenu(activeMenuState, targetMenuState, targetItem);
    activeMenuState = getStateForActiveMenu();
  }

  // When hovering over an item that has a sub menu, open the sub menu if not
  // open already.
  if (targetItem.matches(SELECTOR_SUBMENU)) {
    if (!targetMenuState.menu) {
      openSubMenu(targetMenuState, targetItem);
    }

    // When hovering over a regular item and a sub menu is currently shown, close
    // the sub menu.
  } else if (activeMenuState.menu) {
    closeSubMenuOf(activeMenuState);
  }
}
const onMouseMoveThrottled = (0, _throttle2.default)(onMouseMove);

/**
 * Handler for when an element gets focused.
 *
 * @param {FocusEvent} event A focus event.
 */
function onFocus(event) {
  const targetMenu = event.target.closest(SELECTOR_MENU);
  if (targetMenu && !state.menu) {
    state.menu = {
      node: targetMenu,
      selectedNode: null,
      menu: null,
      active: true,
      parent: null
    };

    targetMenu.addEventListener('mousemove', onMouseMoveThrottled);
    targetMenu.addEventListener('mouseleave', onMouseLeave);

    // We need to ensure that before triggering the "touchstart" event in the <LI> element
    // of the node, we emulate the mouse being moved over it. This way, the listeners are
    // attached and they will fire.
    // Note: this "mouseMove" call cannot be throttled, because the "touchstart" that will
    // trigger in the <LI> will happen before the throttler fires the event. Additionally,
    // there's no need to use the throttling logic for the touchstart event.
    targetMenu.addEventListener('touchstart', onMouseMove, true);
  }
}

/**
 * Handler for when an element loses focus.
 *
 * @param {FocusEvent} event A blur event.
 */
function onBlur(event) {
  const { target, relatedTarget } = event;

  if (state.menu) {
    if (target === state.menu.node) {
      // A blur on the menu (target) can mean an element inside of it gains focus.
      // No need to reset then.
      if (!relatedTarget || !target.contains(relatedTarget)) {
        hideMenu();
      }
    } else if (state.menu.node.contains(target) && !state.menu.node.contains(relatedTarget)) {
      hideMenu();
    }
  }
}

/**
 * Handler for when a key is pressed.
 *
 * @param {KeyboardEvent} event A keyboard event.
 */
function onKeyDown(event) {
  // Only act on events when a menu is open
  if (!state.menu) {
    return;
  }

  const keyCode = event.keyCode;
  const isEnter = keyCode === 13;
  const isEscape = keyCode === 27;
  const isUp = keyCode === 38;
  const isDown = keyCode === 40;
  const isLeft = keyCode === 37;
  const isRight = keyCode === 39;

  if (isEnter) {
    // Look for links to follow inside the current menu item.
    const activeMenuState = getStateForActiveMenu();
    const selectedMenuItem = activeMenuState.selectedNode;
    const link = selectedMenuItem && selectedMenuItem.querySelector('a[href]');
    if (link) {
      navigator.requestOpenState(new _appState2.default(link.getAttribute('href')));
    }
    emitActivateItemEvent(selectedMenuItem);
    return;
  }

  if (isEscape) {
    hideMenu();
    return;
  }

  if (isUp || isDown) {
    const activeMenuState = getStateForActiveMenu();
    if (activeMenuState.node) {
      const newActiveMenuItem = isDown ? getMenuItemBelow(activeMenuState) : getMenuItemAbove(activeMenuState);

      if (newActiveMenuItem) {
        selectItemInMenu(activeMenuState, activeMenuState, newActiveMenuItem);
      }
    }
    return;
  }

  if (isRight) {
    const activeMenuState = getStateForActiveMenu();
    if (activeMenuState.selectedNode) {
      if (activeMenuState.selectedNode.matches(SELECTOR_SUBMENU)) {
        // Open the sub menu if not open already (might have been opened by the
        // mouse cursor)
        if (!activeMenuState.menu) {
          openSubMenu(activeMenuState, activeMenuState.selectedNode);
        }

        // Select the first item in the sub menu
        const subMenuNode = activeMenuState.menu.node;
        const firstItemInSubMenu =
        // We'd like to get firstElementChild to avoid text nodes, but since
        // JSDom doesn't support that, fall back to firstChild for tests.
        subMenuNode.firstElementChild || subMenuNode.firstChild;
        selectItemInMenu(activeMenuState, activeMenuState.menu, firstItemInSubMenu);
      }
    }
    return;
  }

  if (isLeft) {
    const activeMenuState = getStateForActiveMenu();
    if (activeMenuState.parent) {
      closeSubMenuOf(activeMenuState.parent);
    }
    return;
  }
}

/**
 * Handler for when the mouse leaves a menu.
 * This is only attached for the current menu (if there is a current menu).
 *
 * @param {MouseEvent} event A mouse event.
 */
function onMouseLeave(event) {
  if (!event.relatedTarget || !event.relatedTarget.closest(SELECTOR_MENU)) {
    const activeMenuState = getStateForActiveMenu();
    deselectItemInMenu(activeMenuState);
    if (activeMenuState.menu) {
      closeSubMenuOf(activeMenuState);
    }
  }
}

/**
 * Handler for when the current menu item is clicked.
 * This is only attached for the current menu item (if there is one).
 *
 * @param {MouseEvent} event A mouse event.
 */
function onItemClick(event) {
  const targetMenu = event.target.closest(SELECTOR_MENU);
  const targetMenuState = getStateForMenu(targetMenu);
  const itemNode = targetMenuState.selectedNode;

  emitActivateItemEvent(itemNode);
}

/**
 * In order to prevent the simulated click event when using a touchscreen,
 * we prevent default so click won't trigger. That click event would otherwise
 * trigger a click on the layer beneath since the menu is closed after activating an item.
 *
 * @param {TouchEvent} event a Touch event.
 */
function onItemTouchStart(event) {
  event.preventDefault();
  onItemClick(event);
}

/**
 * Emit a center event to activate the current item.
 *
 * @param {HTMLElement} itemNode HTML element for the item.
 */
function emitActivateItemEvent(itemNode) {
  _center2.default.emit('menu-activate-item', {
    menu: {
      id: state.menu.node.getAttribute(ATTRIBUTE_MENU) || '',
      element: state.menu.node
    },
    item: {
      id: itemNode.getAttribute(ATTRIBUTE_MENU_ITEM) || '',
      element: itemNode
    }
  });
}

/**
 * Set the current menu item to a new item.
 *
 * @param {Object} activeMenuState Menu state object for the currently active
 *   menu.
 * @param {Object} targetMenuState Menu state object for the menu where the item
 *   that is to be selected is located.
 * @param {HTMLElement} itemNode An HTML element for the menu item.
 */
function selectItemInMenu(activeMenuState, targetMenuState, itemNode) {
  const isTargetSubMenu = activeMenuState.menu === targetMenuState;
  const isTargetParentMenu = isSecondContainedInFirst(targetMenuState, activeMenuState);

  // If the item is in a sub menu we only want to remove any item event
  // listeners. Removing visual selection should only happen when moving within
  // the same menu.
  if (isTargetSubMenu) {
    removeItemListeners(activeMenuState.selectedNode);
  } else {
    deselectItemInMenu(activeMenuState);
  }

  // Deselect the currently selected item in parent menu, if moving from sub
  // menu to the parent menu.
  if (isTargetParentMenu) {
    deselectItemInMenu(targetMenuState);
  }

  activeMenuState.active = false;

  if (targetMenuState.selectedNode !== itemNode) {
    itemNode.classList.add('selected');
    addItemListeners(itemNode);
    targetMenuState.selectedNode = itemNode;
  }

  targetMenuState.active = true;
}

/**
 * Deselect any selected item in the menu represented by the passed state.
 *
 * @param {Object} menuState The menu state object.
 */
function deselectItemInMenu(menuState) {
  if (menuState.selectedNode) {
    const itemNode = menuState.selectedNode;
    itemNode.classList.remove('selected');
    removeItemListeners(itemNode);
    menuState.selectedNode = null;
  }
}

/**
 * Add the click listeners from an item node.
 *
 * @param {HTMLElement} itemNode An HTML element for the menu item.
 */
function addItemListeners(itemNode) {
  itemNode.addEventListener('click', onItemClick);
  itemNode.addEventListener('touchstart', onItemTouchStart);
}

/**
 * Remove the click listeners from an item node.
 *
 * @param {HTMLElement} itemNode An HTML element for the menu item.
 */
function removeItemListeners(itemNode) {
  itemNode.removeEventListener('click', onItemClick);
  itemNode.removeEventListener('touchstart', onItemTouchStart);
}

/**
 * Open a sub menu for the provided menu state object and item node.
 *
 * @param {Object} menuState The menu state object for the parent menu.
 * @param {HTMLElement} itemNode An HTML element for the menu item.
 */
function openSubMenu(menuState, itemNode) {
  const menuNode = itemNode.querySelector(SELECTOR_MENU);
  if (menuNode) {
    menuState.menu = {
      parent: menuState,
      node: menuNode,
      selectedNode: null,
      menu: null,
      active: false
    };
    menuNode.classList.add('open');
  }
}

/**
 * Close all sub menus for the provided menu state object.
 *
 * @param {Object} menuState The menu state object for the parent menu.
 */
function closeSubMenuOf(menuState) {
  // Close deeper sub menus first
  if (menuState.menu.menu) {
    closeSubMenuOf(menuState.menu);
  }

  if (menuState.menu.active) {
    menuState.menu.active = false;
    menuState.active = true;
  }

  deselectItemInMenu(menuState.menu);
  menuState.menu.node.classList.remove('open');
  menuState.menu = null;
}

/**
 * Hide the current menu by broadcasting a message via center.
 * A listener can be added via center and the handler will then really hide it.
 *
 * @example
 * center.on('menu-hide', function(event) {
 *   if (event.menu.id === 'profile-menu') {
 *     hideProfileMenu();
 *   }
 * });
 */
function hideMenu() {
  if (state.menu) {
    const menuNode = state.menu.node;

    menuNode.removeEventListener('mousemove', onMouseMoveThrottled);
    menuNode.removeEventListener('mouseleave', onMouseLeave);
    menuNode.removeEventListener('touchstart', onMouseMove, true);

    // Remove any sub menus
    let menuState = state.menu;
    while (menuState) {
      deselectItemInMenu(menuState);
      menuState.node.classList.remove('open');
      menuState = menuState.menu;
    }

    delete state.menu;

    _center2.default.emit('menu-hide', {
      menu: {
        id: menuNode.getAttribute(ATTRIBUTE_MENU) || '',
        element: menuNode
      }
    });
  }
}

/**
 * Test if the second menu state object is contained in the second state object.
 *
 * @param {Object} first Menu state object.
 * @param {Object} second Menu state object.
 *
 * @return {Boolean}        True if it is.
 */
function isSecondContainedInFirst(first, second) {
  let statePart = first.menu;
  while (statePart && statePart !== second) {
    statePart = statePart.menu;
  }

  return !!statePart;
}

/**
 * Get the menu state object for the provided menu node. This assumes the node
 * is part of the state tree.
 *
 * @param {HTMLElement} menuNode The menu element.
 *
 * @return {Object} Menu state object.
 */
function getStateForMenu(menuNode) {
  let statePart = state.menu;
  while (statePart && statePart.node !== menuNode) {
    statePart = statePart.menu;
  }

  return statePart;
}

/**
 * Get the menu state object for the currently active menu.
 *
 * @return {Object} Menu state object.
 */
function getStateForActiveMenu() {
  let statePart = state.menu;
  while (statePart && !statePart.active) {
    statePart = statePart.menu;
  }

  return statePart;
}

/**
 * Find the menu item that is below the current one.
 * This will skip disabled menu items as well as any elements that are not
 * defined as menu items. If there is no menu item below the current one,
 * this will return null.
 *
 * @param {Object} activeMenuState Menu state object for the currently active
 *   menu.
 *
 * @return {HTMLElement?} The HTML element for the menu item, or null.
 */
function getMenuItemBelow(activeMenuState) {
  if (!activeMenuState.selectedNode) {
    return activeMenuState.node.querySelector(SELECTOR_MENU_ITEM_ENABLED);
  }

  let item = activeMenuState.selectedNode.nextElementSibling;
  while (item) {
    const isMenuItem = item.matches(SELECTOR_MENU_ITEM);
    const isDisabled = item.matches(SELECTOR_MENU_ITEM_DISABLED);
    if (isMenuItem && !isDisabled) {
      break;
    }
    item = item.nextElementSibling;
  }

  return item;
}

/**
 * Find the menu item that is above the current one.
 * This will skip disabled menu items as well as any elements that are not
 * defined as menu items. If there is no menu item above the current one,
 * this will return null.
 *
 * @param {Object} activeMenuState Menu state object for the currently active
 *   menu.
 *
 * @return {HTMLElement?} The HTML element for the menu item, or null.
 */
function getMenuItemAbove(activeMenuState) {
  if (!activeMenuState.selectedNode) {
    const results = activeMenuState.node.querySelectorAll(SELECTOR_MENU_ITEM_ENABLED);
    return results[results.length - 1] || null;
  }

  let item = activeMenuState.selectedNode.previousElementSibling;
  while (item) {
    const isMenuItem = item.matches(SELECTOR_MENU_ITEM);
    const isDisabled = item.matches(SELECTOR_MENU_ITEM_DISABLED);
    if (isMenuItem && !isDisabled) {
      break;
    }
    item = item.previousElementSibling;
  }

  return item;
}

/**
 * The spotify-events style attach function. Should be called once when DOM
 * is ready.
 */
function attach() {
  if (isAttached) return;
  isAttached = true;

  document.addEventListener('keydown', onKeyDown);

  // use capture to work around the non-bubbling events
  document.addEventListener('focus', onFocus, true);
  document.addEventListener('blur', onBlur, true);
}

/**
 * The spotify-events style detach function. Should be called when you no
 * longer need the events.
 */
function detach() {
  if (!isAttached) return;
  isAttached = false;

  state.menu = null;

  document.removeEventListener('keydown', onKeyDown);
  document.removeEventListener('focus', onFocus, true);
  document.removeEventListener('blur', onBlur, true);
}

/**
 * The spotify-events style update function. Should be called when DOM
 * changes.
 */
function update() {}

},{"../navigation":231,"../navigation/app-state":230,"./center":262,"./util/throttle":334}],306:[function(require,module,exports){
(function (global){
'use strict';

const $ = require('../spotify-elements');

const live = require('../live');
const center = require('./center');

const NAVBAR_ATTR_NAME = 'data-navbar';
const ITEM_ID_ATTR_NAME = 'data-navbar-item-id';
const ITEM_MATCHER_ATTR_NAME = 'data-navbar-item-matcher';
const VIEW_ID_ATTR_NAME = 'data-navbar-view-id';
const ACTIVE_ID_ATTR_NAME = 'data-navbar-active-id';
const HISTORY_POS_ATTR_NAME = 'data-navbar-history-position';
const CLASSNAME_ACTIVE = 'active';
const OVERFLOW_MENU_ID = 'navbar-overflow-menu';
const STICKY_WRAPPER_ATTR_NAME = 'data-sticky-fixed-wrapper';

const APPLICATION_MODEL_URI = 'spotify:application';

const storedMatchers = {};

let navbarOverflowItems;
let isShowingNavbarOverflow;
let shouldShowNavbarOverflow;

const getSelector = function (name, optOperator, optMatcher) {
  if (optOperator && optMatcher) {
    return `[${name}${optOperator}"${optMatcher}"` + ']';
  }
  return `[${name}]`;
};

const updateOverflowMenu = function () {
  const moreMenuItem = document.querySelector('[data-navbar-item-id=navbar-overflow-menu]');
  if (!moreMenuItem) {
    return;
  }

  const canBeOpen = navbarOverflowItems && navbarOverflowItems.length;
  if (!canBeOpen) {
    shouldShowNavbarOverflow = false;
  }

  // There's no check for isShowingNavbarOverflow, the event is intentionally
  // resent on update, to support resizing.
  if (shouldShowNavbarOverflow) {
    isShowingNavbarOverflow = true;
    const descriptors = navbarOverflowItems.map(function (item) {
      const link = item.querySelector('a[href]');

      // The text is in the <a> element inside the item.
      return {
        name: item.firstElementChild && item.firstElementChild.textContent || '',
        id: item.getAttribute(ITEM_ID_ATTR_NAME),
        url: link && link.getAttribute('href'),
        active: item.classList.contains('active')
      };
    });

    const targetRect = moreMenuItem.getBoundingClientRect();
    global.top.postMessage({
      type: 'show-navbar-overflow',
      items: descriptors,
      right: targetRect.right,
      top: targetRect.bottom
    }, '*');
  }

  if (!shouldShowNavbarOverflow && isShowingNavbarOverflow) {
    isShowingNavbarOverflow = false;
    global.top.postMessage({
      type: 'hide-navbar-overflow'
    }, '*');
  }
};

const getTabsForId = function (tabId) {
  if (!tabId) {
    return [];
  }
  // This is intentionally selecting on all of the document
  const tabs = document.querySelectorAll(getSelector(ITEM_ID_ATTR_NAME, '=', tabId));
  return Array.prototype.slice.call(tabs);
};

const getView = function (id) {
  return document.querySelector(getSelector(VIEW_ID_ATTR_NAME, '=', id));
};

const getNavbar = function (optNode) {
  const node = optNode || document.documentElement;
  const selector = getSelector(NAVBAR_ATTR_NAME);
  return node.matches(selector) ? node : node.querySelector(selector);
};

const getActiveTab = function () {
  const navbar = getNavbar();
  if (!navbar) return null;
  const activeTabId = navbar.getAttribute(ACTIVE_ID_ATTR_NAME);
  const activeTabs = getTabsForId(activeTabId);
  return activeTabs[0];
};

const getTabs = function () {
  const tabs = document.querySelectorAll(getSelector(ITEM_ID_ATTR_NAME));
  return Array.prototype.slice.call(tabs);
};

const setActiveTabs = function (id, tabs) {
  const navbar = getNavbar();
  if (!navbar) {
    return;
  }

  navbar.setAttribute(ACTIVE_ID_ATTR_NAME, id);

  tabs.forEach(function (tab) {
    tab.classList.add(CLASSNAME_ACTIVE);
  });

  // Remove the active class name from all tabs except the ones that should be active
  const tabList = getTabs();
  if (tabList.length) {
    tabList.forEach(function (_tab) {
      if (_tab.getAttribute(ITEM_ID_ATTR_NAME) !== id) {
        _tab.classList.remove(CLASSNAME_ACTIVE);
      }
    });
  }
};

const getViews = function () {
  const views = document.querySelectorAll(getSelector(VIEW_ID_ATTR_NAME));
  return Array.prototype.slice.call(views);
};

const hide = function (element) {
  element.style.display = 'none';
};
const show = function (element) {
  element.style.display = 'block';
};

const setActiveView = function (id, view) {
  if (!view) {
    return;
  }

  const views = getViews();

  // Hide all views except the one that should be active
  for (let i = 0, l = views.length; i < l; i++) {
    if (views[i] !== view[0]) {
      hide(views[i]);
    }
  }

  show(view);
};

const setActive = function (id, tabs, view) {
  const currentActiveTab = getActiveTab();
  const currentActiveId = currentActiveTab && currentActiveTab.getAttribute(ITEM_ID_ATTR_NAME);

  // Abort if the new tab is already active
  if (currentActiveId === id) {
    return;
  }

  setActiveTabs(id, tabs);
  setActiveView(id, view);

  center.emit('navbar-change', { id: id });
};

const activateItem = function (id) {
  updateScrollPosition();

  const view = getView(id);
  const tabs = getTabsForId(id);

  // Set styles for navbar items and show/hide views
  setActive(id, tabs, view);
};

const handleClick = function (event, tab) {
  const id = tab.getAttribute(ITEM_ID_ATTR_NAME);
  if (id === OVERFLOW_MENU_ID) {
    shouldShowNavbarOverflow = true;
    updateOverflowMenu();
    return;
  }

  activateItem(id);
  // Prevent any default click action (like link navigation)
  event.preventDefault();
};

const hideOverflow = function () {
  if (isShowingNavbarOverflow) {
    shouldShowNavbarOverflow = false;
    updateOverflowMenu();
  }
};

const onMessage = function (message) {
  if (message.data && message.data.name === 'navbar-overflow-click') {
    activateItem(message.data.itemId);
  }

  if (message.data && message.data.name === 'hide-navbar-overflow') {
    hideOverflow();
  }
};

const getFirstTabId = function () {
  const tab = document.querySelector(getSelector(ITEM_ID_ATTR_NAME));
  if (tab) {
    if (tab.getAttribute(ITEM_ID_ATTR_NAME) === OVERFLOW_MENU_ID) {
      return null;
    }
    return tab.getAttribute(ITEM_ID_ATTR_NAME);
  }
  return null;
};

const setActiveForMatchingId = function (ids) {
  // Off the list of passed ids, find the first one that matches a tab, then set
  // that one as active.
  let count = 0;
  let tabs;
  let id;
  while (count < ids.length && (!tabs || !tabs.length)) {
    if (ids[count]) {
      id = ids[count];
      tabs = getTabsForId(id);
    }
    count++;
  }
  const useID = id;

  if (!tabs || !tabs.length) {
    return;
  }
  const view = getView(useID);

  setActive(useID, tabs, view);
};

// Hack to get around bridge bug (reported at WP-471) where WP reports
// the uri with the arguments as well.
const fixAppURI = function (uri) {
  return uri.split(':').slice(0, 3).join(':');
};

const getIdFromMatchers = function (uri) {
  for (const regexp in storedMatchers) {
    if (storedMatchers.hasOwnProperty(regexp)) {
      const regexpObj = new RegExp(regexp);
      if (regexpObj.test(uri)) return storedMatchers[regexp];
    }
  }
  return null;
};

const updateForNode = function (node) {
  const navbar = getNavbar(node);
  if (!navbar) return;

  live(APPLICATION_MODEL_URI).query('appURI, arguments', function (error, data) {
    if (error) throw error;

    const uri = fixAppURI(data.appURI);
    let fullAppURI = uri;
    if (data.arguments) {
      fullAppURI += `:${data.arguments}`;
    }
    const id = getIdFromMatchers(fullAppURI);

    if (id) {
      // This is only the case when matchers (ITEM_MATCHER_ATTR_NAME) are used in DOM.
      setActiveForMatchingId([id]);
    } else {
      // For cases where id is only to be matched from one argument, find the id to
      // highlight by looking at the argument at HISTORY_POS_ATTR_NAME.
      const argumentIndex = +navbar.getAttribute(HISTORY_POS_ATTR_NAME) || 0;
      const idAtArgumentIndex = data.arguments.split(':')[argumentIndex];

      // For cases where nothing matches, also pass the first tab ID. This is
      // how the first tab is highlighted by default.
      const firstTabId = getFirstTabId();

      setActiveForMatchingId([fullAppURI, idAtArgumentIndex, firstTabId]);
    }
  });
};

function updateForOverflow(node) {
  const navbar = getNavbar(node);
  if (!navbar) return;

  const itemSelector = '[data-navbar] > [data-navbar-item-id]:not(.overflow-menu-button)';
  let items = node.querySelectorAll(itemSelector);
  if (!items) {
    return;
  }

  items = Array.prototype.slice.call(items);

  const overflowMenuButton = navbar.querySelector('.overflow-menu-button');

  // If we have less than two items, only show the navbar and be done. We need
  // at least two items for messurement and chances are a "more" menu won't be
  // needed.
  if (items.length < 2) {
    navbar.style.visibility = 'visible';
    if (overflowMenuButton) {
      overflowMenuButton.style.display = 'none';
    }
    return;
  }

  const navbarWidth = getWidth(navbar);
  if (!navbarWidth) {
    // The navbar isn't rendered. Bail out.
    return;
  }

  // Reset to the initial rendering state to be able to measure items.
  if (overflowMenuButton) {
    overflowMenuButton.style.display = 'inline';
  }

  items.forEach(function (item) {
    item.style.display = 'block';
    item.classList.remove('last-visible');
  });

  const sizing = measureNavbar(items, overflowMenuButton);

  // If stuff doesn't completely fit, reduce the available space by the "more"
  // menu with, then calculate what needs to go in it.
  let availableSpace = navbarWidth;
  let firstOverflown = getFirstOverflownIndex(availableSpace, sizing.itemWidths);
  const needsMoreMenu = items.length !== firstOverflown;

  if (needsMoreMenu) {
    availableSpace -= sizing.overflowMenuButtonWidth;
    firstOverflown = getFirstOverflownIndex(availableSpace, sizing.itemWidths);
  }

  if (!navbarOverflowItems) {
    navbarOverflowItems = [];
  }
  navbarOverflowItems.length = 0;

  items.forEach(function (item, i) {
    const shouldBeInOverflow = i >= firstOverflown;
    if (shouldBeInOverflow) {
      navbarOverflowItems.push(item);
    }

    // If we don't draw an overflow menu, set the last-visible class on the
    // very last item so its margin-right is removed.
    const isLastInNotOverflown = !needsMoreMenu && i === items.length - 1;

    item.style.display = shouldBeInOverflow ? 'none' : 'block';
    item.classList.toggle('last-visible', isLastInNotOverflown);
  });

  if (overflowMenuButton) {
    overflowMenuButton.style.display = needsMoreMenu ? 'inline' : 'none';
  }

  // Update items and position, possibly close the menu
  updateOverflowMenu();
  navbar.style.visibility = 'visible';
}

function updateScrollPosition() {
  const scrollTop = window.pageYOffset;
  const stickyElements = Array.prototype.slice.call(document.querySelectorAll(`[${STICKY_WRAPPER_ATTR_NAME}]`));

  if (stickyElements.length === 0) return;

  // Get the `top` value of a sticky element that is
  // in a fixed position (negative value)
  // and the closest to the top (smallest top value).
  const topTarget = stickyElements.reduce(function (res, el) {
    const top = el.getBoundingClientRect().top;
    return top < res ? top : res;
  }, 0);

  const topBarHeight = parseInt(document.documentElement.getAttribute('data-top-bar-height'), 10) || 0;

  if (topTarget < 0) {
    // Add 1 px to have the sticky element in fixed position.
    window.scrollTo(0, scrollTop + topTarget + 1 - topBarHeight);
  }
}

function handleResize() {
  updateForOverflow(document.body);
}

function measureNavbar(items, overflowMenuButton) {
  // Find out what the margin per item is my messuring beween the first 2 items.
  const item1 = items[0];
  const item2 = items[1];

  const right1 = Math.floor(item1.getBoundingClientRect().right);
  const left2 = Math.floor(item2.getBoundingClientRect().left);
  const marginPerSide = (left2 - right1) / 2;

  let itemWidths = [];
  if (items) {
    itemWidths = items.map(function (item, i, all) {
      const marginLeft = i === 0 ? 0 : marginPerSide;
      const marginRight = i === all.length - 1 ? 0 : marginPerSide;
      return getWidth(item) + marginLeft + marginRight;
    });
  }

  // When the overflowMenuButton is showns, it's always at the end, so it has
  // no right margin.
  let overflowMenuButtonWidth = 0;
  if (overflowMenuButton) {
    overflowMenuButtonWidth = getWidth(overflowMenuButton) + marginPerSide;
  }

  return {
    itemWidths: itemWidths,
    overflowMenuButtonWidth: overflowMenuButtonWidth
  };
}

function getWidth(element) {
  return element && element.offsetWidth || 0;
}

function getFirstOverflownIndex(space, sizes) {
  let count = 0;
  let used = 0;
  while (sizes[count] !== undefined && used < space) {
    used += sizes[count];
    // This is actually expected to return up to .length of the sizes.
    // That will be the case when everything fits.
    count++;
  }
  if (used < space) {
    return count;
  }
  return count - 1;
}

// Matchers allow you to tell a tab to be active for a pattern of the app arguments.
// If you define data-navbar-item-matcher="user:.*?:playlist:.*$" you tell the tab
// to be active when the arguments match that regexp.
const getMatchers = function (node) {
  let matchers = node.querySelectorAll(getSelector(ITEM_MATCHER_ATTR_NAME));
  if (!matchers.length) return;

  matchers = Array.prototype.slice.call(matchers);
  matchers.forEach(function (matcher) {
    const regexp = matcher.getAttribute(ITEM_MATCHER_ATTR_NAME);
    const id = matcher.getAttribute(ITEM_ID_ATTR_NAME);
    storedMatchers[regexp] = id;
  });
};

const onApplicationChange = function (event) {
  if ('arguments' in event || 'active' in event) {
    updateForNode(document.documentElement);
  }
};

let isAttached = false;

exports.update = function update(node) {
  if (!isAttached) return;

  updateForNode(node || document.documentElement);
  getMatchers(node || document.documentElement);
  updateForOverflow(node || document.documentElement);
};

exports.attach = function attach() {
  if (isAttached) return;
  isAttached = true;

  $(document).delegate('click', getSelector(ITEM_ID_ATTR_NAME), handleClick);
  window.addEventListener('message', onMessage);
  live(APPLICATION_MODEL_URI).on('update', onApplicationChange);
  window.addEventListener('resize', handleResize);
  center.on('navbar-hide', hideOverflow);
};

exports.detach = function detach() {
  if (!isAttached) return;
  isAttached = false;

  navbarOverflowItems = null;
  isShowingNavbarOverflow = false;
  shouldShowNavbarOverflow = false;

  $(document).undelegate('click', getSelector(ITEM_ID_ATTR_NAME), handleClick);
  window.removeEventListener('message', onMessage);
  live(APPLICATION_MODEL_URI).off('update', onApplicationChange);
  window.removeEventListener('resize', handleResize);
  center.off('navbar-hide', hideOverflow);
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../live":210,"../spotify-elements":251,"./center":262}],307:[function(require,module,exports){
'use strict';

const $ = require('../spotify-elements');
const live = require('../live');

let sessionModel;

function onSessionUpdate(properties) {
  if ('online' in properties) {
    if (properties.online) {
      $(document.body).removeClass('offline');
    } else {
      $(document.body).addClass('offline');
    }
  }
}

function updateWithSessionValue() {
  live('spotify:client').query('session(online)', function (error, data) {
    if (error) throw error;
    onSessionUpdate({ online: data.session.online });
  });
}

let isAttached = false;

exports.update = function () {
  if (!isAttached) return;

  updateWithSessionValue();
};

exports.attach = function () {
  if (isAttached) return;
  isAttached = true;

  if (!sessionModel) {
    live('spotify:client').get('session', function (error, session) {
      if (error) throw error;
      sessionModel = session;
      sessionModel.on('update', onSessionUpdate);
    });
  }
};

exports.detach = function () {
  if (!isAttached) return;
  isAttached = false;

  if (sessionModel) {
    sessionModel.off('update', onSessionUpdate);
    sessionModel = null;
  }
};

},{"../live":210,"../spotify-elements":251}],308:[function(require,module,exports){
'use strict';

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

/**
 * @private
 */

const $ = require('../../spotify-elements');
const utils = require('./utils');

const SELECTOR_LIST_ROW = '[data-context] [data-list-item]';
const SELECTOR_PLAY_BUTTON = '[data-button=play]';
const SELECTOR_PLAY_CONTEXT_BUTTON = '[data-button=play-context]';

// This array will store event types for touch handling
let lastEventTypes = [];

// Methods that need implementation from another module.
// This is to support generic handling of user actions from within this module,
// but allow further checks and actions to be performed by another module. This
// allows multiple different implementations of starting playback for example.
const methods = {
  getPlayerVariantUri: utils.createEmptyMethod('getPlayerVariantUri'),
  handlePlayButton: utils.createEmptyMethod('handlePlayButton'),
  handlePlayFromRow: utils.createEmptyMethod('handlePlayFromRow')
};

/**
 * Handle the click of a play button.
 *
 * @param {MouseEvent} event An event object for a click event.
 * @param {Elements} button An element instance from the `elements` package.
 *
 * @private
 */
function handlePlayButtonClick(event, button) {
  const buttonNode = button[0];
  const buttonContextUri = utils.getUriFromButton(buttonNode);

  // We need an associated context URI for the button
  if (!buttonContextUri) {
    return;
  }

  const playerContextUri = methods.getPlayerVariantUri();
  const isPlayingContext = methods.getPlayerTrackProvider() !== 'queue' && utils.compareContexts(playerContextUri, buttonContextUri);

  const source = utils.getAttributeValueFromNode(buttonNode, 'data-play-source');

  methods.handlePlayButton(buttonNode, {
    isPlayingContext: isPlayingContext,
    contextUri: buttonContextUri,
    source: source,
    reason: 'playbtn'
  });
}

/**
 * Handle the double click or tap of a list row to start playback.
 *
 * @param {Elements} row An element instance from the `elements` package.
 *
 * @private
 */
function handleListRow(row) {
  const rowNode = row[0];
  const contextNode = $(rowNode.closest('[data-context]'));
  if (contextNode && !rowNode.classList.contains('thumbs-down')) {
    const source = utils.getAttributeValueFromNode(rowNode, 'data-play-source');
    methods.handlePlayFromRow(rowNode, {
      contextUri: contextNode.data('uri'),
      source: source,
      reason: 'clickrow'
    });
  }
}

/**
 * Handle double clicking on a list row to start playback.
 *
 * @param {MouseEvent} event An event object for a double click.
 * @param {Elements} row An element instance from the `elements` package.
 *
 * @private
 */
function handleRowDoubleClick(event, row) {
  // Only play when not clicking on interactive elements such as buttons
  if (!utils.isInteractiveElement(event.target)) {
    handleListRow(row);
  }
}

/**
 * Handle a key press on a list row.
 * This will take care of starting playback when pressing Enter.
 *
 * @param {KeyboardEvent} event A keyboard event.
 * @param {Elements} row An element instance from the `elements` package.
 *
 * @private
 */
function handleRowKeyDown(event, row) {
  const isEnter = event.keyCode === 13;
  if (isEnter) {
    if (utils.isFormOrLinkElement(event.target)) {
      return;
    }

    event.preventDefault();
    event.stopPropagation();

    handleListRow(row);
  }
}

/**
 * Handle the 'contextmenu' event. This is only for touch handling.
 * This is needed since we use a custom context menu in Spotify, and the handler
 * for that calls `preventDefault` for the 'contextmenu' event, which means the
 * rest of the touch handling will go on as usual. So as we don't get the
 * 'touchcancel' event, we need to catch the 'contextmenu' event here to know
 * that we should not act on the following 'touchend' event.
 *
 * @param {MouseEvent} event A 'contextmenu' event.
 *
 * @private
 */
function handleContextMenu(event) {
  lastEventTypes.push(event.type);
}

/**
 * Handle the start of a touch. Used to detect a tap.
 *
 * @param {TouchEvent} event A touch event.
 *
 * @private
 */
function handleRowTouchStart(event) {
  lastEventTypes.push(event.type);
}

/**
 * Handle the move of a touch. Used to abort detection of a tap.
 *
 * @param {TouchEvent} event A touch event.
 *
 * @private
 */
function handleRowTouchMove(event) {
  lastEventTypes.push(event.type);
}

/**
 * Handle the end of a touch. Used to detect a tap and start playback of a row.
 *
 * @param {TouchEvent} event A touch event.
 * @param {Elements} row An element instance from the `elements` package.
 *
 * @private
 */
function handleRowTouchEnd(event, row) {
  // If this was a tap (only touchstart was triggered before this)
  if (lastEventTypes.length === 1 && lastEventTypes[0] === 'touchstart') {
    // Prevent the simulated mouse events (including click). This is to
    // avoid the simulated click event to click on the play button that
    // appears when selecting a row on touchstart.
    // See: https://jira.spotify.net/browse/KM-7983
    if (!utils.isInteractiveElement(event.target)) {
      event.preventDefault();

      // Tapping on a row should play it
      handleListRow(row);
    }
  }
  lastEventTypes = [];
}

/**
 * Attach the needed event listeners for the module.
 */
const defaultSelectors = {
  selectorPlayButton: SELECTOR_PLAY_BUTTON,
  selectorListRow: SELECTOR_LIST_ROW,
  selectorPlayContextButton: SELECTOR_PLAY_CONTEXT_BUTTON
};
let selectors = defaultSelectors;

exports.attach = function () {
  const doc = $(document);

  doc.delegate('keydown', selectors.selectorListRow, handleRowKeyDown);
  doc.delegate('click', selectors.selectorPlayButton, handlePlayButtonClick);
  doc.delegate('click', selectors.selectorPlayContextButton, handlePlayButtonClick);
  doc.delegate('dblclick', selectors.selectorListRow, handleRowDoubleClick);

  /* For touch handling */
  doc.delegate('touchstart', selectors.selectorListRow, handleRowTouchStart);
  doc.delegate('touchend', selectors.selectorListRow, handleRowTouchEnd);
  doc.delegate('touchmove', selectors.selectorListRow, handleRowTouchMove);
  doc.delegate('contextmenu', selectors.selectorListRow, handleContextMenu);
};

/**
 * Detach the event listeners for the module.
 */
exports.detach = function () {
  const doc = $(document);

  doc.undelegate('keydown', selectors.selectorListRow, handleRowKeyDown);
  doc.undelegate('click', selectors.selectorPlayButton, handlePlayButtonClick);
  doc.undelegate('click', selectors.selectorPlayContextButton, handlePlayButtonClick);
  doc.undelegate('dblclick', selectors.selectorListRow, handleRowDoubleClick);

  /* For touch handling */
  doc.undelegate('touchstart', selectors.selectorListRow, handleRowTouchStart);
  doc.undelegate('touchend', selectors.selectorListRow, handleRowTouchEnd);
  doc.undelegate('touchmove', selectors.selectorListRow, handleRowTouchMove);
  doc.undelegate('contextmenu', selectors.selectorListRow, handleContextMenu);
};

exports.setSelectors = function (customSelectors = {}) {
  exports.detach();
  selectors = _extends({}, defaultSelectors, customSelectors);
  exports.attach();
};

/**
 * Set the external methods for this module to add implementations for starting
 * playback etc.
 *
 * @param {Object} methodDefinitions Object where keys are method names and
 *     values are functions.
 */
exports.setMethods = function (methodDefinitions) {
  for (const name in methodDefinitions) {
    if (methodDefinitions.hasOwnProperty(name)) {
      methods[name] = methodDefinitions[name];
    }
  }
};

},{"../../spotify-elements":251,"./utils":311}],309:[function(require,module,exports){
'use strict';

const playerWithIndices = require('./withIndices');
const playerWithUids = require('./withUids');
const actions = require('./actions');

let playerModule = playerWithIndices;

exports.setMode = function (type) {
  switch (type) {
    case 'indices':
      playerModule = playerWithIndices;
      break;
    case 'uids':
      playerModule = playerWithUids;
      break;
    default:
      break;
  }
};

exports.setSelectors = actions.setSelectors;

exports.attach = function () {
  playerModule.attach();
};

exports.detach = function () {
  playerModule.detach();
};

exports.update = function (optNode) {
  playerModule.update(optNode);
};

},{"./actions":308,"./withIndices":312,"./withUids":313}],310:[function(require,module,exports){
'use strict';

/**
 * @private
 */

const difference = require('mout/array/difference');
const $ = require('../../spotify-elements');
const live = require('../../live');

const center = require('../center');
const utils = require('./utils');

const CURRENT = 'current';
const PAUSED = 'paused';
const PLAYING = 'playing';

const LOG_PLAY_BUTTON = 'play-button';
const LOG_PAUSE_BUTTON = 'pause-button';
const LOG_INTENT_PLAY = 'play';
const LOG_INTENT_PAUSE = 'pause';

const SELECTOR_PLAY_BUTTON = '[data-button=play]';
const SELECTOR_PLAY_CONTEXT_BUTTON = '[data-button=play-context]';
const SELECTOR_ALL_PLAY_BUTTONS = `${SELECTOR_PLAY_BUTTON},${SELECTOR_PLAY_CONTEXT_BUTTON}`;

const INTERACTION_INTENT_ATTR = 'data-interaction-intent';
const SELECTOR_PLAYABLE_ROW = '[data-context-index]';

// Methods that need implementation from another module.
// This is to support generic handling of DOM updates from within this module,
// but allow further checks and actions to be performed by another module. This
// allows multiple different implementations of highlighting playing objects.
const methods = {
  getPlayerVariantUri: utils.createEmptyMethod('getPlayerVariantUri'),
  getPlayerIsPlaying: utils.createEmptyMethod('getPlayerIsPlaying'),
  getPlayingNodes: utils.createEmptyMethod('getPlayingNodes'),

  // This should be a function that takes a function as the first argument. That
  // function argument should be called whenever the player state has changed.
  subscribeToPlayerChange: utils.createEmptyMethod('subscribeToPlayerChange')
};

let playableChangeHandlers = {};
let playerSubscription = null;

/**
 * Update states in the DOM based on current player state.
 *
 * @param {HTMLElement=} node An optional DOM node. If passed, only nodes inside
 *     of that node will be updated.
 */
function updateDOM(optNode) {
  const containerNode = optNode || document;

  updateButtonsBasedOnPlayable(containerNode);

  const playingNodes = getPlayingNodes(containerNode);
  const currentNodes = getCurrentNodes(containerNode);

  if (currentNodes) {
    let nodesForRemoval = currentNodes;
    if (playingNodes) {
      nodesForRemoval = difference(currentNodes, playingNodes);
    }
    nodesForRemoval.forEach(removePlayingStateFromNode);
  }

  if (playingNodes) {
    let nodesForAddition = playingNodes;
    if (currentNodes) {
      nodesForAddition = difference(playingNodes, currentNodes);
    }
    nodesForAddition.forEach(addPlayingStateToNode);

    const nodesForUpdate = difference(playingNodes, nodesForAddition);
    nodesForUpdate.forEach(updatePlayingStateForNode);
  }
}

/**
 * Update the playable status of all play buttons found inside the passed
 * container node.
 *
 * @param {HTMLElement} containerNode A DOM node to search for nodes inside.
 *
 * @private
 */
function updateButtonsBasedOnPlayable(containerNode) {
  // `[data-button=play]` buttons are used to play something specific *in* a
  // context (defining an index as a track number or uid/uri or range).
  // Those are currently not updated themselves, instead their rows are being
  // set to `.unavailable`.
  const buttons = $(containerNode).search('[data-button=play-context]');
  if (buttons) {
    buttons.forEach(updateButtonBasedOnPlayable);
  }
}

/**
 * Update the playable status of the passed button.
 *
 * @param {HTMLElement} button A button DOM node.
 *
 * @private
 */
function updateButtonBasedOnPlayable(button) {
  // Play buttons in list rows should not be handled, as the buttons are
  // hidden by CSS anyway for unplayable rows.
  if ($(button).parent('[data-list-item]')) {
    return;
  }

  const contextURI = utils.getUriFromButton(button);

  // Check if the context has a playable flag specified.
  const playableValue = live(contextURI).get('playable');
  const definesPlayable = playableValue !== undefined;

  // If it does, update the `disabled` attribute based on it
  if (definesPlayable) {
    if (playableValue) {
      button.removeAttribute('disabled');
    } else {
      button.setAttribute('disabled', 'disabled');
    }

    if (!playableChangeHandlers[contextURI]) {
      playableChangeHandlers[contextURI] = function (changed) {
        if (!changed.hasOwnProperty('playable')) {
          return;
        }
        // Update all buttons currently in DOM when `playable` changes on a
        // context. Not worth adding logic to only pick out buttons pointing to
        // a specific URI.
        updateButtonsBasedOnPlayable(document.body);
      };
      live(contextURI).on('update', playableChangeHandlers[contextURI]);
    }
  }
}

/**
 * Get the nodes inside the passed container node that are currently marked as
 * playing.
 *
 * @param {HTMLElement} containerNode A DOM node to search for nodes inside.
 *
 * @return {?Elements} An element instance from the `elements` package, or null.
 *
 * @private
 */
function getCurrentNodes(containerNode) {
  return $(containerNode).search('[data-playback-active=true]');
}

/**
 * Get the nodes inside the passed container node that should be marked as
 * playing based on the current player state.
 *
 * @param {HTMLElement} containerNode A DOM node to search for nodes inside.
 *
 * @return {?Elements} An element instance from the `elements` package, or null.
 *
 * @private
 */
function getPlayingNodes(containerNode) {
  let contextNodes = [];

  if (methods.getPlayerTrackProvider() !== 'queue') {
    const variantUri = methods.getPlayerVariantUri();
    const selectors = utils.getContextSelectorsWithVariants(variantUri);

    const foundContextNodes = $(containerNode).search(selectors.join(', '));
    if (foundContextNodes) {
      contextNodes = Array.prototype.slice.call(foundContextNodes);
    }
  }

  // Pass it through the outside implementation, which might filter out
  // nodes from `contextNodes` and add more nodes to the match.
  return methods.getPlayingNodes(containerNode, contextNodes);
}

/**
 * Remove the playing state from the passed DOM node, as it's no longer playing.
 *
 * @param {HTMLElement} node The DOM node to remove state from.
 *
 * @private
 */
function removePlayingStateFromNode(node) {
  const className = [CURRENT, PAUSED, PLAYING].join(' ');
  const newNode = $(node);
  newNode.removeClass(className).removeAttribute('data-playback-active');

  if (newNode.matches(SELECTOR_ALL_PLAY_BUTTONS)) {
    newNode.attribute('data-log-click', LOG_PLAY_BUTTON);
    newNode.attribute(INTERACTION_INTENT_ATTR, LOG_INTENT_PLAY);
  }

  // Play buttons in list rows are not handled automatically
  if (newNode.matches(SELECTOR_PLAYABLE_ROW)) {
    const playButton = newNode[0].querySelector(SELECTOR_PLAY_BUTTON);
    if (playButton) {
      playButton.setAttribute(INTERACTION_INTENT_ATTR, LOG_INTENT_PLAY);
    }
  }
}

/**
 * Add the playing state to the passed DOM node, as it's now playing.
 *
 * @param {HTMLElement} node The DOM node to add state to.
 *
 * @private
 */
function addPlayingStateToNode(node) {
  const isPlaying = methods.getPlayerIsPlaying();

  const classNames = [CURRENT, isPlaying ? PLAYING : PAUSED].join(' ');

  const newNode = $(node);
  newNode.addClass(classNames).data('playback-active', true);

  if (newNode.matches(SELECTOR_ALL_PLAY_BUTTONS)) {
    newNode.attribute('data-log-click', isPlaying ? LOG_PAUSE_BUTTON : LOG_PLAY_BUTTON);
    newNode.attribute(INTERACTION_INTENT_ATTR, isPlaying ? LOG_INTENT_PAUSE : LOG_INTENT_PLAY);
  }

  // Play buttons in list rows are not handled automatically
  if (newNode.matches(SELECTOR_PLAYABLE_ROW)) {
    const playButton = newNode[0].querySelector(SELECTOR_PLAY_BUTTON);
    if (playButton) {
      playButton.setAttribute(INTERACTION_INTENT_ATTR, isPlaying ? LOG_INTENT_PAUSE : LOG_INTENT_PLAY);
    }
  }
}

/**
 * Update the playing state for the passed DOM node, as it's still representing
 * the currently playing context, but the player might switch between
 * playing/paused.
 *
 * @param {HTMLElement} node The DOM node to update state for.
 *
 * @private
 */
function updatePlayingStateForNode(node) {
  const isPlaying = methods.getPlayerIsPlaying();

  const currentClassName = isPlaying ? PAUSED : PLAYING;
  const newClassName = isPlaying ? PLAYING : PAUSED;
  const element = $(node);

  if (element.hasClass(currentClassName)) {
    element.removeClass(currentClassName);
  }

  if (!element.hasClass(newClassName)) {
    element.addClass(newClassName);
  }

  if (element.matches(SELECTOR_ALL_PLAY_BUTTONS)) {
    element.attribute('data-log-click', isPlaying ? LOG_PAUSE_BUTTON : LOG_PLAY_BUTTON);
    element.attribute(INTERACTION_INTENT_ATTR, isPlaying ? LOG_INTENT_PAUSE : LOG_INTENT_PLAY);
  }

  // Play buttons in list rows are not handled automatically
  if (node.matches(SELECTOR_PLAYABLE_ROW)) {
    const playButton = node.querySelector(SELECTOR_PLAY_BUTTON);
    if (playButton) {
      playButton.setAttribute(INTERACTION_INTENT_ATTR, isPlaying ? LOG_INTENT_PAUSE : LOG_INTENT_PLAY);
    }
  }
}

/**
 * Handle updating of DOM nodes when they have been added to the DOM by a scroll
 * agent.
 *
 * @param {Object} event Custom event object sent from the scroll agent. Should
 *     contain a `container` property pointing to the DOM node containing the
 *     rows.
 *
 * @private
 */
function handleScrollShowAfter(event) {
  const container = $(event.container);
  let contextNode = null;
  if (container.matches('[data-context]')) {
    contextNode = container;
  } else {
    contextNode = container.parent('[data-context]');
  }

  // We can't pass the context node itself as root because of how the playing
  // state queries are set up.
  const contextParent = contextNode && contextNode[0].parentElement || document;

  updateDOM(contextParent);
}

/**
 * Attach the needed event listeners for the module.
 */
exports.attach = function () {
  playerSubscription = methods.subscribeToPlayerChange(function () {
    updateDOM();
  });

  center.on('scroll-show-after', handleScrollShowAfter);
};

/**
 * Detach the needed event listeners for the module.
 */
exports.detach = function () {
  if (playerSubscription) {
    playerSubscription.cancel();
    playerSubscription = null;
  }

  for (const contextUri in playableChangeHandlers) {
    if (playableChangeHandlers.hasOwnProperty(contextUri)) {
      live(contextUri).off('update', playableChangeHandlers[contextUri]);
    }
  }
  playableChangeHandlers = {};

  center.off('scroll-show-after', handleScrollShowAfter);
};

/**
 * Update things in the DOM.
 */
exports.update = updateDOM;

/**
 * Set the external methods for this module to add implementations for methods
 * needed for highlighting playing objects.
 *
 * @param {Object} methodDefinitions Object where keys are method names and
 *     values are functions.
 */
exports.setMethods = function (methodDefinitions) {
  for (const name in methodDefinitions) {
    if (methodDefinitions.hasOwnProperty(name)) {
      methods[name] = methodDefinitions[name];
    }
  }
};

},{"../../live":210,"../../spotify-elements":251,"../center":262,"./utils":311,"mout/array/difference":444}],311:[function(require,module,exports){
(function (global){
'use strict';

/**
 * This module might be used by modules outside of spotify-events.
 * @public
 */

const liburi = require('spotify-liburi');

const getOriginUri = require('../../live-wrapped-uri').getOriginUri;

/**
 * Get the context URI from a button node or its parents.
 *
 * @param {HTMLElement} button A DOM node for a button.
 *
 * @return {string} The context URI or empty string if not found.
 */
function getUriFromButton(button) {
  const contextNode = button.closest('[data-context]');
  return contextNode && contextNode.getAttribute('data-uri') || '';
}

/**
 * Get the value for the passed attribute name, either from the passed node or
 * from any parent node.
 *
 * @param {HTMLElement} node The node to start searching from.
 * @param {string} attributeName The name of the attribute.
 *
 * @return {string} The value, or empty string if not found.
 */
function getAttributeValueFromNode(node, attributeName) {
  const selector = `[${attributeName}]`;
  const attributeNode = node.closest(selector);
  return attributeNode && attributeNode.getAttribute(attributeName) || '';
}

/**
 * Check if the passed element is a form or link element.
 *
 * @param {HTMLElement} element A DOM node.
 *
 * @return {boolean} True if it is a form or link element.
 */
function isFormOrLinkElement(element) {
  const tagName = element.tagName.toLowerCase();
  const elements = ['input', 'textarea', 'button', 'select', 'optgroup', 'option', 'a'];
  return elements.indexOf(tagName) > -1;
}

/**
 * Check if the passed element is an interactive element (links, buttons).
 *
 * @param {HTMLElement}  element A DOM node.
 *
 * @return {boolean} True if the element is interactive.
 */
function isInteractiveElement(element) {
  const tagName = element.tagName.toLowerCase();
  return tagName === 'a' || tagName === 'button';
}

/**
 * Get a CSS selector string for a context.
 *
 * @param {string} operator A CSS selector operator ($= or similar).
 * @param {string} uri The context URI.
 *
 * @return {string} The CSS selector string.
 */
function getContextSelector(operator, uri) {
  return `[data-context][data-uri${operator}${uri}]`;
}

/**
 * Get an array of CSS selectors for searching for context nodes inside the DOM.
 * This also includes any variant of the passed context URI. For example, if
 * passing a sorted playlist URI, it will return selectors for matching all
 * variations of that playlist URI, including the regular playlist URI, filtered
 * URI etc.
 *
 * @param {string} uri The context URI to search for. This can be either the
 *     origin URI, or any variant URI. The function will convert it to the
 *     origin URI automatically.
 *
 * @return {Array.<string>} Array of CSS selector strings.
 */
function getContextSelectorsWithVariants(uri) {
  const STARTS_WITH = '^=';
  const ENDS_WITH = '$=';
  const EQUALS = '=';

  const originUri = getOriginUri(uri) || uri;
  const originUriNormalized = normalizeUri(originUri);

  const originUriEnding = originUri.replace(/^spotify:/, ':');
  const originUriEndingNormalized = normalizeUri(originUriEnding);

  const selectors = [getContextSelector(EQUALS, originUri)];

  selectors.push(getContextSelector(STARTS_WITH, 'spotify:internal:filterlist:') + getContextSelector(ENDS_WITH, originUri.replace(/^spotify:/, ':')));

  selectors.push(getContextSelector(STARTS_WITH, 'spotify:internal:sortlist:') + getContextSelector(ENDS_WITH, originUri.replace(/^spotify:/, ':')));

  if (originUri !== originUriNormalized) {
    selectors.push(getContextSelector(EQUALS, originUriNormalized));
    selectors.push(getContextSelector(STARTS_WITH, 'spotify:internal:filterlist:') + getContextSelector(ENDS_WITH, originUriEndingNormalized));
    selectors.push(getContextSelector(STARTS_WITH, 'spotify:internal:sortlist:') + getContextSelector(ENDS_WITH, originUriEndingNormalized));
  }

  return selectors;
}

/**
 * Check if two context URIs are representing the same context. This will take
 * care of normalizing the casing of URL encoding and filtered/sorted contexts.
 *
 * @param {string} context1 The first context.
 * @param {string} context2 The second context.
 *
 * @return {boolean} True if they represent the same context.
 */
function compareContexts(context1, context2) {
  if (!context1 || !context2) return false;

  const newContext1 = normalizeUri(getOriginUri(context1) || context1);
  const newContext2 = normalizeUri(getOriginUri(context2) || context2);

  return newContext1 === newContext2;
}

/**
 * A URI might contain URL encoded characters, and per spec the URL encoding can
 * be either in lowercase or uppercase (should be treated as same URL). If the
 * input URL has lowercase encoding, liburi will convert it into uppercase
 * encoding.
 *
 * @param {string} uri The URI to normalize.
 *
 * @return {string} The normalized URI.
 */
function normalizeUri(uri) {
  const uriObj = liburi.from(uri);
  let normalized = uriObj ? uriObj.toString() : uri;

  // Work around incorrect handling of `spotify:internal:...` URIs by liburi,
  // since it does not recognize `internal` URIs, and therefore uses the default
  // `app` type.
  normalized = normalized.replace(/^spotify:app:internal:/, 'spotify:internal:');

  // Work around the bad conversion of spaces in filtered list URIs. The URI
  // spec we use says that spaces should be encoded as `+`, but the `filterlist`
  // URI uses the regular `%20` encoding for spaces. Passing it through liburi
  // converts it to `+`, so we need to convert it back to `%20` again.
  normalized = normalized.replace(/:internal:filterlist:[^:]+/, function (match) {
    return match.replace(/\+/g, '%20');
  });

  return normalized;
}

/**
 * Create an empty method that will only log a warning when called.
 *
 * @param {string} methodName The name of the method to warn about.
 *
 * @return {Function} The function.
 */
function createEmptyMethod(methodName) {
  return function () {
    if (global.console) {
      console.warn(`spotify-events/player: \`${methodName}\` is not implemented.`);
    }
  };
}

exports.getUriFromButton = getUriFromButton;
exports.getAttributeValueFromNode = getAttributeValueFromNode;
exports.isFormOrLinkElement = isFormOrLinkElement;
exports.isInteractiveElement = isInteractiveElement;
exports.getContextSelector = getContextSelector;
exports.getContextSelectorsWithVariants = getContextSelectorsWithVariants;
exports.compareContexts = compareContexts;
exports.normalizeUri = normalizeUri;
exports.createEmptyMethod = createEmptyMethod;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../live-wrapped-uri":209,"spotify-liburi":730}],312:[function(require,module,exports){
'use strict';

/**
 * @private
 */

const live = require('../../live');
const Range = require('../../range2');
const $ = require('../../spotify-elements');

const playerActions = require('./actions');
const playerUpdates = require('./updates');
const utils = require('./utils');

let isAttached = false;

exports.attach = function () {
  if (isAttached) return;
  isAttached = true;

  playerActions.setMethods({
    getPlayerTrackProvider: getPlayerTrackProvider,
    getPlayerVariantUri: getPlayerVariantUri,
    handlePlayButton: handlePlayButton,
    handlePlayFromRow: handlePlayFromRow
  });

  playerUpdates.setMethods({
    getPlayerTrackProvider: getPlayerTrackProvider,
    getPlayerVariantUri: getPlayerVariantUri,
    getPlayerIsPlaying: getPlayerIsPlaying,
    getPlayingNodes: getPlayingNodes,
    subscribeToPlayerChange: subscribeToPlayerChange
  });

  playerActions.attach();
  playerUpdates.attach();
};

exports.detach = function () {
  if (!isAttached) return;
  isAttached = false;

  playerActions.detach();
  playerUpdates.detach();
};

exports.update = function (optNode) {
  if (!isAttached) return;

  playerUpdates.update(optNode);
};

function getPlayerTrackProvider() {
  const track = live('spotify:player').get('track');
  return track ? track.get('provider') || '' : '';
}

/**
 * Get the variant URI for the currently playing context. For example, if
 * playing a sorted playlist, this should return the sorted URI.
 *
 * @return {string} The context variant URI, or empty string if nothing is
 *     playing.
 */
function getPlayerVariantUri() {
  const variant = live('spotify:player').get('variant');
  return variant ? variant.uri : '';
}

/**
 * Get the index of the currently playing track within the playing context.
 *
 * @return {number} The index, or -1 if not found.
 */
function getPlayerIndex() {
  const indexObject = live('spotify:player').get('index');
  return indexObject ? indexObject.get('track') : -1;
}

/**
 * Get the URI of the currently playing track.
 *
 * @return {string} The track URI, or empty string if nothing is playing.
 */
function getPlayerTrackUri() {
  const track = live('spotify:player').get('track');
  return track && track.uri || '';
}

/**
 * Get the playing status of the player.
 *
 * @return {boolean} True if the player is currently playing audio.
 */
function getPlayerIsPlaying() {
  const isPlaying = live('spotify:player').get('isPlaying');
  const isPaused = live('spotify:player').get('isPaused');
  return isPlaying && !isPaused;
}

/**
 * Subscribe to player changes.
 *
 * @param {Function} handler A handler function. The data passed to this
 *     function is irrelevent, only the fact that something changed is needed.
 *
 * @return {Object} An object with a `cancel` method to cancel the subscription.
 */
function subscribeToPlayerChange(handler) {
  live('spotify:player').on('update', handler);
  let active = true;
  return {
    cancel: function () {
      if (active) {
        live('spotify:player').off('update', handler);
        active = false;
      }
    }
  };
}

/**
 * Handle the click of a play button.
 * This function should decide what the action should be, and pause/resume
 * playback or start playback of a new context.
 *
 * @param {HTMLElement} buttonNode A button DOM node.
 * @param {Object} data Object of data about the action:
 *     isPlayingContext: (boolean) Whether the button looks to be representing
 *         the currently playing context.
 *     contextUri: (string) The context URI for the button.
 *     source: (string) The 'play source' value, for logging purposes.
 *     reason: (string) The 'play reason' value, for logging purposes.
 */
function handlePlayButton(buttonNode, data) {
  const button = $(buttonNode);
  const playerIndex = getPlayerIndex();
  let range;
  let newIndex;
  let uids;
  let uris;

  const dataRange = button.data('range');
  if (dataRange) {
    range = Range.fromString(dataRange);
    const list = live(data.contextUri).get('rows');
    if (list) {
      const indices = range.toIndices();
      uids = indices.map(function (index) {
        return list.keys[index];
      });
      uris = indices.map(function (index) {
        const track = list.get(index).get('track');
        return track.uri;
      });
    }
    newIndex = null;
  } else {
    let contextIndexNode = null;
    if (button.matches('[data-context-index]')) {
      contextIndexNode = button;
    } else {
      contextIndexNode = button.parent('[data-context-index]');
    }

    if (contextIndexNode) {
      newIndex = parseInt(contextIndexNode.data('context-index'), 10);
      const list = live(data.contextUri).get('rows');
      if (list) {
        uids = [list.keys[newIndex]];
        uris = [list.get(newIndex).get('track').uri];
      }
    } else {
      newIndex = null;
    }
  }

  let shouldPauseResume = false;

  if (data.isPlayingContext) {
    if (range) {
      shouldPauseResume = range.contains(new Range(playerIndex, playerIndex + 1));
    } else if (newIndex !== null) {
      shouldPauseResume = newIndex === playerIndex;
    } else {
      shouldPauseResume = true;
    }
  }

  if (shouldPauseResume) {
    if (getPlayerIsPlaying()) {
      live('spotify:player').emit('pause');
    } else {
      live('spotify:player').emit('resume');
    }
  } else {
    const eventData = {
      context: data.contextUri,
      index: newIndex,
      source: data.source,
      reason: data.reason
    };

    if (range) {
      eventData.range = [range.start, range.end];
    }

    if (uids) {
      eventData.uids = uids;
    }

    if (uris) {
      eventData.uris = uris;
    }

    live('spotify:player').emit('play', eventData);
  }
}

/**
 * Handle playing a list row. This function should start playback of a context
 * starting from a specific row.
 *
 * @param {HTMLElement} rowNode A DOM node for a list row.
 * @param {Object} data Object of data about the action:
 *     contextUri: (string) The context URI for the list.
 *     source: (string) The 'play source' value, for logging purposes.
 *     reason: (string) The 'play reason' value, for logging purposes.
 */
function handlePlayFromRow(rowNode, data) {
  let index = parseInt(rowNode.getAttribute('data-context-index'), 10);
  if (isNaN(index)) {
    index = -1;
  }
  const uid = rowNode.getAttribute('data-uid') || '';
  const uri = rowNode.getAttribute('data-uri') || '';

  const eventData = {
    context: data.contextUri,
    index: index,
    source: data.source,
    reason: data.reason
  };

  if (uid) {
    eventData.uids = [uid];
  }

  if (uri) {
    eventData.uris = [uri];
  }

  live('spotify:player').emit('play', eventData);
}

/**
 * Get the nodes inside the passed container node that should be marked as
 * playing.
 *
 * @param {HTMLElement} containerNode The DOM node to search inside.
 * @param {Array.<HTMLElement>} contextNodes Array of DOM nodes that are already
 *     matched based on context URIs. These can be filtered if needed, but
 *     otherwise they should be included in the return value.
 *
 * @return {Array.<HTMLElement>} An array of DOM nodes.
 */
function getPlayingNodes(containerNode, contextNodes) {
  const playerIndex = getPlayerIndex();
  const playerTrackUri = getPlayerTrackUri();
  const variantUri = getPlayerVariantUri();

  // Remove any matched context nodes that have a range specified and where
  // the current player index does not match.
  const filteredContextNodes = filterRanges(playerIndex, contextNodes);

  const selectorsWithVariants = utils.getContextSelectorsWithVariants(variantUri);

  const rowNodes = getContextNodesForRows(containerNode, selectorsWithVariants, playerIndex, playerTrackUri) || [];

  const rangeNodes = getContextNodesForRanges(containerNode, selectorsWithVariants, playerIndex) || [];

  // Only return button nodes whos closest context is one of the nodes in the
  // contextNodes array. Imagine this minimal node tree:
  //
  // [data-context][data-uri="spotify:root-context"]
  //   [data-button=play-context]
  //   [data-context][data-uri="spotify:nested-context"]
  //     [data-button=play-context]
  //
  // The first [data-button=play-context] should play "spotify:root-context".
  // Ths second [data-button=play-context] should play "spotify:nested-context".
  let buttonNodes = [];
  if (contextNodes.length) {
    const candidates = $(contextNodes).search('[data-button=play-context]');
    if (candidates) {
      buttonNodes = candidates.filter(candidate => {
        const closestContextNode = candidate.closest('[data-context]');
        return contextNodes.indexOf(closestContextNode) >= 0;
      });
    }
  }

  // Let `elements` remove any duplicate nodes
  const nodes = $([filteredContextNodes, rowNodes, rangeNodes, buttonNodes]);

  return nodes ? Array.prototype.slice.call(nodes) : [];
}

/**
 * Get the nodes inside the passed container node that match what's currently
 * playing and are list rows.
 *
 * @param {HTMLElement} containerNode The DOM node to search inside.
 * @param {Array.<string>} selectors Array of CSS selectors for matching the
 *     currently playing context.
 * @param {number} index The currently playing index.
 * @param {string} trackUri The URI of the currently playing track.
 *
 * @return {Array.<HTMLElement>} Array of DOM nodes.
 */
function getContextNodesForRows(containerNode, selectors, index, trackUri) {
  // Per container node, find a node that's playing in two steps by finding
  // Attempt 1: the first node where the playing index and
  // the track uri matches.
  // Attempt 2: the first node where only the track uri matches [1].
  const uriSelector = `[data-uri="${trackUri}"]`;
  const indexAndUriSelector = `[data-context-index=${index}]${uriSelector}`;

  // Attempt 1
  const selectorsIndexAndUriSelector = selectors.map(s => `${s} ${indexAndUriSelector}`);
  const elemsViaIndexAndUriSelector = $(containerNode).find(selectorsIndexAndUriSelector);

  if (elemsViaIndexAndUriSelector) {
    return elemsViaIndexAndUriSelector;
  }

  // Attempt 2
  const selectorsUriSelector = selectors.map(s => `${s} ${uriSelector}`);
  return $(containerNode).find(selectorsUriSelector);

  // [1] The index is very likely wrong when while on shuffle, the playing
  // device has changed. Indices are then shuffled indices, and despite this
  // files is all about highlighting in "index mode" we can disregard the index.
}

/**
 * Get the nodes inside the passed container node that match what's currently
 * playing and have a matching range specified.
 *
 * @param {HTMLElement} containerNode The DOM node to search inside.
 * @param {Array.<string>} selectors Array of CSS selectors for matching the
 *     currently playing context.
 * @param {number} index The currently playing index.
 *
 * @return {Array.<HTMLElement>} Array of DOM nodes.
 */
function getContextNodesForRanges(containerNode, selectors, index) {
  const rangeAttribute = '[data-range]';

  // It needs to search for all range elements somewhere inside an element
  // marked up as a context, as well as range elements that themselves are
  // contexts.
  const newSelectors = selectors.map(function (s) {
    const rangeInContextSelector = `${s} ${rangeAttribute}`;
    const rangedContextSelector = s + rangeAttribute;
    const rangeSelector = `${rangeInContextSelector}, ${rangedContextSelector}`;
    return rangeSelector;
  });

  let rangeNodes = $(containerNode).search(newSelectors.join(', '));
  if (rangeNodes) {
    rangeNodes = Array.prototype.slice.call(rangeNodes);
  } else {
    rangeNodes = [];
  }

  return filterRanges(index, rangeNodes);
}

/**
 * Return a new array of nodes where nodes that specify a range that doesn't
 * match the currently playing index are removed.
 *
 * @param {number} index The currently playing index.
 * @param {Array.<HTMLElement>} nodes Array of DOM nodes.
 *
 * @return {Array.<HTMLElement>} Array of DOM nodes.
 */
function filterRanges(index, nodes) {
  const thisRange = new Range(index, index + 1);

  return nodes.filter(function (node) {
    const newNode = $(node);
    let range = newNode.data('range');

    // Node without a range should always be active
    if (!range) return true;

    // If player has no index, but the node has a range, we can't be sure if
    // it's playing
    if (!thisRange) return false;

    range = Range.fromString(range);
    return range.contains(thisRange);
  });
}

},{"../../live":210,"../../range2":245,"../../spotify-elements":251,"./actions":308,"./updates":310,"./utils":311}],313:[function(require,module,exports){
'use strict';

const live = require('../../live');
const $ = require('../../spotify-elements');

const playerActions = require('./actions');
const playerUpdates = require('./updates');
const utils = require('./utils');

let isAttached = false;

exports.attach = function () {
  if (isAttached) return;
  isAttached = true;

  playerActions.setMethods({
    getPlayerTrackProvider: getPlayerTrackProvider,
    getPlayerVariantUri: getPlayerVariantUri,
    handlePlayButton: handlePlayButton,
    handlePlayFromRow: handlePlayFromRow
  });

  playerUpdates.setMethods({
    getPlayerTrackProvider: getPlayerTrackProvider,
    getPlayerVariantUri: getPlayerVariantUri,
    getPlayerIsPlaying: getPlayerIsPlaying,
    getPlayingNodes: getPlayingNodes,
    subscribeToPlayerChange: subscribeToPlayerChange
  });

  playerActions.attach();
  playerUpdates.attach();
};

exports.detach = function () {
  if (!isAttached) return;
  isAttached = false;

  playerActions.detach();
  playerUpdates.detach();
};

exports.update = function (optNode) {
  if (!isAttached) return;

  playerUpdates.update(optNode);
};

function getPlayerTrackProvider() {
  const track = live('spotify:player').get('track');
  return track ? track.get('provider') || '' : '';
}

/**
 * Get the variant URI for the currently playing context. For example, if
 * playing a sorted playlist, this should return the sorted URI.
 *
 * @return {string} The context variant URI, or empty string if nothing is
 *     playing.
 */
function getPlayerVariantUri() {
  const variant = live('spotify:player').get('variant');
  return variant ? variant.uri : '';
}

/**
 * Get the index of the currently playing page.
 *
 * @return {number} The page index, or -1 if not found.
 */
function getPlayerPageIndex() {
  const indexObject = live('spotify:player').get('index');
  const pageIndex = indexObject && indexObject.get('page');
  const hasPageIndex = typeof pageIndex === 'number';
  return hasPageIndex ? pageIndex : -1;
}

/**
 * Get the UID of the currently playing track.
 *
 * @return {string} The UID, or empty string if not found.
 */
function getPlayerTrackUid() {
  return live('spotify:player').get('uid') || '';
}

/**
 * Get the URI of the currently playing track.
 *
 * @return {string} The track URI, or empty string if nothing is playing.
 */
function getPlayerTrackUri() {
  const track = live('spotify:player').get('track');
  return track && track.uri || '';
}

/**
 * Get the playing status of the player.
 *
 * @return {boolean} True if the player is currently playing audio.
 */
function getPlayerIsPlaying() {
  const isPlaying = live('spotify:player').get('isPlaying');
  const isPaused = live('spotify:player').get('isPaused');
  return isPlaying && !isPaused;
}

/**
 * Get whether the playback was initiated from open.spotify.com
 *
 * This info is needed to be able to do a best-effort of highlighting rows when
 * playing from open.
 *
 * @return {boolean} True if playing from open.spotify.com.
 */
function getPlayerIsPlayingFromOpen() {
  const playOrigin = live('spotify:player').get('playOrigin');
  const externalReferrer = playOrigin && playOrigin.get('externalReferrer');

  return externalReferrer && externalReferrer.indexOf('https://open.spotify.com/') === 0;
}

/**
 * Subscribe to player changes.
 *
 * @param {Function} handler A handler function. The data passed to this
 *     function is irrelevent, only the fact that something changed is needed.
 *
 * @return {Object} An object with a `cancel` method to cancel the subscription.
 */
function subscribeToPlayerChange(handler) {
  live('spotify:player').on('update', handler);
  let active = true;
  return {
    cancel: function () {
      if (active) {
        live('spotify:player').off('update', handler);
        active = false;
      }
    }
  };
}

/**
 * Handle the click of a play button.
 * This function should decide what the action should be, and pause/resume
 * playback or start playback of a new context.
 *
 * @param {HTMLElement} buttonNode A button DOM node.
 * @param {Object} data Object of data about the action:
 *     isPlayingContext: (boolean) Whether the button looks to be representing
 *         the currently playing context.
 *     contextUri: (string) The context URI for the button.
 *     source: (string) The 'play source' value, for logging purposes.
 *     reason: (string) The 'play reason' value, for logging purposes.
 */
function handlePlayButton(buttonNode, data) {
  let isPlaying = data.isPlayingContext;

  const trackUid = utils.getAttributeValueFromNode(buttonNode, 'data-uid');
  const trackUri = utils.getAttributeValueFromNode(buttonNode, 'data-track-uri');
  const pageIndex = parseInt(utils.getAttributeValueFromNode(buttonNode, 'data-context-page'), 10);

  if (isPlaying) {
    isPlaying = verifyIsPlayingIndex(trackUid, trackUri, pageIndex);
  }

  if (isPlaying) {
    if (getPlayerIsPlaying()) {
      live('spotify:player').emit('pause');
    } else {
      live('spotify:player').emit('resume');
    }
  } else {
    const eventData = {
      context: data.contextUri,
      source: data.source,
      reason: data.reason
    };

    if (trackUid) {
      eventData.uid = trackUid;
    }

    if (trackUri) {
      eventData.trackUri = trackUri;
    }

    if (!isNaN(pageIndex)) {
      eventData.page = pageIndex;
    }

    live('spotify:player').emit('play', eventData);
  }
}

/**
 * Verify that a uid, uri or pageIndex is playing, or that just the context
 * is playing when none of that is set.
 * This is used when we already know that we're playing the context.
 *
 * @param {string} trackUid
 * @param {string} trackUri
 * @param {number} pageIndex
 *
 * @return {boolean} True if it's really playing
 */
function verifyIsPlayingIndex(trackUid, trackUri, pageIndex) {
  if (trackUid) {
    const playerTrackUid = getPlayerTrackUid();
    return playerTrackUid === trackUid;
  }

  if (trackUri) {
    const playerTrackUri = getPlayerTrackUri();
    return playerTrackUri === trackUri;
  }

  if (!isNaN(pageIndex)) {
    const playerPageIndex = getPlayerPageIndex();
    return playerPageIndex === pageIndex;
  }

  // No index given also means it's really playing.
  return true;
}

/**
 * Handle playing a list row. This function should start playback of a context
 * starting from a specific row.
 *
 * @param {HTMLElement} rowNode A DOM node for a list row.
 * @param {Object} data Object of data about the action:
 *     contextUri: (string) The context URI for the list.
 *     source: (string) The 'play source' value, for logging purposes.
 *     reason: (string) The 'play reason' value, for logging purposes.
 */
function handlePlayFromRow(rowNode, data) {
  const eventData = {
    context: data.contextUri,
    source: data.source,
    reason: data.reason
  };

  const uid = rowNode.getAttribute('data-uid');
  if (uid) {
    eventData.uid = uid;
  }

  const pageIndex = parseInt(utils.getAttributeValueFromNode(rowNode, 'data-context-page'), 10);
  if (!isNaN(pageIndex)) {
    eventData.page = pageIndex;
  }

  live('spotify:player').emit('play', eventData);
}

/**
 * Get the nodes inside the passed container node that should be marked as
 * playing.
 *
 * @param {HTMLElement} containerNode The DOM node to search inside.
 * @param {Array.<HTMLElement>} contextNodes Array of DOM nodes that are already
 *     matched based on context URIs. These can be filtered if needed, but
 *     otherwise they should be included in the return value.
 *
 * @return {Array.<HTMLElement>} An array of DOM nodes.
 */
function getPlayingNodes(containerNode, contextNodes) {
  const playerPageIndex = getPlayerPageIndex();
  const playerTrackUid = getPlayerTrackUid();
  const playerTrackUri = getPlayerTrackUri();
  const variantUri = getPlayerVariantUri();

  // Remove any matched context nodes that have a page specified and where
  // the current player page does not match.
  const filteredContextNodes = filterPages(playerPageIndex, contextNodes);

  const selectors = utils.getContextSelectorsWithVariants(variantUri);
  const rowNodes = getContextNodesForRows(containerNode, selectors, playerTrackUid, playerTrackUri) || [];

  const selectorsWithVariants = utils.getContextSelectorsWithVariants(variantUri);
  const pageNodes = getContextNodesForPages(containerNode, selectorsWithVariants, playerPageIndex) || [];

  // Only return button nodes whos closest context is one of the nodes in the
  // contextNodes array. Imagine this minimal node tree:
  //
  // [data-context][data-uri="spotify:root-context"]
  //   [data-button=play-context]
  //   [data-context][data-uri="spotify:nested-context"]
  //     [data-button=play-context]
  //
  // The first [data-button=play-context] should play "spotify:root-context".
  // Ths second [data-button=play-context] should play "spotify:nested-context".
  let buttonNodes = [];
  if (contextNodes.length) {
    const candidates = $(contextNodes).search('[data-button=play-context]');
    if (candidates) {
      buttonNodes = candidates.filter(candidate => {
        const closestContextNode = candidate.closest('[data-context]');
        return contextNodes.indexOf(closestContextNode) >= 0;
      });
    }
  }

  // Let `elements` remove any duplicate nodes
  const nodes = $([filteredContextNodes, rowNodes, pageNodes, buttonNodes]);

  return nodes ? Array.prototype.slice.call(nodes) : [];
}

/**
 * Get the nodes inside the passed container node that match what's currently
 * playing and are list rows.
 *
 * @param {HTMLElement} containerNode The DOM node to search inside.
 * @param {Array.<string>} selectors Array of CSS selectors for matching the
 *     currently playing context.
 * @param {string} trackUid The UID of the currently playing track.
 *
 * @return {Array.<HTMLElement>} Array of DOM nodes.
 */
function getContextNodesForRows(containerNode, selectors, trackUid, trackUri) {
  // When playing from this client, we highlight the playing UIDs.
  const useTrackSelector = getPlayerIsPlayingFromOpen();

  const selector = selectors.map(function (s) {
    let newSelector = `${s} `;
    if (useTrackSelector) newSelector += `[data-uri=${trackUri}]`;
    if (!useTrackSelector) newSelector += `[data-uid=${trackUid}]`;
    return newSelector;
  }).join(', ');

  let nodes = $(containerNode).search(selector);
  if (nodes) {
    nodes = Array.prototype.slice.call(nodes);

    if (useTrackSelector) {
      // Gets UID of the first node and find all the nodes
      // with the same UID
      const firstUid = $(nodes[0]).data('uid');
      nodes = nodes.filter(function (row) {
        return firstUid === $(row).data('uid');
      });
    }
  } else {
    nodes = [];
  }

  return nodes;
}

/**
 * Get the nodes inside the passed container node that match what's currently
 * playing and have a matching page specified.
 *
 * @param {HTMLElement} containerNode The DOM node to search inside.
 * @param {Array.<string>} selectors Array of CSS selectors for matching the
 *     currently playing context.
 * @param {number} playerPageIndex The currently playing page index.
 *
 * @return {Array.<HTMLElement>} Array of DOM nodes.
 */
function getContextNodesForPages(containerNode, selectors, playerPageIndex) {
  const pageAttribute = '[data-context-page]';

  // It needs to search for all range elements somewhere inside an element
  // marked up as a context, as well as range elements that themselves are
  // contexts.
  const newSelectors = selectors.map(function (selector) {
    const pageInContextSelector = `${selector} ${pageAttribute}`;
    const pagedContextSelector = selector + pageAttribute;
    const pageSelector = `${pageInContextSelector}, ${pagedContextSelector}`;
    return pageSelector;
  });

  let pageNodes = $(containerNode).search(newSelectors.join(', '));
  if (pageNodes) {
    pageNodes = Array.prototype.slice.call(pageNodes);
  } else {
    pageNodes = [];
  }

  return filterPages(playerPageIndex, pageNodes);
}

/**
 * Return a new array of nodes where nodes that specify a context page that
 * doesn't match the currently playing context page are removed.
 *
 * @param {number} playerPageIndex The currently playing page index.
 * @param {Array.<HTMLElement>} contextNodes Array of already matched nodes.
 *
 * @return {Array.<HTMLElement>} Array of filtered nodes.
 */
function filterPages(playerPageIndex, contextNodes) {
  return contextNodes.filter(function (node) {
    const nodePageIndex = parseInt(node.getAttribute('data-context-page'), 10);

    // Node without a page should always be active
    if (isNaN(nodePageIndex)) return true;

    // If player has no page, but the node has a page, we can't be sure if it's
    // playing.
    if (isNaN(playerPageIndex)) return false;

    // Node that matches the player page should be active
    return playerPageIndex === nodePageIndex;
  });
}

},{"../../live":210,"../../spotify-elements":251,"./actions":308,"./updates":310,"./utils":311}],314:[function(require,module,exports){
'use strict';

const Range = require('../range2');

const contains = require('mout/array/contains');

const $ = require('../spotify-elements');

const SYNC = require('../../libs/prime/emitter').EMIT_SYNC;
const attentionHighlight = require('../../libs/glue').attentionHighlight;

const throttle = require('./util/throttle');
const ListManager = require('./util/ListManager.js');

const center = require('./center');

const doc = $(document);
const win = $(window);

let scrollContainers = [];
let listManagers = [];
let scrollHandlers = [];
const pendingScrollContainers = [];
const pendingHiddenIndices = [];
let cleanupHandlers = [];

const getBounds = function (view, container) {
  const dde = document.documentElement;
  let newView = view;

  if (newView === window || newView === document.body) newView = dde;
  const viewTop = newView === dde ? 0 : newView.getBoundingClientRect().top;

  const viewHeight = newView.clientHeight;
  const containerTop = container.getBoundingClientRect().top;
  const containerHeight = container.offsetHeight;

  const viewBox = {
    top: viewTop,
    height: viewHeight,
    bottom: viewTop + viewHeight
  };

  const containerBox = {
    top: containerTop,
    height: containerHeight,
    bottom: containerTop + containerHeight
  };

  return {
    view: viewBox,
    container: containerBox
  };
};

const getRange = function (view, container, height, hotZone = 0) {
  const bounds = getBounds(view, container);
  const top = -(bounds.container.top - bounds.view.top);
  let startsAt = Math.floor((top - hotZone) / height);
  const endsAt = Math.ceil((top + bounds.view.height + hotZone) / height);
  if (startsAt < 0) startsAt = 0;
  if (endsAt <= startsAt) return false;
  return new Range(startsAt, endsAt);
};

const init = function (view, container, length, height, tag) {
  const view0 = view[0];
  const container0 = container[0];
  let savedAttentionHighlightIndex = -1;

  container.addClass('scroll-container-enabled');

  const attentionHighlightIndex = (c, index) => {
    if ($(c) === container) {
      const row = container0.querySelector(`[data-index='${index}']`);
      if (!row) {
        savedAttentionHighlightIndex = index;
        return;
      }

      savedAttentionHighlightIndex = -1;

      let tableRowAttentionHighlight = document.querySelector('[data-table-row-attention-highlight]');
      if (!tableRowAttentionHighlight) {
        tableRowAttentionHighlight = document.createElement('div');
        tableRowAttentionHighlight.className = 'tl-attention-highlight';
        tableRowAttentionHighlight.setAttribute('data-table-row-attention-highlight', '');
        document.body.appendChild(tableRowAttentionHighlight);
      }

      const scrollY = window.pageYOffset;
      const rect = row.getBoundingClientRect();

      // Use document width instead of window width to handle the case when
      // there are scroll bars that are not overlay scroll bars.
      const viewportWidth = document.documentElement.offsetWidth;

      tableRowAttentionHighlight.classList.add('visible');
      tableRowAttentionHighlight.style.top = `${rect.top + scrollY}px`;
      tableRowAttentionHighlight.style.left = `${rect.left}px`;
      tableRowAttentionHighlight.style.right = `${viewportWidth - rect.right}px`;

      setTimeout(() => {
        tableRowAttentionHighlight.classList.remove('visible');
      }, attentionHighlight.HIDE_DELAY);
    }
  };

  const manager = new ListManager(container0, {
    height: height,
    length: length,
    tag: tag,
    debug: false,
    request: function (range, callback) {
      center.emit('scroll-request', container0, range, callback, SYNC);
    }
  });
  listManagers.push(manager);

  // Update the manager with previously saved hidden indices.
  // This allows the scroller to take hidden indices into account even for the
  // first render.
  const pendingIndex = pendingScrollContainers.indexOf(container);
  if (pendingIndex > -1) {
    manager.reset(length, pendingHiddenIndices[pendingIndex]);
    pendingScrollContainers.splice(pendingIndex, 1);
    pendingHiddenIndices.splice(pendingIndex, 1);
  }

  manager.on('before-show', function (range, nodes) {
    center.emit('scroll-show-before', {
      pageNode: container,
      container: container,
      range: range,
      nodes: nodes
    }, SYNC);
  });

  manager.on('after-show', function (range, nodes) {
    center.emit('scroll-show-after', {
      pageNode: container,
      container: container,
      range: range,
      nodes: nodes
    }, SYNC);
  });

  manager.on('index-change', function (index) {
    center.emit('scroll-index-change', {
      pageNode: container,
      container: container,
      ranges: index
    }, SYNC);
  });

  let hasRequestedMore = false;

  const scrollReset = function (c, scrollResetHeight, hiddenIndices, fromIndex) {
    if ($(c) === container) {
      const hasFromIndex = typeof fromIndex === 'number';
      if (hasFromIndex && fromIndex > 0) {
        manager.resetFrom(fromIndex, scrollResetHeight, hiddenIndices);
      } else {
        manager.reset(scrollResetHeight, hiddenIndices);
      }
      container._scrollEvent();
    }
  };

  const scroll = function () {
    const bounds = getBounds(view0, container0);
    let show = getRange(view0, container0, height);

    if (show) {
      manager.on('after-show', function onAfterShow() {
        manager.off('after-show', onAfterShow);

        if (savedAttentionHighlightIndex > -1 && savedAttentionHighlightIndex >= show.start && savedAttentionHighlightIndex < show.end) {
          attentionHighlightIndex(container, savedAttentionHighlightIndex);
        }
      });

      const padding = 2;
      show = new Range(show.start - padding, show.end + padding);
      manager.show(new Range(show.start, show.end));
    }

    // If the scroll position is close enough to the end, an event should be
    // emitted to allow for more content to be loaded. Not all lists will use this,
    // but some lists want to lazy load content by loading more when you reach the
    // bottom, and then they can listen for this event.
    if (!hasRequestedMore) {
      if (bounds.container.bottom < 2000) {
        hasRequestedMore = true;

        // Emit the event and also pass a callback to the event.
        // The receiver of this event should pass the new total length of the list
        // as the second argument to the callback.
        center.emit('scroll-request-more', container0, function (error, emitLength) {
          if (error) throw error;
          hasRequestedMore = false;
          scrollReset(container0, emitLength);
        });
      }
    }
  };

  scrollHandlers.push(scroll);
  container._scrollEvent = throttle(scroll);

  center.on('scroll-reset', scrollReset);
  container._scrollResetEvent = scrollReset;

  const scrollToIndex = function (c, index, options = {}) {
    if (view0 !== window) {
      throw new Error("Can't scroll to index if view is not `window`");
    }

    if ($(c) === container) {
      const bounds = getBounds(view0, container0);

      const offset = options.centerRowIfScrollIsNeeded ? (bounds.view.height - manager.height) / 2 : 0;

      const indexTopRelativeToContainer = manager.height * index;
      const position = bounds.container.top + indexTopRelativeToContainer;

      let scrollY = position + window.pageYOffset;
      let stickyOffset = (doc.search('[data-sticky-active]') || []).map(function (sticky) {
        return sticky.offsetHeight;
      }).reduce(function (a, b) {
        return a + b;
      }, 0);

      if (document.querySelector('[data-top-bar-height]')) {
        stickyOffset += parseInt(document.querySelector('[data-top-bar-height]').getAttribute('data-top-bar-height'), 10);
      }

      if (position <= stickyOffset) {
        // item is above viewport
        scrollY -= offset + stickyOffset;
      } else if (position + manager.height > bounds.view.height) {
        // item is below viewport
        scrollY += offset + manager.height - bounds.view.height;
      } else {
        // item is in viewport
        return;
      }

      view0.scrollTo(0, scrollY);
    }
  };

  const hideAttentionHighlight = () => {
    const tableRowAttentionHighlight = document.querySelector('[data-table-row-attention-highlight]');
    if (tableRowAttentionHighlight) {
      tableRowAttentionHighlight.parentNode.removeChild(tableRowAttentionHighlight);
    }
  };

  center.on('scroll-to-index', scrollToIndex);
  center.on('attention-highlight-index', attentionHighlightIndex);
  center.on('hide-attention-highlight', hideAttentionHighlight);

  view.on('scroll', scroll);
  win.on('resize', scroll);
  scroll();

  cleanupHandlers.push({
    container: container,
    clean: function () {
      center.off('scroll-reset', scrollReset);
      center.off('scroll-to-index', scrollToIndex);
      center.off('attention-highlight-index', attentionHighlightIndex);
      center.off('hide-attention-highlight', hideAttentionHighlight);
      view.off('scroll', scroll);
      win.off('resize', scroll);

      delete container._scrollEvent;
      delete container._scrollResetEvent;

      savedAttentionHighlightIndex = -1;

      container.removeClass('scroll-container-enabled');
    }
  });
};

function onScrollSetHidden(data) {
  const hiddenIndices = data.indices;

  const container = $(data.itemContainer);
  const index = scrollContainers.indexOf(container);
  if (index > -1) {
    const manager = listManagers[index];
    if (manager) {
      manager.reset(manager.length, hiddenIndices);
    }
    const scrollHandler = scrollHandlers[index];
    if (scrollHandler) {
      scrollHandler();
    }
  } else {
    pendingScrollContainers.push(container);
    pendingHiddenIndices.push(hiddenIndices);
  }
}

let isAttached = false;

exports.update = function (node) {
  if (!isAttached) return;

  const newNode = $(node) || doc;

  let scrollNodes = doc.search('[data-scroll-container]');

  const handlers = [];
  const managers = [];
  scrollContainers = scrollContainers.filter(function (container, index) {
    if (!contains(scrollNodes, container[0])) {
      for (let i = 0; i < cleanupHandlers.length; i++) {
        if (cleanupHandlers[i].container === container) {
          cleanupHandlers[i].clean();
          cleanupHandlers.splice(i, 1);
          break;
        }
      }
      return false;
    }
    managers.push(listManagers[index]);
    handlers.push(scrollHandlers[index]);
    return true;
  });
  listManagers = managers;
  scrollHandlers = handlers;

  if (newNode !== doc) scrollNodes = newNode.search('[data-scroll-container]');

  if (scrollNodes) {
    scrollNodes.forEach(function (node0) {
      const container = $(node0);

      if (container._scrollEvent || node0.children.length) return;

      scrollContainers.push(container);
      const view = container.parent('[data-scroll-view]') || win;

      const callback = function (error, children, length) {
        if (error) throw error;

        let newChildren = children;

        // Only continue initialization if the container is still in the DOM
        if (contains(doc.search('[data-scroll-container]'), container[0])) {
          newChildren = $(newChildren);
          newChildren.insert(container);

          const second = newChildren[1];
          const height = second.offsetHeight;
          const tag = $(second).tag();
          newChildren.remove();
          init(view, container, length, height, tag);
        }
      };

      center.emit('scroll-request', container[0], new Range(0, 3), callback, SYNC);
    });
  }
};

exports.attach = function () {
  if (isAttached) return;
  isAttached = true;

  center.on('scroll-set-hidden', onScrollSetHidden);
};

exports.detach = function () {
  if (!isAttached) return;
  isAttached = false;

  center.off('scroll-set-hidden', onScrollSetHidden);

  scrollContainers = [];
  cleanupHandlers.forEach(function ({ clean }) {
    clean();
  });
  cleanupHandlers = [];
};

},{"../../libs/glue":118,"../../libs/prime/emitter":242,"../range2":245,"../spotify-elements":251,"./center":262,"./util/ListManager.js":328,"./util/throttle":334,"mout/array/contains":443}],315:[function(require,module,exports){
'use strict';

var _spotifyCosmosApi = require('spotify-cosmos-api');

var _spotifyCosmosApi2 = _interopRequireDefault(_spotifyCosmosApi);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

let isAttached = false;
let controlMessageSubscription;
let currentStyle = 'always-visible';

function refreshStyle() {
  const nav = window.navigator;
  const isMac = nav && nav.userAgent.indexOf('Mac') > -1;
  const os = isMac ? 'mac' : 'windows';

  if (currentStyle === 'always-visible') {
    document.documentElement.classList.add(`scrollbar-style-visible-${os}`);
    document.documentElement.classList.remove('scrollbar-style-overlay');
  } else {
    document.documentElement.classList.remove(`scrollbar-style-visible-${os}`);
    document.documentElement.classList.add('scrollbar-style-overlay');
  }
}

exports.update = function () {};

exports.attach = function () {
  if (isAttached) return;
  isAttached = true;

  const initialValue = window.__spotify && window.__spotify.scroller_style;
  currentStyle = initialValue === 'overlay' ? 'overlay' : 'always-visible';
  refreshStyle();

  controlMessageSubscription = _spotifyCosmosApi2.default.resolver.subscribe({
    url: 'sp://messages/v1/container/control'
  }, (error, response) => {
    if (!error) {
      const data = response.getJSONBody();
      if (data) {
        let styleWasChanged = false;
        switch (data.type) {
          case 'set_scroller_style_always_visible':
            currentStyle = 'always-visible';
            styleWasChanged = true;
            break;
          case 'set_scroller_style_overlay':
            currentStyle = 'overlay';
            styleWasChanged = true;
            break;
          default:
            break;
        }

        if (styleWasChanged) {
          refreshStyle();
        }

        // Fix a rendering bug in Chromium. When scroller style changes in the
        // system (changing system preference, connecting/disconnecting a mouse
        // etc), Chromium will not always render properly. Sometimes it shows a
        // white area where the scroll bar is supposed to be and sometimes it
        // renders it with native styles even though the CSS styles should be
        // applied. By setting `overflow: hidden` to all elements for a brief
        // moment it will force the scroll bars to re-render.
        //
        // https://jira.spotify.net/browse/KM-8285
        // http://crbug.com/538579
        if (styleWasChanged) {
          const performFix = () => {
            const styleNode = document.createElement('style');
            styleNode.innerHTML = '* {overflow: hidden !important}';
            document.head.appendChild(styleNode);
            // Delay removal one tick so that it has time to render
            setTimeout(() => {
              document.head.removeChild(styleNode);
            }, 0);
          };

          // Perform the fix twice (once with a delay), since it sometimes might
          // be slow and won't apply the fix on the first try.
          performFix();
          setTimeout(performFix, 1000);
        }
      }
    } else {
      controlMessageSubscription.cancel();
    }
  });
};

exports.detach = function () {
  if (!isAttached) return;
  isAttached = false;

  if (controlMessageSubscription) {
    controlMessageSubscription.cancel();
    controlMessageSubscription = null;
  }
};

},{"spotify-cosmos-api":720}],316:[function(require,module,exports){
/**
 * @module spotify-events/select
 */
'use strict';

const $ = require('../spotify-elements');
const center = require('./center');

const live = require('../live');

const ATTR_SELECT = 'select';
const ATTR_PROPERTY = 'select-property';
const SELECTOR_SELECT = `[data-${ATTR_SELECT}]`;

// Stored nodes, used to not add listeners multiple times
const storedNodes = [];

/**
 * Handle a change on a select node.
 *
 * @param {MouseEvent} event Event object.
 * @param {Elements} elem An elements DOM node for the select.
 */
function handleChange(event, elem) {
  const property = elem.data(ATTR_PROPERTY);
  const node = elem[0];
  // If a property is set, update the model. That will later trigger
  // an update of the view and a change event on center will be sent.
  if (property) {
    publish(node, property);
    // If no property is set, just emit a change event on center.
  } else {
    emitUpdate(node, selectedValue(node));
  }
}

/**
 * Return the value attribute of the selected option
 *
 * @param {Elements} elem An elements DOM node for the select
 */
function selectedValue(node) {
  const selected = node.options[node.selectedIndex];
  return selected.value;
}

/**
 * Handle when a select-option event happens on center.
 *
 * @param {Object} event An object with data.
 */
function onSelectSet(event) {
  if (!event.id) return;

  const elem = $(`[data-${ATTR_SELECT}=${event.id}]`);
  if (!elem) return;

  const node = elem[0];
  const value = event.selected;

  // updating the node will trigger a DOM event,
  // delegated to handleChange in this module.
  const property = elem.data(ATTR_PROPERTY);

  if (property) {
    publish(node, property, value);
  } else {
    setState(node, value);
  }
}

/**
 * Publish new data to the live model. If no data-uri is found from
 * the passed node, nothing happens.
 *
 * @param {HtmlElement} node A DOM node for the select
 * @param {string} property A property name on the live model
 * @param {string=} optValue Optional value to set the property to.
 *     If not provided, the selected option's value is fetched from the DOM.
 */
function publish(node, property, optValue) {
  const uri = getUriFromNode(node);
  if (!uri) return;

  const model = live(uri);

  // If the model doesn't have a current value, we can't safely
  // set a new value without maybe being wrong.
  const value = model.get(property);
  if (value === undefined) return;

  const newValue = optValue === undefined ? selectedValue(node) : optValue;

  const data = {};
  data[property] = newValue;

  // Publishing the new value to the model will trigger the update
  // handler added here in this module to send an center event,
  // and update the DOM if needed.
  model.publish(data);
}

/**
 * Update the state of one select node.
 *
 * @param {HTMLElement} node A DOM node for the select.
 */
function updateNode(node) {
  if (storedNodes.indexOf(node) > -1) return;
  storedNodes.push(node);

  const elem = $(node);
  const property = elem.data(ATTR_PROPERTY);
  if (!property) return;

  const uri = getUriFromNode(node);
  if (!uri) return;

  const model = live(uri);

  model.get(property, function (error, value) {
    if (error) throw error;

    setState(node, value);

    model.on('update', function (properties) {
      if (property in properties) {
        setState(node, properties[property]);
      }
    });
  });
}

/**
 * Update a select node based on a value.
 *
 * @param {HTMLElement} node A DOM node for a select.
 * @param {string} value The value attribute of the option to select
 */
function setState(node, value) {
  updateNodeWithValue(node, value);
  emitUpdate(node, value);
}

/**
 * Update a select based on an option's value attribute
 *
 * @param {HTMLElement} node A DOM node for a select.
 * @param {string} value The value attribute of the option to select
 */
function updateNodeWithValue(node, value) {
  const selectElement = $(node);
  const optionElement = selectElement.find(`option[value="${value}"]`);
  if (optionElement && !optionElement.attribute('selected')) {
    optionElement.select();
  }
}

/**
 * Emit a change event on center. It will have the following format:
 * {
 *   element: HTMLElement,
 *   id: 'id from data-select attribute' || null,
 *   selected: the new selected value
 * }
 *
 * @param {HTMLElement} node A DOM node for a select.
 * @param {string} value Attribute of the selected option
 */
function emitUpdate(node, selected) {
  const id = $(node).data(ATTR_SELECT) || null;
  center.emit('select-change', {
    element: node,
    id: id,
    selected: selected
  });
}

/**
 * Get a URI from a node.
 *
 * @param {HTMLElement} node A DOM node.
 *
 * @return {string?} A URI string or null if not found.
 */
function getUriFromNode(node) {
  const stateNode = node.closest('[data-uri]');
  if (!stateNode) return null;
  return stateNode.getAttribute('data-uri');
}

let isAttached = false;

exports.update = function (optNode) {
  if (!isAttached) return;

  const nodes = $(optNode || document).search(SELECTOR_SELECT);
  if (!nodes) return;

  nodes.forEach(updateNode);
};

exports.attach = function () {
  if (isAttached) return;
  isAttached = true;

  const doc = $(document);
  doc.delegate('change', SELECTOR_SELECT, handleChange);

  center.on('select-set', onSelectSet);
};

exports.detach = function () {
  if (!isAttached) return;
  isAttached = false;

  const doc = $(document);
  doc.undelegate('change', SELECTOR_SELECT, handleChange);

  center.off('select-set', onSelectSet);
};

},{"../live":210,"../spotify-elements":251,"./center":262}],317:[function(require,module,exports){
/**
 * @module spotify-events/selection/containers
 * @private
 */
'use strict';

const $ = require('../../spotify-elements');
const live = require('../../live');

/**
 * Container DOM nodes.
 *
 * @type {Array.<HTMLElement>}
 */
const containers = [];

/**
 * Forget the known containers.
 */
function reset() {
  containers.length = 0;
}

/**
 * Update container storage based on the current DOM.
 */
function update() {
  const nodes = $(document).search(':not(.sticky-clone) > [data-list]');
  if (!nodes) return;

  // Don't drop any containers. If they are removed from the DOM we just keep
  // the reference along with the selection state at the same index. Clearing
  // has to be done manually instead.

  nodes.forEach(function (container) {
    if (!containers.includes(container)) {
      containers.push(container);
      containers.sort((a, b) => {
        let n;
        if (a === b) {
          n = 0;
        } else if (a.compareDocumentPosition(b) & Node.DOCUMENT_POSITION_PRECEDING) {
          n = 1;
        } else {
          n = -1;
        }
        return n;
      });
    }
  });
}

/**
 * Get the number of rows in the container at the specified index.
 *
 * @param {number} index The container index.
 *
 * @return {number} The number of rows.
 */
function getContainerLength(index) {
  const container = $(containers[index]);
  if (!container) return 0;

  const uri = container.data('uri');
  if (!uri) return 0;

  const list = live(uri).get('rows');
  if (!list) return 0;

  return list.length;
}

/**
 * Get the index of a container based on URI.
 *
 * @param {string} uri The URI of the container.
 *
 * @return {number} The index of the container. Returns -1 if not found.
 */
function getContainerIndex(uri) {
  for (let i = 0, l = containers.length; i < l; i++) {
    const containerUri = getUri(i);
    if (containerUri === uri) return i;
  }

  return -1;
}

/**
 * Get the URI for a container.
 *
 * @param {number} index The container index.
 *
 * @return {string?} The URI or null if not found.
 */
function getUri(index) {
  const element = containers[index];
  const uri = element && element.getAttribute('data-uri');
  return uri || null;
}

/**
 * Get the URIs for all containers.
 *
 * @return {Array.<string?>} Array of URIs.
 */
function getUris() {
  const uris = [];
  for (let i = 0, l = containers.length; i < l; i++) {
    uris.push(getUri(i));
  }
  return uris;
}

/**
 * Get the live list for a container.
 *
 * @param {number} index The container index.
 *
 * @return {LiveList?} A live list or null if not found.
 */
function getLiveList(index) {
  const uri = getUri(index);
  const list = live(uri).get('rows');
  return list || null;
}

exports.elements = containers;
exports.reset = reset;
exports.update = update;
exports.getContainerLength = getContainerLength;
exports.getContainerIndex = getContainerIndex;
exports.getUri = getUri;
exports.getUris = getUris;
exports.getLiveList = getLiveList;

},{"../../live":210,"../../spotify-elements":251}],318:[function(require,module,exports){
(function (global){
/**
 * spotify-events/selection/controller
 * @private
 */
'use strict';

const $ = require('../../spotify-elements');
const intersection = require('mout/array/intersection');
const live = require('../../live');
const liburi = require('spotify-liburi');

const center = require('../center');
const selection = require('./index');
const model = require('./model');
const rows = require('./rows');
const containers = require('./containers');
const positions = require('./positions');
const Position = require('../util/Position');
const cosmos = require('../util/cosmos');

let focusEventValid = false;
let mouseDownTarget = null;

// Listeners per URI (key is URI)
const listListeners = {};
const listListenerUris = [];

const SELECTABLE = '[data-list-item]';
const CLIPBOARD_ENDPOINT = 'sp://desktop/v1/clipboard';

/**
 * Check whether the event occured on the documentElement.
 *
 * @param {Event} event A event object.
 *
 * @return {boolean}
 */
function isOnDocument(event) {
  return event.target === document.documentElement;
}

/**
 * Get the row node from a mouse event.
 *
 * @param {MouseEvent} event A mouse event object.
 *
 * @return {HTMLElement} A DOM node.
 */
function getNodeFromEvent(event) {
  return event.target !== document && event.target.closest(SELECTABLE);
}

/**
 * Check if a target is inside a filter component.
 *
 * @param {HTMLElement} target A DOM node.
 *
 * @return {boolean} Whether the target was inside a filter component.
 */
function isFilterTarget(target) {
  return target !== document && !!target.closest('[data-filter]');
}

/**
 * Handle a mousedown event.
 *
 * @param {MouseEvent|TouchEvent} event A mouse or touch event.
 * @param {boolean=} isMouseUp Pass true if this is a simulated mousedown
 *     triggered by a mouseup event.
 */
function handleMouseDown(event, isMouseUp) {
  if (isOnDocument(event)) {
    return;
  }

  focusEventValid = false;
  const node = getNodeFromEvent(event);

  if (isMouseUp) {
    if (event.target !== mouseDownTarget) {
      mouseDownTarget = null;
      return;
    }
    mouseDownTarget = null;
  } else {
    mouseDownTarget = event.target;
  }

  if (node) {
    handleRowMouseDown(event, node, isMouseUp);
  } else {
    handleOutsideMouseDown(event);
  }
}

/**
 * Handle when the mouse is pressed down on a list row.
 *
 * @param {MouseEvent|TouchEvent} event A mouse or touch event.
 * @param {HTMLElemtn} rowNode The DOM node for the clicked row.
 * @param {boolean=} isMouseUp Pass true if this is a simulated mousedown
 *     triggered by a mouseup event.
 */
function handleRowMouseDown(event, rowNode, isMouseUp) {
  const button = getButtonFromEvent(event);
  const isPrimaryButton = button === 1;

  // If we can't find a valid position for the DOM node, we can't handle
  // selection correctly.
  const position = positions.getFromNode(rowNode);
  if (!position) return;

  const isSelected = model.isSelected(position);
  let singleMultiSelect = isMac() ? event.metaKey : event.ctrlKey;
  let multiselect = event.shiftKey || singleMultiSelect;
  let singleClick = !event.shiftKey;

  if (!isMultiSelectEnabled()) {
    singleMultiSelect = multiselect = false;
    singleClick = true;
  }

  // Remove selection if a selected item is clicked with cmd/ctrl
  if (multiselect && singleClick && isSelected && isPrimaryButton) {
    // For multiselect, make sure we do the deselection only on mouseup
    if (!isMouseUp) return;
    handleDeselectOnSingleMultiSelect(position);

    // Select multiple items if clicked with shift key
  } else if (!singleClick) {
    // Optimize by doing this only on mousedown
    if (isMouseUp) return;
    handleShiftMultiSelect(position);

    // Select a single item
  } else {
    // Handle the case when the primary button is pressed down on a selected item.
    // The method will be called once again in that case, on mouse up. This is
    // to allow the drag and drop to abort the selection change.

    // So we do the actual selection on mouseup, where we know it's not a drag n drop thing.
    if (isPrimaryButton && isSelected && !isMouseUp) {
      return;
    }
    // For multiselect, make sure we do the selection only on mouseup
    if (multiselect && !isMouseUp) {
      return;
    }

    handleSingleSelect(position, event, isMouseUp);
  }
  rows.update();
}

/**
 * Handle when the mouse is pressed down outside a list row.
 *
 * @param {MouseEvent} event A mouse event.
 */
function handleOutsideMouseDown(event) {
  const isSort = event.target !== document && !!event.target.closest('[data-sort]');
  const isFilter = isFilterTarget(event.target);
  const hasSelection = model.hasSelection();

  // Deselect if clicked outside the list.
  // Clicking sort headers should just sort, not clear selection.
  if (!(isSort || isFilter) && hasSelection) {
    model.clear();
    rows.update();
  }
}

/**
 * Handle a focus event.
 *
 * @param {MouseEvent} event A mouse event.
 */
function handleFocus(event) {
  if (!focusEventValid) return;
  const node = getNodeFromEvent(event);
  if (node) {
    handleRowFocus(event, node);
  } else {
    handleOutsideFocus(event);
  }
  focusEventValid = false;
}

/**
 * Handle when a row receives focus.
 *
 * @param {MouseEvent} event A mouse event.
 * @param {HTMLElement} rowNode The DOM node for the focused row.
 */
function handleRowFocus(event, rowNode) {
  const position = positions.getFromNode(rowNode);

  // Invalid positions and already selected rows don't need to be handled
  if (!position || model.isSelected(position)) {
    return;
  }

  model.clear();
  model.add(position);
  model.setFocus(position);
  model.setOrigin(position);
  rows.update();
}

/**
 * Handle when an element outside the table receives focus.
 *
 * @param {MouseEvent} event A mouse event.
 */
function handleOutsideFocus(event) {
  if (isFilterTarget(event.target)) return;
  model.clear();
  rows.update();
}

/**
 * Handle when the mouse button is released.
 *
 * @param {MouseEvent|TouchEvent} event A mouse or touch event.
 */
function handleMouseUp(event) {
  if (isOnDocument(event)) {
    return;
  }

  handleMouseDown(event, true);
}

/**
 * Handle deselecting a currently selected row in a multi-select situation
 * (cmd/ctrl). This might mean that we need to adjust origin and focus as well.
 *
 * @param {Position} position Position clicked on.
 */
function handleDeselectOnSingleMultiSelect(position) {
  const origin = model.getOrigin();
  const focus = model.getFocus();
  let dir = positions.getDirection(origin, focus);

  // When removing the node that is both origin and focus, there will be no
  // direction in which the origin/focus could be moved. Like here:

  // Click A, CMD click C, CMD click B, CMD click B again.

  // Native desktop will now still have origin on B. MacOS Finder does move
  // origin but it's hard to know how it decides.

  // For a predictable behaviour, default to look downwards, and always reverse
  // the direction when no selected node is found.

  if (!dir) dir = 1;

  const isOrigin = position.isSame(origin);
  const isFocus = position.isSame(focus);
  let above;
  let below;

  if (isOrigin || isFocus) {
    above = getClosestSelected(position, 'up');
    below = getClosestSelected(position, 'down');
  }

  // If direction is down (1), the next after origin is found below
  if (isOrigin) {
    model.setOrigin(dir === 1 ? below || above : above || below);
  }

  // If direction is down (1), the next after focus is found above
  if (position.isSame(focus)) {
    model.setFocus(dir === 1 ? above || below : below || above);
  }

  model.remove(position);
}

/**
 * Handle multi-selecting a range from the current focus to the new position.
 * This also handles deselecting as needed.
 *
 * @param {Position} position Position clicked on.
 */
function handleShiftMultiSelect(position) {
  let origin = model.getOrigin();
  const focus = model.getFocus();

  // Remove selection from origin to old focus.
  // If it's part of the new selection it will be re-added.
  if (origin && focus && !origin.isSame(focus)) {
    model.remove(origin, focus);
  }

  // If there is no origin, we will set the origin to the first selectable row
  if (!origin) {
    origin = new Position(0, 0);
    model.setOrigin(origin);
  }

  // Add selection from the current origin to the clicked position
  model.add(origin, position);
  model.setFocus(position);
}

/**
 * Handle a normal mousedown without any multi-select keys.
 *
 * @param {Position} position Position clicked on.
 * @param {MouseEvent|TouchEvent} event A mouse or touch event.
 */
function handleSingleSelect(position, event) {
  const origin = model.getOrigin();

  const button = getButtonFromEvent(event);
  const isPrimaryButton = button === 1;
  const isSecondaryButton = button === 2;

  const isSelected = model.isSelected(position);
  let singleMultiSelect = isMac() ? event.metaKey : event.ctrlKey;
  let multiselect = event.shiftKey || singleMultiSelect;

  if (!isMultiSelectEnabled()) {
    singleMultiSelect = multiselect = false;
  }

  // Left click without cmd/ctrl/shift clears selection.
  // Also right click on something that wasn't selected clears.
  const isRegularPrimary = !multiselect && isPrimaryButton;
  const isSelectedSecondary = !isSelected && isSecondaryButton;
  if (isRegularPrimary || isSelectedSecondary) {
    model.clear();
  }

  // Add item to selection
  model.add(position);
  model.setFocus(position, { isTouch: isTouchEvent(event) });

  // When adding to an existing selection, leave origin alone.
  let isNextToSelection;
  if (origin && !origin.isSame(position)) {
    const next = positions.getClosest(position, 'down');

    isNextToSelection = next && model.isSelected(next);
    if (!isNextToSelection) {
      const prev = positions.getClosest(position, 'up');
      isNextToSelection = prev && model.isSelected(prev);
    }
  }
  if (!isNextToSelection) {
    model.setOrigin(position);
  }
}

/**
 * Handler for when a key is pressed down in the list. Depending on the key,
 * this will either move the selection (up and down arrows), shrink/grow the
 * selection (shift up and down arrows) or clear the selection (escape key).
 *
 * @param {KeyboardEvent} event The event object.
 */
function handleKeyDown(event) {
  if (isFilterTarget(event.target)) return;

  focusEventValid = true;
  const isUp = event.keyCode === 38;
  const isDown = event.keyCode === 40;

  if (!isKeyboardNavEnabled()) return;

  if (!isUp && !isDown) return;

  const origin = model.getOrigin();
  const focus = model.getFocus();
  let next = focus;

  do {
    next = next && positions.getClosest(next, isDown ? 'down' : 'up');
  } while (next && model.isPositionHidden(next));

  // Only move the selection if the up or down key was pressed.
  // And only do it if the cmd/ctrl key is not also pressed.
  // The cmd/ctrl key will change the volume in the client.
  if ((isUp || isDown) && !event.metaKey && !event.ctrlKey && next) {
    // Multi-select must have a previous selection position
    if (event.shiftKey && isMultiSelectEnabled() && origin && focus) {
      const keyDirection = isDown ? 1 : -1;
      const direction = positions.getDirection(origin, focus);
      const isSingleRange = direction === 0;
      if (isSingleRange || keyDirection === direction) {
        model.add(next);
        scrollIntoView(next);
      } else {
        model.remove(focus);
      }

      // If multi-select can't be performed, just move the current selection
    } else {
      model.clear();
      model.add(next);
      model.setOrigin(next);
      scrollIntoView(next);
      event.preventDefault(); // Prevent normal scrolling
    }

    // Always set the new focus to the row above or below
    model.setFocus(next);
  }

  rows.update();
}

/**
 * Handle when a section of a list is scrolled into view.
 * This needs to update selection state of the row nodes.
 *
 * @param {Object} event Event object.
 */
function handleScrollShowAfter(event) {
  const node = event.pageNode && event.pageNode[0];
  rows.update(node);
}

/**
 * Handle setting which indices are hidden.
 *
 * @param {Object} data Object with properties `hiddenIndices` (array of
 *     indices) and `uri` (URI of the list).
 */
function handleSetHidden(data) {
  model.setHiddenIndices(data.indices, data.uri);
}

/**
 * Add a row to the selection based on a list URI.
 * TODO: Remove logic to handle global lists.
 *
 * @param {string} listUri The list URI.
 * @param {number} index The index within the list.
 * @param {boolean=} doNotScrollIntoView Optionally skip scrolling added index into view
 */
function handleAddByUri(listUri, index, doNotScrollIntoView) {
  const uriNodes = $(`[data-uri=${listUri}]`);
  const matches = intersection(containers.elements, uriNodes);
  let newIndex = index;

  if (!matches || matches.length < 1) {
    return;
  }

  const container = $(matches[0]);
  let containerIndex = container && containers.elements.indexOf(container[0]);
  const listIsPlayContext = container && container.matches('[data-context]');

  if (listIsPlayContext) {
    // Selection is not based on the global container that is defined via data-context,
    // so the indices need to be resolved to match the selection containers.
    const localPosition = positions.getPositionFromGlobalIndex(newIndex);
    containerIndex = localPosition.containerIndex;
    newIndex = localPosition.index;
  } else if (containerIndex === -1) {
    console.warn("No container matching this uri was found or selection doesn't know " + 'about the container. Possibly you need to run events.update.');
    return;
  }

  if (!isMultiSelectEnabled()) model.clear();

  const position = new Position(containerIndex, newIndex);
  if (!model.getOrigin()) model.setOrigin(position);
  model.setFocus(position);
  model.add(position);

  rows.update();

  if (doNotScrollIntoView !== true) {
    scrollIntoView(position);
  }
}

/**
 * Handle a select_all event from Cosmos.
 */
function handleSelectAll() {
  if (!isMultiSelectEnabled()) {
    return;
  }

  model.clear();

  const first = new Position(0, 0);
  model.setOrigin(first);

  const last = positions.getLastPositionForSelectAll();
  model.setFocus(last);

  model.add(first, last);
  rows.update();
}

function handleCopy() {
  cosmos.put({
    url: CLIPBOARD_ENDPOINT,
    body: handleGetUris().map(uri => {
      const uriObject = liburi.from(uri);
      return uriObject && uriObject.toOpenURL();
    }).filter(Boolean).join('\n')
  });
}

function handleCopyAdvanced() {
  cosmos.put({
    url: CLIPBOARD_ENDPOINT,
    body: handleGetUris().filter(Boolean).join('\n')
  });
}

/**
 * Handle a cut event from Cosmos.
 */
function handleCut() {
  handleCopy();

  cosmos.post({
    url: 'sp://messages/v1/container/control',
    body: { type: 'delete' }
  });
}

/**
 * Gets list of uris for selected rows
 *
 * @return {Array.<string>} Array of URIs.
 */
function handleGetUris() {
  const selections = model.selections;
  const uris = [];

  let containerSelection;
  const containerSelectionByKey = key => {
    return !!containerSelection[key];
  };

  for (let container = 0; container < selections.length; container++) {
    containerSelection = selections[container];
    if (!containerSelection) continue;

    let entity;

    const list = containers.getLiveList(container);
    if (!list) continue;

    // * Order the keys
    // Since the user can select tracks in any order,
    // the selection is an unordered set until we actually retrieve the
    // uris of the selection. In this case we want to get the uris
    // in the same order as they are shown in the list.
    const orderedSelectedKeys = list.keys.filter(containerSelectionByKey);

    for (let i = 0, l = orderedSelectedKeys.length; i < l; i++) {
      const item = list.valueOf(orderedSelectedKeys[i]);
      if (!item) continue;

      entity = item.get('track');
      if (!entity) entity = item.get('playlist');
      if (!entity) entity = item.get('album');
      if (!entity) entity = item.get('artist');
      if (!entity) entity = item.get('user');
      if (!entity) entity = item;

      uris.push(entity.get('uri'));
    }
  }

  return uris;
}

/**
 * Get the mouse button number identifier from an event object.
 *
 * @param {MouseEvent|TouchEvent} event A mouse event.
 *
 * @return {number} A number representing the pressed button:
 *     0: No button pressed
 *     1: Primary button (usually left)
 *     2: Secondary button (usually right)
 *     3: Middle (usually the wheel)
 */
function getButtonFromEvent(event) {
  // Touches don't have buttons, so treat all touches as a primary button
  if (isTouchEvent(event)) {
    return 1;
  }

  switch (event.button) {
    case 0:
      return 1;
    case 2:
      return 2;
    case 1:
      return 3;
    default:
      return 0;
  }
}

/**
 * Check if the user agent is on a Mac.
 *
 * @return {boolean} True if Mac, false otherwise.
 */
function isMac() {
  if (!global.window) return false;
  if (!global.window.navigator) return false;
  const userAgent = global.window.navigator.userAgent || '';
  return userAgent.indexOf('Mac') > -1;
}

/**
 * Check if multi-select is enabled.
 * We currently disable it for the Web Player, since not much can be done with
 * a multi-selection there.
 *
 * @return {boolean} True if enabled, false otherwise.
 */
function isMultiSelectEnabled() {
  if ($('body').data('multi-select-disabled') !== null) return false;
  if (!global.window) return false;
  return !!global.window._getSpotifyModule;
}

/**
 * Check if keyboard selection is enabled.
 * If it's not enabled it is not possible to move the selection with arrow
 * keys or extend it with shift + arrow keys.
 *
 * @return {boolean} True if enabled, false otherwise.
 */
function isKeyboardNavEnabled() {
  return $('body').data('keyboard-select-disabled') === null;
}

/**
 * Check if the event is a touch event.
 *
 * @param {Event} event Event object.
 *
 * @return {boolean} True if it is a touch event object.
 */
function isTouchEvent(event) {
  return !!event.changedTouches;
}

/**
 * Get the closest selected position in the specified direction.
 *
 * @param {Position} position A position.
 * @param {string} direction The direction to search in: 'up' or 'down'.
 *
 * @return {Position?} A position or null if not found.
 */
function getClosestSelected(position, direction) {
  let newPosition = position;
  while (newPosition) {
    newPosition = positions.getClosest(newPosition, direction);
    if (newPosition && model.isSelected(newPosition)) {
      return newPosition;
    }
  }
  return null;
}

/**
 * Scroll the position into view.
 *
 * @param {Position} position A position.
 */
function scrollIntoView(position) {
  const container = containers.elements[position.containerIndex];
  const scrollContainer = container && container.querySelector('[data-scroll-container]');
  if (scrollContainer) {
    center.emit('scroll-to-index', scrollContainer, position.index);
  } else {
    const node = positions.getNodeFromPosition(position);
    if (!node) return;

    const offset = node.getBoundingClientRect().top;
    if (offset < 0 || offset >= window.innerHeight) {
      node.scrollIntoView(offset < 0);
    }
  }
}

/**
 * Update the list listeners for the current containers.
 */
function updateListListeners() {
  const uris = containers.getUris();

  for (let i = 0, l = uris.length; i < l; i++) {
    const uri = uris[i];
    if (uri && listListenerUris.indexOf(uri) === -1) {
      const list = live(uri).get('rows');
      if (list) {
        const listener = createListListener(uri);
        list.on('update', listener);
        listListeners[uri] = listener;
        listListenerUris.push(uri);
      }
    }
  }
}

/**
 * Create an event listener for list updates.
 * When an update happens, the selection model will be updated for the right
 * container.
 *
 * @param {string} uri A URI for a list.
 *
 * @return {function} A listener function.
 */
function createListListener(uri) {
  return function (operations) {
    const uris = containers.getUris();
    const containerIndex = uris.indexOf(uri);
    if (containerIndex > -1) {
      // If something was removed from the list, we must update the selection
      // state, as something that was selected might have been removed.
      // Insert and move operations don't affect the current selection state,
      // as everything is based on row IDs, which don't change.
      for (let i = 0, l = operations.length; i < l; i++) {
        const operation = operations[i];
        if (operation.type === 'remove') {
          model.updateContainer(containerIndex);
          break;
        }
      }

      // Update the rows visually based on the model state
      rows.update();
    }
  };
}

/**
 * Remove all list listeners.
 */
function resetListListeners() {
  for (let i = 0, l = listListenerUris.length; i < l; i++) {
    const uri = listListenerUris[i];
    const listener = listListeners[uri];
    const list = live(uri).get('rows');
    if (list && listener) {
      list.off('update', listener);
      delete listListeners[uri];
      listListenerUris.splice(i, 1);
      i--;
      l--;
    }
  }
}

function handleListSwap(event) {
  const rowsListBefore = live(event.before).get('rows');
  if (!rowsListBefore) return;

  const selectionBefore = selection.getIndicesPerList().filter(function (indicesPerList) {
    return indicesPerList.uri === event.before;
  })[0];

  let selectedKeysBefore = [];
  if (selectionBefore) {
    selectedKeysBefore = selectionBefore.indices.map(function (index) {
      return rowsListBefore.keys[index];
    });
  }

  center.on('scroll-reset', function onScrollReset() {
    center.off('scroll-reset', onScrollReset);

    live(event.after).get('rows', function (error, rowsListAfter) {
      selectedKeysBefore.forEach(function (selectedKeyBefore) {
        const indexAfter = rowsListAfter.keys.indexOf(selectedKeyBefore);
        if (indexAfter !== -1) {
          handleAddByUri(event.after, indexAfter, true);
        }
      });
    }, live.ASAP);
  });
}

exports.handleMouseDown = handleMouseDown;
exports.handleMouseUp = handleMouseUp;
exports.handleKeyDown = handleKeyDown;
exports.handleFocus = handleFocus;
exports.handleScrollShowAfter = handleScrollShowAfter;
exports.handleSetHidden = handleSetHidden;
exports.handleAddByUri = handleAddByUri;
exports.handleSelectAll = handleSelectAll;
exports.handleCopy = handleCopy;
exports.handleCopyAdvanced = handleCopyAdvanced;
exports.handleCut = handleCut;
exports.handleGetUris = handleGetUris;
exports.updateListListeners = updateListListeners;
exports.resetListListeners = resetListListeners;
exports.handleListSwap = handleListSwap;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../live":210,"../../spotify-elements":251,"../center":262,"../util/Position":329,"../util/cosmos":331,"./containers":317,"./index":319,"./model":320,"./positions":321,"./rows":322,"mout/array/intersection":450,"spotify-liburi":730}],319:[function(require,module,exports){
/**
 * spotify-events/selection
 */
'use strict';

const $ = require('../../spotify-elements');
const live = require('../../live');
const getOriginUri = require('../../live-wrapped-uri').getOriginUri;

const center = require('../center');
const controller = require('./controller');
const containers = require('./containers');
const model = require('./model');
const rows = require('./rows');
const positions = require('./positions');
const Position = require('../util/Position');
const appUtil = require('../util/app');

const cosmos = require('../util/cosmos');

let controlMessageSubscription;

/**
 * Attach event listeners etc.
 */
exports.attach = function () {
  const doc = $(document);
  doc.on('mousedown', controller.handleMouseDown);
  doc.on('touchstart', controller.handleMouseDown);
  doc.on('mouseup', controller.handleMouseUp);
  doc.on('touchend', controller.handleMouseUp);
  doc.on('keydown', controller.handleKeyDown);
  doc.on('focus', controller.handleFocus, true);

  center.on('scroll-show-after', controller.handleScrollShowAfter);
  center.on('selection-set-hidden', controller.handleSetHidden);
  center.on('list-swap', controller.handleListSwap);

  // Creating an "intentional bug".. By switching to use row IDs internally
  // for the selection model, we no longer need to manually update indices
  // as long as the new list has the same IDs (which we require anyway for
  // other reasons). We stopped using this event a long time ago anyway,
  // because it never really worked without odd behaviors. I've done a
  // code search (indexed Nov 23 2014), and there is not a single place
  // where this event is used, except in old versions of spotify-events,
  // which is not a problem. Technically, not responding to this event
  // is a breaking change, but for simplicity's sake let's stop handling it.
  // Fixing code that never gets used just for the sake of it makes no sense.
  // If someone really needs this in the future, we can fix it then.
  // So, this line should be commented for now.
  //
  // center.on('update-indices', controller.handleUpdateIndices);

  controlMessageSubscription = cosmos.subscribe({ url: 'sp://messages/v1/container/control' }, function (error, response) {
    if (error) throw error;
    const data = response.body;
    if (data && appUtil.isActiveAndFocused()) {
      if (data.type === 'select_all') {
        controller.handleSelectAll();
      } else if (data.type === 'copy') {
        controller.handleCopy();
      } else if (data.type === 'copy_advanced') {
        controller.handleCopyAdvanced();
      } else if (data.type === 'cut') {
        controller.handleCut();
      }
    }
  });
};

/**
 * Detach event listeners etc.
 */
exports.detach = function () {
  const doc = $(document);
  doc.off('mousedown', controller.handleMouseDown);
  doc.off('touchstart', controller.handleMouseDown);
  doc.off('mouseup', controller.handleMouseUp);
  doc.off('touchend', controller.handleMouseUp);
  doc.off('keydown', controller.handleKeyDown);
  doc.off('focus', controller.handleFocus, true);

  center.off('scroll-show-after', controller.handleScrollShowAfter);
  center.off('selection-set-hidden', controller.handleSetHidden);
  center.off('list-swap', controller.handleListSwap);

  // See comment in `attach` for the long story why this is commented.
  // center.off('update-indices', controller.handleUpdateIndices);

  if (controlMessageSubscription) {
    controlMessageSubscription.cancel();
    controlMessageSubscription = null;
  }
};

/**
 * Update the module based on the current DOM state.
 */
exports.update = function () {
  containers.update();
  controller.updateListListeners();
};

/**
 * Add a row to the selection based on a list URI.
 *
 * @param {string} listUri The list URI.
 * @param {number} index The index within the list.
 */
exports.add = function (listUri, index) {
  controller.handleAddByUri(listUri, index);
};

/**
 * Check if the selection has any holes (contains many ranges).
 *
 * @return {boolean} True if it has holes, false otherwise.
 */
exports.hasHoles = function () {
  return model.hasHoles();
};

/**
 * Check if the row node is selected.
 *
 * @param {HTMLElement|Elements} node A DOM node for a row.
 *
 * @return {boolean} True if it is selected, false otherwise.
 */
exports.isNodeSelected = function (node) {
  const newNode = 'innerHTML' in node ? node : node[0];
  if (!newNode) return false;

  const position = positions.getFromNode(newNode);
  if (!position) return false;

  return model.isSelected(position);
};

/**
 * Reset the selection state and its knowledge of any containers.
 */
exports.reset = function () {
  controller.resetListListeners();
  model.reset();
  rows.update();
  containers.reset();
};

/**
 * Clear the current selection.
 */
exports.clear = function () {
  model.clear();
  rows.update();
};

/**
 * Set the origin to a new position.
 *
 * @param {number} containerIndex The index of the container.
 * @param {number} index The index within the container.
 */
exports.setOrigin = function (containerIndex, index) {
  model.setOrigin(new Position(containerIndex, index));
};

/**
 * Set the focus to a new position.
 *
 * @param {number} containerIndex The index of the container.
 * @param {number} index The index within the container.
 */
exports.setFocus = function (containerIndex, index) {
  model.setFocus(new Position(containerIndex, index));
};

/**
 * Get the current origin position.
 *
 * @return {Object?} An object with numeric properties `containerIndex`
 *     and `index`, or null if no origin is set.
 */
exports.getOrigin = function () {
  const origin = model.getOrigin();
  if (!origin) return null;
  return {
    containerIndex: origin.containerIndex,
    index: origin.index
  };
};

/**
 * Get the current focus position.
 *
 * @return {Object?} An object with numeric properties `containerIndex`
 *     and `index`, or null if no origin is set.
 */
exports.getFocus = function () {
  const focus = model.getFocus();
  if (!focus) return null;
  return {
    containerIndex: focus.containerIndex,
    index: focus.index
  };
};

/**
 * Get all selected indices organized by list.
 *
 * @return {Array.<Object>} Array of objects of this structure:
 *     {
 *       containerIndex: 0,
 *
 *       // This is the list in the UI (could be sorted or unsorted)
 *       uri: 'spotify:internal:sortlist:asc:track(name):list',
 *       keys: ['c', 'd', 'e', 'j', 'o', 't'],
 *       indices: [3, 4, 5, 10, 15, 20], // Ordered indices in the list
 *
 *       // If all items between two selected items are hidden, they will be
 *       // included here to allow nice ranges to be created from this. It will
 *       // also include hidden items right after the last selected item.
 *       keysWithHidden: ['c', 'd', 'e', 'j', 'k', 'l', 'm', 'n', 'o', 't'],
 *       indicesWithHidden: [3, 4, 5, 10, 11, 12, 13, 14, 15, 20],
 *
 *       // Optional object for the unsorted list if the list is a sorted list
 *       origin: {
 *         uri: 'spotify:list',
 *         keys: ['c', 'd', 'e', 'j', 'o', 't'],
 *         indices: [7, 19, 8, 14, 0, 9] // Unordered indices in the original list
 *       }
 *     }
 */
exports.getIndicesPerList = function () {
  const selections = model.selections;
  const indicesPerList = [];

  let list;

  const listKeys = selectedIndex => {
    return list.keys[selectedIndex];
  };

  for (let i = 0; i < selections.length; i++) {
    const containerSelection = selections[i];
    if (containerSelection && Object.keys(containerSelection).length) {
      const uri = containers.getUri(i);
      if (!uri) continue;

      list = containers.getLiveList(i);
      if (!list) continue;

      const indices = model.getIndicesForContainer(i);
      if (!indices) continue;

      const keys = indices.map(listKeys);

      const indicesWithHidden = model.getIndicesWithHiddenForContainer(i);
      const keysWithHidden = indicesWithHidden.map(listKeys);

      const context = {
        containerIndex: i,
        uri: uri,
        indices: indices,
        keys: keys,
        indicesWithHidden: indicesWithHidden,
        keysWithHidden: keysWithHidden
      };

      const originUri = getOriginUri(uri);
      if (originUri) {
        const wrappedList = live(uri).get('rows');
        const originList = live(originUri).get('rows');

        let originIndices;
        let originKeys;
        if (wrappedList && originList) {
          let key;
          const originListKeyIndexMap = {};
          originIndices = new Array(indices.length);
          originKeys = new Array(indices.length);

          const originListKeys = originList.keys;
          for (let j = 0; j < originListKeys.length; j++) {
            originListKeyIndexMap[originListKeys[j]] = j;
          }

          for (let j = 0; j < indices.length; j++) {
            key = wrappedList.keys[indices[j]];
            originIndices[j] = originListKeyIndexMap[key];
            originKeys[j] = originList.keys[originIndices[j]];
          }
        }
        context.origin = {
          uri: originUri,
          indices: originIndices || [],
          keys: originKeys || []
        };
      }

      indicesPerList.push(context);
    }
  }

  return indicesPerList;
};

/**
 * Get all selected indices relative to the full page (across all containers).
 *
 * @return {Object?} The value null if no global context is found or if found,
 *     an object of this structure:
 *     {
 *       uri: 'spotify:context:uri',
 *       indices: [0, 3, 56, 120],
 *
 *       // These elements are Elements instances from the 'elements' npm
 *       // package. This should be fixed in a future major version, to be
 *       // normal HTML elements.
 *       containers: [
 *         containerElement1,
 *         containerElement1,
 *         containerElement4,
 *         containerElement5
 *       ]
 *     }
 */
exports.getIndicesGlobal = function () {
  const selections = model.selections;
  const elements = containers.elements;
  const indices = [];
  const selectionContainers = [];

  if (elements.length === 0) {
    return null;
  }
  const contextUriContainer = elements[0].closest('[data-context]');
  const contextUri = contextUriContainer && contextUriContainer.getAttribute('data-uri');

  if (!contextUri) return null;

  let containerSelection;
  const containerSelectionByKey = key => {
    return !!containerSelection[key];
  };

  for (let container = 0; container < selections.length; container++) {
    containerSelection = selections[container];
    const list = containers.getLiveList(container);
    if (list && containerSelection) {
      const orderedSelectedKeys = list.keys.filter(containerSelectionByKey);

      for (let i = 0, l = orderedSelectedKeys.length; i < l; i++) {
        const j = list.keys.indexOf(orderedSelectedKeys[i]);
        indices.push(positions.getGlobalIndexFromPosition(new Position(container, j)));
        selectionContainers.push($(elements[container]));
      }
    }
  }

  return {
    uri: contextUri,
    indices: indices,
    containers: selectionContainers
  };
};

/**
 * Get the URI of all selected rows.
 *
 * @return {Array.<string>} Array of URIs.
 */
exports.getUris = function () {
  return controller.handleGetUris();
};

/**
 * Get the nodes for all selected rows that can be found.
 *
 * @return {Array.<HTMLElement>} Array of DOM nodes.
 */
exports.getNodes = function () {
  return rows.getSelectedRows();
};

},{"../../live":210,"../../live-wrapped-uri":209,"../../spotify-elements":251,"../center":262,"../util/Position":329,"../util/app":330,"../util/cosmos":331,"./containers":317,"./controller":318,"./model":320,"./positions":321,"./rows":322}],320:[function(require,module,exports){
/**
 * @module spotify-events/selection/model
 * @private
 */
'use strict';

const live = require('../../live');
const Range = require('../../range2');
const containers = require('./containers');
const positions = require('./positions');
const Position = require('../util/Position');

/**
 * Selections for all known containers.
 * Each container's selection space is represented as an object where keys are
 * row IDs. This allows for quick lookups.
 *
 * @type {Array.<Object.<string, boolean>>}
 */
const selections = [];

/**
 * Hidden items for all known containers.
 * Each container is represented as an object where keys are row IDs. This
 * allows for quick lookups.
 *
 * @type {Object.<number, Object.<string, boolean>>}
 */
let hiddenKeysPerContainer = {};

let originContainerIndex = null;
let originKey = null;
let focusContainerIndex = null;
let focusKey = null;
let focusIsTouch = false;

/**
 * Get the current origin.
 *
 * @return {Position?} The origin position or null if not set.
 */
function getOrigin() {
  if (originContainerIndex === null) return null;
  if (originKey === null) return null;

  const list = containers.getLiveList(originContainerIndex);
  if (list) {
    const index = list.keys.indexOf(originKey);
    if (index === -1) return null;
    const position = new Position(originContainerIndex, index);
    return position;
  }
  return null;
}

/**
 * Get the current focus. This is the position for the keyboard focus.
 *
 * @return {Position?} The focus position or null if not set.
 */
function getFocus() {
  if (focusContainerIndex === null) return null;
  if (focusKey === null) return null;

  const list = containers.getLiveList(focusContainerIndex);
  if (list) {
    const index = list.keys.indexOf(focusKey);
    const position = new Position(focusContainerIndex, index);
    return position;
  }
  return null;
}

/**
 * Set the current origin.
 *
 * @param {Position?} position A position or null if removing the origin.
 */
function setOrigin(position) {
  if (position) {
    const list = containers.getLiveList(position.containerIndex);
    if (list) {
      originContainerIndex = position.containerIndex;
      originKey = list.keys[position.index] || null;
      return;
    }
  }

  originContainerIndex = null;
  originKey = null;
}

/**
 * Set the current focus.
 *
 * @param {Position?} position A position or null if removing the focus.
 */
function setFocus(position, options) {
  focusIsTouch = !!(options && options.isTouch);

  if (position) {
    const list = containers.getLiveList(position.containerIndex);
    if (list) {
      focusContainerIndex = position.containerIndex;
      focusKey = list.keys[position.index];
      return;
    }
  }

  focusContainerIndex = null;
  focusKey = null;
}

/**
 * Check if the current focus was triggered by a touch.
 * This is done since we might want to have different styles for selection focus
 * when triggered by a touch event.
 *
 * @return {boolean} True if triggered by touch.
 */
function wasFocusTriggeredByTouch() {
  return focusIsTouch;
}

/**
 * Handle setting which indices are hidden.
 *
 * @param {Array.<number>} hiddenIndices Array of indices that are hidden.
 * @param {string} containerUri The URI of the container.
 */
function setHiddenIndices(hiddenIndices, containerUri) {
  const list = live(containerUri).get('rows');
  if (list) {
    const keys = list.keys;
    const hiddenKeys = {};
    for (let i = 0, l = hiddenIndices.length; i < l; i++) {
      const key = keys[hiddenIndices[i]];
      if (key) hiddenKeys[key] = true;
    }

    const containerIndex = containers.getContainerIndex(containerUri);

    hiddenKeysPerContainer[containerIndex] = hiddenKeys;

    updateContainer(containerIndex);
  }
}

/**
 * Check if given position is hidden.
 *
 * @param {Position} from The position to check.
 * @return {boolean} True if position is hidden.
 */
function isPositionHidden(pos) {
  const idsPerContainer = getIds(pos, pos);
  const id = idsPerContainer[0][0];
  const hiddenKeys = hiddenKeysPerContainer[pos.containerIndex];
  return hiddenKeys && hiddenKeys[id];
}

/**
 * Add rows to the selection.
 *
 * @param {Position} from The start position to add.
 * @param {Position=} optTo The end position to add. If not provided, it will
 *     only add a single row to the selection.
 */
function add(from, optTo) {
  let to = optTo || from;
  let newFrom = from;

  // Flip the positions if the direction is up.
  if (positions.getDirection(newFrom, to) === -1) {
    const temp = newFrom;
    newFrom = to;
    to = temp;
  }

  const idsPerContainer = getIds(newFrom, to);

  for (let i = 0, l = idsPerContainer.length; i < l; i++) {
    const containerIndex = newFrom.containerIndex + i;
    const selected = selections[containerIndex] || (selections[containerIndex] = Object.create(null));
    const ids = idsPerContainer[i];
    const hiddenKeys = hiddenKeysPerContainer[containerIndex];

    // Set all new items as selected, unless they're hidden
    for (let j = 0; j < ids.length; j++) {
      const id = ids[j];
      if (!hiddenKeys || !hiddenKeys[id]) {
        selected[id] = true;
      }
    }
  }
}

/**
 * Remove rows from the selection.
 *
 * @param {Position} from The start position to remove.
 * @param {Position=} optTo The end position to remove. If not provided, it will
 *     only remove a single row from the selection.
 */
function remove(from, optTo) {
  let to = optTo || from;
  let newFrom = from;

  // Flip the positions if the direction is up.
  if (positions.getDirection(newFrom, to) === -1) {
    const temp = newFrom;
    newFrom = to;
    to = temp;
  }

  const idsPerContainer = getIds(newFrom, to);

  for (let i = 0, l = idsPerContainer.length; i < l; i++) {
    const containerIndex = newFrom.containerIndex + i;
    const selected = selections[containerIndex] || (selections[containerIndex] = Object.create(null));
    const ids = idsPerContainer[i];

    // Loop the row ids that are to be removed and remove them from the selection.
    // That's usually faster than looping the selection since there's no UI for
    // removing a big chunk of selection in one go.
    for (let j = 0; j < ids.length; j++) {
      const id = ids[j];
      delete selected[id];
    }
  }
}

/**
 * Clear the current selection.
 */
function clear() {
  selections.length = 0;
  setOrigin(null);
  setFocus(null);
}

/**
 * Reset the current selection state.
 */
function reset() {
  clear();
  hiddenKeysPerContainer = {};
}

/**
 * Update the model state based on the current state of the list.
 * If items were removed from the list, removed items that were selected
 * will be removed from selection state.
 */
function updateContainer(containerIndex) {
  const keys = selections[containerIndex];
  if (!keys) return;

  const list = containers.getLiveList(containerIndex);
  if (!list) return;

  // TODO: Fix for-in statement so it doesn't REQUIRE
  // prototype chain iteration
  // eslint-disable-next-line guard-for-in
  for (const key in keys) {
    const hasKey = list.hasKey(key);
    let shouldDelete = !hasKey;
    if (!shouldDelete) {
      const hiddenKeys = hiddenKeysPerContainer[containerIndex];
      shouldDelete = hiddenKeys ? hiddenKeys[key] : false;
    }
    if (shouldDelete) {
      delete keys[key];
    }
  }
}

/**
 * Get IDs for the provided global range.
 *
 * @param {Position} from The start position.
 * @param {Position} to The end position. This position must be below the
 *     `from` position.
 *
 * @return {Array.<Array.<string>>} Array of IDs per container.
 */
function getIds(from, to) {
  const idsPerContainer = [];

  const fromContainer = from.containerIndex;
  const toContainer = to.containerIndex;

  for (let i = fromContainer; i <= toContainer; i++) {
    const fromIndex = i === fromContainer ? from.index : 0;
    let toIndex;
    if (i === toContainer) {
      toIndex = to.index;
    } else {
      const containerLength = containers.getContainerLength(i);
      if (containerLength > 0) {
        toIndex = containerLength - 1;
      }
    }

    if (toIndex === undefined) {
      idsPerContainer.push([]);
    } else {
      const ids = [];
      idsPerContainer.push(ids);

      const containerUri = containers.getUri(i);
      const list = live(containerUri).get('rows');
      if (list) {
        const keys = list.keys;

        for (let n = fromIndex; n < toIndex + 1; n++) {
          ids.push(keys[n]);
        }
      }
    }
  }

  return idsPerContainer;
}

/**
 * Check if the position is selected.
 *
 * @param {Position} position A position.
 *
 * @return {boolean} True if it is selected, false otherwise.
 */
function isSelected(position) {
  // Get the ranges of the according container
  const keys = selections[position.containerIndex];
  if (!keys) return false;

  // Check if the row is within the selected ranges for the container
  const list = containers.getLiveList(position.containerIndex);
  if (list) {
    const key = list.keys[position.index];
    return !!keys[key];
  }

  return false;
}

/**
 * Check if the selection has any holes (contains many ranges).
 *
 * @return {boolean} True if it has holes, false otherwise.
 */
function hasHoles() {
  let rangeCount = 0;

  for (let containerIndex = 0; containerIndex < selections.length; containerIndex++) {
    const containerSelection = selections[containerIndex];
    const list = containers.getLiveList(containerIndex);

    const keys = Object.keys(containerSelection);

    // A selection in more than one container means the selection has holes
    if (keys.length > 0) {
      rangeCount++;

      // Also more than one range in only one container means it has holes.
      if (list) {
        const indices = [];
        for (let j = 0, len = keys.length; j < len; j++) {
          indices.push(list.indexOf(keys[j]));
        }
        indices.sort(function (a, b) {
          return a - b;
        });
        let previousIndex;
        for (let i = 0, l = indices.length; i < l; i++) {
          const index = indices[i];
          if (i > 0 && index > previousIndex + 1) {
            rangeCount++;
            break;
          }
          previousIndex = index;
        }
      }
    }
    if (rangeCount > 1) return true;
  }

  return false;
}

/**
 * Check if there is any selection in any container.
 *
 * @return {boolean} True if there is a selection.
 */
function hasSelection() {
  for (let i = 0, l = selections.length; i < l; i++) {
    if (selections[i] && Object.keys(selections[i]).length > 0) {
      return true;
    }
  }

  return false;
}

/**
 * Get the selected indices for a container.
 *
 * @param {number} containerIndex The container index.
 *
 * @return {Array.<number>?} An array of indices or null if nothing is selected.
 */
function getIndicesForContainer(containerIndex) {
  const unorderedKeys = selections[containerIndex];
  if (!unorderedKeys) return null;
  let indices = [];

  const list = containers.getLiveList(containerIndex);

  const orderedKeys = list.keys.filter(function (key) {
    return !!unorderedKeys[key];
  });

  if (list && orderedKeys.length) {
    if (orderedKeys.length > 1) {
      // indexOfMany() is much more perfomant for big selections
      indices = list.indexOfMany(orderedKeys);
    } else {
      // for a single selected item, indexOf() is a little bit more perfomant
      indices = [list.indexOf(orderedKeys[0])];
    }
  }

  return indices.length ? indices : null;
}

/**
 * Get the selected indices for a container, including hidden items that join
 * two ranges. For example, in a list [A, B, C, D, E, F, G, H], everything is
 * selected except C, D, F and G. There are hidden items, C, D, F and G. This
 * method would then return the indices of all items except H,
 * [0, 1, 2, 3, 4, 5, 6]. It does include hidden items right after the last
 * selected one.
 *
 * @param {number} containerIndex The container index.
 *
 * @return {Array.<number>?} An array of indices or null if nothing is selected.
 */
function getIndicesWithHiddenForContainer(containerIndex) {
  let indices = getIndicesForContainer(containerIndex);
  if (!indices) return null;

  const hiddenKeys = hiddenKeysPerContainer[containerIndex];
  if (!hiddenKeys) return indices;

  const ranges = Range.fromIndices(indices);
  if (ranges.length === 1) return indices;

  const list = containers.getLiveList(containerIndex);
  if (!list) return indices;

  const hiddenIds = Object.keys(hiddenKeys);
  let hiddenIndices = [];

  if (hiddenIds.length) {
    if (hiddenIds.length > 1) {
      // indexOfMany() is much more perfomant for big selections
      hiddenIndices = list.indexOfMany(hiddenIds);
    } else {
      // for a single selected item, indexOf() is a little bit more perfomant
      hiddenIndices = [list.indexOf(hiddenIds[0])];
    }
  }

  hiddenIndices = hiddenIndices.filter(function (index) {
    return index > -1;
  });

  const hiddenRanges = Range.fromIndices(hiddenIndices);
  const hiddenStarts = hiddenRanges.map(function (range) {
    return range.start;
  });
  const hiddenEnds = hiddenRanges.map(function (range) {
    return range.end;
  });

  for (let i = 0, l = ranges.length; i < l; i++) {
    const range = ranges[i];
    const nextRange = ranges[i + 1];

    const indexOfRange = hiddenStarts.indexOf(range.end);
    if (indexOfRange > -1) {
      const hiddenEnd = hiddenEnds[indexOfRange];
      if (!nextRange || hiddenEnd === nextRange.start) {
        const hiddenIndicesInRange = hiddenRanges[indexOfRange].toIndices();
        if (hiddenIndicesInRange.length > 0) {
          indices = indices.concat(hiddenIndicesInRange);
        }
      }
    }
  }

  indices.sort(function (a, b) {
    return a - b;
  });

  return indices.length ? indices : null;
}

exports.selections = selections;
exports.getOrigin = getOrigin;
exports.getFocus = getFocus;
exports.setOrigin = setOrigin;
exports.setFocus = setFocus;
exports.wasFocusTriggeredByTouch = wasFocusTriggeredByTouch;
exports.setHiddenIndices = setHiddenIndices;
exports.isPositionHidden = isPositionHidden;
exports.add = add;
exports.remove = remove;
exports.clear = clear;
exports.reset = reset;
exports.updateContainer = updateContainer;
exports.isSelected = isSelected;
exports.hasHoles = hasHoles;
exports.hasSelection = hasSelection;
exports.getIndicesForContainer = getIndicesForContainer;
exports.getIndicesWithHiddenForContainer = getIndicesWithHiddenForContainer;

},{"../../live":210,"../../range2":245,"../util/Position":329,"./containers":317,"./positions":321}],321:[function(require,module,exports){
/**
 * @module spotify-events/selection/positions
 * @private
 */
'use strict';

const $ = require('../../spotify-elements');

const containers = require('./containers');
const Position = require('../util/Position');

/**
 * Get the closest position in the specified direction.
 *
 * @param {Position} position A position.
 * @param {string} direction The direction to search in: 'up' or 'down'.
 *
 * @return {Position?} A position or null if not found.
 */
function getClosest(position, direction) {
  const isDown = direction === 'down';
  let containerIndex = position.containerIndex;
  const index = position.index;

  // Find next position within the current container
  let containerLength = containers.getContainerLength(containerIndex);
  let nextIndex = isDown ? index + 1 : index - 1;
  if (nextIndex < containerLength && nextIndex >= 0) {
    return new Position(containerIndex, nextIndex);
  }

  // Out of bounds, traverse containers
  containerIndex = isDown ? containerIndex + 1 : containerIndex - 1;
  containerLength = containers.getContainerLength(containerIndex);
  if (containerLength) {
    nextIndex = isDown ? 0 : containerLength - 1;
    return new Position(containerIndex, nextIndex);
  }

  return null;
}

/**
 * Get a position from a row node.
 *
 * @param {HTMLElement} node A DOM node for a list row.
 *
 * @return {Position?} A position or null if not found.
 */
function getFromNode(node) {
  // We need a parent node, since we will be checking if the row is inside
  // one of the known selection containers.
  if (!node.parentNode) return null;

  // We also need a data-index attribute on the row to get the index for the
  // row within the current selection container.
  if (!node.hasAttribute('data-index')) return null;

  const elements = containers.elements;
  if (elements.length === 0) return null;

  for (let i = 0, l = elements.length; i < l; i++) {
    if (elements[i] && containsNode(elements[i], node)) {
      const row = +node.getAttribute('data-index');
      return new Position(i, row);
    }
  }

  return null;
}

/**
 * Check if an element contains another node.
 *
 * @param {HTMLElement} element The container element.
 * @param {HTMLElement} child The potential child node.
 *
 * @return {boolean} True if element contains the child, false otherwise.
 */
function containsNode(element, child) {
  let newChild = child;
  while (newChild && newChild.parentNode !== element) {
    newChild = newChild.parentNode;
  }
  return !!newChild;
}

/**
 * Get the row node that the specified position represents.
 *
 * @param {Position} position A position.
 *
 * @return {HTMLElement?} A DOM node or null if not found.
 */
function getNodeFromPosition(position) {
  const container = containers.elements[position.containerIndex];
  if (!container) return null;
  const node = $(container).find(`[data-index=${position.index}]`);
  return node ? node[0] : null;
}

/**
 * Get the direction from one position to another.
 *
 * @param {Position} from First position.
 * @param {Position} to Second position.
 *
 * @return {number} A number representing the direction.
 *     -1 is up
 *      0 is same
 *      1 is down
 */
function getDirection(from, to) {
  if (!from || !to) return 0;

  // With different containers we can just compare the containers
  if (from.containerIndex !== to.containerIndex) {
    return from.containerIndex < to.containerIndex ? 1 : -1;
  }

  // Within the same container, compare the row indices
  if (from.index === to.index) {
    return 0;
  }
  return from.index < to.index ? 1 : -1;
}

/**
 * Get data about in which container and where inside that the provided
 * global index is.
 *
 * @param {number} globalIndex An index relative to the full page (all
 *     selection containers).
 *
 * @return {Position} A position.
 */
function getPositionFromGlobalIndex(globalIndex) {
  let resolvedIndex = globalIndex;
  let resolvedContainerIndex = 0;
  let containerLength;
  let countIndices = 0;

  // Subtract the amount of tracks in containers until passing globalIndex
  for (let i = 0, l = containers.elements.length; i < l; i++) {
    containerLength = containers.getContainerLength(i);
    countIndices += containerLength;

    if (countIndices > globalIndex) break;

    resolvedContainerIndex = i + 1;
    resolvedIndex -= containerLength;
  }

  return new Position(resolvedContainerIndex, resolvedIndex);
}

/**
 * Get the global index relative to the full page (across all selection
 * containers) from a position object.
 *
 * @param {Position} position A position.
 *
 * @return {number} A global index.
 */
function getGlobalIndexFromPosition(position) {
  let resolvedIndex = position.index;

  // Subtract length of previous lists
  for (let i = position.containerIndex - 1; i >= 0; i--) {
    resolvedIndex += containers.getContainerLength(i);
  }

  return resolvedIndex;
}

/**
 * Get last position on page.
 *
 * @return {Position} A position.
 */
function getLastPosition() {
  const lastContainerIndex = containers.elements.length - 1;
  const lastIndex = containers.getContainerLength(lastContainerIndex) - 1;

  return new Position(lastContainerIndex, lastIndex);
}

/**
 * Get last position for "select all" on page, disregarding containers with
 * [data-select-all="false"].
 *
 * @return {Position} A position.
 */
function getLastPositionForSelectAll() {
  let lastContainerIndex;
  containers.elements.forEach(function (element, index) {
    if (element.getAttribute('data-list-may-select-all') !== 'false') {
      lastContainerIndex = index;
    }
  });

  const lastIndex = containers.getContainerLength(lastContainerIndex) - 1;

  return new Position(lastContainerIndex, lastIndex);
}

exports.getClosest = getClosest;
exports.getFromNode = getFromNode;
exports.getNodeFromPosition = getNodeFromPosition;
exports.getDirection = getDirection;
exports.getPositionFromGlobalIndex = getPositionFromGlobalIndex;
exports.getGlobalIndexFromPosition = getGlobalIndexFromPosition;
exports.getLastPosition = getLastPosition;
exports.getLastPositionForSelectAll = getLastPositionForSelectAll;

},{"../../spotify-elements":251,"../util/Position":329,"./containers":317}],322:[function(require,module,exports){
/**
 * @module spotify-events/selection/rows
 * @private
 */
'use strict';

const $ = require('../../spotify-elements');
const difference = require('mout/array/difference');

const model = require('./model');
const containers = require('./containers');
const positions = require('./positions');

const SELECTOR_ROW = '[data-list-item]';
const CLASSNAME_SELECTED = 'selected';
const CLASSNAME_FOCUSED = 'selection-focus';
const CLASSNAME_FOCUSED_TOUCH = 'selection-focus-touch';
let focusTimeout;

/**
 * Update the selection state of rows.
 *
 * @param {HTMLElement=} node Optional DOM node. If provided, the update
 *     will only affect rows found inside this node.
 */
function update(node) {
  const currentlySelectedRows = getSelectedRows(node);
  const rowsToBeSelected = getRowsToSelect(node);

  const rowsToDeselect = difference(currentlySelectedRows, rowsToBeSelected);
  const rowsToSelect = difference(rowsToBeSelected, currentlySelectedRows);

  currentlySelectedRows.forEach(function (row) {
    $(row).removeClass(CLASSNAME_FOCUSED);
    $(row).removeClass(CLASSNAME_FOCUSED_TOUCH);
  });

  // Remove styles for selected rows that should now be deselected
  rowsToDeselect.forEach(function (row) {
    $(row).removeClass(CLASSNAME_SELECTED);
  });

  // Add styles for unselected rows that should now be selected
  rowsToSelect.forEach(function (row) {
    $(row).addClass(CLASSNAME_SELECTED);
  });

  // Add styles for the row with the selection focus
  const focus = model.getFocus();
  if (focus) {
    const focusNode = positions.getNodeFromPosition(focus);
    if (focusNode) {
      // If the focusNode is not yet in the viewport and we `focus()` it, the
      // browser will bluntly scroll it into view, which looks bad. (KM-6508)
      clearTimeout(focusTimeout);
      focusTimeout = setTimeout(function () {
        const isInputFocused = document.activeElement && $(document.activeElement).matches('input, textarea');
        const isButtonFocused = document.activeElement && $(document.activeElement).matches('button');
        if (isElementInViewport(focusNode) && !isInputFocused && !isButtonFocused) {
          focusNode.focus();
        }
      }, 0);
      $(focusNode).addClass(CLASSNAME_FOCUSED);

      if (model.wasFocusTriggeredByTouch()) {
        $(focusNode).addClass(CLASSNAME_FOCUSED_TOUCH);
      }
    }
  }
}

/**
 * Get the rows that are currently selected, found inside the known containers.
 *
 * @param {HTMLElement=} node Optional DOM node. If provided, it will only
 *     search inside this node.
 *
 * @return {Array.<HTMLElement>} Array of DOM nodes.
 */
function getSelectedRows(node) {
  const elements = node ? [node] : containers.elements;
  const rows = [];

  elements.forEach(function (container) {
    const nodes = $(container).search(`${SELECTOR_ROW}.${CLASSNAME_SELECTED}`);
    if (nodes) Array.prototype.push.apply(rows, nodes);
  });

  return rows;
}

/**
 * Get the rows that should be selected, found inside the known containers.
 *
 * @param {HTMLElement=} node Optional DOM node. If provided, it will only
 *     search inside this node.
 *
 * @return {Array.<HTMLElement>} Array of DOM nodes.
 */
function getRowsToSelect(node) {
  const rows = [];
  const containerElements = containers.elements;

  model.selections.forEach(function (keys, index) {
    if (!keys) return;

    const list = containers.getLiveList(index);
    if (!list) return;

    let container = containerElements[index];
    // If a node was passed, only check the container if it contains the node
    if (node && !containerElements[index].contains(node)) {
      container = null;
    }
    if (!container) {
      return;
    }

    const listNodes = $(container).search(SELECTOR_ROW);
    if (!listNodes) return;

    const nodes = listNodes.filter(function (listNode) {
      const nodeIndex = +listNode.getAttribute('data-index');
      const nodeRowId = list.keys[nodeIndex];
      return !!keys[nodeRowId];
    });

    Array.prototype.push.apply(rows, nodes);
  });
  return rows;
}

function isElementInViewport(el) {
  const rect = el.getBoundingClientRect();
  return rect.top >= 0 && rect.bottom <= document.documentElement.clientHeight;
}

exports.update = update;
exports.getSelectedRows = getSelectedRows;

},{"../../spotify-elements":251,"./containers":317,"./model":320,"./positions":321,"mout/array/difference":444}],323:[function(require,module,exports){
/**
 * @module spotify-events/slider
 */
'use strict';

const $ = require('../spotify-elements');
const center = require('./center');

const live = require('../live');

const ATTR_SLIDER = 'slider';
const ATTR_PROPERTY = 'slider-property';
const SELECTOR_SLIDER = `[data-${ATTR_SLIDER}]`;
const CLASSNAME_ENABLED = 'enabled';
const CLASSNAME_DISABLED = 'disabled';
const ATTR_ALLOWED = 'slider-allowed-property';

const SPACE_KEY_CODE = 32;

// Stored nodes, used to not add listeners multiple times
const storedNodes = [];

/**
 * Handle a click on a slider node.
 *
 * @param {MouseEvent} event Event object.
 * @param {Elements} elem An elements DOM node for the slider.
 */
function handleClick(event, elem) {
  const property = elem.data(ATTR_PROPERTY);

  if (elem.data(ATTR_ALLOWED) && !live(elem.data('uri')).get(elem.data(ATTR_ALLOWED))) {
    return;
  }

  if (property) {
    // If a property is set, update the model. That will later trigger
    // an update of the view and a change event on center will be sent.
    toggleModelPropertyAndPublish(elem[0], property);
  } else {
    // If no property is set, emit a change event on center, and let the handler
    // decide what's the state of the slider by emiting a 'slider-set' event.
    emitChangeEvent(elem[0], !elem.hasClass(CLASSNAME_ENABLED));
  }
}

/**
 * Handle a keyboard event on a slider node.
 *
 * @param {KeyboardEvent} event Event object.
 * @param {Elements} elem An elements DOM node for the slider.
 */
function handleKeyUp(event, elem) {
  if (event.keyCode !== SPACE_KEY_CODE) {
    return;
  }

  handleClick(event, elem);
}

/**
 * Handle when a slider-set event happens on center.
 *
 * @param {Object} event An object with data.
 */
function onSliderSet(event) {
  if (!event.id) return;

  const elem = $(`[data-${ATTR_SLIDER}=${event.id}]`);
  if (!elem) return;

  const node = elem[0];
  const enabled = !!event.enabled;

  const property = elem.data(ATTR_PROPERTY);

  if (property) {
    toggleModelPropertyAndPublish(node, property, enabled);
  } else {
    setState(node, enabled);
  }
}

/**
 * Update the live model with new data. If no data-uri is found from
 * the passed node, nothing happens.
 *
 * @param {HTMLElement} node A DOM node for the slider.
 * @param {string} property A property name on the model.
 * @param {boolean=} enabled Optional boolean flag. If true, this
 *     sets it to true, if false this sets it to false. If not provided,
 *     this sets it to the opposite of the current value in the model.
 */
function toggleModelPropertyAndPublish(node, property, enabled) {
  const uri = getUriFromNode(node);
  if (!uri) return;

  const model = live(uri);

  // If the model doesn't have a current value, we can't safely
  // set a new value without maybe being wrong.
  const value = model.get(property);
  if (value === undefined) return;

  const newValue = enabled === undefined ? !value : enabled;

  const data = {};
  data[property] = newValue;

  // Publishing the new value to the model will trigger the update
  // handler added here in this module to update the visual state
  // of the button.
  model.publish(data);
}

/**
 * Update the state of one slider node.
 *
 * @param {HTMLElement} node A DOM node for the slider.
 */
function updateNode(node) {
  // Don't handle the same URI and node twice.
  if (storedNodes.indexOf(node) > -1) return;
  storedNodes.push(node);

  const elem = $(node);
  const property = elem.data(ATTR_PROPERTY);
  const allowedProperty = elem.data(ATTR_ALLOWED);

  if (!property) return;

  const uri = getUriFromNode(node);
  if (!uri) return;

  const model = live(uri);

  model.get(property, function (error, value) {
    if (error) throw error;

    setState(node, !!value);
    emitChangeEvent(node, !!value);

    model.on('update', function (properties) {
      if (property in properties) {
        setState(node, !!properties[property]);
        emitChangeEvent(node, !!properties[property]);
      }

      if (allowedProperty && allowedProperty in properties) {
        disableNode(node, !properties[allowedProperty]);
      }
    });
  });
}

/**
 * Update a slider node based on a value.
 *
 * @param {HTMLElement} node A DOM node for a slider.
 * @param {boolean} enabled True if should be enabled, false otherwise.
 */
function setState(node, enabled) {
  const elem = $(node);
  if (enabled) {
    elem.addClass(CLASSNAME_ENABLED);
  } else {
    elem.removeClass(CLASSNAME_ENABLED);
  }
}

/**
 * Update a slider node based on whether is disabled
 *
 * @param {HTMLElement} node A DOM node for a slider.
 * @param {boolean} disabled True if should be disabled, false otherwise.
 */
function disableNode(node, disabled) {
  const elem = $(node);
  if (disabled) {
    elem.addClass(CLASSNAME_DISABLED);
  } else {
    elem.removeClass(CLASSNAME_DISABLED);
  }
}

/**
 * Emit a change event on center. It will have the following format:
 * {
 *   element: HTMLElement,
 *   id: 'id from data-slider attribute' || null,
 *   enabled: true // the new value
 * }
 *
 * @param {HTMLElement} node A DOM node for a slider.
 * @param {boolean} enabled True if enabled, false otherwise.
 */
function emitChangeEvent(node, enabled) {
  const id = $(node).data(ATTR_SLIDER) || null;
  center.emit('slider-change', {
    element: node,
    id: id,
    enabled: enabled
  });
}

/**
 * Get a URI from a node.
 *
 * @param {HTMLElement} node A DOM node.
 *
 * @return {string?} A URI string or null if not found.
 */
function getUriFromNode(node) {
  const stateNode = node.closest('[data-uri]');
  if (!stateNode) return null;
  return stateNode.getAttribute('data-uri');
}

let isAttached = false;

/**
 * Update the module based on the current DOM state.
 *
 * @param {HTMLElement=} node Optional DOM node to make changes inside.
 */
exports.update = function (node) {
  if (!isAttached) return;

  const nodes = $(node || document).search(SELECTOR_SLIDER);
  if (!nodes) return;

  nodes.forEach(updateNode);
};

/**
 * Attach event listeners etc.
 */
exports.attach = function () {
  if (isAttached) return;
  isAttached = true;

  const doc = $(document);
  doc.delegate('click', SELECTOR_SLIDER, handleClick);
  doc.delegate('keyup', SELECTOR_SLIDER, handleKeyUp);

  center.on('slider-set', onSliderSet);
};

/**
 * Detach event listeners etc.
 */
exports.detach = function () {
  if (!isAttached) return;
  isAttached = false;

  const doc = $(document);
  doc.undelegate('click', SELECTOR_SLIDER, handleClick);
  doc.undelegate('keyup', SELECTOR_SLIDER, handleKeyUp);

  center.off('slider-set', onSliderSet);
};

},{"../live":210,"../spotify-elements":251,"./center":262}],324:[function(require,module,exports){
'use strict';

const live = require('../live');
const center = require('./center');
const sortUriUtils = require('../live-sort-uri');
const liburi = require('spotify-liburi');
const UIInteraction5 = require('../logger/messages/UIInteraction5');
const $ = require('../spotify-elements');

const ASC = 'tl-sort-asc';
const DESC = 'tl-sort-desc';

const setClassNames = function (list, optQuery, optDirection) {
  const uri = list.data('uri');
  const query = optQuery !== undefined ? optQuery : sortUriUtils.getQuery(uri);
  const direction = optDirection !== undefined ? optDirection : sortUriUtils.getDirection(uri);
  const headers = list.search('[data-sort]');
  if (!headers) {
    return;
  }

  for (let i = 0; i < headers.length; i++) {
    const header = $(headers[i]);
    header.removeClass(`${ASC} ${DESC}`);
    if (header.data('sort') === query) {
      header.addClass(direction === 'asc' ? ASC : DESC);
    }
  }
};

const handleSort = function (event, node) {
  const listNode = node.parent('[data-list]');
  if (!listNode) return;

  const uri = listNode.data('uri');
  if (!uri) return;

  const queryCurrent = sortUriUtils.getQuery(uri);
  const directionCurrent = sortUriUtils.getDirection(uri);

  let query = node.data('sort');

  const reverse = directionCurrent === 'asc' ? 'desc' : 'asc';
  let direction = queryCurrent === query ? reverse : 'asc';
  const reset = queryCurrent === query && directionCurrent === 'desc';

  const origin = sortUriUtils.getOriginUri(uri) || uri;

  let nextUri;
  if (reset) {
    nextUri = origin;
    query = null;
    direction = null;
  } else {
    nextUri = sortUriUtils.create(origin, direction, query);
  }

  // The first time a live model for the sorted URI is created, the sortlist
  // model will set up the sorting queries based on the URI.
  const nextList = live(nextUri);

  // We then need to trigger the sort to happen by asking for rows
  // The app itself will most likely request rows anyway, but by doing it
  // early might make it slightly faster.
  nextList.get('rows', function () {});

  const player = live('spotify:player');
  player.get('variant', 'context', function (error, variant, context) {
    if (error) throw error;
    if (variant && variant.get('uri') === uri) {
      if (liburi.from(context.get('uri')).type !== liburi.Type.SHOW) {
        player.emit('update-context', {
          context: nextUri
        });
      }
    }
  });

  setClassNames(listNode, query, direction);

  center.emit('sort-header-click', {
    uri: origin,
    requested: {
      query: query || null,
      direction: direction || null
    },
    current: {
      query: queryCurrent || null,
      direction: directionCurrent || null
    }
  });

  center.emit('list-swap', { before: uri, after: nextUri });

  UIInteraction5.log({
    pageuri: live('spotify:application').get('appURI') || 'unknown',
    feature_id: 'zlink',
    section_id: 'sort-header',
    target_uri: nextUri,
    interaction_type: 'hit',
    user_intent: 'sort',
    timestamp: Math.round(Date.now() / 1000)
  });
};

const handlePreviousProxyClick = function (event, node) {
  handleSort(null, node.previousSibling());
};

let isAttached = false;

exports.update = function (node) {
  if (!isAttached) return;

  const newNode = $(node) || $(document);

  const lists = newNode.matches('[data-list]') ? [newNode] : newNode.search('[data-list]');
  if (!lists) return;

  for (let i = 0; i < lists.length; i++) {
    const list = $(lists[i]);
    const headers = list.search('[data-sort]');
    if (!headers) {
      continue;
    }
    setClassNames(list);
  }
};

exports.attach = function attach() {
  if (isAttached) return;
  isAttached = true;

  $(document).delegate('click', '[data-sort]', handleSort);
  $(document).delegate('click', '[data-sort-previous]', handlePreviousProxyClick);
};

exports.detach = function detach() {
  if (!isAttached) return;
  isAttached = false;

  $(document).undelegate('click', '[data-sort]', handleSort);
  $(document).undelegate('click', '[data-sort-previous]', handlePreviousProxyClick);
};

},{"../live":210,"../live-sort-uri":208,"../logger/messages/UIInteraction5":222,"../spotify-elements":251,"./center":262,"spotify-liburi":730}],325:[function(require,module,exports){
(function (global){
'use strict';

var _frameUpdater = require('../frame-updater');

const center = require('./center');
const sort = require('./sort');

const DEFAULT_STICKY_CLASS_NAME = 'sticky-top';

let isAttached = false;
let scrollListenerId = 0;
let nodesGBCR = null;
let rootGBCR = null;
let timestamp;
let lastTotalStickyHeight = 0;
let isDragScrolling = false;
let dragScrollingSpeed = 0;

let scrollTopOffset = 0;
let currentScrollX = 0;
let currentScrollY = 0;
let rects = null;
let scrollNode = null;

const getStickyClassName = function (stickyNode) {
  const root = document.documentElement;
  let classSticky;
  let node;

  for (node = stickyNode; node !== root; node = node.parentNode) {
    classSticky = node.getAttribute('data-class-sticky');

    if (classSticky) {
      return classSticky;
    }
  }

  return DEFAULT_STICKY_CLASS_NAME;
};

const getRects = function (ttl) {
  const reference = timestamp + ttl;
  const nodes = document.querySelectorAll('[data-sticky]');

  // Refresh timestamp (always).
  timestamp = Date.now();

  // If the reference time is still valid, and nodes are the same, then return data.
  if (reference > timestamp && nodesGBCR && nodes.length === nodesGBCR.length) {
    let equal = true;

    for (let i = 0; i < nodes.length; i++) {
      equal = equal && nodes[i] === nodesGBCR[i].node;
    }

    if (equal) {
      return {
        nodes: nodesGBCR,
        root: rootGBCR
      };
    }
  }

  // Otherwise, compute and cache.
  if (scrollNode === document) {
    rootGBCR = document.documentElement.getBoundingClientRect();
  } else {
    rootGBCR = scrollNode.getBoundingClientRect();
    rootGBCR = {
      top: rootGBCR.top - currentScrollY,
      right: rootGBCR.right,
      bottom: rootGBCR.bottom,
      left: rootGBCR.left,
      width: rootGBCR.width,
      height: rootGBCR.height
    };
  }
  nodesGBCR = Array.prototype.map.call(document.querySelectorAll('[data-sticky]'), function (node) {
    const parentRect = node.parentNode.getBoundingClientRect();
    const nodeRect = node.getBoundingClientRect();

    // Return a structure per node. Only some fields are stored in the rect object (the ones used).
    return {
      stickyClassName: getStickyClassName(node),
      node: node,
      rect: {
        top: parentRect.top,
        height: nodeRect.height,
        left: parentRect.left,
        right: parentRect.right
      }
    };
  });

  return {
    nodes: nodesGBCR,
    root: rootGBCR
  };
};

const removeClone = function (node) {
  const stickyClone = node.stickyClone;

  if (stickyClone.parentNode) {
    stickyClone.parentNode.removeChild(stickyClone);
  }

  if (node.stickyListSwapListener) {
    center.off('list-swap', node.stickyListSwapListener);
  }

  node.style.removeProperty('visibility');

  delete node.stickyClone;
  delete node.stickyListSwapListener;
};

const resetSticky = function (node) {
  // <THEAD>s can't be made sticky, so verify if we are using a clone and remove it from the DOM.
  if (node.nodeName.toLowerCase() === 'thead' && node.stickyClone) {
    removeClone(node);
  }

  node.classList.remove(getStickyClassName(node));

  const headerNode = node.closest('[data-glue-page-header]');
  if (headerNode) {
    headerNode.classList.remove('glue-page-header--with-active-sticky-header');
    if (global.onPageHeaderToggleStickyMode) {
      global.onPageHeaderToggleStickyMode(false);
    }
  }

  // Update styles accordingly.
  node.removeAttribute('data-sticky-active', '');
  node.style.right = '';
  node.style.left = '';
  node.style.position = '';
  node.style.top = '';
};

const resetOldStickies = function () {
  const selector = '[data-sticky-active]:not([data-sticky])';
  const nodes = document.querySelectorAll(selector);
  for (let i = 0, l = nodes.length; i < l; i++) {
    if (!nodes[i].isStickyClone) {
      resetSticky(nodes[i]);
    }
  }
};

const readValuesWithTTL = function (ttl) {
  const node = scrollNode === document ? document.documentElement : scrollNode;
  const topBarHeight = node.getAttribute('data-top-bar-height');
  scrollTopOffset = parseInt(topBarHeight, 10) || 0;

  currentScrollY = scrollNode === document ? window.scrollY : scrollNode.scrollTop;

  rects = getRects(ttl);
};

const createClone = function (node) {
  const div = document.createElement('div');
  const thead = node.cloneNode(true);
  const table = node.parentNode.cloneNode(false);

  table.appendChild(thead).removeAttribute('data-sticky');
  div.appendChild(table);
  div.className = 'sticky-clone';
  div.isStickyClone = true;

  const onListSwap = function (data) {
    const theadParentTable = thead.parentNode;
    const uri = theadParentTable && theadParentTable.getAttribute('data-uri');

    // Update the "data-uri" of the cloned table, and the sort state of the original one.
    if (uri) {
      theadParentTable.setAttribute('data-uri', data.after);
      sort.update(node.parentNode);
    }
  };

  center.on('list-swap', onListSwap);

  node.parentNode.parentNode.appendChild(div);
  node.style.visibility = 'hidden';
  node.stickyListSwapListener = onListSwap;
  node.stickyClone = div;

  return div;
};

const updateStickies = function () {
  const scrollTop = currentScrollY + scrollTopOffset;
  const width = rects.root.width;
  let top = rects.root.top;
  let height = scrollTopOffset;
  const stickyNodes = rects.nodes;

  resetOldStickies();

  // This is to reset the video header for P2S if no stickies are found in the
  // DOM. Not finding any stickies means if we previously had a sticky P2S
  // video, it should not be sticky anymore. If a sticky header node re-appears
  // in the DOM, the next update of sticky events will call out to the video
  // with the new value.
  if (stickyNodes.length === 0) {
    if (global.onPageHeaderToggleStickyMode) {
      global.onPageHeaderToggleStickyMode(false);
    }
  }

  stickyNodes.forEach(function (nodeInfo, i) {
    const node = nodeInfo.node;
    const rect = nodeInfo.rect;
    const stickyClone = node.stickyClone;
    const stickyClassName = nodeInfo.stickyClassName;
    let stickyNode = stickyClone || node;

    // Check if the node should be sticked or not (if true, it should be).
    if (rect.top - top < scrollTop) {
      const previousNodeInfo = stickyNodes[i - 1];
      if (previousNodeInfo) {
        const previousNode = previousNodeInfo.node;
        const previousRect = previousNodeInfo.rect;
        if (previousNode.hasAttribute('data-sticky-single') && previousNode.classList.contains(stickyClassName)) {
          // This is the position of the current node relative to the bottom
          // edge of the stickies.
          const currentTopToEdge = Math.abs(rect.top - rects.root.top - (scrollTop + height));

          if (currentTopToEdge < previousRect.height) {
            const previousTop = height - previousRect.height;
            const newPreviousTop = previousTop - currentTopToEdge;
            previousNode.style.top = `${newPreviousTop}px`;
            top -= currentTopToEdge;
            height -= currentTopToEdge;
          } else {
            // Unstick the sticky above if it's pushed past its original spot
            resetSticky(previousNode);
            top -= previousRect.height;
            height -= previousRect.height;
          }
        }
      }

      // Offset the position by the offset of the root layer (an issue when a
      // custom scroll node is used).
      const left = rect.left - rects.root.left;
      const right = rect.right - rects.root.left;

      if (!stickyNode.classList.contains(stickyClassName)) {
        // <THEAD>s can't be made sticky, so we clone it and add it to the DOM.
        if (node.nodeName.toLowerCase() === 'thead' && !node.stickyClone) {
          stickyNode = createClone(node);
        }

        stickyNode.classList.add(stickyClassName);

        const headerNode = stickyNode.closest('[data-glue-page-header]');
        if (headerNode) {
          headerNode.classList.add('glue-page-header--with-active-sticky-header');
          if (global.onPageHeaderToggleStickyMode) {
            global.onPageHeaderToggleStickyMode(true);
          }
        }

        // Update styles accordingly.
        stickyNode.setAttribute('data-sticky-active', '');
        stickyNode.setAttribute('data-ta-id', 'sticky-node');
        stickyNode.style.right = `${width - right}px`;
        stickyNode.style.left = `${left}px`;
        stickyNode.style.position = 'fixed';
        stickyNode.style.top = `${height}px`;
      } else {
        stickyNode.style.right = `${width - right}px`;
        stickyNode.style.left = `${left}px`;
        stickyNode.style.top = `${height}px`;
      }

      // Increment the top reference and the height. Do it even if the element is already sticked.
      height += rect.height;
      top += rect.height;
    } else {
      if (stickyNode.classList.contains(stickyClassName)) {
        resetSticky(node);
      }
    }
  });

  lastTotalStickyHeight = height;
};

const handleResize = function () {
  readValuesWithTTL(0);
  updateStickies();
};

const dragScrollingTick = function () {
  if (isDragScrolling && currentScrollY > 0) {
    (0, _frameUpdater.requestFrame)(() => {
      currentScrollX = window.scrollX;
      currentScrollY = window.scrollY;
    }, () => {
      dragScrollingTick();
    });

    window.scrollTo(currentScrollX, currentScrollY - dragScrollingSpeed);
  }
};

const onPointerDragMove = function (event) {
  const distanceFromContentEdge = event.clientY - lastTotalStickyHeight;
  const scrollEdgeThickness = 20;
  const isBelowContentEdge = distanceFromContentEdge > 0;
  const isAboveScrollEdge = distanceFromContentEdge < scrollEdgeThickness;

  if (isBelowContentEdge && isAboveScrollEdge) {
    const speedFactor = (scrollEdgeThickness - Math.max(0, distanceFromContentEdge)) / scrollEdgeThickness;
    dragScrollingSpeed = speedFactor * 20;

    if (!isDragScrolling) {
      isDragScrolling = true;
      dragScrollingTick();
    }
  } else {
    isDragScrolling = false;
  }
};

const onPointerDragEnd = function () {
  isDragScrolling = false;

  document.removeEventListener('dragover', onPointerDragMove);
  document.removeEventListener('dragend', onPointerDragEnd);
  document.removeEventListener('mouseup', onPointerDragEnd);
};

const handleMouseDown = function () {
  document.addEventListener('dragover', onPointerDragMove);
  document.addEventListener('dragend', onPointerDragEnd);

  // Ideally we shouldn't need `mouseup`, but for some reason `dragend` is not
  // being triggered while scrolling. We can also not solely use mouseup, since
  // that is only triggered when releasing the pointer inside the iframe.
  document.addEventListener('mouseup', onPointerDragEnd);
};

exports.DEFAULT_STICKY_CLASS_NAME = DEFAULT_STICKY_CLASS_NAME;

exports.attach = function attach() {
  if (!isAttached) {
    isAttached = true;

    if (!scrollNode) {
      scrollNode = document;
    }

    scrollListenerId = (0, _frameUpdater.addDebouncedScrollListener)(scrollNode, () => {
      readValuesWithTTL(4000);
    }, () => {
      updateStickies();
    });

    window.addEventListener('resize', handleResize);
    document.addEventListener('mousedown', handleMouseDown);
    if (global.top && global.top.document) {
      // Register mousedown events from top document to catch cases when
      // drag was initiated from top document (ex. dragging track from now playing
      // to playlist)
      global.top.document.addEventListener('mousedown', handleMouseDown);
    }
  }
};

exports.detach = function detach() {
  if (isAttached) {
    isAttached = false;

    (0, _frameUpdater.removeDebouncedScrollListener)(scrollListenerId);
    window.removeEventListener('resize', handleResize);
    document.removeEventListener('mousedown', handleMouseDown);
    if (global.top && global.top.document) {
      global.top.document.removeEventListener('mousedown', handleMouseDown);
    }

    nodesGBCR = null;
    rootGBCR = null;
    lastTotalStickyHeight = 0;
    isDragScrolling = false;
    dragScrollingSpeed = 0;
    scrollNode = null;
  }
};

exports.update = function () {
  if (isAttached) {
    nodesGBCR = null;
    rootGBCR = null;

    readValuesWithTTL(4000);
    updateStickies();
  }
};

// A way to let an app override the node to listen for scroll events on.
// This has to be called before `attach` is called.
exports.setScrollNode = function setScrollNode(node) {
  scrollNode = node;
};

exports._getStickyClassName = getStickyClassName;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../frame-updater":93,"./center":262,"./sort":324}],326:[function(require,module,exports){
'use strict';

const $ = require('../spotify-elements');
const live = require('../live');
const dom = require('./util/dom');

const SELECTOR_THUMBS_DOWN_BUTTON = '[data-button=thumbs-down]';
const SELECTOR_THUMBS_UP_BUTTON = '[data-button=thumbs-up]';

/**
 * Handle the click on a Thumbs button.
 *
 * @param {MouseEvent} event An event object for a click event.
 * @param {HTMLElement} button A button DOM node.
 *
 * @private
 */
function handleThumbsButtonClick(event, button) {
  const type = dom.getAttributeFromNodeOrParent(button[0], 'data-button');
  const trackUri = dom.getAttributeFromNodeOrParent(button[0], 'data-uri');
  const contextUri = dom.getContextFromNodeOrParent(button[0]);

  // Must use track uri
  if (!trackUri || !contextUri) return;

  // Emit thumb event on context
  if (type === 'thumbs-down') {
    live(contextUri).emit('thumb-down', trackUri);
  } else if (type === 'thumbs-up') {
    live(contextUri).emit('thumb-up', trackUri);
  }
}

let isAttached = false;

/**
 * Attach the event listeners for the module.
 * Part of the spotify-events interface.
 */
exports.attach = function () {
  if (isAttached) return;
  isAttached = true;

  const doc = $(document);
  doc.delegate('click', SELECTOR_THUMBS_DOWN_BUTTON, handleThumbsButtonClick);
  doc.delegate('click', SELECTOR_THUMBS_UP_BUTTON, handleThumbsButtonClick);
};

/**
 * Detach the event listeners for the module.
 * Part of the spotify-events interface.
 */
exports.detach = function () {
  if (!isAttached) return;
  isAttached = false;

  const doc = $(document);
  doc.undelegate('click', SELECTOR_THUMBS_DOWN_BUTTON, handleThumbsButtonClick);
  doc.undelegate('click', SELECTOR_THUMBS_UP_BUTTON, handleThumbsButtonClick);
};

exports.update = function () {};

},{"../live":210,"../spotify-elements":251,"./util/dom":332}],327:[function(require,module,exports){
'use strict';

const $ = require('../spotify-elements');

const tooltipMargin = 8; // We want some spacing around the tooltip

const tooltipNode = document.createElement('div');
tooltipNode.id = 'tooltip';

const tooltipTextNode = document.createElement('span');

const tooltipArrowTop = document.createElement('div');
tooltipArrowTop.className = 'tooltip-arrow-top';

const tooltipArrowBottom = document.createElement('div');
tooltipArrowBottom.className = 'tooltip-arrow-bottom';

tooltipNode.appendChild(tooltipArrowTop);
tooltipNode.appendChild(tooltipArrowBottom);
tooltipNode.appendChild(tooltipTextNode);

let attachedNode = null;
let tooltipContainer = null;

// tooltipArrow will point to the current visible tooltipArrow
// that can be either tooltipArrowTop or tooltipArrowBottom
let tooltipArrow = null;

const addTooltipToDOM = function (container) {
  tooltipContainer = container;
  tooltipContainer.appendChild(tooltipNode);
};

const removeTooltipFromDOM = function () {
  attachedNode = null;
  if (tooltipNode.parentNode) {
    tooltipContainer.removeChild(tooltipNode);
  }

  tooltipContainer = null;
};

const getTooltipContainer = function (node) {
  const containerSelector = node.getAttribute('data-tooltip-container');
  let containerNode;

  if (containerSelector) {
    containerNode = document.querySelector(containerSelector);
  }

  return containerNode || document.body;
};

const setText = function (text) {
  tooltipTextNode.innerHTML = text;
};

const showTooltip = function (event, node) {
  const realNode = node[0];
  let top = 0;
  let left = 0;

  const tooltipText = node.data('tooltip') || node.getAttribute('title');
  if (!tooltipText) return;

  // Remember the node we set the text from so that text can be updated.
  attachedNode = node;

  if (!node.tooltipCheck) {
    node.removeAttribute('title');
    node.setAttribute('data-tooltip', tooltipText);
    node.tooltipCheck = true;
  }

  const container = getTooltipContainer(node);
  if (!tooltipContainer || container !== tooltipContainer) {
    addTooltipToDOM(container);
  }

  setText(tooltipText);

  const tooltipHeight = tooltipNode.clientHeight;
  const tooltipWidth = tooltipNode.offsetWidth;

  // Don't use window.scrollY because cross browser issues.
  // https://developer.mozilla.org/en-US/docs/Web/API/Window.scrollY
  const scrollY = window.pageYOffset;

  const bounds = realNode.getBoundingClientRect();
  const targetHeight = realNode.offsetHeight;
  const targetWidth = realNode.offsetWidth;
  const targetTop = parseInt(bounds.top, 10) + scrollY;
  const targetLeft = parseInt(bounds.left, 10);
  const targetCenter = targetLeft + targetWidth / 2;
  const targetBottom = targetTop + targetHeight;
  const viewportWidth = document.documentElement.clientWidth;
  const viewportHeight = document.documentElement.clientHeight;

  // Decide if the tooltip should be over or under the node
  if (targetBottom + tooltipHeight + tooltipMargin - scrollY > viewportHeight) {
    // On top
    top = targetTop - tooltipHeight - tooltipMargin;
    tooltipArrowTop.classList.remove('visible');
    tooltipArrowBottom.classList.add('visible');
    tooltipArrow = tooltipArrowBottom;
  } else {
    top = targetTop + targetHeight + tooltipMargin;
    if (top - scrollY > viewportHeight) {
      top = viewportHeight - tooltipHeight;
    }
    tooltipArrowTop.classList.add('visible');
    tooltipArrowBottom.classList.remove('visible');
    tooltipArrow = tooltipArrowTop;
  }

  const distanceToTheRight = viewportWidth - tooltipMargin - targetCenter;
  const distanceToTheLeft = targetCenter - tooltipMargin;
  const tooltipOffsetRight = Math.max(0, tooltipWidth / 2 - distanceToTheRight);
  const tooltipOffsetLeft = Math.max(0, tooltipWidth / 2 - distanceToTheLeft);

  left = targetCenter - tooltipWidth / 2 - (tooltipOffsetRight || -tooltipOffsetLeft);

  tooltipNode.style.top = `${top}px`;
  tooltipNode.style.left = `${left}px`;
  tooltipArrow.style.left = `${targetCenter - left}px`;

  if (node.hasAttribute('data-tooltip-instant')) {
    tooltipNode.classList.add('instant');
  } else {
    tooltipNode.classList.remove('instant');
  }

  tooltipNode.classList.add('visible');
};

const hideTooltip = function () {
  if (!attachedNode) {
    return;
  }
  attachedNode = null;
  setText('');
  tooltipNode.classList.remove('visible');
  tooltipNode.style.left = 0;
  tooltipNode.style.top = 0;
  if (tooltipArrow) {
    tooltipArrow.style.left = 0;
  }
};

let isAttached = false;

exports.attach = function attach() {
  if (isAttached) return;
  isAttached = true;

  const doc = $(document);
  doc.delegate('mouseover', '[data-tooltip]', showTooltip);
  doc.delegate('mouseout', '[data-tooltip]', hideTooltip);
  doc.on('keydown', hideTooltip);
  doc.on('mousedown', hideTooltip);
};

exports.detach = function detach() {
  if (!isAttached) return;
  isAttached = false;

  removeTooltipFromDOM();
  const doc = $(document);
  doc.undelegate('mouseover', '[data-tooltip]', showTooltip);
  doc.undelegate('mouseout', '[data-tooltip]', hideTooltip);
  doc.off('keydown', hideTooltip);
  doc.off('mousedown', hideTooltip);
};

/** Forces an update of the tooltip text. */
exports.update = function update() {
  if (!isAttached) return;

  if (!attachedNode) return;

  if (attachedNode.data('tooltip')) {
    showTooltip(null, attachedNode);
  } else {
    // The tooltip no longer has text and should be hidden.
    hideTooltip();
  }
};

// Export for testing purposes
exports._setText = setText;

},{"../spotify-elements":251}],328:[function(require,module,exports){
'use strict';

const prime = require('../../../libs/prime');
const Emitter = require('../../../libs/prime/emitter');
const Range = require('../../range2');

const SYNC = Emitter.EMIT_SYNC;

module.exports = prime({
  mixin: Emitter,

  constructor: function (container, params) {
    this.container = container;

    this.height = params.height || 0;
    this.length = params.length || 0;

    this.tag = params.tag || 'li';
    this.request = params.request;

    // Unique call identificator.
    this._id = 0;

    this.reset();
  },

  resetFrom: function (fromIndex, length, hiddenIndices) {
    const range = this._range;

    // Redirect the call to reset.
    if (fromIndex < range.end) {
      this.reset(length, hiddenIndices);
      this.show(range);
    }
  },

  reset: function (length, hiddenIndices) {
    const tag = this.tag;

    if (typeof length !== 'undefined') {
      this.length = length;
    }

    const totalHeight = this.length * this.height;

    // Hidden indices are not supported anymore (legacy).
    if (hiddenIndices) {
      throw new TypeError('Hidden indices are not supported anymore!');
    }

    this.container.innerHTML = `<${tag} style="height:${totalHeight}px"></${tag}>` + `<${tag} style="height:0px"></${tag}>`;

    this._range = new Range(0, 0);
    this._waitingRange = new Range(0, 0);

    // An array of ranges representing the visible nodes.
    this.emit('index-change', [], SYNC);
  },

  show: function (range) {
    const length = this.length;
    const actual = this._range;
    const waiting = this._waitingRange;

    // Limit range to the [0, length) interval.
    const bound = new Range(Math.max(0, range.start), Math.min(length, range.end));

    // If the range requested is the same, do nothing.
    if (bound.start === actual.start && bound.end === actual.end) {
      return;
    }

    // If the range requested is the same, do nothing.
    if (bound.start === waiting.start && bound.end === waiting.end) {
      return;
    }

    this._drawRange(bound);
  },

  _drawRange: function (range) {
    const container = this.container;
    const oldRange = this._range;
    const height = this.height;
    const length = this.length;
    const id = ++this._id;

    this._waitingRange = range;

    // Request the whole range. We will manually intersect later with the current one.
    this.request(range, (err, nodes) => {
      let diff = 0;
      let i;

      // If a new range has been requested in the meantime, don't draw/modify anything.
      if (id !== this._id) {
        return;
      }

      // Cache the range requested.
      this._range = range;
      this._waitingRange = new Range(0, 0);

      // Get first and last nodes as references. We will use them for removing/adding nodes.
      const first = container.firstChild;
      const last = container.lastChild;

      // Change heights of the paddings.
      first.style.height = `${range.start * height}px`;
      last.style.height = `${(length - range.end) * height}px`;

      // Remove old nodes. Since nodes change their position when removing them one by one,
      // we have to keep the cumulative sum of nodes removed cached.
      oldRange.subtract(range).forEach(function (subrange) {
        const subrangeLength = subrange.length;

        for (i = 0; i < subrangeLength; i++) {
          // We add one to the children index because the first child is not a row but the top padding.
          container.removeChild(container.children[subrange.start - oldRange.start - diff + 1]);
        }

        diff += subrangeLength;
      });

      // Add new nodes. If the new nodes are below the old range, insert them at the top;
      // otherwise, insert them at the bottom.
      range.subtract(oldRange).forEach(subrange => {
        const subrangeLength = subrange.length;
        const start = subrange.start - range.start;
        const subnodes = nodes.slice(start, start + subrangeLength);
        let ref;

        // Emit a change before.
        this.emit('before-show', subrange, subnodes, SYNC);

        // Get the reference node. If the range is below, then insert at the top.
        // Otherwise, insert at the bottom.
        if (subrange.below(oldRange)) {
          ref = first.nextSibling;
        } else {
          ref = last;
        }

        for (i = 0; i < subrangeLength; i++) {
          container.insertBefore(subnodes[i], ref);
        }

        // Emit a change after.
        this.emit('after-show', subrange, subnodes, SYNC);
      });

      this.emit('index-change', [range], SYNC);
    });
  }
});

},{"../../../libs/prime":243,"../../../libs/prime/emitter":242,"../../range2":245}],329:[function(require,module,exports){
'use strict';

const Position = function (containerIndex, index) {
  this.containerIndex = containerIndex;
  this.index = index;
};

Position.prototype.isSame = function (position) {
  return this.containerIndex === position.containerIndex && this.index === position.index;
};

module.exports = Position;

},{}],330:[function(require,module,exports){
'use strict';

const live = require('../../live');

function checkIfActive() {
  return live('spotify:application').get('active') || false;
}

function checkIfFocused() {
  // If the active element of the top frame has a contentWindow that matches
  // this window, it means the iframe of this app is in focus.
  const topActiveElement = window.top.document.activeElement;
  const activeWindow = topActiveElement && topActiveElement.contentWindow;
  if (activeWindow) {
    return activeWindow === window;
  }

  // Top frame (zlink)
  if (window.top === window) {
    return true;
  }

  return false;
}

exports.isActive = function () {
  return checkIfActive();
};

exports.isActiveAndFocused = function () {
  return checkIfActive() && checkIfFocused();
};

},{"../../live":210}],331:[function(require,module,exports){
/**
 * @module spotify-events/util/cosmos
 * @private
 */

'use strict';

const live = require('../../live');
const cosmos = require('spotify-cosmos-api');
const liburi = require('spotify-liburi');

const ASAP = live.ASAP;

function DELETE(options, callback) {
  options.method = exports.cosmos.Action.DELETE;
  return request(options, callback);
}

function GET(options, callback) {
  options.method = exports.cosmos.Action.GET;
  return request(options, callback);
}

function SUB(options, callback) {
  options.method = exports.cosmos.Action.SUB;
  return request(options, callback);
}

function POST(options, callback) {
  options.method = exports.cosmos.Action.POST;
  return request(options, callback);
}

function PUT(options, callback) {
  options.method = exports.cosmos.Action.PUT;
  return request(options, callback);
}

function HEAD(options, callback) {
  options.method = exports.cosmos.Action.HEAD;
  return request(options, callback);
}

function request(options, callback) {
  const method = options.method;
  delete options.method;

  let subscription;
  let canceled;

  sanitizeURL(options.url, function (error, url) {
    if (error) {
      callback(error);
      return;
    }

    // if you cancel before the userName is replaced.
    if (canceled) return;

    const cosmosRequest = new exports.cosmos.Request(method || exports.cosmos.Action.GET, url, options.headers, options.body);
    subscription = exports.cosmos.resolver.resolve(cosmosRequest, function (cosmosError, response) {
      if (!callback) return;
      if (cosmosError) {
        callback(cosmosError);
        return;
      }
      try {
        callback(null, {
          body: JSON.parse(response.getBody() || '{}'),
          headers: response.getHeaders(),
          status: response.getStatusCode()
        });
      } catch (parseError) {
        parseError.response = response;
        callback(parseError);
      }
    });
  });

  return {
    cancel: function () {
      if (subscription && subscription.cancel) {
        // we already subscribed, cancel it.
        subscription.cancel();
        subscription = null;
      } else if (!canceled) {
        // not subscribed yet, don't even subscribe.
        canceled = true;
      }
      return null;
    }
  };
}

function sanitizeURL(url, callback) {
  if (url.indexOf('@') > -1) {
    live('spotify:client').query('currentUser(username)', function (error, data) {
      if (error) {
        callback(error);
        return;
      }
      callback(null, url.replace('@', liburi.getCanonicalUsername(data.currentUser.username)));
    }, ASAP);
  } else {
    callback(null, url);
  }
}

exports.request = request;
exports.get = GET;
exports.post = POST;
exports.subscribe = SUB;
exports.delete = DELETE;
exports.put = PUT;
exports.head = HEAD;
exports.cosmos = cosmos;

exports.sanitizeURL = sanitizeURL;

},{"../../live":210,"spotify-cosmos-api":720,"spotify-liburi":730}],332:[function(require,module,exports){
'use strict';

/**
 * @public
 */

/**
 * Get the context URI from the specified node or its parents.
 *
 * @param {HTMLElement} node A DOM node.
 *
 * @return {string} The context URI or empty string if not found.
 */

function getContextFromNodeOrParent(node) {
  const contextNode = node.closest('[data-context]');
  return contextNode && contextNode.getAttribute('data-uri') || '';
}

/**
 * Get the value for the passed attribute name, either from the passed node
 * or from any parent node.
 *
 * @param {HTMLElement} node The node to start searching from.
 * @param {string} attributeName The name of the attribute.
 *
 * @return {string} The value, or empty string if not found.
 */
function getAttributeFromNodeOrParent(node, attributeName) {
  const selector = `[${attributeName}]`;
  const attributeNode = node.closest(selector);
  return attributeNode && attributeNode.getAttribute(attributeName) || '';
}

exports.getContextFromNodeOrParent = getContextFromNodeOrParent;
exports.getAttributeFromNodeOrParent = getAttributeFromNodeOrParent;

},{}],333:[function(require,module,exports){
'use strict';

module.exports = function getLogContext(target) {
  let currentNode = target;
  const logContext = [];
  while (currentNode) {
    if (currentNode.matches && currentNode.matches('[data-log-context]')) {
      logContext.unshift(currentNode.getAttribute('data-log-context'));
    }
    currentNode = currentNode.parentNode;
  }
  return logContext.join('/') || null;
};

},{}],334:[function(require,module,exports){
'use strict';

const rAF = window.requestAnimationFrame || function (fn) {
  setTimeout(fn, 16);
};

/**
 * Throttle the function calls to only trigger once per tick.
 * This will return a new function that you will use when you want
 * to call your function. Calling it multiple times in the same
 * run loop will only really call it once.
 *
 * @param {function} fn A function.
 * @param {Object=} ctx The context to run the function in ('this').
 *
 * @return {function} A new function.
 */
function throttle(fn, ctx) {
  let queued = false;
  let args;

  return function () {
    args = arguments;
    if (!queued) {
      queued = true;
      rAF(function () {
        queued = false;
        fn.apply(ctx, args);
      });
    }
  };
}

module.exports = throttle;

},{}],335:[function(require,module,exports){
'use strict';

// Usage
// Data {{#compare 'myvalue' value}}has{{else}}doesn't have{{/compare}} myvalue.
// Data {{#compare '5' tracks.length true}}has{{else}}doesn't have{{/compare}} 5 tracks.
// Data {{#compare tracks.length 5 operator='>'}}has more than{{else}}has less than or equal to{{/compare}} 5 tracks.

const operators = {
  '==': function (a, b) {
    /* eslint eqeqeq: 0 */return a == b;
  },
  '===': function (a, b) {
    return a === b;
  },
  '!=': function (a, b) {
    /* eslint eqeqeq: 0 */return a != b;
  },
  '<': function (a, b) {
    return a < b;
  },
  '>': function (a, b) {
    return a > b;
  },
  '<=': function (a, b) {
    return a <= b;
  },
  '>=': function (a, b) {
    return a >= b;
  },
  'typeof': function (a, b) {
    return typeof a == b;
  }
};

function compare(a, b, s) {
  const options = arguments[arguments.length - 1];
  const soft = s !== options ? s : false;
  const operator = soft ? '==' : options.hash.operator || '===';

  const match = operators[operator](a, b);

  return match ? options.fn(this) : options.inverse(this);
}

compare.displayName = 'compare';

module.exports = compare;

},{}],336:[function(require,module,exports){
'use strict';

const duration = function (ms) {
  if (isNaN(ms)) return ms;

  const s = Math.round(ms / 1000);
  const oneMinute = 60;
  const oneHour = 60 * oneMinute;

  let hours = Math.floor(s / oneHour);
  let minutes = Math.floor(s % oneHour / oneMinute);
  let seconds = Math.round(s % oneHour % oneMinute);

  // Include hours if needed
  if (hours) {
    hours += ':';

    // If hours are specified, minutes should always be with two digits
    if (minutes < 10) minutes = `0${minutes}`;
  } else {
    hours = '';
  }

  // Since minutes should always be displayed, seconds should always be with two digits
  if (seconds < 10) seconds = `0${seconds}`;

  return `${hours + minutes}:${seconds}`;
};

duration.displayName = 'duration';

module.exports = duration;

},{}],337:[function(require,module,exports){
'use strict';

const nameListTooltip = require('./name-list-tooltip');

const facepile = function (list, options) {
  if (!list) {
    return '';
  }

  const len = list.length;
  const thresh = Math.min(3, len);
  let ret = '';

  // Display faces.
  for (let i = 0; i < thresh; i++) {
    const obj = list[i];
    ret += options.fn(obj);
  }

  // Display badge count for hidden faces.
  if (len > thresh) {
    ret += options.inverse({
      badgeCount: len - thresh,
      badgeTooltip: nameListTooltip(list.slice(thresh), len - thresh)
    });
  }
  return ret;
};

facepile.displayName = 'facepile';

module.exports = facepile;

},{"./name-list-tooltip":344}],338:[function(require,module,exports){
(function (global){
'use strict';

const getHTTPLink = require('../util/link');

const isDesktop = !!global._getSpotifyModule;

const href = function (uri) {
  if (isDesktop) return uri;
  return getHTTPLink(uri, 'https://play.spotify.com');
};

href.displayName = 'href';

module.exports = href;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../util/link":351}],339:[function(require,module,exports){
'use strict';

const loc = require('./loc');

const humanizeDuration = function (ms) {
  if (isNaN(ms)) return ms;

  const s = Math.round(ms / 1000);
  const oneMinute = 60;
  const oneHour = 60 * oneMinute;

  const hours = Math.floor(s / oneHour);
  const minutes = Math.floor(s % oneHour / oneMinute);
  const seconds = Math.round(s % oneHour % oneMinute);

  let formattedDuration = '';

  if (hours) {
    formattedDuration += loc('HoursShort', hours, {});
  }

  if (minutes) {
    formattedDuration += ' ';
    formattedDuration += loc('MinutesShort', minutes, {});
  }

  if (!hours && !minutes || hours === 0 && minutes < 10) {
    formattedDuration += ' ';
    formattedDuration += loc('SecondsShort', seconds, {});
  }

  return formattedDuration.trim();
};

humanizeDuration.displayName = 'humanizeDuration';

module.exports = humanizeDuration;

},{"./loc":343}],340:[function(require,module,exports){
'use strict';

exports.compare = require('./compare');
exports.duration = require('./duration');
exports.facepile = require('./facepile');
exports.href = require('./href');
exports.humanizeDuration = require('./humanize-duration');
exports.list = require('./list');
exports.loc = require('./loc');
exports.nameListTooltip = require('./name-list-tooltip');
exports.numeral = require('./numeral');
exports.share = require('./share');
exports.slice = require('./slice');
exports.type = require('./type');
exports.userReaction = require('./user-reaction');
exports.json = require('./json');

},{"./compare":335,"./duration":336,"./facepile":337,"./href":338,"./humanize-duration":339,"./json":341,"./list":342,"./loc":343,"./name-list-tooltip":344,"./numeral":345,"./share":346,"./slice":347,"./type":348,"./user-reaction":349}],341:[function(require,module,exports){
'use strict';

const json = function (context) {
  return JSON.stringify(context);
};

json.displayName = 'json';

module.exports = json;

},{}],342:[function(require,module,exports){
'use strict';

const map = require('mout/array/map');

const Handlebars = require('handlebars/dist/cjs/handlebars.runtime').default;

const lists = {};

const list = function (array) {
  if (!array) {
    return '';
  }

  const args = Array.prototype.slice.call(arguments);
  const options = args.pop();
  const listID = args[1];

  if (array === 'reset') {
    delete lists[listID];
    return '';
  }

  if (listID && lists[listID] === undefined) {
    lists[listID] = -1;
  }

  return map(array, function (item, i) {
    const data = Handlebars.createFrame(options.data || {});
    data.index = listID ? ++lists[listID] : i;
    data.number = data.index + 1;
    data.localIndex = i;
    data.localNumber = i + 1;
    return options.fn(item, { data: data });
  }).join(options.hash && options.hash.join || '');
};

list.displayName = 'list';

module.exports = list;

},{"handlebars/dist/cjs/handlebars.runtime":410,"mout/array/map":451}],343:[function(require,module,exports){
'use strict';

var _mixIn = require('mout/object/mixIn');

var _mixIn2 = _interopRequireDefault(_mixIn);

var _pickString = require('../../spotify-i18n/src/pick-string');

var _pickString2 = _interopRequireDefault(_pickString);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const slice_ = Array.prototype.slice;

let locale = 'en';
let numberFormat = new Intl.NumberFormat(locale);
const storage = {};

const loc = function (key) {
  let args = slice_.call(arguments, 1);
  let options = {};

  const lastArg = args[args.length - 1];
  if (typeof lastArg === 'object' && 'hash' in lastArg) {
    options = args.pop();
  }

  const hash = options.hash;

  const value = (0, _pickString2.default)({ [locale]: storage }, locale, key, args[0]);
  if (!value) return '';

  // If we are passed an array, use that for replacements
  if (Array.isArray(args[0])) {
    args = args[0];
  }

  return value.replace(/\{([\w-]+)\}/g, function (full, match) {
    const n = +match;
    let interpolated;

    if (isNaN(n)) {
      interpolated = hash[match];
    } else {
      interpolated = args[n];
    }

    if (typeof interpolated === 'number') {
      interpolated = numberFormat.format(interpolated);
    }

    return interpolated !== null ? interpolated : '';
  });
};

loc.displayName = 'loc';

loc.register = function (object) {
  (0, _mixIn2.default)(storage, object);
  return this;
};

loc.setLocale = function (newLocale) {
  locale = newLocale;
  numberFormat = new Intl.NumberFormat(locale);
};

module.exports = loc;

},{"../../spotify-i18n/src/pick-string":355,"mout/object/mixIn":480}],344:[function(require,module,exports){
'use strict';

const loc = require('./loc');

const nameListTooltip = function (users, totalCount) {
  if (totalCount === 0) {
    return undefined;
  }

  const len = users.length;
  const textTokens = users.map(function (user) {
    return user.name;
  });

  if (totalCount - len > 0) {
    const andMoreText = loc('AndMore', totalCount - len);
    textTokens.push(andMoreText);
  }

  return textTokens.join('<br>\n').replace(/'/g, '&#39;');
};

nameListTooltip.displayName = 'nameListTooltip';

module.exports = nameListTooltip;

},{"./loc":343}],345:[function(require,module,exports){
'use strict';

const isNumber = require('mout/lang/isNumber');

/**
 * If the first argument is a number, pipe it through spotify-numeral with an
 * optional format propety in the options hash, otherwise return it untouched.
 *
 * Example usage – results when using fr locale:
 *
 * {{numeral 1000}} -> '1 000'
 * {{numeral 1000 format='0,0.000'}} -> '1 000,000'
 * {{numeral 1000 format='$0,0.00'}} -> '€1 000,00'
 *
 * @param {Number|String} number - The number to format (or string to leave
 *     untouched).
 * @param {Object} [options] - The handlebars options object.
 * @param {Object} [options.hash] - The handlebars options hash object.
 * @param {String} [options.hash.format] - The optional format to pass to
 *     numeraljs.
 * @return {String} The formatted (or untouched) string.
 */
const numeralHelper = function (number, options) {
  const format = options && options.hash && options.hash.format;
  const numeral = numeralHelper._numeral;
  return isNumber(number) ? numeral(number).format(format) : number;
};

numeralHelper.displayName = 'numeral';

module.exports = numeralHelper;

// This is tricky, but is a way to allow for the locale to be injected
// from the consuming app instead of from within spotify-numeral, removing
// the dependency on spotify-quickstart.
module.exports.setLocale = function (locale) {
  numeralHelper._numeral = require('../../spotify-numeral')(locale);
};

},{"../../spotify-numeral":357,"mout/lang/isNumber":466}],346:[function(require,module,exports){
'use strict';

const getHTTPLink = require('../util/link');

const share = function (uri) {
  return getHTTPLink(uri, 'https://open.spotify.com');
};

share.displayName = 'share';

module.exports = share;

},{"../util/link":351}],347:[function(require,module,exports){
'use strict';

const kindOf = require('mout/lang/kindOf');
const map = require('mout/array/map');
const forEach = require('mout/array/forEach');

const Handlebars = require('handlebars/dist/cjs/handlebars.runtime').default;
const slice_ = Array.prototype.slice;

const slice = function (arr) {
  let array = arr;

  if (!array) {
    return '';
  }

  let sep;
  let begin;
  let end;
  let options;

  forEach(slice_.call(arguments, 1), function (arg) {
    switch (kindOf(arg)) {
      case 'String':
        sep = arg;
        break;

      case 'Number':
        if (begin === null) {
          begin = arg;
        } else if (end === null) {
          end = arg;
        }
        break;

      case 'Object':
        options = arg;
        break;

      default:
      // Do nothing.
    }
  });

  if (begin !== null) {
    array = array.slice(begin, end !== null ? end : array.length);
  }

  return map(array, function (item, index) {
    const data = Handlebars.createFrame(options.data || {});
    data.index = index;

    return options.fn(item, { data: data });
  }).join(sep || '');
};

slice.displayName = 'slice';

module.exports = slice;

},{"handlebars/dist/cjs/handlebars.runtime":410,"mout/array/forEach":448,"mout/array/map":451,"mout/lang/kindOf":470}],348:[function(require,module,exports){
'use strict';

const getType = require('../util/type');

// This needs at least the uri param to get the type:
// {{type uri}}
//
// If you pass more parameters you can use it like a matcher:
// {{#type uri "track" "album"}}YAY{{/type}}
// This will print 'YAY' for tracks or albums.

const type = function (uri) {
  if (arguments.length <= 2) {
    // Simple get type.
    return getType(uri);
  }

  // Match type.
  const context = arguments[arguments.length - 1];
  let success = false;
  const uriType = getType(uri);

  for (let i = 1; i < arguments.length - 1; i++) {
    if (uriType === arguments[i]) {
      success = true;
      break;
    }
  }

  return success ? context.fn(this) : context.inverse(this);
};

type.displayName = 'type';

module.exports = type;

},{"../util/type":352}],349:[function(require,module,exports){
'use strict';

const loc = require('./loc');

const userReaction = function (users, totalCount, reactionType) {
  if (!totalCount) return '';
  const key = `${reactionType}Reaction${totalCount > 1 ? 'Multi' : 'Single'}`;

  if (totalCount > 1) {
    return loc(key, totalCount);
  }

  if (!users.length) {
    return '';
  }

  const firstListener = users[0].name;
  return loc(key, firstListener);
};

userReaction.displayName = 'userReaction';

module.exports = userReaction;

},{"./loc":343}],350:[function(require,module,exports){
'use strict';

const kindOf = require('mout/lang/kindOf');

const Handlebars = require('handlebars/dist/cjs/handlebars.runtime').default;

// Expose the runtime to make partials easier to register.
exports.runtime = Handlebars;

exports.register = function (helpers) {
  let list = {};

  if (kindOf(helpers) === 'Function') {
    list[helpers.displayName] = helpers;
  } else {
    list = helpers;
  }

  for (const key in list) {
    if (list.hasOwnProperty(key)) {
      Handlebars.registerHelper(key, list[key]);
    }
  }

  return this;
};

},{"handlebars/dist/cjs/handlebars.runtime":410,"mout/lang/kindOf":470}],351:[function(require,module,exports){
'use strict';

module.exports = function (uri, base) {
  const matches = (uri || '').match(/^spotify:(.+)$/);

  if (!matches) {
    return uri || '';
  }

  let parts = matches.pop().replace(/:$/, '').split(/:/);
  const type = parts.shift();

  if (type === 'search') {
    parts = [parts.join(':')];
  }

  parts.unshift(base, type);

  return parts.join('/');
};

},{}],352:[function(require,module,exports){
'use strict';

module.exports = function (uri) {
  if (!uri || !uri.split) {
    return null;
  }
  const parts = uri.split(':');
  const result = null;
  switch (parts[1]) {
    case 'album':
      // spotify:album:<id>:<disc>
      if (parts.length === 4) {
        return 'disc';
      } else if (parts.length === 3) {
        return 'album';
      }
      break;

    case 'artist':
      if (parts.length === 3) {
        return 'artist';
      }
      break;

    case 'track':
      if (parts.length === 3) {
        return 'track';
      }
      break;

    case 'genre':
      if (parts.length === 3) {
        return 'genre';
      }
      break;

    // spotify:show:<id>
    case 'show':
      if (parts.length === 3) {
        return 'show';
      }
      break;

    case 'station':
      if (parts.length > 3) {
        return 'station';
      }
      break;

    case 'episode':
      // spotify:episode:<id>
      if (parts.length === 3) {
        return 'episode';
      }
      break;

    case 'local':
      if (parts.length === 6) {
        return 'track';
      } else if (parts.length === 4) {
        return 'album';
      } else if (parts.length === 3) {
        return 'artist';
      }
      break;

    case 'user':
      // spotify:user:<username>:collection:album:<id>
      if (parts.length > 3 && parts[3] === 'collection' && parts[4] === 'album') {
        return 'collection-album';
      }
      // spotify:user:<username>:collection:artist:<id>
      if (parts.length > 3 && parts[3] === 'collection' && parts[4] === 'artist') {
        return 'collection-artist';
      }
      // spotify:user:<username>:collection
      if (parts.length > 3 && parts[3] === 'collection') {
        return 'collection';
      }

      // spotify:user:<username>:folder:<id>
      if (parts.length === 5 && parts[3] === 'folder') {
        return 'playlist-folder';
      }

      // spotify:user:<username>:cluster:<id>
      if (parts.length === 5 && parts[3] === 'cluster') {
        return 'cluster';
      }

      // spotify:user:<username>:<playlist:<id>|starred|toplist>
      if (parts.length > 3 && parts.length <= 5 && parts[2] !== 'facebook') {
        return 'playlist';
      } else if (parts.length === 3) {
        return 'user';
      }
      break;

    case 'internal':
      // spotify:internal:local-files
      return parts[2];

    case 'app':
      // spotify:app:collection:albums, spotify:app:radio
      return parts.slice(1).join('-');

    default:
    // Do nothing.
  }

  return result;
};

},{}],353:[function(require,module,exports){
'use strict';

var _strings = require('../glue/strings');

var _strings2 = _interopRequireDefault(_strings);

var _interpolateString = require('./src/interpolate-string');

var _interpolateString2 = _interopRequireDefault(_interpolateString);

var _pickString = require('./src/pick-string');

var _pickString2 = _interopRequireDefault(_pickString);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

module.exports = function (locales) {
  if (!locales || typeof locales !== 'object') {
    throw new Error('' + 'Locale strings must be a plain object. ' + 'See spotify-i18n/README.md');
  }

  function getClientLocale() {
    const preference = typeof window !== 'undefined' && window && window.__spotify && window.__spotify.locale;
    return locales[preference] ? preference : 'en';
  }

  return {
    locale: getClientLocale,

    get: function (key) {
      const parameters = Array.prototype.slice.call(arguments, 1);
      const string = (0, _pickString2.default)(locales, getClientLocale(), key, parameters[0]);
      if (typeof string === 'undefined') {
        return key;
      }
      const translation = (0, _interpolateString2.default)(string, parameters, getClientLocale());
      return translation;
    },

    getGlueString: function (key) {
      const parameters = Array.prototype.slice.call(arguments, 1);
      const string = (0, _pickString2.default)(_strings2.default, getClientLocale(), key, parameters[0]);
      if (typeof string === 'undefined') {
        return key;
      }
      const translation = (0, _interpolateString2.default)(string, parameters, getClientLocale());
      return translation;
    },

    glueStrings: function () {
      return _strings2.default[getClientLocale()];
    },

    appStrings: function () {
      return locales[getClientLocale()];
    }
  };
};

},{"../glue/strings":122,"./src/interpolate-string":354,"./src/pick-string":355}],354:[function(require,module,exports){
'use strict';

/**
 * Replaces placeholders with their corresponding parameters
 *
 * This used to be a part of the spotify-translations lib. That package was
 * absorbed into spotify-i18n during the addition of pluralization.
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = interpolateString;
function interpolateString(string, parameters = [], locale) {
  const numberFormat = new Intl.NumberFormat(locale || 'en');

  return string.replace(/\{(\d+?)\}/g, function (str, num) {
    const value = parameters[num];

    if (typeof value === 'undefined') {
      return str;
    }

    if (typeof value === 'number') {
      return numberFormat.format(value);
    }

    return value;
  });
}

},{}],355:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = pickString;

var _pluralization = require('./pluralization');

var _pluralization2 = _interopRequireDefault(_pluralization);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Selects the string for the given key
 *
 * This used to be a simple property existence check on the object containing
 * the strings. Now that we have proper pluralization it's become a little more
 * complex. Before, only the locale and key mattered. Now, we sometimes have to
 * run a pluralization check on the first parameter in case it's a count for a
 * plural form string.
 */
function pickString(strings, locale, key, count) {
  if (typeof strings[locale][key] === 'string') {
    return strings[locale][key];
  }

  if (typeof strings[locale][key] === 'object') {
    const pluralizer = _pluralization2.default[locale];
    const pluralKey = pluralizer(count);
    if (strings[locale][key][pluralKey]) {
      return strings[locale][key][pluralKey];
    }
    if (strings[locale][key].other) {
      // This will mainly happen while waiting for translations to come back,
      // during which time the Polish lang file (for example) will contain the
      // English plural forms. Falling back to "other" covers this quite nicely.
      return strings[locale][key].other;
    }
  }

  // satisfy the consistent-return linter rule
  return undefined;
}

},{"./pluralization":356}],356:[function(require,module,exports){
'use strict';

const oneOther = n => n === 1 ? 'one' : 'other';
const other = () => 'other';

const polish = n => {
  const mod10 = n % 10;
  const mod100 = n % 100;
  if (n === 1) {
    return 'one';
  }
  if ([2, 3, 4].indexOf(mod10) !== -1 && [12, 13, 14].indexOf(mod100) === -1) {
    return 'few';
  }
  if ([0, 1, 5, 6, 7, 8, 9].indexOf(mod10) !== -1 || [12, 13, 14].indexOf(mod100) !== -1) {
    return 'many';
  }
  return 'other';
};

const westSlavic = n => {
  if (n === 1) {
    return 'one';
  }
  if (n >= 2 && n <= 4) {
    return 'few';
  }
  return 'other';
};

module.exports = {
  'cs': westSlavic,
  'en': oneOther,
  'de': oneOther,
  'el': oneOther,
  'es-419': oneOther,
  'es': oneOther,
  'fi': oneOther,
  'fr': oneOther,
  'fr-CA': oneOther,
  'hu': oneOther,
  'id': other,
  'it': oneOther,
  'ja': other,
  'nl': oneOther,
  'pl': polish,
  'pt-BR': oneOther,
  'sv': oneOther,
  'th': other,
  'tr': oneOther,
  'vi': oneOther,
  'zh-Hant': other,
  'zsm': other
};

},{}],357:[function(require,module,exports){
/* eslint-disable no-nested-ternary */

'use strict';

var _locales = require('../locales');

var _locales2 = _interopRequireDefault(_locales);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function getOrdinalFunction(currentLanguage) {
  switch (currentLanguage) {
    case 'cs':
    case 'de':
    case 'el':
    case 'fi':
    case 'hu':
    case 'ja':
    case 'pl':
    case 'sv':
    case 'zsm':
      return n => `${n}.`;

    case 'it':
    case 'pt-BR':
      return n => `${n}º`;

    case 'fr':
    case 'fr-CA':
      return n => `${n}${n === 1 ? 'er' : 'e'}`;

    case 'es':
    case 'es-419':
      return (n, b = n % 10) => `${n}${b === 1 || b === 3 ? 'er' : b === 2 ? 'do' : b === 7 || b === 0 ? 'mo' : b === 8 ? 'vo' : b === 9 ? 'no' : 'to'}`;

    case 'id':
      // According to Spotify's internal Indonesian specialist,
      // there is no ordinal symbol in Indonesian (like st, nd, th, º, ª),
      // they just use the word (equivalent to writing: first, second,
      // third, instead of 1st, 2nd, 3rd). And as we don't have such
      // capability to translate all numbers to words, this function
      // returns the cardinal number as a string.
      return n => `${n}`;

    case 'nl':
      return (n, b = n % 100) => `${n}${n !== 0 && b <= 1 || b === 8 || b >= 20 ? 'ste' : 'de'}`;

    case 'tr':
      return n => {
        if (n === 0) {
          // special case for zero
          return `${n}'ıncı`;
        }
        const suffixes = {
          1: "'inci",
          5: "'inci",
          8: "'inci",
          70: "'inci",
          80: "'inci",

          2: "'nci",
          7: "'nci",
          20: "'nci",
          50: "'nci",

          3: "'üncü",
          4: "'üncü",
          100: "'üncü",

          6: "'ncı",

          9: "'uncu",
          10: "'uncu",
          30: "'uncu",

          60: "'ıncı",
          90: "'ıncı"
        };
        const a = n % 10;
        const b = n % 100 - a;
        const c = n >= 100 ? 100 : null;

        return `${n}${suffixes[a] || suffixes[b] || suffixes[c]}`;
      };

    case 'zh-Hant':
      return n => `第${n}`;

    case 'en':
      return (n, b = n % 10) => `${n}${~~(n % 100 / 10) === 1 ? 'th' : b === 1 ? 'st' : b === 2 ? 'nd' : b === 3 ? 'rd' : 'th'}`;

    case 'th':
      // There is no ordinal symbol in Thai (like st, nd, th, º, ª),
      // they just numbers 1,2,3. Suppose the '1st' album will be 'album number 1'.
      // And as we don't have such capability to reorder words,
      // this function just returns the cardinal number as a string.
      return n => `${n}`;

    case 'vi':
      return n => {
        if (n === 1) {
          // special case for 1st
          return 'thứ nhất';
        }
        return `thứ ${n}`;
      };

    default:
      console.warn(`No explicit ordinal formatter specified for "${currentLanguage}" locale – please add to spotify-numeral`);
      return n => `${n}.`;
  }
}

module.exports = function (currentLanguage) {
  const getOrdinal = getOrdinalFunction(currentLanguage);
  const numberFormat = new Intl.NumberFormat((0, _locales2.default)(currentLanguage, 'spotify-numeral'));

  const getFormattedNumber = (number, format = '0,0') => {
    if (format === '0,0') return numberFormat.format(number);else if (format === '0o') return getOrdinal(number);
    throw new Error(`Unsupported format ${format}`);
  };

  return number => ({
    format: format => getFormattedNumber(number, format)
  });
};

},{"../locales":216}],358:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.watchSessionChange = exports.dispatchQBEUpdate = exports.dispatchQBEShowSuccessMessage = exports.dispatchQBEShowHighlight = exports.dispatchQBEShowModal = exports.dispatchUriAdded = exports.dispatchAppOpened = exports.subscribeToMessages = exports.sendMessages = exports.SESSION_ONLINE_STATUS_CHANGE = exports.QBE_UPDATE = exports.QBE_SHOW_SUCCESS_MESSAGE = exports.QBE_SHOW_HIGHLIGHT = exports.QBE_SHOW_MODAL = exports.ADD_URI = exports.OPEN_PLAYLIST = exports.OPEN_APP = undefined;

var _bridge = require('../../libs/bridge');

var _bridge2 = _interopRequireDefault(_bridge);

var _live = require('../../libs/live');

var _live2 = _interopRequireDefault(_live);

var _kernel = require('./kernel');

var _kernel2 = _interopRequireDefault(_kernel);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const sideEffects = {
  bridge: _bridge2.default,
  live: _live2.default
};
const shell = (0, _kernel2.default)(sideEffects);

const {
  OPEN_APP,
  OPEN_PLAYLIST,
  ADD_URI,
  QBE_SHOW_MODAL,
  QBE_SHOW_HIGHLIGHT,
  QBE_SHOW_SUCCESS_MESSAGE,
  QBE_UPDATE,
  SESSION_ONLINE_STATUS_CHANGE,

  sendMessages,
  subscribeToMessages,
  dispatchAppOpened,
  dispatchUriAdded,
  dispatchQBEShowModal,
  dispatchQBEShowHighlight,
  dispatchQBEShowSuccessMessage,
  dispatchQBEUpdate,
  watchSessionChange
} = shell;
exports.OPEN_APP = OPEN_APP;
exports.OPEN_PLAYLIST = OPEN_PLAYLIST;
exports.ADD_URI = ADD_URI;
exports.QBE_SHOW_MODAL = QBE_SHOW_MODAL;
exports.QBE_SHOW_HIGHLIGHT = QBE_SHOW_HIGHLIGHT;
exports.QBE_SHOW_SUCCESS_MESSAGE = QBE_SHOW_SUCCESS_MESSAGE;
exports.QBE_UPDATE = QBE_UPDATE;
exports.SESSION_ONLINE_STATUS_CHANGE = SESSION_ONLINE_STATUS_CHANGE;
exports.sendMessages = sendMessages;
exports.subscribeToMessages = subscribeToMessages;
exports.dispatchAppOpened = dispatchAppOpened;
exports.dispatchUriAdded = dispatchUriAdded;
exports.dispatchQBEShowModal = dispatchQBEShowModal;
exports.dispatchQBEShowHighlight = dispatchQBEShowHighlight;
exports.dispatchQBEShowSuccessMessage = dispatchQBEShowSuccessMessage;
exports.dispatchQBEUpdate = dispatchQBEUpdate;
exports.watchSessionChange = watchSessionChange;

},{"../../libs/bridge":86,"../../libs/live":210,"./kernel":359}],359:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = kernel;

var _spotifyLiburi = require('spotify-liburi');

var _spotifyLiburi2 = _interopRequireDefault(_spotifyLiburi);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function kernel({ bridge, live }) {
  const OPEN_APP = 'open_app';
  const OPEN_PLAYLIST = 'open_playlist';
  const ADD_URI = 'add_uri'; // add/follow an URI
  const QBE_SHOW_MODAL = 'qbe_show_modal';
  const QBE_SHOW_HIGHLIGHT = 'qbe_show_highlight';
  const QBE_UPDATE = 'qbe_update';
  const QBE_SHOW_SUCCESS_MESSAGE = 'qbe_show_success_message';
  const SESSION_ONLINE_STATUS_CHANGE = 'session_online_status_change';

  function sendMessages(messages) {
    bridge.cosmosJSON({
      method: 'POST',
      uri: 'sp://messages/v1/surround',
      body: messages
    });
  }

  // The seconds parameter passed to `callback` is an array of messages that may
  // contain 1 or more messages.
  function subscribeToMessages(callback) {
    bridge.cosmosJSON({
      method: 'SUB',
      uri: 'sp://messages/v1/surround'
    }, callback);
  }

  function dispatchAppOpened(appId, appArguments) {
    const messages = [{
      action: OPEN_APP,
      appId: appId
    }];

    switch (appId) {
      case 'playlist':
      case 'chart':
        {
          const openPlaylistMessage = function createOpenPlaylistMessageFromAppArguments() {
            // args are the arguments passed to the playlist app and chart app.
            const args = appArguments;
            let playlistUri = null;

            if (args.length === 1 && args[0] === 'local-files') {
              playlistUri = 'spotify:internal:local-files';
            } else if (args.length >= 2) {
              playlistUri = _spotifyLiburi2.default.playlistURI(args[0], args[1]).toString();
            }

            if (playlistUri) {
              return { action: OPEN_PLAYLIST, playlistUri: playlistUri };
            }
            return null;
          }();

          if (openPlaylistMessage) {
            messages.push(openPlaylistMessage);
          }
          break;
        }

      default:
        break;
    }

    sendMessages(messages);
  }

  function dispatchUriAdded(uri, data) {
    if (!data.added) {
      return;
    }

    sendMessages([{
      action: ADD_URI,
      uri: uri
    }]);
  }

  function dispatchQBEShowModal(title, content, id, buttons) {
    sendMessages([{
      action: QBE_SHOW_MODAL,
      modal: { title, content, id },
      buttons
    }]);
  }

  function dispatchQBEShowHighlight(highlight, taskId) {
    sendMessages([{
      action: QBE_SHOW_HIGHLIGHT,
      highlight,
      taskId
    }]);
  }

  function dispatchQBEShowSuccessMessage(text) {
    sendMessages([{
      action: QBE_SHOW_SUCCESS_MESSAGE,
      text
    }]);
  }

  function dispatchQBEUpdate({ enabled, tasks = [] }) {
    sendMessages([{
      action: QBE_UPDATE,
      enabled,
      tasks
    }]);
  }

  function watchSessionChange() {
    function subscribe() {
      live('spotify:client').get('session').on('update', data => {
        if ('online' in data) {
          sendMessages([{
            action: SESSION_ONLINE_STATUS_CHANGE,
            online: data.online
          }]);
        }
      });
    }
    live('spotify:client').query('session(online)', (error, data) => {
      sendMessages([{
        action: SESSION_ONLINE_STATUS_CHANGE,
        online: data.session.online
      }]);
      subscribe();
    });
  }

  return {
    OPEN_APP,
    OPEN_PLAYLIST,
    ADD_URI,
    QBE_SHOW_MODAL,
    QBE_SHOW_HIGHLIGHT,
    QBE_UPDATE,
    QBE_SHOW_SUCCESS_MESSAGE,
    SESSION_ONLINE_STATUS_CHANGE,

    sendMessages,
    subscribeToMessages,
    dispatchAppOpened,
    dispatchUriAdded,
    dispatchQBEShowModal,
    dispatchQBEShowHighlight,
    dispatchQBEShowSuccessMessage,
    dispatchQBEUpdate,
    watchSessionChange
  };
}

},{"spotify-liburi":730}],360:[function(require,module,exports){
(function (global){
var check = require('./check.js');
var compare = require('./compare.js');

/**
 * Throws an Error if there are differences between the two given instances. The
 * error message will contain the difference summary. Compares arrays, booleans,
 * numbers, objects and strings as well as null and undefined by value and other
 * types by reference.
 */
var assert = function (one, two) {
  var summary;

  summary = compare(one, two, '');

  if (summary !== null) {
    throw new global.Error(summary);
  }
};

/**
 * Throws an Error if the given method does not throw when called with the given
 * args for the given instance.
 */
assert.throws = function (instance, method, args) {
  var unexpected;

  check.function(method);
  check.array(args);

  unexpected = new Error('Expected an error to be thrown!');

  try {
    method.apply(instance, args);

    throw unexpected;
  } catch (error) {
    if (error === unexpected) {
      throw unexpected;
    }
  }
};

module.exports = assert;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./check.js":361,"./compare.js":363}],361:[function(require,module,exports){
(function (global){
var is = require('./is.js');

/**
 * Throws a TypeError if the given instance is not an array.
 */
exports.array = function (instance) {
  if (!is.array(instance)) {
    throw new global.TypeError('Expected array!');
  }
};

/**
 * Throws a TypeError if the given instance is not a boolean.
 */
exports.boolean = function (instance) {
  if (!is.boolean(instance)) {
    throw new global.TypeError('Expected boolean!');
  }
};

/**
 * Throws a TypeError if the given instance is not a function.
 */
exports.function = function (instance) {
  if (!is.function(instance)) {
    throw new global.TypeError('Expected function!');
  }
};

/**
 * Throws a TypeError if the given instance is not null.
 */
exports.null = function (instance) {
  if (!is.null(instance)) {
    throw new global.TypeError('Expected null!');
  }
};

/**
 * Throws a TypeError if the given instance is not a number.
 */
exports.number = function (instance) {
  if (!is.number(instance)) {
    throw new global.TypeError('Expected number!');
  }
};

/**
 * Throws a TypeError if the given instance is not an object.
 */
exports.object = function (instance) {
  if (!is.object(instance)) {
    throw new global.TypeError('Expected object!');
  }
};

/**
 * Throws a TypeError if the given instance is not a string.
 */
exports.string = function (instance) {
  if (!is.string(instance)) {
    throw new global.TypeError('Expected string!');
  }
};

/**
 * Throws a TypeError if the given instance does not descend from the given
 * constructor.
 */
exports.type = function (instance, constructor) {
  if (!is.type(instance, constructor)) {
    throw new global.TypeError('Expected type!');
  }
};

/**
 * Throws a TypeError if the given instance is not undefined.
 */
exports.undefined = function (instance) {
  if (!is.undefined(instance)) {
    throw new global.TypeError('Expected undefined!');
  }
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./is.js":371}],362:[function(require,module,exports){
(function (global){
var is = require('./is.js');
var name = require('./name.js');

/**
 * Attemps to clone the given instance. Only arrays, booleans, numbers, objects
 * and strings as well as null and undefined are accepted. If any other type is
 * encountered, a TypeError is thrown.
 */
var clone = function (instance) {
  var array;
  var i;
  var k;
  var l;
  var object;

  if (is.array(instance)) {
    array = [];

    for (i = 0, l = instance.length; i < l; i++) {
      array[i] = clone(instance[i]);
    }

    return array;
  }

  if (is.boolean(instance)) {
    return instance;
  }

  if (is.null(instance)) {
    return instance;
  }

  if (is.number(instance)) {
    return instance;
  }

  if (is.object(instance)) {
    object = {};

    for (k in instance) {
      object[k] = clone(instance[k]);
    }

    return object;
  }

  if (is.string(instance)) {
    return instance;
  }

  if (is.undefined(instance)) {
    return instance;
  }

  throw new global.TypeError('Unexpected type "' + name(instance) + '"!');
};

module.exports = clone;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./is.js":371,"./name.js":373}],363:[function(require,module,exports){
var is = require('./is.js');
var name = require('./name.js');

/**
 * Creates a difference summary between the two given instances. Compares
 * arrays, booleans, numbers, objects and strings as well as null and undefined
 * by value and other types by reference. Returns null if the two given
 * instances are identical.
 */
var compare = function (one, two, prefix) {
  var i;
  var k;
  var l;
  var m;
  var result;
  var summary;

  result = '\n';

  if (!is.string(prefix)) {
    prefix = '';
  }

  if (is.array(one)) {
    if (!is.array(two)) {
      return 'expected type "' + name(one) + '" but found type "' + name(two) + '"\n';
    }

    for (i = 0, l = one.length, m = two.length; i < l && i < m; i++) {
      summary = compare(one[i], two[i], prefix + '    ');

      if (summary !== null) {
        result += prefix + '"' + i + '": ' + summary;
      }
    }

    for (; i < l; i++) {
      result += prefix + '"' + i + '": the item is missing\n';
    }

    for (; i < m; i++) {
      result += prefix + '"' + i + '": the item was not expected\n';
    }

    return result !== '\n' ? result : null;
  }

  if (is.boolean(one)) {
    if (!is.boolean(two)) {
      return 'expected type "' + name(one) + '" but found type "' + name(two) + '"\n';
    }

    if (one.valueOf() !== two.valueOf()) {
      return 'expected ' + one.valueOf() + ' but found ' + two.valueOf() + '\n';
    }

    return null;
  }

  if (is.null(one)) {
    if (!is.null(two)) {
      return 'expected type "' + name(one) + '" but found type "' + name(two) + '"\n';
    }

    return null;
  }

  if (is.number(one)) {
    if (!is.number(two)) {
      return 'expected type "' + name(one) + '" but found type "' + name(two) + '"\n';
    }

    if (one.valueOf() !== two.valueOf()) {
      return 'expected ' + one.valueOf() + ' but found ' + two.valueOf() + '\n';
    }

    return null;
  }

  if (is.object(one)) {
    if (!is.object(two)) {
      return 'expected type "' + name(one) + '" but found type "' + name(two) + '"\n';
    }

    for (k in one) {
      if (!(k in two)) {
        result += prefix + '"' + k + '": the item is missing\n';
      } else {
        summary = compare(one[k], two[k], prefix + '    ');

        if (summary !== null) {
          result += prefix + '"' + k + '": ' + summary;
        }
      }
    }

    for (k in two) {
      if (!(k in one)) {
        result += prefix + '"' + k + '": the item was not expected\n';
      }
    }

    return result !== '\n' ? result : null;
  }

  if (is.string(one)) {
    if (!is.string(two)) {
      return 'expected type "' + name(one) + '" but found type "' + name(two) + '"\n';
    }

    if (one.valueOf() !== two.valueOf()) {
      return 'expected "' + one.valueOf() + '" but found "' + two.valueOf() + '"\n';
    }

    return null;
  }

  if (is.undefined(one)) {
    if (!is.undefined(two)) {
      return 'expected type "' + name(one) + '" but found type "' + name(two) + '"\n';
    }

    return null;
  }

  if (two == null || two.constructor !== one.constructor) {
    return 'expected an instance of type "' + name(one) + '"\n';
  } else {
    if (one !== two) {
      return 'expected a different instance of type "' + name(one) + '"\n';
    }
  }

  return null;
};

module.exports = compare;

},{"./is.js":371,"./name.js":373}],364:[function(require,module,exports){
var is = require('./is.js');

/**
 * Checks whether the given actual json conforms to the given schema. This
 * asserts that all required fields are present and have the correct types. It
 * also asserts that all optional fields either are present and have the correct
 * types or are missing in the given actual json.
 */
var conforms = function (actual, schema, verbose, path) {
  var i;
  var l;
  var result;
  var k;
  var parts;

  if (!is.boolean(verbose)) {
    verbose = false;
  }

  if (!is.string(path)) {
    path = 'root';
  }

  if (is.array(schema)) {
    if (is.array(actual)) {
      if (schema.length === 0) {
        return true;
      }

      if (schema.length !== 1) {
        if (verbose) {
          console.warn(path + ': expected an array with exactly one element in the schema but found ' + schema.length + ' elements');
        }

        return false;
      }

      result = true;

      for (i = 0, l = actual.length; i < l; i++) {
        if (!conforms(actual[i], schema[0], verbose, path + '[' + i + ']')) {
          result = false;
        }
      }

      return result;
    } else {
      if (verbose) {
        console.warn(path + ': expected an array but found', actual);
      }

      return false;
    }
  }

  if (is.boolean(schema)) {
    if (is.boolean(actual)) {
      return true;
    } else {
      if (verbose) {
        console.warn(path + ': expected a boolean but found', actual);
      }

      return false;
    }
  }

  if (is.number(schema)) {
    if (is.number(actual)) {
      return true;
    } else {
      if (verbose) {
        console.warn(path + ': expected a number but found', actual);
      }

      return false;
    }
  }

  if (is.object(schema)) {
    if (is.object(actual)) {
      result = true;

      for (k in schema) {
        parts = /^([^?]+)\?$/.exec(k);

        if (parts === null) {
          if (!conforms(actual[k], schema[k], verbose, path + '.' + k)) {
            result = false;
          }
        } else {
          if (actual[parts[1]] != null) {
            if (!conforms(actual[parts[1]], schema[k], verbose, path + '.' + k)) {
              result = false;
            }
          }
        }
      }

      return result;
    } else {
      if (verbose) {
        console.warn(path + ': expected an object but found', actual);
      }

      return false;
    }
  }

  if (is.string(schema)) {
    if (is.string(actual)) {
      return true;
    } else {
      if (verbose) {
        console.warn(path + ': expected a string but found', actual);
      }

      return false;
    }
  }

  if (verbose) {
    console.warn(path + ': expected a supported type in the schema but found', schema);
  }

  return false;
};

module.exports = conforms;

},{"./is.js":371}],365:[function(require,module,exports){
(function (global){
var check = require('./check.js');

/**
 * Makes base a pure class.
 */
var define = function (base) {
  check.function(base);

  base.prototype = global.Object.create(null);
  base.prototype.constructor = base;
};

module.exports = define;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./check.js":361}],366:[function(require,module,exports){
var is = require('./is.js');
var name = require('./name.js');

/**
 * Determines if the two given instances are identical. Compares arrays,
 * booleans, numbers, objects and strings as well as null and undefined by value
 * and other types by reference.
 */
var equals = function (one, two) {
  var i;
  var k;
  var l;

  if (is.array(one)) {
    if (!is.array(two)) {
      return false;
    }

    if (one.length !== two.length) {
      return false;
    }

    for (i = 0, l = one.length; i < l; i++) {
      if (!equals(one[i], two[i])) {
        return false;
      }
    }

    return true;
  }

  if (is.boolean(one)) {
    if (!is.boolean(two)) {
      return false;
    }

    if (one.valueOf() !== two.valueOf()) {
      return false;
    }

    return true;
  }

  if (is.null(one)) {
    if (!is.null(two)) {
      return false;
    }

    return true;
  }

  if (is.number(one)) {
    if (!is.number(two)) {
      return false;
    }

    if (one.valueOf() !== two.valueOf()) {
      return false;
    }

    return true;
  }

  if (is.object(one)) {
    if (!is.object(two)) {
      return false;
    }

    for (k in one) {
      if (!(k in two)) {
        return false;
      }

      if (!equals(one[k], two[k])) {
        return false;
      }
    }

    for (k in two) {
      if (!(k in one)) {
        return false;
      }
    }

    return true;
  }

  if (is.string(one)) {
    if (!is.string(two)) {
      return false;
    }

    if (one.valueOf() !== two.valueOf()) {
      return false;
    }

    return true;
  }

  if (is.undefined(one)) {
    if (!is.undefined(two)) {
      return false;
    }

    return true;
  }

  return one === two;
};

module.exports = equals;

},{"./is.js":371,"./name.js":373}],367:[function(require,module,exports){
(function (global){
var check = require('./check.js');

/**
 * Makes derived extend base.
 */
var extend = function (derived, base) {
  check.function(derived);
  check.function(base);

  derived.prototype = global.Object.create(base.prototype);
  derived.prototype.constructor = derived;
};

module.exports = extend;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./check.js":361}],368:[function(require,module,exports){
var is = require('./is.js');

/**
 * Returns the given fallback if the given instance is not an array.
 */
exports.array = function (instance, fallback) {
  return is.array(instance) ? instance : fallback;
};

/**
 * Returns the given fallback if the given instance is not a boolean.
 */
exports.boolean = function (instance, fallback) {
  return is.boolean(instance) ? instance : fallback;
};

/**
 * Returns the given fallback if the given instance is not a function.
 */
exports.function = function (instance, fallback) {
  return is.function(instance) ? instance : fallback;
};

/**
 * Returns the given fallback if the given instance is not null.
 */
exports.null = function (instance, fallback) {
  return is.null(instance) ? instance : fallback;
};

/**
 * Returns the given fallback if the given instance is not a number.
 */
exports.number = function (instance, fallback) {
  return is.number(instance) ? instance : fallback;
};

/**
 * Returns the given fallback if the given instance is not an object.
 */
exports.object = function (instance, fallback) {
  return is.object(instance) ? instance : fallback;
};

/**
 * Returns the given fallback if the given instance is not a string.
 */
exports.string = function (instance, fallback) {
  return is.string(instance) ? instance : fallback;
};

/**
 * Returns the given fallback if the given instance does not descend from the
 * given constructor.
 */
exports.type = function (instance, constructor, fallback) {
  return is.type(instance, constructor) ? instance : fallback;
};

/**
 * Returns the given fallback if the given instance is not undefined.
 */
exports.undefined = function (instance, fallback) {
  return is.undefined(instance) ? instance : fallback;
};

},{"./is.js":371}],369:[function(require,module,exports){
/**
 * Creates a function wrapper that always returns the given value.
 */
var fixture = function (value) {
  return function () {
    return value;
  };
};

module.exports = fixture;

},{}],370:[function(require,module,exports){
exports.assert = require('./assert.js');
exports.check = require('./check.js');
exports.clone = require('./clone.js');
exports.compare = require('./compare.js');
exports.conforms = require('./conforms.js');
exports.define = require('./define.js');
exports.equals = require('./equals.js');
exports.extend = require('./extend.js');
exports.fallback = require('./fallback.js');
exports.fixture = require('./fixture.js');
exports.is = require('./is.js');
exports.mock = require('./mock.js');
exports.name = require('./name.js');
exports.spy = require('./spy.js');
exports.stub = require('./stub.js');

},{"./assert.js":360,"./check.js":361,"./clone.js":362,"./compare.js":363,"./conforms.js":364,"./define.js":365,"./equals.js":366,"./extend.js":367,"./fallback.js":368,"./fixture.js":369,"./is.js":371,"./mock.js":372,"./name.js":373,"./spy.js":374,"./stub.js":375}],371:[function(require,module,exports){
(function (global){
/**
 * Determines if the given instance is an array.
 */
exports.array = function (instance) {
  return instance != null && instance.constructor === global.Array;
};

/**
 * Determines if the given instance is a boolean.
 */
exports.boolean = function (instance) {
  return instance != null && instance.constructor === global.Boolean;
};

/**
 * Determines if the given instance is a function.
 */
exports.function = function (instance) {
  return instance != null && instance.constructor === global.Function;
};

/**
 * Determines if the given instance is null.
 */
exports.null = function (instance) {
  return instance === null;
};

/**
 * Determines if the given instance is a number.
 */
exports.number = function (instance) {
  return instance != null && instance.constructor === global.Number;
};

/**
 * Determines if the given instance is an object.
 */
exports.object = function (instance) {
  return instance != null && instance.constructor === global.Object;
};

/**
 * Determines if the given instance is a string.
 */
exports.string = function (instance) {
  return instance != null && instance.constructor === global.String;
};

/**
 * Determines if the given instance descends from the given constructor.
 */
exports.type = function (instance, constructor) {
  return instance != null && constructor != null && instance instanceof constructor;
};

/**
 * Determines if the given instance is undefined.
 */
exports.undefined = function (instance) {
  return instance === global.undefined;
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],372:[function(require,module,exports){
(function (global){
var check = require('./check.js');
var extend = require('./extend.js');
var is = require('./is.js');

/**
 * Creates a mock for the given base class with the given implementation that
 * can be used for unit testing. The methods defined on implementation will be
 * used instead of the methods defined on the base class.
 */
var mock = function (base, implementation) {
  var derived;
  var keys;
  var i;
  var key;

  check.function(base);

  derived = function () {
    base.apply(this, arguments);
  };

  extend(derived, base);

  derived.create = function () {
    var that;

    that = global.Object.create(derived.prototype);

    derived.apply(that, arguments);

    return that;
  };

  if (implementation != null) {
    check.object(implementation);

    keys = global.Object.getOwnPropertyNames(implementation);

    for (i = 0; i < keys.length; i++) {
      key = keys[i];

      if (key !== 'constructor' && is.function(implementation[key])) {
        if (is.function(base.prototype[key])) {
          derived.prototype[key] = implementation[key];
        } else {
          throw new global.Error('Method "' + key + '" doesn\'t override any method defined on the base class!');
        }
      }
    }
  }

  return derived;
};

module.exports = mock;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./check.js":361,"./extend.js":367,"./is.js":371}],373:[function(require,module,exports){
var is = require('./is.js');

/**
 * Attempts to read the type name for the given instance.
 */
var name = function (instance) {
  if (is.null(instance)) {
    return 'Null';
  }

  if (is.undefined(instance)) {
    return 'Undefined';
  }

  if (is.function(instance.constructor) && is.string(instance.constructor.name)) {
    return instance.constructor.name;
  }

  return '';
};

module.exports = name;

},{"./is.js":371}],374:[function(require,module,exports){
(function (global){
var check = require('./check.js');

/**
 * Creates a spy function that records all function calls into the given calls
 * array.
 */
var spy = function (calls) {
  check.array(calls);

  return function () {
    calls.push({ 'caller' : this, 'arguments' : global.Array.prototype.slice.call(arguments) });
  };
};

module.exports = spy;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./check.js":361}],375:[function(require,module,exports){
(function (global){
var check = require('./check.js');
var extend = require('./extend.js');
var is = require('./is.js');

/**
 * Creates a stub for the given base class with the given implementation that
 * can be used for unit testing.
 */
var stub = function (base, implementation) {
  var derived;
  var prototype;
  var keys;
  var i;
  var key;

  check.function(base);
  check.object(implementation);

  derived = function () {
    var key;

    for (key in implementation) {
      this[key] = implementation[key];
    }
  };

  extend(derived, base);

  derived.create = function () {
    var that;

    that = global.Object.create(derived.prototype);

    derived.apply(that, arguments);

    return that;
  };

  prototype = base.prototype;

  while (prototype != null && prototype !== global.Object.prototype) {
    keys = global.Object.getOwnPropertyNames(prototype);

    for (i = 0; i < keys.length; i++) {
      key = keys[i];

      if (key !== 'constructor' && is.function(prototype[key])) {
        if (is.function(implementation[key])) {
          derived.prototype[key] = implementation[key];
        } else {
          derived.prototype[key] = (function (key) {
            return function () {
              throw new global.Error('Method stub "' + key + '" called!');
            };
          })(key);
        }
      }
    }

    prototype = global.Object.getPrototypeOf(prototype);
  }

  return derived;
};

module.exports = stub;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./check.js":361,"./extend.js":367,"./is.js":371}],376:[function(require,module,exports){
/*!
  Copyright (c) 2016 Jed Watson.
  Licensed under the MIT License (MIT), see
  http://jedwatson.github.io/classnames
*/
/* global define */

(function () {
	'use strict';

	var hasOwn = {}.hasOwnProperty;

	function classNames () {
		var classes = [];

		for (var i = 0; i < arguments.length; i++) {
			var arg = arguments[i];
			if (!arg) continue;

			var argType = typeof arg;

			if (argType === 'string' || argType === 'number') {
				classes.push(arg);
			} else if (Array.isArray(arg)) {
				classes.push(classNames.apply(null, arg));
			} else if (argType === 'object') {
				for (var key in arg) {
					if (hasOwn.call(arg, key) && arg[key]) {
						classes.push(key);
					}
				}
			}
		}

		return classes.join(' ');
	}

	if (typeof module !== 'undefined' && module.exports) {
		module.exports = classNames;
	} else if (typeof define === 'function' && typeof define.amd === 'object' && define.amd) {
		// register as 'classnames', consistent with npm package name
		define('classnames', [], function () {
			return classNames;
		});
	} else {
		window.classNames = classNames;
	}
}());

},{}],377:[function(require,module,exports){
'use strict';

exports.message = require('./src/message');
exports.request = require('./src/request');
exports.response = require('./src/response');
exports.playerstate = require('./src/player_state');

},{"./src/message":378,"./src/player_state":379,"./src/request":380,"./src/response":381}],378:[function(require,module,exports){
/**
 * A set of Message headers.
 *
 * @name exports.Headers
 * @typedef {Object.<string, string>}
 */
exports.Headers;

/**
 * A body of a Request-Response.
 *
 * @name exports.Body
 * @typedef {*}
 */
exports.Body;

/**
 * A serialized Message object.
 *
 * @name Spotify.Cosmos.SerializedMessage
 * @typedef {{
 *   uri: Spotify.Cosmos.URI,
 *   headers: Spotify.Cosmos.Headers,
 *   body: Spotify.Cosmos.Body
 * }}
 */
exports.SerializedMessage;

/**
 * Encapsulates a message.
 *
 * A message is an entity that has a URI, headers and a body.
 *
 * @constructs Spotify.Cosmos.Message
 * @param {Spotify.Cosmos.URI} uri The URI of the message
 * @param {Spotify.Cosmos.Headers=} opt_headers The optional headers of the
 *     message.
 * @param {Spotify.Cosmos.Body=} opt_body The optional body of the message.
 */
function Message(uri, opt_headers, opt_body) {
  if (uri == null)
    throw new TypeError('Invalid `uri` argument for Message.');

  /**
   * The URI of the Message.
   *
   * @type {Spotify.Cosmos.URI}
   * @protected
   */
  this._uri = uri;

  /**
   * The headers of the Message.
   *
   * @type {Spotify.Cosmos.Headers}
   * @protected
   */
  this._headers = {};

  /**
   * The body of the Message.
   *
   * @type {Spotify.Cosmos.Body}
   * @protected
   */
  this._body = this._encodeBody(opt_body || '');

  if (opt_headers) this._setHeaders(opt_headers);
}
exports.Message = Message;

/**
 * Creates a new Message from a SerializedMessage object.
 *
 * @param {Spotify.Cosmos.SerializedMessage} object The serialized request.
 * @return {Spotify.Cosmos.Message|null} The new Message object or null.
 */
Message.fromObject = function(object) {
  return (object && object.uri) ?
    new Message(
        object.uri,
        object.headers,
        object.body
    ) : null;
};

/**
 * Encodes a message body to a string.
 *
 * @param {*} body The value for the body.
 * @return {string} The body encoded as a string.
 */
Message.prototype._encodeBody = function(body) {
  if (typeof body != 'string') {
    body = JSON.stringify(body);
  }
  return body;
};

/**
 * Returns the URI of the message.
 *
 * @return {Spotify.Cosmos.URI} The URI of the message.
 */
Message.prototype.getURI = function() {
  return this._uri;
};

/**
 * Returns the mimetype of the message.
 *
 * @return {Spotify.Cosmos.MimeType} The mimetype of the message.
 */
Message.prototype.getMimeType = function() {
  return this._headers['accept'];
};

/**
 * Returns the value of a message's headers.
 *
 * @param {string} name The name of the header.
 * @return {string|null} The header value or null if the header wasn't set.
 */
Message.prototype.getHeader = function(name) {
  return this._headers[name.toLowerCase()] || null;
};

/**
 * Returns the headers of the message.
 *
 * @return {Spotify.Cosmos.Headers} The headers of the message.
 */
Message.prototype.getHeaders = function() {
  var _headers = this._headers;
  var headers = {};
  for (var name in _headers) {
    if (!_headers.hasOwnProperty(name)) continue;
    headers[name] = _headers[name];
  }
  return headers;
};

/**
 * Sets a bunch of headers to the message's headers.
 *
 * @param {Spotify.Cosmos.Headers} headers The headers to set to the message.
 * @protected
 */
Message.prototype._setHeaders = function(headers) {
  var _headers = this._headers;
  for (var name in headers) {
    if (!headers.hasOwnProperty(name)) continue;
    _headers[name.toLowerCase()] = headers[name];
  }
  return this;
};

/**
 * Returns the body of the message.
 *
 * @return {Spotify.Cosmos.Body} The body of the message.
 */
Message.prototype.getBody = function() {
  return this._body;
};

/**
 * Returns the body as a JSON object.
 *
 * @return {Object|null} The body of the message parsed as a JSON value. Can
 *     be null if the body is not a proper JSON string.
 */
Message.prototype.getJSONBody = function() {
  try {
    return JSON.parse(this._body);
  } catch(e) {
    return null;
  }
};

/**
 * Creates a new Message instance with data copied from the current instance.
 *
 * @param {Spotify.Cosmos.Headers=} opt_headers The optional headers of the
 *     message.
 * @param {Spotify.Cosmos.Body=} opt_body The optional body of the message.
 */
Message.prototype.copy = function(opt_headers, opt_body) {
  return new Message(
      this._uri,
      this._copyHeaders(opt_headers),
      typeof opt_body != 'undefined' ? opt_body : this._body
  );
};

/**
 * Copies the headers of the message.
 *
 * @param {Spotify.Cosmos.Headers=} opt_headers The optional headers of the
 *     message.
 * @return {Spotify.Cosmos.Headers} The headers of the message.
 */
Message.prototype._copyHeaders = function(opt_headers) {
  var headers;
  if (opt_headers) {
    var _headers = this._headers;
    var name;
    headers = {};
    for (name in _headers) {
      if (!_headers.hasOwnProperty(name)) continue;
      headers[name] = _headers[name];
    }
    for (name in opt_headers) {
      if (!opt_headers.hasOwnProperty(name)) continue;
      headers[name.toLowerCase()] = opt_headers[name];
    }
  } else {
    headers = this._headers;
  }
  return headers;
};

/**
 * Serializes the message into a plain object.
 *
 * @return {Spotify.Cosmos.SerializedMessage} The serialized object.
 */
Message.prototype.serialize = function() {
  return this.toJSON();
};

/**
 * Returns a JSON-object representation of the message.
 *
 * @return {Object} The JSON representation of the message.
 */
Message.prototype.toJSON = function() {
  return {
    uri: this._uri,
    headers: this._headers,
    body: this._body
  };
};

},{}],379:[function(require,module,exports){
var inherit = require('spotify-inheritance').inherit;

/**
 * PlayerState is used for two distinct purposes: Pushing new state to the
 * player (this is done when you request to play a completely new context with
 * 'play' method) and retrieving player state updates.
 *
 * Changing properties on PlayerState objects will not change the state of
 * the player unless you pass it to the 'play' method.
 *
 * @param {Object} stateData the data for the playerState.
 */
function PlayerState(stateData) {
  Serializable.call(this, [
    'action',
    'context',
    'tracks',
    'index',
    'playing',
    'loading',
    'track',
    'position',
    'duration',
    'volume',
    'options',
    'play_origin',
    'next_page_url',
    'prev_page_url'
  ]);

  stateData = stateData || {};
  /**
   * What kind of the action player should perform.
   * It's set directly before sending the request.
   * @type {String}
   */
  this.action = stateData.action;

  /**
   * Spotify uri describing the context that
   * will be played e.g playlist, album or artist.
   * Example: spotify:artist:4XaUmUGjidSklcDHxv3XWf,
   * spotify:user:daftpunkofficial:playlist:5nrg0D90OlFyveVfrQD0zE,
   * spotify:album:2nXJkqkS1tIKIyhBcFMmwz
   *
   * @type {String}
   */
  this.context = stateData.context;

  /**
   * The list of tracks uris to play in the given context.
   * Example: [
   *    spotify:track:0bXpmJyHHYPk6QBFj25bYF,
   *    spotify:track:6DXFVsLcEvOTSrkG9G1Cb1,
   *    spotify:track:6rxEjkoar48SssZePbtb2x
   * ]
   *
   * @type {Array.<String>}
   */
  this.tracks = stateData.tracks;

  /**
   * Which element on the this.tracks list should
   * be played.
   *
   * @type {Number}
   */
  this.index = stateData.index;

  /**
   * Is the player currently playing
   */
  this.playing = stateData.playing;
  this.loading = stateData.loading;

  /**
   * Current track URI
   * @type {String}
   */
  this.track = stateData.track;


  this.position = stateData.position;

  this.volume = stateData.volume;

  /**
   * Current track duration in miliseconds?
   * @type {Number}
   */
  this.duration = stateData.duration;

  /**
   * See PlayOptions description
   * @type {cosmos-bindings-js/scripts/player_state~PlayOptions}
   */
  this.options = new PlayOptions(stateData.options);

  /**
   * See PlayOrigin description
   * @type {cosmos-bindings-js/scripts/player_state~PlayOrigin}
   */
  this.play_origin = new PlayOrigin(stateData.play_origin);

  /**
   * Before the list of tracks that are to be played ends, a request will be sent
   * to this URL, which is supposed to return a list of tracks. That list of
   * tracks will then be appended to the list of tracks in the context.
   *
   * The response payload of the next_page_url should look like this:
   *
   * {
   *   "tracks": [
   *     { "track": "spotify:track:$TRACK-ID1", "context": "spotify:album:$ALBUM-ID1" },
   *     { "track": "spotify:track:$TRACK-ID2", "context": "spotify:album:$ALBUM-ID1" },
   *     { "track": "spotify:track:$TRACK-ID3", "context": "spotify:album:$ALBUM-ID1" },
   *   ],
   *   "next_page_url": "...", // Optional
   *   "prev_page_url": "..." // Optional
   * }
   *
   * May be null, which is the same as a URL that would return an empty list
   * of tracks (but with null, no network request is made).
   */
  this.next_page_url = stateData.next_page_url;

  /**
   * Like `next_page_url`, but for going backwards in the context.
   */
  this.prev_page_url = stateData.prev_page_url;
}
inherit(PlayerState, Serializable);

/**
 * Ovverides prototype method.
 * Converts play options and origin to
 * serializable to make sure only correct data
 * is returned.
 * @return {Object} Data associated with player state.
 */
PlayerState.prototype.serialize = function() {
  if (this.options && !(this.options instanceof PlayOptions)) {
    this.options = new PlayOptions(this.options);
  }

  if (this.play_origin && !(this.play_origin instanceof PlayOrigin)) {
    this.play_origin = new PlayOrigin(this.play_origin);
  }

  return this.constructor.prototype.serialize.call(this);
};

/**
 * Possible player actions.
 */
PlayerState.ACTIONS = {
  UNKNOWN: 'unknown',
  PLAY: 'play',
  UPDATE: 'update',
  STOP: 'stop',
  RESUME: 'resume',
  PAUSE: 'pause',
  SKIP_PREV: 'skip_prev',
  SKIP_NEXT: 'skip_next'
};

function PlayOrigin(data) {
  Serializable.call(this, [
    'source',
    'source_context',
    'reason',
    'referrer',
    'referrer_version',
    'referrer_vendor'
  ]);

  data = data || {};

  /**
   * What kind of playlist did we play from?
   *
   * The default value of this property is "unknown". Must have a value.
   *
   * Valid values include 'album', 'artist', 'extlink', 'playlist', 'playqueue',
   * 'radio', 'search', 'unknown'.
   *
   * For an up to date list of valid values, see `PLAY_SOURCES` in
   * https://git.spotify.net/cgit.cgi/log-parser.git/tree/spotify/log_parser/messages_specs.py
   */
  this.source = data.source || 'unknown';

  /**
   * The uri of the view that initiated the playback.
   */
  this.source_context = data.source_context || 'unknown';

  /**
   * Why was the song started?
   *
   * The default value of this property is "unknown". Must have a value.
   *
   * A list of valid values that might be used by features:
   *
   * unknown    = Client doesn't know
   * clickrow   = A row in the song list was clicked/opened
   * playbtn    = The play button was pressed
   * urlopen    = A Url was opened
   *
   * For a complete and up to date list of valid values, see `PLAY_REASONS` in
   * https://git.spotify.net/cgit.cgi/log-parser.git/tree/spotify/log_parser/messages_specs.py
   */
  this.reason = data.reason || 'unknown';

  /**
   * Either a remote site or a spotify app which initiated the request.
   *
   * NOTE: This normally should be a readonly property and not be set
   * explicitly in the PlayerState as the Player will overwrite it when sending the request.
   */
  this.referrer = data.referrer || 'unknown';

  /**
   * The version of the referrer, where applicable. It usually makes sense to
   * set this value to the version of the JS app version, for instance "0.7.5".
   *
   * NOTE: This normally should be a readonly property and not be set
   * explicitly in the PlayerState as the Player will overwrite it when sending the request.
   */
  this.referrer_version = data.referrer_version || 'unknown';

  /**
   * The vendor of the referrer, where applicable.
   * For example com.soundrop, com.spotify.
   *
   * NOTE: This normally should be a readonly property and not be set
   * explicitly in the PlayerState as the Player will overwrite it when sending the request.
   */
  this.referrer_vendor = data.referrer_vendor || 'unknown';
}
inherit(PlayOrigin, Serializable);

/**
 * What kind of options user has
 * with the player. By default
 * all 'can_*' properties are set to true.
 * You might want to restrict some of them
 * in the special cases like ads (no skipping)
 * or radio no skipping prev.
 * @constructor
 * @param {Object} options The options data.
 */
function PlayOptions(options) {
  Serializable.call(this, [
    'repeat',
    'shuffle',
    'can_repeat',
    'can_shuffle',
    'can_skip_prev',
    'can_skip_next',
    'can_seek',
    'use_dmca_rules'
  ]);
  options = options || {};

  /**
   * True if repeat (repeat all, not single track repeat) is (or is to be) enabled.
   *
   * Default value is false
   */
  this.repeat = options.repeat !== undefined ? options.repeat : false;

  /**
   * True if shuffle is (or is to be) enabled.
   *
   * Default value is false
   */
  this.shuffle = options.shuffle !== undefined ? options.shuffle : false;

  /**
   * True if this context can be repeated. This would be false for instance in the
   * case of radio.
   *
   * Default value is true.
   */
  this.can_repeat = options.can_repeat !== undefined ? options.can_repeat : true;

  /**
   * True if this context can be shuffled. This would be false for instance in the
   * case of radio.
   *
   * Default value is true.
   */
  this.can_shuffle = options.can_shuffle !== undefined ? options.can_shuffle : true;

  /**
   * True if the user is (or should be) allowed to skip to the previous track.
   *
   * Default value is true.
   */
  this.can_skip_prev = options.can_skip_prev !== undefined ? options.can_skip_prev : true;

  /**
   * True if the user is (or should be) allowed to skip to the next track.
   *
   * Default value is true.
   */
  this.can_skip_next = options.can_skip_next !== undefined ? options.can_skip_next : true;

  /**
   * True if the user is (or should be) allowed to seek to a certain time in the
   * currently playing track.
   *
   * Default value is true.
   */
  this.can_seek = options.can_seek !== undefined ? options.can_seek : true;

  /**
   * True if the track player should automatically apply DMCA rules when playing.
   * DMCA rules should be enabled for users that have free radio in the US, and
   * controls how many tracks the user are allowed to skip etc.
   *
   * Default value is false.
   */
  this.use_dmca_rules = options.use_dmca_rules !== undefined ? options.use_dmca_rules : false;
}
inherit(PlayOptions, Serializable);

/**
 * The object accepting only defined properties.
 * To make sure only valid properties are passed
 * always use 'serialize()' when object value needed.
 * @constructor
 * @param {Array.<string>} allowedProps The list of the properties
 * that are supported for the object.
 */
function Serializable(allowedProps) {
  this._props = allowedProps || [];
}

/**
 * The JSON representation of the object.
 * @return {Object} Data associated with current player state.
 */
Serializable.prototype.serialize = function() {
  var data = {};
  var prop;

  for (var i = 0, l = this._props.length; i < l; i++) {
    prop = this._props[i];
    if (this[prop] !== undefined) {
      if (this[prop] instanceof Serializable) {
        data[prop] = this[prop].serialize();
      } else {
        data[prop] = this[prop];
      }
    }
  }

  return data;
};

exports.PlayerState = PlayerState;

},{"spotify-inheritance":728}],380:[function(require,module,exports){
var inherit = require('spotify-inheritance').inherit;

var Message = require('./message').Message;

/**
 * Request actions.
 *
 * @name exports.Action
 * @enum {string}
 */
exports.Action = {
  DELETE: 'DELETE',
  GET: 'GET',
  HEAD: 'HEAD',
  POST: 'POST',
  PUT: 'PUT',
  SUB: 'SUB',
  PATCH: 'PATCH'
};

/**
 * A serialized Request object.
 *
 * @name Spotify.Cosmos.SerializedRequest
 * @typedef {{
 *   uri: Spotify.Cosmos.URI,
 *   headers: Spotify.Cosmos.Headers,
 *   body: Spotify.Cosmos.Body
 * }}
 */
exports.SerializedRequest;

/**
 * Encapsulates a request to the handlers.
 *
 * Instances of this class are "immutable" and should not be changed.
 *
 * @constructs Spotify.Cosmos.Request
 * @extends Spotify.Cosmos.Message
 * @param {Spotify.Cosmos.Action} action The action of the request.
 * @param {Spotify.Cosmos.URI} uri The URI of the request
 * @param {Spotify.Cosmos.Headers=} opt_headers The optional headers of the
 *     request.
 * @param {Spotify.Cosmos.Body=} opt_body The optional body of the request.
 */
function Request(action, uri, opt_headers, opt_body) {
  if (!(this instanceof Request))
    return new Request(action, uri, opt_headers, opt_body);
  if (!action)
    throw new TypeError('Invalid `action` argument for Request.');
  Message.call(this, uri, opt_headers, opt_body);

  /**
   * The action of the request.
   *
   * @type {Spotify.Cosmos.Action}
   * @protected
   */
  this._action = action;
}
inherit(Request, Message);
exports.Request = Request;

/**
 * Creates a new Request from a SerializedRequest object.
 *
 * @param {Spotify.Cosmos.SerializedRequest} object The serialized request.
 * @return {Spotify.Cosmos.Request|null} The new Request object or null.
 */
Request.fromObject = function(object) {
  return (object && object.action && object.uri) ?
    new Request(
        object.action,
        object.uri,
        object.headers,
        object.body
    ) : null;
};

/**
 * Returns the action of the request.
 *
 * @return {Spotify.Cosmos.Action} The action of the request.
 */
Request.prototype.getAction = function() {
  return this._action;
};

/**
 * @inheritDoc
 */
Request.prototype.copy = function(opt_headers, opt_body) {
  return new Request(
      this._action,
      this._uri,
      this._copyHeaders(opt_headers),
      typeof opt_body != 'undefined' ? opt_body : this._body
  );
};

/**
 * @inheritDoc
 */
Request.prototype.toJSON = function() {
  return {
    action: this._action,
    uri: this._uri,
    headers: this._headers,
    body: this._body
  };
};



},{"./message":378,"spotify-inheritance":728}],381:[function(require,module,exports){
var inherit = require('spotify-inheritance').inherit;

var Message = require('./message').Message;

/**
 * Statuscode.
 * The statuses with negative numbers are reserved for
 * errors that originate within the cosmos library.
 *
 * @name exports.StatusCode
 * @enum {number}
 */
exports.StatusCode = {
  OK: 200,
  CREATED: 201,
  ACCEPTED: 202,
  BAD_REQUEST: 400,
  UNAUTHORIZED: 401,
  FORBIDDEN: 403,
  NOT_FOUND: 404,
  METHOD_NOT_ALLOWED: 405,
  TIMED_OUT: 408,
  CONFLICT: 409,
  GONE: 410,
  INTERNAL_SERVER_ERROR: 500,
  NOT_IMPLEMENTED: 501,
  BAD_GATEWAY: 502,
  SERVICE_UNAVAILABLE: 503,

  /** Something went wrong, but the exact reason is not known. */
  ERROR_UNKNOWN: -100,

  /** A resource allocation required to complete the request failed. */
  ERROR_ALLOCATION_FAILED: -101,

  /** The body could not be decoded because it does
   not conform to the encoding header field. */
  ERROR_INVALID_ENCODING: -102,

  /** The router detected an infinite loop while processing the request. */
  ERROR_INFINITE_LOOP: -103,

  /** No endpoint resolver that could handle the request was found. */
  ERROR_RESOLVER_NOT_FOUND: -104
};

/**
 * A serialized Response object.
 *
 * @name Spotify.Cosmos.SerializedResponse
 * @typedef {{
 *   uri: Spotify.Cosmos.URI,
 *   status: Spotify.Cosmos.StatusCode,
 *   headers: Spotify.Cosmos.Headers,
 *   body: Spotify.Cosmos.Body
 * }}
 */
exports.SerializedResponse;

/**
 * Encapsulates a response from the handlers.
 *
 * @constructs Spotify.Cosmos.Response
 * @extends Spotify.Cosmos.Message
 * @param {Spotify.Cosmos.URI} uri The URI of the response
 * @param {Spotify.Cosmos.StatusCode} status The status of the response.
 * @param {Spotify.Cosmos.Headers=} opt_headers The optional headers of the
 *     response.
 * @param {Spotify.Cosmos.Body=} opt_body The optional body of the response.
 */
function Response(uri, status, opt_headers, opt_body) {
  if (!(this instanceof Response))
    return new Response(uri, status, opt_headers, opt_body, opt_requestURI);
  if (typeof status == 'undefined' || status == null)
    throw new TypeError('Invalid `status` argument for Response.');

  Message.call(this, uri, opt_headers, opt_body);

  /**
   * The Status of the Response.
   *
   * @type {Spotify.Cosmos.StatusCode}
   * @protected
   */
  this._status = status;
}
inherit(Response, Message);
exports.Response = Response;

/**
 * Creates a new Response from a SerializedResponse object.
 *
 * @param {Spotify.Cosmos.SerializedResponse} object The serialized response.
 * @return {Spotify.Cosmos.Response|null} The new Response object or null.
 */
Response.fromObject = function(object) {
  return (object && object.uri && object.status) ?
    new Response(
        object.uri,
        object.status,
        object.headers,
        object.body
    ) : null;
};

/**
 * @inheritDoc
 */
Response.prototype.getMimeType = function() {
  return this._headers['content-type'];
};

/**
 * Returns the status code of the Response.
 *
 * @return {Spotify.Cosmos.StatusCode} The status code of the response.
 */
Response.prototype.getStatusCode = function() {
  return this._status;
};

/**
 * @inheritDoc
 */
Response.prototype.copy = function(opt_headers, opt_body) {
  return new Response(
      this._uri,
      this._status,
      this._copyHeaders(opt_headers),
      typeof opt_body != 'undefined' ? opt_body : this._body
  );
};

/**
 * @inheritDoc
 */
Response.prototype.toJSON = function() {
  return {
    uri: this._uri,
    status: this._status,
    headers: this._headers,
    body: this._body
  };
};


},{"./message":378,"spotify-inheritance":728}],382:[function(require,module,exports){
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */

'use strict';

var _assign = require('object-assign');

var emptyObject = require('fbjs/lib/emptyObject');
var _invariant = require('fbjs/lib/invariant');

if ("production" !== 'production') {
  var warning = require('fbjs/lib/warning');
}

var MIXINS_KEY = 'mixins';

// Helper function to allow the creation of anonymous functions which do not
// have .name set to the name of the variable being assigned to.
function identity(fn) {
  return fn;
}

var ReactPropTypeLocationNames;
if ("production" !== 'production') {
  ReactPropTypeLocationNames = {
    prop: 'prop',
    context: 'context',
    childContext: 'child context'
  };
} else {
  ReactPropTypeLocationNames = {};
}

function factory(ReactComponent, isValidElement, ReactNoopUpdateQueue) {
  /**
   * Policies that describe methods in `ReactClassInterface`.
   */

  var injectedMixins = [];

  /**
   * Composite components are higher-level components that compose other composite
   * or host components.
   *
   * To create a new type of `ReactClass`, pass a specification of
   * your new class to `React.createClass`. The only requirement of your class
   * specification is that you implement a `render` method.
   *
   *   var MyComponent = React.createClass({
   *     render: function() {
   *       return <div>Hello World</div>;
   *     }
   *   });
   *
   * The class specification supports a specific protocol of methods that have
   * special meaning (e.g. `render`). See `ReactClassInterface` for
   * more the comprehensive protocol. Any other properties and methods in the
   * class specification will be available on the prototype.
   *
   * @interface ReactClassInterface
   * @internal
   */
  var ReactClassInterface = {
    /**
     * An array of Mixin objects to include when defining your component.
     *
     * @type {array}
     * @optional
     */
    mixins: 'DEFINE_MANY',

    /**
     * An object containing properties and methods that should be defined on
     * the component's constructor instead of its prototype (static methods).
     *
     * @type {object}
     * @optional
     */
    statics: 'DEFINE_MANY',

    /**
     * Definition of prop types for this component.
     *
     * @type {object}
     * @optional
     */
    propTypes: 'DEFINE_MANY',

    /**
     * Definition of context types for this component.
     *
     * @type {object}
     * @optional
     */
    contextTypes: 'DEFINE_MANY',

    /**
     * Definition of context types this component sets for its children.
     *
     * @type {object}
     * @optional
     */
    childContextTypes: 'DEFINE_MANY',

    // ==== Definition methods ====

    /**
     * Invoked when the component is mounted. Values in the mapping will be set on
     * `this.props` if that prop is not specified (i.e. using an `in` check).
     *
     * This method is invoked before `getInitialState` and therefore cannot rely
     * on `this.state` or use `this.setState`.
     *
     * @return {object}
     * @optional
     */
    getDefaultProps: 'DEFINE_MANY_MERGED',

    /**
     * Invoked once before the component is mounted. The return value will be used
     * as the initial value of `this.state`.
     *
     *   getInitialState: function() {
     *     return {
     *       isOn: false,
     *       fooBaz: new BazFoo()
     *     }
     *   }
     *
     * @return {object}
     * @optional
     */
    getInitialState: 'DEFINE_MANY_MERGED',

    /**
     * @return {object}
     * @optional
     */
    getChildContext: 'DEFINE_MANY_MERGED',

    /**
     * Uses props from `this.props` and state from `this.state` to render the
     * structure of the component.
     *
     * No guarantees are made about when or how often this method is invoked, so
     * it must not have side effects.
     *
     *   render: function() {
     *     var name = this.props.name;
     *     return <div>Hello, {name}!</div>;
     *   }
     *
     * @return {ReactComponent}
     * @required
     */
    render: 'DEFINE_ONCE',

    // ==== Delegate methods ====

    /**
     * Invoked when the component is initially created and about to be mounted.
     * This may have side effects, but any external subscriptions or data created
     * by this method must be cleaned up in `componentWillUnmount`.
     *
     * @optional
     */
    componentWillMount: 'DEFINE_MANY',

    /**
     * Invoked when the component has been mounted and has a DOM representation.
     * However, there is no guarantee that the DOM node is in the document.
     *
     * Use this as an opportunity to operate on the DOM when the component has
     * been mounted (initialized and rendered) for the first time.
     *
     * @param {DOMElement} rootNode DOM element representing the component.
     * @optional
     */
    componentDidMount: 'DEFINE_MANY',

    /**
     * Invoked before the component receives new props.
     *
     * Use this as an opportunity to react to a prop transition by updating the
     * state using `this.setState`. Current props are accessed via `this.props`.
     *
     *   componentWillReceiveProps: function(nextProps, nextContext) {
     *     this.setState({
     *       likesIncreasing: nextProps.likeCount > this.props.likeCount
     *     });
     *   }
     *
     * NOTE: There is no equivalent `componentWillReceiveState`. An incoming prop
     * transition may cause a state change, but the opposite is not true. If you
     * need it, you are probably looking for `componentWillUpdate`.
     *
     * @param {object} nextProps
     * @optional
     */
    componentWillReceiveProps: 'DEFINE_MANY',

    /**
     * Invoked while deciding if the component should be updated as a result of
     * receiving new props, state and/or context.
     *
     * Use this as an opportunity to `return false` when you're certain that the
     * transition to the new props/state/context will not require a component
     * update.
     *
     *   shouldComponentUpdate: function(nextProps, nextState, nextContext) {
     *     return !equal(nextProps, this.props) ||
     *       !equal(nextState, this.state) ||
     *       !equal(nextContext, this.context);
     *   }
     *
     * @param {object} nextProps
     * @param {?object} nextState
     * @param {?object} nextContext
     * @return {boolean} True if the component should update.
     * @optional
     */
    shouldComponentUpdate: 'DEFINE_ONCE',

    /**
     * Invoked when the component is about to update due to a transition from
     * `this.props`, `this.state` and `this.context` to `nextProps`, `nextState`
     * and `nextContext`.
     *
     * Use this as an opportunity to perform preparation before an update occurs.
     *
     * NOTE: You **cannot** use `this.setState()` in this method.
     *
     * @param {object} nextProps
     * @param {?object} nextState
     * @param {?object} nextContext
     * @param {ReactReconcileTransaction} transaction
     * @optional
     */
    componentWillUpdate: 'DEFINE_MANY',

    /**
     * Invoked when the component's DOM representation has been updated.
     *
     * Use this as an opportunity to operate on the DOM when the component has
     * been updated.
     *
     * @param {object} prevProps
     * @param {?object} prevState
     * @param {?object} prevContext
     * @param {DOMElement} rootNode DOM element representing the component.
     * @optional
     */
    componentDidUpdate: 'DEFINE_MANY',

    /**
     * Invoked when the component is about to be removed from its parent and have
     * its DOM representation destroyed.
     *
     * Use this as an opportunity to deallocate any external resources.
     *
     * NOTE: There is no `componentDidUnmount` since your component will have been
     * destroyed by that point.
     *
     * @optional
     */
    componentWillUnmount: 'DEFINE_MANY',

    // ==== Advanced methods ====

    /**
     * Updates the component's currently mounted DOM representation.
     *
     * By default, this implements React's rendering and reconciliation algorithm.
     * Sophisticated clients may wish to override this.
     *
     * @param {ReactReconcileTransaction} transaction
     * @internal
     * @overridable
     */
    updateComponent: 'OVERRIDE_BASE'
  };

  /**
   * Mapping from class specification keys to special processing functions.
   *
   * Although these are declared like instance properties in the specification
   * when defining classes using `React.createClass`, they are actually static
   * and are accessible on the constructor instead of the prototype. Despite
   * being static, they must be defined outside of the "statics" key under
   * which all other static methods are defined.
   */
  var RESERVED_SPEC_KEYS = {
    displayName: function(Constructor, displayName) {
      Constructor.displayName = displayName;
    },
    mixins: function(Constructor, mixins) {
      if (mixins) {
        for (var i = 0; i < mixins.length; i++) {
          mixSpecIntoComponent(Constructor, mixins[i]);
        }
      }
    },
    childContextTypes: function(Constructor, childContextTypes) {
      if ("production" !== 'production') {
        validateTypeDef(Constructor, childContextTypes, 'childContext');
      }
      Constructor.childContextTypes = _assign(
        {},
        Constructor.childContextTypes,
        childContextTypes
      );
    },
    contextTypes: function(Constructor, contextTypes) {
      if ("production" !== 'production') {
        validateTypeDef(Constructor, contextTypes, 'context');
      }
      Constructor.contextTypes = _assign(
        {},
        Constructor.contextTypes,
        contextTypes
      );
    },
    /**
     * Special case getDefaultProps which should move into statics but requires
     * automatic merging.
     */
    getDefaultProps: function(Constructor, getDefaultProps) {
      if (Constructor.getDefaultProps) {
        Constructor.getDefaultProps = createMergedResultFunction(
          Constructor.getDefaultProps,
          getDefaultProps
        );
      } else {
        Constructor.getDefaultProps = getDefaultProps;
      }
    },
    propTypes: function(Constructor, propTypes) {
      if ("production" !== 'production') {
        validateTypeDef(Constructor, propTypes, 'prop');
      }
      Constructor.propTypes = _assign({}, Constructor.propTypes, propTypes);
    },
    statics: function(Constructor, statics) {
      mixStaticSpecIntoComponent(Constructor, statics);
    },
    autobind: function() {}
  };

  function validateTypeDef(Constructor, typeDef, location) {
    for (var propName in typeDef) {
      if (typeDef.hasOwnProperty(propName)) {
        // use a warning instead of an _invariant so components
        // don't show up in prod but only in __DEV__
        if ("production" !== 'production') {
          warning(
            typeof typeDef[propName] === 'function',
            '%s: %s type `%s` is invalid; it must be a function, usually from ' +
              'React.PropTypes.',
            Constructor.displayName || 'ReactClass',
            ReactPropTypeLocationNames[location],
            propName
          );
        }
      }
    }
  }

  function validateMethodOverride(isAlreadyDefined, name) {
    var specPolicy = ReactClassInterface.hasOwnProperty(name)
      ? ReactClassInterface[name]
      : null;

    // Disallow overriding of base class methods unless explicitly allowed.
    if (ReactClassMixin.hasOwnProperty(name)) {
      _invariant(
        specPolicy === 'OVERRIDE_BASE',
        'ReactClassInterface: You are attempting to override ' +
          '`%s` from your class specification. Ensure that your method names ' +
          'do not overlap with React methods.',
        name
      );
    }

    // Disallow defining methods more than once unless explicitly allowed.
    if (isAlreadyDefined) {
      _invariant(
        specPolicy === 'DEFINE_MANY' || specPolicy === 'DEFINE_MANY_MERGED',
        'ReactClassInterface: You are attempting to define ' +
          '`%s` on your component more than once. This conflict may be due ' +
          'to a mixin.',
        name
      );
    }
  }

  /**
   * Mixin helper which handles policy validation and reserved
   * specification keys when building React classes.
   */
  function mixSpecIntoComponent(Constructor, spec) {
    if (!spec) {
      if ("production" !== 'production') {
        var typeofSpec = typeof spec;
        var isMixinValid = typeofSpec === 'object' && spec !== null;

        if ("production" !== 'production') {
          warning(
            isMixinValid,
            "%s: You're attempting to include a mixin that is either null " +
              'or not an object. Check the mixins included by the component, ' +
              'as well as any mixins they include themselves. ' +
              'Expected object but got %s.',
            Constructor.displayName || 'ReactClass',
            spec === null ? null : typeofSpec
          );
        }
      }

      return;
    }

    _invariant(
      typeof spec !== 'function',
      "ReactClass: You're attempting to " +
        'use a component class or function as a mixin. Instead, just use a ' +
        'regular object.'
    );
    _invariant(
      !isValidElement(spec),
      "ReactClass: You're attempting to " +
        'use a component as a mixin. Instead, just use a regular object.'
    );

    var proto = Constructor.prototype;
    var autoBindPairs = proto.__reactAutoBindPairs;

    // By handling mixins before any other properties, we ensure the same
    // chaining order is applied to methods with DEFINE_MANY policy, whether
    // mixins are listed before or after these methods in the spec.
    if (spec.hasOwnProperty(MIXINS_KEY)) {
      RESERVED_SPEC_KEYS.mixins(Constructor, spec.mixins);
    }

    for (var name in spec) {
      if (!spec.hasOwnProperty(name)) {
        continue;
      }

      if (name === MIXINS_KEY) {
        // We have already handled mixins in a special case above.
        continue;
      }

      var property = spec[name];
      var isAlreadyDefined = proto.hasOwnProperty(name);
      validateMethodOverride(isAlreadyDefined, name);

      if (RESERVED_SPEC_KEYS.hasOwnProperty(name)) {
        RESERVED_SPEC_KEYS[name](Constructor, property);
      } else {
        // Setup methods on prototype:
        // The following member methods should not be automatically bound:
        // 1. Expected ReactClass methods (in the "interface").
        // 2. Overridden methods (that were mixed in).
        var isReactClassMethod = ReactClassInterface.hasOwnProperty(name);
        var isFunction = typeof property === 'function';
        var shouldAutoBind =
          isFunction &&
          !isReactClassMethod &&
          !isAlreadyDefined &&
          spec.autobind !== false;

        if (shouldAutoBind) {
          autoBindPairs.push(name, property);
          proto[name] = property;
        } else {
          if (isAlreadyDefined) {
            var specPolicy = ReactClassInterface[name];

            // These cases should already be caught by validateMethodOverride.
            _invariant(
              isReactClassMethod &&
                (specPolicy === 'DEFINE_MANY_MERGED' ||
                  specPolicy === 'DEFINE_MANY'),
              'ReactClass: Unexpected spec policy %s for key %s ' +
                'when mixing in component specs.',
              specPolicy,
              name
            );

            // For methods which are defined more than once, call the existing
            // methods before calling the new property, merging if appropriate.
            if (specPolicy === 'DEFINE_MANY_MERGED') {
              proto[name] = createMergedResultFunction(proto[name], property);
            } else if (specPolicy === 'DEFINE_MANY') {
              proto[name] = createChainedFunction(proto[name], property);
            }
          } else {
            proto[name] = property;
            if ("production" !== 'production') {
              // Add verbose displayName to the function, which helps when looking
              // at profiling tools.
              if (typeof property === 'function' && spec.displayName) {
                proto[name].displayName = spec.displayName + '_' + name;
              }
            }
          }
        }
      }
    }
  }

  function mixStaticSpecIntoComponent(Constructor, statics) {
    if (!statics) {
      return;
    }
    for (var name in statics) {
      var property = statics[name];
      if (!statics.hasOwnProperty(name)) {
        continue;
      }

      var isReserved = name in RESERVED_SPEC_KEYS;
      _invariant(
        !isReserved,
        'ReactClass: You are attempting to define a reserved ' +
          'property, `%s`, that shouldn\'t be on the "statics" key. Define it ' +
          'as an instance property instead; it will still be accessible on the ' +
          'constructor.',
        name
      );

      var isInherited = name in Constructor;
      _invariant(
        !isInherited,
        'ReactClass: You are attempting to define ' +
          '`%s` on your component more than once. This conflict may be ' +
          'due to a mixin.',
        name
      );
      Constructor[name] = property;
    }
  }

  /**
   * Merge two objects, but throw if both contain the same key.
   *
   * @param {object} one The first object, which is mutated.
   * @param {object} two The second object
   * @return {object} one after it has been mutated to contain everything in two.
   */
  function mergeIntoWithNoDuplicateKeys(one, two) {
    _invariant(
      one && two && typeof one === 'object' && typeof two === 'object',
      'mergeIntoWithNoDuplicateKeys(): Cannot merge non-objects.'
    );

    for (var key in two) {
      if (two.hasOwnProperty(key)) {
        _invariant(
          one[key] === undefined,
          'mergeIntoWithNoDuplicateKeys(): ' +
            'Tried to merge two objects with the same key: `%s`. This conflict ' +
            'may be due to a mixin; in particular, this may be caused by two ' +
            'getInitialState() or getDefaultProps() methods returning objects ' +
            'with clashing keys.',
          key
        );
        one[key] = two[key];
      }
    }
    return one;
  }

  /**
   * Creates a function that invokes two functions and merges their return values.
   *
   * @param {function} one Function to invoke first.
   * @param {function} two Function to invoke second.
   * @return {function} Function that invokes the two argument functions.
   * @private
   */
  function createMergedResultFunction(one, two) {
    return function mergedResult() {
      var a = one.apply(this, arguments);
      var b = two.apply(this, arguments);
      if (a == null) {
        return b;
      } else if (b == null) {
        return a;
      }
      var c = {};
      mergeIntoWithNoDuplicateKeys(c, a);
      mergeIntoWithNoDuplicateKeys(c, b);
      return c;
    };
  }

  /**
   * Creates a function that invokes two functions and ignores their return vales.
   *
   * @param {function} one Function to invoke first.
   * @param {function} two Function to invoke second.
   * @return {function} Function that invokes the two argument functions.
   * @private
   */
  function createChainedFunction(one, two) {
    return function chainedFunction() {
      one.apply(this, arguments);
      two.apply(this, arguments);
    };
  }

  /**
   * Binds a method to the component.
   *
   * @param {object} component Component whose method is going to be bound.
   * @param {function} method Method to be bound.
   * @return {function} The bound method.
   */
  function bindAutoBindMethod(component, method) {
    var boundMethod = method.bind(component);
    if ("production" !== 'production') {
      boundMethod.__reactBoundContext = component;
      boundMethod.__reactBoundMethod = method;
      boundMethod.__reactBoundArguments = null;
      var componentName = component.constructor.displayName;
      var _bind = boundMethod.bind;
      boundMethod.bind = function(newThis) {
        for (
          var _len = arguments.length,
            args = Array(_len > 1 ? _len - 1 : 0),
            _key = 1;
          _key < _len;
          _key++
        ) {
          args[_key - 1] = arguments[_key];
        }

        // User is trying to bind() an autobound method; we effectively will
        // ignore the value of "this" that the user is trying to use, so
        // let's warn.
        if (newThis !== component && newThis !== null) {
          if ("production" !== 'production') {
            warning(
              false,
              'bind(): React component methods may only be bound to the ' +
                'component instance. See %s',
              componentName
            );
          }
        } else if (!args.length) {
          if ("production" !== 'production') {
            warning(
              false,
              'bind(): You are binding a component method to the component. ' +
                'React does this for you automatically in a high-performance ' +
                'way, so you can safely remove this call. See %s',
              componentName
            );
          }
          return boundMethod;
        }
        var reboundMethod = _bind.apply(boundMethod, arguments);
        reboundMethod.__reactBoundContext = component;
        reboundMethod.__reactBoundMethod = method;
        reboundMethod.__reactBoundArguments = args;
        return reboundMethod;
      };
    }
    return boundMethod;
  }

  /**
   * Binds all auto-bound methods in a component.
   *
   * @param {object} component Component whose method is going to be bound.
   */
  function bindAutoBindMethods(component) {
    var pairs = component.__reactAutoBindPairs;
    for (var i = 0; i < pairs.length; i += 2) {
      var autoBindKey = pairs[i];
      var method = pairs[i + 1];
      component[autoBindKey] = bindAutoBindMethod(component, method);
    }
  }

  var IsMountedPreMixin = {
    componentDidMount: function() {
      this.__isMounted = true;
    }
  };

  var IsMountedPostMixin = {
    componentWillUnmount: function() {
      this.__isMounted = false;
    }
  };

  /**
   * Add more to the ReactClass base class. These are all legacy features and
   * therefore not already part of the modern ReactComponent.
   */
  var ReactClassMixin = {
    /**
     * TODO: This will be deprecated because state should always keep a consistent
     * type signature and the only use case for this, is to avoid that.
     */
    replaceState: function(newState, callback) {
      this.updater.enqueueReplaceState(this, newState, callback);
    },

    /**
     * Checks whether or not this composite component is mounted.
     * @return {boolean} True if mounted, false otherwise.
     * @protected
     * @final
     */
    isMounted: function() {
      if ("production" !== 'production') {
        warning(
          this.__didWarnIsMounted,
          '%s: isMounted is deprecated. Instead, make sure to clean up ' +
            'subscriptions and pending requests in componentWillUnmount to ' +
            'prevent memory leaks.',
          (this.constructor && this.constructor.displayName) ||
            this.name ||
            'Component'
        );
        this.__didWarnIsMounted = true;
      }
      return !!this.__isMounted;
    }
  };

  var ReactClassComponent = function() {};
  _assign(
    ReactClassComponent.prototype,
    ReactComponent.prototype,
    ReactClassMixin
  );

  /**
   * Creates a composite component class given a class specification.
   * See https://facebook.github.io/react/docs/top-level-api.html#react.createclass
   *
   * @param {object} spec Class specification (which must define `render`).
   * @return {function} Component constructor function.
   * @public
   */
  function createClass(spec) {
    // To keep our warnings more understandable, we'll use a little hack here to
    // ensure that Constructor.name !== 'Constructor'. This makes sure we don't
    // unnecessarily identify a class without displayName as 'Constructor'.
    var Constructor = identity(function(props, context, updater) {
      // This constructor gets overridden by mocks. The argument is used
      // by mocks to assert on what gets mounted.

      if ("production" !== 'production') {
        warning(
          this instanceof Constructor,
          'Something is calling a React component directly. Use a factory or ' +
            'JSX instead. See: https://fb.me/react-legacyfactory'
        );
      }

      // Wire up auto-binding
      if (this.__reactAutoBindPairs.length) {
        bindAutoBindMethods(this);
      }

      this.props = props;
      this.context = context;
      this.refs = emptyObject;
      this.updater = updater || ReactNoopUpdateQueue;

      this.state = null;

      // ReactClasses doesn't have constructors. Instead, they use the
      // getInitialState and componentWillMount methods for initialization.

      var initialState = this.getInitialState ? this.getInitialState() : null;
      if ("production" !== 'production') {
        // We allow auto-mocks to proceed as if they're returning null.
        if (
          initialState === undefined &&
          this.getInitialState._isMockFunction
        ) {
          // This is probably bad practice. Consider warning here and
          // deprecating this convenience.
          initialState = null;
        }
      }
      _invariant(
        typeof initialState === 'object' && !Array.isArray(initialState),
        '%s.getInitialState(): must return an object or null',
        Constructor.displayName || 'ReactCompositeComponent'
      );

      this.state = initialState;
    });
    Constructor.prototype = new ReactClassComponent();
    Constructor.prototype.constructor = Constructor;
    Constructor.prototype.__reactAutoBindPairs = [];

    injectedMixins.forEach(mixSpecIntoComponent.bind(null, Constructor));

    mixSpecIntoComponent(Constructor, IsMountedPreMixin);
    mixSpecIntoComponent(Constructor, spec);
    mixSpecIntoComponent(Constructor, IsMountedPostMixin);

    // Initialize the defaultProps property after all mixins have been merged.
    if (Constructor.getDefaultProps) {
      Constructor.defaultProps = Constructor.getDefaultProps();
    }

    if ("production" !== 'production') {
      // This is a tag to indicate that the use of these method names is ok,
      // since it's used with createClass. If it's not, then it's likely a
      // mistake so we'll warn you to use the static property, property
      // initializer or constructor respectively.
      if (Constructor.getDefaultProps) {
        Constructor.getDefaultProps.isReactClassApproved = {};
      }
      if (Constructor.prototype.getInitialState) {
        Constructor.prototype.getInitialState.isReactClassApproved = {};
      }
    }

    _invariant(
      Constructor.prototype.render,
      'createClass(...): Class specification must implement a `render` method.'
    );

    if ("production" !== 'production') {
      warning(
        !Constructor.prototype.componentShouldUpdate,
        '%s has a method called ' +
          'componentShouldUpdate(). Did you mean shouldComponentUpdate()? ' +
          'The name is phrased as a question because the function is ' +
          'expected to return a value.',
        spec.displayName || 'A component'
      );
      warning(
        !Constructor.prototype.componentWillRecieveProps,
        '%s has a method called ' +
          'componentWillRecieveProps(). Did you mean componentWillReceiveProps()?',
        spec.displayName || 'A component'
      );
    }

    // Reduce time spent doing lookups by setting these on the prototype.
    for (var methodName in ReactClassInterface) {
      if (!Constructor.prototype[methodName]) {
        Constructor.prototype[methodName] = null;
      }
    }

    return Constructor;
  }

  return createClass;
}

module.exports = factory;

},{"fbjs/lib/emptyObject":395,"fbjs/lib/invariant":402,"fbjs/lib/warning":409,"object-assign":489}],383:[function(require,module,exports){
(function (process){
/**
 * This is the web browser implementation of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = require('./debug');
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = 'undefined' != typeof chrome
               && 'undefined' != typeof chrome.storage
                  ? chrome.storage.local
                  : localstorage();

/**
 * Colors.
 */

exports.colors = [
  'lightseagreen',
  'forestgreen',
  'goldenrod',
  'dodgerblue',
  'darkorchid',
  'crimson'
];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

function useColors() {
  // NB: In an Electron preload script, document will be defined but not fully
  // initialized. Since we know we're in Chrome, we'll just detect this case
  // explicitly
  if (typeof window !== 'undefined' && window.process && window.process.type === 'renderer') {
    return true;
  }

  // is webkit? http://stackoverflow.com/a/16459606/376773
  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
  return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||
    // is firebug? http://stackoverflow.com/a/398120/376773
    (typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||
    // is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||
    // double check webkit in userAgent just in case we are in a worker
    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
}

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

exports.formatters.j = function(v) {
  try {
    return JSON.stringify(v);
  } catch (err) {
    return '[UnexpectedJSONParseError]: ' + err.message;
  }
};


/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs(args) {
  var useColors = this.useColors;

  args[0] = (useColors ? '%c' : '')
    + this.namespace
    + (useColors ? ' %c' : ' ')
    + args[0]
    + (useColors ? '%c ' : ' ')
    + '+' + exports.humanize(this.diff);

  if (!useColors) return;

  var c = 'color: ' + this.color;
  args.splice(1, 0, c, 'color: inherit')

  // the final "%c" is somewhat tricky, because there could be other
  // arguments passed either before or after the %c, so we need to
  // figure out the correct index to insert the CSS into
  var index = 0;
  var lastC = 0;
  args[0].replace(/%[a-zA-Z%]/g, function(match) {
    if ('%%' === match) return;
    index++;
    if ('%c' === match) {
      // we only are interested in the *last* %c
      // (the user may have provided their own)
      lastC = index;
    }
  });

  args.splice(lastC, 0, c);
}

/**
 * Invokes `console.log()` when available.
 * No-op when `console.log` is not a "function".
 *
 * @api public
 */

function log() {
  // this hackery is required for IE8/9, where
  // the `console.log` function doesn't have 'apply'
  return 'object' === typeof console
    && console.log
    && Function.prototype.apply.call(console.log, console, arguments);
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */

function save(namespaces) {
  try {
    if (null == namespaces) {
      exports.storage.removeItem('debug');
    } else {
      exports.storage.debug = namespaces;
    }
  } catch(e) {}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
  var r;
  try {
    r = exports.storage.debug;
  } catch(e) {}

  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG
  if (!r && typeof process !== 'undefined' && 'env' in process) {
    r = process.env.DEBUG;
  }

  return r;
}

/**
 * Enable namespaces listed in `localStorage.debug` initially.
 */

exports.enable(load());

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage() {
  try {
    return window.localStorage;
  } catch (e) {}
}

}).call(this,require('_process'))
},{"./debug":384,"_process":490}],384:[function(require,module,exports){

/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = createDebug.debug = createDebug['default'] = createDebug;
exports.coerce = coerce;
exports.disable = disable;
exports.enable = enable;
exports.enabled = enabled;
exports.humanize = require('ms');

/**
 * The currently active debug mode names, and names to skip.
 */

exports.names = [];
exports.skips = [];

/**
 * Map of special "%n" handling functions, for the debug "format" argument.
 *
 * Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
 */

exports.formatters = {};

/**
 * Previous log timestamp.
 */

var prevTime;

/**
 * Select a color.
 * @param {String} namespace
 * @return {Number}
 * @api private
 */

function selectColor(namespace) {
  var hash = 0, i;

  for (i in namespace) {
    hash  = ((hash << 5) - hash) + namespace.charCodeAt(i);
    hash |= 0; // Convert to 32bit integer
  }

  return exports.colors[Math.abs(hash) % exports.colors.length];
}

/**
 * Create a debugger with the given `namespace`.
 *
 * @param {String} namespace
 * @return {Function}
 * @api public
 */

function createDebug(namespace) {

  function debug() {
    // disabled?
    if (!debug.enabled) return;

    var self = debug;

    // set `diff` timestamp
    var curr = +new Date();
    var ms = curr - (prevTime || curr);
    self.diff = ms;
    self.prev = prevTime;
    self.curr = curr;
    prevTime = curr;

    // turn the `arguments` into a proper Array
    var args = new Array(arguments.length);
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }

    args[0] = exports.coerce(args[0]);

    if ('string' !== typeof args[0]) {
      // anything else let's inspect with %O
      args.unshift('%O');
    }

    // apply any `formatters` transformations
    var index = 0;
    args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {
      // if we encounter an escaped % then don't increase the array index
      if (match === '%%') return match;
      index++;
      var formatter = exports.formatters[format];
      if ('function' === typeof formatter) {
        var val = args[index];
        match = formatter.call(self, val);

        // now we need to remove `args[index]` since it's inlined in the `format`
        args.splice(index, 1);
        index--;
      }
      return match;
    });

    // apply env-specific formatting (colors, etc.)
    exports.formatArgs.call(self, args);

    var logFn = debug.log || exports.log || console.log.bind(console);
    logFn.apply(self, args);
  }

  debug.namespace = namespace;
  debug.enabled = exports.enabled(namespace);
  debug.useColors = exports.useColors();
  debug.color = selectColor(namespace);

  // env-specific initialization logic for debug instances
  if ('function' === typeof exports.init) {
    exports.init(debug);
  }

  return debug;
}

/**
 * Enables a debug mode by namespaces. This can include modes
 * separated by a colon and wildcards.
 *
 * @param {String} namespaces
 * @api public
 */

function enable(namespaces) {
  exports.save(namespaces);

  exports.names = [];
  exports.skips = [];

  var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
  var len = split.length;

  for (var i = 0; i < len; i++) {
    if (!split[i]) continue; // ignore empty strings
    namespaces = split[i].replace(/\*/g, '.*?');
    if (namespaces[0] === '-') {
      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
    } else {
      exports.names.push(new RegExp('^' + namespaces + '$'));
    }
  }
}

/**
 * Disable debug output.
 *
 * @api public
 */

function disable() {
  exports.enable('');
}

/**
 * Returns true if the given mode name is enabled, false otherwise.
 *
 * @param {String} name
 * @return {Boolean}
 * @api public
 */

function enabled(name) {
  var i, len;
  for (i = 0, len = exports.skips.length; i < len; i++) {
    if (exports.skips[i].test(name)) {
      return false;
    }
  }
  for (i = 0, len = exports.names.length; i < len; i++) {
    if (exports.names[i].test(name)) {
      return true;
    }
  }
  return false;
}

/**
 * Coerce `val`.
 *
 * @param {Mixed} val
 * @return {Mixed}
 * @api private
 */

function coerce(val) {
  if (val instanceof Error) return val.stack || val.message;
  return val;
}

},{"ms":488}],385:[function(require,module,exports){
(function (global){
/*!
 * deep-diff.
 * Licensed under the MIT License.
 */
;(function(root, factory) {
  'use strict';
  if (typeof define === 'function' && define.amd) {
    // AMD. Register as an anonymous module.
    define([], function() {
      return factory();
    });
  } else if (typeof exports === 'object') {
    // Node. Does not work with strict CommonJS, but
    // only CommonJS-like environments that support module.exports,
    // like Node.
    module.exports = factory();
  } else {
    // Browser globals (root is window)
    root.DeepDiff = factory();
  }
}(this, function(undefined) {
  'use strict';

  var $scope, conflict, conflictResolution = [];
  if (typeof global === 'object' && global) {
    $scope = global;
  } else if (typeof window !== 'undefined') {
    $scope = window;
  } else {
    $scope = {};
  }
  conflict = $scope.DeepDiff;
  if (conflict) {
    conflictResolution.push(
      function() {
        if ('undefined' !== typeof conflict && $scope.DeepDiff === accumulateDiff) {
          $scope.DeepDiff = conflict;
          conflict = undefined;
        }
      });
  }

  // nodejs compatible on server side and in the browser.
  function inherits(ctor, superCtor) {
    ctor.super_ = superCtor;
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  }

  function Diff(kind, path) {
    Object.defineProperty(this, 'kind', {
      value: kind,
      enumerable: true
    });
    if (path && path.length) {
      Object.defineProperty(this, 'path', {
        value: path,
        enumerable: true
      });
    }
  }

  function DiffEdit(path, origin, value) {
    DiffEdit.super_.call(this, 'E', path);
    Object.defineProperty(this, 'lhs', {
      value: origin,
      enumerable: true
    });
    Object.defineProperty(this, 'rhs', {
      value: value,
      enumerable: true
    });
  }
  inherits(DiffEdit, Diff);

  function DiffNew(path, value) {
    DiffNew.super_.call(this, 'N', path);
    Object.defineProperty(this, 'rhs', {
      value: value,
      enumerable: true
    });
  }
  inherits(DiffNew, Diff);

  function DiffDeleted(path, value) {
    DiffDeleted.super_.call(this, 'D', path);
    Object.defineProperty(this, 'lhs', {
      value: value,
      enumerable: true
    });
  }
  inherits(DiffDeleted, Diff);

  function DiffArray(path, index, item) {
    DiffArray.super_.call(this, 'A', path);
    Object.defineProperty(this, 'index', {
      value: index,
      enumerable: true
    });
    Object.defineProperty(this, 'item', {
      value: item,
      enumerable: true
    });
  }
  inherits(DiffArray, Diff);

  function arrayRemove(arr, from, to) {
    var rest = arr.slice((to || from) + 1 || arr.length);
    arr.length = from < 0 ? arr.length + from : from;
    arr.push.apply(arr, rest);
    return arr;
  }

  function realTypeOf(subject) {
    var type = typeof subject;
    if (type !== 'object') {
      return type;
    }

    if (subject === Math) {
      return 'math';
    } else if (subject === null) {
      return 'null';
    } else if (Array.isArray(subject)) {
      return 'array';
    } else if (Object.prototype.toString.call(subject) === '[object Date]') {
      return 'date';
    } else if (typeof subject.toString !== 'undefined' && /^\/.*\//.test(subject.toString())) {
      return 'regexp';
    }
    return 'object';
  }

  function deepDiff(lhs, rhs, changes, prefilter, path, key, stack) {
    path = path || [];
    var currentPath = path.slice(0);
    if (typeof key !== 'undefined') {
      if (prefilter) {
        if (typeof(prefilter) === 'function' && prefilter(currentPath, key)) { return; }
        else if (typeof(prefilter) === 'object') {
          if (prefilter.prefilter && prefilter.prefilter(currentPath, key)) { return; }
          if (prefilter.normalize) {
            var alt = prefilter.normalize(currentPath, key, lhs, rhs);
            if (alt) {
              lhs = alt[0];
              rhs = alt[1];
            }
          }
        }
      }
      currentPath.push(key);
    }

    // Use string comparison for regexes
    if (realTypeOf(lhs) === 'regexp' && realTypeOf(rhs) === 'regexp') {
      lhs = lhs.toString();
      rhs = rhs.toString();
    }

    var ltype = typeof lhs;
    var rtype = typeof rhs;
    if (ltype === 'undefined') {
      if (rtype !== 'undefined') {
        changes(new DiffNew(currentPath, rhs));
      }
    } else if (rtype === 'undefined') {
      changes(new DiffDeleted(currentPath, lhs));
    } else if (realTypeOf(lhs) !== realTypeOf(rhs)) {
      changes(new DiffEdit(currentPath, lhs, rhs));
    } else if (Object.prototype.toString.call(lhs) === '[object Date]' && Object.prototype.toString.call(rhs) === '[object Date]' && ((lhs - rhs) !== 0)) {
      changes(new DiffEdit(currentPath, lhs, rhs));
    } else if (ltype === 'object' && lhs !== null && rhs !== null) {
      stack = stack || [];
      if (stack.indexOf(lhs) < 0) {
        stack.push(lhs);
        if (Array.isArray(lhs)) {
          var i, len = lhs.length;
          for (i = 0; i < lhs.length; i++) {
            if (i >= rhs.length) {
              changes(new DiffArray(currentPath, i, new DiffDeleted(undefined, lhs[i])));
            } else {
              deepDiff(lhs[i], rhs[i], changes, prefilter, currentPath, i, stack);
            }
          }
          while (i < rhs.length) {
            changes(new DiffArray(currentPath, i, new DiffNew(undefined, rhs[i++])));
          }
        } else {
          var akeys = Object.keys(lhs);
          var pkeys = Object.keys(rhs);
          akeys.forEach(function(k, i) {
            var other = pkeys.indexOf(k);
            if (other >= 0) {
              deepDiff(lhs[k], rhs[k], changes, prefilter, currentPath, k, stack);
              pkeys = arrayRemove(pkeys, other);
            } else {
              deepDiff(lhs[k], undefined, changes, prefilter, currentPath, k, stack);
            }
          });
          pkeys.forEach(function(k) {
            deepDiff(undefined, rhs[k], changes, prefilter, currentPath, k, stack);
          });
        }
        stack.length = stack.length - 1;
      }
    } else if (lhs !== rhs) {
      if (!(ltype === 'number' && isNaN(lhs) && isNaN(rhs))) {
        changes(new DiffEdit(currentPath, lhs, rhs));
      }
    }
  }

  function accumulateDiff(lhs, rhs, prefilter, accum) {
    accum = accum || [];
    deepDiff(lhs, rhs,
      function(diff) {
        if (diff) {
          accum.push(diff);
        }
      },
      prefilter);
    return (accum.length) ? accum : undefined;
  }

  function applyArrayChange(arr, index, change) {
    if (change.path && change.path.length) {
      var it = arr[index],
          i, u = change.path.length - 1;
      for (i = 0; i < u; i++) {
        it = it[change.path[i]];
      }
      switch (change.kind) {
        case 'A':
          applyArrayChange(it[change.path[i]], change.index, change.item);
          break;
        case 'D':
          delete it[change.path[i]];
          break;
        case 'E':
        case 'N':
          it[change.path[i]] = change.rhs;
          break;
      }
    } else {
      switch (change.kind) {
        case 'A':
          applyArrayChange(arr[index], change.index, change.item);
          break;
        case 'D':
          arr = arrayRemove(arr, index);
          break;
        case 'E':
        case 'N':
          arr[index] = change.rhs;
          break;
      }
    }
    return arr;
  }

  function applyChange(target, source, change) {
    if (target && source && change && change.kind) {
      var it = target,
          i = -1,
          last = change.path ? change.path.length - 1 : 0;
      while (++i < last) {
        if (typeof it[change.path[i]] === 'undefined') {
          it[change.path[i]] = (typeof change.path[i] === 'number') ? [] : {};
        }
        it = it[change.path[i]];
      }
      switch (change.kind) {
        case 'A':
          applyArrayChange(change.path ? it[change.path[i]] : it, change.index, change.item);
          break;
        case 'D':
          delete it[change.path[i]];
          break;
        case 'E':
        case 'N':
          it[change.path[i]] = change.rhs;
          break;
      }
    }
  }

  function revertArrayChange(arr, index, change) {
    if (change.path && change.path.length) {
      // the structure of the object at the index has changed...
      var it = arr[index],
          i, u = change.path.length - 1;
      for (i = 0; i < u; i++) {
        it = it[change.path[i]];
      }
      switch (change.kind) {
        case 'A':
          revertArrayChange(it[change.path[i]], change.index, change.item);
          break;
        case 'D':
          it[change.path[i]] = change.lhs;
          break;
        case 'E':
          it[change.path[i]] = change.lhs;
          break;
        case 'N':
          delete it[change.path[i]];
          break;
      }
    } else {
      // the array item is different...
      switch (change.kind) {
        case 'A':
          revertArrayChange(arr[index], change.index, change.item);
          break;
        case 'D':
          arr[index] = change.lhs;
          break;
        case 'E':
          arr[index] = change.lhs;
          break;
        case 'N':
          arr = arrayRemove(arr, index);
          break;
      }
    }
    return arr;
  }

  function revertChange(target, source, change) {
    if (target && source && change && change.kind) {
      var it = target,
          i, u;
      u = change.path.length - 1;
      for (i = 0; i < u; i++) {
        if (typeof it[change.path[i]] === 'undefined') {
          it[change.path[i]] = {};
        }
        it = it[change.path[i]];
      }
      switch (change.kind) {
        case 'A':
          // Array was modified...
          // it will be an array...
          revertArrayChange(it[change.path[i]], change.index, change.item);
          break;
        case 'D':
          // Item was deleted...
          it[change.path[i]] = change.lhs;
          break;
        case 'E':
          // Item was edited...
          it[change.path[i]] = change.lhs;
          break;
        case 'N':
          // Item is new...
          delete it[change.path[i]];
          break;
      }
    }
  }

  function applyDiff(target, source, filter) {
    if (target && source) {
      var onChange = function(change) {
        if (!filter || filter(target, source, change)) {
          applyChange(target, source, change);
        }
      };
      deepDiff(target, source, onChange);
    }
  }

  Object.defineProperties(accumulateDiff, {

    diff: {
      value: accumulateDiff,
      enumerable: true
    },
    observableDiff: {
      value: deepDiff,
      enumerable: true
    },
    applyDiff: {
      value: applyDiff,
      enumerable: true
    },
    applyChange: {
      value: applyChange,
      enumerable: true
    },
    revertChange: {
      value: revertChange,
      enumerable: true
    },
    isConflict: {
      value: function() {
        return 'undefined' !== typeof conflict;
      },
      enumerable: true
    },
    noConflict: {
      value: function() {
        if (conflictResolution) {
          conflictResolution.forEach(function(it) {
            it();
          });
          conflictResolution = null;
        }
        return accumulateDiff;
      },
      enumerable: true
    }
  });

  return accumulateDiff;
}));

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],386:[function(require,module,exports){
var hasOwn = Object.prototype.hasOwnProperty;
var toStr = Object.prototype.toString;
var undefined;

var isArray = function isArray(arr) {
	if (typeof Array.isArray === 'function') {
		return Array.isArray(arr);
	}

	return toStr.call(arr) === '[object Array]';
};

var isPlainObject = function isPlainObject(obj) {
	'use strict';
	if (!obj || toStr.call(obj) !== '[object Object]') {
		return false;
	}

	var has_own_constructor = hasOwn.call(obj, 'constructor');
	var has_is_property_of_method = obj.constructor && obj.constructor.prototype && hasOwn.call(obj.constructor.prototype, 'isPrototypeOf');
	// Not own constructor property must be Object
	if (obj.constructor && !has_own_constructor && !has_is_property_of_method) {
		return false;
	}

	// Own properties are enumerated firstly, so to speed up,
	// if last one is own, then all properties are own.
	var key;
	for (key in obj) {}

	return key === undefined || hasOwn.call(obj, key);
};

module.exports = function extend() {
	'use strict';
	var options, name, src, copy, copyIsArray, clone,
		target = arguments[0],
		i = 1,
		length = arguments.length,
		deep = false;

	// Handle a deep copy situation
	if (typeof target === 'boolean') {
		deep = target;
		target = arguments[1] || {};
		// skip the boolean and the target
		i = 2;
	} else if ((typeof target !== 'object' && typeof target !== 'function') || target == null) {
		target = {};
	}

	for (; i < length; ++i) {
		options = arguments[i];
		// Only deal with non-null/undefined values
		if (options != null) {
			// Extend the base object
			for (name in options) {
				src = target[name];
				copy = options[name];

				// Prevent never-ending loop
				if (target === copy) {
					continue;
				}

				// Recurse if we're merging plain objects or arrays
				if (deep && copy && (isPlainObject(copy) || (copyIsArray = isArray(copy)))) {
					if (copyIsArray) {
						copyIsArray = false;
						clone = src && isArray(src) ? src : [];
					} else {
						clone = src && isPlainObject(src) ? src : {};
					}

					// Never move original objects, clone them
					target[name] = extend(deep, clone, copy);

				// Don't bring in undefined values
				} else if (copy !== undefined) {
					target[name] = copy;
				}
			}
		}
	}

	// Return the modified object
	return target;
};


},{}],387:[function(require,module,exports){
'use strict';

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @typechecks
 */

var emptyFunction = require('./emptyFunction');

/**
 * Upstream version of event listener. Does not take into account specific
 * nature of platform.
 */
var EventListener = {
  /**
   * Listen to DOM events during the bubble phase.
   *
   * @param {DOMEventTarget} target DOM element to register listener on.
   * @param {string} eventType Event type, e.g. 'click' or 'mouseover'.
   * @param {function} callback Callback function.
   * @return {object} Object with a `remove` method.
   */
  listen: function listen(target, eventType, callback) {
    if (target.addEventListener) {
      target.addEventListener(eventType, callback, false);
      return {
        remove: function remove() {
          target.removeEventListener(eventType, callback, false);
        }
      };
    } else if (target.attachEvent) {
      target.attachEvent('on' + eventType, callback);
      return {
        remove: function remove() {
          target.detachEvent('on' + eventType, callback);
        }
      };
    }
  },

  /**
   * Listen to DOM events during the capture phase.
   *
   * @param {DOMEventTarget} target DOM element to register listener on.
   * @param {string} eventType Event type, e.g. 'click' or 'mouseover'.
   * @param {function} callback Callback function.
   * @return {object} Object with a `remove` method.
   */
  capture: function capture(target, eventType, callback) {
    if (target.addEventListener) {
      target.addEventListener(eventType, callback, true);
      return {
        remove: function remove() {
          target.removeEventListener(eventType, callback, true);
        }
      };
    } else {
      if ("production" !== 'production') {
        console.error('Attempted to listen to events during the capture phase on a ' + 'browser that does not support the capture phase. Your application ' + 'will not receive some events.');
      }
      return {
        remove: emptyFunction
      };
    }
  },

  registerDefault: function registerDefault() {}
};

module.exports = EventListener;
},{"./emptyFunction":394}],388:[function(require,module,exports){
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */

'use strict';

var canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);

/**
 * Simple, lightweight module assisting with the detection and context of
 * Worker. Helps avoid circular dependencies and allows code to reason about
 * whether or not they are in a Worker, even if they never include the main
 * `ReactWorker` dependency.
 */
var ExecutionEnvironment = {

  canUseDOM: canUseDOM,

  canUseWorkers: typeof Worker !== 'undefined',

  canUseEventListeners: canUseDOM && !!(window.addEventListener || window.attachEvent),

  canUseViewport: canUseDOM && !!window.screen,

  isInWorker: !canUseDOM // For now, this is true - might change in the future.

};

module.exports = ExecutionEnvironment;
},{}],389:[function(require,module,exports){
"use strict";

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @typechecks
 */

var _hyphenPattern = /-(.)/g;

/**
 * Camelcases a hyphenated string, for example:
 *
 *   > camelize('background-color')
 *   < "backgroundColor"
 *
 * @param {string} string
 * @return {string}
 */
function camelize(string) {
  return string.replace(_hyphenPattern, function (_, character) {
    return character.toUpperCase();
  });
}

module.exports = camelize;
},{}],390:[function(require,module,exports){
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @typechecks
 */

'use strict';

var camelize = require('./camelize');

var msPattern = /^-ms-/;

/**
 * Camelcases a hyphenated CSS property name, for example:
 *
 *   > camelizeStyleName('background-color')
 *   < "backgroundColor"
 *   > camelizeStyleName('-moz-transition')
 *   < "MozTransition"
 *   > camelizeStyleName('-ms-transition')
 *   < "msTransition"
 *
 * As Andi Smith suggests
 * (http://www.andismith.com/blog/2012/02/modernizr-prefixed/), an `-ms` prefix
 * is converted to lowercase `ms`.
 *
 * @param {string} string
 * @return {string}
 */
function camelizeStyleName(string) {
  return camelize(string.replace(msPattern, 'ms-'));
}

module.exports = camelizeStyleName;
},{"./camelize":389}],391:[function(require,module,exports){
'use strict';

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

var isTextNode = require('./isTextNode');

/*eslint-disable no-bitwise */

/**
 * Checks if a given DOM node contains or is another DOM node.
 */
function containsNode(outerNode, innerNode) {
  if (!outerNode || !innerNode) {
    return false;
  } else if (outerNode === innerNode) {
    return true;
  } else if (isTextNode(outerNode)) {
    return false;
  } else if (isTextNode(innerNode)) {
    return containsNode(outerNode, innerNode.parentNode);
  } else if ('contains' in outerNode) {
    return outerNode.contains(innerNode);
  } else if (outerNode.compareDocumentPosition) {
    return !!(outerNode.compareDocumentPosition(innerNode) & 16);
  } else {
    return false;
  }
}

module.exports = containsNode;
},{"./isTextNode":404}],392:[function(require,module,exports){
'use strict';

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @typechecks
 */

var invariant = require('./invariant');

/**
 * Convert array-like objects to arrays.
 *
 * This API assumes the caller knows the contents of the data type. For less
 * well defined inputs use createArrayFromMixed.
 *
 * @param {object|function|filelist} obj
 * @return {array}
 */
function toArray(obj) {
  var length = obj.length;

  // Some browsers builtin objects can report typeof 'function' (e.g. NodeList
  // in old versions of Safari).
  !(!Array.isArray(obj) && (typeof obj === 'object' || typeof obj === 'function')) ? "production" !== 'production' ? invariant(false, 'toArray: Array-like object expected') : invariant(false) : void 0;

  !(typeof length === 'number') ? "production" !== 'production' ? invariant(false, 'toArray: Object needs a length property') : invariant(false) : void 0;

  !(length === 0 || length - 1 in obj) ? "production" !== 'production' ? invariant(false, 'toArray: Object should have keys for indices') : invariant(false) : void 0;

  !(typeof obj.callee !== 'function') ? "production" !== 'production' ? invariant(false, 'toArray: Object can\'t be `arguments`. Use rest params ' + '(function(...args) {}) or Array.from() instead.') : invariant(false) : void 0;

  // Old IE doesn't give collections access to hasOwnProperty. Assume inputs
  // without method will throw during the slice call and skip straight to the
  // fallback.
  if (obj.hasOwnProperty) {
    try {
      return Array.prototype.slice.call(obj);
    } catch (e) {
      // IE < 9 does not support Array#slice on collections objects
    }
  }

  // Fall back to copying key by key. This assumes all keys have a value,
  // so will not preserve sparsely populated inputs.
  var ret = Array(length);
  for (var ii = 0; ii < length; ii++) {
    ret[ii] = obj[ii];
  }
  return ret;
}

/**
 * Perform a heuristic test to determine if an object is "array-like".
 *
 *   A monk asked Joshu, a Zen master, "Has a dog Buddha nature?"
 *   Joshu replied: "Mu."
 *
 * This function determines if its argument has "array nature": it returns
 * true if the argument is an actual array, an `arguments' object, or an
 * HTMLCollection (e.g. node.childNodes or node.getElementsByTagName()).
 *
 * It will return false for other array-like objects like Filelist.
 *
 * @param {*} obj
 * @return {boolean}
 */
function hasArrayNature(obj) {
  return (
    // not null/false
    !!obj && (
    // arrays are objects, NodeLists are functions in Safari
    typeof obj == 'object' || typeof obj == 'function') &&
    // quacks like an array
    'length' in obj &&
    // not window
    !('setInterval' in obj) &&
    // no DOM node should be considered an array-like
    // a 'select' element has 'length' and 'item' properties on IE8
    typeof obj.nodeType != 'number' && (
    // a real array
    Array.isArray(obj) ||
    // arguments
    'callee' in obj ||
    // HTMLCollection/NodeList
    'item' in obj)
  );
}

/**
 * Ensure that the argument is an array by wrapping it in an array if it is not.
 * Creates a copy of the argument if it is already an array.
 *
 * This is mostly useful idiomatically:
 *
 *   var createArrayFromMixed = require('createArrayFromMixed');
 *
 *   function takesOneOrMoreThings(things) {
 *     things = createArrayFromMixed(things);
 *     ...
 *   }
 *
 * This allows you to treat `things' as an array, but accept scalars in the API.
 *
 * If you need to convert an array-like object, like `arguments`, into an array
 * use toArray instead.
 *
 * @param {*} obj
 * @return {array}
 */
function createArrayFromMixed(obj) {
  if (!hasArrayNature(obj)) {
    return [obj];
  } else if (Array.isArray(obj)) {
    return obj.slice();
  } else {
    return toArray(obj);
  }
}

module.exports = createArrayFromMixed;
},{"./invariant":402}],393:[function(require,module,exports){
'use strict';

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @typechecks
 */

/*eslint-disable fb-www/unsafe-html*/

var ExecutionEnvironment = require('./ExecutionEnvironment');

var createArrayFromMixed = require('./createArrayFromMixed');
var getMarkupWrap = require('./getMarkupWrap');
var invariant = require('./invariant');

/**
 * Dummy container used to render all markup.
 */
var dummyNode = ExecutionEnvironment.canUseDOM ? document.createElement('div') : null;

/**
 * Pattern used by `getNodeName`.
 */
var nodeNamePattern = /^\s*<(\w+)/;

/**
 * Extracts the `nodeName` of the first element in a string of markup.
 *
 * @param {string} markup String of markup.
 * @return {?string} Node name of the supplied markup.
 */
function getNodeName(markup) {
  var nodeNameMatch = markup.match(nodeNamePattern);
  return nodeNameMatch && nodeNameMatch[1].toLowerCase();
}

/**
 * Creates an array containing the nodes rendered from the supplied markup. The
 * optionally supplied `handleScript` function will be invoked once for each
 * <script> element that is rendered. If no `handleScript` function is supplied,
 * an exception is thrown if any <script> elements are rendered.
 *
 * @param {string} markup A string of valid HTML markup.
 * @param {?function} handleScript Invoked once for each rendered <script>.
 * @return {array<DOMElement|DOMTextNode>} An array of rendered nodes.
 */
function createNodesFromMarkup(markup, handleScript) {
  var node = dummyNode;
  !!!dummyNode ? "production" !== 'production' ? invariant(false, 'createNodesFromMarkup dummy not initialized') : invariant(false) : void 0;
  var nodeName = getNodeName(markup);

  var wrap = nodeName && getMarkupWrap(nodeName);
  if (wrap) {
    node.innerHTML = wrap[1] + markup + wrap[2];

    var wrapDepth = wrap[0];
    while (wrapDepth--) {
      node = node.lastChild;
    }
  } else {
    node.innerHTML = markup;
  }

  var scripts = node.getElementsByTagName('script');
  if (scripts.length) {
    !handleScript ? "production" !== 'production' ? invariant(false, 'createNodesFromMarkup(...): Unexpected <script> element rendered.') : invariant(false) : void 0;
    createArrayFromMixed(scripts).forEach(handleScript);
  }

  var nodes = Array.from(node.childNodes);
  while (node.lastChild) {
    node.removeChild(node.lastChild);
  }
  return nodes;
}

module.exports = createNodesFromMarkup;
},{"./ExecutionEnvironment":388,"./createArrayFromMixed":392,"./getMarkupWrap":398,"./invariant":402}],394:[function(require,module,exports){
"use strict";

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

function makeEmptyFunction(arg) {
  return function () {
    return arg;
  };
}

/**
 * This function accepts and discards inputs; it has no side effects. This is
 * primarily useful idiomatically for overridable function endpoints which
 * always need to be callable, since JS lacks a null-call idiom ala Cocoa.
 */
var emptyFunction = function emptyFunction() {};

emptyFunction.thatReturns = makeEmptyFunction;
emptyFunction.thatReturnsFalse = makeEmptyFunction(false);
emptyFunction.thatReturnsTrue = makeEmptyFunction(true);
emptyFunction.thatReturnsNull = makeEmptyFunction(null);
emptyFunction.thatReturnsThis = function () {
  return this;
};
emptyFunction.thatReturnsArgument = function (arg) {
  return arg;
};

module.exports = emptyFunction;
},{}],395:[function(require,module,exports){
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */

'use strict';

var emptyObject = {};

if ("production" !== 'production') {
  Object.freeze(emptyObject);
}

module.exports = emptyObject;
},{}],396:[function(require,module,exports){
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */

'use strict';

/**
 * @param {DOMElement} node input/textarea to focus
 */

function focusNode(node) {
  // IE8 can throw "Can't move focus to the control because it is invisible,
  // not enabled, or of a type that does not accept the focus." for all kinds of
  // reasons that are too expensive and fragile to test.
  try {
    node.focus();
  } catch (e) {}
}

module.exports = focusNode;
},{}],397:[function(require,module,exports){
'use strict';

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @typechecks
 */

/* eslint-disable fb-www/typeof-undefined */

/**
 * Same as document.activeElement but wraps in a try-catch block. In IE it is
 * not safe to call document.activeElement if there is nothing focused.
 *
 * The activeElement will be null only if the document or document body is not
 * yet defined.
 *
 * @param {?DOMDocument} doc Defaults to current document.
 * @return {?DOMElement}
 */
function getActiveElement(doc) /*?DOMElement*/{
  doc = doc || (typeof document !== 'undefined' ? document : undefined);
  if (typeof doc === 'undefined') {
    return null;
  }
  try {
    return doc.activeElement || doc.body;
  } catch (e) {
    return doc.body;
  }
}

module.exports = getActiveElement;
},{}],398:[function(require,module,exports){
'use strict';

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */

/*eslint-disable fb-www/unsafe-html */

var ExecutionEnvironment = require('./ExecutionEnvironment');

var invariant = require('./invariant');

/**
 * Dummy container used to detect which wraps are necessary.
 */
var dummyNode = ExecutionEnvironment.canUseDOM ? document.createElement('div') : null;

/**
 * Some browsers cannot use `innerHTML` to render certain elements standalone,
 * so we wrap them, render the wrapped nodes, then extract the desired node.
 *
 * In IE8, certain elements cannot render alone, so wrap all elements ('*').
 */

var shouldWrap = {};

var selectWrap = [1, '<select multiple="true">', '</select>'];
var tableWrap = [1, '<table>', '</table>'];
var trWrap = [3, '<table><tbody><tr>', '</tr></tbody></table>'];

var svgWrap = [1, '<svg xmlns="http://www.w3.org/2000/svg">', '</svg>'];

var markupWrap = {
  '*': [1, '?<div>', '</div>'],

  'area': [1, '<map>', '</map>'],
  'col': [2, '<table><tbody></tbody><colgroup>', '</colgroup></table>'],
  'legend': [1, '<fieldset>', '</fieldset>'],
  'param': [1, '<object>', '</object>'],
  'tr': [2, '<table><tbody>', '</tbody></table>'],

  'optgroup': selectWrap,
  'option': selectWrap,

  'caption': tableWrap,
  'colgroup': tableWrap,
  'tbody': tableWrap,
  'tfoot': tableWrap,
  'thead': tableWrap,

  'td': trWrap,
  'th': trWrap
};

// Initialize the SVG elements since we know they'll always need to be wrapped
// consistently. If they are created inside a <div> they will be initialized in
// the wrong namespace (and will not display).
var svgElements = ['circle', 'clipPath', 'defs', 'ellipse', 'g', 'image', 'line', 'linearGradient', 'mask', 'path', 'pattern', 'polygon', 'polyline', 'radialGradient', 'rect', 'stop', 'text', 'tspan'];
svgElements.forEach(function (nodeName) {
  markupWrap[nodeName] = svgWrap;
  shouldWrap[nodeName] = true;
});

/**
 * Gets the markup wrap configuration for the supplied `nodeName`.
 *
 * NOTE: This lazily detects which wraps are necessary for the current browser.
 *
 * @param {string} nodeName Lowercase `nodeName`.
 * @return {?array} Markup wrap configuration, if applicable.
 */
function getMarkupWrap(nodeName) {
  !!!dummyNode ? "production" !== 'production' ? invariant(false, 'Markup wrapping node not initialized') : invariant(false) : void 0;
  if (!markupWrap.hasOwnProperty(nodeName)) {
    nodeName = '*';
  }
  if (!shouldWrap.hasOwnProperty(nodeName)) {
    if (nodeName === '*') {
      dummyNode.innerHTML = '<link />';
    } else {
      dummyNode.innerHTML = '<' + nodeName + '></' + nodeName + '>';
    }
    shouldWrap[nodeName] = !dummyNode.firstChild;
  }
  return shouldWrap[nodeName] ? markupWrap[nodeName] : null;
}

module.exports = getMarkupWrap;
},{"./ExecutionEnvironment":388,"./invariant":402}],399:[function(require,module,exports){
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @typechecks
 */

'use strict';

/**
 * Gets the scroll position of the supplied element or window.
 *
 * The return values are unbounded, unlike `getScrollPosition`. This means they
 * may be negative or exceed the element boundaries (which is possible using
 * inertial scrolling).
 *
 * @param {DOMWindow|DOMElement} scrollable
 * @return {object} Map with `x` and `y` keys.
 */

function getUnboundedScrollPosition(scrollable) {
  if (scrollable.Window && scrollable instanceof scrollable.Window) {
    return {
      x: scrollable.pageXOffset || scrollable.document.documentElement.scrollLeft,
      y: scrollable.pageYOffset || scrollable.document.documentElement.scrollTop
    };
  }
  return {
    x: scrollable.scrollLeft,
    y: scrollable.scrollTop
  };
}

module.exports = getUnboundedScrollPosition;
},{}],400:[function(require,module,exports){
'use strict';

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @typechecks
 */

var _uppercasePattern = /([A-Z])/g;

/**
 * Hyphenates a camelcased string, for example:
 *
 *   > hyphenate('backgroundColor')
 *   < "background-color"
 *
 * For CSS style names, use `hyphenateStyleName` instead which works properly
 * with all vendor prefixes, including `ms`.
 *
 * @param {string} string
 * @return {string}
 */
function hyphenate(string) {
  return string.replace(_uppercasePattern, '-$1').toLowerCase();
}

module.exports = hyphenate;
},{}],401:[function(require,module,exports){
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @typechecks
 */

'use strict';

var hyphenate = require('./hyphenate');

var msPattern = /^ms-/;

/**
 * Hyphenates a camelcased CSS property name, for example:
 *
 *   > hyphenateStyleName('backgroundColor')
 *   < "background-color"
 *   > hyphenateStyleName('MozTransition')
 *   < "-moz-transition"
 *   > hyphenateStyleName('msTransition')
 *   < "-ms-transition"
 *
 * As Modernizr suggests (http://modernizr.com/docs/#prefixed), an `ms` prefix
 * is converted to `-ms-`.
 *
 * @param {string} string
 * @return {string}
 */
function hyphenateStyleName(string) {
  return hyphenate(string).replace(msPattern, '-ms-');
}

module.exports = hyphenateStyleName;
},{"./hyphenate":400}],402:[function(require,module,exports){
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */

'use strict';

/**
 * Use invariant() to assert state which your program assumes to be true.
 *
 * Provide sprintf-style format (only %s is supported) and arguments
 * to provide information about what broke and what you were
 * expecting.
 *
 * The invariant message will be stripped in production, but the invariant
 * will remain to ensure logic does not differ in production.
 */

var validateFormat = function validateFormat(format) {};

if ("production" !== 'production') {
  validateFormat = function validateFormat(format) {
    if (format === undefined) {
      throw new Error('invariant requires an error message argument');
    }
  };
}

function invariant(condition, format, a, b, c, d, e, f) {
  validateFormat(format);

  if (!condition) {
    var error;
    if (format === undefined) {
      error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');
    } else {
      var args = [a, b, c, d, e, f];
      var argIndex = 0;
      error = new Error(format.replace(/%s/g, function () {
        return args[argIndex++];
      }));
      error.name = 'Invariant Violation';
    }

    error.framesToPop = 1; // we don't care about invariant's own frame
    throw error;
  }
}

module.exports = invariant;
},{}],403:[function(require,module,exports){
'use strict';

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @typechecks
 */

/**
 * @param {*} object The object to check.
 * @return {boolean} Whether or not the object is a DOM node.
 */
function isNode(object) {
  var doc = object ? object.ownerDocument || object : document;
  var defaultView = doc.defaultView || window;
  return !!(object && (typeof defaultView.Node === 'function' ? object instanceof defaultView.Node : typeof object === 'object' && typeof object.nodeType === 'number' && typeof object.nodeName === 'string'));
}

module.exports = isNode;
},{}],404:[function(require,module,exports){
'use strict';

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @typechecks
 */

var isNode = require('./isNode');

/**
 * @param {*} object The object to check.
 * @return {boolean} Whether or not the object is a DOM text node.
 */
function isTextNode(object) {
  return isNode(object) && object.nodeType == 3;
}

module.exports = isTextNode;
},{"./isNode":403}],405:[function(require,module,exports){
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @typechecks static-only
 */

'use strict';

/**
 * Memoizes the return value of a function that accepts one string argument.
 */

function memoizeStringOnly(callback) {
  var cache = {};
  return function (string) {
    if (!cache.hasOwnProperty(string)) {
      cache[string] = callback.call(this, string);
    }
    return cache[string];
  };
}

module.exports = memoizeStringOnly;
},{}],406:[function(require,module,exports){
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @typechecks
 */

'use strict';

var ExecutionEnvironment = require('./ExecutionEnvironment');

var performance;

if (ExecutionEnvironment.canUseDOM) {
  performance = window.performance || window.msPerformance || window.webkitPerformance;
}

module.exports = performance || {};
},{"./ExecutionEnvironment":388}],407:[function(require,module,exports){
'use strict';

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @typechecks
 */

var performance = require('./performance');

var performanceNow;

/**
 * Detect if we can use `window.performance.now()` and gracefully fallback to
 * `Date.now()` if it doesn't exist. We need to support Firefox < 15 for now
 * because of Facebook's testing infrastructure.
 */
if (performance.now) {
  performanceNow = function performanceNow() {
    return performance.now();
  };
} else {
  performanceNow = function performanceNow() {
    return Date.now();
  };
}

module.exports = performanceNow;
},{"./performance":406}],408:[function(require,module,exports){
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @typechecks
 * 
 */

/*eslint-disable no-self-compare */

'use strict';

var hasOwnProperty = Object.prototype.hasOwnProperty;

/**
 * inlined Object.is polyfill to avoid requiring consumers ship their own
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
 */
function is(x, y) {
  // SameValue algorithm
  if (x === y) {
    // Steps 1-5, 7-10
    // Steps 6.b-6.e: +0 != -0
    // Added the nonzero y check to make Flow happy, but it is redundant
    return x !== 0 || y !== 0 || 1 / x === 1 / y;
  } else {
    // Step 6.a: NaN == NaN
    return x !== x && y !== y;
  }
}

/**
 * Performs equality by iterating through keys on an object and returning false
 * when any key has values which are not strictly equal between the arguments.
 * Returns true when the values of all keys are strictly equal.
 */
function shallowEqual(objA, objB) {
  if (is(objA, objB)) {
    return true;
  }

  if (typeof objA !== 'object' || objA === null || typeof objB !== 'object' || objB === null) {
    return false;
  }

  var keysA = Object.keys(objA);
  var keysB = Object.keys(objB);

  if (keysA.length !== keysB.length) {
    return false;
  }

  // Test for A's keys different from B.
  for (var i = 0; i < keysA.length; i++) {
    if (!hasOwnProperty.call(objB, keysA[i]) || !is(objA[keysA[i]], objB[keysA[i]])) {
      return false;
    }
  }

  return true;
}

module.exports = shallowEqual;
},{}],409:[function(require,module,exports){
/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */

'use strict';

var emptyFunction = require('./emptyFunction');

/**
 * Similar to invariant but only logs a warning if the condition is not met.
 * This can be used to log issues in development environments in critical
 * paths. Removing the logging code for production environments will keep the
 * same logic and follow the same code paths.
 */

var warning = emptyFunction;

if ("production" !== 'production') {
  var printWarning = function printWarning(format) {
    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    var argIndex = 0;
    var message = 'Warning: ' + format.replace(/%s/g, function () {
      return args[argIndex++];
    });
    if (typeof console !== 'undefined') {
      console.error(message);
    }
    try {
      // --- Welcome to debugging React ---
      // This error was thrown as a convenience so that you can use this stack
      // to find the callsite that caused this warning to fire.
      throw new Error(message);
    } catch (x) {}
  };

  warning = function warning(condition, format) {
    if (format === undefined) {
      throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');
    }

    if (format.indexOf('Failed Composite propType: ') === 0) {
      return; // Ignore CompositeComponent proptype check.
    }

    if (!condition) {
      for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
        args[_key2 - 2] = arguments[_key2];
      }

      printWarning.apply(undefined, [format].concat(args));
    }
  };
}

module.exports = warning;
},{"./emptyFunction":394}],410:[function(require,module,exports){
'use strict';

exports.__esModule = true;
// istanbul ignore next

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

// istanbul ignore next

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

var _handlebarsBase = require('./handlebars/base');

var base = _interopRequireWildcard(_handlebarsBase);

// Each of these augment the Handlebars object. No need to setup here.
// (This is done to easily share code between commonjs and browse envs)

var _handlebarsSafeString = require('./handlebars/safe-string');

var _handlebarsSafeString2 = _interopRequireDefault(_handlebarsSafeString);

var _handlebarsException = require('./handlebars/exception');

var _handlebarsException2 = _interopRequireDefault(_handlebarsException);

var _handlebarsUtils = require('./handlebars/utils');

var Utils = _interopRequireWildcard(_handlebarsUtils);

var _handlebarsRuntime = require('./handlebars/runtime');

var runtime = _interopRequireWildcard(_handlebarsRuntime);

var _handlebarsNoConflict = require('./handlebars/no-conflict');

var _handlebarsNoConflict2 = _interopRequireDefault(_handlebarsNoConflict);

// For compatibility and usage outside of module systems, make the Handlebars object a namespace
function create() {
  var hb = new base.HandlebarsEnvironment();

  Utils.extend(hb, base);
  hb.SafeString = _handlebarsSafeString2['default'];
  hb.Exception = _handlebarsException2['default'];
  hb.Utils = Utils;
  hb.escapeExpression = Utils.escapeExpression;

  hb.VM = runtime;
  hb.template = function (spec) {
    return runtime.template(spec, hb);
  };

  return hb;
}

var inst = create();
inst.create = create;

_handlebarsNoConflict2['default'](inst);

inst['default'] = inst;

exports['default'] = inst;
module.exports = exports['default'];


},{"./handlebars/base":411,"./handlebars/exception":414,"./handlebars/no-conflict":424,"./handlebars/runtime":425,"./handlebars/safe-string":426,"./handlebars/utils":427}],411:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports.HandlebarsEnvironment = HandlebarsEnvironment;
// istanbul ignore next

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _utils = require('./utils');

var _exception = require('./exception');

var _exception2 = _interopRequireDefault(_exception);

var _helpers = require('./helpers');

var _decorators = require('./decorators');

var _logger = require('./logger');

var _logger2 = _interopRequireDefault(_logger);

var VERSION = '4.0.5';
exports.VERSION = VERSION;
var COMPILER_REVISION = 7;

exports.COMPILER_REVISION = COMPILER_REVISION;
var REVISION_CHANGES = {
  1: '<= 1.0.rc.2', // 1.0.rc.2 is actually rev2 but doesn't report it
  2: '== 1.0.0-rc.3',
  3: '== 1.0.0-rc.4',
  4: '== 1.x.x',
  5: '== 2.0.0-alpha.x',
  6: '>= 2.0.0-beta.1',
  7: '>= 4.0.0'
};

exports.REVISION_CHANGES = REVISION_CHANGES;
var objectType = '[object Object]';

function HandlebarsEnvironment(helpers, partials, decorators) {
  this.helpers = helpers || {};
  this.partials = partials || {};
  this.decorators = decorators || {};

  _helpers.registerDefaultHelpers(this);
  _decorators.registerDefaultDecorators(this);
}

HandlebarsEnvironment.prototype = {
  constructor: HandlebarsEnvironment,

  logger: _logger2['default'],
  log: _logger2['default'].log,

  registerHelper: function registerHelper(name, fn) {
    if (_utils.toString.call(name) === objectType) {
      if (fn) {
        throw new _exception2['default']('Arg not supported with multiple helpers');
      }
      _utils.extend(this.helpers, name);
    } else {
      this.helpers[name] = fn;
    }
  },
  unregisterHelper: function unregisterHelper(name) {
    delete this.helpers[name];
  },

  registerPartial: function registerPartial(name, partial) {
    if (_utils.toString.call(name) === objectType) {
      _utils.extend(this.partials, name);
    } else {
      if (typeof partial === 'undefined') {
        throw new _exception2['default']('Attempting to register a partial called "' + name + '" as undefined');
      }
      this.partials[name] = partial;
    }
  },
  unregisterPartial: function unregisterPartial(name) {
    delete this.partials[name];
  },

  registerDecorator: function registerDecorator(name, fn) {
    if (_utils.toString.call(name) === objectType) {
      if (fn) {
        throw new _exception2['default']('Arg not supported with multiple decorators');
      }
      _utils.extend(this.decorators, name);
    } else {
      this.decorators[name] = fn;
    }
  },
  unregisterDecorator: function unregisterDecorator(name) {
    delete this.decorators[name];
  }
};

var log = _logger2['default'].log;

exports.log = log;
exports.createFrame = _utils.createFrame;
exports.logger = _logger2['default'];


},{"./decorators":412,"./exception":414,"./helpers":415,"./logger":423,"./utils":427}],412:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports.registerDefaultDecorators = registerDefaultDecorators;
// istanbul ignore next

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _decoratorsInline = require('./decorators/inline');

var _decoratorsInline2 = _interopRequireDefault(_decoratorsInline);

function registerDefaultDecorators(instance) {
  _decoratorsInline2['default'](instance);
}


},{"./decorators/inline":413}],413:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _utils = require('../utils');

exports['default'] = function (instance) {
  instance.registerDecorator('inline', function (fn, props, container, options) {
    var ret = fn;
    if (!props.partials) {
      props.partials = {};
      ret = function (context, options) {
        // Create a new partials stack frame prior to exec.
        var original = container.partials;
        container.partials = _utils.extend({}, original, props.partials);
        var ret = fn(context, options);
        container.partials = original;
        return ret;
      };
    }

    props.partials[options.args[0]] = options.fn;

    return ret;
  });
};

module.exports = exports['default'];


},{"../utils":427}],414:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var errorProps = ['description', 'fileName', 'lineNumber', 'message', 'name', 'number', 'stack'];

function Exception(message, node) {
  var loc = node && node.loc,
      line = undefined,
      column = undefined;
  if (loc) {
    line = loc.start.line;
    column = loc.start.column;

    message += ' - ' + line + ':' + column;
  }

  var tmp = Error.prototype.constructor.call(this, message);

  // Unfortunately errors are not enumerable in Chrome (at least), so `for prop in tmp` doesn't work.
  for (var idx = 0; idx < errorProps.length; idx++) {
    this[errorProps[idx]] = tmp[errorProps[idx]];
  }

  /* istanbul ignore else */
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, Exception);
  }

  try {
    if (loc) {
      this.lineNumber = line;

      // Work around issue under safari where we can't directly set the column value
      /* istanbul ignore next */
      if (Object.defineProperty) {
        Object.defineProperty(this, 'column', { value: column });
      } else {
        this.column = column;
      }
    }
  } catch (nop) {
    /* Ignore if the browser is very particular */
  }
}

Exception.prototype = new Error();

exports['default'] = Exception;
module.exports = exports['default'];


},{}],415:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports.registerDefaultHelpers = registerDefaultHelpers;
// istanbul ignore next

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _helpersBlockHelperMissing = require('./helpers/block-helper-missing');

var _helpersBlockHelperMissing2 = _interopRequireDefault(_helpersBlockHelperMissing);

var _helpersEach = require('./helpers/each');

var _helpersEach2 = _interopRequireDefault(_helpersEach);

var _helpersHelperMissing = require('./helpers/helper-missing');

var _helpersHelperMissing2 = _interopRequireDefault(_helpersHelperMissing);

var _helpersIf = require('./helpers/if');

var _helpersIf2 = _interopRequireDefault(_helpersIf);

var _helpersLog = require('./helpers/log');

var _helpersLog2 = _interopRequireDefault(_helpersLog);

var _helpersLookup = require('./helpers/lookup');

var _helpersLookup2 = _interopRequireDefault(_helpersLookup);

var _helpersWith = require('./helpers/with');

var _helpersWith2 = _interopRequireDefault(_helpersWith);

function registerDefaultHelpers(instance) {
  _helpersBlockHelperMissing2['default'](instance);
  _helpersEach2['default'](instance);
  _helpersHelperMissing2['default'](instance);
  _helpersIf2['default'](instance);
  _helpersLog2['default'](instance);
  _helpersLookup2['default'](instance);
  _helpersWith2['default'](instance);
}


},{"./helpers/block-helper-missing":416,"./helpers/each":417,"./helpers/helper-missing":418,"./helpers/if":419,"./helpers/log":420,"./helpers/lookup":421,"./helpers/with":422}],416:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _utils = require('../utils');

exports['default'] = function (instance) {
  instance.registerHelper('blockHelperMissing', function (context, options) {
    var inverse = options.inverse,
        fn = options.fn;

    if (context === true) {
      return fn(this);
    } else if (context === false || context == null) {
      return inverse(this);
    } else if (_utils.isArray(context)) {
      if (context.length > 0) {
        if (options.ids) {
          options.ids = [options.name];
        }

        return instance.helpers.each(context, options);
      } else {
        return inverse(this);
      }
    } else {
      if (options.data && options.ids) {
        var data = _utils.createFrame(options.data);
        data.contextPath = _utils.appendContextPath(options.data.contextPath, options.name);
        options = { data: data };
      }

      return fn(context, options);
    }
  });
};

module.exports = exports['default'];


},{"../utils":427}],417:[function(require,module,exports){
'use strict';

exports.__esModule = true;
// istanbul ignore next

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _utils = require('../utils');

var _exception = require('../exception');

var _exception2 = _interopRequireDefault(_exception);

exports['default'] = function (instance) {
  instance.registerHelper('each', function (context, options) {
    if (!options) {
      throw new _exception2['default']('Must pass iterator to #each');
    }

    var fn = options.fn,
        inverse = options.inverse,
        i = 0,
        ret = '',
        data = undefined,
        contextPath = undefined;

    if (options.data && options.ids) {
      contextPath = _utils.appendContextPath(options.data.contextPath, options.ids[0]) + '.';
    }

    if (_utils.isFunction(context)) {
      context = context.call(this);
    }

    if (options.data) {
      data = _utils.createFrame(options.data);
    }

    function execIteration(field, index, last) {
      if (data) {
        data.key = field;
        data.index = index;
        data.first = index === 0;
        data.last = !!last;

        if (contextPath) {
          data.contextPath = contextPath + field;
        }
      }

      ret = ret + fn(context[field], {
        data: data,
        blockParams: _utils.blockParams([context[field], field], [contextPath + field, null])
      });
    }

    if (context && typeof context === 'object') {
      if (_utils.isArray(context)) {
        for (var j = context.length; i < j; i++) {
          if (i in context) {
            execIteration(i, i, i === context.length - 1);
          }
        }
      } else {
        var priorKey = undefined;

        for (var key in context) {
          if (context.hasOwnProperty(key)) {
            // We're running the iterations one step out of sync so we can detect
            // the last iteration without have to scan the object twice and create
            // an itermediate keys array.
            if (priorKey !== undefined) {
              execIteration(priorKey, i - 1);
            }
            priorKey = key;
            i++;
          }
        }
        if (priorKey !== undefined) {
          execIteration(priorKey, i - 1, true);
        }
      }
    }

    if (i === 0) {
      ret = inverse(this);
    }

    return ret;
  });
};

module.exports = exports['default'];


},{"../exception":414,"../utils":427}],418:[function(require,module,exports){
'use strict';

exports.__esModule = true;
// istanbul ignore next

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _exception = require('../exception');

var _exception2 = _interopRequireDefault(_exception);

exports['default'] = function (instance) {
  instance.registerHelper('helperMissing', function () /* [args, ]options */{
    if (arguments.length === 1) {
      // A missing field in a {{foo}} construct.
      return undefined;
    } else {
      // Someone is actually trying to call something, blow up.
      throw new _exception2['default']('Missing helper: "' + arguments[arguments.length - 1].name + '"');
    }
  });
};

module.exports = exports['default'];


},{"../exception":414}],419:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _utils = require('../utils');

exports['default'] = function (instance) {
  instance.registerHelper('if', function (conditional, options) {
    if (_utils.isFunction(conditional)) {
      conditional = conditional.call(this);
    }

    // Default behavior is to render the positive path if the value is truthy and not empty.
    // The `includeZero` option may be set to treat the condtional as purely not empty based on the
    // behavior of isEmpty. Effectively this determines if 0 is handled by the positive path or negative.
    if (!options.hash.includeZero && !conditional || _utils.isEmpty(conditional)) {
      return options.inverse(this);
    } else {
      return options.fn(this);
    }
  });

  instance.registerHelper('unless', function (conditional, options) {
    return instance.helpers['if'].call(this, conditional, { fn: options.inverse, inverse: options.fn, hash: options.hash });
  });
};

module.exports = exports['default'];


},{"../utils":427}],420:[function(require,module,exports){
'use strict';

exports.__esModule = true;

exports['default'] = function (instance) {
  instance.registerHelper('log', function () /* message, options */{
    var args = [undefined],
        options = arguments[arguments.length - 1];
    for (var i = 0; i < arguments.length - 1; i++) {
      args.push(arguments[i]);
    }

    var level = 1;
    if (options.hash.level != null) {
      level = options.hash.level;
    } else if (options.data && options.data.level != null) {
      level = options.data.level;
    }
    args[0] = level;

    instance.log.apply(instance, args);
  });
};

module.exports = exports['default'];


},{}],421:[function(require,module,exports){
'use strict';

exports.__esModule = true;

exports['default'] = function (instance) {
  instance.registerHelper('lookup', function (obj, field) {
    return obj && obj[field];
  });
};

module.exports = exports['default'];


},{}],422:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _utils = require('../utils');

exports['default'] = function (instance) {
  instance.registerHelper('with', function (context, options) {
    if (_utils.isFunction(context)) {
      context = context.call(this);
    }

    var fn = options.fn;

    if (!_utils.isEmpty(context)) {
      var data = options.data;
      if (options.data && options.ids) {
        data = _utils.createFrame(options.data);
        data.contextPath = _utils.appendContextPath(options.data.contextPath, options.ids[0]);
      }

      return fn(context, {
        data: data,
        blockParams: _utils.blockParams([context], [data && data.contextPath])
      });
    } else {
      return options.inverse(this);
    }
  });
};

module.exports = exports['default'];


},{"../utils":427}],423:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _utils = require('./utils');

var logger = {
  methodMap: ['debug', 'info', 'warn', 'error'],
  level: 'info',

  // Maps a given level value to the `methodMap` indexes above.
  lookupLevel: function lookupLevel(level) {
    if (typeof level === 'string') {
      var levelMap = _utils.indexOf(logger.methodMap, level.toLowerCase());
      if (levelMap >= 0) {
        level = levelMap;
      } else {
        level = parseInt(level, 10);
      }
    }

    return level;
  },

  // Can be overridden in the host environment
  log: function log(level) {
    level = logger.lookupLevel(level);

    if (typeof console !== 'undefined' && logger.lookupLevel(logger.level) <= level) {
      var method = logger.methodMap[level];
      if (!console[method]) {
        // eslint-disable-line no-console
        method = 'log';
      }

      for (var _len = arguments.length, message = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        message[_key - 1] = arguments[_key];
      }

      console[method].apply(console, message); // eslint-disable-line no-console
    }
  }
};

exports['default'] = logger;
module.exports = exports['default'];


},{"./utils":427}],424:[function(require,module,exports){
(function (global){
/* global window */
'use strict';

exports.__esModule = true;

exports['default'] = function (Handlebars) {
  /* istanbul ignore next */
  var root = typeof global !== 'undefined' ? global : window,
      $Handlebars = root.Handlebars;
  /* istanbul ignore next */
  Handlebars.noConflict = function () {
    if (root.Handlebars === Handlebars) {
      root.Handlebars = $Handlebars;
    }
    return Handlebars;
  };
};

module.exports = exports['default'];


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],425:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports.checkRevision = checkRevision;
exports.template = template;
exports.wrapProgram = wrapProgram;
exports.resolvePartial = resolvePartial;
exports.invokePartial = invokePartial;
exports.noop = noop;
// istanbul ignore next

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

// istanbul ignore next

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

var _utils = require('./utils');

var Utils = _interopRequireWildcard(_utils);

var _exception = require('./exception');

var _exception2 = _interopRequireDefault(_exception);

var _base = require('./base');

function checkRevision(compilerInfo) {
  var compilerRevision = compilerInfo && compilerInfo[0] || 1,
      currentRevision = _base.COMPILER_REVISION;

  if (compilerRevision !== currentRevision) {
    if (compilerRevision < currentRevision) {
      var runtimeVersions = _base.REVISION_CHANGES[currentRevision],
          compilerVersions = _base.REVISION_CHANGES[compilerRevision];
      throw new _exception2['default']('Template was precompiled with an older version of Handlebars than the current runtime. ' + 'Please update your precompiler to a newer version (' + runtimeVersions + ') or downgrade your runtime to an older version (' + compilerVersions + ').');
    } else {
      // Use the embedded version info since the runtime doesn't know about this revision yet
      throw new _exception2['default']('Template was precompiled with a newer version of Handlebars than the current runtime. ' + 'Please update your runtime to a newer version (' + compilerInfo[1] + ').');
    }
  }
}

function template(templateSpec, env) {
  /* istanbul ignore next */
  if (!env) {
    throw new _exception2['default']('No environment passed to template');
  }
  if (!templateSpec || !templateSpec.main) {
    throw new _exception2['default']('Unknown template object: ' + typeof templateSpec);
  }

  templateSpec.main.decorator = templateSpec.main_d;

  // Note: Using env.VM references rather than local var references throughout this section to allow
  // for external users to override these as psuedo-supported APIs.
  env.VM.checkRevision(templateSpec.compiler);

  function invokePartialWrapper(partial, context, options) {
    if (options.hash) {
      context = Utils.extend({}, context, options.hash);
      if (options.ids) {
        options.ids[0] = true;
      }
    }

    partial = env.VM.resolvePartial.call(this, partial, context, options);
    var result = env.VM.invokePartial.call(this, partial, context, options);

    if (result == null && env.compile) {
      options.partials[options.name] = env.compile(partial, templateSpec.compilerOptions, env);
      result = options.partials[options.name](context, options);
    }
    if (result != null) {
      if (options.indent) {
        var lines = result.split('\n');
        for (var i = 0, l = lines.length; i < l; i++) {
          if (!lines[i] && i + 1 === l) {
            break;
          }

          lines[i] = options.indent + lines[i];
        }
        result = lines.join('\n');
      }
      return result;
    } else {
      throw new _exception2['default']('The partial ' + options.name + ' could not be compiled when running in runtime-only mode');
    }
  }

  // Just add water
  var container = {
    strict: function strict(obj, name) {
      if (!(name in obj)) {
        throw new _exception2['default']('"' + name + '" not defined in ' + obj);
      }
      return obj[name];
    },
    lookup: function lookup(depths, name) {
      var len = depths.length;
      for (var i = 0; i < len; i++) {
        if (depths[i] && depths[i][name] != null) {
          return depths[i][name];
        }
      }
    },
    lambda: function lambda(current, context) {
      return typeof current === 'function' ? current.call(context) : current;
    },

    escapeExpression: Utils.escapeExpression,
    invokePartial: invokePartialWrapper,

    fn: function fn(i) {
      var ret = templateSpec[i];
      ret.decorator = templateSpec[i + '_d'];
      return ret;
    },

    programs: [],
    program: function program(i, data, declaredBlockParams, blockParams, depths) {
      var programWrapper = this.programs[i],
          fn = this.fn(i);
      if (data || depths || blockParams || declaredBlockParams) {
        programWrapper = wrapProgram(this, i, fn, data, declaredBlockParams, blockParams, depths);
      } else if (!programWrapper) {
        programWrapper = this.programs[i] = wrapProgram(this, i, fn);
      }
      return programWrapper;
    },

    data: function data(value, depth) {
      while (value && depth--) {
        value = value._parent;
      }
      return value;
    },
    merge: function merge(param, common) {
      var obj = param || common;

      if (param && common && param !== common) {
        obj = Utils.extend({}, common, param);
      }

      return obj;
    },

    noop: env.VM.noop,
    compilerInfo: templateSpec.compiler
  };

  function ret(context) {
    var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

    var data = options.data;

    ret._setup(options);
    if (!options.partial && templateSpec.useData) {
      data = initData(context, data);
    }
    var depths = undefined,
        blockParams = templateSpec.useBlockParams ? [] : undefined;
    if (templateSpec.useDepths) {
      if (options.depths) {
        depths = context != options.depths[0] ? [context].concat(options.depths) : options.depths;
      } else {
        depths = [context];
      }
    }

    function main(context /*, options*/) {
      return '' + templateSpec.main(container, context, container.helpers, container.partials, data, blockParams, depths);
    }
    main = executeDecorators(templateSpec.main, main, container, options.depths || [], data, blockParams);
    return main(context, options);
  }
  ret.isTop = true;

  ret._setup = function (options) {
    if (!options.partial) {
      container.helpers = container.merge(options.helpers, env.helpers);

      if (templateSpec.usePartial) {
        container.partials = container.merge(options.partials, env.partials);
      }
      if (templateSpec.usePartial || templateSpec.useDecorators) {
        container.decorators = container.merge(options.decorators, env.decorators);
      }
    } else {
      container.helpers = options.helpers;
      container.partials = options.partials;
      container.decorators = options.decorators;
    }
  };

  ret._child = function (i, data, blockParams, depths) {
    if (templateSpec.useBlockParams && !blockParams) {
      throw new _exception2['default']('must pass block params');
    }
    if (templateSpec.useDepths && !depths) {
      throw new _exception2['default']('must pass parent depths');
    }

    return wrapProgram(container, i, templateSpec[i], data, 0, blockParams, depths);
  };
  return ret;
}

function wrapProgram(container, i, fn, data, declaredBlockParams, blockParams, depths) {
  function prog(context) {
    var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

    var currentDepths = depths;
    if (depths && context != depths[0]) {
      currentDepths = [context].concat(depths);
    }

    return fn(container, context, container.helpers, container.partials, options.data || data, blockParams && [options.blockParams].concat(blockParams), currentDepths);
  }

  prog = executeDecorators(fn, prog, container, depths, data, blockParams);

  prog.program = i;
  prog.depth = depths ? depths.length : 0;
  prog.blockParams = declaredBlockParams || 0;
  return prog;
}

function resolvePartial(partial, context, options) {
  if (!partial) {
    if (options.name === '@partial-block') {
      var data = options.data;
      while (data['partial-block'] === noop) {
        data = data._parent;
      }
      partial = data['partial-block'];
      data['partial-block'] = noop;
    } else {
      partial = options.partials[options.name];
    }
  } else if (!partial.call && !options.name) {
    // This is a dynamic partial that returned a string
    options.name = partial;
    partial = options.partials[partial];
  }
  return partial;
}

function invokePartial(partial, context, options) {
  options.partial = true;
  if (options.ids) {
    options.data.contextPath = options.ids[0] || options.data.contextPath;
  }

  var partialBlock = undefined;
  if (options.fn && options.fn !== noop) {
    options.data = _base.createFrame(options.data);
    partialBlock = options.data['partial-block'] = options.fn;

    if (partialBlock.partials) {
      options.partials = Utils.extend({}, options.partials, partialBlock.partials);
    }
  }

  if (partial === undefined && partialBlock) {
    partial = partialBlock;
  }

  if (partial === undefined) {
    throw new _exception2['default']('The partial ' + options.name + ' could not be found');
  } else if (partial instanceof Function) {
    return partial(context, options);
  }
}

function noop() {
  return '';
}

function initData(context, data) {
  if (!data || !('root' in data)) {
    data = data ? _base.createFrame(data) : {};
    data.root = context;
  }
  return data;
}

function executeDecorators(fn, prog, container, depths, data, blockParams) {
  if (fn.decorator) {
    var props = {};
    prog = fn.decorator(prog, props, container, depths && depths[0], data, blockParams, depths);
    Utils.extend(prog, props);
  }
  return prog;
}


},{"./base":411,"./exception":414,"./utils":427}],426:[function(require,module,exports){
// Build out our basic SafeString type
'use strict';

exports.__esModule = true;
function SafeString(string) {
  this.string = string;
}

SafeString.prototype.toString = SafeString.prototype.toHTML = function () {
  return '' + this.string;
};

exports['default'] = SafeString;
module.exports = exports['default'];


},{}],427:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports.extend = extend;
exports.indexOf = indexOf;
exports.escapeExpression = escapeExpression;
exports.isEmpty = isEmpty;
exports.createFrame = createFrame;
exports.blockParams = blockParams;
exports.appendContextPath = appendContextPath;
var escape = {
  '&': '&amp;',
  '<': '&lt;',
  '>': '&gt;',
  '"': '&quot;',
  "'": '&#x27;',
  '`': '&#x60;',
  '=': '&#x3D;'
};

var badChars = /[&<>"'`=]/g,
    possible = /[&<>"'`=]/;

function escapeChar(chr) {
  return escape[chr];
}

function extend(obj /* , ...source */) {
  for (var i = 1; i < arguments.length; i++) {
    for (var key in arguments[i]) {
      if (Object.prototype.hasOwnProperty.call(arguments[i], key)) {
        obj[key] = arguments[i][key];
      }
    }
  }

  return obj;
}

var toString = Object.prototype.toString;

exports.toString = toString;
// Sourced from lodash
// https://github.com/bestiejs/lodash/blob/master/LICENSE.txt
/* eslint-disable func-style */
var isFunction = function isFunction(value) {
  return typeof value === 'function';
};
// fallback for older versions of Chrome and Safari
/* istanbul ignore next */
if (isFunction(/x/)) {
  exports.isFunction = isFunction = function (value) {
    return typeof value === 'function' && toString.call(value) === '[object Function]';
  };
}
exports.isFunction = isFunction;

/* eslint-enable func-style */

/* istanbul ignore next */
var isArray = Array.isArray || function (value) {
  return value && typeof value === 'object' ? toString.call(value) === '[object Array]' : false;
};

exports.isArray = isArray;
// Older IE versions do not directly support indexOf so we must implement our own, sadly.

function indexOf(array, value) {
  for (var i = 0, len = array.length; i < len; i++) {
    if (array[i] === value) {
      return i;
    }
  }
  return -1;
}

function escapeExpression(string) {
  if (typeof string !== 'string') {
    // don't escape SafeStrings, since they're already safe
    if (string && string.toHTML) {
      return string.toHTML();
    } else if (string == null) {
      return '';
    } else if (!string) {
      return string + '';
    }

    // Force a string conversion as this will be done by the append regardless and
    // the regex test will do this transparently behind the scenes, causing issues if
    // an object's to string has escaped characters in it.
    string = '' + string;
  }

  if (!possible.test(string)) {
    return string;
  }
  return string.replace(badChars, escapeChar);
}

function isEmpty(value) {
  if (!value && value !== 0) {
    return true;
  } else if (isArray(value) && value.length === 0) {
    return true;
  } else {
    return false;
  }
}

function createFrame(object) {
  var frame = extend({}, object);
  frame._parent = object;
  return frame;
}

function blockParams(params, ids) {
  params.path = ids;
  return params;
}

function appendContextPath(contextPath, id) {
  return (contextPath ? contextPath + '.' : '') + id;
}


},{}],428:[function(require,module,exports){
// Create a simple path alias to allow browserify to resolve
// the runtime on a supported path.
module.exports = require('./dist/cjs/handlebars.runtime')['default'];

},{"./dist/cjs/handlebars.runtime":410}],429:[function(require,module,exports){
module.exports = require("handlebars/runtime")["default"];

},{"handlebars/runtime":428}],430:[function(require,module,exports){
/**
 * Copyright 2015, Yahoo! Inc.
 * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.
 */
'use strict';

var REACT_STATICS = {
    childContextTypes: true,
    contextTypes: true,
    defaultProps: true,
    displayName: true,
    getDefaultProps: true,
    mixins: true,
    propTypes: true,
    type: true
};

var KNOWN_STATICS = {
  name: true,
  length: true,
  prototype: true,
  caller: true,
  callee: true,
  arguments: true,
  arity: true
};

var defineProperty = Object.defineProperty;
var getOwnPropertyNames = Object.getOwnPropertyNames;
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
var getPrototypeOf = Object.getPrototypeOf;
var objectPrototype = getPrototypeOf && getPrototypeOf(Object);

module.exports = function hoistNonReactStatics(targetComponent, sourceComponent, blacklist) {
    if (typeof sourceComponent !== 'string') { // don't hoist over string (html) components

        if (objectPrototype) {
            var inheritedComponent = getPrototypeOf(sourceComponent);
            if (inheritedComponent && inheritedComponent !== objectPrototype) {
                hoistNonReactStatics(targetComponent, inheritedComponent, blacklist);
            }
        }

        var keys = getOwnPropertyNames(sourceComponent);

        if (getOwnPropertySymbols) {
            keys = keys.concat(getOwnPropertySymbols(sourceComponent));
        }

        for (var i = 0; i < keys.length; ++i) {
            var key = keys[i];
            if (!REACT_STATICS[key] && !KNOWN_STATICS[key] && (!blacklist || !blacklist[key])) {
                var descriptor = getOwnPropertyDescriptor(sourceComponent, key);
                try { // Avoid failures from read-only properties
                    defineProperty(targetComponent, key, descriptor);
                } catch (e) {}
            }
        }

        return targetComponent;
    }

    return targetComponent;
};

},{}],431:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

'use strict';

/**
 * Use invariant() to assert state which your program assumes to be true.
 *
 * Provide sprintf-style format (only %s is supported) and arguments
 * to provide information about what broke and what you were
 * expecting.
 *
 * The invariant message will be stripped in production, but the invariant
 * will remain to ensure logic does not differ in production.
 */

var invariant = function(condition, format, a, b, c, d, e, f) {
  if ("production" !== 'production') {
    if (format === undefined) {
      throw new Error('invariant requires an error message argument');
    }
  }

  if (!condition) {
    var error;
    if (format === undefined) {
      error = new Error(
        'Minified exception occurred; use the non-minified dev environment ' +
        'for the full error message and additional helpful warnings.'
      );
    } else {
      var args = [a, b, c, d, e, f];
      var argIndex = 0;
      error = new Error(
        format.replace(/%s/g, function() { return args[argIndex++]; })
      );
      error.name = 'Invariant Violation';
    }

    error.framesToPop = 1; // we don't care about invariant's own frame
    throw error;
  }
};

module.exports = invariant;

},{}],432:[function(require,module,exports){
var root = require('./_root');

/** Built-in value references. */
var Symbol = root.Symbol;

module.exports = Symbol;

},{"./_root":439}],433:[function(require,module,exports){
var Symbol = require('./_Symbol'),
    getRawTag = require('./_getRawTag'),
    objectToString = require('./_objectToString');

/** `Object#toString` result references. */
var nullTag = '[object Null]',
    undefinedTag = '[object Undefined]';

/** Built-in value references. */
var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function baseGetTag(value) {
  if (value == null) {
    return value === undefined ? undefinedTag : nullTag;
  }
  return (symToStringTag && symToStringTag in Object(value))
    ? getRawTag(value)
    : objectToString(value);
}

module.exports = baseGetTag;

},{"./_Symbol":432,"./_getRawTag":436,"./_objectToString":437}],434:[function(require,module,exports){
(function (global){
/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

module.exports = freeGlobal;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],435:[function(require,module,exports){
var overArg = require('./_overArg');

/** Built-in value references. */
var getPrototype = overArg(Object.getPrototypeOf, Object);

module.exports = getPrototype;

},{"./_overArg":438}],436:[function(require,module,exports){
var Symbol = require('./_Symbol');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/** Built-in value references. */
var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */
function getRawTag(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag),
      tag = value[symToStringTag];

  try {
    value[symToStringTag] = undefined;
    var unmasked = true;
  } catch (e) {}

  var result = nativeObjectToString.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }
  return result;
}

module.exports = getRawTag;

},{"./_Symbol":432}],437:[function(require,module,exports){
/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */
function objectToString(value) {
  return nativeObjectToString.call(value);
}

module.exports = objectToString;

},{}],438:[function(require,module,exports){
/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}

module.exports = overArg;

},{}],439:[function(require,module,exports){
var freeGlobal = require('./_freeGlobal');

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

module.exports = root;

},{"./_freeGlobal":434}],440:[function(require,module,exports){
/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return value != null && typeof value == 'object';
}

module.exports = isObjectLike;

},{}],441:[function(require,module,exports){
var baseGetTag = require('./_baseGetTag'),
    getPrototype = require('./_getPrototype'),
    isObjectLike = require('./isObjectLike');

/** `Object#toString` result references. */
var objectTag = '[object Object]';

/** Used for built-in method references. */
var funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Used to infer the `Object` constructor. */
var objectCtorString = funcToString.call(Object);

/**
 * Checks if `value` is a plain object, that is, an object created by the
 * `Object` constructor or one with a `[[Prototype]]` of `null`.
 *
 * @static
 * @memberOf _
 * @since 0.8.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 * }
 *
 * _.isPlainObject(new Foo);
 * // => false
 *
 * _.isPlainObject([1, 2, 3]);
 * // => false
 *
 * _.isPlainObject({ 'x': 0, 'y': 0 });
 * // => true
 *
 * _.isPlainObject(Object.create(null));
 * // => true
 */
function isPlainObject(value) {
  if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
    return false;
  }
  var proto = getPrototype(value);
  if (proto === null) {
    return true;
  }
  var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
  return typeof Ctor == 'function' && Ctor instanceof Ctor &&
    funcToString.call(Ctor) == objectCtorString;
}

module.exports = isPlainObject;

},{"./_baseGetTag":433,"./_getPrototype":435,"./isObjectLike":440}],442:[function(require,module,exports){
var indexOf = require('./indexOf');

    /**
     * Combines an array with all the items of another.
     * Does not allow duplicates and is case and type sensitive.
     */
    function combine(arr1, arr2) {
        if (arr2 == null) {
            return arr1;
        }

        var i = -1, len = arr2.length;
        while (++i < len) {
            if (indexOf(arr1, arr2[i]) === -1) {
                arr1.push(arr2[i]);
            }
        }

        return arr1;
    }
    module.exports = combine;


},{"./indexOf":449}],443:[function(require,module,exports){
var indexOf = require('./indexOf');

    /**
     * If array contains values.
     */
    function contains(arr, val) {
        return indexOf(arr, val) !== -1;
    }
    module.exports = contains;


},{"./indexOf":449}],444:[function(require,module,exports){
var unique = require('./unique');
var filter = require('./filter');
var some = require('./some');
var contains = require('./contains');
var slice = require('./slice');


    /**
     * Return a new Array with elements that aren't present in the other Arrays.
     */
    function difference(arr) {
        var arrs = slice(arguments, 1),
            result = filter(unique(arr), function(needle){
                return !some(arrs, function(haystack){
                    return contains(haystack, needle);
                });
            });
        return result;
    }

    module.exports = difference;



},{"./contains":443,"./filter":447,"./slice":453,"./some":454,"./unique":455}],445:[function(require,module,exports){
var is = require('../lang/is');
var isArray = require('../lang/isArray');
var every = require('./every');

    /**
     * Compares if both arrays have the same elements
     */
    function equals(a, b, callback){
        callback = callback || is;

        if (!isArray(a) || !isArray(b)) {
            return callback(a, b);
        }

        if (a.length !== b.length) {
            return false;
        }

        return every(a, makeCompare(callback), b);
    }

    function makeCompare(callback) {
        return function(value, i) {
            return i in this && callback(value, this[i]);
        };
    }

    module.exports = equals;



},{"../lang/is":463,"../lang/isArray":464,"./every":446}],446:[function(require,module,exports){
var makeIterator = require('../function/makeIterator_');

    /**
     * Array every
     */
    function every(arr, callback, thisObj) {
        callback = makeIterator(callback, thisObj);
        var result = true;
        if (arr == null) {
            return result;
        }

        var i = -1, len = arr.length;
        while (++i < len) {
            // we iterate over sparse items since there is no way to make it
            // work properly on IE 7-8. see #64
            if (!callback(arr[i], i, arr) ) {
                result = false;
                break;
            }
        }

        return result;
    }

    module.exports = every;


},{"../function/makeIterator_":457}],447:[function(require,module,exports){
var makeIterator = require('../function/makeIterator_');

    /**
     * Array filter
     */
    function filter(arr, callback, thisObj) {
        callback = makeIterator(callback, thisObj);
        var results = [];
        if (arr == null) {
            return results;
        }

        var i = -1, len = arr.length, value;
        while (++i < len) {
            value = arr[i];
            if (callback(value, i, arr)) {
                results.push(value);
            }
        }

        return results;
    }

    module.exports = filter;



},{"../function/makeIterator_":457}],448:[function(require,module,exports){


    /**
     * Array forEach
     */
    function forEach(arr, callback, thisObj) {
        if (arr == null) {
            return;
        }
        var i = -1,
            len = arr.length;
        while (++i < len) {
            // we iterate over sparse items since there is no way to make it
            // work properly on IE 7-8. see #64
            if ( callback.call(thisObj, arr[i], i, arr) === false ) {
                break;
            }
        }
    }

    module.exports = forEach;



},{}],449:[function(require,module,exports){


    /**
     * Array.indexOf
     */
    function indexOf(arr, item, fromIndex) {
        fromIndex = fromIndex || 0;
        if (arr == null) {
            return -1;
        }

        var len = arr.length,
            i = fromIndex < 0 ? len + fromIndex : fromIndex;
        while (i < len) {
            // we iterate over sparse items since there is no way to make it
            // work properly on IE 7-8. see #64
            if (arr[i] === item) {
                return i;
            }

            i++;
        }

        return -1;
    }

    module.exports = indexOf;


},{}],450:[function(require,module,exports){
var unique = require('./unique');
var filter = require('./filter');
var every = require('./every');
var contains = require('./contains');
var slice = require('./slice');


    /**
     * Return a new Array with elements common to all Arrays.
     * - based on underscore.js implementation
     */
    function intersection(arr) {
        var arrs = slice(arguments, 1),
            result = filter(unique(arr), function(needle){
                return every(arrs, function(haystack){
                    return contains(haystack, needle);
                });
            });
        return result;
    }

    module.exports = intersection;



},{"./contains":443,"./every":446,"./filter":447,"./slice":453,"./unique":455}],451:[function(require,module,exports){
var makeIterator = require('../function/makeIterator_');

    /**
     * Array map
     */
    function map(arr, callback, thisObj) {
        callback = makeIterator(callback, thisObj);
        var results = [];
        if (arr == null){
            return results;
        }

        var i = -1, len = arr.length;
        while (++i < len) {
            results[i] = callback(arr[i], i, arr);
        }

        return results;
    }

     module.exports = map;


},{"../function/makeIterator_":457}],452:[function(require,module,exports){
var indexOf = require('./indexOf');

    /**
     * Remove a single item from the array.
     * (it won't remove duplicates, just a single item)
     */
    function remove(arr, item){
        var idx = indexOf(arr, item);
        if (idx !== -1) arr.splice(idx, 1);
    }

    module.exports = remove;


},{"./indexOf":449}],453:[function(require,module,exports){


    /**
     * Create slice of source array or array-like object
     */
    function slice(arr, start, end){
        var len = arr.length;

        if (start == null) {
            start = 0;
        } else if (start < 0) {
            start = Math.max(len + start, 0);
        } else {
            start = Math.min(start, len);
        }

        if (end == null) {
            end = len;
        } else if (end < 0) {
            end = Math.max(len + end, 0);
        } else {
            end = Math.min(end, len);
        }

        var result = [];
        while (start < end) {
            result.push(arr[start++]);
        }

        return result;
    }

    module.exports = slice;



},{}],454:[function(require,module,exports){
var makeIterator = require('../function/makeIterator_');

    /**
     * Array some
     */
    function some(arr, callback, thisObj) {
        callback = makeIterator(callback, thisObj);
        var result = false;
        if (arr == null) {
            return result;
        }

        var i = -1, len = arr.length;
        while (++i < len) {
            // we iterate over sparse items since there is no way to make it
            // work properly on IE 7-8. see #64
            if ( callback(arr[i], i, arr) ) {
                result = true;
                break;
            }
        }

        return result;
    }

    module.exports = some;


},{"../function/makeIterator_":457}],455:[function(require,module,exports){
var filter = require('./filter');

    /**
     * @return {array} Array of unique items
     */
    function unique(arr, compare){
        compare = compare || isEqual;
        return filter(arr, function(item, i, arr){
            var n = arr.length;
            while (++i < n) {
                if ( compare(item, arr[i]) ) {
                    return false;
                }
            }
            return true;
        });
    }

    function isEqual(a, b){
        return a === b;
    }

    module.exports = unique;



},{"./filter":447}],456:[function(require,module,exports){


    /**
     * Returns the first argument provided to it.
     */
    function identity(val){
        return val;
    }

    module.exports = identity;



},{}],457:[function(require,module,exports){
var identity = require('./identity');
var prop = require('./prop');
var deepMatches = require('../object/deepMatches');

    /**
     * Converts argument into a valid iterator.
     * Used internally on most array/object/collection methods that receives a
     * callback/iterator providing a shortcut syntax.
     */
    function makeIterator(src, thisObj){
        if (src == null) {
            return identity;
        }
        switch(typeof src) {
            case 'function':
                // function is the first to improve perf (most common case)
                // also avoid using `Function#call` if not needed, which boosts
                // perf a lot in some cases
                return (typeof thisObj !== 'undefined')? function(val, i, arr){
                    return src.call(thisObj, val, i, arr);
                } : src;
            case 'object':
                return function(val){
                    return deepMatches(val, src);
                };
            case 'string':
            case 'number':
                return prop(src);
        }
    }

    module.exports = makeIterator;



},{"../object/deepMatches":472,"./identity":456,"./prop":458}],458:[function(require,module,exports){


    /**
     * Returns a function that gets a property of the passed object
     */
    function prop(name){
        return function(obj){
            return obj[name];
        };
    }

    module.exports = prop;



},{}],459:[function(require,module,exports){
var kindOf = require('./kindOf');
var isPlainObject = require('./isPlainObject');
var mixIn = require('../object/mixIn');

    /**
     * Clone native types.
     */
    function clone(val){
        switch (kindOf(val)) {
            case 'Object':
                return cloneObject(val);
            case 'Array':
                return cloneArray(val);
            case 'RegExp':
                return cloneRegExp(val);
            case 'Date':
                return cloneDate(val);
            default:
                return val;
        }
    }

    function cloneObject(source) {
        if (isPlainObject(source)) {
            return mixIn({}, source);
        } else {
            return source;
        }
    }

    function cloneRegExp(r) {
        var flags = '';
        flags += r.multiline ? 'm' : '';
        flags += r.global ? 'g' : '';
        flags += r.ignoreCase ? 'i' : '';
        return new RegExp(r.source, flags);
    }

    function cloneDate(date) {
        return new Date(+date);
    }

    function cloneArray(arr) {
        return arr.slice();
    }

    module.exports = clone;



},{"../object/mixIn":480,"./isPlainObject":468,"./kindOf":470}],460:[function(require,module,exports){
var mixIn = require('../object/mixIn');

    /**
     * Create Object using prototypal inheritance and setting custom properties.
     * - Mix between Douglas Crockford Prototypal Inheritance <http://javascript.crockford.com/prototypal.html> and the EcmaScript 5 `Object.create()` method.
     * @param {object} parent    Parent Object.
     * @param {object} [props] Object properties.
     * @return {object} Created object.
     */
    function createObject(parent, props){
        function F(){}
        F.prototype = parent;
        return mixIn(new F(), props);

    }
    module.exports = createObject;



},{"../object/mixIn":480}],461:[function(require,module,exports){
var clone = require('./clone');
var forOwn = require('../object/forOwn');
var kindOf = require('./kindOf');
var isPlainObject = require('./isPlainObject');

    /**
     * Recursively clone native types.
     */
    function deepClone(val, instanceClone) {
        switch ( kindOf(val) ) {
            case 'Object':
                return cloneObject(val, instanceClone);
            case 'Array':
                return cloneArray(val, instanceClone);
            default:
                return clone(val);
        }
    }

    function cloneObject(source, instanceClone) {
        if (isPlainObject(source)) {
            var out = {};
            forOwn(source, function(val, key) {
                this[key] = deepClone(val, instanceClone);
            }, out);
            return out;
        } else if (instanceClone) {
            return instanceClone(source);
        } else {
            return source;
        }
    }

    function cloneArray(arr, instanceClone) {
        var out = [],
            i = -1,
            n = arr.length,
            val;
        while (++i < n) {
            out[i] = deepClone(arr[i], instanceClone);
        }
        return out;
    }

    module.exports = deepClone;




},{"../object/forOwn":477,"./clone":459,"./isPlainObject":468,"./kindOf":470}],462:[function(require,module,exports){
var is = require('./is');
var isObject = require('./isObject');
var isArray = require('./isArray');
var objEquals = require('../object/equals');
var arrEquals = require('../array/equals');

    /**
     * Recursively checks for same properties and values.
     */
    function deepEquals(a, b, callback){
        callback = callback || is;

        var bothObjects = isObject(a) && isObject(b);
        var bothArrays = !bothObjects && isArray(a) && isArray(b);

        if (!bothObjects && !bothArrays) {
            return callback(a, b);
        }

        function compare(a, b){
            return deepEquals(a, b, callback);
        }

        var method = bothObjects ? objEquals : arrEquals;
        return method(a, b, compare);
    }

    module.exports = deepEquals;



},{"../array/equals":445,"../object/equals":474,"./is":463,"./isArray":464,"./isObject":467}],463:[function(require,module,exports){


    /**
     * Check if both arguments are egal.
     */
    function is(x, y){
        // implementation borrowed from harmony:egal spec
        if (x === y) {
          // 0 === -0, but they are not identical
          return x !== 0 || 1 / x === 1 / y;
        }

        // NaN !== NaN, but they are identical.
        // NaNs are the only non-reflexive value, i.e., if x !== x,
        // then x is a NaN.
        // isNaN is broken: it converts its argument to number, so
        // isNaN("foo") => true
        return x !== x && y !== y;
    }

    module.exports = is;



},{}],464:[function(require,module,exports){
var isKind = require('./isKind');
    /**
     */
    var isArray = Array.isArray || function (val) {
        return isKind(val, 'Array');
    };
    module.exports = isArray;


},{"./isKind":465}],465:[function(require,module,exports){
var kindOf = require('./kindOf');
    /**
     * Check if value is from a specific "kind".
     */
    function isKind(val, kind){
        return kindOf(val) === kind;
    }
    module.exports = isKind;


},{"./kindOf":470}],466:[function(require,module,exports){
var isKind = require('./isKind');
    /**
     */
    function isNumber(val) {
        return isKind(val, 'Number');
    }
    module.exports = isNumber;


},{"./isKind":465}],467:[function(require,module,exports){
var isKind = require('./isKind');
    /**
     */
    function isObject(val) {
        return isKind(val, 'Object');
    }
    module.exports = isObject;


},{"./isKind":465}],468:[function(require,module,exports){


    /**
     * Checks if the value is created by the `Object` constructor.
     */
    function isPlainObject(value) {
        return (!!value && typeof value === 'object' &&
            value.constructor === Object);
    }

    module.exports = isPlainObject;



},{}],469:[function(require,module,exports){
var isKind = require('./isKind');
    /**
     */
    function isRegExp(val) {
        return isKind(val, 'RegExp');
    }
    module.exports = isRegExp;


},{"./isKind":465}],470:[function(require,module,exports){


    var _rKind = /^\[object (.*)\]$/,
        _toString = Object.prototype.toString,
        UNDEF;

    /**
     * Gets the "kind" of value. (e.g. "String", "Number", etc)
     */
    function kindOf(val) {
        if (val === null) {
            return 'Null';
        } else if (val === UNDEF) {
            return 'Undefined';
        } else {
            return _rKind.exec( _toString.call(val) )[1];
        }
    }
    module.exports = kindOf;


},{}],471:[function(require,module,exports){


    /**
     * Typecast a value to a String, using an empty string value for null or
     * undefined.
     */
    function toString(val){
        return val == null ? '' : val.toString();
    }

    module.exports = toString;



},{}],472:[function(require,module,exports){
var forOwn = require('./forOwn');
var isArray = require('../lang/isArray');

    function containsMatch(array, pattern) {
        var i = -1, length = array.length;
        while (++i < length) {
            if (deepMatches(array[i], pattern)) {
                return true;
            }
        }

        return false;
    }

    function matchArray(target, pattern) {
        var i = -1, patternLength = pattern.length;
        while (++i < patternLength) {
            if (!containsMatch(target, pattern[i])) {
                return false;
            }
        }

        return true;
    }

    function matchObject(target, pattern) {
        var result = true;
        forOwn(pattern, function(val, key) {
            if (!deepMatches(target[key], val)) {
                // Return false to break out of forOwn early
                return (result = false);
            }
        });

        return result;
    }

    /**
     * Recursively check if the objects match.
     */
    function deepMatches(target, pattern){
        if (target && typeof target === 'object') {
            if (isArray(target) && isArray(pattern)) {
                return matchArray(target, pattern);
            } else {
                return matchObject(target, pattern);
            }
        } else {
            return target === pattern;
        }
    }

    module.exports = deepMatches;



},{"../lang/isArray":464,"./forOwn":477}],473:[function(require,module,exports){
var forOwn = require('./forOwn');
var isPlainObject = require('../lang/isPlainObject');

    /**
     * Mixes objects into the target object, recursively mixing existing child
     * objects.
     */
    function deepMixIn(target, objects) {
        var i = 0,
            n = arguments.length,
            obj;

        while(++i < n){
            obj = arguments[i];
            if (obj) {
                forOwn(obj, copyProp, target);
            }
        }

        return target;
    }

    function copyProp(val, key) {
        var existing = this[key];
        if (isPlainObject(val) && isPlainObject(existing)) {
            deepMixIn(existing, val);
        } else {
            this[key] = val;
        }
    }

    module.exports = deepMixIn;



},{"../lang/isPlainObject":468,"./forOwn":477}],474:[function(require,module,exports){
var hasOwn = require('./hasOwn');
var every = require('./every');
var isObject = require('../lang/isObject');
var is = require('../lang/is');

    // Makes a function to compare the object values from the specified compare
    // operation callback.
    function makeCompare(callback) {
        return function(value, key) {
            return hasOwn(this, key) && callback(value, this[key]);
        };
    }

    function checkProperties(value, key) {
        return hasOwn(this, key);
    }

    /**
     * Checks if two objects have the same keys and values.
     */
    function equals(a, b, callback) {
        callback = callback || is;

        if (!isObject(a) || !isObject(b)) {
            return callback(a, b);
        }

        return (every(a, makeCompare(callback), b) &&
                every(b, checkProperties, a));
    }

    module.exports = equals;


},{"../lang/is":463,"../lang/isObject":467,"./every":475,"./hasOwn":478}],475:[function(require,module,exports){
var forOwn = require('./forOwn');
var makeIterator = require('../function/makeIterator_');

    /**
     * Object every
     */
    function every(obj, callback, thisObj) {
        callback = makeIterator(callback, thisObj);
        var result = true;
        forOwn(obj, function(val, key) {
            // we consider any falsy values as "false" on purpose so shorthand
            // syntax can be used to check property existence
            if (!callback(val, key, obj)) {
                result = false;
                return false; // break
            }
        });
        return result;
    }

    module.exports = every;



},{"../function/makeIterator_":457,"./forOwn":477}],476:[function(require,module,exports){
var hasOwn = require('./hasOwn');

    var _hasDontEnumBug,
        _dontEnums;

    function checkDontEnum(){
        _dontEnums = [
                'toString',
                'toLocaleString',
                'valueOf',
                'hasOwnProperty',
                'isPrototypeOf',
                'propertyIsEnumerable',
                'constructor'
            ];

        _hasDontEnumBug = true;

        for (var key in {'toString': null}) {
            _hasDontEnumBug = false;
        }
    }

    /**
     * Similar to Array/forEach but works over object properties and fixes Don't
     * Enum bug on IE.
     * based on: http://whattheheadsaid.com/2010/10/a-safer-object-keys-compatibility-implementation
     */
    function forIn(obj, fn, thisObj){
        var key, i = 0;
        // no need to check if argument is a real object that way we can use
        // it for arrays, functions, date, etc.

        //post-pone check till needed
        if (_hasDontEnumBug == null) checkDontEnum();

        for (key in obj) {
            if (exec(fn, obj, key, thisObj) === false) {
                break;
            }
        }


        if (_hasDontEnumBug) {
            var ctor = obj.constructor,
                isProto = !!ctor && obj === ctor.prototype;

            while (key = _dontEnums[i++]) {
                // For constructor, if it is a prototype object the constructor
                // is always non-enumerable unless defined otherwise (and
                // enumerated above).  For non-prototype objects, it will have
                // to be defined on this object, since it cannot be defined on
                // any prototype objects.
                //
                // For other [[DontEnum]] properties, check if the value is
                // different than Object prototype value.
                if (
                    (key !== 'constructor' ||
                        (!isProto && hasOwn(obj, key))) &&
                    obj[key] !== Object.prototype[key]
                ) {
                    if (exec(fn, obj, key, thisObj) === false) {
                        break;
                    }
                }
            }
        }
    }

    function exec(fn, obj, key, thisObj){
        return fn.call(thisObj, obj[key], key, obj);
    }

    module.exports = forIn;



},{"./hasOwn":478}],477:[function(require,module,exports){
var hasOwn = require('./hasOwn');
var forIn = require('./forIn');

    /**
     * Similar to Array/forEach but works over object properties and fixes Don't
     * Enum bug on IE.
     * based on: http://whattheheadsaid.com/2010/10/a-safer-object-keys-compatibility-implementation
     */
    function forOwn(obj, fn, thisObj){
        forIn(obj, function(val, key){
            if (hasOwn(obj, key)) {
                return fn.call(thisObj, obj[key], key, obj);
            }
        });
    }

    module.exports = forOwn;



},{"./forIn":476,"./hasOwn":478}],478:[function(require,module,exports){


    /**
     * Safer Object.hasOwnProperty
     */
     function hasOwn(obj, prop){
         return Object.prototype.hasOwnProperty.call(obj, prop);
     }

     module.exports = hasOwn;



},{}],479:[function(require,module,exports){
var hasOwn = require('./hasOwn');
var deepClone = require('../lang/deepClone');
var isObject = require('../lang/isObject');

    /**
     * Deep merge objects.
     */
    function merge() {
        var i = 1,
            key, val, obj, target;

        // make sure we don't modify source element and it's properties
        // objects are passed by reference
        target = deepClone( arguments[0] );

        while (obj = arguments[i++]) {
            for (key in obj) {
                if ( ! hasOwn(obj, key) ) {
                    continue;
                }

                val = obj[key];

                if ( isObject(val) && isObject(target[key]) ){
                    // inception, deep merge objects
                    target[key] = merge(target[key], val);
                } else {
                    // make sure arrays, regexp, date, objects are cloned
                    target[key] = deepClone(val);
                }

            }
        }

        return target;
    }

    module.exports = merge;



},{"../lang/deepClone":461,"../lang/isObject":467,"./hasOwn":478}],480:[function(require,module,exports){
var forOwn = require('./forOwn');

    /**
    * Combine properties from all the objects into first one.
    * - This method affects target object in place, if you want to create a new Object pass an empty object as first param.
    * @param {object} target    Target Object
    * @param {...object} objects    Objects to be combined (0...n objects).
    * @return {object} Target Object.
    */
    function mixIn(target, objects){
        var i = 0,
            n = arguments.length,
            obj;
        while(++i < n){
            obj = arguments[i];
            if (obj != null) {
                forOwn(obj, copyProp, target);
            }
        }
        return target;
    }

    function copyProp(val, key){
        this[key] = val;
    }

    module.exports = mixIn;


},{"./forOwn":477}],481:[function(require,module,exports){
var slice = require('../array/slice');

    /**
     * Return a copy of the object, filtered to only have values for the whitelisted keys.
     */
    function pick(obj, var_keys){
        var keys = typeof arguments[1] !== 'string'? arguments[1] : slice(arguments, 1),
            out = {},
            i = 0, key;
        while (key = keys[i++]) {
            out[key] = obj[key];
        }
        return out;
    }

    module.exports = pick;



},{"../array/slice":453}],482:[function(require,module,exports){

    /**
     * Contains all Unicode white-spaces. Taken from
     * http://en.wikipedia.org/wiki/Whitespace_character.
     */
    module.exports = [
        ' ', '\n', '\r', '\t', '\f', '\v', '\u00A0', '\u1680', '\u180E',
        '\u2000', '\u2001', '\u2002', '\u2003', '\u2004', '\u2005', '\u2006',
        '\u2007', '\u2008', '\u2009', '\u200A', '\u2028', '\u2029', '\u202F',
        '\u205F', '\u3000'
    ];


},{}],483:[function(require,module,exports){
var toString = require('../lang/toString');

    /**
     * Escape RegExp string chars.
     */
    function escapeRegExp(str) {
        return toString(str).replace(/\W/g,'\\$&');
    }

    module.exports = escapeRegExp;



},{"../lang/toString":471}],484:[function(require,module,exports){
var toString = require('../lang/toString');
var WHITE_SPACES = require('./WHITE_SPACES');
    /**
     * Remove chars from beginning of string.
     */
    function ltrim(str, chars) {
        str = toString(str);
        chars = chars || WHITE_SPACES;

        var start = 0,
            len = str.length,
            charLen = chars.length,
            found = true,
            i, c;

        while (found && start < len) {
            found = false;
            i = -1;
            c = str.charAt(start);

            while (++i < charLen) {
                if (c === chars[i]) {
                    found = true;
                    start++;
                    break;
                }
            }
        }

        return (start >= len) ? '' : str.substr(start, len);
    }

    module.exports = ltrim;


},{"../lang/toString":471,"./WHITE_SPACES":482}],485:[function(require,module,exports){
var toString = require('../lang/toString');
var WHITE_SPACES = require('./WHITE_SPACES');
    /**
     * Remove chars from end of string.
     */
    function rtrim(str, chars) {
        str = toString(str);
        chars = chars || WHITE_SPACES;

        var end = str.length - 1,
            charLen = chars.length,
            found = true,
            i, c;

        while (found && end >= 0) {
            found = false;
            i = -1;
            c = str.charAt(end);

            while (++i < charLen) {
                if (c === chars[i]) {
                    found = true;
                    end--;
                    break;
                }
            }
        }

        return (end >= 0) ? str.substring(0, end + 1) : '';
    }

    module.exports = rtrim;


},{"../lang/toString":471,"./WHITE_SPACES":482}],486:[function(require,module,exports){
var toString = require('../lang/toString');
var WHITE_SPACES = require('./WHITE_SPACES');
var ltrim = require('./ltrim');
var rtrim = require('./rtrim');
    /**
     * Remove white-spaces from beginning and end of string.
     */
    function trim(str, chars) {
        str = toString(str);
        chars = chars || WHITE_SPACES;
        return ltrim(rtrim(str, chars), chars);
    }

    module.exports = trim;


},{"../lang/toString":471,"./WHITE_SPACES":482,"./ltrim":484,"./rtrim":485}],487:[function(require,module,exports){


    /**
     * Get current time in miliseconds
     */
    function now(){
        // yes, we defer the work to another function to allow mocking it
        // during the tests
        return now.get();
    }

    now.get = (typeof Date.now === 'function')? Date.now : function(){
        return +(new Date());
    };

    module.exports = now;



},{}],488:[function(require,module,exports){
/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */

module.exports = function(val, options) {
  options = options || {};
  var type = typeof val;
  if (type === 'string' && val.length > 0) {
    return parse(val);
  } else if (type === 'number' && isNaN(val) === false) {
    return options.long ? fmtLong(val) : fmtShort(val);
  }
  throw new Error(
    'val is not a non-empty string or a valid number. val=' +
      JSON.stringify(val)
  );
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  str = String(str);
  if (str.length > 100) {
    return;
  }
  var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(
    str
  );
  if (!match) {
    return;
  }
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
    default:
      return undefined;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtShort(ms) {
  if (ms >= d) {
    return Math.round(ms / d) + 'd';
  }
  if (ms >= h) {
    return Math.round(ms / h) + 'h';
  }
  if (ms >= m) {
    return Math.round(ms / m) + 'm';
  }
  if (ms >= s) {
    return Math.round(ms / s) + 's';
  }
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtLong(ms) {
  return plural(ms, d, 'day') ||
    plural(ms, h, 'hour') ||
    plural(ms, m, 'minute') ||
    plural(ms, s, 'second') ||
    ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, n, name) {
  if (ms < n) {
    return;
  }
  if (ms < n * 1.5) {
    return Math.floor(ms / n) + ' ' + name;
  }
  return Math.ceil(ms / n) + ' ' + name + 's';
}

},{}],489:[function(require,module,exports){
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/

'use strict';
/* eslint-disable no-unused-vars */
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;

function toObject(val) {
	if (val === null || val === undefined) {
		throw new TypeError('Object.assign cannot be called with null or undefined');
	}

	return Object(val);
}

function shouldUseNative() {
	try {
		if (!Object.assign) {
			return false;
		}

		// Detect buggy property enumeration order in older V8 versions.

		// https://bugs.chromium.org/p/v8/issues/detail?id=4118
		var test1 = new String('abc');  // eslint-disable-line no-new-wrappers
		test1[5] = 'de';
		if (Object.getOwnPropertyNames(test1)[0] === '5') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test2 = {};
		for (var i = 0; i < 10; i++) {
			test2['_' + String.fromCharCode(i)] = i;
		}
		var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
			return test2[n];
		});
		if (order2.join('') !== '0123456789') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test3 = {};
		'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
			test3[letter] = letter;
		});
		if (Object.keys(Object.assign({}, test3)).join('') !==
				'abcdefghijklmnopqrst') {
			return false;
		}

		return true;
	} catch (err) {
		// We don't expect any of the above to throw, but better to be safe.
		return false;
	}
}

module.exports = shouldUseNative() ? Object.assign : function (target, source) {
	var from;
	var to = toObject(target);
	var symbols;

	for (var s = 1; s < arguments.length; s++) {
		from = Object(arguments[s]);

		for (var key in from) {
			if (hasOwnProperty.call(from, key)) {
				to[key] = from[key];
			}
		}

		if (getOwnPropertySymbols) {
			symbols = getOwnPropertySymbols(from);
			for (var i = 0; i < symbols.length; i++) {
				if (propIsEnumerable.call(from, symbols[i])) {
					to[symbols[i]] = from[symbols[i]];
				}
			}
		}
	}

	return to;
};

},{}],490:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],491:[function(require,module,exports){
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

'use strict';

if ("production" !== 'production') {
  var invariant = require('fbjs/lib/invariant');
  var warning = require('fbjs/lib/warning');
  var ReactPropTypesSecret = require('./lib/ReactPropTypesSecret');
  var loggedTypeFailures = {};
}

/**
 * Assert that the values match with the type specs.
 * Error messages are memorized and will only be shown once.
 *
 * @param {object} typeSpecs Map of name to a ReactPropType
 * @param {object} values Runtime values that need to be type-checked
 * @param {string} location e.g. "prop", "context", "child context"
 * @param {string} componentName Name of the component for error messages.
 * @param {?Function} getStack Returns the component stack.
 * @private
 */
function checkPropTypes(typeSpecs, values, location, componentName, getStack) {
  if ("production" !== 'production') {
    for (var typeSpecName in typeSpecs) {
      if (typeSpecs.hasOwnProperty(typeSpecName)) {
        var error;
        // Prop type validation may throw. In case they do, we don't want to
        // fail the render phase where it didn't fail before. So we log it.
        // After these have been cleaned up, we'll let them throw.
        try {
          // This is intentionally an invariant that gets caught. It's the same
          // behavior as without this statement except with a better message.
          invariant(typeof typeSpecs[typeSpecName] === 'function', '%s: %s type `%s` is invalid; it must be a function, usually from ' + 'the `prop-types` package, but received `%s`.', componentName || 'React class', location, typeSpecName, typeof typeSpecs[typeSpecName]);
          error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);
        } catch (ex) {
          error = ex;
        }
        warning(!error || error instanceof Error, '%s: type specification of %s `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', location, typeSpecName, typeof error);
        if (error instanceof Error && !(error.message in loggedTypeFailures)) {
          // Only monitor this failure once because there tends to be a lot of the
          // same error.
          loggedTypeFailures[error.message] = true;

          var stack = getStack ? getStack() : '';

          warning(false, 'Failed %s type: %s%s', location, error.message, stack != null ? stack : '');
        }
      }
    }
  }
}

module.exports = checkPropTypes;

},{"./lib/ReactPropTypesSecret":496,"fbjs/lib/invariant":402,"fbjs/lib/warning":409}],492:[function(require,module,exports){
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

'use strict';

// React 15.5 references this module, and assumes PropTypes are still callable in production.
// Therefore we re-export development-only version with all the PropTypes checks here.
// However if one is migrating to the `prop-types` npm library, they will go through the
// `index.js` entry point, and it will branch depending on the environment.
var factory = require('./factoryWithTypeCheckers');
module.exports = function(isValidElement) {
  // It is still allowed in 15.5.
  var throwOnDirectAccess = false;
  return factory(isValidElement, throwOnDirectAccess);
};

},{"./factoryWithTypeCheckers":494}],493:[function(require,module,exports){
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

'use strict';

var emptyFunction = require('fbjs/lib/emptyFunction');
var invariant = require('fbjs/lib/invariant');
var ReactPropTypesSecret = require('./lib/ReactPropTypesSecret');

module.exports = function() {
  function shim(props, propName, componentName, location, propFullName, secret) {
    if (secret === ReactPropTypesSecret) {
      // It is still safe when called from React.
      return;
    }
    invariant(
      false,
      'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +
      'Use PropTypes.checkPropTypes() to call them. ' +
      'Read more at http://fb.me/use-check-prop-types'
    );
  };
  shim.isRequired = shim;
  function getShim() {
    return shim;
  };
  // Important!
  // Keep this list in sync with production version in `./factoryWithTypeCheckers.js`.
  var ReactPropTypes = {
    array: shim,
    bool: shim,
    func: shim,
    number: shim,
    object: shim,
    string: shim,
    symbol: shim,

    any: shim,
    arrayOf: getShim,
    element: shim,
    instanceOf: getShim,
    node: shim,
    objectOf: getShim,
    oneOf: getShim,
    oneOfType: getShim,
    shape: getShim,
    exact: getShim
  };

  ReactPropTypes.checkPropTypes = emptyFunction;
  ReactPropTypes.PropTypes = ReactPropTypes;

  return ReactPropTypes;
};

},{"./lib/ReactPropTypesSecret":496,"fbjs/lib/emptyFunction":394,"fbjs/lib/invariant":402}],494:[function(require,module,exports){
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

'use strict';

var emptyFunction = require('fbjs/lib/emptyFunction');
var invariant = require('fbjs/lib/invariant');
var warning = require('fbjs/lib/warning');
var assign = require('object-assign');

var ReactPropTypesSecret = require('./lib/ReactPropTypesSecret');
var checkPropTypes = require('./checkPropTypes');

module.exports = function(isValidElement, throwOnDirectAccess) {
  /* global Symbol */
  var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
  var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.

  /**
   * Returns the iterator method function contained on the iterable object.
   *
   * Be sure to invoke the function with the iterable as context:
   *
   *     var iteratorFn = getIteratorFn(myIterable);
   *     if (iteratorFn) {
   *       var iterator = iteratorFn.call(myIterable);
   *       ...
   *     }
   *
   * @param {?object} maybeIterable
   * @return {?function}
   */
  function getIteratorFn(maybeIterable) {
    var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
    if (typeof iteratorFn === 'function') {
      return iteratorFn;
    }
  }

  /**
   * Collection of methods that allow declaration and validation of props that are
   * supplied to React components. Example usage:
   *
   *   var Props = require('ReactPropTypes');
   *   var MyArticle = React.createClass({
   *     propTypes: {
   *       // An optional string prop named "description".
   *       description: Props.string,
   *
   *       // A required enum prop named "category".
   *       category: Props.oneOf(['News','Photos']).isRequired,
   *
   *       // A prop named "dialog" that requires an instance of Dialog.
   *       dialog: Props.instanceOf(Dialog).isRequired
   *     },
   *     render: function() { ... }
   *   });
   *
   * A more formal specification of how these methods are used:
   *
   *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)
   *   decl := ReactPropTypes.{type}(.isRequired)?
   *
   * Each and every declaration produces a function with the same signature. This
   * allows the creation of custom validation functions. For example:
   *
   *  var MyLink = React.createClass({
   *    propTypes: {
   *      // An optional string or URI prop named "href".
   *      href: function(props, propName, componentName) {
   *        var propValue = props[propName];
   *        if (propValue != null && typeof propValue !== 'string' &&
   *            !(propValue instanceof URI)) {
   *          return new Error(
   *            'Expected a string or an URI for ' + propName + ' in ' +
   *            componentName
   *          );
   *        }
   *      }
   *    },
   *    render: function() {...}
   *  });
   *
   * @internal
   */

  var ANONYMOUS = '<<anonymous>>';

  // Important!
  // Keep this list in sync with production version in `./factoryWithThrowingShims.js`.
  var ReactPropTypes = {
    array: createPrimitiveTypeChecker('array'),
    bool: createPrimitiveTypeChecker('boolean'),
    func: createPrimitiveTypeChecker('function'),
    number: createPrimitiveTypeChecker('number'),
    object: createPrimitiveTypeChecker('object'),
    string: createPrimitiveTypeChecker('string'),
    symbol: createPrimitiveTypeChecker('symbol'),

    any: createAnyTypeChecker(),
    arrayOf: createArrayOfTypeChecker,
    element: createElementTypeChecker(),
    instanceOf: createInstanceTypeChecker,
    node: createNodeChecker(),
    objectOf: createObjectOfTypeChecker,
    oneOf: createEnumTypeChecker,
    oneOfType: createUnionTypeChecker,
    shape: createShapeTypeChecker,
    exact: createStrictShapeTypeChecker,
  };

  /**
   * inlined Object.is polyfill to avoid requiring consumers ship their own
   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
   */
  /*eslint-disable no-self-compare*/
  function is(x, y) {
    // SameValue algorithm
    if (x === y) {
      // Steps 1-5, 7-10
      // Steps 6.b-6.e: +0 != -0
      return x !== 0 || 1 / x === 1 / y;
    } else {
      // Step 6.a: NaN == NaN
      return x !== x && y !== y;
    }
  }
  /*eslint-enable no-self-compare*/

  /**
   * We use an Error-like object for backward compatibility as people may call
   * PropTypes directly and inspect their output. However, we don't use real
   * Errors anymore. We don't inspect their stack anyway, and creating them
   * is prohibitively expensive if they are created too often, such as what
   * happens in oneOfType() for any type before the one that matched.
   */
  function PropTypeError(message) {
    this.message = message;
    this.stack = '';
  }
  // Make `instanceof Error` still work for returned errors.
  PropTypeError.prototype = Error.prototype;

  function createChainableTypeChecker(validate) {
    if ("production" !== 'production') {
      var manualPropTypeCallCache = {};
      var manualPropTypeWarningCount = 0;
    }
    function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
      componentName = componentName || ANONYMOUS;
      propFullName = propFullName || propName;

      if (secret !== ReactPropTypesSecret) {
        if (throwOnDirectAccess) {
          // New behavior only for users of `prop-types` package
          invariant(
            false,
            'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +
            'Use `PropTypes.checkPropTypes()` to call them. ' +
            'Read more at http://fb.me/use-check-prop-types'
          );
        } else if ("production" !== 'production' && typeof console !== 'undefined') {
          // Old behavior for people using React.PropTypes
          var cacheKey = componentName + ':' + propName;
          if (
            !manualPropTypeCallCache[cacheKey] &&
            // Avoid spamming the console because they are often not actionable except for lib authors
            manualPropTypeWarningCount < 3
          ) {
            warning(
              false,
              'You are manually calling a React.PropTypes validation ' +
              'function for the `%s` prop on `%s`. This is deprecated ' +
              'and will throw in the standalone `prop-types` package. ' +
              'You may be seeing this warning due to a third-party PropTypes ' +
              'library. See https://fb.me/react-warning-dont-call-proptypes ' + 'for details.',
              propFullName,
              componentName
            );
            manualPropTypeCallCache[cacheKey] = true;
            manualPropTypeWarningCount++;
          }
        }
      }
      if (props[propName] == null) {
        if (isRequired) {
          if (props[propName] === null) {
            return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required ' + ('in `' + componentName + '`, but its value is `null`.'));
          }
          return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required in ' + ('`' + componentName + '`, but its value is `undefined`.'));
        }
        return null;
      } else {
        return validate(props, propName, componentName, location, propFullName);
      }
    }

    var chainedCheckType = checkType.bind(null, false);
    chainedCheckType.isRequired = checkType.bind(null, true);

    return chainedCheckType;
  }

  function createPrimitiveTypeChecker(expectedType) {
    function validate(props, propName, componentName, location, propFullName, secret) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== expectedType) {
        // `propValue` being instance of, say, date/regexp, pass the 'object'
        // check, but we can offer a more precise error message here rather than
        // 'of type `object`'.
        var preciseType = getPreciseType(propValue);

        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + preciseType + '` supplied to `' + componentName + '`, expected ') + ('`' + expectedType + '`.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createAnyTypeChecker() {
    return createChainableTypeChecker(emptyFunction.thatReturnsNull);
  }

  function createArrayOfTypeChecker(typeChecker) {
    function validate(props, propName, componentName, location, propFullName) {
      if (typeof typeChecker !== 'function') {
        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside arrayOf.');
      }
      var propValue = props[propName];
      if (!Array.isArray(propValue)) {
        var propType = getPropType(propValue);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an array.'));
      }
      for (var i = 0; i < propValue.length; i++) {
        var error = typeChecker(propValue, i, componentName, location, propFullName + '[' + i + ']', ReactPropTypesSecret);
        if (error instanceof Error) {
          return error;
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createElementTypeChecker() {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      if (!isValidElement(propValue)) {
        var propType = getPropType(propValue);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createInstanceTypeChecker(expectedClass) {
    function validate(props, propName, componentName, location, propFullName) {
      if (!(props[propName] instanceof expectedClass)) {
        var expectedClassName = expectedClass.name || ANONYMOUS;
        var actualClassName = getClassName(props[propName]);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + actualClassName + '` supplied to `' + componentName + '`, expected ') + ('instance of `' + expectedClassName + '`.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createEnumTypeChecker(expectedValues) {
    if (!Array.isArray(expectedValues)) {
      "production" !== 'production' ? warning(false, 'Invalid argument supplied to oneOf, expected an instance of array.') : void 0;
      return emptyFunction.thatReturnsNull;
    }

    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      for (var i = 0; i < expectedValues.length; i++) {
        if (is(propValue, expectedValues[i])) {
          return null;
        }
      }

      var valuesString = JSON.stringify(expectedValues);
      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of value `' + propValue + '` ' + ('supplied to `' + componentName + '`, expected one of ' + valuesString + '.'));
    }
    return createChainableTypeChecker(validate);
  }

  function createObjectOfTypeChecker(typeChecker) {
    function validate(props, propName, componentName, location, propFullName) {
      if (typeof typeChecker !== 'function') {
        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside objectOf.');
      }
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an object.'));
      }
      for (var key in propValue) {
        if (propValue.hasOwnProperty(key)) {
          var error = typeChecker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
          if (error instanceof Error) {
            return error;
          }
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createUnionTypeChecker(arrayOfTypeCheckers) {
    if (!Array.isArray(arrayOfTypeCheckers)) {
      "production" !== 'production' ? warning(false, 'Invalid argument supplied to oneOfType, expected an instance of array.') : void 0;
      return emptyFunction.thatReturnsNull;
    }

    for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
      var checker = arrayOfTypeCheckers[i];
      if (typeof checker !== 'function') {
        warning(
          false,
          'Invalid argument supplied to oneOfType. Expected an array of check functions, but ' +
          'received %s at index %s.',
          getPostfixForTypeWarning(checker),
          i
        );
        return emptyFunction.thatReturnsNull;
      }
    }

    function validate(props, propName, componentName, location, propFullName) {
      for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
        var checker = arrayOfTypeCheckers[i];
        if (checker(props, propName, componentName, location, propFullName, ReactPropTypesSecret) == null) {
          return null;
        }
      }

      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`.'));
    }
    return createChainableTypeChecker(validate);
  }

  function createNodeChecker() {
    function validate(props, propName, componentName, location, propFullName) {
      if (!isNode(props[propName])) {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a ReactNode.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createShapeTypeChecker(shapeTypes) {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
      }
      for (var key in shapeTypes) {
        var checker = shapeTypes[key];
        if (!checker) {
          continue;
        }
        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
        if (error) {
          return error;
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createStrictShapeTypeChecker(shapeTypes) {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
      }
      // We need to check all keys in case some are required but missing from
      // props.
      var allKeys = assign({}, props[propName], shapeTypes);
      for (var key in allKeys) {
        var checker = shapeTypes[key];
        if (!checker) {
          return new PropTypeError(
            'Invalid ' + location + ' `' + propFullName + '` key `' + key + '` supplied to `' + componentName + '`.' +
            '\nBad object: ' + JSON.stringify(props[propName], null, '  ') +
            '\nValid keys: ' +  JSON.stringify(Object.keys(shapeTypes), null, '  ')
          );
        }
        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
        if (error) {
          return error;
        }
      }
      return null;
    }

    return createChainableTypeChecker(validate);
  }

  function isNode(propValue) {
    switch (typeof propValue) {
      case 'number':
      case 'string':
      case 'undefined':
        return true;
      case 'boolean':
        return !propValue;
      case 'object':
        if (Array.isArray(propValue)) {
          return propValue.every(isNode);
        }
        if (propValue === null || isValidElement(propValue)) {
          return true;
        }

        var iteratorFn = getIteratorFn(propValue);
        if (iteratorFn) {
          var iterator = iteratorFn.call(propValue);
          var step;
          if (iteratorFn !== propValue.entries) {
            while (!(step = iterator.next()).done) {
              if (!isNode(step.value)) {
                return false;
              }
            }
          } else {
            // Iterator will provide entry [k,v] tuples rather than values.
            while (!(step = iterator.next()).done) {
              var entry = step.value;
              if (entry) {
                if (!isNode(entry[1])) {
                  return false;
                }
              }
            }
          }
        } else {
          return false;
        }

        return true;
      default:
        return false;
    }
  }

  function isSymbol(propType, propValue) {
    // Native Symbol.
    if (propType === 'symbol') {
      return true;
    }

    // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'
    if (propValue['@@toStringTag'] === 'Symbol') {
      return true;
    }

    // Fallback for non-spec compliant Symbols which are polyfilled.
    if (typeof Symbol === 'function' && propValue instanceof Symbol) {
      return true;
    }

    return false;
  }

  // Equivalent of `typeof` but with special handling for array and regexp.
  function getPropType(propValue) {
    var propType = typeof propValue;
    if (Array.isArray(propValue)) {
      return 'array';
    }
    if (propValue instanceof RegExp) {
      // Old webkits (at least until Android 4.0) return 'function' rather than
      // 'object' for typeof a RegExp. We'll normalize this here so that /bla/
      // passes PropTypes.object.
      return 'object';
    }
    if (isSymbol(propType, propValue)) {
      return 'symbol';
    }
    return propType;
  }

  // This handles more types than `getPropType`. Only used for error messages.
  // See `createPrimitiveTypeChecker`.
  function getPreciseType(propValue) {
    if (typeof propValue === 'undefined' || propValue === null) {
      return '' + propValue;
    }
    var propType = getPropType(propValue);
    if (propType === 'object') {
      if (propValue instanceof Date) {
        return 'date';
      } else if (propValue instanceof RegExp) {
        return 'regexp';
      }
    }
    return propType;
  }

  // Returns a string that is postfixed to a warning about an invalid type.
  // For example, "undefined" or "of type array"
  function getPostfixForTypeWarning(value) {
    var type = getPreciseType(value);
    switch (type) {
      case 'array':
      case 'object':
        return 'an ' + type;
      case 'boolean':
      case 'date':
      case 'regexp':
        return 'a ' + type;
      default:
        return type;
    }
  }

  // Returns class name of the object, if any.
  function getClassName(propValue) {
    if (!propValue.constructor || !propValue.constructor.name) {
      return ANONYMOUS;
    }
    return propValue.constructor.name;
  }

  ReactPropTypes.checkPropTypes = checkPropTypes;
  ReactPropTypes.PropTypes = ReactPropTypes;

  return ReactPropTypes;
};

},{"./checkPropTypes":491,"./lib/ReactPropTypesSecret":496,"fbjs/lib/emptyFunction":394,"fbjs/lib/invariant":402,"fbjs/lib/warning":409,"object-assign":489}],495:[function(require,module,exports){
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

if ("production" !== 'production') {
  var REACT_ELEMENT_TYPE = (typeof Symbol === 'function' &&
    Symbol.for &&
    Symbol.for('react.element')) ||
    0xeac7;

  var isValidElement = function(object) {
    return typeof object === 'object' &&
      object !== null &&
      object.$$typeof === REACT_ELEMENT_TYPE;
  };

  // By explicitly using `prop-types` you are opting into new development behavior.
  // http://fb.me/prop-types-in-prod
  var throwOnDirectAccess = true;
  module.exports = require('./factoryWithTypeCheckers')(isValidElement, throwOnDirectAccess);
} else {
  // By explicitly using `prop-types` you are opting into new production behavior.
  // http://fb.me/prop-types-in-prod
  module.exports = require('./factoryWithThrowingShims')();
}

},{"./factoryWithThrowingShims":493,"./factoryWithTypeCheckers":494}],496:[function(require,module,exports){
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

'use strict';

var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';

module.exports = ReactPropTypesSecret;

},{}],497:[function(require,module,exports){
var _curry2 = require('./internal/_curry2');
var _dispatchable = require('./internal/_dispatchable');
var _xall = require('./internal/_xall');


/**
 * Returns `true` if all elements of the list match the predicate, `false` if there are any
 * that don't.
 *
 * Acts as a transducer if a transformer is given in list position.
 * @see R.transduce
 *
 * @func
 * @memberOf R
 * @category List
 * @sig (a -> Boolean) -> [a] -> Boolean
 * @param {Function} fn The predicate function.
 * @param {Array} list The array to consider.
 * @return {Boolean} `true` if the predicate is satisfied by every element, `false`
 *         otherwise.
 * @see R.any, R.none
 * @example
 *
 *      var lessThan2 = R.flip(R.lt)(2);
 *      var lessThan3 = R.flip(R.lt)(3);
 *      R.all(lessThan2)([1, 2]); //=> false
 *      R.all(lessThan3)([1, 2]); //=> true
 */
module.exports = _curry2(_dispatchable('all', _xall, function all(fn, list) {
  var idx = 0;
  while (idx < list.length) {
    if (!fn(list[idx])) {
      return false;
    }
    idx += 1;
  }
  return true;
}));

},{"./internal/_curry2":504,"./internal/_dispatchable":505,"./internal/_xall":515}],498:[function(require,module,exports){
var _contains = require('./internal/_contains');
var _curry2 = require('./internal/_curry2');


/**
 * Returns `true` if the specified value is equal, in `R.equals` terms,
 * to at least one element of the given list; `false` otherwise.
 *
 * @func
 * @memberOf R
 * @category List
 * @sig a -> [a] -> Boolean
 * @param {Object} a The item to compare against.
 * @param {Array} list The array to consider.
 * @return {Boolean} `true` if the item is in the list, `false` otherwise.
 *
 * @example
 *
 *      R.contains(3, [1, 2, 3]); //=> true
 *      R.contains(4, [1, 2, 3]); //=> false
 *      R.contains([42], [[42]]); //=> true
 */
module.exports = _curry2(_contains);

},{"./internal/_contains":502,"./internal/_curry2":504}],499:[function(require,module,exports){
var _curry2 = require('./internal/_curry2');
var _equals = require('./internal/_equals');
var _hasMethod = require('./internal/_hasMethod');


/**
 * Returns `true` if its arguments are equivalent, `false` otherwise.
 * Dispatches to an `equals` method if present. Handles cyclical data
 * structures.
 *
 * @func
 * @memberOf R
 * @category Relation
 * @sig a -> b -> Boolean
 * @param {*} a
 * @param {*} b
 * @return {Boolean}
 * @example
 *
 *      R.equals(1, 1); //=> true
 *      R.equals(1, '1'); //=> false
 *      R.equals([1, 2, 3], [1, 2, 3]); //=> true
 *
 *      var a = {}; a.v = a;
 *      var b = {}; b.v = b;
 *      R.equals(a, b); //=> true
 */
module.exports = _curry2(function equals(a, b) {
  return _hasMethod('equals', a) ? a.equals(b) :
         _hasMethod('equals', b) ? b.equals(a) : _equals(a, b, [], []);
});

},{"./internal/_curry2":504,"./internal/_equals":506,"./internal/_hasMethod":508}],500:[function(require,module,exports){
var _curry2 = require('./internal/_curry2');
var _has = require('./internal/_has');


/**
 * Returns whether or not an object has an own property with
 * the specified name
 *
 * @func
 * @memberOf R
 * @category Object
 * @sig s -> {s: x} -> Boolean
 * @param {String} prop The name of the property to check for.
 * @param {Object} obj The object to query.
 * @return {Boolean} Whether the property exists.
 * @example
 *
 *      var hasName = R.has('name');
 *      hasName({name: 'alice'});   //=> true
 *      hasName({name: 'bob'});     //=> true
 *      hasName({});                //=> false
 *
 *      var point = {x: 0, y: 0};
 *      var pointHas = R.has(R.__, point);
 *      pointHas('x');  //=> true
 *      pointHas('y');  //=> true
 *      pointHas('z');  //=> false
 */
module.exports = _curry2(_has);

},{"./internal/_curry2":504,"./internal/_has":507}],501:[function(require,module,exports){
var _curry2 = require('./internal/_curry2');


/**
 * Returns true if its arguments are identical, false otherwise. Values are
 * identical if they reference the same memory. `NaN` is identical to `NaN`;
 * `0` and `-0` are not identical.
 *
 * @func
 * @memberOf R
 * @category Relation
 * @sig a -> a -> Boolean
 * @param {*} a
 * @param {*} b
 * @return {Boolean}
 * @example
 *
 *      var o = {};
 *      R.identical(o, o); //=> true
 *      R.identical(1, 1); //=> true
 *      R.identical(1, '1'); //=> false
 *      R.identical([], []); //=> false
 *      R.identical(0, -0); //=> false
 *      R.identical(NaN, NaN); //=> true
 */
module.exports = _curry2(function identical(a, b) {
  // SameValue algorithm
  if (a === b) { // Steps 1-5, 7-10
    // Steps 6.b-6.e: +0 != -0
    return a !== 0 || 1 / a === 1 / b;
  } else {
    // Step 6.a: NaN == NaN
    return a !== a && b !== b;
  }
});

},{"./internal/_curry2":504}],502:[function(require,module,exports){
var _indexOf = require('./_indexOf');


module.exports = function _contains(a, list) {
  return _indexOf(list, a, 0) >= 0;
};

},{"./_indexOf":509}],503:[function(require,module,exports){
/**
 * Optimized internal two-arity curry function.
 *
 * @private
 * @category Function
 * @param {Function} fn The function to curry.
 * @return {Function} The curried function.
 */
module.exports = function _curry1(fn) {
  return function f1(a) {
    if (arguments.length === 0) {
      return f1;
    } else if (a != null && a['@@functional/placeholder'] === true) {
      return f1;
    } else {
      return fn.apply(this, arguments);
    }
  };
};

},{}],504:[function(require,module,exports){
var _curry1 = require('./_curry1');


/**
 * Optimized internal two-arity curry function.
 *
 * @private
 * @category Function
 * @param {Function} fn The function to curry.
 * @return {Function} The curried function.
 */
module.exports = function _curry2(fn) {
  return function f2(a, b) {
    var n = arguments.length;
    if (n === 0) {
      return f2;
    } else if (n === 1 && a != null && a['@@functional/placeholder'] === true) {
      return f2;
    } else if (n === 1) {
      return _curry1(function(b) { return fn(a, b); });
    } else if (n === 2 && a != null && a['@@functional/placeholder'] === true &&
                          b != null && b['@@functional/placeholder'] === true) {
      return f2;
    } else if (n === 2 && a != null && a['@@functional/placeholder'] === true) {
      return _curry1(function(a) { return fn(a, b); });
    } else if (n === 2 && b != null && b['@@functional/placeholder'] === true) {
      return _curry1(function(b) { return fn(a, b); });
    } else {
      return fn(a, b);
    }
  };
};

},{"./_curry1":503}],505:[function(require,module,exports){
var _isArray = require('./_isArray');
var _isTransformer = require('./_isTransformer');
var _slice = require('./_slice');


/**
 * Returns a function that dispatches with different strategies based on the
 * object in list position (last argument). If it is an array, executes [fn].
 * Otherwise, if it has a  function with [methodname], it will execute that
 * function (functor case). Otherwise, if it is a transformer, uses transducer
 * [xf] to return a new transformer (transducer case). Otherwise, it will
 * default to executing [fn].
 *
 * @private
 * @param {String} methodname property to check for a custom implementation
 * @param {Function} xf transducer to initialize if object is transformer
 * @param {Function} fn default ramda implementation
 * @return {Function} A function that dispatches on object in list position
 */
module.exports = function _dispatchable(methodname, xf, fn) {
  return function() {
    var length = arguments.length;
    if (length === 0) {
      return fn();
    }
    var obj = arguments[length - 1];
    if (!_isArray(obj)) {
      var args = _slice(arguments, 0, length - 1);
      if (typeof obj[methodname] === 'function') {
        return obj[methodname].apply(obj, args);
      }
      if (_isTransformer(obj)) {
        var transducer = xf.apply(null, args);
        return transducer(obj);
      }
    }
    return fn.apply(this, arguments);
  };
};

},{"./_isArray":510,"./_isTransformer":511,"./_slice":514}],506:[function(require,module,exports){
var _has = require('./_has');
var identical = require('../identical');
var keys = require('../keys');
var type = require('../type');

// The algorithm used to handle cyclic structures is
// inspired by underscore's isEqual
module.exports = function _equals(a, b, stackA, stackB) {
  var typeA = type(a);
  if (typeA !== type(b)) {
    return false;
  }

  if (typeA === 'Boolean' || typeA === 'Number' || typeA === 'String') {
    return typeof a === 'object' ?
      typeof b === 'object' && identical(a.valueOf(), b.valueOf()) :
      identical(a, b);
  }

  if (identical(a, b)) {
    return true;
  }

  if (typeA === 'RegExp') {
    // RegExp equality algorithm: http://stackoverflow.com/a/10776635
    return (a.source === b.source) &&
           (a.global === b.global) &&
           (a.ignoreCase === b.ignoreCase) &&
           (a.multiline === b.multiline) &&
           (a.sticky === b.sticky) &&
           (a.unicode === b.unicode);
  }

  if (Object(a) === a) {
    if (typeA === 'Date' && a.getTime() !== b.getTime()) {
      return false;
    }

    var keysA = keys(a);
    if (keysA.length !== keys(b).length) {
      return false;
    }

    var idx = stackA.length - 1;
    while (idx >= 0) {
      if (stackA[idx] === a) {
        return stackB[idx] === b;
      }
      idx -= 1;
    }

    stackA[stackA.length] = a;
    stackB[stackB.length] = b;
    idx = keysA.length - 1;
    while (idx >= 0) {
      var key = keysA[idx];
      if (!_has(key, b) || !_equals(b[key], a[key], stackA, stackB)) {
        return false;
      }
      idx -= 1;
    }
    stackA.pop();
    stackB.pop();
    return true;
  }
  return false;
};

},{"../identical":501,"../keys":518,"../type":522,"./_has":507}],507:[function(require,module,exports){
module.exports = function _has(prop, obj) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
};

},{}],508:[function(require,module,exports){
var _isArray = require('./_isArray');


/**
 * Private function that determines whether or not a provided object has a given method.
 * Does not ignore methods stored on the object's prototype chain. Used for dynamically
 * dispatching Ramda methods to non-Array objects.
 *
 * @private
 * @param {String} methodName The name of the method to check for.
 * @param {Object} obj The object to test.
 * @return {Boolean} `true` has a given method, `false` otherwise.
 * @example
 *
 *      var person = { name: 'John' };
 *      person.shout = function() { alert(this.name); };
 *
 *      _hasMethod('shout', person); //=> true
 *      _hasMethod('foo', person); //=> false
 */
module.exports = function _hasMethod(methodName, obj) {
  return obj != null && !_isArray(obj) && typeof obj[methodName] === 'function';
};

},{"./_isArray":510}],509:[function(require,module,exports){
var equals = require('../equals');


module.exports = function _indexOf(list, item, from) {
  var idx = from;
  while (idx < list.length) {
    if (equals(list[idx], item)) {
      return idx;
    }
    idx += 1;
  }
  return -1;
};

},{"../equals":499}],510:[function(require,module,exports){
/**
 * Tests whether or not an object is an array.
 *
 * @private
 * @param {*} val The object to test.
 * @return {Boolean} `true` if `val` is an array, `false` otherwise.
 * @example
 *
 *      _isArray([]); //=> true
 *      _isArray(null); //=> false
 *      _isArray({}); //=> false
 */
module.exports = Array.isArray || function _isArray(val) {
  return (val != null &&
          val.length >= 0 &&
          Object.prototype.toString.call(val) === '[object Array]');
};

},{}],511:[function(require,module,exports){
module.exports = function _isTransformer(obj) {
  return typeof obj['@@transducer/step'] === 'function';
};

},{}],512:[function(require,module,exports){
module.exports = function _map(fn, list) {
  var idx = 0, len = list.length, result = Array(len);
  while (idx < len) {
    result[idx] = fn(list[idx]);
    idx += 1;
  }
  return result;
};

},{}],513:[function(require,module,exports){
module.exports = function _reduced(x) {
  return x && x['@@transducer/reduced'] ? x :
    {
      '@@transducer/value': x,
      '@@transducer/reduced': true
    };
};

},{}],514:[function(require,module,exports){
/**
 * An optimized, private array `slice` implementation.
 *
 * @private
 * @param {Arguments|Array} args The array or arguments object to consider.
 * @param {Number} [from=0] The array index to slice from, inclusive.
 * @param {Number} [to=args.length] The array index to slice to, exclusive.
 * @return {Array} A new, sliced array.
 * @example
 *
 *      _slice([1, 2, 3, 4, 5], 1, 3); //=> [2, 3]
 *
 *      var firstThreeArgs = function(a, b, c, d) {
 *        return _slice(arguments, 0, 3);
 *      };
 *      firstThreeArgs(1, 2, 3, 4); //=> [1, 2, 3]
 */
module.exports = function _slice(args, from, to) {
  switch (arguments.length) {
    case 1: return _slice(args, 0, args.length);
    case 2: return _slice(args, from, args.length);
    default:
      var list = [];
      var idx = 0;
      var len = Math.max(0, Math.min(args.length, to) - from);
      while (idx < len) {
        list[idx] = args[from + idx];
        idx += 1;
      }
      return list;
  }
};

},{}],515:[function(require,module,exports){
var _curry2 = require('./_curry2');
var _reduced = require('./_reduced');
var _xfBase = require('./_xfBase');


module.exports = (function() {
  function XAll(f, xf) {
    this.xf = xf;
    this.f = f;
    this.all = true;
  }
  XAll.prototype['@@transducer/init'] = _xfBase.init;
  XAll.prototype['@@transducer/result'] = function(result) {
    if (this.all) {
      result = this.xf['@@transducer/step'](result, true);
    }
    return this.xf['@@transducer/result'](result);
  };
  XAll.prototype['@@transducer/step'] = function(result, input) {
    if (!this.f(input)) {
      this.all = false;
      result = _reduced(this.xf['@@transducer/step'](result, false));
    }
    return result;
  };

  return _curry2(function _xall(f, xf) { return new XAll(f, xf); });
})();

},{"./_curry2":504,"./_reduced":513,"./_xfBase":516}],516:[function(require,module,exports){
module.exports = {
  init: function() {
    return this.xf['@@transducer/init']();
  },
  result: function(result) {
    return this.xf['@@transducer/result'](result);
  }
};

},{}],517:[function(require,module,exports){
var _curry2 = require('./_curry2');
var _xfBase = require('./_xfBase');


module.exports = (function() {
  function XMap(f, xf) {
    this.xf = xf;
    this.f = f;
  }
  XMap.prototype['@@transducer/init'] = _xfBase.init;
  XMap.prototype['@@transducer/result'] = _xfBase.result;
  XMap.prototype['@@transducer/step'] = function(result, input) {
    return this.xf['@@transducer/step'](result, this.f(input));
  };

  return _curry2(function _xmap(f, xf) { return new XMap(f, xf); });
})();

},{"./_curry2":504,"./_xfBase":516}],518:[function(require,module,exports){
var _curry1 = require('./internal/_curry1');
var _has = require('./internal/_has');


/**
 * Returns a list containing the names of all the enumerable own
 * properties of the supplied object.
 * Note that the order of the output array is not guaranteed to be
 * consistent across different JS platforms.
 *
 * @func
 * @memberOf R
 * @category Object
 * @sig {k: v} -> [k]
 * @param {Object} obj The object to extract properties from
 * @return {Array} An array of the object's own properties.
 * @example
 *
 *      R.keys({a: 1, b: 2, c: 3}); //=> ['a', 'b', 'c']
 */
module.exports = (function() {
  // cover IE < 9 keys issues
  var hasEnumBug = !({toString: null}).propertyIsEnumerable('toString');
  var nonEnumerableProps = ['constructor', 'valueOf', 'isPrototypeOf', 'toString',
                            'propertyIsEnumerable', 'hasOwnProperty', 'toLocaleString'];

  var contains = function contains(list, item) {
    var idx = 0;
    while (idx < list.length) {
      if (list[idx] === item) {
        return true;
      }
      idx += 1;
    }
    return false;
  };

  return typeof Object.keys === 'function' ?
    _curry1(function keys(obj) {
      return Object(obj) !== obj ? [] : Object.keys(obj);
    }) :
    _curry1(function keys(obj) {
      if (Object(obj) !== obj) {
        return [];
      }
      var prop, ks = [], nIdx;
      for (prop in obj) {
        if (_has(prop, obj)) {
          ks[ks.length] = prop;
        }
      }
      if (hasEnumBug) {
        nIdx = nonEnumerableProps.length - 1;
        while (nIdx >= 0) {
          prop = nonEnumerableProps[nIdx];
          if (_has(prop, obj) && !contains(ks, prop)) {
            ks[ks.length] = prop;
          }
          nIdx -= 1;
        }
      }
      return ks;
    });
}());

},{"./internal/_curry1":503,"./internal/_has":507}],519:[function(require,module,exports){
var _curry2 = require('./internal/_curry2');
var _dispatchable = require('./internal/_dispatchable');
var _map = require('./internal/_map');
var _xmap = require('./internal/_xmap');


/**
 * Returns a new list, constructed by applying the supplied function to every element of the
 * supplied list.
 *
 * Note: `R.map` does not skip deleted or unassigned indices (sparse arrays), unlike the
 * native `Array.prototype.map` method. For more details on this behavior, see:
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map#Description
 *
 * Acts as a transducer if a transformer is given in list position.
 * @see R.transduce
 *
 * @func
 * @memberOf R
 * @category List
 * @sig (a -> b) -> [a] -> [b]
 * @param {Function} fn The function to be called on every element of the input `list`.
 * @param {Array} list The list to be iterated over.
 * @return {Array} The new list.
 * @example
 *
 *      var double = function(x) {
 *        return x * 2;
 *      };
 *
 *      R.map(double, [1, 2, 3]); //=> [2, 4, 6]
 */
module.exports = _curry2(_dispatchable('map', _xmap, _map));

},{"./internal/_curry2":504,"./internal/_dispatchable":505,"./internal/_map":512,"./internal/_xmap":517}],520:[function(require,module,exports){
var _curry2 = require('./internal/_curry2');
var map = require('./map');
var prop = require('./prop');


/**
 * Returns a new list by plucking the same named property off all objects in the list supplied.
 *
 * @func
 * @memberOf R
 * @category List
 * @sig k -> [{k: v}] -> [v]
 * @param {Number|String} key The key name to pluck off of each object.
 * @param {Array} list The array to consider.
 * @return {Array} The list of values for the given key.
 * @example
 *
 *      R.pluck('a')([{a: 1}, {a: 2}]); //=> [1, 2]
 *      R.pluck(0)([[1, 2], [3, 4]]);   //=> [1, 3]
 */
module.exports = _curry2(function pluck(p, list) {
  return map(prop(p), list);
});

},{"./internal/_curry2":504,"./map":519,"./prop":521}],521:[function(require,module,exports){
var _curry2 = require('./internal/_curry2');


/**
 * Returns a function that when supplied an object returns the indicated property of that object, if it exists.
 *
 * @func
 * @memberOf R
 * @category Object
 * @sig s -> {s: a} -> a | Undefined
 * @param {String} p The property name
 * @param {Object} obj The object to query
 * @return {*} The value at `obj.p`.
 * @example
 *
 *      R.prop('x', {x: 100}); //=> 100
 *      R.prop('x', {}); //=> undefined
 */
module.exports = _curry2(function prop(p, obj) { return obj[p]; });

},{"./internal/_curry2":504}],522:[function(require,module,exports){
var _curry1 = require('./internal/_curry1');


/**
 * Gives a single-word string description of the (native) type of a value, returning such
 * answers as 'Object', 'Number', 'Array', or 'Null'.  Does not attempt to distinguish user
 * Object types any further, reporting them all as 'Object'.
 *
 * @func
 * @memberOf R
 * @category Type
 * @sig (* -> {*}) -> String
 * @param {*} val The value to test
 * @return {String}
 * @example
 *
 *      R.type({}); //=> "Object"
 *      R.type(1); //=> "Number"
 *      R.type(false); //=> "Boolean"
 *      R.type('s'); //=> "String"
 *      R.type(null); //=> "Null"
 *      R.type([]); //=> "Array"
 *      R.type(/[A-z]/); //=> "RegExp"
 */
module.exports = _curry1(function type(val) {
  return val === null      ? 'Null'      :
         val === undefined ? 'Undefined' :
         Object.prototype.toString.call(val).slice(8, -1);
});

},{"./internal/_curry1":503}],523:[function(require,module,exports){
'use strict';

function RavenConfigError(message) {
    this.name = 'RavenConfigError';
    this.message = message;
}
RavenConfigError.prototype = new Error();
RavenConfigError.prototype.constructor = RavenConfigError;

module.exports = RavenConfigError;

},{}],524:[function(require,module,exports){
'use strict';

var wrapMethod = function(console, level, callback) {
    var originalConsoleLevel = console[level];
    var originalConsole = console;

    if (!(level in console)) {
        return;
    }

    var sentryLevel = level === 'warn'
        ? 'warning'
        : level;

    console[level] = function () {
        var args = [].slice.call(arguments);

        var msg = '' + args.join(' ');
        var data = {level: sentryLevel, logger: 'console', extra: {'arguments': args}};
        callback && callback(msg, data);

        // this fails for some browsers. :(
        if (originalConsoleLevel) {
            // IE9 doesn't allow calling apply on console functions directly
            // See: https://stackoverflow.com/questions/5472938/does-ie9-support-console-log-and-is-it-a-real-function#answer-5473193
            Function.prototype.apply.call(
                originalConsoleLevel,
                originalConsole,
                args
            );
        }
    };
};

module.exports = {
    wrapMethod: wrapMethod
};

},{}],525:[function(require,module,exports){
(function (global){
/*global XDomainRequest:false, __DEV__:false*/
'use strict';

var TraceKit = require('../vendor/TraceKit/tracekit');
var stringify = require('../vendor/json-stringify-safe/stringify');
var RavenConfigError = require('./configError');
var utils = require('./utils');

var isError = utils.isError,
    isObject = utils.isObject;

var wrapConsoleMethod = require('./console').wrapMethod;

var dsnKeys = 'source protocol user pass host port path'.split(' '),
    dsnPattern = /^(?:(\w+):)?\/\/(?:(\w+)(:\w+)?@)?([\w\.-]+)(?::(\d+))?(\/.*)/;

function now() {
    return +new Date();
}

// This is to be defensive in environments where window does not exist (see https://github.com/getsentry/raven-js/pull/785)
var _window = typeof window !== 'undefined' ? window
            : typeof global !== 'undefined' ? global
            : typeof self !== 'undefined' ? self
            : {};
var _document = _window.document;
var _navigator = _window.navigator;

// First, check for JSON support
// If there is no JSON, we no-op the core features of Raven
// since JSON is required to encode the payload
function Raven() {
    this._hasJSON = !!(typeof JSON === 'object' && JSON.stringify);
    // Raven can run in contexts where there's no document (react-native)
    this._hasDocument = !isUndefined(_document);
    this._hasNavigator = !isUndefined(_navigator);
    this._lastCapturedException = null;
    this._lastData = null;
    this._lastEventId = null;
    this._globalServer = null;
    this._globalKey = null;
    this._globalProject = null;
    this._globalContext = {};
    this._globalOptions = {
        logger: 'javascript',
        ignoreErrors: [],
        ignoreUrls: [],
        whitelistUrls: [],
        includePaths: [],
        crossOrigin: 'anonymous',
        collectWindowErrors: true,
        maxMessageLength: 0,

        // By default, truncates URL values to 250 chars
        maxUrlLength: 250,
        stackTraceLimit: 50,
        autoBreadcrumbs: true,
        instrument: true,
        sampleRate: 1
    };
    this._ignoreOnError = 0;
    this._isRavenInstalled = false;
    this._originalErrorStackTraceLimit = Error.stackTraceLimit;
    // capture references to window.console *and* all its methods first
    // before the console plugin has a chance to monkey patch
    this._originalConsole = _window.console || {};
    this._originalConsoleMethods = {};
    this._plugins = [];
    this._startTime = now();
    this._wrappedBuiltIns = [];
    this._breadcrumbs = [];
    this._lastCapturedEvent = null;
    this._keypressTimeout;
    this._location = _window.location;
    this._lastHref = this._location && this._location.href;
    this._resetBackoff();

    for (var method in this._originalConsole) {  // eslint-disable-line guard-for-in
      this._originalConsoleMethods[method] = this._originalConsole[method];
    }
}

/*
 * The core Raven singleton
 *
 * @this {Raven}
 */

Raven.prototype = {
    // Hardcode version string so that raven source can be loaded directly via
    // webpack (using a build step causes webpack #1617). Grunt verifies that
    // this value matches package.json during build.
    //   See: https://github.com/getsentry/raven-js/issues/465
    VERSION: '3.15.0',

    debug: false,

    TraceKit: TraceKit, // alias to TraceKit

    /*
     * Configure Raven with a DSN and extra options
     *
     * @param {string} dsn The public Sentry DSN
     * @param {object} options Optional set of of global options [optional]
     * @return {Raven}
     */
    config: function(dsn, options) {
        var self = this;

        if (self._globalServer) {
                this._logDebug('error', 'Error: Raven has already been configured');
            return self;
        }
        if (!dsn) return self;

        var globalOptions = self._globalOptions;

        // merge in options
        if (options) {
            each(options, function(key, value){
                // tags and extra are special and need to be put into context
                if (key === 'tags' || key === 'extra' || key === 'user') {
                    self._globalContext[key] = value;
                } else {
                    globalOptions[key] = value;
                }
            });
        }

        self.setDSN(dsn);

        // "Script error." is hard coded into browsers for errors that it can't read.
        // this is the result of a script being pulled in from an external domain and CORS.
        globalOptions.ignoreErrors.push(/^Script error\.?$/);
        globalOptions.ignoreErrors.push(/^Javascript error: Script error\.? on line 0$/);

        // join regexp rules into one big rule
        globalOptions.ignoreErrors = joinRegExp(globalOptions.ignoreErrors);
        globalOptions.ignoreUrls = globalOptions.ignoreUrls.length ? joinRegExp(globalOptions.ignoreUrls) : false;
        globalOptions.whitelistUrls = globalOptions.whitelistUrls.length ? joinRegExp(globalOptions.whitelistUrls) : false;
        globalOptions.includePaths = joinRegExp(globalOptions.includePaths);
        globalOptions.maxBreadcrumbs = Math.max(0, Math.min(globalOptions.maxBreadcrumbs || 100, 100)); // default and hard limit is 100

        var autoBreadcrumbDefaults = {
            xhr: true,
            console: true,
            dom: true,
            location: true
        };

        var autoBreadcrumbs = globalOptions.autoBreadcrumbs;
        if ({}.toString.call(autoBreadcrumbs) === '[object Object]') {
            autoBreadcrumbs = objectMerge(autoBreadcrumbDefaults, autoBreadcrumbs);
        } else if (autoBreadcrumbs !== false) {
            autoBreadcrumbs = autoBreadcrumbDefaults;
        }
        globalOptions.autoBreadcrumbs = autoBreadcrumbs;

        var instrumentDefaults = {
            tryCatch: true
        };

        var instrument = globalOptions.instrument;
        if ({}.toString.call(instrument) === '[object Object]') {
            instrument = objectMerge(instrumentDefaults, instrument);
        } else if (instrument !== false) {
            instrument = instrumentDefaults;
        }
        globalOptions.instrument = instrument;

        TraceKit.collectWindowErrors = !!globalOptions.collectWindowErrors;

        // return for chaining
        return self;
    },

    /*
     * Installs a global window.onerror error handler
     * to capture and report uncaught exceptions.
     * At this point, install() is required to be called due
     * to the way TraceKit is set up.
     *
     * @return {Raven}
     */
    install: function() {
        var self = this;
        if (self.isSetup() && !self._isRavenInstalled) {
            TraceKit.report.subscribe(function () {
                self._handleOnErrorStackInfo.apply(self, arguments);
            });
            if (self._globalOptions.instrument && self._globalOptions.instrument.tryCatch) {
              self._instrumentTryCatch();
            }

            if (self._globalOptions.autoBreadcrumbs)
                self._instrumentBreadcrumbs();

            // Install all of the plugins
            self._drainPlugins();

            self._isRavenInstalled = true;
        }

        Error.stackTraceLimit = self._globalOptions.stackTraceLimit;
        return this;
    },

    /*
     * Set the DSN (can be called multiple time unlike config)
     *
     * @param {string} dsn The public Sentry DSN
     */
    setDSN: function(dsn) {
        var self = this,
            uri = self._parseDSN(dsn),
          lastSlash = uri.path.lastIndexOf('/'),
          path = uri.path.substr(1, lastSlash);

        self._dsn = dsn;
        self._globalKey = uri.user;
        self._globalSecret = uri.pass && uri.pass.substr(1);
        self._globalProject = uri.path.substr(lastSlash + 1);

        self._globalServer = self._getGlobalServer(uri);

        self._globalEndpoint = self._globalServer +
            '/' + path + 'api/' + self._globalProject + '/store/';

        // Reset backoff state since we may be pointing at a
        // new project/server
        this._resetBackoff();
    },

    /*
     * Wrap code within a context so Raven can capture errors
     * reliably across domains that is executed immediately.
     *
     * @param {object} options A specific set of options for this context [optional]
     * @param {function} func The callback to be immediately executed within the context
     * @param {array} args An array of arguments to be called with the callback [optional]
     */
    context: function(options, func, args) {
        if (isFunction(options)) {
            args = func || [];
            func = options;
            options = undefined;
        }

        return this.wrap(options, func).apply(this, args);
    },

    /*
     * Wrap code within a context and returns back a new function to be executed
     *
     * @param {object} options A specific set of options for this context [optional]
     * @param {function} func The function to be wrapped in a new context
     * @param {function} func A function to call before the try/catch wrapper [optional, private]
     * @return {function} The newly wrapped functions with a context
     */
    wrap: function(options, func, _before) {
        var self = this;
        // 1 argument has been passed, and it's not a function
        // so just return it
        if (isUndefined(func) && !isFunction(options)) {
            return options;
        }

        // options is optional
        if (isFunction(options)) {
            func = options;
            options = undefined;
        }

        // At this point, we've passed along 2 arguments, and the second one
        // is not a function either, so we'll just return the second argument.
        if (!isFunction(func)) {
            return func;
        }

        // We don't wanna wrap it twice!
        try {
            if (func.__raven__) {
                return func;
            }

            // If this has already been wrapped in the past, return that
            if (func.__raven_wrapper__ ){
                return func.__raven_wrapper__ ;
            }
        } catch (e) {
            // Just accessing custom props in some Selenium environments
            // can cause a "Permission denied" exception (see raven-js#495).
            // Bail on wrapping and return the function as-is (defers to window.onerror).
            return func;
        }

        function wrapped() {
            var args = [], i = arguments.length,
                deep = !options || options && options.deep !== false;

            if (_before && isFunction(_before)) {
                _before.apply(this, arguments);
            }

            // Recursively wrap all of a function's arguments that are
            // functions themselves.
            while(i--) args[i] = deep ? self.wrap(options, arguments[i]) : arguments[i];

            try {
                // Attempt to invoke user-land function
                // NOTE: If you are a Sentry user, and you are seeing this stack frame, it
                //       means Raven caught an error invoking your application code. This is
                //       expected behavior and NOT indicative of a bug with Raven.js.
                return func.apply(this, args);
            } catch(e) {
                self._ignoreNextOnError();
                self.captureException(e, options);
                throw e;
            }
        }

        // copy over properties of the old function
        for (var property in func) {
            if (hasKey(func, property)) {
                wrapped[property] = func[property];
            }
        }
        wrapped.prototype = func.prototype;

        func.__raven_wrapper__ = wrapped;
        // Signal that this function has been wrapped already
        // for both debugging and to prevent it to being wrapped twice
        wrapped.__raven__ = true;
        wrapped.__inner__ = func;

        return wrapped;
    },

    /*
     * Uninstalls the global error handler.
     *
     * @return {Raven}
     */
    uninstall: function() {
        TraceKit.report.uninstall();

        this._restoreBuiltIns();

        Error.stackTraceLimit = this._originalErrorStackTraceLimit;
        this._isRavenInstalled = false;

        return this;
    },

    /*
     * Manually capture an exception and send it over to Sentry
     *
     * @param {error} ex An exception to be logged
     * @param {object} options A specific set of options for this error [optional]
     * @return {Raven}
     */
    captureException: function(ex, options) {
        // If not an Error is passed through, recall as a message instead
        if (!isError(ex)) {
            return this.captureMessage(ex, objectMerge({
                trimHeadFrames: 1,
                stacktrace: true // if we fall back to captureMessage, default to attempting a new trace
            }, options));
        }

        // Store the raw exception object for potential debugging and introspection
        this._lastCapturedException = ex;

        // TraceKit.report will re-raise any exception passed to it,
        // which means you have to wrap it in try/catch. Instead, we
        // can wrap it here and only re-raise if TraceKit.report
        // raises an exception different from the one we asked to
        // report on.
        try {
            var stack = TraceKit.computeStackTrace(ex);
            this._handleStackInfo(stack, options);
        } catch(ex1) {
            if(ex !== ex1) {
                throw ex1;
            }
        }

        return this;
    },

    /*
     * Manually send a message to Sentry
     *
     * @param {string} msg A plain message to be captured in Sentry
     * @param {object} options A specific set of options for this message [optional]
     * @return {Raven}
     */
    captureMessage: function(msg, options) {
        // config() automagically converts ignoreErrors from a list to a RegExp so we need to test for an
        // early call; we'll error on the side of logging anything called before configuration since it's
        // probably something you should see:
        if (!!this._globalOptions.ignoreErrors.test && this._globalOptions.ignoreErrors.test(msg)) {
            return;
        }

        options = options || {};

        var data = objectMerge({
            message: msg + ''  // Make sure it's actually a string
        }, options);

        if (this._globalOptions.stacktrace || (options && options.stacktrace)) {
            var ex;
            // Generate a "synthetic" stack trace from this point.
            // NOTE: If you are a Sentry user, and you are seeing this stack frame, it is NOT indicative
            //       of a bug with Raven.js. Sentry generates synthetic traces either by configuration,
            //       or if it catches a thrown object without a "stack" property.
            try {
                throw new Error(msg);
            } catch (ex1) {
                ex = ex1;
            }

            // null exception name so `Error` isn't prefixed to msg
            ex.name = null;

            options = objectMerge({
                // fingerprint on msg, not stack trace (legacy behavior, could be
                // revisited)
                fingerprint: msg,
                // since we know this is a synthetic trace, the top N-most frames
                // MUST be from Raven.js, so mark them as in_app later by setting
                // trimHeadFrames
                trimHeadFrames: (options.trimHeadFrames || 0) + 1
            }, options);

            var stack = TraceKit.computeStackTrace(ex);
            var frames = this._prepareFrames(stack, options);
            data.stacktrace = {
                // Sentry expects frames oldest to newest
                frames: frames.reverse()
            }
        }

        // Fire away!
        this._send(data);

        return this;
    },

    captureBreadcrumb: function (obj) {
        var crumb = objectMerge({
            timestamp: now() / 1000
        }, obj);

        if (isFunction(this._globalOptions.breadcrumbCallback)) {
            var result = this._globalOptions.breadcrumbCallback(crumb);

            if (isObject(result) && !isEmptyObject(result)) {
                crumb = result;
            } else if (result === false) {
                return this;
            }
        }

        this._breadcrumbs.push(crumb);
        if (this._breadcrumbs.length > this._globalOptions.maxBreadcrumbs) {
            this._breadcrumbs.shift();
        }
        return this;
    },

    addPlugin: function(plugin /*arg1, arg2, ... argN*/) {
        var pluginArgs = [].slice.call(arguments, 1);

        this._plugins.push([plugin, pluginArgs]);
        if (this._isRavenInstalled) {
            this._drainPlugins();
        }

        return this;
    },

    /*
     * Set/clear a user to be sent along with the payload.
     *
     * @param {object} user An object representing user data [optional]
     * @return {Raven}
     */
    setUserContext: function(user) {
        // Intentionally do not merge here since that's an unexpected behavior.
        this._globalContext.user = user;

        return this;
    },

    /*
     * Merge extra attributes to be sent along with the payload.
     *
     * @param {object} extra An object representing extra data [optional]
     * @return {Raven}
     */
    setExtraContext: function(extra) {
        this._mergeContext('extra', extra);

        return this;
    },

    /*
     * Merge tags to be sent along with the payload.
     *
     * @param {object} tags An object representing tags [optional]
     * @return {Raven}
     */
    setTagsContext: function(tags) {
        this._mergeContext('tags', tags);

        return this;
    },

    /*
     * Clear all of the context.
     *
     * @return {Raven}
     */
    clearContext: function() {
        this._globalContext = {};

        return this;
    },

    /*
     * Get a copy of the current context. This cannot be mutated.
     *
     * @return {object} copy of context
     */
    getContext: function() {
        // lol javascript
        return JSON.parse(stringify(this._globalContext));
    },


    /*
     * Set environment of application
     *
     * @param {string} environment Typically something like 'production'.
     * @return {Raven}
     */
    setEnvironment: function(environment) {
        this._globalOptions.environment = environment;

        return this;
    },

    /*
     * Set release version of application
     *
     * @param {string} release Typically something like a git SHA to identify version
     * @return {Raven}
     */
    setRelease: function(release) {
        this._globalOptions.release = release;

        return this;
    },

    /*
     * Set the dataCallback option
     *
     * @param {function} callback The callback to run which allows the
     *                            data blob to be mutated before sending
     * @return {Raven}
     */
    setDataCallback: function(callback) {
        var original = this._globalOptions.dataCallback;
        this._globalOptions.dataCallback = isFunction(callback)
          ? function (data) { return callback(data, original); }
          : callback;

        return this;
    },

    /*
     * Set the breadcrumbCallback option
     *
     * @param {function} callback The callback to run which allows filtering
     *                            or mutating breadcrumbs
     * @return {Raven}
     */
    setBreadcrumbCallback: function(callback) {
        var original = this._globalOptions.breadcrumbCallback;
        this._globalOptions.breadcrumbCallback = isFunction(callback)
          ? function (data) { return callback(data, original); }
          : callback;

        return this;
    },

    /*
     * Set the shouldSendCallback option
     *
     * @param {function} callback The callback to run which allows
     *                            introspecting the blob before sending
     * @return {Raven}
     */
    setShouldSendCallback: function(callback) {
        var original = this._globalOptions.shouldSendCallback;
        this._globalOptions.shouldSendCallback = isFunction(callback)
            ? function (data) { return callback(data, original); }
            : callback;

        return this;
    },

    /**
     * Override the default HTTP transport mechanism that transmits data
     * to the Sentry server.
     *
     * @param {function} transport Function invoked instead of the default
     *                             `makeRequest` handler.
     *
     * @return {Raven}
     */
    setTransport: function(transport) {
        this._globalOptions.transport = transport;

        return this;
    },

    /*
     * Get the latest raw exception that was captured by Raven.
     *
     * @return {error}
     */
    lastException: function() {
        return this._lastCapturedException;
    },

    /*
     * Get the last event id
     *
     * @return {string}
     */
    lastEventId: function() {
        return this._lastEventId;
    },

    /*
     * Determine if Raven is setup and ready to go.
     *
     * @return {boolean}
     */
    isSetup: function() {
        if (!this._hasJSON) return false;  // needs JSON support
        if (!this._globalServer) {
            if (!this.ravenNotConfiguredError) {
              this.ravenNotConfiguredError = true;
              this._logDebug('error', 'Error: Raven has not been configured.');
            }
            return false;
        }
        return true;
    },

    afterLoad: function () {
        // TODO: remove window dependence?

        // Attempt to initialize Raven on load
        var RavenConfig = _window.RavenConfig;
        if (RavenConfig) {
            this.config(RavenConfig.dsn, RavenConfig.config).install();
        }
    },

    showReportDialog: function (options) {
        if (!_document) // doesn't work without a document (React native)
            return;

        options = options || {};

        var lastEventId = options.eventId || this.lastEventId();
        if (!lastEventId) {
            throw new RavenConfigError('Missing eventId');
        }

        var dsn = options.dsn || this._dsn;
        if (!dsn) {
            throw new RavenConfigError('Missing DSN');
        }

        var encode = encodeURIComponent;
        var qs = '';
        qs += '?eventId=' + encode(lastEventId);
        qs += '&dsn=' + encode(dsn);

        var user = options.user || this._globalContext.user;
        if (user) {
            if (user.name)  qs += '&name=' + encode(user.name);
            if (user.email) qs += '&email=' + encode(user.email);
        }

        var globalServer = this._getGlobalServer(this._parseDSN(dsn));

        var script = _document.createElement('script');
        script.async = true;
        script.src = globalServer + '/api/embed/error-page/' + qs;
        (_document.head || _document.body).appendChild(script);
    },

    /**** Private functions ****/
    _ignoreNextOnError: function () {
        var self = this;
        this._ignoreOnError += 1;
        setTimeout(function () {
            // onerror should trigger before setTimeout
            self._ignoreOnError -= 1;
        });
    },

    _triggerEvent: function(eventType, options) {
        // NOTE: `event` is a native browser thing, so let's avoid conflicting wiht it
        var evt, key;

        if (!this._hasDocument)
            return;

        options = options || {};

        eventType = 'raven' + eventType.substr(0,1).toUpperCase() + eventType.substr(1);

        if (_document.createEvent) {
            evt = _document.createEvent('HTMLEvents');
            evt.initEvent(eventType, true, true);
        } else {
            evt = _document.createEventObject();
            evt.eventType = eventType;
        }

        for (key in options) if (hasKey(options, key)) {
            evt[key] = options[key];
        }

        if (_document.createEvent) {
            // IE9 if standards
            _document.dispatchEvent(evt);
        } else {
            // IE8 regardless of Quirks or Standards
            // IE9 if quirks
            try {
                _document.fireEvent('on' + evt.eventType.toLowerCase(), evt);
            } catch(e) {
                // Do nothing
            }
        }
    },

    /**
     * Wraps addEventListener to capture UI breadcrumbs
     * @param evtName the event name (e.g. "click")
     * @returns {Function}
     * @private
     */
    _breadcrumbEventHandler: function(evtName) {
        var self = this;
        return function (evt) {
            // reset keypress timeout; e.g. triggering a 'click' after
            // a 'keypress' will reset the keypress debounce so that a new
            // set of keypresses can be recorded
            self._keypressTimeout = null;

            // It's possible this handler might trigger multiple times for the same
            // event (e.g. event propagation through node ancestors). Ignore if we've
            // already captured the event.
            if (self._lastCapturedEvent === evt)
                return;

            self._lastCapturedEvent = evt;

            // try/catch both:
            // - accessing evt.target (see getsentry/raven-js#838, #768)
            // - `htmlTreeAsString` because it's complex, and just accessing the DOM incorrectly
            //   can throw an exception in some circumstances.
            var target;
            try {
                target = htmlTreeAsString(evt.target);
            } catch (e) {
                target = '<unknown>';
            }

            self.captureBreadcrumb({
                category: 'ui.' + evtName, // e.g. ui.click, ui.input
                message: target
            });
        };
    },

    /**
     * Wraps addEventListener to capture keypress UI events
     * @returns {Function}
     * @private
     */
    _keypressEventHandler: function() {
        var self = this,
            debounceDuration = 1000; // milliseconds

        // TODO: if somehow user switches keypress target before
        //       debounce timeout is triggered, we will only capture
        //       a single breadcrumb from the FIRST target (acceptable?)
        return function (evt) {
            var target;
            try {
                target = evt.target;
            } catch (e) {
                // just accessing event properties can throw an exception in some rare circumstances
                // see: https://github.com/getsentry/raven-js/issues/838
                return;
            }
            var tagName = target && target.tagName;

            // only consider keypress events on actual input elements
            // this will disregard keypresses targeting body (e.g. tabbing
            // through elements, hotkeys, etc)
            if (!tagName || tagName !== 'INPUT' && tagName !== 'TEXTAREA' && !target.isContentEditable)
                return;

            // record first keypress in a series, but ignore subsequent
            // keypresses until debounce clears
            var timeout = self._keypressTimeout;
            if (!timeout) {
                self._breadcrumbEventHandler('input')(evt);
            }
            clearTimeout(timeout);
            self._keypressTimeout = setTimeout(function () {
                self._keypressTimeout = null;
            }, debounceDuration);
        };
    },

    /**
     * Captures a breadcrumb of type "navigation", normalizing input URLs
     * @param to the originating URL
     * @param from the target URL
     * @private
     */
    _captureUrlChange: function(from, to) {
        var parsedLoc = parseUrl(this._location.href);
        var parsedTo = parseUrl(to);
        var parsedFrom = parseUrl(from);

        // because onpopstate only tells you the "new" (to) value of location.href, and
        // not the previous (from) value, we need to track the value of the current URL
        // state ourselves
        this._lastHref = to;

        // Use only the path component of the URL if the URL matches the current
        // document (almost all the time when using pushState)
        if (parsedLoc.protocol === parsedTo.protocol && parsedLoc.host === parsedTo.host)
            to = parsedTo.relative;
        if (parsedLoc.protocol === parsedFrom.protocol && parsedLoc.host === parsedFrom.host)
            from = parsedFrom.relative;

        this.captureBreadcrumb({
            category: 'navigation',
            data: {
                to: to,
                from: from
            }
        });
    },

    /**
     * Wrap timer functions and event targets to catch errors and provide
     * better metadata.
     */
    _instrumentTryCatch: function() {
        var self = this;

        var wrappedBuiltIns = self._wrappedBuiltIns;

        function wrapTimeFn(orig) {
            return function (fn, t) { // preserve arity
                // Make a copy of the arguments to prevent deoptimization
                // https://github.com/petkaantonov/bluebird/wiki/Optimization-killers#32-leaking-arguments
                var args = new Array(arguments.length);
                for(var i = 0; i < args.length; ++i) {
                    args[i] = arguments[i];
                }
                var originalCallback = args[0];
                if (isFunction(originalCallback)) {
                    args[0] = self.wrap(originalCallback);
                }

                // IE < 9 doesn't support .call/.apply on setInterval/setTimeout, but it
                // also supports only two arguments and doesn't care what this is, so we
                // can just call the original function directly.
                if (orig.apply) {
                    return orig.apply(this, args);
                } else {
                    return orig(args[0], args[1]);
                }
            };
        }

        var autoBreadcrumbs = this._globalOptions.autoBreadcrumbs;

        function wrapEventTarget(global) {
            var proto = _window[global] && _window[global].prototype;
            if (proto && proto.hasOwnProperty && proto.hasOwnProperty('addEventListener')) {
                fill(proto, 'addEventListener', function(orig) {
                    return function (evtName, fn, capture, secure) { // preserve arity
                        try {
                            if (fn && fn.handleEvent) {
                                fn.handleEvent = self.wrap(fn.handleEvent);
                            }
                        } catch (err) {
                            // can sometimes get 'Permission denied to access property "handle Event'
                        }

                        // More breadcrumb DOM capture ... done here and not in `_instrumentBreadcrumbs`
                        // so that we don't have more than one wrapper function
                        var before,
                            clickHandler,
                            keypressHandler;

                        if (autoBreadcrumbs && autoBreadcrumbs.dom && (global === 'EventTarget' || global === 'Node')) {
                            // NOTE: generating multiple handlers per addEventListener invocation, should
                            //       revisit and verify we can just use one (almost certainly)
                            clickHandler = self._breadcrumbEventHandler('click');
                            keypressHandler = self._keypressEventHandler();
                            before = function (evt) {
                                // need to intercept every DOM event in `before` argument, in case that
                                // same wrapped method is re-used for different events (e.g. mousemove THEN click)
                                // see #724
                                if (!evt) return;

                                var eventType;
                                try {
                                    eventType = evt.type
                                } catch (e) {
                                    // just accessing event properties can throw an exception in some rare circumstances
                                    // see: https://github.com/getsentry/raven-js/issues/838
                                    return;
                                }
                                if (eventType === 'click')
                                    return clickHandler(evt);
                                else if (eventType === 'keypress')
                                    return keypressHandler(evt);
                            };
                        }
                        return orig.call(this, evtName, self.wrap(fn, undefined, before), capture, secure);
                    };
                }, wrappedBuiltIns);
                fill(proto, 'removeEventListener', function (orig) {
                    return function (evt, fn, capture, secure) {
                        try {
                            fn = fn && (fn.__raven_wrapper__ ? fn.__raven_wrapper__  : fn);
                        } catch (e) {
                            // ignore, accessing __raven_wrapper__ will throw in some Selenium environments
                        }
                        return orig.call(this, evt, fn, capture, secure);
                    };
                }, wrappedBuiltIns);
            }
        }

        fill(_window, 'setTimeout', wrapTimeFn, wrappedBuiltIns);
        fill(_window, 'setInterval', wrapTimeFn, wrappedBuiltIns);
        if (_window.requestAnimationFrame) {
            fill(_window, 'requestAnimationFrame', function (orig) {
                return function (cb) {
                    return orig(self.wrap(cb));
                };
            }, wrappedBuiltIns);
        }

        // event targets borrowed from bugsnag-js:
        // https://github.com/bugsnag/bugsnag-js/blob/master/src/bugsnag.js#L666
        var eventTargets = ['EventTarget', 'Window', 'Node', 'ApplicationCache', 'AudioTrackList', 'ChannelMergerNode', 'CryptoOperation', 'EventSource', 'FileReader', 'HTMLUnknownElement', 'IDBDatabase', 'IDBRequest', 'IDBTransaction', 'KeyOperation', 'MediaController', 'MessagePort', 'ModalWindow', 'Notification', 'SVGElementInstance', 'Screen', 'TextTrack', 'TextTrackCue', 'TextTrackList', 'WebSocket', 'WebSocketWorker', 'Worker', 'XMLHttpRequest', 'XMLHttpRequestEventTarget', 'XMLHttpRequestUpload'];
        for (var i = 0; i < eventTargets.length; i++) {
            wrapEventTarget(eventTargets[i]);
        }
    },


    /**
     * Instrument browser built-ins w/ breadcrumb capturing
     *  - XMLHttpRequests
     *  - DOM interactions (click/typing)
     *  - window.location changes
     *  - console
     *
     * Can be disabled or individually configured via the `autoBreadcrumbs` config option
     */
    _instrumentBreadcrumbs: function () {
        var self = this;
        var autoBreadcrumbs = this._globalOptions.autoBreadcrumbs;

        var wrappedBuiltIns = self._wrappedBuiltIns;

        function wrapProp(prop, xhr) {
            if (prop in xhr && isFunction(xhr[prop])) {
                fill(xhr, prop, function (orig) {
                    return self.wrap(orig);
                }); // intentionally don't track filled methods on XHR instances
            }
        }

        if (autoBreadcrumbs.xhr && 'XMLHttpRequest' in _window) {
            var xhrproto = XMLHttpRequest.prototype;
            fill(xhrproto, 'open', function(origOpen) {
                return function (method, url) { // preserve arity

                    // if Sentry key appears in URL, don't capture
                    if (isString(url) && url.indexOf(self._globalKey) === -1) {
                        this.__raven_xhr = {
                            method: method,
                            url: url,
                            status_code: null
                        };
                    }

                    return origOpen.apply(this, arguments);
                };
            }, wrappedBuiltIns);

            fill(xhrproto, 'send', function(origSend) {
                return function (data) { // preserve arity
                    var xhr = this;

                    function onreadystatechangeHandler() {
                        if (xhr.__raven_xhr && (xhr.readyState === 1 || xhr.readyState === 4)) {
                            try {
                                // touching statusCode in some platforms throws
                                // an exception
                                xhr.__raven_xhr.status_code = xhr.status;
                            } catch (e) { /* do nothing */ }
                            self.captureBreadcrumb({
                                type: 'http',
                                category: 'xhr',
                                data: xhr.__raven_xhr
                            });
                        }
                    }

                    var props = ['onload', 'onerror', 'onprogress'];
                    for (var j = 0; j < props.length; j++) {
                        wrapProp(props[j], xhr);
                    }

                    if ('onreadystatechange' in xhr && isFunction(xhr.onreadystatechange)) {
                        fill(xhr, 'onreadystatechange', function (orig) {
                            return self.wrap(orig, undefined, onreadystatechangeHandler);
                        } /* intentionally don't track this instrumentation */);
                    } else {
                        // if onreadystatechange wasn't actually set by the page on this xhr, we
                        // are free to set our own and capture the breadcrumb
                        xhr.onreadystatechange = onreadystatechangeHandler;
                    }

                    return origSend.apply(this, arguments);
                };
            }, wrappedBuiltIns);
        }

        if (autoBreadcrumbs.xhr && 'fetch' in _window) {
            fill(_window, 'fetch', function(origFetch) {
                return function (fn, t) { // preserve arity
                    // Make a copy of the arguments to prevent deoptimization
                    // https://github.com/petkaantonov/bluebird/wiki/Optimization-killers#32-leaking-arguments
                    var args = new Array(arguments.length);
                    for (var i = 0; i < args.length; ++i) {
                        args[i] = arguments[i];
                    }

                    var fetchInput = args[0];
                    var method = 'GET';
                    var url;

                    if (typeof fetchInput === 'string') {
                        url = fetchInput;
                    } else {
                        url = fetchInput.url;
                        if (fetchInput.method) {
                            method = fetchInput.method;
                        }
                    }

                    if (args[1] && args[1].method) {
                        method = args[1].method;
                    }

                    var fetchData = {
                        method: method,
                        url: url,
                        status_code: null
                    };

                    self.captureBreadcrumb({
                        type: 'http',
                        category: 'fetch',
                        data: fetchData
                    });

                    return origFetch.apply(this, args).then(function (response) {
                        fetchData.status_code = response.status;

                        return response;
                    });
                };
            }, wrappedBuiltIns);
        }

        // Capture breadcrumbs from any click that is unhandled / bubbled up all the way
        // to the document. Do this before we instrument addEventListener.
        if (autoBreadcrumbs.dom && this._hasDocument) {
            if (_document.addEventListener) {
                _document.addEventListener('click', self._breadcrumbEventHandler('click'), false);
                _document.addEventListener('keypress', self._keypressEventHandler(), false);
            }
            else {
                // IE8 Compatibility
                _document.attachEvent('onclick', self._breadcrumbEventHandler('click'));
                _document.attachEvent('onkeypress', self._keypressEventHandler());
            }
        }

        // record navigation (URL) changes
        // NOTE: in Chrome App environment, touching history.pushState, *even inside
        //       a try/catch block*, will cause Chrome to output an error to console.error
        // borrowed from: https://github.com/angular/angular.js/pull/13945/files
        var chrome = _window.chrome;
        var isChromePackagedApp = chrome && chrome.app && chrome.app.runtime;
        var hasPushState = !isChromePackagedApp && _window.history && history.pushState;
        if (autoBreadcrumbs.location && hasPushState) {
            // TODO: remove onpopstate handler on uninstall()
            var oldOnPopState = _window.onpopstate;
            _window.onpopstate = function () {
                var currentHref = self._location.href;
                self._captureUrlChange(self._lastHref, currentHref);

                if (oldOnPopState) {
                    return oldOnPopState.apply(this, arguments);
                }
            };

            fill(history, 'pushState', function (origPushState) {
                // note history.pushState.length is 0; intentionally not declaring
                // params to preserve 0 arity
                return function (/* state, title, url */) {
                    var url = arguments.length > 2 ? arguments[2] : undefined;

                    // url argument is optional
                    if (url) {
                        // coerce to string (this is what pushState does)
                        self._captureUrlChange(self._lastHref, url + '');
                    }

                    return origPushState.apply(this, arguments);
                };
            }, wrappedBuiltIns);
        }

        if (autoBreadcrumbs.console && 'console' in _window && console.log) {
            // console
            var consoleMethodCallback = function (msg, data) {
                self.captureBreadcrumb({
                    message: msg,
                    level: data.level,
                    category: 'console'
                });
            };

            each(['debug', 'info', 'warn', 'error', 'log'], function (_, level) {
                wrapConsoleMethod(console, level, consoleMethodCallback);
            });
        }

    },

    _restoreBuiltIns: function () {
        // restore any wrapped builtins
        var builtin;
        while (this._wrappedBuiltIns.length) {
            builtin = this._wrappedBuiltIns.shift();

            var obj = builtin[0],
              name = builtin[1],
              orig = builtin[2];

            obj[name] = orig;
        }
    },

    _drainPlugins: function() {
        var self = this;

        // FIX ME TODO
        each(this._plugins, function(_, plugin) {
            var installer = plugin[0];
            var args = plugin[1];
            installer.apply(self, [self].concat(args));
        });
    },

    _parseDSN: function(str) {
        var m = dsnPattern.exec(str),
            dsn = {},
            i = 7;

        try {
            while (i--) dsn[dsnKeys[i]] = m[i] || '';
        } catch(e) {
            throw new RavenConfigError('Invalid DSN: ' + str);
        }

        if (dsn.pass && !this._globalOptions.allowSecretKey) {
            throw new RavenConfigError('Do not specify your secret key in the DSN. See: http://bit.ly/raven-secret-key');
        }

        return dsn;
    },

    _getGlobalServer: function(uri) {
        // assemble the endpoint from the uri pieces
        var globalServer = '//' + uri.host +
            (uri.port ? ':' + uri.port : '');

        if (uri.protocol) {
            globalServer = uri.protocol + ':' + globalServer;
        }
        return globalServer;
    },

    _handleOnErrorStackInfo: function() {
        // if we are intentionally ignoring errors via onerror, bail out
        if (!this._ignoreOnError) {
            this._handleStackInfo.apply(this, arguments);
        }
    },

    _handleStackInfo: function(stackInfo, options) {
        var frames = this._prepareFrames(stackInfo, options);

        this._triggerEvent('handle', {
            stackInfo: stackInfo,
            options: options
        });

        this._processException(
            stackInfo.name,
            stackInfo.message,
            stackInfo.url,
            stackInfo.lineno,
            frames,
            options
        );
    },

    _prepareFrames: function(stackInfo, options) {
        var self = this;
        var frames = [];
        if (stackInfo.stack && stackInfo.stack.length) {
            each(stackInfo.stack, function(i, stack) {
                var frame = self._normalizeFrame(stack);
                if (frame) {
                    frames.push(frame);
                }
            });

            // e.g. frames captured via captureMessage throw
            if (options && options.trimHeadFrames) {
                for (var j = 0; j < options.trimHeadFrames && j < frames.length; j++) {
                    frames[j].in_app = false;
                }
            }
        }
        frames = frames.slice(0, this._globalOptions.stackTraceLimit);
        return frames;
    },


    _normalizeFrame: function(frame) {
        if (!frame.url) return;

        // normalize the frames data
        var normalized = {
            filename:   frame.url,
            lineno:     frame.line,
            colno:      frame.column,
            'function': frame.func || '?'
        };

        normalized.in_app = !( // determine if an exception came from outside of our app
            // first we check the global includePaths list.
            !!this._globalOptions.includePaths.test && !this._globalOptions.includePaths.test(normalized.filename) ||
            // Now we check for fun, if the function name is Raven or TraceKit
            /(Raven|TraceKit)\./.test(normalized['function']) ||
            // finally, we do a last ditch effort and check for raven.min.js
            /raven\.(min\.)?js$/.test(normalized.filename)
        );

        return normalized;
    },

    _processException: function(type, message, fileurl, lineno, frames, options) {
        var stacktrace;
        if (!!this._globalOptions.ignoreErrors.test && this._globalOptions.ignoreErrors.test(message)) return;

        message += '';

        if (frames && frames.length) {
            fileurl = frames[0].filename || fileurl;
            // Sentry expects frames oldest to newest
            // and JS sends them as newest to oldest
            frames.reverse();
            stacktrace = {frames: frames};
        } else if (fileurl) {
            stacktrace = {
                frames: [{
                    filename: fileurl,
                    lineno: lineno,
                    in_app: true
                }]
            };
        }

        if (!!this._globalOptions.ignoreUrls.test && this._globalOptions.ignoreUrls.test(fileurl)) return;
        if (!!this._globalOptions.whitelistUrls.test && !this._globalOptions.whitelistUrls.test(fileurl)) return;

        var data = objectMerge({
            // sentry.interfaces.Exception
            exception: {
                values: [{
                    type: type,
                    value: message,
                    stacktrace: stacktrace
                }]
            },
            culprit: fileurl
        }, options);

        // Fire away!
        this._send(data);
    },

    _trimPacket: function(data) {
        // For now, we only want to truncate the two different messages
        // but this could/should be expanded to just trim everything
        var max = this._globalOptions.maxMessageLength;
        if (data.message) {
            data.message = truncate(data.message, max);
        }
        if (data.exception) {
            var exception = data.exception.values[0];
            exception.value = truncate(exception.value, max);
        }

        var request = data.request;
        if (request) {
            if (request.url) {
                request.url = truncate(request.url, this._globalOptions.maxUrlLength);
            }
            if (request.Referer) {
                request.Referer = truncate(request.Referer, this._globalOptions.maxUrlLength);
            }
        }

        if (data.breadcrumbs && data.breadcrumbs.values)
            this._trimBreadcrumbs(data.breadcrumbs);

        return data;
    },

    /**
     * Truncate breadcrumb values (right now just URLs)
     */
    _trimBreadcrumbs: function (breadcrumbs) {
        // known breadcrumb properties with urls
        // TODO: also consider arbitrary prop values that start with (https?)?://
        var urlProps = ['to', 'from', 'url'],
            urlProp,
            crumb,
            data;

        for (var i = 0; i < breadcrumbs.values.length; ++i) {
            crumb = breadcrumbs.values[i];
            if (!crumb.hasOwnProperty('data') || !isObject(crumb.data))
                continue;

            data = crumb.data;
            for (var j = 0; j < urlProps.length; ++j) {
                urlProp = urlProps[j];
                if (data.hasOwnProperty(urlProp)) {
                    data[urlProp] = truncate(data[urlProp], this._globalOptions.maxUrlLength);
                }
            }
        }
    },

    _getHttpData: function() {
        if (!this._hasNavigator && !this._hasDocument) return;
        var httpData = {};

        if (this._hasNavigator && _navigator.userAgent) {
            httpData.headers = {
              'User-Agent': navigator.userAgent
            };
        }

        if (this._hasDocument) {
            if (_document.location && _document.location.href) {
                httpData.url = _document.location.href;
            }
            if (_document.referrer) {
                if (!httpData.headers) httpData.headers = {};
                httpData.headers.Referer = _document.referrer;
            }
        }

        return httpData;
    },

    _resetBackoff: function() {
        this._backoffDuration = 0;
        this._backoffStart = null;
    },

    _shouldBackoff: function() {
        return this._backoffDuration && now() - this._backoffStart < this._backoffDuration;
    },

    /**
     * Returns true if the in-process data payload matches the signature
     * of the previously-sent data
     *
     * NOTE: This has to be done at this level because TraceKit can generate
     *       data from window.onerror WITHOUT an exception object (IE8, IE9,
     *       other old browsers). This can take the form of an "exception"
     *       data object with a single frame (derived from the onerror args).
     */
    _isRepeatData: function (current) {
        var last = this._lastData;

        if (!last ||
            current.message !== last.message || // defined for captureMessage
            current.culprit !== last.culprit)   // defined for captureException/onerror
            return false;

        // Stacktrace interface (i.e. from captureMessage)
        if (current.stacktrace || last.stacktrace) {
            return isSameStacktrace(current.stacktrace, last.stacktrace);
        }
        // Exception interface (i.e. from captureException/onerror)
        else if (current.exception || last.exception) {
            return isSameException(current.exception, last.exception);
        }

        return true;
    },

    _setBackoffState: function(request) {
        // If we are already in a backoff state, don't change anything
        if (this._shouldBackoff()) {
            return;
        }

        var status = request.status;

        // 400 - project_id doesn't exist or some other fatal
        // 401 - invalid/revoked dsn
        // 429 - too many requests
        if (!(status === 400 || status === 401 || status === 429))
            return;

        var retry;
        try {
            // If Retry-After is not in Access-Control-Expose-Headers, most
            // browsers will throw an exception trying to access it
            retry = request.getResponseHeader('Retry-After');
            retry = parseInt(retry, 10) * 1000; // Retry-After is returned in seconds
        } catch (e) {
            /* eslint no-empty:0 */
        }


        this._backoffDuration = retry
            // If Sentry server returned a Retry-After value, use it
            ? retry
            // Otherwise, double the last backoff duration (starts at 1 sec)
            : this._backoffDuration * 2 || 1000;

        this._backoffStart = now();
    },

    _send: function(data) {
        var globalOptions = this._globalOptions;

        var baseData = {
            project: this._globalProject,
            logger: globalOptions.logger,
            platform: 'javascript'
        }, httpData = this._getHttpData();

        if (httpData) {
            baseData.request = httpData;
        }

        // HACK: delete `trimHeadFrames` to prevent from appearing in outbound payload
        if (data.trimHeadFrames) delete data.trimHeadFrames;

        data = objectMerge(baseData, data);

        // Merge in the tags and extra separately since objectMerge doesn't handle a deep merge
        data.tags = objectMerge(objectMerge({}, this._globalContext.tags), data.tags);
        data.extra = objectMerge(objectMerge({}, this._globalContext.extra), data.extra);

        // Send along our own collected metadata with extra
        data.extra['session:duration'] = now() - this._startTime;

        if (this._breadcrumbs && this._breadcrumbs.length > 0) {
            // intentionally make shallow copy so that additions
            // to breadcrumbs aren't accidentally sent in this request
            data.breadcrumbs = {
                values: [].slice.call(this._breadcrumbs, 0)
            };
        }

        // If there are no tags/extra, strip the key from the payload alltogther.
        if (isEmptyObject(data.tags)) delete data.tags;

        if (this._globalContext.user) {
            // sentry.interfaces.User
            data.user = this._globalContext.user;
        }

        // Include the environment if it's defined in globalOptions
        if (globalOptions.environment) data.environment = globalOptions.environment;

        // Include the release if it's defined in globalOptions
        if (globalOptions.release) data.release = globalOptions.release;

        // Include server_name if it's defined in globalOptions
        if (globalOptions.serverName) data.server_name = globalOptions.serverName;

        if (isFunction(globalOptions.dataCallback)) {
            data = globalOptions.dataCallback(data) || data;
        }

        // Why??????????
        if (!data || isEmptyObject(data)) {
            return;
        }

        // Check if the request should be filtered or not
        if (isFunction(globalOptions.shouldSendCallback) && !globalOptions.shouldSendCallback(data)) {
            return;
        }

        // Backoff state: Sentry server previously responded w/ an error (e.g. 429 - too many requests),
        // so drop requests until "cool-off" period has elapsed.
        if (this._shouldBackoff()) {
            this._logDebug('warn', 'Raven dropped error due to backoff: ', data);
            return;
        }

        if (typeof globalOptions.sampleRate === 'number') {
            if (Math.random() < globalOptions.sampleRate) {
                this._sendProcessedPayload(data);
            }
        } else {
            this._sendProcessedPayload(data);
        }
    },

    _getUuid: function () {
      return uuid4();
    },

    _sendProcessedPayload: function(data, callback) {
        var self = this;
        var globalOptions = this._globalOptions;

        if (!this.isSetup()) return;

        // Send along an event_id if not explicitly passed.
        // This event_id can be used to reference the error within Sentry itself.
        // Set lastEventId after we know the error should actually be sent
        this._lastEventId = data.event_id || (data.event_id = this._getUuid());

        // Try and clean up the packet before sending by truncating long values
        data = this._trimPacket(data);

        // ideally duplicate error testing should occur *before* dataCallback/shouldSendCallback,
        // but this would require copying an un-truncated copy of the data packet, which can be
        // arbitrarily deep (extra_data) -- could be worthwhile? will revisit
        if (!this._globalOptions.allowDuplicates && this._isRepeatData(data)) {
            this._logDebug('warn', 'Raven dropped repeat event: ', data);
            return;
        }

        // Store outbound payload after trim
        this._lastData = data;

        this._logDebug('debug', 'Raven about to send:', data);

        var auth = {
            sentry_version: '7',
            sentry_client: 'raven-js/' + this.VERSION,
            sentry_key: this._globalKey
        };
        if (this._globalSecret) {
            auth.sentry_secret = this._globalSecret;
        }

        var exception = data.exception && data.exception.values[0];
        this.captureBreadcrumb({
            category: 'sentry',
            message: exception
                ? (exception.type ? exception.type + ': ' : '') + exception.value
                : data.message,
            event_id: data.event_id,
            level: data.level || 'error' // presume error unless specified
        });

        var url = this._globalEndpoint;
        (globalOptions.transport || this._makeRequest).call(this, {
            url: url,
            auth: auth,
            data: data,
            options: globalOptions,
            onSuccess: function success() {
                self._resetBackoff();

                self._triggerEvent('success', {
                    data: data,
                    src: url
                });
                callback && callback();
            },
            onError: function failure(error) {
                self._logDebug('error', 'Raven transport failed to send: ', error);

                if (error.request) {
                    self._setBackoffState(error.request);
                }

                self._triggerEvent('failure', {
                    data: data,
                    src: url
                });
                error = error || new Error('Raven send failed (no additional details provided)');
                callback && callback(error);
            }
        });
    },

    _makeRequest: function(opts) {
        var request = new XMLHttpRequest();

        // if browser doesn't support CORS (e.g. IE7), we are out of luck
        var hasCORS =
            'withCredentials' in request ||
            typeof XDomainRequest !== 'undefined';

        if (!hasCORS) return;

        var url = opts.url;

        if ('withCredentials' in request) {
            request.onreadystatechange = function () {
                if (request.readyState !== 4) {
                    return;
                } else if (request.status === 200) {
                    opts.onSuccess && opts.onSuccess();
                } else if (opts.onError) {
                    var err = new Error('Sentry error code: ' + request.status);
                    err.request = request;
                    opts.onError(err);
                }
            };
        } else {
            request = new XDomainRequest();
            // xdomainrequest cannot go http -> https (or vice versa),
            // so always use protocol relative
            url = url.replace(/^https?:/, '');

            // onreadystatechange not supported by XDomainRequest
            if (opts.onSuccess) {
                request.onload = opts.onSuccess;
            }
            if (opts.onError) {
                request.onerror = function () {
                    var err = new Error('Sentry error code: XDomainRequest');
                    err.request = request;
                    opts.onError(err);
                }
            }
        }

        // NOTE: auth is intentionally sent as part of query string (NOT as custom
        //       HTTP header) so as to avoid preflight CORS requests
        request.open('POST', url + '?' + urlencode(opts.auth));
        request.send(stringify(opts.data));
    },

    _logDebug: function(level) {
        if (this._originalConsoleMethods[level] && this.debug) {
            // In IE<10 console methods do not have their own 'apply' method
            Function.prototype.apply.call(
                this._originalConsoleMethods[level],
                this._originalConsole,
                [].slice.call(arguments, 1)
            );
        }
    },

    _mergeContext: function(key, context) {
        if (isUndefined(context)) {
            delete this._globalContext[key];
        } else {
            this._globalContext[key] = objectMerge(this._globalContext[key] || {}, context);
        }
    }
};

/*------------------------------------------------
 * utils
 *
 * conditionally exported for test via Raven.utils
 =================================================
 */
var objectPrototype = Object.prototype;

function isUndefined(what) {
    return what === void 0;
}

function isFunction(what) {
    return typeof what === 'function';
}

function isString(what) {
    return objectPrototype.toString.call(what) === '[object String]';
}


function isEmptyObject(what) {
    for (var _ in what) return false;  // eslint-disable-line guard-for-in, no-unused-vars
    return true;
}

function each(obj, callback) {
    var i, j;

    if (isUndefined(obj.length)) {
        for (i in obj) {
            if (hasKey(obj, i)) {
                callback.call(null, i, obj[i]);
            }
        }
    } else {
        j = obj.length;
        if (j) {
            for (i = 0; i < j; i++) {
                callback.call(null, i, obj[i]);
            }
        }
    }
}

function objectMerge(obj1, obj2) {
    if (!obj2) {
        return obj1;
    }
    each(obj2, function(key, value){
        obj1[key] = value;
    });
    return obj1;
}

function truncate(str, max) {
    return !max || str.length <= max ? str : str.substr(0, max) + '\u2026';
}

/**
 * hasKey, a better form of hasOwnProperty
 * Example: hasKey(MainHostObject, property) === true/false
 *
 * @param {Object} host object to check property
 * @param {string} key to check
 */
function hasKey(object, key) {
    return objectPrototype.hasOwnProperty.call(object, key);
}

function joinRegExp(patterns) {
    // Combine an array of regular expressions and strings into one large regexp
    // Be mad.
    var sources = [],
        i = 0, len = patterns.length,
        pattern;

    for (; i < len; i++) {
        pattern = patterns[i];
        if (isString(pattern)) {
            // If it's a string, we need to escape it
            // Taken from: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions
            sources.push(pattern.replace(/([.*+?^=!:${}()|\[\]\/\\])/g, '\\$1'));
        } else if (pattern && pattern.source) {
            // If it's a regexp already, we want to extract the source
            sources.push(pattern.source);
        }
        // Intentionally skip other cases
    }
    return new RegExp(sources.join('|'), 'i');
}

function urlencode(o) {
    var pairs = [];
    each(o, function(key, value) {
        pairs.push(encodeURIComponent(key) + '=' + encodeURIComponent(value));
    });
    return pairs.join('&');
}

// borrowed from https://tools.ietf.org/html/rfc3986#appendix-B
// intentionally using regex and not <a/> href parsing trick because React Native and other
// environments where DOM might not be available
function parseUrl(url) {
    var match = url.match(/^(([^:\/?#]+):)?(\/\/([^\/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?$/);
    if (!match) return {};

    // coerce to undefined values to empty string so we don't get 'undefined'
    var query = match[6] || '';
    var fragment = match[8] || '';
    return {
        protocol: match[2],
        host: match[4],
        path: match[5],
        relative: match[5] + query + fragment // everything minus origin
    };
}
function uuid4() {
    var crypto = _window.crypto || _window.msCrypto;

    if (!isUndefined(crypto) && crypto.getRandomValues) {
        // Use window.crypto API if available
        var arr = new Uint16Array(8);
        crypto.getRandomValues(arr);

        // set 4 in byte 7
        arr[3] = arr[3] & 0xFFF | 0x4000;
        // set 2 most significant bits of byte 9 to '10'
        arr[4] = arr[4] & 0x3FFF | 0x8000;

        var pad = function(num) {
            var v = num.toString(16);
            while (v.length < 4) {
                v = '0' + v;
            }
            return v;
        };

        return pad(arr[0]) + pad(arr[1]) + pad(arr[2]) + pad(arr[3]) + pad(arr[4]) +
        pad(arr[5]) + pad(arr[6]) + pad(arr[7]);
    } else {
        // http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/2117523#2117523
        return 'xxxxxxxxxxxx4xxxyxxxxxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
            var r = Math.random()*16|0,
                v = c === 'x' ? r : r&0x3|0x8;
            return v.toString(16);
        });
    }
}

/**
 * Given a child DOM element, returns a query-selector statement describing that
 * and its ancestors
 * e.g. [HTMLElement] => body > div > input#foo.btn[name=baz]
 * @param elem
 * @returns {string}
 */
function htmlTreeAsString(elem) {
    /* eslint no-extra-parens:0*/
    var MAX_TRAVERSE_HEIGHT = 5,
        MAX_OUTPUT_LEN = 80,
        out = [],
        height = 0,
        len = 0,
        separator = ' > ',
        sepLength = separator.length,
        nextStr;

    while (elem && height++ < MAX_TRAVERSE_HEIGHT) {

        nextStr = htmlElementAsString(elem);
        // bail out if
        // - nextStr is the 'html' element
        // - the length of the string that would be created exceeds MAX_OUTPUT_LEN
        //   (ignore this limit if we are on the first iteration)
        if (nextStr === 'html' || height > 1 && len + (out.length * sepLength) + nextStr.length >= MAX_OUTPUT_LEN) {
            break;
        }

        out.push(nextStr);

        len += nextStr.length;
        elem = elem.parentNode;
    }

    return out.reverse().join(separator);
}

/**
 * Returns a simple, query-selector representation of a DOM element
 * e.g. [HTMLElement] => input#foo.btn[name=baz]
 * @param HTMLElement
 * @returns {string}
 */
function htmlElementAsString(elem) {
    var out = [],
        className,
        classes,
        key,
        attr,
        i;

    if (!elem || !elem.tagName) {
        return '';
    }

    out.push(elem.tagName.toLowerCase());
    if (elem.id) {
        out.push('#' + elem.id);
    }

    className = elem.className;
    if (className && isString(className)) {
        classes = className.split(/\s+/);
        for (i = 0; i < classes.length; i++) {
            out.push('.' + classes[i]);
        }
    }
    var attrWhitelist = ['type', 'name', 'title', 'alt'];
    for (i = 0; i < attrWhitelist.length; i++) {
        key = attrWhitelist[i];
        attr = elem.getAttribute(key);
        if (attr) {
            out.push('[' + key + '="' + attr + '"]');
        }
    }
    return out.join('');
}

/**
 * Returns true if either a OR b is truthy, but not both
 */
function isOnlyOneTruthy(a, b) {
    return !!(!!a ^ !!b);
}

/**
 * Returns true if the two input exception interfaces have the same content
 */
function isSameException(ex1, ex2) {
    if (isOnlyOneTruthy(ex1, ex2))
        return false;

    ex1 = ex1.values[0];
    ex2 = ex2.values[0];

    if (ex1.type !== ex2.type ||
        ex1.value !== ex2.value)
        return false;

    return isSameStacktrace(ex1.stacktrace, ex2.stacktrace);
}

/**
 * Returns true if the two input stack trace interfaces have the same content
 */
function isSameStacktrace(stack1, stack2) {
    if (isOnlyOneTruthy(stack1, stack2))
        return false;

    var frames1 = stack1.frames;
    var frames2 = stack2.frames;

    // Exit early if frame count differs
    if (frames1.length !== frames2.length)
        return false;

    // Iterate through every frame; bail out if anything differs
    var a, b;
    for (var i = 0; i < frames1.length; i++) {
        a = frames1[i];
        b = frames2[i];
        if (a.filename !== b.filename ||
            a.lineno !== b.lineno ||
            a.colno !== b.colno ||
            a['function'] !== b['function'])
            return false;
    }
    return true;
}

/**
 * Polyfill a method
 * @param obj object e.g. `document`
 * @param name method name present on object e.g. `addEventListener`
 * @param replacement replacement function
 * @param track {optional} record instrumentation to an array
 */
function fill(obj, name, replacement, track) {
    var orig = obj[name];
    obj[name] = replacement(orig);
    if (track) {
        track.push([obj, name, orig]);
    }
}

if (typeof __DEV__ !== 'undefined' && __DEV__) {
    Raven.utils = {
        isUndefined: isUndefined,
        isFunction: isFunction,
        isString: isString,
        isObject: isObject,
        isEmptyObject: isEmptyObject,
        isError: isError,
        each: each,
        objectMerge: objectMerge,
        truncate: truncate,
        hasKey: hasKey,
        joinRegExp: joinRegExp,
        urlencode: urlencode,
        uuid4: uuid4,
        htmlTreeAsString: htmlTreeAsString,
        htmlElementAsString: htmlElementAsString,
        parseUrl: parseUrl,
        fill: fill
    };
};

// Deprecations
Raven.prototype.setUser = Raven.prototype.setUserContext;
Raven.prototype.setReleaseContext = Raven.prototype.setRelease;

module.exports = Raven;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../vendor/TraceKit/tracekit":528,"../vendor/json-stringify-safe/stringify":529,"./configError":523,"./console":524,"./utils":527}],526:[function(require,module,exports){
(function (global){
/**
 * Enforces a single instance of the Raven client, and the
 * main entry point for Raven. If you are a consumer of the
 * Raven library, you SHOULD load this file (vs raven.js).
 **/

'use strict';

var RavenConstructor = require('./raven');

// This is to be defensive in environments where window does not exist (see https://github.com/getsentry/raven-js/pull/785)
var _window = typeof window !== 'undefined' ? window
            : typeof global !== 'undefined' ? global
            : typeof self !== 'undefined' ? self
            : {};
var _Raven = _window.Raven;

var Raven = new RavenConstructor();

/*
 * Allow multiple versions of Raven to be installed.
 * Strip Raven from the global context and returns the instance.
 *
 * @return {Raven}
 */
Raven.noConflict = function () {
	_window.Raven = _Raven;
	return Raven;
};

Raven.afterLoad();

module.exports = Raven;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./raven":525}],527:[function(require,module,exports){
'use strict';

function isObject(what) {
    return typeof what === 'object' && what !== null;
}

// Yanked from https://git.io/vS8DV re-used under CC0
// with some tiny modifications
function isError(value) {
  switch ({}.toString.call(value)) {
    case '[object Error]': return true;
    case '[object Exception]': return true;
    case '[object DOMException]': return true;
    default: return value instanceof Error;
  }
}

module.exports = {
    isObject: isObject,
    isError: isError
};

},{}],528:[function(require,module,exports){
(function (global){
'use strict';

var utils = require('../../src/utils');

/*
 TraceKit - Cross brower stack traces

 This was originally forked from github.com/occ/TraceKit, but has since been
 largely re-written and is now maintained as part of raven-js.  Tests for
 this are in test/vendor.

 MIT license
*/

var TraceKit = {
    collectWindowErrors: true,
    debug: false
};

// This is to be defensive in environments where window does not exist (see https://github.com/getsentry/raven-js/pull/785)
var _window = typeof window !== 'undefined' ? window
            : typeof global !== 'undefined' ? global
            : typeof self !== 'undefined' ? self
            : {};

// global reference to slice
var _slice = [].slice;
var UNKNOWN_FUNCTION = '?';

// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error#Error_types
var ERROR_TYPES_RE = /^(?:[Uu]ncaught (?:exception: )?)?(?:((?:Eval|Internal|Range|Reference|Syntax|Type|URI|)Error): )?(.*)$/;

function getLocationHref() {
    if (typeof document === 'undefined' || typeof document.location === 'undefined')
        return '';

    return document.location.href;
}


/**
 * TraceKit.report: cross-browser processing of unhandled exceptions
 *
 * Syntax:
 *   TraceKit.report.subscribe(function(stackInfo) { ... })
 *   TraceKit.report.unsubscribe(function(stackInfo) { ... })
 *   TraceKit.report(exception)
 *   try { ...code... } catch(ex) { TraceKit.report(ex); }
 *
 * Supports:
 *   - Firefox: full stack trace with line numbers, plus column number
 *              on top frame; column number is not guaranteed
 *   - Opera:   full stack trace with line and column numbers
 *   - Chrome:  full stack trace with line and column numbers
 *   - Safari:  line and column number for the top frame only; some frames
 *              may be missing, and column number is not guaranteed
 *   - IE:      line and column number for the top frame only; some frames
 *              may be missing, and column number is not guaranteed
 *
 * In theory, TraceKit should work on all of the following versions:
 *   - IE5.5+ (only 8.0 tested)
 *   - Firefox 0.9+ (only 3.5+ tested)
 *   - Opera 7+ (only 10.50 tested; versions 9 and earlier may require
 *     Exceptions Have Stacktrace to be enabled in opera:config)
 *   - Safari 3+ (only 4+ tested)
 *   - Chrome 1+ (only 5+ tested)
 *   - Konqueror 3.5+ (untested)
 *
 * Requires TraceKit.computeStackTrace.
 *
 * Tries to catch all unhandled exceptions and report them to the
 * subscribed handlers. Please note that TraceKit.report will rethrow the
 * exception. This is REQUIRED in order to get a useful stack trace in IE.
 * If the exception does not reach the top of the browser, you will only
 * get a stack trace from the point where TraceKit.report was called.
 *
 * Handlers receive a stackInfo object as described in the
 * TraceKit.computeStackTrace docs.
 */
TraceKit.report = (function reportModuleWrapper() {
    var handlers = [],
        lastArgs = null,
        lastException = null,
        lastExceptionStack = null;

    /**
     * Add a crash handler.
     * @param {Function} handler
     */
    function subscribe(handler) {
        installGlobalHandler();
        handlers.push(handler);
    }

    /**
     * Remove a crash handler.
     * @param {Function} handler
     */
    function unsubscribe(handler) {
        for (var i = handlers.length - 1; i >= 0; --i) {
            if (handlers[i] === handler) {
                handlers.splice(i, 1);
            }
        }
    }

    /**
     * Remove all crash handlers.
     */
    function unsubscribeAll() {
        uninstallGlobalHandler();
        handlers = [];
    }

    /**
     * Dispatch stack information to all handlers.
     * @param {Object.<string, *>} stack
     */
    function notifyHandlers(stack, isWindowError) {
        var exception = null;
        if (isWindowError && !TraceKit.collectWindowErrors) {
          return;
        }
        for (var i in handlers) {
            if (handlers.hasOwnProperty(i)) {
                try {
                    handlers[i].apply(null, [stack].concat(_slice.call(arguments, 2)));
                } catch (inner) {
                    exception = inner;
                }
            }
        }

        if (exception) {
            throw exception;
        }
    }

    var _oldOnerrorHandler, _onErrorHandlerInstalled;

    /**
     * Ensures all global unhandled exceptions are recorded.
     * Supported by Gecko and IE.
     * @param {string} message Error message.
     * @param {string} url URL of script that generated the exception.
     * @param {(number|string)} lineNo The line number at which the error
     * occurred.
     * @param {?(number|string)} colNo The column number at which the error
     * occurred.
     * @param {?Error} ex The actual Error object.
     */
    function traceKitWindowOnError(message, url, lineNo, colNo, ex) {
        var stack = null;

        if (lastExceptionStack) {
            TraceKit.computeStackTrace.augmentStackTraceWithInitialElement(lastExceptionStack, url, lineNo, message);
            processLastException();
        } else if (ex && utils.isError(ex)) {
            // non-string `ex` arg; attempt to extract stack trace

            // New chrome and blink send along a real error object
            // Let's just report that like a normal error.
            // See: https://mikewest.org/2013/08/debugging-runtime-errors-with-window-onerror
            stack = TraceKit.computeStackTrace(ex);
            notifyHandlers(stack, true);
        } else {
            var location = {
                'url': url,
                'line': lineNo,
                'column': colNo
            };

            var name = undefined;
            var msg = message; // must be new var or will modify original `arguments`
            var groups;
            if ({}.toString.call(message) === '[object String]') {
                var groups = message.match(ERROR_TYPES_RE);
                if (groups) {
                    name = groups[1];
                    msg = groups[2];
                }
            }

            location.func = UNKNOWN_FUNCTION;

            stack = {
                'name': name,
                'message': msg,
                'url': getLocationHref(),
                'stack': [location]
            };
            notifyHandlers(stack, true);
        }

        if (_oldOnerrorHandler) {
            return _oldOnerrorHandler.apply(this, arguments);
        }

        return false;
    }

    function installGlobalHandler ()
    {
        if (_onErrorHandlerInstalled) {
            return;
        }
        _oldOnerrorHandler = _window.onerror;
        _window.onerror = traceKitWindowOnError;
        _onErrorHandlerInstalled = true;
    }

    function uninstallGlobalHandler ()
    {
        if (!_onErrorHandlerInstalled) {
            return;
        }
        _window.onerror = _oldOnerrorHandler;
        _onErrorHandlerInstalled = false;
        _oldOnerrorHandler = undefined;
    }

    function processLastException() {
        var _lastExceptionStack = lastExceptionStack,
            _lastArgs = lastArgs;
        lastArgs = null;
        lastExceptionStack = null;
        lastException = null;
        notifyHandlers.apply(null, [_lastExceptionStack, false].concat(_lastArgs));
    }

    /**
     * Reports an unhandled Error to TraceKit.
     * @param {Error} ex
     * @param {?boolean} rethrow If false, do not re-throw the exception.
     * Only used for window.onerror to not cause an infinite loop of
     * rethrowing.
     */
    function report(ex, rethrow) {
        var args = _slice.call(arguments, 1);
        if (lastExceptionStack) {
            if (lastException === ex) {
                return; // already caught by an inner catch block, ignore
            } else {
              processLastException();
            }
        }

        var stack = TraceKit.computeStackTrace(ex);
        lastExceptionStack = stack;
        lastException = ex;
        lastArgs = args;

        // If the stack trace is incomplete, wait for 2 seconds for
        // slow slow IE to see if onerror occurs or not before reporting
        // this exception; otherwise, we will end up with an incomplete
        // stack trace
        setTimeout(function () {
            if (lastException === ex) {
                processLastException();
            }
        }, (stack.incomplete ? 2000 : 0));

        if (rethrow !== false) {
            throw ex; // re-throw to propagate to the top level (and cause window.onerror)
        }
    }

    report.subscribe = subscribe;
    report.unsubscribe = unsubscribe;
    report.uninstall = unsubscribeAll;
    return report;
}());

/**
 * TraceKit.computeStackTrace: cross-browser stack traces in JavaScript
 *
 * Syntax:
 *   s = TraceKit.computeStackTrace(exception) // consider using TraceKit.report instead (see below)
 * Returns:
 *   s.name              - exception name
 *   s.message           - exception message
 *   s.stack[i].url      - JavaScript or HTML file URL
 *   s.stack[i].func     - function name, or empty for anonymous functions (if guessing did not work)
 *   s.stack[i].args     - arguments passed to the function, if known
 *   s.stack[i].line     - line number, if known
 *   s.stack[i].column   - column number, if known
 *
 * Supports:
 *   - Firefox:  full stack trace with line numbers and unreliable column
 *               number on top frame
 *   - Opera 10: full stack trace with line and column numbers
 *   - Opera 9-: full stack trace with line numbers
 *   - Chrome:   full stack trace with line and column numbers
 *   - Safari:   line and column number for the topmost stacktrace element
 *               only
 *   - IE:       no line numbers whatsoever
 *
 * Tries to guess names of anonymous functions by looking for assignments
 * in the source code. In IE and Safari, we have to guess source file names
 * by searching for function bodies inside all page scripts. This will not
 * work for scripts that are loaded cross-domain.
 * Here be dragons: some function names may be guessed incorrectly, and
 * duplicate functions may be mismatched.
 *
 * TraceKit.computeStackTrace should only be used for tracing purposes.
 * Logging of unhandled exceptions should be done with TraceKit.report,
 * which builds on top of TraceKit.computeStackTrace and provides better
 * IE support by utilizing the window.onerror event to retrieve information
 * about the top of the stack.
 *
 * Note: In IE and Safari, no stack trace is recorded on the Error object,
 * so computeStackTrace instead walks its *own* chain of callers.
 * This means that:
 *  * in Safari, some methods may be missing from the stack trace;
 *  * in IE, the topmost function in the stack trace will always be the
 *    caller of computeStackTrace.
 *
 * This is okay for tracing (because you are likely to be calling
 * computeStackTrace from the function you want to be the topmost element
 * of the stack trace anyway), but not okay for logging unhandled
 * exceptions (because your catch block will likely be far away from the
 * inner function that actually caused the exception).
 *
 */
TraceKit.computeStackTrace = (function computeStackTraceWrapper() {
    // Contents of Exception in various browsers.
    //
    // SAFARI:
    // ex.message = Can't find variable: qq
    // ex.line = 59
    // ex.sourceId = 580238192
    // ex.sourceURL = http://...
    // ex.expressionBeginOffset = 96
    // ex.expressionCaretOffset = 98
    // ex.expressionEndOffset = 98
    // ex.name = ReferenceError
    //
    // FIREFOX:
    // ex.message = qq is not defined
    // ex.fileName = http://...
    // ex.lineNumber = 59
    // ex.columnNumber = 69
    // ex.stack = ...stack trace... (see the example below)
    // ex.name = ReferenceError
    //
    // CHROME:
    // ex.message = qq is not defined
    // ex.name = ReferenceError
    // ex.type = not_defined
    // ex.arguments = ['aa']
    // ex.stack = ...stack trace...
    //
    // INTERNET EXPLORER:
    // ex.message = ...
    // ex.name = ReferenceError
    //
    // OPERA:
    // ex.message = ...message... (see the example below)
    // ex.name = ReferenceError
    // ex.opera#sourceloc = 11  (pretty much useless, duplicates the info in ex.message)
    // ex.stacktrace = n/a; see 'opera:config#UserPrefs|Exceptions Have Stacktrace'

    /**
     * Computes stack trace information from the stack property.
     * Chrome and Gecko use this property.
     * @param {Error} ex
     * @return {?Object.<string, *>} Stack trace information.
     */
    function computeStackTraceFromStackProp(ex) {
        if (typeof ex.stack === 'undefined' || !ex.stack) return;

        var chrome = /^\s*at (.*?) ?\(((?:file|https?|blob|chrome-extension|native|eval|webpack|<anonymous>|\/).*?)(?::(\d+))?(?::(\d+))?\)?\s*$/i,
            gecko = /^\s*(.*?)(?:\((.*?)\))?(?:^|@)((?:file|https?|blob|chrome|webpack|resource|\[native).*?)(?::(\d+))?(?::(\d+))?\s*$/i,
            winjs = /^\s*at (?:((?:\[object object\])?.+) )?\(?((?:file|ms-appx|https?|webpack|blob):.*?):(\d+)(?::(\d+))?\)?\s*$/i,

            // Used to additionally parse URL/line/column from eval frames
            geckoEval = /(\S+) line (\d+)(?: > eval line \d+)* > eval/i,
            chromeEval = /\((\S*)(?::(\d+))(?::(\d+))\)/,

            lines = ex.stack.split('\n'),
            stack = [],
            submatch,
            parts,
            element,
            reference = /^(.*) is undefined$/.exec(ex.message);

        for (var i = 0, j = lines.length; i < j; ++i) {
            if ((parts = chrome.exec(lines[i]))) {
                var isNative = parts[2] && parts[2].indexOf('native') === 0; // start of line
                var isEval = parts[2] && parts[2].indexOf('eval') === 0; // start of line
                if (isEval && (submatch = chromeEval.exec(parts[2]))) {
                    // throw out eval line/column and use top-most line/column number
                    parts[2] = submatch[1]; // url
                    parts[3] = submatch[2]; // line
                    parts[4] = submatch[3]; // column
                }
                element = {
                    'url': !isNative ? parts[2] : null,
                    'func': parts[1] || UNKNOWN_FUNCTION,
                    'args': isNative ? [parts[2]] : [],
                    'line': parts[3] ? +parts[3] : null,
                    'column': parts[4] ? +parts[4] : null
                };
            } else if ( parts = winjs.exec(lines[i]) ) {
                element = {
                    'url': parts[2],
                    'func': parts[1] || UNKNOWN_FUNCTION,
                    'args': [],
                    'line': +parts[3],
                    'column': parts[4] ? +parts[4] : null
                };
            } else if ((parts = gecko.exec(lines[i]))) {
                var isEval = parts[3] && parts[3].indexOf(' > eval') > -1;
                if (isEval && (submatch = geckoEval.exec(parts[3]))) {
                    // throw out eval line/column and use top-most line number
                    parts[3] = submatch[1];
                    parts[4] = submatch[2];
                    parts[5] = null; // no column when eval
                } else if (i === 0 && !parts[5] && typeof ex.columnNumber !== 'undefined') {
                    // FireFox uses this awesome columnNumber property for its top frame
                    // Also note, Firefox's column number is 0-based and everything else expects 1-based,
                    // so adding 1
                    // NOTE: this hack doesn't work if top-most frame is eval
                    stack[0].column = ex.columnNumber + 1;
                }
                element = {
                    'url': parts[3],
                    'func': parts[1] || UNKNOWN_FUNCTION,
                    'args': parts[2] ? parts[2].split(',') : [],
                    'line': parts[4] ? +parts[4] : null,
                    'column': parts[5] ? +parts[5] : null
                };
            } else {
                continue;
            }

            if (!element.func && element.line) {
                element.func = UNKNOWN_FUNCTION;
            }

            stack.push(element);
        }

        if (!stack.length) {
            return null;
        }

        return {
            'name': ex.name,
            'message': ex.message,
            'url': getLocationHref(),
            'stack': stack
        };
    }

    /**
     * Adds information about the first frame to incomplete stack traces.
     * Safari and IE require this to get complete data on the first frame.
     * @param {Object.<string, *>} stackInfo Stack trace information from
     * one of the compute* methods.
     * @param {string} url The URL of the script that caused an error.
     * @param {(number|string)} lineNo The line number of the script that
     * caused an error.
     * @param {string=} message The error generated by the browser, which
     * hopefully contains the name of the object that caused the error.
     * @return {boolean} Whether or not the stack information was
     * augmented.
     */
    function augmentStackTraceWithInitialElement(stackInfo, url, lineNo, message) {
        var initial = {
            'url': url,
            'line': lineNo
        };

        if (initial.url && initial.line) {
            stackInfo.incomplete = false;

            if (!initial.func) {
                initial.func = UNKNOWN_FUNCTION;
            }

            if (stackInfo.stack.length > 0) {
                if (stackInfo.stack[0].url === initial.url) {
                    if (stackInfo.stack[0].line === initial.line) {
                        return false; // already in stack trace
                    } else if (!stackInfo.stack[0].line && stackInfo.stack[0].func === initial.func) {
                        stackInfo.stack[0].line = initial.line;
                        return false;
                    }
                }
            }

            stackInfo.stack.unshift(initial);
            stackInfo.partial = true;
            return true;
        } else {
            stackInfo.incomplete = true;
        }

        return false;
    }

    /**
     * Computes stack trace information by walking the arguments.caller
     * chain at the time the exception occurred. This will cause earlier
     * frames to be missed but is the only way to get any stack trace in
     * Safari and IE. The top frame is restored by
     * {@link augmentStackTraceWithInitialElement}.
     * @param {Error} ex
     * @return {?Object.<string, *>} Stack trace information.
     */
    function computeStackTraceByWalkingCallerChain(ex, depth) {
        var functionName = /function\s+([_$a-zA-Z\xA0-\uFFFF][_$a-zA-Z0-9\xA0-\uFFFF]*)?\s*\(/i,
            stack = [],
            funcs = {},
            recursion = false,
            parts,
            item,
            source;

        for (var curr = computeStackTraceByWalkingCallerChain.caller; curr && !recursion; curr = curr.caller) {
            if (curr === computeStackTrace || curr === TraceKit.report) {
                // console.log('skipping internal function');
                continue;
            }

            item = {
                'url': null,
                'func': UNKNOWN_FUNCTION,
                'line': null,
                'column': null
            };

            if (curr.name) {
                item.func = curr.name;
            } else if ((parts = functionName.exec(curr.toString()))) {
                item.func = parts[1];
            }

            if (typeof item.func === 'undefined') {
              try {
                item.func = parts.input.substring(0, parts.input.indexOf('{'));
              } catch (e) { }
            }

            if (funcs['' + curr]) {
                recursion = true;
            }else{
                funcs['' + curr] = true;
            }

            stack.push(item);
        }

        if (depth) {
            // console.log('depth is ' + depth);
            // console.log('stack is ' + stack.length);
            stack.splice(0, depth);
        }

        var result = {
            'name': ex.name,
            'message': ex.message,
            'url': getLocationHref(),
            'stack': stack
        };
        augmentStackTraceWithInitialElement(result, ex.sourceURL || ex.fileName, ex.line || ex.lineNumber, ex.message || ex.description);
        return result;
    }

    /**
     * Computes a stack trace for an exception.
     * @param {Error} ex
     * @param {(string|number)=} depth
     */
    function computeStackTrace(ex, depth) {
        var stack = null;
        depth = (depth == null ? 0 : +depth);

        try {
            stack = computeStackTraceFromStackProp(ex);
            if (stack) {
                return stack;
            }
        } catch (e) {
            if (TraceKit.debug) {
                throw e;
            }
        }

        try {
            stack = computeStackTraceByWalkingCallerChain(ex, depth + 1);
            if (stack) {
                return stack;
            }
        } catch (e) {
            if (TraceKit.debug) {
                throw e;
            }
        }
        return {
            'name': ex.name,
            'message': ex.message,
            'url': getLocationHref()
        };
    }

    computeStackTrace.augmentStackTraceWithInitialElement = augmentStackTraceWithInitialElement;
    computeStackTrace.computeStackTraceFromStackProp = computeStackTraceFromStackProp;

    return computeStackTrace;
}());

module.exports = TraceKit;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../src/utils":527}],529:[function(require,module,exports){
'use strict';

/*
 json-stringify-safe
 Like JSON.stringify, but doesn't throw on circular references.

 Originally forked from https://github.com/isaacs/json-stringify-safe
 version 5.0.1 on 3/8/2017 and modified for IE8 compatibility.
 Tests for this are in test/vendor.

 ISC license: https://github.com/isaacs/json-stringify-safe/blob/master/LICENSE
*/

exports = module.exports = stringify
exports.getSerialize = serializer

function indexOf(haystack, needle) {
  for (var i = 0; i < haystack.length; ++i) {
    if (haystack[i] === needle) return i;
  }
  return -1;
}

function stringify(obj, replacer, spaces, cycleReplacer) {
  return JSON.stringify(obj, serializer(replacer, cycleReplacer), spaces)
}

function serializer(replacer, cycleReplacer) {
  var stack = [], keys = []

  if (cycleReplacer == null) cycleReplacer = function(key, value) {
    if (stack[0] === value) return '[Circular ~]'
    return '[Circular ~.' + keys.slice(0, indexOf(stack, value)).join('.') + ']'
  }

  return function(key, value) {
    if (stack.length > 0) {
      var thisPos = indexOf(stack, this);
      ~thisPos ? stack.splice(thisPos + 1) : stack.push(this)
      ~thisPos ? keys.splice(thisPos, Infinity, key) : keys.push(key)
      if (~indexOf(stack, value)) value = cycleReplacer.call(this, key, value)
    }
    else stack.push(value)

    return replacer == null ? value : replacer.call(this, key, value)
  }
}

},{}],530:[function(require,module,exports){
'use strict';

module.exports = require('./lib/ReactDOM');

},{"./lib/ReactDOM":560}],531:[function(require,module,exports){
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */

'use strict';

var ARIADOMPropertyConfig = {
  Properties: {
    // Global States and Properties
    'aria-current': 0, // state
    'aria-details': 0,
    'aria-disabled': 0, // state
    'aria-hidden': 0, // state
    'aria-invalid': 0, // state
    'aria-keyshortcuts': 0,
    'aria-label': 0,
    'aria-roledescription': 0,
    // Widget Attributes
    'aria-autocomplete': 0,
    'aria-checked': 0,
    'aria-expanded': 0,
    'aria-haspopup': 0,
    'aria-level': 0,
    'aria-modal': 0,
    'aria-multiline': 0,
    'aria-multiselectable': 0,
    'aria-orientation': 0,
    'aria-placeholder': 0,
    'aria-pressed': 0,
    'aria-readonly': 0,
    'aria-required': 0,
    'aria-selected': 0,
    'aria-sort': 0,
    'aria-valuemax': 0,
    'aria-valuemin': 0,
    'aria-valuenow': 0,
    'aria-valuetext': 0,
    // Live Region Attributes
    'aria-atomic': 0,
    'aria-busy': 0,
    'aria-live': 0,
    'aria-relevant': 0,
    // Drag-and-Drop Attributes
    'aria-dropeffect': 0,
    'aria-grabbed': 0,
    // Relationship Attributes
    'aria-activedescendant': 0,
    'aria-colcount': 0,
    'aria-colindex': 0,
    'aria-colspan': 0,
    'aria-controls': 0,
    'aria-describedby': 0,
    'aria-errormessage': 0,
    'aria-flowto': 0,
    'aria-labelledby': 0,
    'aria-owns': 0,
    'aria-posinset': 0,
    'aria-rowcount': 0,
    'aria-rowindex': 0,
    'aria-rowspan': 0,
    'aria-setsize': 0
  },
  DOMAttributeNames: {},
  DOMPropertyNames: {}
};

module.exports = ARIADOMPropertyConfig;
},{}],532:[function(require,module,exports){
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */

'use strict';

var ReactDOMComponentTree = require('./ReactDOMComponentTree');

var focusNode = require('fbjs/lib/focusNode');

var AutoFocusUtils = {
  focusDOMComponent: function () {
    focusNode(ReactDOMComponentTree.getNodeFromInstance(this));
  }
};

module.exports = AutoFocusUtils;
},{"./ReactDOMComponentTree":563,"fbjs/lib/focusNode":396}],533:[function(require,module,exports){
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */

'use strict';

var EventPropagators = require('./EventPropagators');
var ExecutionEnvironment = require('fbjs/lib/ExecutionEnvironment');
var FallbackCompositionState = require('./FallbackCompositionState');
var SyntheticCompositionEvent = require('./SyntheticCompositionEvent');
var SyntheticInputEvent = require('./SyntheticInputEvent');

var END_KEYCODES = [9, 13, 27, 32]; // Tab, Return, Esc, Space
var START_KEYCODE = 229;

var canUseCompositionEvent = ExecutionEnvironment.canUseDOM && 'CompositionEvent' in window;

var documentMode = null;
if (ExecutionEnvironment.canUseDOM && 'documentMode' in document) {
  documentMode = document.documentMode;
}

// Webkit offers a very useful `textInput` event that can be used to
// directly represent `beforeInput`. The IE `textinput` event is not as
// useful, so we don't use it.
var canUseTextInputEvent = ExecutionEnvironment.canUseDOM && 'TextEvent' in window && !documentMode && !isPresto();

// In IE9+, we have access to composition events, but the data supplied
// by the native compositionend event may be incorrect. Japanese ideographic
// spaces, for instance (\u3000) are not recorded correctly.
var useFallbackCompositionData = ExecutionEnvironment.canUseDOM && (!canUseCompositionEvent || documentMode && documentMode > 8 && documentMode <= 11);

/**
 * Opera <= 12 includes TextEvent in window, but does not fire
 * text input events. Rely on keypress instead.
 */
function isPresto() {
  var opera = window.opera;
  return typeof opera === 'object' && typeof opera.version === 'function' && parseInt(opera.version(), 10) <= 12;
}

var SPACEBAR_CODE = 32;
var SPACEBAR_CHAR = String.fromCharCode(SPACEBAR_CODE);

// Events and their corresponding property names.
var eventTypes = {
  beforeInput: {
    phasedRegistrationNames: {
      bubbled: 'onBeforeInput',
      captured: 'onBeforeInputCapture'
    },
    dependencies: ['topCompositionEnd', 'topKeyPress', 'topTextInput', 'topPaste']
  },
  compositionEnd: {
    phasedRegistrationNames: {
      bubbled: 'onCompositionEnd',
      captured: 'onCompositionEndCapture'
    },
    dependencies: ['topBlur', 'topCompositionEnd', 'topKeyDown', 'topKeyPress', 'topKeyUp', 'topMouseDown']
  },
  compositionStart: {
    phasedRegistrationNames: {
      bubbled: 'onCompositionStart',
      captured: 'onCompositionStartCapture'
    },
    dependencies: ['topBlur', 'topCompositionStart', 'topKeyDown', 'topKeyPress', 'topKeyUp', 'topMouseDown']
  },
  compositionUpdate: {
    phasedRegistrationNames: {
      bubbled: 'onCompositionUpdate',
      captured: 'onCompositionUpdateCapture'
    },
    dependencies: ['topBlur', 'topCompositionUpdate', 'topKeyDown', 'topKeyPress', 'topKeyUp', 'topMouseDown']
  }
};

// Track whether we've ever handled a keypress on the space key.
var hasSpaceKeypress = false;

/**
 * Return whether a native keypress event is assumed to be a command.
 * This is required because Firefox fires `keypress` events for key commands
 * (cut, copy, select-all, etc.) even though no character is inserted.
 */
function isKeypressCommand(nativeEvent) {
  return (nativeEvent.ctrlKey || nativeEvent.altKey || nativeEvent.metaKey) &&
  // ctrlKey && altKey is equivalent to AltGr, and is not a command.
  !(nativeEvent.ctrlKey && nativeEvent.altKey);
}

/**
 * Translate native top level events into event types.
 *
 * @param {string} topLevelType
 * @return {object}
 */
function getCompositionEventType(topLevelType) {
  switch (topLevelType) {
    case 'topCompositionStart':
      return eventTypes.compositionStart;
    case 'topCompositionEnd':
      return eventTypes.compositionEnd;
    case 'topCompositionUpdate':
      return eventTypes.compositionUpdate;
  }
}

/**
 * Does our fallback best-guess model think this event signifies that
 * composition has begun?
 *
 * @param {string} topLevelType
 * @param {object} nativeEvent
 * @return {boolean}
 */
function isFallbackCompositionStart(topLevelType, nativeEvent) {
  return topLevelType === 'topKeyDown' && nativeEvent.keyCode === START_KEYCODE;
}

/**
 * Does our fallback mode think that this event is the end of composition?
 *
 * @param {string} topLevelType
 * @param {object} nativeEvent
 * @return {boolean}
 */
function isFallbackCompositionEnd(topLevelType, nativeEvent) {
  switch (topLevelType) {
    case 'topKeyUp':
      // Command keys insert or clear IME input.
      return END_KEYCODES.indexOf(nativeEvent.keyCode) !== -1;
    case 'topKeyDown':
      // Expect IME keyCode on each keydown. If we get any other
      // code we must have exited earlier.
      return nativeEvent.keyCode !== START_KEYCODE;
    case 'topKeyPress':
    case 'topMouseDown':
    case 'topBlur':
      // Events are not possible without cancelling IME.
      return true;
    default:
      return false;
  }
}

/**
 * Google Input Tools provides composition data via a CustomEvent,
 * with the `data` property populated in the `detail` object. If this
 * is available on the event object, use it. If not, this is a plain
 * composition event and we have nothing special to extract.
 *
 * @param {object} nativeEvent
 * @return {?string}
 */
function getDataFromCustomEvent(nativeEvent) {
  var detail = nativeEvent.detail;
  if (typeof detail === 'object' && 'data' in detail) {
    return detail.data;
  }
  return null;
}

// Track the current IME composition fallback object, if any.
var currentComposition = null;

/**
 * @return {?object} A SyntheticCompositionEvent.
 */
function extractCompositionEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
  var eventType;
  var fallbackData;

  if (canUseCompositionEvent) {
    eventType = getCompositionEventType(topLevelType);
  } else if (!currentComposition) {
    if (isFallbackCompositionStart(topLevelType, nativeEvent)) {
      eventType = eventTypes.compositionStart;
    }
  } else if (isFallbackCompositionEnd(topLevelType, nativeEvent)) {
    eventType = eventTypes.compositionEnd;
  }

  if (!eventType) {
    return null;
  }

  if (useFallbackCompositionData) {
    // The current composition is stored statically and must not be
    // overwritten while composition continues.
    if (!currentComposition && eventType === eventTypes.compositionStart) {
      currentComposition = FallbackCompositionState.getPooled(nativeEventTarget);
    } else if (eventType === eventTypes.compositionEnd) {
      if (currentComposition) {
        fallbackData = currentComposition.getData();
      }
    }
  }

  var event = SyntheticCompositionEvent.getPooled(eventType, targetInst, nativeEvent, nativeEventTarget);

  if (fallbackData) {
    // Inject data generated from fallback path into the synthetic event.
    // This matches the property of native CompositionEventInterface.
    event.data = fallbackData;
  } else {
    var customData = getDataFromCustomEvent(nativeEvent);
    if (customData !== null) {
      event.data = customData;
    }
  }

  EventPropagators.accumulateTwoPhaseDispatches(event);
  return event;
}

/**
 * @param {string} topLevelType Record from `EventConstants`.
 * @param {object} nativeEvent Native browser event.
 * @return {?string} The string corresponding to this `beforeInput` event.
 */
function getNativeBeforeInputChars(topLevelType, nativeEvent) {
  switch (topLevelType) {
    case 'topCompositionEnd':
      return getDataFromCustomEvent(nativeEvent);
    case 'topKeyPress':
      /**
       * If native `textInput` events are available, our goal is to make
       * use of them. However, there is a special case: the spacebar key.
       * In Webkit, preventing default on a spacebar `textInput` event
       * cancels character insertion, but it *also* causes the browser
       * to fall back to its default spacebar behavior of scrolling the
       * page.
       *
       * Tracking at:
       * https://code.google.com/p/chromium/issues/detail?id=355103
       *
       * To avoid this issue, use the keypress event as if no `textInput`
       * event is available.
       */
      var which = nativeEvent.which;
      if (which !== SPACEBAR_CODE) {
        return null;
      }

      hasSpaceKeypress = true;
      return SPACEBAR_CHAR;

    case 'topTextInput':
      // Record the characters to be added to the DOM.
      var chars = nativeEvent.data;

      // If it's a spacebar character, assume that we have already handled
      // it at the keypress level and bail immediately. Android Chrome
      // doesn't give us keycodes, so we need to blacklist it.
      if (chars === SPACEBAR_CHAR && hasSpaceKeypress) {
        return null;
      }

      return chars;

    default:
      // For other native event types, do nothing.
      return null;
  }
}

/**
 * For browsers that do not provide the `textInput` event, extract the
 * appropriate string to use for SyntheticInputEvent.
 *
 * @param {string} topLevelType Record from `EventConstants`.
 * @param {object} nativeEvent Native browser event.
 * @return {?string} The fallback string for this `beforeInput` event.
 */
function getFallbackBeforeInputChars(topLevelType, nativeEvent) {
  // If we are currently composing (IME) and using a fallback to do so,
  // try to extract the composed characters from the fallback object.
  // If composition event is available, we extract a string only at
  // compositionevent, otherwise extract it at fallback events.
  if (currentComposition) {
    if (topLevelType === 'topCompositionEnd' || !canUseCompositionEvent && isFallbackCompositionEnd(topLevelType, nativeEvent)) {
      var chars = currentComposition.getData();
      FallbackCompositionState.release(currentComposition);
      currentComposition = null;
      return chars;
    }
    return null;
  }

  switch (topLevelType) {
    case 'topPaste':
      // If a paste event occurs after a keypress, throw out the input
      // chars. Paste events should not lead to BeforeInput events.
      return null;
    case 'topKeyPress':
      /**
       * As of v27, Firefox may fire keypress events even when no character
       * will be inserted. A few possibilities:
       *
       * - `which` is `0`. Arrow keys, Esc key, etc.
       *
       * - `which` is the pressed key code, but no char is available.
       *   Ex: 'AltGr + d` in Polish. There is no modified character for
       *   this key combination and no character is inserted into the
       *   document, but FF fires the keypress for char code `100` anyway.
       *   No `input` event will occur.
       *
       * - `which` is the pressed key code, but a command combination is
       *   being used. Ex: `Cmd+C`. No character is inserted, and no
       *   `input` event will occur.
       */
      if (nativeEvent.which && !isKeypressCommand(nativeEvent)) {
        return String.fromCharCode(nativeEvent.which);
      }
      return null;
    case 'topCompositionEnd':
      return useFallbackCompositionData ? null : nativeEvent.data;
    default:
      return null;
  }
}

/**
 * Extract a SyntheticInputEvent for `beforeInput`, based on either native
 * `textInput` or fallback behavior.
 *
 * @return {?object} A SyntheticInputEvent.
 */
function extractBeforeInputEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
  var chars;

  if (canUseTextInputEvent) {
    chars = getNativeBeforeInputChars(topLevelType, nativeEvent);
  } else {
    chars = getFallbackBeforeInputChars(topLevelType, nativeEvent);
  }

  // If no characters are being inserted, no BeforeInput event should
  // be fired.
  if (!chars) {
    return null;
  }

  var event = SyntheticInputEvent.getPooled(eventTypes.beforeInput, targetInst, nativeEvent, nativeEventTarget);

  event.data = chars;
  EventPropagators.accumulateTwoPhaseDispatches(event);
  return event;
}

/**
 * Create an `onBeforeInput` event to match
 * http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105/#events-inputevents.
 *
 * This event plugin is based on the native `textInput` event
 * available in Chrome, Safari, Opera, and IE. This event fires after
 * `onKeyPress` and `onCompositionEnd`, but before `onInput`.
 *
 * `beforeInput` is spec'd but not implemented in any browsers, and
 * the `input` event does not provide any useful information about what has
 * actually been added, contrary to the spec. Thus, `textInput` is the best
 * available event to identify the characters that have actually been inserted
 * into the target node.
 *
 * This plugin is also responsible for emitting `composition` events, thus
 * allowing us to share composition fallback code for both `beforeInput` and
 * `composition` event types.
 */
var BeforeInputEventPlugin = {
  eventTypes: eventTypes,

  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
    return [extractCompositionEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget), extractBeforeInputEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget)];
  }
};

module.exports = BeforeInputEventPlugin;
},{"./EventPropagators":549,"./FallbackCompositionState":550,"./SyntheticCompositionEvent":614,"./SyntheticInputEvent":618,"fbjs/lib/ExecutionEnvironment":388}],534:[function(require,module,exports){
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */

'use strict';

/**
 * CSS properties which accept numbers but are not in units of "px".
 */

var isUnitlessNumber = {
  animationIterationCount: true,
  borderImageOutset: true,
  borderImageSlice: true,
  borderImageWidth: true,
  boxFlex: true,
  boxFlexGroup: true,
  boxOrdinalGroup: true,
  columnCount: true,
  columns: true,
  flex: true,
  flexGrow: true,
  flexPositive: true,
  flexShrink: true,
  flexNegative: true,
  flexOrder: true,
  gridRow: true,
  gridRowEnd: true,
  gridRowSpan: true,
  gridRowStart: true,
  gridColumn: true,
  gridColumnEnd: true,
  gridColumnSpan: true,
  gridColumnStart: true,
  fontWeight: true,
  lineClamp: true,
  lineHeight: true,
  opacity: true,
  order: true,
  orphans: true,
  tabSize: true,
  widows: true,
  zIndex: true,
  zoom: true,

  // SVG-related properties
  fillOpacity: true,
  floodOpacity: true,
  stopOpacity: true,
  strokeDasharray: true,
  strokeDashoffset: true,
  strokeMiterlimit: true,
  strokeOpacity: true,
  strokeWidth: true
};

/**
 * @param {string} prefix vendor-specific prefix, eg: Webkit
 * @param {string} key style name, eg: transitionDuration
 * @return {string} style name prefixed with `prefix`, properly camelCased, eg:
 * WebkitTransitionDuration
 */
function prefixKey(prefix, key) {
  return prefix + key.charAt(0).toUpperCase() + key.substring(1);
}

/**
 * Support style names that may come passed in prefixed by adding permutations
 * of vendor prefixes.
 */
var prefixes = ['Webkit', 'ms', 'Moz', 'O'];

// Using Object.keys here, or else the vanilla for-in loop makes IE8 go into an
// infinite loop, because it iterates over the newly added props too.
Object.keys(isUnitlessNumber).forEach(function (prop) {
  prefixes.forEach(function (prefix) {
    isUnitlessNumber[prefixKey(prefix, prop)] = isUnitlessNumber[prop];
  });
});

/**
 * Most style properties can be unset by doing .style[prop] = '' but IE8
 * doesn't like doing that with shorthand properties so for the properties that
 * IE8 breaks on, which are listed here, we instead unset each of the
 * individual properties. See http://bugs.jquery.com/ticket/12385.
 * The 4-value 'clock' properties like margin, padding, border-width seem to
 * behave without any problems. Curiously, list-style works too without any
 * special prodding.
 */
var shorthandPropertyExpansions = {
  background: {
    backgroundAttachment: true,
    backgroundColor: true,
    backgroundImage: true,
    backgroundPositionX: true,
    backgroundPositionY: true,
    backgroundRepeat: true
  },
  backgroundPosition: {
    backgroundPositionX: true,
    backgroundPositionY: true
  },
  border: {
    borderWidth: true,
    borderStyle: true,
    borderColor: true
  },
  borderBottom: {
    borderBottomWidth: true,
    borderBottomStyle: true,
    borderBottomColor: true
  },
  borderLeft: {
    borderLeftWidth: true,
    borderLeftStyle: true,
    borderLeftColor: true
  },
  borderRight: {
    borderRightWidth: true,
    borderRightStyle: true,
    borderRightColor: true
  },
  borderTop: {
    borderTopWidth: true,
    borderTopStyle: true,
    borderTopColor: true
  },
  font: {
    fontStyle: true,
    fontVariant: true,
    fontWeight: true,
    fontSize: true,
    lineHeight: true,
    fontFamily: true
  },
  outline: {
    outlineWidth: true,
    outlineStyle: true,
    outlineColor: true
  }
};

var CSSProperty = {
  isUnitlessNumber: isUnitlessNumber,
  shorthandPropertyExpansions: shorthandPropertyExpansions
};

module.exports = CSSProperty;
},{}],535:[function(require,module,exports){
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */

'use strict';

var CSSProperty = require('./CSSProperty');
var ExecutionEnvironment = require('fbjs/lib/ExecutionEnvironment');
var ReactInstrumentation = require('./ReactInstrumentation');

var camelizeStyleName = require('fbjs/lib/camelizeStyleName');
var dangerousStyleValue = require('./dangerousStyleValue');
var hyphenateStyleName = require('fbjs/lib/hyphenateStyleName');
var memoizeStringOnly = require('fbjs/lib/memoizeStringOnly');
var warning = require('fbjs/lib/warning');

var processStyleName = memoizeStringOnly(function (styleName) {
  return hyphenateStyleName(styleName);
});

var hasShorthandPropertyBug = false;
var styleFloatAccessor = 'cssFloat';
if (ExecutionEnvironment.canUseDOM) {
  var tempStyle = document.createElement('div').style;
  try {
    // IE8 throws "Invalid argument." if resetting shorthand style properties.
    tempStyle.font = '';
  } catch (e) {
    hasShorthandPropertyBug = true;
  }
  // IE8 only supports accessing cssFloat (standard) as styleFloat
  if (document.documentElement.style.cssFloat === undefined) {
    styleFloatAccessor = 'styleFloat';
  }
}

if ("production" !== 'production') {
  // 'msTransform' is correct, but the other prefixes should be capitalized
  var badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/;

  // style values shouldn't contain a semicolon
  var badStyleValueWithSemicolonPattern = /;\s*$/;

  var warnedStyleNames = {};
  var warnedStyleValues = {};
  var warnedForNaNValue = false;

  var warnHyphenatedStyleName = function (name, owner) {
    if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
      return;
    }

    warnedStyleNames[name] = true;
    "production" !== 'production' ? warning(false, 'Unsupported style property %s. Did you mean %s?%s', name, camelizeStyleName(name), checkRenderMessage(owner)) : void 0;
  };

  var warnBadVendoredStyleName = function (name, owner) {
    if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
      return;
    }

    warnedStyleNames[name] = true;
    "production" !== 'production' ? warning(false, 'Unsupported vendor-prefixed style property %s. Did you mean %s?%s', name, name.charAt(0).toUpperCase() + name.slice(1), checkRenderMessage(owner)) : void 0;
  };

  var warnStyleValueWithSemicolon = function (name, value, owner) {
    if (warnedStyleValues.hasOwnProperty(value) && warnedStyleValues[value]) {
      return;
    }

    warnedStyleValues[value] = true;
    "production" !== 'production' ? warning(false, "Style property values shouldn't contain a semicolon.%s " + 'Try "%s: %s" instead.', checkRenderMessage(owner), name, value.replace(badStyleValueWithSemicolonPattern, '')) : void 0;
  };

  var warnStyleValueIsNaN = function (name, value, owner) {
    if (warnedForNaNValue) {
      return;
    }

    warnedForNaNValue = true;
    "production" !== 'production' ? warning(false, '`NaN` is an invalid value for the `%s` css style property.%s', name, checkRenderMessage(owner)) : void 0;
  };

  var checkRenderMessage = function (owner) {
    if (owner) {
      var name = owner.getName();
      if (name) {
        return ' Check the render method of `' + name + '`.';
      }
    }
    return '';
  };

  /**
   * @param {string} name
   * @param {*} value
   * @param {ReactDOMComponent} component
   */
  var warnValidStyle = function (name, value, component) {
    var owner;
    if (component) {
      owner = component._currentElement._owner;
    }
    if (name.indexOf('-') > -1) {
      warnHyphenatedStyleName(name, owner);
    } else if (badVendoredStyleNamePattern.test(name)) {
      warnBadVendoredStyleName(name, owner);
    } else if (badStyleValueWithSemicolonPattern.test(value)) {
      warnStyleValueWithSemicolon(name, value, owner);
    }

    if (typeof value === 'number' && isNaN(value)) {
      warnStyleValueIsNaN(name, value, owner);
    }
  };
}

/**
 * Operations for dealing with CSS properties.
 */
var CSSPropertyOperations = {
  /**
   * Serializes a mapping of style properties for use as inline styles:
   *
   *   > createMarkupForStyles({width: '200px', height: 0})
   *   "width:200px;height:0;"
   *
   * Undefined values are ignored so that declarative programming is easier.
   * The result should be HTML-escaped before insertion into the DOM.
   *
   * @param {object} styles
   * @param {ReactDOMComponent} component
   * @return {?string}
   */
  createMarkupForStyles: function (styles, component) {
    var serialized = '';
    for (var styleName in styles) {
      if (!styles.hasOwnProperty(styleName)) {
        continue;
      }
      var isCustomProperty = styleName.indexOf('--') === 0;
      var styleValue = styles[styleName];
      if ("production" !== 'production') {
        if (!isCustomProperty) {
          warnValidStyle(styleName, styleValue, component);
        }
      }
      if (styleValue != null) {
        serialized += processStyleName(styleName) + ':';
        serialized += dangerousStyleValue(styleName, styleValue, component, isCustomProperty) + ';';
      }
    }
    return serialized || null;
  },

  /**
   * Sets the value for multiple styles on a node.  If a value is specified as
   * '' (empty string), the corresponding style property will be unset.
   *
   * @param {DOMElement} node
   * @param {object} styles
   * @param {ReactDOMComponent} component
   */
  setValueForStyles: function (node, styles, component) {
    if ("production" !== 'production') {
      ReactInstrumentation.debugTool.onHostOperation({
        instanceID: component._debugID,
        type: 'update styles',
        payload: styles
      });
    }

    var style = node.style;
    for (var styleName in styles) {
      if (!styles.hasOwnProperty(styleName)) {
        continue;
      }
      var isCustomProperty = styleName.indexOf('--') === 0;
      if ("production" !== 'production') {
        if (!isCustomProperty) {
          warnValidStyle(styleName, styles[styleName], component);
        }
      }
      var styleValue = dangerousStyleValue(styleName, styles[styleName], component, isCustomProperty);
      if (styleName === 'float' || styleName === 'cssFloat') {
        styleName = styleFloatAccessor;
      }
      if (isCustomProperty) {
        style.setProperty(styleName, styleValue);
      } else if (styleValue) {
        style[styleName] = styleValue;
      } else {
        var expansion = hasShorthandPropertyBug && CSSProperty.shorthandPropertyExpansions[styleName];
        if (expansion) {
          // Shorthand property that IE8 won't like unsetting, so unset each
          // component to placate it
          for (var individualStyleName in expansion) {
            style[individualStyleName] = '';
          }
        } else {
          style[styleName] = '';
        }
      }
    }
  }
};

module.exports = CSSPropertyOperations;
},{"./CSSProperty":534,"./ReactInstrumentation":592,"./dangerousStyleValue":631,"fbjs/lib/ExecutionEnvironment":388,"fbjs/lib/camelizeStyleName":390,"fbjs/lib/hyphenateStyleName":401,"fbjs/lib/memoizeStringOnly":405,"fbjs/lib/warning":409}],536:[function(require,module,exports){
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

'use strict';

var _prodInvariant = require('./reactProdInvariant');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var PooledClass = require('./PooledClass');

var invariant = require('fbjs/lib/invariant');

/**
 * A specialized pseudo-event module to help keep track of components waiting to
 * be notified when their DOM representations are available for use.
 *
 * This implements `PooledClass`, so you should never need to instantiate this.
 * Instead, use `CallbackQueue.getPooled()`.
 *
 * @class ReactMountReady
 * @implements PooledClass
 * @internal
 */

var CallbackQueue = function () {
  function CallbackQueue(arg) {
    _classCallCheck(this, CallbackQueue);

    this._callbacks = null;
    this._contexts = null;
    this._arg = arg;
  }

  /**
   * Enqueues a callback to be invoked when `notifyAll` is invoked.
   *
   * @param {function} callback Invoked when `notifyAll` is invoked.
   * @param {?object} context Context to call `callback` with.
   * @internal
   */


  CallbackQueue.prototype.enqueue = function enqueue(callback, context) {
    this._callbacks = this._callbacks || [];
    this._callbacks.push(callback);
    this._contexts = this._contexts || [];
    this._contexts.push(context);
  };

  /**
   * Invokes all enqueued callbacks and clears the queue. This is invoked after
   * the DOM representation of a component has been created or updated.
   *
   * @internal
   */


  CallbackQueue.prototype.notifyAll = function notifyAll() {
    var callbacks = this._callbacks;
    var contexts = this._contexts;
    var arg = this._arg;
    if (callbacks && contexts) {
      !(callbacks.length === contexts.length) ? "production" !== 'production' ? invariant(false, 'Mismatched list of contexts in callback queue') : _prodInvariant('24') : void 0;
      this._callbacks = null;
      this._contexts = null;
      for (var i = 0; i < callbacks.length; i++) {
        callbacks[i].call(contexts[i], arg);
      }
      callbacks.length = 0;
      contexts.length = 0;
    }
  };

  CallbackQueue.prototype.checkpoint = function checkpoint() {
    return this._callbacks ? this._callbacks.length : 0;
  };

  CallbackQueue.prototype.rollback = function rollback(len) {
    if (this._callbacks && this._contexts) {
      this._callbacks.length = len;
      this._contexts.length = len;
    }
  };

  /**
   * Resets the internal queue.
   *
   * @internal
   */


  CallbackQueue.prototype.reset = function reset() {
    this._callbacks = null;
    this._contexts = null;
  };

  /**
   * `PooledClass` looks for this.
   */


  CallbackQueue.prototype.destructor = function destructor() {
    this.reset();
  };

  return CallbackQueue;
}();

module.exports = PooledClass.addPoolingTo(CallbackQueue);
},{"./PooledClass":554,"./reactProdInvariant":650,"fbjs/lib/invariant":402}],537:[function(require,module,exports){
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */

'use strict';

var EventPluginHub = require('./EventPluginHub');
var EventPropagators = require('./EventPropagators');
var ExecutionEnvironment = require('fbjs/lib/ExecutionEnvironment');
var ReactDOMComponentTree = require('./ReactDOMComponentTree');
var ReactUpdates = require('./ReactUpdates');
var SyntheticEvent = require('./SyntheticEvent');

var inputValueTracking = require('./inputValueTracking');
var getEventTarget = require('./getEventTarget');
var isEventSupported = require('./isEventSupported');
var isTextInputElement = require('./isTextInputElement');

var eventTypes = {
  change: {
    phasedRegistrationNames: {
      bubbled: 'onChange',
      captured: 'onChangeCapture'
    },
    dependencies: ['topBlur', 'topChange', 'topClick', 'topFocus', 'topInput', 'topKeyDown', 'topKeyUp', 'topSelectionChange']
  }
};

function createAndAccumulateChangeEvent(inst, nativeEvent, target) {
  var event = SyntheticEvent.getPooled(eventTypes.change, inst, nativeEvent, target);
  event.type = 'change';
  EventPropagators.accumulateTwoPhaseDispatches(event);
  return event;
}
/**
 * For IE shims
 */
var activeElement = null;
var activeElementInst = null;

/**
 * SECTION: handle `change` event
 */
function shouldUseChangeEvent(elem) {
  var nodeName = elem.nodeName && elem.nodeName.toLowerCase();
  return nodeName === 'select' || nodeName === 'input' && elem.type === 'file';
}

var doesChangeEventBubble = false;
if (ExecutionEnvironment.canUseDOM) {
  // See `handleChange` comment below
  doesChangeEventBubble = isEventSupported('change') && (!document.documentMode || document.documentMode > 8);
}

function manualDispatchChangeEvent(nativeEvent) {
  var event = createAndAccumulateChangeEvent(activeElementInst, nativeEvent, getEventTarget(nativeEvent));

  // If change and propertychange bubbled, we'd just bind to it like all the
  // other events and have it go through ReactBrowserEventEmitter. Since it
  // doesn't, we manually listen for the events and so we have to enqueue and
  // process the abstract event manually.
  //
  // Batching is necessary here in order to ensure that all event handlers run
  // before the next rerender (including event handlers attached to ancestor
  // elements instead of directly on the input). Without this, controlled
  // components don't work properly in conjunction with event bubbling because
  // the component is rerendered and the value reverted before all the event
  // handlers can run. See https://github.com/facebook/react/issues/708.
  ReactUpdates.batchedUpdates(runEventInBatch, event);
}

function runEventInBatch(event) {
  EventPluginHub.enqueueEvents(event);
  EventPluginHub.processEventQueue(false);
}

function startWatchingForChangeEventIE8(target, targetInst) {
  activeElement = target;
  activeElementInst = targetInst;
  activeElement.attachEvent('onchange', manualDispatchChangeEvent);
}

function stopWatchingForChangeEventIE8() {
  if (!activeElement) {
    return;
  }
  activeElement.detachEvent('onchange', manualDispatchChangeEvent);
  activeElement = null;
  activeElementInst = null;
}

function getInstIfValueChanged(targetInst, nativeEvent) {
  var updated = inputValueTracking.updateValueIfChanged(targetInst);
  var simulated = nativeEvent.simulated === true && ChangeEventPlugin._allowSimulatedPassThrough;

  if (updated || simulated) {
    return targetInst;
  }
}

function getTargetInstForChangeEvent(topLevelType, targetInst) {
  if (topLevelType === 'topChange') {
    return targetInst;
  }
}

function handleEventsForChangeEventIE8(topLevelType, target, targetInst) {
  if (topLevelType === 'topFocus') {
    // stopWatching() should be a noop here but we call it just in case we
    // missed a blur event somehow.
    stopWatchingForChangeEventIE8();
    startWatchingForChangeEventIE8(target, targetInst);
  } else if (topLevelType === 'topBlur') {
    stopWatchingForChangeEventIE8();
  }
}

/**
 * SECTION: handle `input` event
 */
var isInputEventSupported = false;
if (ExecutionEnvironment.canUseDOM) {
  // IE9 claims to support the input event but fails to trigger it when
  // deleting text, so we ignore its input events.

  isInputEventSupported = isEventSupported('input') && (!document.documentMode || document.documentMode > 9);
}

/**
 * (For IE <=9) Starts tracking propertychange events on the passed-in element
 * and override the value property so that we can distinguish user events from
 * value changes in JS.
 */
function startWatchingForValueChange(target, targetInst) {
  activeElement = target;
  activeElementInst = targetInst;
  activeElement.attachEvent('onpropertychange', handlePropertyChange);
}

/**
 * (For IE <=9) Removes the event listeners from the currently-tracked element,
 * if any exists.
 */
function stopWatchingForValueChange() {
  if (!activeElement) {
    return;
  }
  activeElement.detachEvent('onpropertychange', handlePropertyChange);

  activeElement = null;
  activeElementInst = null;
}

/**
 * (For IE <=9) Handles a propertychange event, sending a `change` event if
 * the value of the active element has changed.
 */
function handlePropertyChange(nativeEvent) {
  if (nativeEvent.propertyName !== 'value') {
    return;
  }
  if (getInstIfValueChanged(activeElementInst, nativeEvent)) {
    manualDispatchChangeEvent(nativeEvent);
  }
}

function handleEventsForInputEventPolyfill(topLevelType, target, targetInst) {
  if (topLevelType === 'topFocus') {
    // In IE8, we can capture almost all .value changes by adding a
    // propertychange handler and looking for events with propertyName
    // equal to 'value'
    // In IE9, propertychange fires for most input events but is buggy and
    // doesn't fire when text is deleted, but conveniently, selectionchange
    // appears to fire in all of the remaining cases so we catch those and
    // forward the event if the value has changed
    // In either case, we don't want to call the event handler if the value
    // is changed from JS so we redefine a setter for `.value` that updates
    // our activeElementValue variable, allowing us to ignore those changes
    //
    // stopWatching() should be a noop here but we call it just in case we
    // missed a blur event somehow.
    stopWatchingForValueChange();
    startWatchingForValueChange(target, targetInst);
  } else if (topLevelType === 'topBlur') {
    stopWatchingForValueChange();
  }
}

// For IE8 and IE9.
function getTargetInstForInputEventPolyfill(topLevelType, targetInst, nativeEvent) {
  if (topLevelType === 'topSelectionChange' || topLevelType === 'topKeyUp' || topLevelType === 'topKeyDown') {
    // On the selectionchange event, the target is just document which isn't
    // helpful for us so just check activeElement instead.
    //
    // 99% of the time, keydown and keyup aren't necessary. IE8 fails to fire
    // propertychange on the first input event after setting `value` from a
    // script and fires only keydown, keypress, keyup. Catching keyup usually
    // gets it and catching keydown lets us fire an event for the first
    // keystroke if user does a key repeat (it'll be a little delayed: right
    // before the second keystroke). Other input methods (e.g., paste) seem to
    // fire selectionchange normally.
    return getInstIfValueChanged(activeElementInst, nativeEvent);
  }
}

/**
 * SECTION: handle `click` event
 */
function shouldUseClickEvent(elem) {
  // Use the `click` event to detect changes to checkbox and radio inputs.
  // This approach works across all browsers, whereas `change` does not fire
  // until `blur` in IE8.
  var nodeName = elem.nodeName;
  return nodeName && nodeName.toLowerCase() === 'input' && (elem.type === 'checkbox' || elem.type === 'radio');
}

function getTargetInstForClickEvent(topLevelType, targetInst, nativeEvent) {
  if (topLevelType === 'topClick') {
    return getInstIfValueChanged(targetInst, nativeEvent);
  }
}

function getTargetInstForInputOrChangeEvent(topLevelType, targetInst, nativeEvent) {
  if (topLevelType === 'topInput' || topLevelType === 'topChange') {
    return getInstIfValueChanged(targetInst, nativeEvent);
  }
}

function handleControlledInputBlur(inst, node) {
  // TODO: In IE, inst is occasionally null. Why?
  if (inst == null) {
    return;
  }

  // Fiber and ReactDOM keep wrapper state in separate places
  var state = inst._wrapperState || node._wrapperState;

  if (!state || !state.controlled || node.type !== 'number') {
    return;
  }

  // If controlled, assign the value attribute to the current value on blur
  var value = '' + node.value;
  if (node.getAttribute('value') !== value) {
    node.setAttribute('value', value);
  }
}

/**
 * This plugin creates an `onChange` event that normalizes change events
 * across form elements. This event fires at a time when it's possible to
 * change the element's value without seeing a flicker.
 *
 * Supported elements are:
 * - input (see `isTextInputElement`)
 * - textarea
 * - select
 */
var ChangeEventPlugin = {
  eventTypes: eventTypes,

  _allowSimulatedPassThrough: true,
  _isInputEventSupported: isInputEventSupported,

  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
    var targetNode = targetInst ? ReactDOMComponentTree.getNodeFromInstance(targetInst) : window;

    var getTargetInstFunc, handleEventFunc;
    if (shouldUseChangeEvent(targetNode)) {
      if (doesChangeEventBubble) {
        getTargetInstFunc = getTargetInstForChangeEvent;
      } else {
        handleEventFunc = handleEventsForChangeEventIE8;
      }
    } else if (isTextInputElement(targetNode)) {
      if (isInputEventSupported) {
        getTargetInstFunc = getTargetInstForInputOrChangeEvent;
      } else {
        getTargetInstFunc = getTargetInstForInputEventPolyfill;
        handleEventFunc = handleEventsForInputEventPolyfill;
      }
    } else if (shouldUseClickEvent(targetNode)) {
      getTargetInstFunc = getTargetInstForClickEvent;
    }

    if (getTargetInstFunc) {
      var inst = getTargetInstFunc(topLevelType, targetInst, nativeEvent);
      if (inst) {
        var event = createAndAccumulateChangeEvent(inst, nativeEvent, nativeEventTarget);
        return event;
      }
    }

    if (handleEventFunc) {
      handleEventFunc(topLevelType, targetNode, targetInst);
    }

    // When blurring, set the value attribute for number inputs
    if (topLevelType === 'topBlur') {
      handleControlledInputBlur(targetInst, targetNode);
    }
  }
};

module.exports = ChangeEventPlugin;
},{"./EventPluginHub":546,"./EventPropagators":549,"./ReactDOMComponentTree":563,"./ReactUpdates":607,"./SyntheticEvent":616,"./getEventTarget":639,"./inputValueTracking":645,"./isEventSupported":647,"./isTextInputElement":648,"fbjs/lib/ExecutionEnvironment":388}],538:[function(require,module,exports){
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */

'use strict';

var DOMLazyTree = require('./DOMLazyTree');
var Danger = require('./Danger');
var ReactDOMComponentTree = require('./ReactDOMComponentTree');
var ReactInstrumentation = require('./ReactInstrumentation');

var createMicrosoftUnsafeLocalFunction = require('./createMicrosoftUnsafeLocalFunction');
var setInnerHTML = require('./setInnerHTML');
var setTextContent = require('./setTextContent');

function getNodeAfter(parentNode, node) {
  // Special case for text components, which return [open, close] comments
  // from getHostNode.
  if (Array.isArray(node)) {
    node = node[1];
  }
  return node ? node.nextSibling : parentNode.firstChild;
}

/**
 * Inserts `childNode` as a child of `parentNode` at the `index`.
 *
 * @param {DOMElement} parentNode Parent node in which to insert.
 * @param {DOMElement} childNode Child node to insert.
 * @param {number} index Index at which to insert the child.
 * @internal
 */
var insertChildAt = createMicrosoftUnsafeLocalFunction(function (parentNode, childNode, referenceNode) {
  // We rely exclusively on `insertBefore(node, null)` instead of also using
  // `appendChild(node)`. (Using `undefined` is not allowed by all browsers so
  // we are careful to use `null`.)
  parentNode.insertBefore(childNode, referenceNode);
});

function insertLazyTreeChildAt(parentNode, childTree, referenceNode) {
  DOMLazyTree.insertTreeBefore(parentNode, childTree, referenceNode);
}

function moveChild(parentNode, childNode, referenceNode) {
  if (Array.isArray(childNode)) {
    moveDelimitedText(parentNode, childNode[0], childNode[1], referenceNode);
  } else {
    insertChildAt(parentNode, childNode, referenceNode);
  }
}

function removeChild(parentNode, childNode) {
  if (Array.isArray(childNode)) {
    var closingComment = childNode[1];
    childNode = childNode[0];
    removeDelimitedText(parentNode, childNode, closingComment);
    parentNode.removeChild(closingComment);
  }
  parentNode.removeChild(childNode);
}

function moveDelimitedText(parentNode, openingComment, closingComment, referenceNode) {
  var node = openingComment;
  while (true) {
    var nextNode = node.nextSibling;
    insertChildAt(parentNode, node, referenceNode);
    if (node === closingComment) {
      break;
    }
    node = nextNode;
  }
}

function removeDelimitedText(parentNode, startNode, closingComment) {
  while (true) {
    var node = startNode.nextSibling;
    if (node === closingComment) {
      // The closing comment is removed by ReactMultiChild.
      break;
    } else {
      parentNode.removeChild(node);
    }
  }
}

function replaceDelimitedText(openingComment, closingComment, stringText) {
  var parentNode = openingComment.parentNode;
  var nodeAfterComment = openingComment.nextSibling;
  if (nodeAfterComment === closingComment) {
    // There are no text nodes between the opening and closing comments; insert
    // a new one if stringText isn't empty.
    if (stringText) {
      insertChildAt(parentNode, document.createTextNode(stringText), nodeAfterComment);
    }
  } else {
    if (stringText) {
      // Set the text content of the first node after the opening comment, and
      // remove all following nodes up until the closing comment.
      setTextContent(nodeAfterComment, stringText);
      removeDelimitedText(parentNode, nodeAfterComment, closingComment);
    } else {
      removeDelimitedText(parentNode, openingComment, closingComment);
    }
  }

  if ("production" !== 'production') {
    ReactInstrumentation.debugTool.onHostOperation({
      instanceID: ReactDOMComponentTree.getInstanceFromNode(openingComment)._debugID,
      type: 'replace text',
      payload: stringText
    });
  }
}

var dangerouslyReplaceNodeWithMarkup = Danger.dangerouslyReplaceNodeWithMarkup;
if ("production" !== 'production') {
  dangerouslyReplaceNodeWithMarkup = function (oldChild, markup, prevInstance) {
    Danger.dangerouslyReplaceNodeWithMarkup(oldChild, markup);
    if (prevInstance._debugID !== 0) {
      ReactInstrumentation.debugTool.onHostOperation({
        instanceID: prevInstance._debugID,
        type: 'replace with',
        payload: markup.toString()
      });
    } else {
      var nextInstance = ReactDOMComponentTree.getInstanceFromNode(markup.node);
      if (nextInstance._debugID !== 0) {
        ReactInstrumentation.debugTool.onHostOperation({
          instanceID: nextInstance._debugID,
          type: 'mount',
          payload: markup.toString()
        });
      }
    }
  };
}

/**
 * Operations for updating with DOM children.
 */
var DOMChildrenOperations = {
  dangerouslyReplaceNodeWithMarkup: dangerouslyReplaceNodeWithMarkup,

  replaceDelimitedText: replaceDelimitedText,

  /**
   * Updates a component's children by processing a series of updates. The
   * update configurations are each expected to have a `parentNode` property.
   *
   * @param {array<object>} updates List of update configurations.
   * @internal
   */
  processUpdates: function (parentNode, updates) {
    if ("production" !== 'production') {
      var parentNodeDebugID = ReactDOMComponentTree.getInstanceFromNode(parentNode)._debugID;
    }

    for (var k = 0; k < updates.length; k++) {
      var update = updates[k];
      switch (update.type) {
        case 'INSERT_MARKUP':
          insertLazyTreeChildAt(parentNode, update.content, getNodeAfter(parentNode, update.afterNode));
          if ("production" !== 'production') {
            ReactInstrumentation.debugTool.onHostOperation({
              instanceID: parentNodeDebugID,
              type: 'insert child',
              payload: {
                toIndex: update.toIndex,
                content: update.content.toString()
              }
            });
          }
          break;
        case 'MOVE_EXISTING':
          moveChild(parentNode, update.fromNode, getNodeAfter(parentNode, update.afterNode));
          if ("production" !== 'production') {
            ReactInstrumentation.debugTool.onHostOperation({
              instanceID: parentNodeDebugID,
              type: 'move child',
              payload: { fromIndex: update.fromIndex, toIndex: update.toIndex }
            });
          }
          break;
        case 'SET_MARKUP':
          setInnerHTML(parentNode, update.content);
          if ("production" !== 'production') {
            ReactInstrumentation.debugTool.onHostOperation({
              instanceID: parentNodeDebugID,
              type: 'replace children',
              payload: update.content.toString()
            });
          }
          break;
        case 'TEXT_CONTENT':
          setTextContent(parentNode, update.content);
          if ("production" !== 'production') {
            ReactInstrumentation.debugTool.onHostOperation({
              instanceID: parentNodeDebugID,
              type: 'replace text',
              payload: update.content.toString()
            });
          }
          break;
        case 'REMOVE_NODE':
          removeChild(parentNode, update.fromNode);
          if ("production" !== 'production') {
            ReactInstrumentation.debugTool.onHostOperation({
              instanceID: parentNodeDebugID,
              type: 'remove child',
              payload: { fromIndex: update.fromIndex }
            });
          }
          break;
      }
    }
  }
};

module.exports = DOMChildrenOperations;
},{"./DOMLazyTree":539,"./Danger":543,"./ReactDOMComponentTree":563,"./ReactInstrumentation":592,"./createMicrosoftUnsafeLocalFunction":630,"./setInnerHTML":652,"./setTextContent":653}],539:[function(require,module,exports){
/**
 * Copyright (c) 2015-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */

'use strict';

var DOMNamespaces = require('./DOMNamespaces');
var setInnerHTML = require('./setInnerHTML');

var createMicrosoftUnsafeLocalFunction = require('./createMicrosoftUnsafeLocalFunction');
var setTextContent = require('./setTextContent');

var ELEMENT_NODE_TYPE = 1;
var DOCUMENT_FRAGMENT_NODE_TYPE = 11;

/**
 * In IE (8-11) and Edge, appending nodes with no children is dramatically
 * faster than appending a full subtree, so we essentially queue up the
 * .appendChild calls here and apply them so each node is added to its parent
 * before any children are added.
 *
 * In other browsers, doing so is slower or neutral compared to the other order
 * (in Firefox, twice as slow) so we only do this inversion in IE.
 *
 * See https://github.com/spicyj/innerhtml-vs-createelement-vs-clonenode.
 */
var enableLazy = typeof document !== 'undefined' && typeof document.documentMode === 'number' || typeof navigator !== 'undefined' && typeof navigator.userAgent === 'string' && /\bEdge\/\d/.test(navigator.userAgent);

function insertTreeChildren(tree) {
  if (!enableLazy) {
    return;
  }
  var node = tree.node;
  var children = tree.children;
  if (children.length) {
    for (var i = 0; i < children.length; i++) {
      insertTreeBefore(node, children[i], null);
    }
  } else if (tree.html != null) {
    setInnerHTML(node, tree.html);
  } else if (tree.text != null) {
    setTextContent(node, tree.text);
  }
}

var insertTreeBefore = createMicrosoftUnsafeLocalFunction(function (parentNode, tree, referenceNode) {
  // DocumentFragments aren't actually part of the DOM after insertion so
  // appending children won't update the DOM. We need to ensure the fragment
  // is properly populated first, breaking out of our lazy approach for just
  // this level. Also, some <object> plugins (like Flash Player) will read
  // <param> nodes immediately upon insertion into the DOM, so <object>
  // must also be populated prior to insertion into the DOM.
  if (tree.node.nodeType === DOCUMENT_FRAGMENT_NODE_TYPE || tree.node.nodeType === ELEMENT_NODE_TYPE && tree.node.nodeName.toLowerCase() === 'object' && (tree.node.namespaceURI == null || tree.node.namespaceURI === DOMNamespaces.html)) {
    insertTreeChildren(tree);
    parentNode.insertBefore(tree.node, referenceNode);
  } else {
    parentNode.insertBefore(tree.node, referenceNode);
    insertTreeChildren(tree);
  }
});

function replaceChildWithTree(oldNode, newTree) {
  oldNode.parentNode.replaceChild(newTree.node, oldNode);
  insertTreeChildren(newTree);
}

function queueChild(parentTree, childTree) {
  if (enableLazy) {
    parentTree.children.push(childTree);
  } else {
    parentTree.node.appendChild(childTree.node);
  }
}

function queueHTML(tree, html) {
  if (enableLazy) {
    tree.html = html;
  } else {
    setInnerHTML(tree.node, html);
  }
}

function queueText(tree, text) {
  if (enableLazy) {
    tree.text = text;
  } else {
    setTextContent(tree.node, text);
  }
}

function toString() {
  return this.node.nodeName;
}

function DOMLazyTree(node) {
  return {
    node: node,
    children: [],
    html: null,
    text: null,
    toString: toString
  };
}

DOMLazyTree.insertTreeBefore = insertTreeBefore;
DOMLazyTree.replaceChildWithTree = replaceChildWithTree;
DOMLazyTree.queueChild = queueChild;
DOMLazyTree.queueHTML = queueHTML;
DOMLazyTree.queueText = queueText;

module.exports = DOMLazyTree;
},{"./DOMNamespaces":540,"./createMicrosoftUnsafeLocalFunction":630,"./setInnerHTML":652,"./setTextContent":653}],540:[function(require,module,exports){
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */

'use strict';

var DOMNamespaces = {
  html: 'http://www.w3.org/1999/xhtml',
  mathml: 'http://www.w3.org/1998/Math/MathML',
  svg: 'http://www.w3.org/2000/svg'
};

module.exports = DOMNamespaces;
},{}],541:[function(require,module,exports){
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */

'use strict';

var _prodInvariant = require('./reactProdInvariant');

var invariant = require('fbjs/lib/invariant');

function checkMask(value, bitmask) {
  return (value & bitmask) === bitmask;
}

var DOMPropertyInjection = {
  /**
   * Mapping from normalized, camelcased property names to a configuration that
   * specifies how the associated DOM property should be accessed or rendered.
   */
  MUST_USE_PROPERTY: 0x1,
  HAS_BOOLEAN_VALUE: 0x4,
  HAS_NUMERIC_VALUE: 0x8,
  HAS_POSITIVE_NUMERIC_VALUE: 0x10 | 0x8,
  HAS_OVERLOADED_BOOLEAN_VALUE: 0x20,

  /**
   * Inject some specialized knowledge about the DOM. This takes a config object
   * with the following properties:
   *
   * isCustomAttribute: function that given an attribute name will return true
   * if it can be inserted into the DOM verbatim. Useful for data-* or aria-*
   * attributes where it's impossible to enumerate all of the possible
   * attribute names,
   *
   * Properties: object mapping DOM property name to one of the
   * DOMPropertyInjection constants or null. If your attribute isn't in here,
   * it won't get written to the DOM.
   *
   * DOMAttributeNames: object mapping React attribute name to the DOM
   * attribute name. Attribute names not specified use the **lowercase**
   * normalized name.
   *
   * DOMAttributeNamespaces: object mapping React attribute name to the DOM
   * attribute namespace URL. (Attribute names not specified use no namespace.)
   *
   * DOMPropertyNames: similar to DOMAttributeNames but for DOM properties.
   * Property names not specified use the normalized name.
   *
   * DOMMutationMethods: Properties that require special mutation methods. If
   * `value` is undefined, the mutation method should unset the property.
   *
   * @param {object} domPropertyConfig the config as described above.
   */
  injectDOMPropertyConfig: function (domPropertyConfig) {
    var Injection = DOMPropertyInjection;
    var Properties = domPropertyConfig.Properties || {};
    var DOMAttributeNamespaces = domPropertyConfig.DOMAttributeNamespaces || {};
    var DOMAttributeNames = domPropertyConfig.DOMAttributeNames || {};
    var DOMPropertyNames = domPropertyConfig.DOMPropertyNames || {};
    var DOMMutationMethods = domPropertyConfig.DOMMutationMethods || {};

    if (domPropertyConfig.isCustomAttribute) {
      DOMProperty._isCustomAttributeFunctions.push(domPropertyConfig.isCustomAttribute);
    }

    for (var propName in Properties) {
      !!DOMProperty.properties.hasOwnProperty(propName) ? "production" !== 'production' ? invariant(false, 'injectDOMPropertyConfig(...): You\'re trying to inject DOM property \'%s\' which has already been injected. You may be accidentally injecting the same DOM property config twice, or you may be injecting two configs that have conflicting property names.', propName) : _prodInvariant('48', propName) : void 0;

      var lowerCased = propName.toLowerCase();
      var propConfig = Properties[propName];

      var propertyInfo = {
        attributeName: lowerCased,
        attributeNamespace: null,
        propertyName: propName,
        mutationMethod: null,

        mustUseProperty: checkMask(propConfig, Injection.MUST_USE_PROPERTY),
        hasBooleanValue: checkMask(propConfig, Injection.HAS_BOOLEAN_VALUE),
        hasNumericValue: checkMask(propConfig, Injection.HAS_NUMERIC_VALUE),
        hasPositiveNumericValue: checkMask(propConfig, Injection.HAS_POSITIVE_NUMERIC_VALUE),
        hasOverloadedBooleanValue: checkMask(propConfig, Injection.HAS_OVERLOADED_BOOLEAN_VALUE)
      };
      !(propertyInfo.hasBooleanValue + propertyInfo.hasNumericValue + propertyInfo.hasOverloadedBooleanValue <= 1) ? "production" !== 'production' ? invariant(false, 'DOMProperty: Value can be one of boolean, overloaded boolean, or numeric value, but not a combination: %s', propName) : _prodInvariant('50', propName) : void 0;

      if ("production" !== 'production') {
        DOMProperty.getPossibleStandardName[lowerCased] = propName;
      }

      if (DOMAttributeNames.hasOwnProperty(propName)) {
        var attributeName = DOMAttributeNames[propName];
        propertyInfo.attributeName = attributeName;
        if ("production" !== 'production') {
          DOMProperty.getPossibleStandardName[attributeName] = propName;
        }
      }

      if (DOMAttributeNamespaces.hasOwnProperty(propName)) {
        propertyInfo.attributeNamespace = DOMAttributeNamespaces[propName];
      }

      if (DOMPropertyNames.hasOwnProperty(propName)) {
        propertyInfo.propertyName = DOMPropertyNames[propName];
      }

      if (DOMMutationMethods.hasOwnProperty(propName)) {
        propertyInfo.mutationMethod = DOMMutationMethods[propName];
      }

      DOMProperty.properties[propName] = propertyInfo;
    }
  }
};

/* eslint-disable max-len */
var ATTRIBUTE_NAME_START_CHAR = ':A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD';
/* eslint-enable max-len */

/**
 * DOMProperty exports lookup objects that can be used like functions:
 *
 *   > DOMProperty.isValid['id']
 *   true
 *   > DOMProperty.isValid['foobar']
 *   undefined
 *
 * Although this may be confusing, it performs better in general.
 *
 * @see http://jsperf.com/key-exists
 * @see http://jsperf.com/key-missing
 */
var DOMProperty = {
  ID_ATTRIBUTE_NAME: 'data-reactid',
  ROOT_ATTRIBUTE_NAME: 'data-reactroot',

  ATTRIBUTE_NAME_START_CHAR: ATTRIBUTE_NAME_START_CHAR,
  ATTRIBUTE_NAME_CHAR: ATTRIBUTE_NAME_START_CHAR + '\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040',

  /**
   * Map from property "standard name" to an object with info about how to set
   * the property in the DOM. Each object contains:
   *
   * attributeName:
   *   Used when rendering markup or with `*Attribute()`.
   * attributeNamespace
   * propertyName:
   *   Used on DOM node instances. (This includes properties that mutate due to
   *   external factors.)
   * mutationMethod:
   *   If non-null, used instead of the property or `setAttribute()` after
   *   initial render.
   * mustUseProperty:
   *   Whether the property must be accessed and mutated as an object property.
   * hasBooleanValue:
   *   Whether the property should be removed when set to a falsey value.
   * hasNumericValue:
   *   Whether the property must be numeric or parse as a numeric and should be
   *   removed when set to a falsey value.
   * hasPositiveNumericValue:
   *   Whether the property must be positive numeric or parse as a positive
   *   numeric and should be removed when set to a falsey value.
   * hasOverloadedBooleanValue:
   *   Whether the property can be used as a flag as well as with a value.
   *   Removed when strictly equal to false; present without a value when
   *   strictly equal to true; present with a value otherwise.
   */
  properties: {},

  /**
   * Mapping from lowercase property names to the properly cased version, used
   * to warn in the case of missing properties. Available only in __DEV__.
   *
   * autofocus is predefined, because adding it to the property whitelist
   * causes unintended side effects.
   *
   * @type {Object}
   */
  getPossibleStandardName: "production" !== 'production' ? { autofocus: 'autoFocus' } : null,

  /**
   * All of the isCustomAttribute() functions that have been injected.
   */
  _isCustomAttributeFunctions: [],

  /**
   * Checks whether a property name is a custom attribute.
   * @method
   */
  isCustomAttribute: function (attributeName) {
    for (var i = 0; i < DOMProperty._isCustomAttributeFunctions.length; i++) {
      var isCustomAttributeFn = DOMProperty._isCustomAttributeFunctions[i];
      if (isCustomAttributeFn(attributeName)) {
        return true;
      }
    }
    return false;
  },

  injection: DOMPropertyInjection
};

module.exports = DOMProperty;
},{"./reactProdInvariant":650,"fbjs/lib/invariant":402}],542:[function(require,module,exports){
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */

'use strict';

var DOMProperty = require('./DOMProperty');
var ReactDOMComponentTree = require('./ReactDOMComponentTree');
var ReactInstrumentation = require('./ReactInstrumentation');

var quoteAttributeValueForBrowser = require('./quoteAttributeValueForBrowser');
var warning = require('fbjs/lib/warning');

var VALID_ATTRIBUTE_NAME_REGEX = new RegExp('^[' + DOMProperty.ATTRIBUTE_NAME_START_CHAR + '][' + DOMProperty.ATTRIBUTE_NAME_CHAR + ']*$');
var illegalAttributeNameCache = {};
var validatedAttributeNameCache = {};

function isAttributeNameSafe(attributeName) {
  if (validatedAttributeNameCache.hasOwnProperty(attributeName)) {
    return true;
  }
  if (illegalAttributeNameCache.hasOwnProperty(attributeName)) {
    return false;
  }
  if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName)) {
    validatedAttributeNameCache[attributeName] = true;
    return true;
  }
  illegalAttributeNameCache[attributeName] = true;
  "production" !== 'production' ? warning(false, 'Invalid attribute name: `%s`', attributeName) : void 0;
  return false;
}

function shouldIgnoreValue(propertyInfo, value) {
  return value == null || propertyInfo.hasBooleanValue && !value || propertyInfo.hasNumericValue && isNaN(value) || propertyInfo.hasPositiveNumericValue && value < 1 || propertyInfo.hasOverloadedBooleanValue && value === false;
}

/**
 * Operations for dealing with DOM properties.
 */
var DOMPropertyOperations = {
  /**
   * Creates markup for the ID property.
   *
   * @param {string} id Unescaped ID.
   * @return {string} Markup string.
   */
  createMarkupForID: function (id) {
    return DOMProperty.ID_ATTRIBUTE_NAME + '=' + quoteAttributeValueForBrowser(id);
  },

  setAttributeForID: function (node, id) {
    node.setAttribute(DOMProperty.ID_ATTRIBUTE_NAME, id);
  },

  createMarkupForRoot: function () {
    return DOMProperty.ROOT_ATTRIBUTE_NAME + '=""';
  },

  setAttributeForRoot: function (node) {
    node.setAttribute(DOMProperty.ROOT_ATTRIBUTE_NAME, '');
  },

  /**
   * Creates markup for a property.
   *
   * @param {string} name
   * @param {*} value
   * @return {?string} Markup string, or null if the property was invalid.
   */
  createMarkupForProperty: function (name, value) {
    var propertyInfo = DOMProperty.properties.hasOwnProperty(name) ? DOMProperty.properties[name] : null;
    if (propertyInfo) {
      if (shouldIgnoreValue(propertyInfo, value)) {
        return '';
      }
      var attributeName = propertyInfo.attributeName;
      if (propertyInfo.hasBooleanValue || propertyInfo.hasOverloadedBooleanValue && value === true) {
        return attributeName + '=""';
      }
      return attributeName + '=' + quoteAttributeValueForBrowser(value);
    } else if (DOMProperty.isCustomAttribute(name)) {
      if (value == null) {
        return '';
      }
      return name + '=' + quoteAttributeValueForBrowser(value);
    }
    return null;
  },

  /**
   * Creates markup for a custom property.
   *
   * @param {string} name
   * @param {*} value
   * @return {string} Markup string, or empty string if the property was invalid.
   */
  createMarkupForCustomAttribute: function (name, value) {
    if (!isAttributeNameSafe(name) || value == null) {
      return '';
    }
    return name + '=' + quoteAttributeValueForBrowser(value);
  },

  /**
   * Sets the value for a property on a node.
   *
   * @param {DOMElement} node
   * @param {string} name
   * @param {*} value
   */
  setValueForProperty: function (node, name, value) {
    var propertyInfo = DOMProperty.properties.hasOwnProperty(name) ? DOMProperty.properties[name] : null;
    if (propertyInfo) {
      var mutationMethod = propertyInfo.mutationMethod;
      if (mutationMethod) {
        mutationMethod(node, value);
      } else if (shouldIgnoreValue(propertyInfo, value)) {
        this.deleteValueForProperty(node, name);
        return;
      } else if (propertyInfo.mustUseProperty) {
        // Contrary to `setAttribute`, object properties are properly
        // `toString`ed by IE8/9.
        node[propertyInfo.propertyName] = value;
      } else {
        var attributeName = propertyInfo.attributeName;
        var namespace = propertyInfo.attributeNamespace;
        // `setAttribute` with objects becomes only `[object]` in IE8/9,
        // ('' + value) makes it output the correct toString()-value.
        if (namespace) {
          node.setAttributeNS(namespace, attributeName, '' + value);
        } else if (propertyInfo.hasBooleanValue || propertyInfo.hasOverloadedBooleanValue && value === true) {
          node.setAttribute(attributeName, '');
        } else {
          node.setAttribute(attributeName, '' + value);
        }
      }
    } else if (DOMProperty.isCustomAttribute(name)) {
      DOMPropertyOperations.setValueForAttribute(node, name, value);
      return;
    }

    if ("production" !== 'production') {
      var payload = {};
      payload[name] = value;
      ReactInstrumentation.debugTool.onHostOperation({
        instanceID: ReactDOMComponentTree.getInstanceFromNode(node)._debugID,
        type: 'update attribute',
        payload: payload
      });
    }
  },

  setValueForAttribute: function (node, name, value) {
    if (!isAttributeNameSafe(name)) {
      return;
    }
    if (value == null) {
      node.removeAttribute(name);
    } else {
      node.setAttribute(name, '' + value);
    }

    if ("production" !== 'production') {
      var payload = {};
      payload[name] = value;
      ReactInstrumentation.debugTool.onHostOperation({
        instanceID: ReactDOMComponentTree.getInstanceFromNode(node)._debugID,
        type: 'update attribute',
        payload: payload
      });
    }
  },

  /**
   * Deletes an attributes from a node.
   *
   * @param {DOMElement} node
   * @param {string} name
   */
  deleteValueForAttribute: function (node, name) {
    node.removeAttribute(name);
    if ("production" !== 'production') {
      ReactInstrumentation.debugTool.onHostOperation({
        instanceID: ReactDOMComponentTree.getInstanceFromNode(node)._debugID,
        type: 'remove attribute',
        payload: name
      });
    }
  },

  /**
   * Deletes the value for a property on a node.
   *
   * @param {DOMElement} node
   * @param {string} name
   */
  deleteValueForProperty: function (node, name) {
    var propertyInfo = DOMProperty.properties.hasOwnProperty(name) ? DOMProperty.properties[name] : null;
    if (propertyInfo) {
      var mutationMethod = propertyInfo.mutationMethod;
      if (mutationMethod) {
        mutationMethod(node, undefined);
      } else if (propertyInfo.mustUseProperty) {
        var propName = propertyInfo.propertyName;
        if (propertyInfo.hasBooleanValue) {
          node[propName] = false;
        } else {
          node[propName] = '';
        }
      } else {
        node.removeAttribute(propertyInfo.attributeName);
      }
    } else if (DOMProperty.isCustomAttribute(name)) {
      node.removeAttribute(name);
    }

    if ("production" !== 'production') {
      ReactInstrumentation.debugTool.onHostOperation({
        instanceID: ReactDOMComponentTree.getInstanceFromNode(node)._debugID,
        type: 'remove attribute',
        payload: name
      });
    }
  }
};

module.exports = DOMPropertyOperations;
},{"./DOMProperty":541,"./ReactDOMComponentTree":563,"./ReactInstrumentation":592,"./quoteAttributeValueForBrowser":649,"fbjs/lib/warning":409}],543:[function(require,module,exports){
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */

'use strict';

var _prodInvariant = require('./reactProdInvariant');

var DOMLazyTree = require('./DOMLazyTree');
var ExecutionEnvironment = require('fbjs/lib/ExecutionEnvironment');

var createNodesFromMarkup = require('fbjs/lib/createNodesFromMarkup');
var emptyFunction = require('fbjs/lib/emptyFunction');
var invariant = require('fbjs/lib/invariant');

var Danger = {
  /**
   * Replaces a node with a string of markup at its current position within its
   * parent. The markup must render into a single root node.
   *
   * @param {DOMElement} oldChild Child node to replace.
   * @param {string} markup Markup to render in place of the child node.
   * @internal
   */
  dangerouslyReplaceNodeWithMarkup: function (oldChild, markup) {
    !ExecutionEnvironment.canUseDOM ? "production" !== 'production' ? invariant(false, 'dangerouslyReplaceNodeWithMarkup(...): Cannot render markup in a worker thread. Make sure `window` and `document` are available globally before requiring React when unit testing or use ReactDOMServer.renderToString() for server rendering.') : _prodInvariant('56') : void 0;
    !markup ? "production" !== 'production' ? invariant(false, 'dangerouslyReplaceNodeWithMarkup(...): Missing markup.') : _prodInvariant('57') : void 0;
    !(oldChild.nodeName !== 'HTML') ? "production" !== 'production' ? invariant(false, 'dangerouslyReplaceNodeWithMarkup(...): Cannot replace markup of the <html> node. This is because browser quirks make this unreliable and/or slow. If you want to render to the root you must use server rendering. See ReactDOMServer.renderToString().') : _prodInvariant('58') : void 0;

    if (typeof markup === 'string') {
      var newChild = createNodesFromMarkup(markup, emptyFunction)[0];
      oldChild.parentNode.replaceChild(newChild, oldChild);
    } else {
      DOMLazyTree.replaceChildWithTree(oldChild, markup);
    }
  }
};

module.exports = Danger;
},{"./DOMLazyTree":539,"./reactProdInvariant":650,"fbjs/lib/ExecutionEnvironment":388,"fbjs/lib/createNodesFromMarkup":393,"fbjs/lib/emptyFunction":394,"fbjs/lib/invariant":402}],544:[function(require,module,exports){
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */

'use strict';

/**
 * Module that is injectable into `EventPluginHub`, that specifies a
 * deterministic ordering of `EventPlugin`s. A convenient way to reason about
 * plugins, without having to package every one of them. This is better than
 * having plugins be ordered in the same order that they are injected because
 * that ordering would be influenced by the packaging order.
 * `ResponderEventPlugin` must occur before `SimpleEventPlugin` so that
 * preventing default on events is convenient in `SimpleEventPlugin` handlers.
 */

var DefaultEventPluginOrder = ['ResponderEventPlugin', 'SimpleEventPlugin', 'TapEventPlugin', 'EnterLeaveEventPlugin', 'ChangeEventPlugin', 'SelectEventPlugin', 'BeforeInputEventPlugin'];

module.exports = DefaultEventPluginOrder;
},{}],545:[function(require,module,exports){
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */

'use strict';

var EventPropagators = require('./EventPropagators');
var ReactDOMComponentTree = require('./ReactDOMComponentTree');
var SyntheticMouseEvent = require('./SyntheticMouseEvent');

var eventTypes = {
  mouseEnter: {
    registrationName: 'onMouseEnter',
    dependencies: ['topMouseOut', 'topMouseOver']
  },
  mouseLeave: {
    registrationName: 'onMouseLeave',
    dependencies: ['topMouseOut', 'topMouseOver']
  }
};

var EnterLeaveEventPlugin = {
  eventTypes: eventTypes,

  /**
   * For almost every interaction we care about, there will be both a top-level
   * `mouseover` and `mouseout` event that occurs. Only use `mouseout` so that
   * we do not extract duplicate events. However, moving the mouse into the
   * browser from outside will not fire a `mouseout` event. In this case, we use
   * the `mouseover` top-level event.
   */
  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
    if (topLevelType === 'topMouseOver' && (nativeEvent.relatedTarget || nativeEvent.fromElement)) {
      return null;
    }
    if (topLevelType !== 'topMouseOut' && topLevelType !== 'topMouseOver') {
      // Must not be a mouse in or mouse out - ignoring.
      return null;
    }

    var win;
    if (nativeEventTarget.window === nativeEventTarget) {
      // `nativeEventTarget` is probably a window object.
      win = nativeEventTarget;
    } else {
      // TODO: Figure out why `ownerDocument` is sometimes undefined in IE8.
      var doc = nativeEventTarget.ownerDocument;
      if (doc) {
        win = doc.defaultView || doc.parentWindow;
      } else {
        win = window;
      }
    }

    var from;
    var to;
    if (topLevelType === 'topMouseOut') {
      from = targetInst;
      var related = nativeEvent.relatedTarget || nativeEvent.toElement;
      to = related ? ReactDOMComponentTree.getClosestInstanceFromNode(related) : null;
    } else {
      // Moving to a node from outside the window.
      from = null;
      to = targetInst;
    }

    if (from === to) {
      // Nothing pertains to our managed components.
      return null;
    }

    var fromNode = from == null ? win : ReactDOMComponentTree.getNodeFromInstance(from);
    var toNode = to == null ? win : ReactDOMComponentTree.getNodeFromInstance(to);

    var leave = SyntheticMouseEvent.getPooled(eventTypes.mouseLeave, from, nativeEvent, nativeEventTarget);
    leave.type = 'mouseleave';
    leave.target = fromNode;
    leave.relatedTarget = toNode;

    var enter = SyntheticMouseEvent.getPooled(eventTypes.mouseEnter, to, nativeEvent, nativeEventTarget);
    enter.type = 'mouseenter';
    enter.target = toNode;
    enter.relatedTarget = fromNode;

    EventPropagators.accumulateEnterLeaveDispatches(leave, enter, from, to);

    return [leave, enter];
  }
};

module.exports = EnterLeaveEventPlugin;
},{"./EventPropagators":549,"./ReactDOMComponentTree":563,"./SyntheticMouseEvent":620}],546:[function(require,module,exports){
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */

'use strict';

var _prodInvariant = require('./reactProdInvariant');

var EventPluginRegistry = require('./EventPluginRegistry');
var EventPluginUtils = require('./EventPluginUtils');
var ReactErrorUtils = require('./ReactErrorUtils');

var accumulateInto = require('./accumulateInto');
var forEachAccumulated = require('./forEachAccumulated');
var invariant = require('fbjs/lib/invariant');

/**
 * Internal store for event listeners
 */
var listenerBank = {};

/**
 * Internal queue of events that have accumulated their dispatches and are
 * waiting to have their dispatches executed.
 */
var eventQueue = null;

/**
 * Dispatches an event and releases it back into the pool, unless persistent.
 *
 * @param {?object} event Synthetic event to be dispatched.
 * @param {boolean} simulated If the event is simulated (changes exn behavior)
 * @private
 */
var executeDispatchesAndRelease = function (event, simulated) {
  if (event) {
    EventPluginUtils.executeDispatchesInOrder(event, simulated);

    if (!event.isPersistent()) {
      event.constructor.release(event);
    }
  }
};
var executeDispatchesAndReleaseSimulated = function (e) {
  return executeDispatchesAndRelease(e, true);
};
var executeDispatchesAndReleaseTopLevel = function (e) {
  return executeDispatchesAndRelease(e, false);
};

var getDictionaryKey = function (inst) {
  // Prevents V8 performance issue:
  // https://github.com/facebook/react/pull/7232
  return '.' + inst._rootNodeID;
};

function isInteractive(tag) {
  return tag === 'button' || tag === 'input' || tag === 'select' || tag === 'textarea';
}

function shouldPreventMouseEvent(name, type, props) {
  switch (name) {
    case 'onClick':
    case 'onClickCapture':
    case 'onDoubleClick':
    case 'onDoubleClickCapture':
    case 'onMouseDown':
    case 'onMouseDownCapture':
    case 'onMouseMove':
    case 'onMouseMoveCapture':
    case 'onMouseUp':
    case 'onMouseUpCapture':
      return !!(props.disabled && isInteractive(type));
    default:
      return false;
  }
}

/**
 * This is a unified interface for event plugins to be installed and configured.
 *
 * Event plugins can implement the following properties:
 *
 *   `extractEvents` {function(string, DOMEventTarget, string, object): *}
 *     Required. When a top-level event is fired, this method is expected to
 *     extract synthetic events that will in turn be queued and dispatched.
 *
 *   `eventTypes` {object}
 *     Optional, plugins that fire events must publish a mapping of registration
 *     names that are used to register listeners. Values of this mapping must
 *     be objects that contain `registrationName` or `phasedRegistrationNames`.
 *
 *   `executeDispatch` {function(object, function, string)}
 *     Optional, allows plugins to override how an event gets dispatched. By
 *     default, the listener is simply invoked.
 *
 * Each plugin that is injected into `EventsPluginHub` is immediately operable.
 *
 * @public
 */
var EventPluginHub = {
  /**
   * Methods for injecting dependencies.
   */
  injection: {
    /**
     * @param {array} InjectedEventPluginOrder
     * @public
     */
    injectEventPluginOrder: EventPluginRegistry.injectEventPluginOrder,

    /**
     * @param {object} injectedNamesToPlugins Map from names to plugin modules.
     */
    injectEventPluginsByName: EventPluginRegistry.injectEventPluginsByName
  },

  /**
   * Stores `listener` at `listenerBank[registrationName][key]`. Is idempotent.
   *
   * @param {object} inst The instance, which is the source of events.
   * @param {string} registrationName Name of listener (e.g. `onClick`).
   * @param {function} listener The callback to store.
   */
  putListener: function (inst, registrationName, listener) {
    !(typeof listener === 'function') ? "production" !== 'production' ? invariant(false, 'Expected %s listener to be a function, instead got type %s', registrationName, typeof listener) : _prodInvariant('94', registrationName, typeof listener) : void 0;

    var key = getDictionaryKey(inst);
    var bankForRegistrationName = listenerBank[registrationName] || (listenerBank[registrationName] = {});
    bankForRegistrationName[key] = listener;

    var PluginModule = EventPluginRegistry.registrationNameModules[registrationName];
    if (PluginModule && PluginModule.didPutListener) {
      PluginModule.didPutListener(inst, registrationName, listener);
    }
  },

  /**
   * @param {object} inst The instance, which is the source of events.
   * @param {string} registrationName Name of listener (e.g. `onClick`).
   * @return {?function} The stored callback.
   */
  getListener: function (inst, registrationName) {
    // TODO: shouldPreventMouseEvent is DOM-specific and definitely should not
    // live here; needs to be moved to a better place soon
    var bankForRegistrationName = listenerBank[registrationName];
    if (shouldPreventMouseEvent(registrationName, inst._currentElement.type, inst._currentElement.props)) {
      return null;
    }
    var key = getDictionaryKey(inst);
    return bankForRegistrationName && bankForRegistrationName[key];
  },

  /**
   * Deletes a listener from the registration bank.
   *
   * @param {object} inst The instance, which is the source of events.
   * @param {string} registrationName Name of listener (e.g. `onClick`).
   */
  deleteListener: function (inst, registrationName) {
    var PluginModule = EventPluginRegistry.registrationNameModules[registrationName];
    if (PluginModule && PluginModule.willDeleteListener) {
      PluginModule.willDeleteListener(inst, registrationName);
    }

    var bankForRegistrationName = listenerBank[registrationName];
    // TODO: This should never be null -- when is it?
    if (bankForRegistrationName) {
      var key = getDictionaryKey(inst);
      delete bankForRegistrationName[key];
    }
  },

  /**
   * Deletes all listeners for the DOM element with the supplied ID.
   *
   * @param {object} inst The instance, which is the source of events.
   */
  deleteAllListeners: function (inst) {
    var key = getDictionaryKey(inst);
    for (var registrationName in listenerBank) {
      if (!listenerBank.hasOwnProperty(registrationName)) {
        continue;
      }

      if (!listenerBank[registrationName][key]) {
        continue;
      }

      var PluginModule = EventPluginRegistry.registrationNameModules[registrationName];
      if (PluginModule && PluginModule.willDeleteListener) {
        PluginModule.willDeleteListener(inst, registrationName);
      }

      delete listenerBank[registrationName][key];
    }
  },

  /**
   * Allows registered plugins an opportunity to extract events from top-level
   * native browser events.
   *
   * @return {*} An accumulation of synthetic events.
   * @internal
   */
  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
    var events;
    var plugins = EventPluginRegistry.plugins;
    for (var i = 0; i < plugins.length; i++) {
      // Not every plugin in the ordering may be loaded at runtime.
      var possiblePlugin = plugins[i];
      if (possiblePlugin) {
        var extractedEvents = possiblePlugin.extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget);
        if (extractedEvents) {
          events = accumulateInto(events, extractedEvents);
        }
      }
    }
    return events;
  },

  /**
   * Enqueues a synthetic event that should be dispatched when
   * `processEventQueue` is invoked.
   *
   * @param {*} events An accumulation of synthetic events.
   * @internal
   */
  enqueueEvents: function (events) {
    if (events) {
      eventQueue = accumulateInto(eventQueue, events);
    }
  },

  /**
   * Dispatches all synthetic events on the event queue.
   *
   * @internal
   */
  processEventQueue: function (simulated) {
    // Set `eventQueue` to null before processing it so that we can tell if more
    // events get enqueued while processing.
    var processingEventQueue = eventQueue;
    eventQueue = null;
    if (simulated) {
      forEachAccumulated(processingEventQueue, executeDispatchesAndReleaseSimulated);
    } else {
      forEachAccumulated(processingEventQueue, executeDispatchesAndReleaseTopLevel);
    }
    !!eventQueue ? "production" !== 'production' ? invariant(false, 'processEventQueue(): Additional events were enqueued while processing an event queue. Support for this has not yet been implemented.') : _prodInvariant('95') : void 0;
    // This would be a good time to rethrow if any of the event handlers threw.
    ReactErrorUtils.rethrowCaughtError();
  },

  /**
   * These are needed for tests only. Do not use!
   */
  __purge: function () {
    listenerBank = {};
  },

  __getListenerBank: function () {
    return listenerBank;
  }
};

module.exports = EventPluginHub;
},{"./EventPluginRegistry":547,"./EventPluginUtils":548,"./ReactErrorUtils":583,"./accumulateInto":627,"./forEachAccumulated":635,"./reactProdInvariant":650,"fbjs/lib/invariant":402}],547:[function(require,module,exports){
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

'use strict';

var _prodInvariant = require('./reactProdInvariant');

var invariant = require('fbjs/lib/invariant');

/**
 * Injectable ordering of event plugins.
 */
var eventPluginOrder = null;

/**
 * Injectable mapping from names to event plugin modules.
 */
var namesToPlugins = {};

/**
 * Recomputes the plugin list using the injected plugins and plugin ordering.
 *
 * @private
 */
function recomputePluginOrdering() {
  if (!eventPluginOrder) {
    // Wait until an `eventPluginOrder` is injected.
    return;
  }
  for (var pluginName in namesToPlugins) {
    var pluginModule = namesToPlugins[pluginName];
    var pluginIndex = eventPluginOrder.indexOf(pluginName);
    !(pluginIndex > -1) ? "production" !== 'production' ? invariant(false, 'EventPluginRegistry: Cannot inject event plugins that do not exist in the plugin ordering, `%s`.', pluginName) : _prodInvariant('96', pluginName) : void 0;
    if (EventPluginRegistry.plugins[pluginIndex]) {
      continue;
    }
    !pluginModule.extractEvents ? "production" !== 'production' ? invariant(false, 'EventPluginRegistry: Event plugins must implement an `extractEvents` method, but `%s` does not.', pluginName) : _prodInvariant('97', pluginName) : void 0;
    EventPluginRegistry.plugins[pluginIndex] = pluginModule;
    var publishedEvents = pluginModule.eventTypes;
    for (var eventName in publishedEvents) {
      !publishEventForPlugin(publishedEvents[eventName], pluginModule, eventName) ? "production" !== 'production' ? invariant(false, 'EventPluginRegistry: Failed to publish event `%s` for plugin `%s`.', eventName, pluginName) : _prodInvariant('98', eventName, pluginName) : void 0;
    }
  }
}

/**
 * Publishes an event so that it can be dispatched by the supplied plugin.
 *
 * @param {object} dispatchConfig Dispatch configuration for the event.
 * @param {object} PluginModule Plugin publishing the event.
 * @return {boolean} True if the event was successfully published.
 * @private
 */
function publishEventForPlugin(dispatchConfig, pluginModule, eventName) {
  !!EventPluginRegistry.eventNameDispatchConfigs.hasOwnProperty(eventName) ? "production" !== 'production' ? invariant(false, 'EventPluginHub: More than one plugin attempted to publish the same event name, `%s`.', eventName) : _prodInvariant('99', eventName) : void 0;
  EventPluginRegistry.eventNameDispatchConfigs[eventName] = dispatchConfig;

  var phasedRegistrationNames = dispatchConfig.phasedRegistrationNames;
  if (phasedRegistrationNames) {
    for (var phaseName in phasedRegistrationNames) {
      if (phasedRegistrationNames.hasOwnProperty(phaseName)) {
        var phasedRegistrationName = phasedRegistrationNames[phaseName];
        publishRegistrationName(phasedRegistrationName, pluginModule, eventName);
      }
    }
    return true;
  } else if (dispatchConfig.registrationName) {
    publishRegistrationName(dispatchConfig.registrationName, pluginModule, eventName);
    return true;
  }
  return false;
}

/**
 * Publishes a registration name that is used to identify dispatched events and
 * can be used with `EventPluginHub.putListener` to register listeners.
 *
 * @param {string} registrationName Registration name to add.
 * @param {object} PluginModule Plugin publishing the event.
 * @private
 */
function publishRegistrationName(registrationName, pluginModule, eventName) {
  !!EventPluginRegistry.registrationNameModules[registrationName] ? "production" !== 'production' ? invariant(false, 'EventPluginHub: More than one plugin attempted to publish the same registration name, `%s`.', registrationName) : _prodInvariant('100', registrationName) : void 0;
  EventPluginRegistry.registrationNameModules[registrationName] = pluginModule;
  EventPluginRegistry.registrationNameDependencies[registrationName] = pluginModule.eventTypes[eventName].dependencies;

  if ("production" !== 'production') {
    var lowerCasedName = registrationName.toLowerCase();
    EventPluginRegistry.possibleRegistrationNames[lowerCasedName] = registrationName;

    if (registrationName === 'onDoubleClick') {
      EventPluginRegistry.possibleRegistrationNames.ondblclick = registrationName;
    }
  }
}

/**
 * Registers plugins so that they can extract and dispatch events.
 *
 * @see {EventPluginHub}
 */
var EventPluginRegistry = {
  /**
   * Ordered list of injected plugins.
   */
  plugins: [],

  /**
   * Mapping from event name to dispatch config
   */
  eventNameDispatchConfigs: {},

  /**
   * Mapping from registration name to plugin module
   */
  registrationNameModules: {},

  /**
   * Mapping from registration name to event name
   */
  registrationNameDependencies: {},

  /**
   * Mapping from lowercase registration names to the properly cased version,
   * used to warn in the case of missing event handlers. Available
   * only in __DEV__.
   * @type {Object}
   */
  possibleRegistrationNames: "production" !== 'production' ? {} : null,
  // Trust the developer to only use possibleRegistrationNames in __DEV__

  /**
   * Injects an ordering of plugins (by plugin name). This allows the ordering
   * to be decoupled from injection of the actual plugins so that ordering is
   * always deterministic regardless of packaging, on-the-fly injection, etc.
   *
   * @param {array} InjectedEventPluginOrder
   * @internal
   * @see {EventPluginHub.injection.injectEventPluginOrder}
   */
  injectEventPluginOrder: function (injectedEventPluginOrder) {
    !!eventPluginOrder ? "production" !== 'production' ? invariant(false, 'EventPluginRegistry: Cannot inject event plugin ordering more than once. You are likely trying to load more than one copy of React.') : _prodInvariant('101') : void 0;
    // Clone the ordering so it cannot be dynamically mutated.
    eventPluginOrder = Array.prototype.slice.call(injectedEventPluginOrder);
    recomputePluginOrdering();
  },

  /**
   * Injects plugins to be used by `EventPluginHub`. The plugin names must be
   * in the ordering injected by `injectEventPluginOrder`.
   *
   * Plugins can be injected as part of page initialization or on-the-fly.
   *
   * @param {object} injectedNamesToPlugins Map from names to plugin modules.
   * @internal
   * @see {EventPluginHub.injection.injectEventPluginsByName}
   */
  injectEventPluginsByName: function (injectedNamesToPlugins) {
    var isOrderingDirty = false;
    for (var pluginName in injectedNamesToPlugins) {
      if (!injectedNamesToPlugins.hasOwnProperty(pluginName)) {
        continue;
      }
      var pluginModule = injectedNamesToPlugins[pluginName];
      if (!namesToPlugins.hasOwnProperty(pluginName) || namesToPlugins[pluginName] !== pluginModule) {
        !!namesToPlugins[pluginName] ? "production" !== 'production' ? invariant(false, 'EventPluginRegistry: Cannot inject two different event plugins using the same name, `%s`.', pluginName) : _prodInvariant('102', pluginName) : void 0;
        namesToPlugins[pluginName] = pluginModule;
        isOrderingDirty = true;
      }
    }
    if (isOrderingDirty) {
      recomputePluginOrdering();
    }
  },

  /**
   * Looks up the plugin for the supplied event.
   *
   * @param {object} event A synthetic event.
   * @return {?object} The plugin that created the supplied event.
   * @internal
   */
  getPluginModuleForEvent: function (event) {
    var dispatchConfig = event.dispatchConfig;
    if (dispatchConfig.registrationName) {
      return EventPluginRegistry.registrationNameModules[dispatchConfig.registrationName] || null;
    }
    if (dispatchConfig.phasedRegistrationNames !== undefined) {
      // pulling phasedRegistrationNames out of dispatchConfig helps Flow see
      // that it is not undefined.
      var phasedRegistrationNames = dispatchConfig.phasedRegistrationNames;

      for (var phase in phasedRegistrationNames) {
        if (!phasedRegistrationNames.hasOwnProperty(phase)) {
          continue;
        }
        var pluginModule = EventPluginRegistry.registrationNameModules[phasedRegistrationNames[phase]];
        if (pluginModule) {
          return pluginModule;
        }
      }
    }
    return null;
  },

  /**
   * Exposed for unit testing.
   * @private
   */
  _resetEventPlugins: function () {
    eventPluginOrder = null;
    for (var pluginName in namesToPlugins) {
      if (namesToPlugins.hasOwnProperty(pluginName)) {
        delete namesToPlugins[pluginName];
      }
    }
    EventPluginRegistry.plugins.length = 0;

    var eventNameDispatchConfigs = EventPluginRegistry.eventNameDispatchConfigs;
    for (var eventName in eventNameDispatchConfigs) {
      if (eventNameDispatchConfigs.hasOwnProperty(eventName)) {
        delete eventNameDispatchConfigs[eventName];
      }
    }

    var registrationNameModules = EventPluginRegistry.registrationNameModules;
    for (var registrationName in registrationNameModules) {
      if (registrationNameModules.hasOwnProperty(registrationName)) {
        delete registrationNameModules[registrationName];
      }
    }

    if ("production" !== 'production') {
      var possibleRegistrationNames = EventPluginRegistry.possibleRegistrationNames;
      for (var lowerCasedName in possibleRegistrationNames) {
        if (possibleRegistrationNames.hasOwnProperty(lowerCasedName)) {
          delete possibleRegistrationNames[lowerCasedName];
        }
      }
    }
  }
};

module.exports = EventPluginRegistry;
},{"./reactProdInvariant":650,"fbjs/lib/invariant":402}],548:[function(require,module,exports){
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */

'use strict';

var _prodInvariant = require('./reactProdInvariant');

var ReactErrorUtils = require('./ReactErrorUtils');

var invariant = require('fbjs/lib/invariant');
var warning = require('fbjs/lib/warning');

/**
 * Injected dependencies:
 */

/**
 * - `ComponentTree`: [required] Module that can convert between React instances
 *   and actual node references.
 */
var ComponentTree;
var TreeTraversal;
var injection = {
  injectComponentTree: function (Injected) {
    ComponentTree = Injected;
    if ("production" !== 'production') {
      "production" !== 'production' ? warning(Injected && Injected.getNodeFromInstance && Injected.getInstanceFromNode, 'EventPluginUtils.injection.injectComponentTree(...): Injected ' + 'module is missing getNodeFromInstance or getInstanceFromNode.') : void 0;
    }
  },
  injectTreeTraversal: function (Injected) {
    TreeTraversal = Injected;
    if ("production" !== 'production') {
      "production" !== 'production' ? warning(Injected && Injected.isAncestor && Injected.getLowestCommonAncestor, 'EventPluginUtils.injection.injectTreeTraversal(...): Injected ' + 'module is missing isAncestor or getLowestCommonAncestor.') : void 0;
    }
  }
};

function isEndish(topLevelType) {
  return topLevelType === 'topMouseUp' || topLevelType === 'topTouchEnd' || topLevelType === 'topTouchCancel';
}

function isMoveish(topLevelType) {
  return topLevelType === 'topMouseMove' || topLevelType === 'topTouchMove';
}
function isStartish(topLevelType) {
  return topLevelType === 'topMouseDown' || topLevelType === 'topTouchStart';
}

var validateEventDispatches;
if ("production" !== 'production') {
  validateEventDispatches = function (event) {
    var dispatchListeners = event._dispatchListeners;
    var dispatchInstances = event._dispatchInstances;

    var listenersIsArr = Array.isArray(dispatchListeners);
    var listenersLen = listenersIsArr ? dispatchListeners.length : dispatchListeners ? 1 : 0;

    var instancesIsArr = Array.isArray(dispatchInstances);
    var instancesLen = instancesIsArr ? dispatchInstances.length : dispatchInstances ? 1 : 0;

    "production" !== 'production' ? warning(instancesIsArr === listenersIsArr && instancesLen === listenersLen, 'EventPluginUtils: Invalid `event`.') : void 0;
  };
}

/**
 * Dispatch the event to the listener.
 * @param {SyntheticEvent} event SyntheticEvent to handle
 * @param {boolean} simulated If the event is simulated (changes exn behavior)
 * @param {function} listener Application-level callback
 * @param {*} inst Internal component instance
 */
function executeDispatch(event, simulated, listener, inst) {
  var type = event.type || 'unknown-event';
  event.currentTarget = EventPluginUtils.getNodeFromInstance(inst);
  if (simulated) {
    ReactErrorUtils.invokeGuardedCallbackWithCatch(type, listener, event);
  } else {
    ReactErrorUtils.invokeGuardedCallback(type, listener, event);
  }
  event.currentTarget = null;
}

/**
 * Standard/simple iteration through an event's collected dispatches.
 */
function executeDispatchesInOrder(event, simulated) {
  var dispatchListeners = event._dispatchListeners;
  var dispatchInstances = event._dispatchInstances;
  if ("production" !== 'production') {
    validateEventDispatches(event);
  }
  if (Array.isArray(dispatchListeners)) {
    for (var i = 0; i < dispatchListeners.length; i++) {
      if (event.isPropagationStopped()) {
        break;
      }
      // Listeners and Instances are two parallel arrays that are always in sync.
      executeDispatch(event, simulated, dispatchListeners[i], dispatchInstances[i]);
    }
  } else if (dispatchListeners) {
    executeDispatch(event, simulated, dispatchListeners, dispatchInstances);
  }
  event._dispatchListeners = null;
  event._dispatchInstances = null;
}

/**
 * Standard/simple iteration through an event's collected dispatches, but stops
 * at the first dispatch execution returning true, and returns that id.
 *
 * @return {?string} id of the first dispatch execution who's listener returns
 * true, or null if no listener returned true.
 */
function executeDispatchesInOrderStopAtTrueImpl(event) {
  var dispatchListeners = event._dispatchListeners;
  var dispatchInstances = event._dispatchInstances;
  if ("production" !== 'production') {
    validateEventDispatches(event);
  }
  if (Array.isArray(dispatchListeners)) {
    for (var i = 0; i < dispatchListeners.length; i++) {
      if (event.isPropagationStopped()) {
        break;
      }
      // Listeners and Instances are two parallel arrays that are always in sync.
      if (dispatchListeners[i](event, dispatchInstances[i])) {
        return dispatchInstances[i];
      }
    }
  } else if (dispatchListeners) {
    if (dispatchListeners(event, dispatchInstances)) {
      return dispatchInstances;
    }
  }
  return null;
}

/**
 * @see executeDispatchesInOrderStopAtTrueImpl
 */
function executeDispatchesInOrderStopAtTrue(event) {
  var ret = executeDispatchesInOrderStopAtTrueImpl(event);
  event._dispatchInstances = null;
  event._dispatchListeners = null;
  return ret;
}

/**
 * Execution of a "direct" dispatch - there must be at most one dispatch
 * accumulated on the event or it is considered an error. It doesn't really make
 * sense for an event with multiple dispatches (bubbled) to keep track of the
 * return values at each dispatch execution, but it does tend to make sense when
 * dealing with "direct" dispatches.
 *
 * @return {*} The return value of executing the single dispatch.
 */
function executeDirectDispatch(event) {
  if ("production" !== 'production') {
    validateEventDispatches(event);
  }
  var dispatchListener = event._dispatchListeners;
  var dispatchInstance = event._dispatchInstances;
  !!Array.isArray(dispatchListener) ? "production" !== 'production' ? invariant(false, 'executeDirectDispatch(...): Invalid `event`.') : _prodInvariant('103') : void 0;
  event.currentTarget = dispatchListener ? EventPluginUtils.getNodeFromInstance(dispatchInstance) : null;
  var res = dispatchListener ? dispatchListener(event) : null;
  event.currentTarget = null;
  event._dispatchListeners = null;
  event._dispatchInstances = null;
  return res;
}

/**
 * @param {SyntheticEvent} event
 * @return {boolean} True iff number of dispatches accumulated is greater than 0.
 */
function hasDispatches(event) {
  return !!event._dispatchListeners;
}

/**
 * General utilities that are useful in creating custom Event Plugins.
 */
var EventPluginUtils = {
  isEndish: isEndish,
  isMoveish: isMoveish,
  isStartish: isStartish,

  executeDirectDispatch: executeDirectDispatch,
  executeDispatchesInOrder: executeDispatchesInOrder,
  executeDispatchesInOrderStopAtTrue: executeDispatchesInOrderStopAtTrue,
  hasDispatches: hasDispatches,

  getInstanceFromNode: function (node) {
    return ComponentTree.getInstanceFromNode(node);
  },
  getNodeFromInstance: function (node) {
    return ComponentTree.getNodeFromInstance(node);
  },
  isAncestor: function (a, b) {
    return TreeTraversal.isAncestor(a, b);
  },
  getLowestCommonAncestor: function (a, b) {
    return TreeTraversal.getLowestCommonAncestor(a, b);
  },
  getParentInstance: function (inst) {
    return TreeTraversal.getParentInstance(inst);
  },
  traverseTwoPhase: function (target, fn, arg) {
    return TreeTraversal.traverseTwoPhase(target, fn, arg);
  },
  traverseEnterLeave: function (from, to, fn, argFrom, argTo) {
    return TreeTraversal.traverseEnterLeave(from, to, fn, argFrom, argTo);
  },

  injection: injection
};

module.exports = EventPluginUtils;
},{"./ReactErrorUtils":583,"./reactProdInvariant":650,"fbjs/lib/invariant":402,"fbjs/lib/warning":409}],549:[function(require,module,exports){
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */

'use strict';

var EventPluginHub = require('./EventPluginHub');
var EventPluginUtils = require('./EventPluginUtils');

var accumulateInto = require('./accumulateInto');
var forEachAccumulated = require('./forEachAccumulated');
var warning = require('fbjs/lib/warning');

var getListener = EventPluginHub.getListener;

/**
 * Some event types have a notion of different registration names for different
 * "phases" of propagation. This finds listeners by a given phase.
 */
function listenerAtPhase(inst, event, propagationPhase) {
  var registrationName = event.dispatchConfig.phasedRegistrationNames[propagationPhase];
  return getListener(inst, registrationName);
}

/**
 * Tags a `SyntheticEvent` with dispatched listeners. Creating this function
 * here, allows us to not have to bind or create functions for each event.
 * Mutating the event's members allows us to not have to create a wrapping
 * "dispatch" object that pairs the event with the listener.
 */
function accumulateDirectionalDispatches(inst, phase, event) {
  if ("production" !== 'production') {
    "production" !== 'production' ? warning(inst, 'Dispatching inst must not be null') : void 0;
  }
  var listener = listenerAtPhase(inst, event, phase);
  if (listener) {
    event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);
    event._dispatchInstances = accumulateInto(event._dispatchInstances, inst);
  }
}

/**
 * Collect dispatches (must be entirely collected before dispatching - see unit
 * tests). Lazily allocate the array to conserve memory.  We must loop through
 * each event and perform the traversal for each one. We cannot perform a
 * single traversal for the entire collection of events because each event may
 * have a different target.
 */
function accumulateTwoPhaseDispatchesSingle(event) {
  if (event && event.dispatchConfig.phasedRegistrationNames) {
    EventPluginUtils.traverseTwoPhase(event._targetInst, accumulateDirectionalDispatches, event);
  }
}

/**
 * Same as `accumulateTwoPhaseDispatchesSingle`, but skips over the targetID.
 */
function accumulateTwoPhaseDispatchesSingleSkipTarget(event) {
  if (event && event.dispatchConfig.phasedRegistrationNames) {
    var targetInst = event._targetInst;
    var parentInst = targetInst ? EventPluginUtils.getParentInstance(targetInst) : null;
    EventPluginUtils.traverseTwoPhase(parentInst, accumulateDirectionalDispatches, event);
  }
}

/**
 * Accumulates without regard to direction, does not look for phased
 * registration names. Same as `accumulateDirectDispatchesSingle` but without
 * requiring that the `dispatchMarker` be the same as the dispatched ID.
 */
function accumulateDispatches(inst, ignoredDirection, event) {
  if (event && event.dispatchConfig.registrationName) {
    var registrationName = event.dispatchConfig.registrationName;
    var listener = getListener(inst, registrationName);
    if (listener) {
      event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);
      event._dispatchInstances = accumulateInto(event._dispatchInstances, inst);
    }
  }
}

/**
 * Accumulates dispatches on an `SyntheticEvent`, but only for the
 * `dispatchMarker`.
 * @param {SyntheticEvent} event
 */
function accumulateDirectDispatchesSingle(event) {
  if (event && event.dispatchConfig.registrationName) {
    accumulateDispatches(event._targetInst, null, event);
  }
}

function accumulateTwoPhaseDispatches(events) {
  forEachAccumulated(events, accumulateTwoPhaseDispatchesSingle);
}

function accumulateTwoPhaseDispatchesSkipTarget(events) {
  forEachAccumulated(events, accumulateTwoPhaseDispatchesSingleSkipTarget);
}

function accumulateEnterLeaveDispatches(leave, enter, from, to) {
  EventPluginUtils.traverseEnterLeave(from, to, accumulateDispatches, leave, enter);
}

function accumulateDirectDispatches(events) {
  forEachAccumulated(events, accumulateDirectDispatchesSingle);
}

/**
 * A small set of propagation patterns, each of which will accept a small amount
 * of information, and generate a set of "dispatch ready event objects" - which
 * are sets of events that have already been annotated with a set of dispatched
 * listener functions/ids. The API is designed this way to discourage these
 * propagation strategies from actually executing the dispatches, since we
 * always want to collect the entire set of dispatches before executing event a
 * single one.
 *
 * @constructor EventPropagators
 */
var EventPropagators = {
  accumulateTwoPhaseDispatches: accumulateTwoPhaseDispatches,
  accumulateTwoPhaseDispatchesSkipTarget: accumulateTwoPhaseDispatchesSkipTarget,
  accumulateDirectDispatches: accumulateDirectDispatches,
  accumulateEnterLeaveDispatches: accumulateEnterLeaveDispatches
};

module.exports = EventPropagators;
},{"./EventPluginHub":546,"./EventPluginUtils":548,"./accumulateInto":627,"./forEachAccumulated":635,"fbjs/lib/warning":409}],550:[function(require,module,exports){
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */

'use strict';

var _assign = require('object-assign');

var PooledClass = require('./PooledClass');

var getTextContentAccessor = require('./getTextContentAccessor');

/**
 * This helper class stores information about text content of a target node,
 * allowing comparison of content before and after a given event.
 *
 * Identify the node where selection currently begins, then observe
 * both its text content and its current position in the DOM. Since the
 * browser may natively replace the target node during composition, we can
 * use its position to find its replacement.
 *
 * @param {DOMEventTarget} root
 */
function FallbackCompositionState(root) {
  this._root = root;
  this._startText = this.getText();
  this._fallbackText = null;
}

_assign(FallbackCompositionState.prototype, {
  destructor: function () {
    this._root = null;
    this._startText = null;
    this._fallbackText = null;
  },

  /**
   * Get current text of input.
   *
   * @return {string}
   */
  getText: function () {
    if ('value' in this._root) {
      return this._root.value;
    }
    return this._root[getTextContentAccessor()];
  },

  /**
   * Determine the differing substring between the initially stored
   * text content and the current content.
   *
   * @return {string}
   */
  getData: function () {
    if (this._fallbackText) {
      return this._fallbackText;
    }

    var start;
    var startValue = this._startText;
    var startLength = startValue.length;
    var end;
    var endValue = this.getText();
    var endLength = endValue.length;

    for (start = 0; start < startLength; start++) {
      if (startValue[start] !== endValue[start]) {
        break;
      }
    }

    var minEnd = startLength - start;
    for (end = 1; end <= minEnd; end++) {
      if (startValue[startLength - end] !== endValue[endLength - end]) {
        break;
      }
    }

    var sliceTail = end > 1 ? 1 - end : undefined;
    this._fallbackText = endValue.slice(start, sliceTail);
    return this._fallbackText;
  }
});

PooledClass.addPoolingTo(FallbackCompositionState);

module.exports = FallbackCompositionState;
},{"./PooledClass":554,"./getTextContentAccessor":643,"object-assign":489}],551:[function(require,module,exports){
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */

'use strict';

var DOMProperty = require('./DOMProperty');

var MUST_USE_PROPERTY = DOMProperty.injection.MUST_USE_PROPERTY;
var HAS_BOOLEAN_VALUE = DOMProperty.injection.HAS_BOOLEAN_VALUE;
var HAS_NUMERIC_VALUE = DOMProperty.injection.HAS_NUMERIC_VALUE;
var HAS_POSITIVE_NUMERIC_VALUE = DOMProperty.injection.HAS_POSITIVE_NUMERIC_VALUE;
var HAS_OVERLOADED_BOOLEAN_VALUE = DOMProperty.injection.HAS_OVERLOADED_BOOLEAN_VALUE;

var HTMLDOMPropertyConfig = {
  isCustomAttribute: RegExp.prototype.test.bind(new RegExp('^(data|aria)-[' + DOMProperty.ATTRIBUTE_NAME_CHAR + ']*$')),
  Properties: {
    /**
     * Standard Properties
     */
    accept: 0,
    acceptCharset: 0,
    accessKey: 0,
    action: 0,
    allowFullScreen: HAS_BOOLEAN_VALUE,
    allowTransparency: 0,
    alt: 0,
    // specifies target context for links with `preload` type
    as: 0,
    async: HAS_BOOLEAN_VALUE,
    autoComplete: 0,
    // autoFocus is polyfilled/normalized by AutoFocusUtils
    // autoFocus: HAS_BOOLEAN_VALUE,
    autoPlay: HAS_BOOLEAN_VALUE,
    capture: HAS_BOOLEAN_VALUE,
    cellPadding: 0,
    cellSpacing: 0,
    charSet: 0,
    challenge: 0,
    checked: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
    cite: 0,
    classID: 0,
    className: 0,
    cols: HAS_POSITIVE_NUMERIC_VALUE,
    colSpan: 0,
    content: 0,
    contentEditable: 0,
    contextMenu: 0,
    controls: HAS_BOOLEAN_VALUE,
    controlsList: 0,
    coords: 0,
    crossOrigin: 0,
    data: 0, // For `<object />` acts as `src`.
    dateTime: 0,
    'default': HAS_BOOLEAN_VALUE,
    defer: HAS_BOOLEAN_VALUE,
    dir: 0,
    disabled: HAS_BOOLEAN_VALUE,
    download: HAS_OVERLOADED_BOOLEAN_VALUE,
    draggable: 0,
    encType: 0,
    form: 0,
    formAction: 0,
    formEncType: 0,
    formMethod: 0,
    formNoValidate: HAS_BOOLEAN_VALUE,
    formTarget: 0,
    frameBorder: 0,
    headers: 0,
    height: 0,
    hidden: HAS_BOOLEAN_VALUE,
    high: 0,
    href: 0,
    hrefLang: 0,
    htmlFor: 0,
    httpEquiv: 0,
    icon: 0,
    id: 0,
    inputMode: 0,
    integrity: 0,
    is: 0,
    keyParams: 0,
    keyType: 0,
    kind: 0,
    label: 0,
    lang: 0,
    list: 0,
    loop: HAS_BOOLEAN_VALUE,
    low: 0,
    manifest: 0,
    marginHeight: 0,
    marginWidth: 0,
    max: 0,
    maxLength: 0,
    media: 0,
    mediaGroup: 0,
    method: 0,
    min: 0,
    minLength: 0,
    // Caution; `option.selected` is not updated if `select.multiple` is
    // disabled with `removeAttribute`.
    multiple: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
    muted: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
    name: 0,
    nonce: 0,
    noValidate: HAS_BOOLEAN_VALUE,
    open: HAS_BOOLEAN_VALUE,
    optimum: 0,
    pattern: 0,
    placeholder: 0,
    playsInline: HAS_BOOLEAN_VALUE,
    poster: 0,
    preload: 0,
    profile: 0,
    radioGroup: 0,
    readOnly: HAS_BOOLEAN_VALUE,
    referrerPolicy: 0,
    rel: 0,
    required: HAS_BOOLEAN_VALUE,
    reversed: HAS_BOOLEAN_VALUE,
    role: 0,
    rows: HAS_POSITIVE_NUMERIC_VALUE,
    rowSpan: HAS_NUMERIC_VALUE,
    sandbox: 0,
    scope: 0,
    scoped: HAS_BOOLEAN_VALUE,
    scrolling: 0,
    seamless: HAS_BOOLEAN_VALUE,
    selected: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
    shape: 0,
    size: HAS_POSITIVE_NUMERIC_VALUE,
    sizes: 0,
    span: HAS_POSITIVE_NUMERIC_VALUE,
    spellCheck: 0,
    src: 0,
    srcDoc: 0,
    srcLang: 0,
    srcSet: 0,
    start: HAS_NUMERIC_VALUE,
    step: 0,
    style: 0,
    summary: 0,
    tabIndex: 0,
    target: 0,
    title: 0,
    // Setting .type throws on non-<input> tags
    type: 0,
    useMap: 0,
    value: 0,
    width: 0,
    wmode: 0,
    wrap: 0,

    /**
     * RDFa Properties
     */
    about: 0,
    datatype: 0,
    inlist: 0,
    prefix: 0,
    // property is also supported for OpenGraph in meta tags.
    property: 0,
    resource: 0,
    'typeof': 0,
    vocab: 0,

    /**
     * Non-standard Properties
     */
    // autoCapitalize and autoCorrect are supported in Mobile Safari for
    // keyboard hints.
    autoCapitalize: 0,
    autoCorrect: 0,
    // autoSave allows WebKit/Blink to persist values of input fields on page reloads
    autoSave: 0,
    // color is for Safari mask-icon link
    color: 0,
    // itemProp, itemScope, itemType are for
    // Microdata support. See http://schema.org/docs/gs.html
    itemProp: 0,
    itemScope: HAS_BOOLEAN_VALUE,
    itemType: 0,
    // itemID and itemRef are for Microdata support as well but
    // only specified in the WHATWG spec document. See
    // https://html.spec.whatwg.org/multipage/microdata.html#microdata-dom-api
    itemID: 0,
    itemRef: 0,
    // results show looking glass icon and recent searches on input
    // search fields in WebKit/Blink
    results: 0,
    // IE-only attribute that specifies security restrictions on an iframe
    // as an alternative to the sandbox attribute on IE<10
    security: 0,
    // IE-only attribute that controls focus behavior
    unselectable: 0
  },
  DOMAttributeNames: {
    acceptCharset: 'accept-charset',
    className: 'class',
    htmlFor: 'for',
    httpEquiv: 'http-equiv'
  },
  DOMPropertyNames: {},
  DOMMutationMethods: {
    value: function (node, value) {
      if (value == null) {
        return node.removeAttribute('value');
      }

      // Number inputs get special treatment due to some edge cases in
      // Chrome. Let everything else assign the value attribute as normal.
      // https://github.com/facebook/react/issues/7253#issuecomment-236074326
      if (node.type !== 'number' || node.hasAttribute('value') === false) {
        node.setAttribute('value', '' + value);
      } else if (node.validity && !node.validity.badInput && node.ownerDocument.activeElement !== node) {
        // Don't assign an attribute if validation reports bad
        // input. Chrome will clear the value. Additionally, don't
        // operate on inputs that have focus, otherwise Chrome might
        // strip off trailing decimal places and cause the user's
        // cursor position to jump to the beginning of the input.
        //
        // In ReactDOMInput, we have an onBlur event that will trigger
        // this function again when focus is lost.
        node.setAttribute('value', '' + value);
      }
    }
  }
};

module.exports = HTMLDOMPropertyConfig;
},{"./DOMProperty":541}],552:[function(require,module,exports){
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

'use strict';

/**
 * Escape and wrap key so it is safe to use as a reactid
 *
 * @param {string} key to be escaped.
 * @return {string} the escaped key.
 */

function escape(key) {
  var escapeRegex = /[=:]/g;
  var escaperLookup = {
    '=': '=0',
    ':': '=2'
  };
  var escapedString = ('' + key).replace(escapeRegex, function (match) {
    return escaperLookup[match];
  });

  return '$' + escapedString;
}

/**
 * Unescape and unwrap key for human-readable display
 *
 * @param {string} key to unescape.
 * @return {string} the unescaped key.
 */
function unescape(key) {
  var unescapeRegex = /(=0|=2)/g;
  var unescaperLookup = {
    '=0': '=',
    '=2': ':'
  };
  var keySubstring = key[0] === '.' && key[1] === '$' ? key.substring(2) : key.substring(1);

  return ('' + keySubstring).replace(unescapeRegex, function (match) {
    return unescaperLookup[match];
  });
}

var KeyEscapeUtils = {
  escape: escape,
  unescape: unescape
};

module.exports = KeyEscapeUtils;
},{}],553:[function(require,module,exports){
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */

'use strict';

var _prodInvariant = require('./reactProdInvariant');

var ReactPropTypesSecret = require('./ReactPropTypesSecret');
var propTypesFactory = require('prop-types/factory');

var React = require('react/lib/React');
var PropTypes = propTypesFactory(React.isValidElement);

var invariant = require('fbjs/lib/invariant');
var warning = require('fbjs/lib/warning');

var hasReadOnlyValue = {
  button: true,
  checkbox: true,
  image: true,
  hidden: true,
  radio: true,
  reset: true,
  submit: true
};

function _assertSingleLink(inputProps) {
  !(inputProps.checkedLink == null || inputProps.valueLink == null) ? "production" !== 'production' ? invariant(false, 'Cannot provide a checkedLink and a valueLink. If you want to use checkedLink, you probably don\'t want to use valueLink and vice versa.') : _prodInvariant('87') : void 0;
}
function _assertValueLink(inputProps) {
  _assertSingleLink(inputProps);
  !(inputProps.value == null && inputProps.onChange == null) ? "production" !== 'production' ? invariant(false, 'Cannot provide a valueLink and a value or onChange event. If you want to use value or onChange, you probably don\'t want to use valueLink.') : _prodInvariant('88') : void 0;
}

function _assertCheckedLink(inputProps) {
  _assertSingleLink(inputProps);
  !(inputProps.checked == null && inputProps.onChange == null) ? "production" !== 'production' ? invariant(false, 'Cannot provide a checkedLink and a checked property or onChange event. If you want to use checked or onChange, you probably don\'t want to use checkedLink') : _prodInvariant('89') : void 0;
}

var propTypes = {
  value: function (props, propName, componentName) {
    if (!props[propName] || hasReadOnlyValue[props.type] || props.onChange || props.readOnly || props.disabled) {
      return null;
    }
    return new Error('You provided a `value` prop to a form field without an ' + '`onChange` handler. This will render a read-only field. If ' + 'the field should be mutable use `defaultValue`. Otherwise, ' + 'set either `onChange` or `readOnly`.');
  },
  checked: function (props, propName, componentName) {
    if (!props[propName] || props.onChange || props.readOnly || props.disabled) {
      return null;
    }
    return new Error('You provided a `checked` prop to a form field without an ' + '`onChange` handler. This will render a read-only field. If ' + 'the field should be mutable use `defaultChecked`. Otherwise, ' + 'set either `onChange` or `readOnly`.');
  },
  onChange: PropTypes.func
};

var loggedTypeFailures = {};
function getDeclarationErrorAddendum(owner) {
  if (owner) {
    var name = owner.getName();
    if (name) {
      return ' Check the render method of `' + name + '`.';
    }
  }
  return '';
}

/**
 * Provide a linked `value` attribute for controlled forms. You should not use
 * this outside of the ReactDOM controlled form components.
 */
var LinkedValueUtils = {
  checkPropTypes: function (tagName, props, owner) {
    for (var propName in propTypes) {
      if (propTypes.hasOwnProperty(propName)) {
        var error = propTypes[propName](props, propName, tagName, 'prop', null, ReactPropTypesSecret);
      }
      if (error instanceof Error && !(error.message in loggedTypeFailures)) {
        // Only monitor this failure once because there tends to be a lot of the
        // same error.
        loggedTypeFailures[error.message] = true;

        var addendum = getDeclarationErrorAddendum(owner);
        "production" !== 'production' ? warning(false, 'Failed form propType: %s%s', error.message, addendum) : void 0;
      }
    }
  },

  /**
   * @param {object} inputProps Props for form component
   * @return {*} current value of the input either from value prop or link.
   */
  getValue: function (inputProps) {
    if (inputProps.valueLink) {
      _assertValueLink(inputProps);
      return inputProps.valueLink.value;
    }
    return inputProps.value;
  },

  /**
   * @param {object} inputProps Props for form component
   * @return {*} current checked status of the input either from checked prop
   *             or link.
   */
  getChecked: function (inputProps) {
    if (inputProps.checkedLink) {
      _assertCheckedLink(inputProps);
      return inputProps.checkedLink.value;
    }
    return inputProps.checked;
  },

  /**
   * @param {object} inputProps Props for form component
   * @param {SyntheticEvent} event change event to handle
   */
  executeOnChange: function (inputProps, event) {
    if (inputProps.valueLink) {
      _assertValueLink(inputProps);
      return inputProps.valueLink.requestChange(event.target.value);
    } else if (inputProps.checkedLink) {
      _assertCheckedLink(inputProps);
      return inputProps.checkedLink.requestChange(event.target.checked);
    } else if (inputProps.onChange) {
      return inputProps.onChange.call(undefined, event);
    }
  }
};

module.exports = LinkedValueUtils;
},{"./ReactPropTypesSecret":600,"./reactProdInvariant":650,"fbjs/lib/invariant":402,"fbjs/lib/warning":409,"prop-types/factory":492,"react/lib/React":674}],554:[function(require,module,exports){
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

'use strict';

var _prodInvariant = require('./reactProdInvariant');

var invariant = require('fbjs/lib/invariant');

/**
 * Static poolers. Several custom versions for each potential number of
 * arguments. A completely generic pooler is easy to implement, but would
 * require accessing the `arguments` object. In each of these, `this` refers to
 * the Class itself, not an instance. If any others are needed, simply add them
 * here, or in their own files.
 */
var oneArgumentPooler = function (copyFieldsFrom) {
  var Klass = this;
  if (Klass.instancePool.length) {
    var instance = Klass.instancePool.pop();
    Klass.call(instance, copyFieldsFrom);
    return instance;
  } else {
    return new Klass(copyFieldsFrom);
  }
};

var twoArgumentPooler = function (a1, a2) {
  var Klass = this;
  if (Klass.instancePool.length) {
    var instance = Klass.instancePool.pop();
    Klass.call(instance, a1, a2);
    return instance;
  } else {
    return new Klass(a1, a2);
  }
};

var threeArgumentPooler = function (a1, a2, a3) {
  var Klass = this;
  if (Klass.instancePool.length) {
    var instance = Klass.instancePool.pop();
    Klass.call(instance, a1, a2, a3);
    return instance;
  } else {
    return new Klass(a1, a2, a3);
  }
};

var fourArgumentPooler = function (a1, a2, a3, a4) {
  var Klass = this;
  if (Klass.instancePool.length) {
    var instance = Klass.instancePool.pop();
    Klass.call(instance, a1, a2, a3, a4);
    return instance;
  } else {
    return new Klass(a1, a2, a3, a4);
  }
};

var standardReleaser = function (instance) {
  var Klass = this;
  !(instance instanceof Klass) ? "production" !== 'production' ? invariant(false, 'Trying to release an instance into a pool of a different type.') : _prodInvariant('25') : void 0;
  instance.destructor();
  if (Klass.instancePool.length < Klass.poolSize) {
    Klass.instancePool.push(instance);
  }
};

var DEFAULT_POOL_SIZE = 10;
var DEFAULT_POOLER = oneArgumentPooler;

/**
 * Augments `CopyConstructor` to be a poolable class, augmenting only the class
 * itself (statically) not adding any prototypical fields. Any CopyConstructor
 * you give this may have a `poolSize` property, and will look for a
 * prototypical `destructor` on instances.
 *
 * @param {Function} CopyConstructor Constructor that can be used to reset.
 * @param {Function} pooler Customizable pooler.
 */
var addPoolingTo = function (CopyConstructor, pooler) {
  // Casting as any so that flow ignores the actual implementation and trusts
  // it to match the type we declared
  var NewKlass = CopyConstructor;
  NewKlass.instancePool = [];
  NewKlass.getPooled = pooler || DEFAULT_POOLER;
  if (!NewKlass.poolSize) {
    NewKlass.poolSize = DEFAULT_POOL_SIZE;
  }
  NewKlass.release = standardReleaser;
  return NewKlass;
};

var PooledClass = {
  addPoolingTo: addPoolingTo,
  oneArgumentPooler: oneArgumentPooler,
  twoArgumentPooler: twoArgumentPooler,
  threeArgumentPooler: threeArgumentPooler,
  fourArgumentPooler: fourArgumentPooler
};

module.exports = PooledClass;
},{"./reactProdInvariant":650,"fbjs/lib/invariant":402}],555:[function(require,module,exports){
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */

'use strict';

var _assign = require('object-assign');

var EventPluginRegistry = require('./EventPluginRegistry');
var ReactEventEmitterMixin = require('./ReactEventEmitterMixin');
var ViewportMetrics = require('./ViewportMetrics');

var getVendorPrefixedEventName = require('./getVendorPrefixedEventName');
var isEventSupported = require('./isEventSupported');

/**
 * Summary of `ReactBrowserEventEmitter` event handling:
 *
 *  - Top-level delegation is used to trap most native browser events. This
 *    may only occur in the main thread and is the responsibility of
 *    ReactEventListener, which is injected and can therefore support pluggable
 *    event sources. This is the only work that occurs in the main thread.
 *
 *  - We normalize and de-duplicate events to account for browser quirks. This
 *    may be done in the worker thread.
 *
 *  - Forward these native events (with the associated top-level type used to
 *    trap it) to `EventPluginHub`, which in turn will ask plugins if they want
 *    to extract any synthetic events.
 *
 *  - The `EventPluginHub` will then process each event by annotating them with
 *    "dispatches", a sequence of listeners and IDs that care about that event.
 *
 *  - The `EventPluginHub` then dispatches the events.
 *
 * Overview of React and the event system:
 *
 * +------------+    .
 * |    DOM     |    .
 * +------------+    .
 *       |           .
 *       v           .
 * +------------+    .
 * | ReactEvent |    .
 * |  Listener  |    .
 * +------------+    .                         +-----------+
 *       |           .               +--------+|SimpleEvent|
 *       |           .               |         |Plugin     |
 * +-----|------+    .               v         +-----------+
 * |     |      |    .    +--------------+                    +------------+
 * |     +-----------.--->|EventPluginHub|                    |    Event   |
 * |            |    .    |              |     +-----------+  | Propagators|
 * | ReactEvent |    .    |              |     |TapEvent   |  |------------|
 * |  Emitter   |    .    |              |<---+|Plugin     |  |other plugin|
 * |            |    .    |              |     +-----------+  |  utilities |
 * |     +-----------.--->|              |                    +------------+
 * |     |      |    .    +--------------+
 * +-----|------+    .                ^        +-----------+
 *       |           .                |        |Enter/Leave|
 *       +           .                +-------+|Plugin     |
 * +-------------+   .                         +-----------+
 * | application |   .
 * |-------------|   .
 * |             |   .
 * |             |   .
 * +-------------+   .
 *                   .
 *    React Core     .  General Purpose Event Plugin System
 */

var hasEventPageXY;
var alreadyListeningTo = {};
var isMonitoringScrollValue = false;
var reactTopListenersCounter = 0;

// For events like 'submit' which don't consistently bubble (which we trap at a
// lower node than `document`), binding at `document` would cause duplicate
// events so we don't include them here
var topEventMapping = {
  topAbort: 'abort',
  topAnimationEnd: getVendorPrefixedEventName('animationend') || 'animationend',
  topAnimationIteration: getVendorPrefixedEventName('animationiteration') || 'animationiteration',
  topAnimationStart: getVendorPrefixedEventName('animationstart') || 'animationstart',
  topBlur: 'blur',
  topCanPlay: 'canplay',
  topCanPlayThrough: 'canplaythrough',
  topChange: 'change',
  topClick: 'click',
  topCompositionEnd: 'compositionend',
  topCompositionStart: 'compositionstart',
  topCompositionUpdate: 'compositionupdate',
  topContextMenu: 'contextmenu',
  topCopy: 'copy',
  topCut: 'cut',
  topDoubleClick: 'dblclick',
  topDrag: 'drag',
  topDragEnd: 'dragend',
  topDragEnter: 'dragenter',
  topDragExit: 'dragexit',
  topDragLeave: 'dragleave',
  topDragOver: 'dragover',
  topDragStart: 'dragstart',
  topDrop: 'drop',
  topDurationChange: 'durationchange',
  topEmptied: 'emptied',
  topEncrypted: 'encrypted',
  topEnded: 'ended',
  topError: 'error',
  topFocus: 'focus',
  topInput: 'input',
  topKeyDown: 'keydown',
  topKeyPress: 'keypress',
  topKeyUp: 'keyup',
  topLoadedData: 'loadeddata',
  topLoadedMetadata: 'loadedmetadata',
  topLoadStart: 'loadstart',
  topMouseDown: 'mousedown',
  topMouseMove: 'mousemove',
  topMouseOut: 'mouseout',
  topMouseOver: 'mouseover',
  topMouseUp: 'mouseup',
  topPaste: 'paste',
  topPause: 'pause',
  topPlay: 'play',
  topPlaying: 'playing',
  topProgress: 'progress',
  topRateChange: 'ratechange',
  topScroll: 'scroll',
  topSeeked: 'seeked',
  topSeeking: 'seeking',
  topSelectionChange: 'selectionchange',
  topStalled: 'stalled',
  topSuspend: 'suspend',
  topTextInput: 'textInput',
  topTimeUpdate: 'timeupdate',
  topTouchCancel: 'touchcancel',
  topTouchEnd: 'touchend',
  topTouchMove: 'touchmove',
  topTouchStart: 'touchstart',
  topTransitionEnd: getVendorPrefixedEventName('transitionend') || 'transitionend',
  topVolumeChange: 'volumechange',
  topWaiting: 'waiting',
  topWheel: 'wheel'
};

/**
 * To ensure no conflicts with other potential React instances on the page
 */
var topListenersIDKey = '_reactListenersID' + String(Math.random()).slice(2);

function getListeningForDocument(mountAt) {
  // In IE8, `mountAt` is a host object and doesn't have `hasOwnProperty`
  // directly.
  if (!Object.prototype.hasOwnProperty.call(mountAt, topListenersIDKey)) {
    mountAt[topListenersIDKey] = reactTopListenersCounter++;
    alreadyListeningTo[mountAt[topListenersIDKey]] = {};
  }
  return alreadyListeningTo[mountAt[topListenersIDKey]];
}

/**
 * `ReactBrowserEventEmitter` is used to attach top-level event listeners. For
 * example:
 *
 *   EventPluginHub.putListener('myID', 'onClick', myFunction);
 *
 * This would allocate a "registration" of `('onClick', myFunction)` on 'myID'.
 *
 * @internal
 */
var ReactBrowserEventEmitter = _assign({}, ReactEventEmitterMixin, {
  /**
   * Injectable event backend
   */
  ReactEventListener: null,

  injection: {
    /**
     * @param {object} ReactEventListener
     */
    injectReactEventListener: function (ReactEventListener) {
      ReactEventListener.setHandleTopLevel(ReactBrowserEventEmitter.handleTopLevel);
      ReactBrowserEventEmitter.ReactEventListener = ReactEventListener;
    }
  },

  /**
   * Sets whether or not any created callbacks should be enabled.
   *
   * @param {boolean} enabled True if callbacks should be enabled.
   */
  setEnabled: function (enabled) {
    if (ReactBrowserEventEmitter.ReactEventListener) {
      ReactBrowserEventEmitter.ReactEventListener.setEnabled(enabled);
    }
  },

  /**
   * @return {boolean} True if callbacks are enabled.
   */
  isEnabled: function () {
    return !!(ReactBrowserEventEmitter.ReactEventListener && ReactBrowserEventEmitter.ReactEventListener.isEnabled());
  },

  /**
   * We listen for bubbled touch events on the document object.
   *
   * Firefox v8.01 (and possibly others) exhibited strange behavior when
   * mounting `onmousemove` events at some node that was not the document
   * element. The symptoms were that if your mouse is not moving over something
   * contained within that mount point (for example on the background) the
   * top-level listeners for `onmousemove` won't be called. However, if you
   * register the `mousemove` on the document object, then it will of course
   * catch all `mousemove`s. This along with iOS quirks, justifies restricting
   * top-level listeners to the document object only, at least for these
   * movement types of events and possibly all events.
   *
   * @see http://www.quirksmode.org/blog/archives/2010/09/click_event_del.html
   *
   * Also, `keyup`/`keypress`/`keydown` do not bubble to the window on IE, but
   * they bubble to document.
   *
   * @param {string} registrationName Name of listener (e.g. `onClick`).
   * @param {object} contentDocumentHandle Document which owns the container
   */
  listenTo: function (registrationName, contentDocumentHandle) {
    var mountAt = contentDocumentHandle;
    var isListening = getListeningForDocument(mountAt);
    var dependencies = EventPluginRegistry.registrationNameDependencies[registrationName];

    for (var i = 0; i < dependencies.length; i++) {
      var dependency = dependencies[i];
      if (!(isListening.hasOwnProperty(dependency) && isListening[dependency])) {
        if (dependency === 'topWheel') {
          if (isEventSupported('wheel')) {
            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent('topWheel', 'wheel', mountAt);
          } else if (isEventSupported('mousewheel')) {
            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent('topWheel', 'mousewheel', mountAt);
          } else {
            // Firefox needs to capture a different mouse scroll event.
            // @see http://www.quirksmode.org/dom/events/tests/scroll.html
            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent('topWheel', 'DOMMouseScroll', mountAt);
          }
        } else if (dependency === 'topScroll') {
          if (isEventSupported('scroll', true)) {
            ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent('topScroll', 'scroll', mountAt);
          } else {
            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent('topScroll', 'scroll', ReactBrowserEventEmitter.ReactEventListener.WINDOW_HANDLE);
          }
        } else if (dependency === 'topFocus' || dependency === 'topBlur') {
          if (isEventSupported('focus', true)) {
            ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent('topFocus', 'focus', mountAt);
            ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent('topBlur', 'blur', mountAt);
          } else if (isEventSupported('focusin')) {
            // IE has `focusin` and `focusout` events which bubble.
            // @see http://www.quirksmode.org/blog/archives/2008/04/delegating_the.html
            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent('topFocus', 'focusin', mountAt);
            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent('topBlur', 'focusout', mountAt);
          }

          // to make sure blur and focus event listeners are only attached once
          isListening.topBlur = true;
          isListening.topFocus = true;
        } else if (topEventMapping.hasOwnProperty(dependency)) {
          ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(dependency, topEventMapping[dependency], mountAt);
        }

        isListening[dependency] = true;
      }
    }
  },

  trapBubbledEvent: function (topLevelType, handlerBaseName, handle) {
    return ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelType, handlerBaseName, handle);
  },

  trapCapturedEvent: function (topLevelType, handlerBaseName, handle) {
    return ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent(topLevelType, handlerBaseName, handle);
  },

  /**
   * Protect against document.createEvent() returning null
   * Some popup blocker extensions appear to do this:
   * https://github.com/facebook/react/issues/6887
   */
  supportsEventPageXY: function () {
    if (!document.createEvent) {
      return false;
    }
    var ev = document.createEvent('MouseEvent');
    return ev != null && 'pageX' in ev;
  },

  /**
   * Listens to window scroll and resize events. We cache scroll values so that
   * application code can access them without triggering reflows.
   *
   * ViewportMetrics is only used by SyntheticMouse/TouchEvent and only when
   * pageX/pageY isn't supported (legacy browsers).
   *
   * NOTE: Scroll events do not bubble.
   *
   * @see http://www.quirksmode.org/dom/events/scroll.html
   */
  ensureScrollValueMonitoring: function () {
    if (hasEventPageXY === undefined) {
      hasEventPageXY = ReactBrowserEventEmitter.supportsEventPageXY();
    }
    if (!hasEventPageXY && !isMonitoringScrollValue) {
      var refresh = ViewportMetrics.refreshScrollValues;
      ReactBrowserEventEmitter.ReactEventListener.monitorScrollValue(refresh);
      isMonitoringScrollValue = true;
    }
  }
});

module.exports = ReactBrowserEventEmitter;
},{"./EventPluginRegistry":547,"./ReactEventEmitterMixin":584,"./ViewportMetrics":626,"./getVendorPrefixedEventName":644,"./isEventSupported":647,"object-assign":489}],556:[function(require,module,exports){
(function (process){
/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */

'use strict';

var ReactReconciler = require('./ReactReconciler');

var instantiateReactComponent = require('./instantiateReactComponent');
var KeyEscapeUtils = require('./KeyEscapeUtils');
var shouldUpdateReactComponent = require('./shouldUpdateReactComponent');
var traverseAllChildren = require('./traverseAllChildren');
var warning = require('fbjs/lib/warning');

var ReactComponentTreeHook;

if (typeof process !== 'undefined' && process.env && "production" === 'test') {
  // Temporary hack.
  // Inline requires don't work well with Jest:
  // https://github.com/facebook/react/issues/7240
  // Remove the inline requires when we don't need them anymore:
  // https://github.com/facebook/react/pull/7178
  ReactComponentTreeHook = require('react/lib/ReactComponentTreeHook');
}

function instantiateChild(childInstances, child, name, selfDebugID) {
  // We found a component instance.
  var keyUnique = childInstances[name] === undefined;
  if ("production" !== 'production') {
    if (!ReactComponentTreeHook) {
      ReactComponentTreeHook = require('react/lib/ReactComponentTreeHook');
    }
    if (!keyUnique) {
      "production" !== 'production' ? warning(false, 'flattenChildren(...): Encountered two children with the same key, ' + '`%s`. Child keys must be unique; when two children share a key, only ' + 'the first child will be used.%s', KeyEscapeUtils.unescape(name), ReactComponentTreeHook.getStackAddendumByID(selfDebugID)) : void 0;
    }
  }
  if (child != null && keyUnique) {
    childInstances[name] = instantiateReactComponent(child, true);
  }
}

/**
 * ReactChildReconciler provides helpers for initializing or updating a set of
 * children. Its output is suitable for passing it onto ReactMultiChild which
 * does diffed reordering and insertion.
 */
var ReactChildReconciler = {
  /**
   * Generates a "mount image" for each of the supplied children. In the case
   * of `ReactDOMComponent`, a mount image is a string of markup.
   *
   * @param {?object} nestedChildNodes Nested child maps.
   * @return {?object} A set of child instances.
   * @internal
   */
  instantiateChildren: function (nestedChildNodes, transaction, context, selfDebugID) // 0 in production and for roots
  {
    if (nestedChildNodes == null) {
      return null;
    }
    var childInstances = {};

    if ("production" !== 'production') {
      traverseAllChildren(nestedChildNodes, function (childInsts, child, name) {
        return instantiateChild(childInsts, child, name, selfDebugID);
      }, childInstances);
    } else {
      traverseAllChildren(nestedChildNodes, instantiateChild, childInstances);
    }
    return childInstances;
  },

  /**
   * Updates the rendered children and returns a new set of children.
   *
   * @param {?object} prevChildren Previously initialized set of children.
   * @param {?object} nextChildren Flat child element maps.
   * @param {ReactReconcileTransaction} transaction
   * @param {object} context
   * @return {?object} A new set of child instances.
   * @internal
   */
  updateChildren: function (prevChildren, nextChildren, mountImages, removedNodes, transaction, hostParent, hostContainerInfo, context, selfDebugID) // 0 in production and for roots
  {
    // We currently don't have a way to track moves here but if we use iterators
    // instead of for..in we can zip the iterators and check if an item has
    // moved.
    // TODO: If nothing has changed, return the prevChildren object so that we
    // can quickly bailout if nothing has changed.
    if (!nextChildren && !prevChildren) {
      return;
    }
    var name;
    var prevChild;
    for (name in nextChildren) {
      if (!nextChildren.hasOwnProperty(name)) {
        continue;
      }
      prevChild = prevChildren && prevChildren[name];
      var prevElement = prevChild && prevChild._currentElement;
      var nextElement = nextChildren[name];
      if (prevChild != null && shouldUpdateReactComponent(prevElement, nextElement)) {
        ReactReconciler.receiveComponent(prevChild, nextElement, transaction, context);
        nextChildren[name] = prevChild;
      } else {
        if (prevChild) {
          removedNodes[name] = ReactReconciler.getHostNode(prevChild);
          ReactReconciler.unmountComponent(prevChild, false);
        }
        // The child must be instantiated before it's mounted.
        var nextChildInstance = instantiateReactComponent(nextElement, true);
        nextChildren[name] = nextChildInstance;
        // Creating mount image now ensures refs are resolved in right order
        // (see https://github.com/facebook/react/pull/7101 for explanation).
        var nextChildMountImage = ReactReconciler.mountComponent(nextChildInstance, transaction, hostParent, hostContainerInfo, context, selfDebugID);
        mountImages.push(nextChildMountImage);
      }
    }
    // Unmount children that are no longer present.
    for (name in prevChildren) {
      if (prevChildren.hasOwnProperty(name) && !(nextChildren && nextChildren.hasOwnProperty(name))) {
        prevChild = prevChildren[name];
        removedNodes[name] = ReactReconciler.getHostNode(prevChild);
        ReactReconciler.unmountComponent(prevChild, false);
      }
    }
  },

  /**
   * Unmounts all rendered children. This should be used to clean up children
   * when this component is unmounted.
   *
   * @param {?object} renderedChildren Previously initialized set of children.
   * @internal
   */
  unmountChildren: function (renderedChildren, safely) {
    for (var name in renderedChildren) {
      if (renderedChildren.hasOwnProperty(name)) {
        var renderedChild = renderedChildren[name];
        ReactReconciler.unmountComponent(renderedChild, safely);
      }
    }
  }
};

module.exports = ReactChildReconciler;
}).call(this,require('_process'))
},{"./KeyEscapeUtils":552,"./ReactReconciler":602,"./instantiateReactComponent":646,"./shouldUpdateReactComponent":654,"./traverseAllChildren":655,"_process":490,"fbjs/lib/warning":409,"react/lib/ReactComponentTreeHook":677}],557:[function(require,module,exports){
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */

'use strict';

var DOMChildrenOperations = require('./DOMChildrenOperations');
var ReactDOMIDOperations = require('./ReactDOMIDOperations');

/**
 * Abstracts away all functionality of the reconciler that requires knowledge of
 * the browser context. TODO: These callers should be refactored to avoid the
 * need for this injection.
 */
var ReactComponentBrowserEnvironment = {
  processChildrenUpdates: ReactDOMIDOperations.dangerouslyProcessChildrenUpdates,

  replaceNodeWithMarkup: DOMChildrenOperations.dangerouslyReplaceNodeWithMarkup
};

module.exports = ReactComponentBrowserEnvironment;
},{"./DOMChildrenOperations":538,"./ReactDOMIDOperations":567}],558:[function(require,module,exports){
/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

'use strict';

var _prodInvariant = require('./reactProdInvariant');

var invariant = require('fbjs/lib/invariant');

var injected = false;

var ReactComponentEnvironment = {
  /**
   * Optionally injectable hook for swapping out mount images in the middle of
   * the tree.
   */
  replaceNodeWithMarkup: null,

  /**
   * Optionally injectable hook for processing a queue of child updates. Will
   * later move into MultiChildComponents.
   */
  processChildrenUpdates: null,

  injection: {
    injectEnvironment: function (environment) {
      !!injected ? "production" !== 'production' ? invariant(false, 'ReactCompositeComponent: injectEnvironment() can only be called once.') : _prodInvariant('104') : void 0;
      ReactComponentEnvironment.replaceNodeWithMarkup = environment.replaceNodeWithMarkup;
      ReactComponentEnvironment.processChildrenUpdates = environment.processChildrenUpdates;
      injected = true;
    }
  }
};

module.exports = ReactComponentEnvironment;
},{"./reactProdInvariant":650,"fbjs/lib/invariant":402}],559:[function(require,module,exports){
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */

'use strict';

var _prodInvariant = require('./reactProdInvariant'),
    _assign = require('object-assign');

var React = require('react/lib/React');
var ReactComponentEnvironment = require('./ReactComponentEnvironment');
var ReactCurrentOwner = require('react/lib/ReactCurrentOwner');
var ReactErrorUtils = require('./ReactErrorUtils');
var ReactInstanceMap = require('./ReactInstanceMap');
var ReactInstrumentation = require('./ReactInstrumentation');
var ReactNodeTypes = require('./ReactNodeTypes');
var ReactReconciler = require('./ReactReconciler');

if ("production" !== 'production') {
  var checkReactTypeSpec = require('./checkReactTypeSpec');
}

var emptyObject = require('fbjs/lib/emptyObject');
var invariant = require('fbjs/lib/invariant');
var shallowEqual = require('fbjs/lib/shallowEqual');
var shouldUpdateReactComponent = require('./shouldUpdateReactComponent');
var warning = require('fbjs/lib/warning');

var CompositeTypes = {
  ImpureClass: 0,
  PureClass: 1,
  StatelessFunctional: 2
};

function StatelessComponent(Component) {}
StatelessComponent.prototype.render = function () {
  var Component = ReactInstanceMap.get(this)._currentElement.type;
  var element = Component(this.props, this.context, this.updater);
  warnIfInvalidElement(Component, element);
  return element;
};

function warnIfInvalidElement(Component, element) {
  if ("production" !== 'production') {
    "production" !== 'production' ? warning(element === null || element === false || React.isValidElement(element), '%s(...): A valid React element (or null) must be returned. You may have ' + 'returned undefined, an array or some other invalid object.', Component.displayName || Component.name || 'Component') : void 0;
    "production" !== 'production' ? warning(!Component.childContextTypes, '%s(...): childContextTypes cannot be defined on a functional component.', Component.displayName || Component.name || 'Component') : void 0;
  }
}

function shouldConstruct(Component) {
  return !!(Component.prototype && Component.prototype.isReactComponent);
}

function isPureComponent(Component) {
  return !!(Component.prototype && Component.prototype.isPureReactComponent);
}

// Separated into a function to contain deoptimizations caused by try/finally.
function measureLifeCyclePerf(fn, debugID, timerType) {
  if (debugID === 0) {
    // Top-level wrappers (see ReactMount) and empty components (see
    // ReactDOMEmptyComponent) are invisible to hooks and devtools.
    // Both are implementation details that should go away in the future.
    return fn();
  }

  ReactInstrumentation.debugTool.onBeginLifeCycleTimer(debugID, timerType);
  try {
    return fn();
  } finally {
    ReactInstrumentation.debugTool.onEndLifeCycleTimer(debugID, timerType);
  }
}

/**
 * ------------------ The Life-Cycle of a Composite Component ------------------
 *
 * - constructor: Initialization of state. The instance is now retained.
 *   - componentWillMount
 *   - render
 *   - [children's constructors]
 *     - [children's componentWillMount and render]
 *     - [children's componentDidMount]
 *     - componentDidMount
 *
 *       Update Phases:
 *       - componentWillReceiveProps (only called if parent updated)
 *       - shouldComponentUpdate
 *         - componentWillUpdate
 *           - render
 *           - [children's constructors or receive props phases]
 *         - componentDidUpdate
 *
 *     - componentWillUnmount
 *     - [children's componentWillUnmount]
 *   - [children destroyed]
 * - (destroyed): The instance is now blank, released by React and ready for GC.
 *
 * -----------------------------------------------------------------------------
 */

/**
 * An incrementing ID assigned to each component when it is mounted. This is
 * used to enforce the order in which `ReactUpdates` updates dirty components.
 *
 * @private
 */
var nextMountID = 1;

/**
 * @lends {ReactCompositeComponent.prototype}
 */
var ReactCompositeComponent = {
  /**
   * Base constructor for all composite component.
   *
   * @param {ReactElement} element
   * @final
   * @internal
   */
  construct: function (element) {
    this._currentElement = element;
    this._rootNodeID = 0;
    this._compositeType = null;
    this._instance = null;
    this._hostParent = null;
    this._hostContainerInfo = null;

    // See ReactUpdateQueue
    this._updateBatchNumber = null;
    this._pendingElement = null;
    this._pendingStateQueue = null;
    this._pendingReplaceState = false;
    this._pendingForceUpdate = false;

    this._renderedNodeType = null;
    this._renderedComponent = null;
    this._context = null;
    this._mountOrder = 0;
    this._topLevelWrapper = null;

    // See ReactUpdates and ReactUpdateQueue.
    this._pendingCallbacks = null;

    // ComponentWillUnmount shall only be called once
    this._calledComponentWillUnmount = false;

    if ("production" !== 'production') {
      this._warnedAboutRefsInRender = false;
    }
  },

  /**
   * Initializes the component, renders markup, and registers event listeners.
   *
   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
   * @param {?object} hostParent
   * @param {?object} hostContainerInfo
   * @param {?object} context
   * @return {?string} Rendered markup to be inserted into the DOM.
   * @final
   * @internal
   */
  mountComponent: function (transaction, hostParent, hostContainerInfo, context) {
    var _this = this;

    this._context = context;
    this._mountOrder = nextMountID++;
    this._hostParent = hostParent;
    this._hostContainerInfo = hostContainerInfo;

    var publicProps = this._currentElement.props;
    var publicContext = this._processContext(context);

    var Component = this._currentElement.type;

    var updateQueue = transaction.getUpdateQueue();

    // Initialize the public class
    var doConstruct = shouldConstruct(Component);
    var inst = this._constructComponent(doConstruct, publicProps, publicContext, updateQueue);
    var renderedElement;

    // Support functional components
    if (!doConstruct && (inst == null || inst.render == null)) {
      renderedElement = inst;
      warnIfInvalidElement(Component, renderedElement);
      !(inst === null || inst === false || React.isValidElement(inst)) ? "production" !== 'production' ? invariant(false, '%s(...): A valid React element (or null) must be returned. You may have returned undefined, an array or some other invalid object.', Component.displayName || Component.name || 'Component') : _prodInvariant('105', Component.displayName || Component.name || 'Component') : void 0;
      inst = new StatelessComponent(Component);
      this._compositeType = CompositeTypes.StatelessFunctional;
    } else {
      if (isPureComponent(Component)) {
        this._compositeType = CompositeTypes.PureClass;
      } else {
        this._compositeType = CompositeTypes.ImpureClass;
      }
    }

    if ("production" !== 'production') {
      // This will throw later in _renderValidatedComponent, but add an early
      // warning now to help debugging
      if (inst.render == null) {
        "production" !== 'production' ? warning(false, '%s(...): No `render` method found on the returned component ' + 'instance: you may have forgotten to define `render`.', Component.displayName || Component.name || 'Component') : void 0;
      }

      var propsMutated = inst.props !== publicProps;
      var componentName = Component.displayName || Component.name || 'Component';

      "production" !== 'production' ? warning(inst.props === undefined || !propsMutated, '%s(...): When calling super() in `%s`, make sure to pass ' + "up the same props that your component's constructor was passed.", componentName, componentName) : void 0;
    }

    // These should be set up in the constructor, but as a convenience for
    // simpler class abstractions, we set them up after the fact.
    inst.props = publicProps;
    inst.context = publicContext;
    inst.refs = emptyObject;
    inst.updater = updateQueue;

    this._instance = inst;

    // Store a reference from the instance back to the internal representation
    ReactInstanceMap.set(inst, this);

    if ("production" !== 'production') {
      // Since plain JS classes are defined without any special initialization
      // logic, we can not catch common errors early. Therefore, we have to
      // catch them here, at initialization time, instead.
      "production" !== 'production' ? warning(!inst.getInitialState || inst.getInitialState.isReactClassApproved || inst.state, 'getInitialState was defined on %s, a plain JavaScript class. ' + 'This is only supported for classes created using React.createClass. ' + 'Did you mean to define a state property instead?', this.getName() || 'a component') : void 0;
      "production" !== 'production' ? warning(!inst.getDefaultProps || inst.getDefaultProps.isReactClassApproved, 'getDefaultProps was defined on %s, a plain JavaScript class. ' + 'This is only supported for classes created using React.createClass. ' + 'Use a static property to define defaultProps instead.', this.getName() || 'a component') : void 0;
      "production" !== 'production' ? warning(!inst.propTypes, 'propTypes was defined as an instance property on %s. Use a static ' + 'property to define propTypes instead.', this.getName() || 'a component') : void 0;
      "production" !== 'production' ? warning(!inst.contextTypes, 'contextTypes was defined as an instance property on %s. Use a ' + 'static property to define contextTypes instead.', this.getName() || 'a component') : void 0;
      "production" !== 'production' ? warning(typeof inst.componentShouldUpdate !== 'function', '%s has a method called ' + 'componentShouldUpdate(). Did you mean shouldComponentUpdate()? ' + 'The name is phrased as a question because the function is ' + 'expected to return a value.', this.getName() || 'A component') : void 0;
      "production" !== 'production' ? warning(typeof inst.componentDidUnmount !== 'function', '%s has a method called ' + 'componentDidUnmount(). But there is no such lifecycle method. ' + 'Did you mean componentWillUnmount()?', this.getName() || 'A component') : void 0;
      "production" !== 'production' ? warning(typeof inst.componentWillRecieveProps !== 'function', '%s has a method called ' + 'componentWillRecieveProps(). Did you mean componentWillReceiveProps()?', this.getName() || 'A component') : void 0;
    }

    var initialState = inst.state;
    if (initialState === undefined) {
      inst.state = initialState = null;
    }
    !(typeof initialState === 'object' && !Array.isArray(initialState)) ? "production" !== 'production' ? invariant(false, '%s.state: must be set to an object or null', this.getName() || 'ReactCompositeComponent') : _prodInvariant('106', this.getName() || 'ReactCompositeComponent') : void 0;

    this._pendingStateQueue = null;
    this._pendingReplaceState = false;
    this._pendingForceUpdate = false;

    var markup;
    if (inst.unstable_handleError) {
      markup = this.performInitialMountWithErrorHandling(renderedElement, hostParent, hostContainerInfo, transaction, context);
    } else {
      markup = this.performInitialMount(renderedElement, hostParent, hostContainerInfo, transaction, context);
    }

    if (inst.componentDidMount) {
      if ("production" !== 'production') {
        transaction.getReactMountReady().enqueue(function () {
          measureLifeCyclePerf(function () {
            return inst.componentDidMount();
          }, _this._debugID, 'componentDidMount');
        });
      } else {
        transaction.getReactMountReady().enqueue(inst.componentDidMount, inst);
      }
    }

    return markup;
  },

  _constructComponent: function (doConstruct, publicProps, publicContext, updateQueue) {
    if ("production" !== 'production' && !doConstruct) {
      ReactCurrentOwner.current = this;
      try {
        return this._constructComponentWithoutOwner(doConstruct, publicProps, publicContext, updateQueue);
      } finally {
        ReactCurrentOwner.current = null;
      }
    } else {
      return this._constructComponentWithoutOwner(doConstruct, publicProps, publicContext, updateQueue);
    }
  },

  _constructComponentWithoutOwner: function (doConstruct, publicProps, publicContext, updateQueue) {
    var Component = this._currentElement.type;

    if (doConstruct) {
      if ("production" !== 'production') {
        return measureLifeCyclePerf(function () {
          return new Component(publicProps, publicContext, updateQueue);
        }, this._debugID, 'ctor');
      } else {
        return new Component(publicProps, publicContext, updateQueue);
      }
    }

    // This can still be an instance in case of factory components
    // but we'll count this as time spent rendering as the more common case.
    if ("production" !== 'production') {
      return measureLifeCyclePerf(function () {
        return Component(publicProps, publicContext, updateQueue);
      }, this._debugID, 'render');
    } else {
      return Component(publicProps, publicContext, updateQueue);
    }
  },

  performInitialMountWithErrorHandling: function (renderedElement, hostParent, hostContainerInfo, transaction, context) {
    var markup;
    var checkpoint = transaction.checkpoint();
    try {
      markup = this.performInitialMount(renderedElement, hostParent, hostContainerInfo, transaction, context);
    } catch (e) {
      // Roll back to checkpoint, handle error (which may add items to the transaction), and take a new checkpoint
      transaction.rollback(checkpoint);
      this._instance.unstable_handleError(e);
      if (this._pendingStateQueue) {
        this._instance.state = this._processPendingState(this._instance.props, this._instance.context);
      }
      checkpoint = transaction.checkpoint();

      this._renderedComponent.unmountComponent(true);
      transaction.rollback(checkpoint);

      // Try again - we've informed the component about the error, so they can render an error message this time.
      // If this throws again, the error will bubble up (and can be caught by a higher error boundary).
      markup = this.performInitialMount(renderedElement, hostParent, hostContainerInfo, transaction, context);
    }
    return markup;
  },

  performInitialMount: function (renderedElement, hostParent, hostContainerInfo, transaction, context) {
    var inst = this._instance;

    var debugID = 0;
    if ("production" !== 'production') {
      debugID = this._debugID;
    }

    if (inst.componentWillMount) {
      if ("production" !== 'production') {
        measureLifeCyclePerf(function () {
          return inst.componentWillMount();
        }, debugID, 'componentWillMount');
      } else {
        inst.componentWillMount();
      }
      // When mounting, calls to `setState` by `componentWillMount` will set
      // `this._pendingStateQueue` without triggering a re-render.
      if (this._pendingStateQueue) {
        inst.state = this._processPendingState(inst.props, inst.context);
      }
    }

    // If not a stateless component, we now render
    if (renderedElement === undefined) {
      renderedElement = this._renderValidatedComponent();
    }

    var nodeType = ReactNodeTypes.getType(renderedElement);
    this._renderedNodeType = nodeType;
    var child = this._instantiateReactComponent(renderedElement, nodeType !== ReactNodeTypes.EMPTY /* shouldHaveDebugID */
    );
    this._renderedComponent = child;

    var markup = ReactReconciler.mountComponent(child, transaction, hostParent, hostContainerInfo, this._processChildContext(context), debugID);

    if ("production" !== 'production') {
      if (debugID !== 0) {
        var childDebugIDs = child._debugID !== 0 ? [child._debugID] : [];
        ReactInstrumentation.debugTool.onSetChildren(debugID, childDebugIDs);
      }
    }

    return markup;
  },

  getHostNode: function () {
    return ReactReconciler.getHostNode(this._renderedComponent);
  },

  /**
   * Releases any resources allocated by `mountComponent`.
   *
   * @final
   * @internal
   */
  unmountComponent: function (safely) {
    if (!this._renderedComponent) {
      return;
    }

    var inst = this._instance;

    if (inst.componentWillUnmount && !inst._calledComponentWillUnmount) {
      inst._calledComponentWillUnmount = true;

      if (safely) {
        var name = this.getName() + '.componentWillUnmount()';
        ReactErrorUtils.invokeGuardedCallback(name, inst.componentWillUnmount.bind(inst));
      } else {
        if ("production" !== 'production') {
          measureLifeCyclePerf(function () {
            return inst.componentWillUnmount();
          }, this._debugID, 'componentWillUnmount');
        } else {
          inst.componentWillUnmount();
        }
      }
    }

    if (this._renderedComponent) {
      ReactReconciler.unmountComponent(this._renderedComponent, safely);
      this._renderedNodeType = null;
      this._renderedComponent = null;
      this._instance = null;
    }

    // Reset pending fields
    // Even if this component is scheduled for another update in ReactUpdates,
    // it would still be ignored because these fields are reset.
    this._pendingStateQueue = null;
    this._pendingReplaceState = false;
    this._pendingForceUpdate = false;
    this._pendingCallbacks = null;
    this._pendingElement = null;

    // These fields do not really need to be reset since this object is no
    // longer accessible.
    this._context = null;
    this._rootNodeID = 0;
    this._topLevelWrapper = null;

    // Delete the reference from the instance to this internal representation
    // which allow the internals to be properly cleaned up even if the user
    // leaks a reference to the public instance.
    ReactInstanceMap.remove(inst);

    // Some existing components rely on inst.props even after they've been
    // destroyed (in event handlers).
    // TODO: inst.props = null;
    // TODO: inst.state = null;
    // TODO: inst.context = null;
  },

  /**
   * Filters the context object to only contain keys specified in
   * `contextTypes`
   *
   * @param {object} context
   * @return {?object}
   * @private
   */
  _maskContext: function (context) {
    var Component = this._currentElement.type;
    var contextTypes = Component.contextTypes;
    if (!contextTypes) {
      return emptyObject;
    }
    var maskedContext = {};
    for (var contextName in contextTypes) {
      maskedContext[contextName] = context[contextName];
    }
    return maskedContext;
  },

  /**
   * Filters the context object to only contain keys specified in
   * `contextTypes`, and asserts that they are valid.
   *
   * @param {object} context
   * @return {?object}
   * @private
   */
  _processContext: function (context) {
    var maskedContext = this._maskContext(context);
    if ("production" !== 'production') {
      var Component = this._currentElement.type;
      if (Component.contextTypes) {
        this._checkContextTypes(Component.contextTypes, maskedContext, 'context');
      }
    }
    return maskedContext;
  },

  /**
   * @param {object} currentContext
   * @return {object}
   * @private
   */
  _processChildContext: function (currentContext) {
    var Component = this._currentElement.type;
    var inst = this._instance;
    var childContext;

    if (inst.getChildContext) {
      if ("production" !== 'production') {
        ReactInstrumentation.debugTool.onBeginProcessingChildContext();
        try {
          childContext = inst.getChildContext();
        } finally {
          ReactInstrumentation.debugTool.onEndProcessingChildContext();
        }
      } else {
        childContext = inst.getChildContext();
      }
    }

    if (childContext) {
      !(typeof Component.childContextTypes === 'object') ? "production" !== 'production' ? invariant(false, '%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().', this.getName() || 'ReactCompositeComponent') : _prodInvariant('107', this.getName() || 'ReactCompositeComponent') : void 0;
      if ("production" !== 'production') {
        this._checkContextTypes(Component.childContextTypes, childContext, 'child context');
      }
      for (var name in childContext) {
        !(name in Component.childContextTypes) ? "production" !== 'production' ? invariant(false, '%s.getChildContext(): key "%s" is not defined in childContextTypes.', this.getName() || 'ReactCompositeComponent', name) : _prodInvariant('108', this.getName() || 'ReactCompositeComponent', name) : void 0;
      }
      return _assign({}, currentContext, childContext);
    }
    return currentContext;
  },

  /**
   * Assert that the context types are valid
   *
   * @param {object} typeSpecs Map of context field to a ReactPropType
   * @param {object} values Runtime values that need to be type-checked
   * @param {string} location e.g. "prop", "context", "child context"
   * @private
   */
  _checkContextTypes: function (typeSpecs, values, location) {
    if ("production" !== 'production') {
      checkReactTypeSpec(typeSpecs, values, location, this.getName(), null, this._debugID);
    }
  },

  receiveComponent: function (nextElement, transaction, nextContext) {
    var prevElement = this._currentElement;
    var prevContext = this._context;

    this._pendingElement = null;

    this.updateComponent(transaction, prevElement, nextElement, prevContext, nextContext);
  },

  /**
   * If any of `_pendingElement`, `_pendingStateQueue`, or `_pendingForceUpdate`
   * is set, update the component.
   *
   * @param {ReactReconcileTransaction} transaction
   * @internal
   */
  performUpdateIfNecessary: function (transaction) {
    if (this._pendingElement != null) {
      ReactReconciler.receiveComponent(this, this._pendingElement, transaction, this._context);
    } else if (this._pendingStateQueue !== null || this._pendingForceUpdate) {
      this.updateComponent(transaction, this._currentElement, this._currentElement, this._context, this._context);
    } else {
      this._updateBatchNumber = null;
    }
  },

  /**
   * Perform an update to a mounted component. The componentWillReceiveProps and
   * shouldComponentUpdate methods are called, then (assuming the update isn't
   * skipped) the remaining update lifecycle methods are called and the DOM
   * representation is updated.
   *
   * By default, this implements React's rendering and reconciliation algorithm.
   * Sophisticated clients may wish to override this.
   *
   * @param {ReactReconcileTransaction} transaction
   * @param {ReactElement} prevParentElement
   * @param {ReactElement} nextParentElement
   * @internal
   * @overridable
   */
  updateComponent: function (transaction, prevParentElement, nextParentElement, prevUnmaskedContext, nextUnmaskedContext) {
    var inst = this._instance;
    !(inst != null) ? "production" !== 'production' ? invariant(false, 'Attempted to update component `%s` that has already been unmounted (or failed to mount).', this.getName() || 'ReactCompositeComponent') : _prodInvariant('136', this.getName() || 'ReactCompositeComponent') : void 0;

    var willReceive = false;
    var nextContext;

    // Determine if the context has changed or not
    if (this._context === nextUnmaskedContext) {
      nextContext = inst.context;
    } else {
      nextContext = this._processContext(nextUnmaskedContext);
      willReceive = true;
    }

    var prevProps = prevParentElement.props;
    var nextProps = nextParentElement.props;

    // Not a simple state update but a props update
    if (prevParentElement !== nextParentElement) {
      willReceive = true;
    }

    // An update here will schedule an update but immediately set
    // _pendingStateQueue which will ensure that any state updates gets
    // immediately reconciled instead of waiting for the next batch.
    if (willReceive && inst.componentWillReceiveProps) {
      if ("production" !== 'production') {
        measureLifeCyclePerf(function () {
          return inst.componentWillReceiveProps(nextProps, nextContext);
        }, this._debugID, 'componentWillReceiveProps');
      } else {
        inst.componentWillReceiveProps(nextProps, nextContext);
      }
    }

    var nextState = this._processPendingState(nextProps, nextContext);
    var shouldUpdate = true;

    if (!this._pendingForceUpdate) {
      if (inst.shouldComponentUpdate) {
        if ("production" !== 'production') {
          shouldUpdate = measureLifeCyclePerf(function () {
            return inst.shouldComponentUpdate(nextProps, nextState, nextContext);
          }, this._debugID, 'shouldComponentUpdate');
        } else {
          shouldUpdate = inst.shouldComponentUpdate(nextProps, nextState, nextContext);
        }
      } else {
        if (this._compositeType === CompositeTypes.PureClass) {
          shouldUpdate = !shallowEqual(prevProps, nextProps) || !shallowEqual(inst.state, nextState);
        }
      }
    }

    if ("production" !== 'production') {
      "production" !== 'production' ? warning(shouldUpdate !== undefined, '%s.shouldComponentUpdate(): Returned undefined instead of a ' + 'boolean value. Make sure to return true or false.', this.getName() || 'ReactCompositeComponent') : void 0;
    }

    this._updateBatchNumber = null;
    if (shouldUpdate) {
      this._pendingForceUpdate = false;
      // Will set `this.props`, `this.state` and `this.context`.
      this._performComponentUpdate(nextParentElement, nextProps, nextState, nextContext, transaction, nextUnmaskedContext);
    } else {
      // If it's determined that a component should not update, we still want
      // to set props and state but we shortcut the rest of the update.
      this._currentElement = nextParentElement;
      this._context = nextUnmaskedContext;
      inst.props = nextProps;
      inst.state = nextState;
      inst.context = nextContext;
    }
  },

  _processPendingState: function (props, context) {
    var inst = this._instance;
    var queue = this._pendingStateQueue;
    var replace = this._pendingReplaceState;
    this._pendingReplaceState = false;
    this._pendingStateQueue = null;

    if (!queue) {
      return inst.state;
    }

    if (replace && queue.length === 1) {
      return queue[0];
    }

    var nextState = _assign({}, replace ? queue[0] : inst.state);
    for (var i = replace ? 1 : 0; i < queue.length; i++) {
      var partial = queue[i];
      _assign(nextState, typeof partial === 'function' ? partial.call(inst, nextState, props, context) : partial);
    }

    return nextState;
  },

  /**
   * Merges new props and state, notifies delegate methods of update and
   * performs update.
   *
   * @param {ReactElement} nextElement Next element
   * @param {object} nextProps Next public object to set as properties.
   * @param {?object} nextState Next object to set as state.
   * @param {?object} nextContext Next public object to set as context.
   * @param {ReactReconcileTransaction} transaction
   * @param {?object} unmaskedContext
   * @private
   */
  _performComponentUpdate: function (nextElement, nextProps, nextState, nextContext, transaction, unmaskedContext) {
    var _this2 = this;

    var inst = this._instance;

    var hasComponentDidUpdate = Boolean(inst.componentDidUpdate);
    var prevProps;
    var prevState;
    var prevContext;
    if (hasComponentDidUpdate) {
      prevProps = inst.props;
      prevState = inst.state;
      prevContext = inst.context;
    }

    if (inst.componentWillUpdate) {
      if ("production" !== 'production') {
        measureLifeCyclePerf(function () {
          return inst.componentWillUpdate(nextProps, nextState, nextContext);
        }, this._debugID, 'componentWillUpdate');
      } else {
        inst.componentWillUpdate(nextProps, nextState, nextContext);
      }
    }

    this._currentElement = nextElement;
    this._context = unmaskedContext;
    inst.props = nextProps;
    inst.state = nextState;
    inst.context = nextContext;

    this._updateRenderedComponent(transaction, unmaskedContext);

    if (hasComponentDidUpdate) {
      if ("production" !== 'production') {
        transaction.getReactMountReady().enqueue(function () {
          measureLifeCyclePerf(inst.componentDidUpdate.bind(inst, prevProps, prevState, prevContext), _this2._debugID, 'componentDidUpdate');
        });
      } else {
        transaction.getReactMountReady().enqueue(inst.componentDidUpdate.bind(inst, prevProps, prevState, prevContext), inst);
      }
    }
  },

  /**
   * Call the component's `render` method and update the DOM accordingly.
   *
   * @param {ReactReconcileTransaction} transaction
   * @internal
   */
  _updateRenderedComponent: function (transaction, context) {
    var prevComponentInstance = this._renderedComponent;
    var prevRenderedElement = prevComponentInstance._currentElement;
    var nextRenderedElement = this._renderValidatedComponent();

    var debugID = 0;
    if ("production" !== 'production') {
      debugID = this._debugID;
    }

    if (shouldUpdateReactComponent(prevRenderedElement, nextRenderedElement)) {
      ReactReconciler.receiveComponent(prevComponentInstance, nextRenderedElement, transaction, this._processChildContext(context));
    } else {
      var oldHostNode = ReactReconciler.getHostNode(prevComponentInstance);
      ReactReconciler.unmountComponent(prevComponentInstance, false);

      var nodeType = ReactNodeTypes.getType(nextRenderedElement);
      this._renderedNodeType = nodeType;
      var child = this._instantiateReactComponent(nextRenderedElement, nodeType !== ReactNodeTypes.EMPTY /* shouldHaveDebugID */
      );
      this._renderedComponent = child;

      var nextMarkup = ReactReconciler.mountComponent(child, transaction, this._hostParent, this._hostContainerInfo, this._processChildContext(context), debugID);

      if ("production" !== 'production') {
        if (debugID !== 0) {
          var childDebugIDs = child._debugID !== 0 ? [child._debugID] : [];
          ReactInstrumentation.debugTool.onSetChildren(debugID, childDebugIDs);
        }
      }

      this._replaceNodeWithMarkup(oldHostNode, nextMarkup, prevComponentInstance);
    }
  },

  /**
   * Overridden in shallow rendering.
   *
   * @protected
   */
  _replaceNodeWithMarkup: function (oldHostNode, nextMarkup, prevInstance) {
    ReactComponentEnvironment.replaceNodeWithMarkup(oldHostNode, nextMarkup, prevInstance);
  },

  /**
   * @protected
   */
  _renderValidatedComponentWithoutOwnerOrContext: function () {
    var inst = this._instance;
    var renderedElement;

    if ("production" !== 'production') {
      renderedElement = measureLifeCyclePerf(function () {
        return inst.render();
      }, this._debugID, 'render');
    } else {
      renderedElement = inst.render();
    }

    if ("production" !== 'production') {
      // We allow auto-mocks to proceed as if they're returning null.
      if (renderedElement === undefined && inst.render._isMockFunction) {
        // This is probably bad practice. Consider warning here and
        // deprecating this convenience.
        renderedElement = null;
      }
    }

    return renderedElement;
  },

  /**
   * @private
   */
  _renderValidatedComponent: function () {
    var renderedElement;
    if ("production" !== 'production' || this._compositeType !== CompositeTypes.StatelessFunctional) {
      ReactCurrentOwner.current = this;
      try {
        renderedElement = this._renderValidatedComponentWithoutOwnerOrContext();
      } finally {
        ReactCurrentOwner.current = null;
      }
    } else {
      renderedElement = this._renderValidatedComponentWithoutOwnerOrContext();
    }
    !(
    // TODO: An `isValidNode` function would probably be more appropriate
    renderedElement === null || renderedElement === false || React.isValidElement(renderedElement)) ? "production" !== 'production' ? invariant(false, '%s.render(): A valid React element (or null) must be returned. You may have returned undefined, an array or some other invalid object.', this.getName() || 'ReactCompositeComponent') : _prodInvariant('109', this.getName() || 'ReactCompositeComponent') : void 0;

    return renderedElement;
  },

  /**
   * Lazily allocates the refs object and stores `component` as `ref`.
   *
   * @param {string} ref Reference name.
   * @param {component} component Component to store as `ref`.
   * @final
   * @private
   */
  attachRef: function (ref, component) {
    var inst = this.getPublicInstance();
    !(inst != null) ? "production" !== 'production' ? invariant(false, 'Stateless function components cannot have refs.') : _prodInvariant('110') : void 0;
    var publicComponentInstance = component.getPublicInstance();
    if ("production" !== 'production') {
      var componentName = component && component.getName ? component.getName() : 'a component';
      "production" !== 'production' ? warning(publicComponentInstance != null || component._compositeType !== CompositeTypes.StatelessFunctional, 'Stateless function components cannot be given refs ' + '(See ref "%s" in %s created by %s). ' + 'Attempts to access this ref will fail.', ref, componentName, this.getName()) : void 0;
    }
    var refs = inst.refs === emptyObject ? inst.refs = {} : inst.refs;
    refs[ref] = publicComponentInstance;
  },

  /**
   * Detaches a reference name.
   *
   * @param {string} ref Name to dereference.
   * @final
   * @private
   */
  detachRef: function (ref) {
    var refs = this.getPublicInstance().refs;
    delete refs[ref];
  },

  /**
   * Get a text description of the component that can be used to identify it
   * in error messages.
   * @return {string} The name or null.
   * @internal
   */
  getName: function () {
    var type = this._currentElement.type;
    var constructor = this._instance && this._instance.constructor;
    return type.displayName || constructor && constructor.displayName || type.name || constructor && constructor.name || null;
  },

  /**
   * Get the publicly accessible representation of this component - i.e. what
   * is exposed by refs and returned by render. Can be null for stateless
   * components.
   *
   * @return {ReactComponent} the public component instance.
   * @internal
   */
  getPublicInstance: function () {
    var inst = this._instance;
    if (this._compositeType === CompositeTypes.StatelessFunctional) {
      return null;
    }
    return inst;
  },

  // Stub
  _instantiateReactComponent: null
};

module.exports = ReactCompositeComponent;
},{"./ReactComponentEnvironment":558,"./ReactErrorUtils":583,"./ReactInstanceMap":591,"./ReactInstrumentation":592,"./ReactNodeTypes":597,"./ReactReconciler":602,"./checkReactTypeSpec":629,"./reactProdInvariant":650,"./shouldUpdateReactComponent":654,"fbjs/lib/emptyObject":395,"fbjs/lib/invariant":402,"fbjs/lib/shallowEqual":408,"fbjs/lib/warning":409,"object-assign":489,"react/lib/React":674,"react/lib/ReactCurrentOwner":678}],560:[function(require,module,exports){
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */

/* globals __REACT_DEVTOOLS_GLOBAL_HOOK__*/

'use strict';

var ReactDOMComponentTree = require('./ReactDOMComponentTree');
var ReactDefaultInjection = require('./ReactDefaultInjection');
var ReactMount = require('./ReactMount');
var ReactReconciler = require('./ReactReconciler');
var ReactUpdates = require('./ReactUpdates');
var ReactVersion = require('./ReactVersion');

var findDOMNode = require('./findDOMNode');
var getHostComponentFromComposite = require('./getHostComponentFromComposite');
var renderSubtreeIntoContainer = require('./renderSubtreeIntoContainer');
var warning = require('fbjs/lib/warning');

ReactDefaultInjection.inject();

var ReactDOM = {
  findDOMNode: findDOMNode,
  render: ReactMount.render,
  unmountComponentAtNode: ReactMount.unmountComponentAtNode,
  version: ReactVersion,

  /* eslint-disable camelcase */
  unstable_batchedUpdates: ReactUpdates.batchedUpdates,
  unstable_renderSubtreeIntoContainer: renderSubtreeIntoContainer
  /* eslint-enable camelcase */
};

// Inject the runtime into a devtools global hook regardless of browser.
// Allows for debugging when the hook is injected on the page.
if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.inject === 'function') {
  __REACT_DEVTOOLS_GLOBAL_HOOK__.inject({
    ComponentTree: {
      getClosestInstanceFromNode: ReactDOMComponentTree.getClosestInstanceFromNode,
      getNodeFromInstance: function (inst) {
        // inst is an internal instance (but could be a composite)
        if (inst._renderedComponent) {
          inst = getHostComponentFromComposite(inst);
        }
        if (inst) {
          return ReactDOMComponentTree.getNodeFromInstance(inst);
        } else {
          return null;
        }
      }
    },
    Mount: ReactMount,
    Reconciler: ReactReconciler
  });
}

if ("production" !== 'production') {
  var ExecutionEnvironment = require('fbjs/lib/ExecutionEnvironment');
  if (ExecutionEnvironment.canUseDOM && window.top === window.self) {
    // First check if devtools is not installed
    if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined') {
      // If we're in Chrome or Firefox, provide a download link if not installed.
      if (navigator.userAgent.indexOf('Chrome') > -1 && navigator.userAgent.indexOf('Edge') === -1 || navigator.userAgent.indexOf('Firefox') > -1) {
        // Firefox does not have the issue with devtools loaded over file://
        var showFileUrlMessage = window.location.protocol.indexOf('http') === -1 && navigator.userAgent.indexOf('Firefox') === -1;
        console.debug('Download the React DevTools ' + (showFileUrlMessage ? 'and use an HTTP server (instead of a file: URL) ' : '') + 'for a better development experience: ' + 'https://fb.me/react-devtools');
      }
    }

    var testFunc = function testFn() {};
    "production" !== 'production' ? warning((testFunc.name || testFunc.toString()).indexOf('testFn') !== -1, "It looks like you're using a minified copy of the development build " + 'of React. When deploying React apps to production, make sure to use ' + 'the production build which skips development warnings and is faster. ' + 'See https://fb.me/react-minification for more details.') : void 0;

    // If we're in IE8, check to see if we are in compatibility mode and provide
    // information on preventing compatibility mode
    var ieCompatibilityMode = document.documentMode && document.documentMode < 8;

    "production" !== 'production' ? warning(!ieCompatibilityMode, 'Internet Explorer is running in compatibility mode; please add the ' + 'following tag to your HTML to prevent this from happening: ' + '<meta http-equiv="X-UA-Compatible" content="IE=edge" />') : void 0;

    var expectedFeatures = [
    // shims
    Array.isArray, Array.prototype.every, Array.prototype.forEach, Array.prototype.indexOf, Array.prototype.map, Date.now, Function.prototype.bind, Object.keys, String.prototype.trim];

    for (var i = 0; i < expectedFeatures.length; i++) {
      if (!expectedFeatures[i]) {
        "production" !== 'production' ? warning(false, 'One or more ES5 shims expected by React are not available: ' + 'https://fb.me/react-warning-polyfills') : void 0;
        break;
      }
    }
  }
}

if ("production" !== 'production') {
  var ReactInstrumentation = require('./ReactInstrumentation');
  var ReactDOMUnknownPropertyHook = require('./ReactDOMUnknownPropertyHook');
  var ReactDOMNullInputValuePropHook = require('./ReactDOMNullInputValuePropHook');
  var ReactDOMInvalidARIAHook = require('./ReactDOMInvalidARIAHook');

  ReactInstrumentation.debugTool.addHook(ReactDOMUnknownPropertyHook);
  ReactInstrumentation.debugTool.addHook(ReactDOMNullInputValuePropHook);
  ReactInstrumentation.debugTool.addHook(ReactDOMInvalidARIAHook);
}

module.exports = ReactDOM;
},{"./ReactDOMComponentTree":563,"./ReactDOMInvalidARIAHook":569,"./ReactDOMNullInputValuePropHook":570,"./ReactDOMUnknownPropertyHook":577,"./ReactDefaultInjection":580,"./ReactInstrumentation":592,"./ReactMount":595,"./ReactReconciler":602,"./ReactUpdates":607,"./ReactVersion":608,"./findDOMNode":633,"./getHostComponentFromComposite":640,"./renderSubtreeIntoContainer":651,"fbjs/lib/ExecutionEnvironment":388,"fbjs/lib/warning":409}],561:[function(require,module,exports){
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */

/* global hasOwnProperty:true */

'use strict';

var _prodInvariant = require('./reactProdInvariant'),
    _assign = require('object-assign');

var AutoFocusUtils = require('./AutoFocusUtils');
var CSSPropertyOperations = require('./CSSPropertyOperations');
var DOMLazyTree = require('./DOMLazyTree');
var DOMNamespaces = require('./DOMNamespaces');
var DOMProperty = require('./DOMProperty');
var DOMPropertyOperations = require('./DOMPropertyOperations');
var EventPluginHub = require('./EventPluginHub');
var EventPluginRegistry = require('./EventPluginRegistry');
var ReactBrowserEventEmitter = require('./ReactBrowserEventEmitter');
var ReactDOMComponentFlags = require('./ReactDOMComponentFlags');
var ReactDOMComponentTree = require('./ReactDOMComponentTree');
var ReactDOMInput = require('./ReactDOMInput');
var ReactDOMOption = require('./ReactDOMOption');
var ReactDOMSelect = require('./ReactDOMSelect');
var ReactDOMTextarea = require('./ReactDOMTextarea');
var ReactInstrumentation = require('./ReactInstrumentation');
var ReactMultiChild = require('./ReactMultiChild');
var ReactServerRenderingTransaction = require('./ReactServerRenderingTransaction');

var emptyFunction = require('fbjs/lib/emptyFunction');
var escapeTextContentForBrowser = require('./escapeTextContentForBrowser');
var invariant = require('fbjs/lib/invariant');
var isEventSupported = require('./isEventSupported');
var shallowEqual = require('fbjs/lib/shallowEqual');
var inputValueTracking = require('./inputValueTracking');
var validateDOMNesting = require('./validateDOMNesting');
var warning = require('fbjs/lib/warning');

var Flags = ReactDOMComponentFlags;
var deleteListener = EventPluginHub.deleteListener;
var getNode = ReactDOMComponentTree.getNodeFromInstance;
var listenTo = ReactBrowserEventEmitter.listenTo;
var registrationNameModules = EventPluginRegistry.registrationNameModules;

// For quickly matching children type, to test if can be treated as content.
var CONTENT_TYPES = { string: true, number: true };

var STYLE = 'style';
var HTML = '__html';
var RESERVED_PROPS = {
  children: null,
  dangerouslySetInnerHTML: null,
  suppressContentEditableWarning: null
};

// Node type for document fragments (Node.DOCUMENT_FRAGMENT_NODE).
var DOC_FRAGMENT_TYPE = 11;

function getDeclarationErrorAddendum(internalInstance) {
  if (internalInstance) {
    var owner = internalInstance._currentElement._owner || null;
    if (owner) {
      var name = owner.getName();
      if (name) {
        return ' This DOM node was rendered by `' + name + '`.';
      }
    }
  }
  return '';
}

function friendlyStringify(obj) {
  if (typeof obj === 'object') {
    if (Array.isArray(obj)) {
      return '[' + obj.map(friendlyStringify).join(', ') + ']';
    } else {
      var pairs = [];
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          var keyEscaped = /^[a-z$_][\w$_]*$/i.test(key) ? key : JSON.stringify(key);
          pairs.push(keyEscaped + ': ' + friendlyStringify(obj[key]));
        }
      }
      return '{' + pairs.join(', ') + '}';
    }
  } else if (typeof obj === 'string') {
    return JSON.stringify(obj);
  } else if (typeof obj === 'function') {
    return '[function object]';
  }
  // Differs from JSON.stringify in that undefined because undefined and that
  // inf and nan don't become null
  return String(obj);
}

var styleMutationWarning = {};

function checkAndWarnForMutatedStyle(style1, style2, component) {
  if (style1 == null || style2 == null) {
    return;
  }
  if (shallowEqual(style1, style2)) {
    return;
  }

  var componentName = component._tag;
  var owner = component._currentElement._owner;
  var ownerName;
  if (owner) {
    ownerName = owner.getName();
  }

  var hash = ownerName + '|' + componentName;

  if (styleMutationWarning.hasOwnProperty(hash)) {
    return;
  }

  styleMutationWarning[hash] = true;

  "production" !== 'production' ? warning(false, '`%s` was passed a style object that has previously been mutated. ' + 'Mutating `style` is deprecated. Consider cloning it beforehand. Check ' + 'the `render` %s. Previous style: %s. Mutated style: %s.', componentName, owner ? 'of `' + ownerName + '`' : 'using <' + componentName + '>', friendlyStringify(style1), friendlyStringify(style2)) : void 0;
}

/**
 * @param {object} component
 * @param {?object} props
 */
function assertValidProps(component, props) {
  if (!props) {
    return;
  }
  // Note the use of `==` which checks for null or undefined.
  if (voidElementTags[component._tag]) {
    !(props.children == null && props.dangerouslySetInnerHTML == null) ? "production" !== 'production' ? invariant(false, '%s is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`.%s', component._tag, component._currentElement._owner ? ' Check the render method of ' + component._currentElement._owner.getName() + '.' : '') : _prodInvariant('137', component._tag, component._currentElement._owner ? ' Check the render method of ' + component._currentElement._owner.getName() + '.' : '') : void 0;
  }
  if (props.dangerouslySetInnerHTML != null) {
    !(props.children == null) ? "production" !== 'production' ? invariant(false, 'Can only set one of `children` or `props.dangerouslySetInnerHTML`.') : _prodInvariant('60') : void 0;
    !(typeof props.dangerouslySetInnerHTML === 'object' && HTML in props.dangerouslySetInnerHTML) ? "production" !== 'production' ? invariant(false, '`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://fb.me/react-invariant-dangerously-set-inner-html for more information.') : _prodInvariant('61') : void 0;
  }
  if ("production" !== 'production') {
    "production" !== 'production' ? warning(props.innerHTML == null, 'Directly setting property `innerHTML` is not permitted. ' + 'For more information, lookup documentation on `dangerouslySetInnerHTML`.') : void 0;
    "production" !== 'production' ? warning(props.suppressContentEditableWarning || !props.contentEditable || props.children == null, 'A component is `contentEditable` and contains `children` managed by ' + 'React. It is now your responsibility to guarantee that none of ' + 'those nodes are unexpectedly modified or duplicated. This is ' + 'probably not intentional.') : void 0;
    "production" !== 'production' ? warning(props.onFocusIn == null && props.onFocusOut == null, 'React uses onFocus and onBlur instead of onFocusIn and onFocusOut. ' + 'All React events are normalized to bubble, so onFocusIn and onFocusOut ' + 'are not needed/supported by React.') : void 0;
  }
  !(props.style == null || typeof props.style === 'object') ? "production" !== 'production' ? invariant(false, 'The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + \'em\'}} when using JSX.%s', getDeclarationErrorAddendum(component)) : _prodInvariant('62', getDeclarationErrorAddendum(component)) : void 0;
}

function enqueuePutListener(inst, registrationName, listener, transaction) {
  if (transaction instanceof ReactServerRenderingTransaction) {
    return;
  }
  if ("production" !== 'production') {
    // IE8 has no API for event capturing and the `onScroll` event doesn't
    // bubble.
    "production" !== 'production' ? warning(registrationName !== 'onScroll' || isEventSupported('scroll', true), "This browser doesn't support the `onScroll` event") : void 0;
  }
  var containerInfo = inst._hostContainerInfo;
  var isDocumentFragment = containerInfo._node && containerInfo._node.nodeType === DOC_FRAGMENT_TYPE;
  var doc = isDocumentFragment ? containerInfo._node : containerInfo._ownerDocument;
  listenTo(registrationName, doc);
  transaction.getReactMountReady().enqueue(putListener, {
    inst: inst,
    registrationName: registrationName,
    listener: listener
  });
}

function putListener() {
  var listenerToPut = this;
  EventPluginHub.putListener(listenerToPut.inst, listenerToPut.registrationName, listenerToPut.listener);
}

function inputPostMount() {
  var inst = this;
  ReactDOMInput.postMountWrapper(inst);
}

function textareaPostMount() {
  var inst = this;
  ReactDOMTextarea.postMountWrapper(inst);
}

function optionPostMount() {
  var inst = this;
  ReactDOMOption.postMountWrapper(inst);
}

var setAndValidateContentChildDev = emptyFunction;
if ("production" !== 'production') {
  setAndValidateContentChildDev = function (content) {
    var hasExistingContent = this._contentDebugID != null;
    var debugID = this._debugID;
    // This ID represents the inlined child that has no backing instance:
    var contentDebugID = -debugID;

    if (content == null) {
      if (hasExistingContent) {
        ReactInstrumentation.debugTool.onUnmountComponent(this._contentDebugID);
      }
      this._contentDebugID = null;
      return;
    }

    validateDOMNesting(null, String(content), this, this._ancestorInfo);
    this._contentDebugID = contentDebugID;
    if (hasExistingContent) {
      ReactInstrumentation.debugTool.onBeforeUpdateComponent(contentDebugID, content);
      ReactInstrumentation.debugTool.onUpdateComponent(contentDebugID);
    } else {
      ReactInstrumentation.debugTool.onBeforeMountComponent(contentDebugID, content, debugID);
      ReactInstrumentation.debugTool.onMountComponent(contentDebugID);
      ReactInstrumentation.debugTool.onSetChildren(debugID, [contentDebugID]);
    }
  };
}

// There are so many media events, it makes sense to just
// maintain a list rather than create a `trapBubbledEvent` for each
var mediaEvents = {
  topAbort: 'abort',
  topCanPlay: 'canplay',
  topCanPlayThrough: 'canplaythrough',
  topDurationChange: 'durationchange',
  topEmptied: 'emptied',
  topEncrypted: 'encrypted',
  topEnded: 'ended',
  topError: 'error',
  topLoadedData: 'loadeddata',
  topLoadedMetadata: 'loadedmetadata',
  topLoadStart: 'loadstart',
  topPause: 'pause',
  topPlay: 'play',
  topPlaying: 'playing',
  topProgress: 'progress',
  topRateChange: 'ratechange',
  topSeeked: 'seeked',
  topSeeking: 'seeking',
  topStalled: 'stalled',
  topSuspend: 'suspend',
  topTimeUpdate: 'timeupdate',
  topVolumeChange: 'volumechange',
  topWaiting: 'waiting'
};

function trackInputValue() {
  inputValueTracking.track(this);
}

function trapBubbledEventsLocal() {
  var inst = this;
  // If a component renders to null or if another component fatals and causes
  // the state of the tree to be corrupted, `node` here can be null.
  !inst._rootNodeID ? "production" !== 'production' ? invariant(false, 'Must be mounted to trap events') : _prodInvariant('63') : void 0;
  var node = getNode(inst);
  !node ? "production" !== 'production' ? invariant(false, 'trapBubbledEvent(...): Requires node to be rendered.') : _prodInvariant('64') : void 0;

  switch (inst._tag) {
    case 'iframe':
    case 'object':
      inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent('topLoad', 'load', node)];
      break;
    case 'video':
    case 'audio':
      inst._wrapperState.listeners = [];
      // Create listener for each media event
      for (var event in mediaEvents) {
        if (mediaEvents.hasOwnProperty(event)) {
          inst._wrapperState.listeners.push(ReactBrowserEventEmitter.trapBubbledEvent(event, mediaEvents[event], node));
        }
      }
      break;
    case 'source':
      inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent('topError', 'error', node)];
      break;
    case 'img':
      inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent('topError', 'error', node), ReactBrowserEventEmitter.trapBubbledEvent('topLoad', 'load', node)];
      break;
    case 'form':
      inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent('topReset', 'reset', node), ReactBrowserEventEmitter.trapBubbledEvent('topSubmit', 'submit', node)];
      break;
    case 'input':
    case 'select':
    case 'textarea':
      inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent('topInvalid', 'invalid', node)];
      break;
  }
}

function postUpdateSelectWrapper() {
  ReactDOMSelect.postUpdateWrapper(this);
}

// For HTML, certain tags should omit their close tag. We keep a whitelist for
// those special-case tags.

var omittedCloseTags = {
  area: true,
  base: true,
  br: true,
  col: true,
  embed: true,
  hr: true,
  img: true,
  input: true,
  keygen: true,
  link: true,
  meta: true,
  param: true,
  source: true,
  track: true,
  wbr: true
  // NOTE: menuitem's close tag should be omitted, but that causes problems.
};

var newlineEatingTags = {
  listing: true,
  pre: true,
  textarea: true
};

// For HTML, certain tags cannot have children. This has the same purpose as
// `omittedCloseTags` except that `menuitem` should still have its closing tag.

var voidElementTags = _assign({
  menuitem: true
}, omittedCloseTags);

// We accept any tag to be rendered but since this gets injected into arbitrary
// HTML, we want to make sure that it's a safe tag.
// http://www.w3.org/TR/REC-xml/#NT-Name

var VALID_TAG_REGEX = /^[a-zA-Z][a-zA-Z:_\.\-\d]*$/; // Simplified subset
var validatedTagCache = {};
var hasOwnProperty = {}.hasOwnProperty;

function validateDangerousTag(tag) {
  if (!hasOwnProperty.call(validatedTagCache, tag)) {
    !VALID_TAG_REGEX.test(tag) ? "production" !== 'production' ? invariant(false, 'Invalid tag: %s', tag) : _prodInvariant('65', tag) : void 0;
    validatedTagCache[tag] = true;
  }
}

function isCustomComponent(tagName, props) {
  return tagName.indexOf('-') >= 0 || props.is != null;
}

var globalIdCounter = 1;

/**
 * Creates a new React class that is idempotent and capable of containing other
 * React components. It accepts event listeners and DOM properties that are
 * valid according to `DOMProperty`.
 *
 *  - Event listeners: `onClick`, `onMouseDown`, etc.
 *  - DOM properties: `className`, `name`, `title`, etc.
 *
 * The `style` property functions differently from the DOM API. It accepts an
 * object mapping of style properties to values.
 *
 * @constructor ReactDOMComponent
 * @extends ReactMultiChild
 */
function ReactDOMComponent(element) {
  var tag = element.type;
  validateDangerousTag(tag);
  this._currentElement = element;
  this._tag = tag.toLowerCase();
  this._namespaceURI = null;
  this._renderedChildren = null;
  this._previousStyle = null;
  this._previousStyleCopy = null;
  this._hostNode = null;
  this._hostParent = null;
  this._rootNodeID = 0;
  this._domID = 0;
  this._hostContainerInfo = null;
  this._wrapperState = null;
  this._topLevelWrapper = null;
  this._flags = 0;
  if ("production" !== 'production') {
    this._ancestorInfo = null;
    setAndValidateContentChildDev.call(this, null);
  }
}

ReactDOMComponent.displayName = 'ReactDOMComponent';

ReactDOMComponent.Mixin = {
  /**
   * Generates root tag markup then recurses. This method has side effects and
   * is not idempotent.
   *
   * @internal
   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
   * @param {?ReactDOMComponent} the parent component instance
   * @param {?object} info about the host container
   * @param {object} context
   * @return {string} The computed markup.
   */
  mountComponent: function (transaction, hostParent, hostContainerInfo, context) {
    this._rootNodeID = globalIdCounter++;
    this._domID = hostContainerInfo._idCounter++;
    this._hostParent = hostParent;
    this._hostContainerInfo = hostContainerInfo;

    var props = this._currentElement.props;

    switch (this._tag) {
      case 'audio':
      case 'form':
      case 'iframe':
      case 'img':
      case 'link':
      case 'object':
      case 'source':
      case 'video':
        this._wrapperState = {
          listeners: null
        };
        transaction.getReactMountReady().enqueue(trapBubbledEventsLocal, this);
        break;
      case 'input':
        ReactDOMInput.mountWrapper(this, props, hostParent);
        props = ReactDOMInput.getHostProps(this, props);
        transaction.getReactMountReady().enqueue(trackInputValue, this);
        transaction.getReactMountReady().enqueue(trapBubbledEventsLocal, this);
        break;
      case 'option':
        ReactDOMOption.mountWrapper(this, props, hostParent);
        props = ReactDOMOption.getHostProps(this, props);
        break;
      case 'select':
        ReactDOMSelect.mountWrapper(this, props, hostParent);
        props = ReactDOMSelect.getHostProps(this, props);
        transaction.getReactMountReady().enqueue(trapBubbledEventsLocal, this);
        break;
      case 'textarea':
        ReactDOMTextarea.mountWrapper(this, props, hostParent);
        props = ReactDOMTextarea.getHostProps(this, props);
        transaction.getReactMountReady().enqueue(trackInputValue, this);
        transaction.getReactMountReady().enqueue(trapBubbledEventsLocal, this);
        break;
    }

    assertValidProps(this, props);

    // We create tags in the namespace of their parent container, except HTML
    // tags get no namespace.
    var namespaceURI;
    var parentTag;
    if (hostParent != null) {
      namespaceURI = hostParent._namespaceURI;
      parentTag = hostParent._tag;
    } else if (hostContainerInfo._tag) {
      namespaceURI = hostContainerInfo._namespaceURI;
      parentTag = hostContainerInfo._tag;
    }
    if (namespaceURI == null || namespaceURI === DOMNamespaces.svg && parentTag === 'foreignobject') {
      namespaceURI = DOMNamespaces.html;
    }
    if (namespaceURI === DOMNamespaces.html) {
      if (this._tag === 'svg') {
        namespaceURI = DOMNamespaces.svg;
      } else if (this._tag === 'math') {
        namespaceURI = DOMNamespaces.mathml;
      }
    }
    this._namespaceURI = namespaceURI;

    if ("production" !== 'production') {
      var parentInfo;
      if (hostParent != null) {
        parentInfo = hostParent._ancestorInfo;
      } else if (hostContainerInfo._tag) {
        parentInfo = hostContainerInfo._ancestorInfo;
      }
      if (parentInfo) {
        // parentInfo should always be present except for the top-level
        // component when server rendering
        validateDOMNesting(this._tag, null, this, parentInfo);
      }
      this._ancestorInfo = validateDOMNesting.updatedAncestorInfo(parentInfo, this._tag, this);
    }

    var mountImage;
    if (transaction.useCreateElement) {
      var ownerDocument = hostContainerInfo._ownerDocument;
      var el;
      if (namespaceURI === DOMNamespaces.html) {
        if (this._tag === 'script') {
          // Create the script via .innerHTML so its "parser-inserted" flag is
          // set to true and it does not execute
          var div = ownerDocument.createElement('div');
          var type = this._currentElement.type;
          div.innerHTML = '<' + type + '></' + type + '>';
          el = div.removeChild(div.firstChild);
        } else if (props.is) {
          el = ownerDocument.createElement(this._currentElement.type, props.is);
        } else {
          // Separate else branch instead of using `props.is || undefined` above becuase of a Firefox bug.
          // See discussion in https://github.com/facebook/react/pull/6896
          // and discussion in https://bugzilla.mozilla.org/show_bug.cgi?id=1276240
          el = ownerDocument.createElement(this._currentElement.type);
        }
      } else {
        el = ownerDocument.createElementNS(namespaceURI, this._currentElement.type);
      }
      ReactDOMComponentTree.precacheNode(this, el);
      this._flags |= Flags.hasCachedChildNodes;
      if (!this._hostParent) {
        DOMPropertyOperations.setAttributeForRoot(el);
      }
      this._updateDOMProperties(null, props, transaction);
      var lazyTree = DOMLazyTree(el);
      this._createInitialChildren(transaction, props, context, lazyTree);
      mountImage = lazyTree;
    } else {
      var tagOpen = this._createOpenTagMarkupAndPutListeners(transaction, props);
      var tagContent = this._createContentMarkup(transaction, props, context);
      if (!tagContent && omittedCloseTags[this._tag]) {
        mountImage = tagOpen + '/>';
      } else {
        mountImage = tagOpen + '>' + tagContent + '</' + this._currentElement.type + '>';
      }
    }

    switch (this._tag) {
      case 'input':
        transaction.getReactMountReady().enqueue(inputPostMount, this);
        if (props.autoFocus) {
          transaction.getReactMountReady().enqueue(AutoFocusUtils.focusDOMComponent, this);
        }
        break;
      case 'textarea':
        transaction.getReactMountReady().enqueue(textareaPostMount, this);
        if (props.autoFocus) {
          transaction.getReactMountReady().enqueue(AutoFocusUtils.focusDOMComponent, this);
        }
        break;
      case 'select':
        if (props.autoFocus) {
          transaction.getReactMountReady().enqueue(AutoFocusUtils.focusDOMComponent, this);
        }
        break;
      case 'button':
        if (props.autoFocus) {
          transaction.getReactMountReady().enqueue(AutoFocusUtils.focusDOMComponent, this);
        }
        break;
      case 'option':
        transaction.getReactMountReady().enqueue(optionPostMount, this);
        break;
    }

    return mountImage;
  },

  /**
   * Creates markup for the open tag and all attributes.
   *
   * This method has side effects because events get registered.
   *
   * Iterating over object properties is faster than iterating over arrays.
   * @see http://jsperf.com/obj-vs-arr-iteration
   *
   * @private
   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
   * @param {object} props
   * @return {string} Markup of opening tag.
   */
  _createOpenTagMarkupAndPutListeners: function (transaction, props) {
    var ret = '<' + this._currentElement.type;

    for (var propKey in props) {
      if (!props.hasOwnProperty(propKey)) {
        continue;
      }
      var propValue = props[propKey];
      if (propValue == null) {
        continue;
      }
      if (registrationNameModules.hasOwnProperty(propKey)) {
        if (propValue) {
          enqueuePutListener(this, propKey, propValue, transaction);
        }
      } else {
        if (propKey === STYLE) {
          if (propValue) {
            if ("production" !== 'production') {
              // See `_updateDOMProperties`. style block
              this._previousStyle = propValue;
            }
            propValue = this._previousStyleCopy = _assign({}, props.style);
          }
          propValue = CSSPropertyOperations.createMarkupForStyles(propValue, this);
        }
        var markup = null;
        if (this._tag != null && isCustomComponent(this._tag, props)) {
          if (!RESERVED_PROPS.hasOwnProperty(propKey)) {
            markup = DOMPropertyOperations.createMarkupForCustomAttribute(propKey, propValue);
          }
        } else {
          markup = DOMPropertyOperations.createMarkupForProperty(propKey, propValue);
        }
        if (markup) {
          ret += ' ' + markup;
        }
      }
    }

    // For static pages, no need to put React ID and checksum. Saves lots of
    // bytes.
    if (transaction.renderToStaticMarkup) {
      return ret;
    }

    if (!this._hostParent) {
      ret += ' ' + DOMPropertyOperations.createMarkupForRoot();
    }
    ret += ' ' + DOMPropertyOperations.createMarkupForID(this._domID);
    return ret;
  },

  /**
   * Creates markup for the content between the tags.
   *
   * @private
   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
   * @param {object} props
   * @param {object} context
   * @return {string} Content markup.
   */
  _createContentMarkup: function (transaction, props, context) {
    var ret = '';

    // Intentional use of != to avoid catching zero/false.
    var innerHTML = props.dangerouslySetInnerHTML;
    if (innerHTML != null) {
      if (innerHTML.__html != null) {
        ret = innerHTML.__html;
      }
    } else {
      var contentToUse = CONTENT_TYPES[typeof props.children] ? props.children : null;
      var childrenToUse = contentToUse != null ? null : props.children;
      if (contentToUse != null) {
        // TODO: Validate that text is allowed as a child of this node
        ret = escapeTextContentForBrowser(contentToUse);
        if ("production" !== 'production') {
          setAndValidateContentChildDev.call(this, contentToUse);
        }
      } else if (childrenToUse != null) {
        var mountImages = this.mountChildren(childrenToUse, transaction, context);
        ret = mountImages.join('');
      }
    }
    if (newlineEatingTags[this._tag] && ret.charAt(0) === '\n') {
      // text/html ignores the first character in these tags if it's a newline
      // Prefer to break application/xml over text/html (for now) by adding
      // a newline specifically to get eaten by the parser. (Alternately for
      // textareas, replacing "^\n" with "\r\n" doesn't get eaten, and the first
      // \r is normalized out by HTMLTextAreaElement#value.)
      // See: <http://www.w3.org/TR/html-polyglot/#newlines-in-textarea-and-pre>
      // See: <http://www.w3.org/TR/html5/syntax.html#element-restrictions>
      // See: <http://www.w3.org/TR/html5/syntax.html#newlines>
      // See: Parsing of "textarea" "listing" and "pre" elements
      //  from <http://www.w3.org/TR/html5/syntax.html#parsing-main-inbody>
      return '\n' + ret;
    } else {
      return ret;
    }
  },

  _createInitialChildren: function (transaction, props, context, lazyTree) {
    // Intentional use of != to avoid catching zero/false.
    var innerHTML = props.dangerouslySetInnerHTML;
    if (innerHTML != null) {
      if (innerHTML.__html != null) {
        DOMLazyTree.queueHTML(lazyTree, innerHTML.__html);
      }
    } else {
      var contentToUse = CONTENT_TYPES[typeof props.children] ? props.children : null;
      var childrenToUse = contentToUse != null ? null : props.children;
      // TODO: Validate that text is allowed as a child of this node
      if (contentToUse != null) {
        // Avoid setting textContent when the text is empty. In IE11 setting
        // textContent on a text area will cause the placeholder to not
        // show within the textarea until it has been focused and blurred again.
        // https://github.com/facebook/react/issues/6731#issuecomment-254874553
        if (contentToUse !== '') {
          if ("production" !== 'production') {
            setAndValidateContentChildDev.call(this, contentToUse);
          }
          DOMLazyTree.queueText(lazyTree, contentToUse);
        }
      } else if (childrenToUse != null) {
        var mountImages = this.mountChildren(childrenToUse, transaction, context);
        for (var i = 0; i < mountImages.length; i++) {
          DOMLazyTree.queueChild(lazyTree, mountImages[i]);
        }
      }
    }
  },

  /**
   * Receives a next element and updates the component.
   *
   * @internal
   * @param {ReactElement} nextElement
   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
   * @param {object} context
   */
  receiveComponent: function (nextElement, transaction, context) {
    var prevElement = this._currentElement;
    this._currentElement = nextElement;
    this.updateComponent(transaction, prevElement, nextElement, context);
  },

  /**
   * Updates a DOM component after it has already been allocated and
   * attached to the DOM. Reconciles the root DOM node, then recurses.
   *
   * @param {ReactReconcileTransaction} transaction
   * @param {ReactElement} prevElement
   * @param {ReactElement} nextElement
   * @internal
   * @overridable
   */
  updateComponent: function (transaction, prevElement, nextElement, context) {
    var lastProps = prevElement.props;
    var nextProps = this._currentElement.props;

    switch (this._tag) {
      case 'input':
        lastProps = ReactDOMInput.getHostProps(this, lastProps);
        nextProps = ReactDOMInput.getHostProps(this, nextProps);
        break;
      case 'option':
        lastProps = ReactDOMOption.getHostProps(this, lastProps);
        nextProps = ReactDOMOption.getHostProps(this, nextProps);
        break;
      case 'select':
        lastProps = ReactDOMSelect.getHostProps(this, lastProps);
        nextProps = ReactDOMSelect.getHostProps(this, nextProps);
        break;
      case 'textarea':
        lastProps = ReactDOMTextarea.getHostProps(this, lastProps);
        nextProps = ReactDOMTextarea.getHostProps(this, nextProps);
        break;
    }

    assertValidProps(this, nextProps);
    this._updateDOMProperties(lastProps, nextProps, transaction);
    this._updateDOMChildren(lastProps, nextProps, transaction, context);

    switch (this._tag) {
      case 'input':
        // Update the wrapper around inputs *after* updating props. This has to
        // happen after `_updateDOMProperties`. Otherwise HTML5 input validations
        // raise warnings and prevent the new value from being assigned.
        ReactDOMInput.updateWrapper(this);

        // We also check that we haven't missed a value update, such as a
        // Radio group shifting the checked value to another named radio input.
        inputValueTracking.updateValueIfChanged(this);
        break;
      case 'textarea':
        ReactDOMTextarea.updateWrapper(this);
        break;
      case 'select':
        // <select> value update needs to occur after <option> children
        // reconciliation
        transaction.getReactMountReady().enqueue(postUpdateSelectWrapper, this);
        break;
    }
  },

  /**
   * Reconciles the properties by detecting differences in property values and
   * updating the DOM as necessary. This function is probably the single most
   * critical path for performance optimization.
   *
   * TODO: Benchmark whether checking for changed values in memory actually
   *       improves performance (especially statically positioned elements).
   * TODO: Benchmark the effects of putting this at the top since 99% of props
   *       do not change for a given reconciliation.
   * TODO: Benchmark areas that can be improved with caching.
   *
   * @private
   * @param {object} lastProps
   * @param {object} nextProps
   * @param {?DOMElement} node
   */
  _updateDOMProperties: function (lastProps, nextProps, transaction) {
    var propKey;
    var styleName;
    var styleUpdates;
    for (propKey in lastProps) {
      if (nextProps.hasOwnProperty(propKey) || !lastProps.hasOwnProperty(propKey) || lastProps[propKey] == null) {
        continue;
      }
      if (propKey === STYLE) {
        var lastStyle = this._previousStyleCopy;
        for (styleName in lastStyle) {
          if (lastStyle.hasOwnProperty(styleName)) {
            styleUpdates = styleUpdates || {};
            styleUpdates[styleName] = '';
          }
        }
        this._previousStyleCopy = null;
      } else if (registrationNameModules.hasOwnProperty(propKey)) {
        if (lastProps[propKey]) {
          // Only call deleteListener if there was a listener previously or
          // else willDeleteListener gets called when there wasn't actually a
          // listener (e.g., onClick={null})
          deleteListener(this, propKey);
        }
      } else if (isCustomComponent(this._tag, lastProps)) {
        if (!RESERVED_PROPS.hasOwnProperty(propKey)) {
          DOMPropertyOperations.deleteValueForAttribute(getNode(this), propKey);
        }
      } else if (DOMProperty.properties[propKey] || DOMProperty.isCustomAttribute(propKey)) {
        DOMPropertyOperations.deleteValueForProperty(getNode(this), propKey);
      }
    }
    for (propKey in nextProps) {
      var nextProp = nextProps[propKey];
      var lastProp = propKey === STYLE ? this._previousStyleCopy : lastProps != null ? lastProps[propKey] : undefined;
      if (!nextProps.hasOwnProperty(propKey) || nextProp === lastProp || nextProp == null && lastProp == null) {
        continue;
      }
      if (propKey === STYLE) {
        if (nextProp) {
          if ("production" !== 'production') {
            checkAndWarnForMutatedStyle(this._previousStyleCopy, this._previousStyle, this);
            this._previousStyle = nextProp;
          }
          nextProp = this._previousStyleCopy = _assign({}, nextProp);
        } else {
          this._previousStyleCopy = null;
        }
        if (lastProp) {
          // Unset styles on `lastProp` but not on `nextProp`.
          for (styleName in lastProp) {
            if (lastProp.hasOwnProperty(styleName) && (!nextProp || !nextProp.hasOwnProperty(styleName))) {
              styleUpdates = styleUpdates || {};
              styleUpdates[styleName] = '';
            }
          }
          // Update styles that changed since `lastProp`.
          for (styleName in nextProp) {
            if (nextProp.hasOwnProperty(styleName) && lastProp[styleName] !== nextProp[styleName]) {
              styleUpdates = styleUpdates || {};
              styleUpdates[styleName] = nextProp[styleName];
            }
          }
        } else {
          // Relies on `updateStylesByID` not mutating `styleUpdates`.
          styleUpdates = nextProp;
        }
      } else if (registrationNameModules.hasOwnProperty(propKey)) {
        if (nextProp) {
          enqueuePutListener(this, propKey, nextProp, transaction);
        } else if (lastProp) {
          deleteListener(this, propKey);
        }
      } else if (isCustomComponent(this._tag, nextProps)) {
        if (!RESERVED_PROPS.hasOwnProperty(propKey)) {
          DOMPropertyOperations.setValueForAttribute(getNode(this), propKey, nextProp);
        }
      } else if (DOMProperty.properties[propKey] || DOMProperty.isCustomAttribute(propKey)) {
        var node = getNode(this);
        // If we're updating to null or undefined, we should remove the property
        // from the DOM node instead of inadvertently setting to a string. This
        // brings us in line with the same behavior we have on initial render.
        if (nextProp != null) {
          DOMPropertyOperations.setValueForProperty(node, propKey, nextProp);
        } else {
          DOMPropertyOperations.deleteValueForProperty(node, propKey);
        }
      }
    }
    if (styleUpdates) {
      CSSPropertyOperations.setValueForStyles(getNode(this), styleUpdates, this);
    }
  },

  /**
   * Reconciles the children with the various properties that affect the
   * children content.
   *
   * @param {object} lastProps
   * @param {object} nextProps
   * @param {ReactReconcileTransaction} transaction
   * @param {object} context
   */
  _updateDOMChildren: function (lastProps, nextProps, transaction, context) {
    var lastContent = CONTENT_TYPES[typeof lastProps.children] ? lastProps.children : null;
    var nextContent = CONTENT_TYPES[typeof nextProps.children] ? nextProps.children : null;

    var lastHtml = lastProps.dangerouslySetInnerHTML && lastProps.dangerouslySetInnerHTML.__html;
    var nextHtml = nextProps.dangerouslySetInnerHTML && nextProps.dangerouslySetInnerHTML.__html;

    // Note the use of `!=` which checks for null or undefined.
    var lastChildren = lastContent != null ? null : lastProps.children;
    var nextChildren = nextContent != null ? null : nextProps.children;

    // If we're switching from children to content/html or vice versa, remove
    // the old content
    var lastHasContentOrHtml = lastContent != null || lastHtml != null;
    var nextHasContentOrHtml = nextContent != null || nextHtml != null;
    if (lastChildren != null && nextChildren == null) {
      this.updateChildren(null, transaction, context);
    } else if (lastHasContentOrHtml && !nextHasContentOrHtml) {
      this.updateTextContent('');
      if ("production" !== 'production') {
        ReactInstrumentation.debugTool.onSetChildren(this._debugID, []);
      }
    }

    if (nextContent != null) {
      if (lastContent !== nextContent) {
        this.updateTextContent('' + nextContent);
        if ("production" !== 'production') {
          setAndValidateContentChildDev.call(this, nextContent);
        }
      }
    } else if (nextHtml != null) {
      if (lastHtml !== nextHtml) {
        this.updateMarkup('' + nextHtml);
      }
      if ("production" !== 'production') {
        ReactInstrumentation.debugTool.onSetChildren(this._debugID, []);
      }
    } else if (nextChildren != null) {
      if ("production" !== 'production') {
        setAndValidateContentChildDev.call(this, null);
      }

      this.updateChildren(nextChildren, transaction, context);
    }
  },

  getHostNode: function () {
    return getNode(this);
  },

  /**
   * Destroys all event registrations for this instance. Does not remove from
   * the DOM. That must be done by the parent.
   *
   * @internal
   */
  unmountComponent: function (safely) {
    switch (this._tag) {
      case 'audio':
      case 'form':
      case 'iframe':
      case 'img':
      case 'link':
      case 'object':
      case 'source':
      case 'video':
        var listeners = this._wrapperState.listeners;
        if (listeners) {
          for (var i = 0; i < listeners.length; i++) {
            listeners[i].remove();
          }
        }
        break;
      case 'input':
      case 'textarea':
        inputValueTracking.stopTracking(this);
        break;
      case 'html':
      case 'head':
      case 'body':
        /**
         * Components like <html> <head> and <body> can't be removed or added
         * easily in a cross-browser way, however it's valuable to be able to
         * take advantage of React's reconciliation for styling and <title>
         * management. So we just document it and throw in dangerous cases.
         */
        !false ? "production" !== 'production' ? invariant(false, '<%s> tried to unmount. Because of cross-browser quirks it is impossible to unmount some top-level components (eg <html>, <head>, and <body>) reliably and efficiently. To fix this, have a single top-level component that never unmounts render these elements.', this._tag) : _prodInvariant('66', this._tag) : void 0;
        break;
    }

    this.unmountChildren(safely);
    ReactDOMComponentTree.uncacheNode(this);
    EventPluginHub.deleteAllListeners(this);
    this._rootNodeID = 0;
    this._domID = 0;
    this._wrapperState = null;

    if ("production" !== 'production') {
      setAndValidateContentChildDev.call(this, null);
    }
  },

  getPublicInstance: function () {
    return getNode(this);
  }
};

_assign(ReactDOMComponent.prototype, ReactDOMComponent.Mixin, ReactMultiChild.Mixin);

module.exports = ReactDOMComponent;
},{"./AutoFocusUtils":532,"./CSSPropertyOperations":535,"./DOMLazyTree":539,"./DOMNamespaces":540,"./DOMProperty":541,"./DOMPropertyOperations":542,"./EventPluginHub":546,"./EventPluginRegistry":547,"./ReactBrowserEventEmitter":555,"./ReactDOMComponentFlags":562,"./ReactDOMComponentTree":563,"./ReactDOMInput":568,"./ReactDOMOption":571,"./ReactDOMSelect":572,"./ReactDOMTextarea":575,"./ReactInstrumentation":592,"./ReactMultiChild":596,"./ReactServerRenderingTransaction":604,"./escapeTextContentForBrowser":632,"./inputValueTracking":645,"./isEventSupported":647,"./reactProdInvariant":650,"./validateDOMNesting":656,"fbjs/lib/emptyFunction":394,"fbjs/lib/invariant":402,"fbjs/lib/shallowEqual":408,"fbjs/lib/warning":409,"object-assign":489}],562:[function(require,module,exports){
/**
 * Copyright (c) 2015-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */

'use strict';

var ReactDOMComponentFlags = {
  hasCachedChildNodes: 1 << 0
};

module.exports = ReactDOMComponentFlags;
},{}],563:[function(require,module,exports){
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */

'use strict';

var _prodInvariant = require('./reactProdInvariant');

var DOMProperty = require('./DOMProperty');
var ReactDOMComponentFlags = require('./ReactDOMComponentFlags');

var invariant = require('fbjs/lib/invariant');

var ATTR_NAME = DOMProperty.ID_ATTRIBUTE_NAME;
var Flags = ReactDOMComponentFlags;

var internalInstanceKey = '__reactInternalInstance$' + Math.random().toString(36).slice(2);

/**
 * Check if a given node should be cached.
 */
function shouldPrecacheNode(node, nodeID) {
  return node.nodeType === 1 && node.getAttribute(ATTR_NAME) === String(nodeID) || node.nodeType === 8 && node.nodeValue === ' react-text: ' + nodeID + ' ' || node.nodeType === 8 && node.nodeValue === ' react-empty: ' + nodeID + ' ';
}

/**
 * Drill down (through composites and empty components) until we get a host or
 * host text component.
 *
 * This is pretty polymorphic but unavoidable with the current structure we have
 * for `_renderedChildren`.
 */
function getRenderedHostOrTextFromComponent(component) {
  var rendered;
  while (rendered = component._renderedComponent) {
    component = rendered;
  }
  return component;
}

/**
 * Populate `_hostNode` on the rendered host/text component with the given
 * DOM node. The passed `inst` can be a composite.
 */
function precacheNode(inst, node) {
  var hostInst = getRenderedHostOrTextFromComponent(inst);
  hostInst._hostNode = node;
  node[internalInstanceKey] = hostInst;
}

function uncacheNode(inst) {
  var node = inst._hostNode;
  if (node) {
    delete node[internalInstanceKey];
    inst._hostNode = null;
  }
}

/**
 * Populate `_hostNode` on each child of `inst`, assuming that the children
 * match up with the DOM (element) children of `node`.
 *
 * We cache entire levels at once to avoid an n^2 problem where we access the
 * children of a node sequentially and have to walk from the start to our target
 * node every time.
 *
 * Since we update `_renderedChildren` and the actual DOM at (slightly)
 * different times, we could race here and see a newer `_renderedChildren` than
 * the DOM nodes we see. To avoid this, ReactMultiChild calls
 * `prepareToManageChildren` before we change `_renderedChildren`, at which
 * time the container's child nodes are always cached (until it unmounts).
 */
function precacheChildNodes(inst, node) {
  if (inst._flags & Flags.hasCachedChildNodes) {
    return;
  }
  var children = inst._renderedChildren;
  var childNode = node.firstChild;
  outer: for (var name in children) {
    if (!children.hasOwnProperty(name)) {
      continue;
    }
    var childInst = children[name];
    var childID = getRenderedHostOrTextFromComponent(childInst)._domID;
    if (childID === 0) {
      // We're currently unmounting this child in ReactMultiChild; skip it.
      continue;
    }
    // We assume the child nodes are in the same order as the child instances.
    for (; childNode !== null; childNode = childNode.nextSibling) {
      if (shouldPrecacheNode(childNode, childID)) {
        precacheNode(childInst, childNode);
        continue outer;
      }
    }
    // We reached the end of the DOM children without finding an ID match.
    !false ? "production" !== 'production' ? invariant(false, 'Unable to find element with ID %s.', childID) : _prodInvariant('32', childID) : void 0;
  }
  inst._flags |= Flags.hasCachedChildNodes;
}

/**
 * Given a DOM node, return the closest ReactDOMComponent or
 * ReactDOMTextComponent instance ancestor.
 */
function getClosestInstanceFromNode(node) {
  if (node[internalInstanceKey]) {
    return node[internalInstanceKey];
  }

  // Walk up the tree until we find an ancestor whose instance we have cached.
  var parents = [];
  while (!node[internalInstanceKey]) {
    parents.push(node);
    if (node.parentNode) {
      node = node.parentNode;
    } else {
      // Top of the tree. This node must not be part of a React tree (or is
      // unmounted, potentially).
      return null;
    }
  }

  var closest;
  var inst;
  for (; node && (inst = node[internalInstanceKey]); node = parents.pop()) {
    closest = inst;
    if (parents.length) {
      precacheChildNodes(inst, node);
    }
  }

  return closest;
}

/**
 * Given a DOM node, return the ReactDOMComponent or ReactDOMTextComponent
 * instance, or null if the node was not rendered by this React.
 */
function getInstanceFromNode(node) {
  var inst = getClosestInstanceFromNode(node);
  if (inst != null && inst._hostNode === node) {
    return inst;
  } else {
    return null;
  }
}

/**
 * Given a ReactDOMComponent or ReactDOMTextComponent, return the corresponding
 * DOM node.
 */
function getNodeFromInstance(inst) {
  // Without this first invariant, passing a non-DOM-component triggers the next
  // invariant for a missing parent, which is super confusing.
  !(inst._hostNode !== undefined) ? "production" !== 'production' ? invariant(false, 'getNodeFromInstance: Invalid argument.') : _prodInvariant('33') : void 0;

  if (inst._hostNode) {
    return inst._hostNode;
  }

  // Walk up the tree until we find an ancestor whose DOM node we have cached.
  var parents = [];
  while (!inst._hostNode) {
    parents.push(inst);
    !inst._hostParent ? "production" !== 'production' ? invariant(false, 'React DOM tree root should always have a node reference.') : _prodInvariant('34') : void 0;
    inst = inst._hostParent;
  }

  // Now parents contains each ancestor that does *not* have a cached native
  // node, and `inst` is the deepest ancestor that does.
  for (; parents.length; inst = parents.pop()) {
    precacheChildNodes(inst, inst._hostNode);
  }

  return inst._hostNode;
}

var ReactDOMComponentTree = {
  getClosestInstanceFromNode: getClosestInstanceFromNode,
  getInstanceFromNode: getInstanceFromNode,
  getNodeFromInstance: getNodeFromInstance,
  precacheChildNodes: precacheChildNodes,
  precacheNode: precacheNode,
  uncacheNode: uncacheNode
};

module.exports = ReactDOMComponentTree;
},{"./DOMProperty":541,"./ReactDOMComponentFlags":562,"./reactProdInvariant":650,"fbjs/lib/invariant":402}],564:[function(require,module,exports){
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */

'use strict';

var validateDOMNesting = require('./validateDOMNesting');

var DOC_NODE_TYPE = 9;

function ReactDOMContainerInfo(topLevelWrapper, node) {
  var info = {
    _topLevelWrapper: topLevelWrapper,
    _idCounter: 1,
    _ownerDocument: node ? node.nodeType === DOC_NODE_TYPE ? node : node.ownerDocument : null,
    _node: node,
    _tag: node ? node.nodeName.toLowerCase() : null,
    _namespaceURI: node ? node.namespaceURI : null
  };
  if ("production" !== 'production') {
    info._ancestorInfo = node ? validateDOMNesting.updatedAncestorInfo(null, info._tag, null) : null;
  }
  return info;
}

module.exports = ReactDOMContainerInfo;
},{"./validateDOMNesting":656}],565:[function(require,module,exports){
/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */

'use strict';

var _assign = require('object-assign');

var DOMLazyTree = require('./DOMLazyTree');
var ReactDOMComponentTree = require('./ReactDOMComponentTree');

var ReactDOMEmptyComponent = function (instantiate) {
  // ReactCompositeComponent uses this:
  this._currentElement = null;
  // ReactDOMComponentTree uses these:
  this._hostNode = null;
  this._hostParent = null;
  this._hostContainerInfo = null;
  this._domID = 0;
};
_assign(ReactDOMEmptyComponent.prototype, {
  mountComponent: function (transaction, hostParent, hostContainerInfo, context) {
    var domID = hostContainerInfo._idCounter++;
    this._domID = domID;
    this._hostParent = hostParent;
    this._hostContainerInfo = hostContainerInfo;

    var nodeValue = ' react-empty: ' + this._domID + ' ';
    if (transaction.useCreateElement) {
      var ownerDocument = hostContainerInfo._ownerDocument;
      var node = ownerDocument.createComment(nodeValue);
      ReactDOMComponentTree.precacheNode(this, node);
      return DOMLazyTree(node);
    } else {
      if (transaction.renderToStaticMarkup) {
        // Normally we'd insert a comment node, but since this is a situation
        // where React won't take over (static pages), we can simply return
        // nothing.
        return '';
      }
      return '<!--' + nodeValue + '-->';
    }
  },
  receiveComponent: function () {},
  getHostNode: function () {
    return ReactDOMComponentTree.getNodeFromInstance(this);
  },
  unmountComponent: function () {
    ReactDOMComponentTree.uncacheNode(this);
  }
});

module.exports = ReactDOMEmptyComponent;
},{"./DOMLazyTree":539,"./ReactDOMComponentTree":563,"object-assign":489}],566:[function(require,module,exports){
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */

'use strict';

var ReactDOMFeatureFlags = {
  useCreateElement: true,
  useFiber: false
};

module.exports = ReactDOMFeatureFlags;
},{}],567:[function(require,module,exports){
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */

'use strict';

var DOMChildrenOperations = require('./DOMChildrenOperations');
var ReactDOMComponentTree = require('./ReactDOMComponentTree');

/**
 * Operations used to process updates to DOM nodes.
 */
var ReactDOMIDOperations = {
  /**
   * Updates a component's children by processing a series of updates.
   *
   * @param {array<object>} updates List of update configurations.
   * @internal
   */
  dangerouslyProcessChildrenUpdates: function (parentInst, updates) {
    var node = ReactDOMComponentTree.getNodeFromInstance(parentInst);
    DOMChildrenOperations.processUpdates(node, updates);
  }
};

module.exports = ReactDOMIDOperations;
},{"./DOMChildrenOperations":538,"./ReactDOMComponentTree":563}],568:[function(require,module,exports){
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */

'use strict';

var _prodInvariant = require('./reactProdInvariant'),
    _assign = require('object-assign');

var DOMPropertyOperations = require('./DOMPropertyOperations');
var LinkedValueUtils = require('./LinkedValueUtils');
var ReactDOMComponentTree = require('./ReactDOMComponentTree');
var ReactUpdates = require('./ReactUpdates');

var invariant = require('fbjs/lib/invariant');
var warning = require('fbjs/lib/warning');

var didWarnValueLink = false;
var didWarnCheckedLink = false;
var didWarnValueDefaultValue = false;
var didWarnCheckedDefaultChecked = false;
var didWarnControlledToUncontrolled = false;
var didWarnUncontrolledToControlled = false;

function forceUpdateIfMounted() {
  if (this._rootNodeID) {
    // DOM component is still mounted; update
    ReactDOMInput.updateWrapper(this);
  }
}

function isControlled(props) {
  var usesChecked = props.type === 'checkbox' || props.type === 'radio';
  return usesChecked ? props.checked != null : props.value != null;
}

/**
 * Implements an <input> host component that allows setting these optional
 * props: `checked`, `value`, `defaultChecked`, and `defaultValue`.
 *
 * If `checked` or `value` are not supplied (or null/undefined), user actions
 * that affect the checked state or value will trigger updates to the element.
 *
 * If they are supplied (and not null/undefined), the rendered element will not
 * trigger updates to the element. Instead, the props must change in order for
 * the rendered element to be updated.
 *
 * The rendered element will be initialized as unchecked (or `defaultChecked`)
 * with an empty value (or `defaultValue`).
 *
 * @see http://www.w3.org/TR/2012/WD-html5-20121025/the-input-element.html
 */
var ReactDOMInput = {
  getHostProps: function (inst, props) {
    var value = LinkedValueUtils.getValue(props);
    var checked = LinkedValueUtils.getChecked(props);

    var hostProps = _assign({
      // Make sure we set .type before any other properties (setting .value
      // before .type means .value is lost in IE11 and below)
      type: undefined,
      // Make sure we set .step before .value (setting .value before .step
      // means .value is rounded on mount, based upon step precision)
      step: undefined,
      // Make sure we set .min & .max before .value (to ensure proper order
      // in corner cases such as min or max deriving from value, e.g. Issue #7170)
      min: undefined,
      max: undefined
    }, props, {
      defaultChecked: undefined,
      defaultValue: undefined,
      value: value != null ? value : inst._wrapperState.initialValue,
      checked: checked != null ? checked : inst._wrapperState.initialChecked,
      onChange: inst._wrapperState.onChange
    });

    return hostProps;
  },

  mountWrapper: function (inst, props) {
    if ("production" !== 'production') {
      LinkedValueUtils.checkPropTypes('input', props, inst._currentElement._owner);

      var owner = inst._currentElement._owner;

      if (props.valueLink !== undefined && !didWarnValueLink) {
        "production" !== 'production' ? warning(false, '`valueLink` prop on `input` is deprecated; set `value` and `onChange` instead.') : void 0;
        didWarnValueLink = true;
      }
      if (props.checkedLink !== undefined && !didWarnCheckedLink) {
        "production" !== 'production' ? warning(false, '`checkedLink` prop on `input` is deprecated; set `value` and `onChange` instead.') : void 0;
        didWarnCheckedLink = true;
      }
      if (props.checked !== undefined && props.defaultChecked !== undefined && !didWarnCheckedDefaultChecked) {
        "production" !== 'production' ? warning(false, '%s contains an input of type %s with both checked and defaultChecked props. ' + 'Input elements must be either controlled or uncontrolled ' + '(specify either the checked prop, or the defaultChecked prop, but not ' + 'both). Decide between using a controlled or uncontrolled input ' + 'element and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components', owner && owner.getName() || 'A component', props.type) : void 0;
        didWarnCheckedDefaultChecked = true;
      }
      if (props.value !== undefined && props.defaultValue !== undefined && !didWarnValueDefaultValue) {
        "production" !== 'production' ? warning(false, '%s contains an input of type %s with both value and defaultValue props. ' + 'Input elements must be either controlled or uncontrolled ' + '(specify either the value prop, or the defaultValue prop, but not ' + 'both). Decide between using a controlled or uncontrolled input ' + 'element and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components', owner && owner.getName() || 'A component', props.type) : void 0;
        didWarnValueDefaultValue = true;
      }
    }

    var defaultValue = props.defaultValue;
    inst._wrapperState = {
      initialChecked: props.checked != null ? props.checked : props.defaultChecked,
      initialValue: props.value != null ? props.value : defaultValue,
      listeners: null,
      onChange: _handleChange.bind(inst),
      controlled: isControlled(props)
    };
  },

  updateWrapper: function (inst) {
    var props = inst._currentElement.props;

    if ("production" !== 'production') {
      var controlled = isControlled(props);
      var owner = inst._currentElement._owner;

      if (!inst._wrapperState.controlled && controlled && !didWarnUncontrolledToControlled) {
        "production" !== 'production' ? warning(false, '%s is changing an uncontrolled input of type %s to be controlled. ' + 'Input elements should not switch from uncontrolled to controlled (or vice versa). ' + 'Decide between using a controlled or uncontrolled input ' + 'element for the lifetime of the component. More info: https://fb.me/react-controlled-components', owner && owner.getName() || 'A component', props.type) : void 0;
        didWarnUncontrolledToControlled = true;
      }
      if (inst._wrapperState.controlled && !controlled && !didWarnControlledToUncontrolled) {
        "production" !== 'production' ? warning(false, '%s is changing a controlled input of type %s to be uncontrolled. ' + 'Input elements should not switch from controlled to uncontrolled (or vice versa). ' + 'Decide between using a controlled or uncontrolled input ' + 'element for the lifetime of the component. More info: https://fb.me/react-controlled-components', owner && owner.getName() || 'A component', props.type) : void 0;
        didWarnControlledToUncontrolled = true;
      }
    }

    // TODO: Shouldn't this be getChecked(props)?
    var checked = props.checked;
    if (checked != null) {
      DOMPropertyOperations.setValueForProperty(ReactDOMComponentTree.getNodeFromInstance(inst), 'checked', checked || false);
    }

    var node = ReactDOMComponentTree.getNodeFromInstance(inst);
    var value = LinkedValueUtils.getValue(props);
    if (value != null) {
      if (value === 0 && node.value === '') {
        node.value = '0';
        // Note: IE9 reports a number inputs as 'text', so check props instead.
      } else if (props.type === 'number') {
        // Simulate `input.valueAsNumber`. IE9 does not support it
        var valueAsNumber = parseFloat(node.value, 10) || 0;

        if (
        // eslint-disable-next-line
        value != valueAsNumber ||
        // eslint-disable-next-line
        value == valueAsNumber && node.value != value) {
          // Cast `value` to a string to ensure the value is set correctly. While
          // browsers typically do this as necessary, jsdom doesn't.
          node.value = '' + value;
        }
      } else if (node.value !== '' + value) {
        // Cast `value` to a string to ensure the value is set correctly. While
        // browsers typically do this as necessary, jsdom doesn't.
        node.value = '' + value;
      }
    } else {
      if (props.value == null && props.defaultValue != null) {
        // In Chrome, assigning defaultValue to certain input types triggers input validation.
        // For number inputs, the display value loses trailing decimal points. For email inputs,
        // Chrome raises "The specified value <x> is not a valid email address".
        //
        // Here we check to see if the defaultValue has actually changed, avoiding these problems
        // when the user is inputting text
        //
        // https://github.com/facebook/react/issues/7253
        if (node.defaultValue !== '' + props.defaultValue) {
          node.defaultValue = '' + props.defaultValue;
        }
      }
      if (props.checked == null && props.defaultChecked != null) {
        node.defaultChecked = !!props.defaultChecked;
      }
    }
  },

  postMountWrapper: function (inst) {
    var props = inst._currentElement.props;

    // This is in postMount because we need access to the DOM node, which is not
    // available until after the component has mounted.
    var node = ReactDOMComponentTree.getNodeFromInstance(inst);

    // Detach value from defaultValue. We won't do anything if we're working on
    // submit or reset inputs as those values & defaultValues are linked. They
    // are not resetable nodes so this operation doesn't matter and actually
    // removes browser-default values (eg "Submit Query") when no value is
    // provided.

    switch (props.type) {
      case 'submit':
      case 'reset':
        break;
      case 'color':
      case 'date':
      case 'datetime':
      case 'datetime-local':
      case 'month':
      case 'time':
      case 'week':
        // This fixes the no-show issue on iOS Safari and Android Chrome:
        // https://github.com/facebook/react/issues/7233
        node.value = '';
        node.value = node.defaultValue;
        break;
      default:
        node.value = node.value;
        break;
    }

    // Normally, we'd just do `node.checked = node.checked` upon initial mount, less this bug
    // this is needed to work around a chrome bug where setting defaultChecked
    // will sometimes influence the value of checked (even after detachment).
    // Reference: https://bugs.chromium.org/p/chromium/issues/detail?id=608416
    // We need to temporarily unset name to avoid disrupting radio button groups.
    var name = node.name;
    if (name !== '') {
      node.name = '';
    }
    node.defaultChecked = !node.defaultChecked;
    node.defaultChecked = !node.defaultChecked;
    if (name !== '') {
      node.name = name;
    }
  }
};

function _handleChange(event) {
  var props = this._currentElement.props;

  var returnValue = LinkedValueUtils.executeOnChange(props, event);

  // Here we use asap to wait until all updates have propagated, which
  // is important when using controlled components within layers:
  // https://github.com/facebook/react/issues/1698
  ReactUpdates.asap(forceUpdateIfMounted, this);

  var name = props.name;
  if (props.type === 'radio' && name != null) {
    var rootNode = ReactDOMComponentTree.getNodeFromInstance(this);
    var queryRoot = rootNode;

    while (queryRoot.parentNode) {
      queryRoot = queryRoot.parentNode;
    }

    // If `rootNode.form` was non-null, then we could try `form.elements`,
    // but that sometimes behaves strangely in IE8. We could also try using
    // `form.getElementsByName`, but that will only return direct children
    // and won't include inputs that use the HTML5 `form=` attribute. Since
    // the input might not even be in a form, let's just use the global
    // `querySelectorAll` to ensure we don't miss anything.
    var group = queryRoot.querySelectorAll('input[name=' + JSON.stringify('' + name) + '][type="radio"]');

    for (var i = 0; i < group.length; i++) {
      var otherNode = group[i];
      if (otherNode === rootNode || otherNode.form !== rootNode.form) {
        continue;
      }
      // This will throw if radio buttons rendered by different copies of React
      // and the same name are rendered into the same form (same as #1939).
      // That's probably okay; we don't support it just as we don't support
      // mixing React radio buttons with non-React ones.
      var otherInstance = ReactDOMComponentTree.getInstanceFromNode(otherNode);
      !otherInstance ? "production" !== 'production' ? invariant(false, 'ReactDOMInput: Mixing React and non-React radio inputs with the same `name` is not supported.') : _prodInvariant('90') : void 0;
      // If this is a controlled radio button group, forcing the input that
      // was previously checked to update will cause it to be come re-checked
      // as appropriate.
      ReactUpdates.asap(forceUpdateIfMounted, otherInstance);
    }
  }

  return returnValue;
}

module.exports = ReactDOMInput;
},{"./DOMPropertyOperations":542,"./LinkedValueUtils":553,"./ReactDOMComponentTree":563,"./ReactUpdates":607,"./reactProdInvariant":650,"fbjs/lib/invariant":402,"fbjs/lib/warning":409,"object-assign":489}],569:[function(require,module,exports){
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */

'use strict';

var DOMProperty = require('./DOMProperty');
var ReactComponentTreeHook = require('react/lib/ReactComponentTreeHook');

var warning = require('fbjs/lib/warning');

var warnedProperties = {};
var rARIA = new RegExp('^(aria)-[' + DOMProperty.ATTRIBUTE_NAME_CHAR + ']*$');

function validateProperty(tagName, name, debugID) {
  if (warnedProperties.hasOwnProperty(name) && warnedProperties[name]) {
    return true;
  }

  if (rARIA.test(name)) {
    var lowerCasedName = name.toLowerCase();
    var standardName = DOMProperty.getPossibleStandardName.hasOwnProperty(lowerCasedName) ? DOMProperty.getPossibleStandardName[lowerCasedName] : null;

    // If this is an aria-* attribute, but is not listed in the known DOM
    // DOM properties, then it is an invalid aria-* attribute.
    if (standardName == null) {
      warnedProperties[name] = true;
      return false;
    }
    // aria-* attributes should be lowercase; suggest the lowercase version.
    if (name !== standardName) {
      "production" !== 'production' ? warning(false, 'Unknown ARIA attribute %s. Did you mean %s?%s', name, standardName, ReactComponentTreeHook.getStackAddendumByID(debugID)) : void 0;
      warnedProperties[name] = true;
      return true;
    }
  }

  return true;
}

function warnInvalidARIAProps(debugID, element) {
  var invalidProps = [];

  for (var key in element.props) {
    var isValid = validateProperty(element.type, key, debugID);
    if (!isValid) {
      invalidProps.push(key);
    }
  }

  var unknownPropString = invalidProps.map(function (prop) {
    return '`' + prop + '`';
  }).join(', ');

  if (invalidProps.length === 1) {
    "production" !== 'production' ? warning(false, 'Invalid aria prop %s on <%s> tag. ' + 'For details, see https://fb.me/invalid-aria-prop%s', unknownPropString, element.type, ReactComponentTreeHook.getStackAddendumByID(debugID)) : void 0;
  } else if (invalidProps.length > 1) {
    "production" !== 'production' ? warning(false, 'Invalid aria props %s on <%s> tag. ' + 'For details, see https://fb.me/invalid-aria-prop%s', unknownPropString, element.type, ReactComponentTreeHook.getStackAddendumByID(debugID)) : void 0;
  }
}

function handleElement(debugID, element) {
  if (element == null || typeof element.type !== 'string') {
    return;
  }
  if (element.type.indexOf('-') >= 0 || element.props.is) {
    return;
  }

  warnInvalidARIAProps(debugID, element);
}

var ReactDOMInvalidARIAHook = {
  onBeforeMountComponent: function (debugID, element) {
    if ("production" !== 'production') {
      handleElement(debugID, element);
    }
  },
  onBeforeUpdateComponent: function (debugID, element) {
    if ("production" !== 'production') {
      handleElement(debugID, element);
    }
  }
};

module.exports = ReactDOMInvalidARIAHook;
},{"./DOMProperty":541,"fbjs/lib/warning":409,"react/lib/ReactComponentTreeHook":677}],570:[function(require,module,exports){
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */

'use strict';

var ReactComponentTreeHook = require('react/lib/ReactComponentTreeHook');

var warning = require('fbjs/lib/warning');

var didWarnValueNull = false;

function handleElement(debugID, element) {
  if (element == null) {
    return;
  }
  if (element.type !== 'input' && element.type !== 'textarea' && element.type !== 'select') {
    return;
  }
  if (element.props != null && element.props.value === null && !didWarnValueNull) {
    "production" !== 'production' ? warning(false, '`value` prop on `%s` should not be null. ' + 'Consider using the empty string to clear the component or `undefined` ' + 'for uncontrolled components.%s', element.type, ReactComponentTreeHook.getStackAddendumByID(debugID)) : void 0;

    didWarnValueNull = true;
  }
}

var ReactDOMNullInputValuePropHook = {
  onBeforeMountComponent: function (debugID, element) {
    handleElement(debugID, element);
  },
  onBeforeUpdateComponent: function (debugID, element) {
    handleElement(debugID, element);
  }
};

module.exports = ReactDOMNullInputValuePropHook;
},{"fbjs/lib/warning":409,"react/lib/ReactComponentTreeHook":677}],571:[function(require,module,exports){
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */

'use strict';

var _assign = require('object-assign');

var React = require('react/lib/React');
var ReactDOMComponentTree = require('./ReactDOMComponentTree');
var ReactDOMSelect = require('./ReactDOMSelect');

var warning = require('fbjs/lib/warning');
var didWarnInvalidOptionChildren = false;

function flattenChildren(children) {
  var content = '';

  // Flatten children and warn if they aren't strings or numbers;
  // invalid types are ignored.
  React.Children.forEach(children, function (child) {
    if (child == null) {
      return;
    }
    if (typeof child === 'string' || typeof child === 'number') {
      content += child;
    } else if (!didWarnInvalidOptionChildren) {
      didWarnInvalidOptionChildren = true;
      "production" !== 'production' ? warning(false, 'Only strings and numbers are supported as <option> children.') : void 0;
    }
  });

  return content;
}

/**
 * Implements an <option> host component that warns when `selected` is set.
 */
var ReactDOMOption = {
  mountWrapper: function (inst, props, hostParent) {
    // TODO (yungsters): Remove support for `selected` in <option>.
    if ("production" !== 'production') {
      "production" !== 'production' ? warning(props.selected == null, 'Use the `defaultValue` or `value` props on <select> instead of ' + 'setting `selected` on <option>.') : void 0;
    }

    // Look up whether this option is 'selected'
    var selectValue = null;
    if (hostParent != null) {
      var selectParent = hostParent;

      if (selectParent._tag === 'optgroup') {
        selectParent = selectParent._hostParent;
      }

      if (selectParent != null && selectParent._tag === 'select') {
        selectValue = ReactDOMSelect.getSelectValueContext(selectParent);
      }
    }

    // If the value is null (e.g., no specified value or after initial mount)
    // or missing (e.g., for <datalist>), we don't change props.selected
    var selected = null;
    if (selectValue != null) {
      var value;
      if (props.value != null) {
        value = props.value + '';
      } else {
        value = flattenChildren(props.children);
      }
      selected = false;
      if (Array.isArray(selectValue)) {
        // multiple
        for (var i = 0; i < selectValue.length; i++) {
          if ('' + selectValue[i] === value) {
            selected = true;
            break;
          }
        }
      } else {
        selected = '' + selectValue === value;
      }
    }

    inst._wrapperState = { selected: selected };
  },

  postMountWrapper: function (inst) {
    // value="" should make a value attribute (#6219)
    var props = inst._currentElement.props;
    if (props.value != null) {
      var node = ReactDOMComponentTree.getNodeFromInstance(inst);
      node.setAttribute('value', props.value);
    }
  },

  getHostProps: function (inst, props) {
    var hostProps = _assign({ selected: undefined, children: undefined }, props);

    // Read state only from initial mount because <select> updates value
    // manually; we need the initial state only for server rendering
    if (inst._wrapperState.selected != null) {
      hostProps.selected = inst._wrapperState.selected;
    }

    var content = flattenChildren(props.children);

    if (content) {
      hostProps.children = content;
    }

    return hostProps;
  }
};

module.exports = ReactDOMOption;
},{"./ReactDOMComponentTree":563,"./ReactDOMSelect":572,"fbjs/lib/warning":409,"object-assign":489,"react/lib/React":674}],572:[function(require,module,exports){
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */

'use strict';

var _assign = require('object-assign');

var LinkedValueUtils = require('./LinkedValueUtils');
var ReactDOMComponentTree = require('./ReactDOMComponentTree');
var ReactUpdates = require('./ReactUpdates');

var warning = require('fbjs/lib/warning');

var didWarnValueLink = false;
var didWarnValueDefaultValue = false;

function updateOptionsIfPendingUpdateAndMounted() {
  if (this._rootNodeID && this._wrapperState.pendingUpdate) {
    this._wrapperState.pendingUpdate = false;

    var props = this._currentElement.props;
    var value = LinkedValueUtils.getValue(props);

    if (value != null) {
      updateOptions(this, Boolean(props.multiple), value);
    }
  }
}

function getDeclarationErrorAddendum(owner) {
  if (owner) {
    var name = owner.getName();
    if (name) {
      return ' Check the render method of `' + name + '`.';
    }
  }
  return '';
}

var valuePropNames = ['value', 'defaultValue'];

/**
 * Validation function for `value` and `defaultValue`.
 * @private
 */
function checkSelectPropTypes(inst, props) {
  var owner = inst._currentElement._owner;
  LinkedValueUtils.checkPropTypes('select', props, owner);

  if (props.valueLink !== undefined && !didWarnValueLink) {
    "production" !== 'production' ? warning(false, '`valueLink` prop on `select` is deprecated; set `value` and `onChange` instead.') : void 0;
    didWarnValueLink = true;
  }

  for (var i = 0; i < valuePropNames.length; i++) {
    var propName = valuePropNames[i];
    if (props[propName] == null) {
      continue;
    }
    var isArray = Array.isArray(props[propName]);
    if (props.multiple && !isArray) {
      "production" !== 'production' ? warning(false, 'The `%s` prop supplied to <select> must be an array if ' + '`multiple` is true.%s', propName, getDeclarationErrorAddendum(owner)) : void 0;
    } else if (!props.multiple && isArray) {
      "production" !== 'production' ? warning(false, 'The `%s` prop supplied to <select> must be a scalar ' + 'value if `multiple` is false.%s', propName, getDeclarationErrorAddendum(owner)) : void 0;
    }
  }
}

/**
 * @param {ReactDOMComponent} inst
 * @param {boolean} multiple
 * @param {*} propValue A stringable (with `multiple`, a list of stringables).
 * @private
 */
function updateOptions(inst, multiple, propValue) {
  var selectedValue, i;
  var options = ReactDOMComponentTree.getNodeFromInstance(inst).options;

  if (multiple) {
    selectedValue = {};
    for (i = 0; i < propValue.length; i++) {
      selectedValue['' + propValue[i]] = true;
    }
    for (i = 0; i < options.length; i++) {
      var selected = selectedValue.hasOwnProperty(options[i].value);
      if (options[i].selected !== selected) {
        options[i].selected = selected;
      }
    }
  } else {
    // Do not set `select.value` as exact behavior isn't consistent across all
    // browsers for all cases.
    selectedValue = '' + propValue;
    for (i = 0; i < options.length; i++) {
      if (options[i].value === selectedValue) {
        options[i].selected = true;
        return;
      }
    }
    if (options.length) {
      options[0].selected = true;
    }
  }
}

/**
 * Implements a <select> host component that allows optionally setting the
 * props `value` and `defaultValue`. If `multiple` is false, the prop must be a
 * stringable. If `multiple` is true, the prop must be an array of stringables.
 *
 * If `value` is not supplied (or null/undefined), user actions that change the
 * selected option will trigger updates to the rendered options.
 *
 * If it is supplied (and not null/undefined), the rendered options will not
 * update in response to user actions. Instead, the `value` prop must change in
 * order for the rendered options to update.
 *
 * If `defaultValue` is provided, any options with the supplied values will be
 * selected.
 */
var ReactDOMSelect = {
  getHostProps: function (inst, props) {
    return _assign({}, props, {
      onChange: inst._wrapperState.onChange,
      value: undefined
    });
  },

  mountWrapper: function (inst, props) {
    if ("production" !== 'production') {
      checkSelectPropTypes(inst, props);
    }

    var value = LinkedValueUtils.getValue(props);
    inst._wrapperState = {
      pendingUpdate: false,
      initialValue: value != null ? value : props.defaultValue,
      listeners: null,
      onChange: _handleChange.bind(inst),
      wasMultiple: Boolean(props.multiple)
    };

    if (props.value !== undefined && props.defaultValue !== undefined && !didWarnValueDefaultValue) {
      "production" !== 'production' ? warning(false, 'Select elements must be either controlled or uncontrolled ' + '(specify either the value prop, or the defaultValue prop, but not ' + 'both). Decide between using a controlled or uncontrolled select ' + 'element and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components') : void 0;
      didWarnValueDefaultValue = true;
    }
  },

  getSelectValueContext: function (inst) {
    // ReactDOMOption looks at this initial value so the initial generated
    // markup has correct `selected` attributes
    return inst._wrapperState.initialValue;
  },

  postUpdateWrapper: function (inst) {
    var props = inst._currentElement.props;

    // After the initial mount, we control selected-ness manually so don't pass
    // this value down
    inst._wrapperState.initialValue = undefined;

    var wasMultiple = inst._wrapperState.wasMultiple;
    inst._wrapperState.wasMultiple = Boolean(props.multiple);

    var value = LinkedValueUtils.getValue(props);
    if (value != null) {
      inst._wrapperState.pendingUpdate = false;
      updateOptions(inst, Boolean(props.multiple), value);
    } else if (wasMultiple !== Boolean(props.multiple)) {
      // For simplicity, reapply `defaultValue` if `multiple` is toggled.
      if (props.defaultValue != null) {
        updateOptions(inst, Boolean(props.multiple), props.defaultValue);
      } else {
        // Revert the select back to its default unselected state.
        updateOptions(inst, Boolean(props.multiple), props.multiple ? [] : '');
      }
    }
  }
};

function _handleChange(event) {
  var props = this._currentElement.props;
  var returnValue = LinkedValueUtils.executeOnChange(props, event);

  if (this._rootNodeID) {
    this._wrapperState.pendingUpdate = true;
  }
  ReactUpdates.asap(updateOptionsIfPendingUpdateAndMounted, this);
  return returnValue;
}

module.exports = ReactDOMSelect;
},{"./LinkedValueUtils":553,"./ReactDOMComponentTree":563,"./ReactUpdates":607,"fbjs/lib/warning":409,"object-assign":489}],573:[function(require,module,exports){
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */

'use strict';

var ExecutionEnvironment = require('fbjs/lib/ExecutionEnvironment');

var getNodeForCharacterOffset = require('./getNodeForCharacterOffset');
var getTextContentAccessor = require('./getTextContentAccessor');

/**
 * While `isCollapsed` is available on the Selection object and `collapsed`
 * is available on the Range object, IE11 sometimes gets them wrong.
 * If the anchor/focus nodes and offsets are the same, the range is collapsed.
 */
function isCollapsed(anchorNode, anchorOffset, focusNode, focusOffset) {
  return anchorNode === focusNode && anchorOffset === focusOffset;
}

/**
 * Get the appropriate anchor and focus node/offset pairs for IE.
 *
 * The catch here is that IE's selection API doesn't provide information
 * about whether the selection is forward or backward, so we have to
 * behave as though it's always forward.
 *
 * IE text differs from modern selection in that it behaves as though
 * block elements end with a new line. This means character offsets will
 * differ between the two APIs.
 *
 * @param {DOMElement} node
 * @return {object}
 */
function getIEOffsets(node) {
  var selection = document.selection;
  var selectedRange = selection.createRange();
  var selectedLength = selectedRange.text.length;

  // Duplicate selection so we can move range without breaking user selection.
  var fromStart = selectedRange.duplicate();
  fromStart.moveToElementText(node);
  fromStart.setEndPoint('EndToStart', selectedRange);

  var startOffset = fromStart.text.length;
  var endOffset = startOffset + selectedLength;

  return {
    start: startOffset,
    end: endOffset
  };
}

/**
 * @param {DOMElement} node
 * @return {?object}
 */
function getModernOffsets(node) {
  var selection = window.getSelection && window.getSelection();

  if (!selection || selection.rangeCount === 0) {
    return null;
  }

  var anchorNode = selection.anchorNode;
  var anchorOffset = selection.anchorOffset;
  var focusNode = selection.focusNode;
  var focusOffset = selection.focusOffset;

  var currentRange = selection.getRangeAt(0);

  // In Firefox, range.startContainer and range.endContainer can be "anonymous
  // divs", e.g. the up/down buttons on an <input type="number">. Anonymous
  // divs do not seem to expose properties, triggering a "Permission denied
  // error" if any of its properties are accessed. The only seemingly possible
  // way to avoid erroring is to access a property that typically works for
  // non-anonymous divs and catch any error that may otherwise arise. See
  // https://bugzilla.mozilla.org/show_bug.cgi?id=208427
  try {
    /* eslint-disable no-unused-expressions */
    currentRange.startContainer.nodeType;
    currentRange.endContainer.nodeType;
    /* eslint-enable no-unused-expressions */
  } catch (e) {
    return null;
  }

  // If the node and offset values are the same, the selection is collapsed.
  // `Selection.isCollapsed` is available natively, but IE sometimes gets
  // this value wrong.
  var isSelectionCollapsed = isCollapsed(selection.anchorNode, selection.anchorOffset, selection.focusNode, selection.focusOffset);

  var rangeLength = isSelectionCollapsed ? 0 : currentRange.toString().length;

  var tempRange = currentRange.cloneRange();
  tempRange.selectNodeContents(node);
  tempRange.setEnd(currentRange.startContainer, currentRange.startOffset);

  var isTempRangeCollapsed = isCollapsed(tempRange.startContainer, tempRange.startOffset, tempRange.endContainer, tempRange.endOffset);

  var start = isTempRangeCollapsed ? 0 : tempRange.toString().length;
  var end = start + rangeLength;

  // Detect whether the selection is backward.
  var detectionRange = document.createRange();
  detectionRange.setStart(anchorNode, anchorOffset);
  detectionRange.setEnd(focusNode, focusOffset);
  var isBackward = detectionRange.collapsed;

  return {
    start: isBackward ? end : start,
    end: isBackward ? start : end
  };
}

/**
 * @param {DOMElement|DOMTextNode} node
 * @param {object} offsets
 */
function setIEOffsets(node, offsets) {
  var range = document.selection.createRange().duplicate();
  var start, end;

  if (offsets.end === undefined) {
    start = offsets.start;
    end = start;
  } else if (offsets.start > offsets.end) {
    start = offsets.end;
    end = offsets.start;
  } else {
    start = offsets.start;
    end = offsets.end;
  }

  range.moveToElementText(node);
  range.moveStart('character', start);
  range.setEndPoint('EndToStart', range);
  range.moveEnd('character', end - start);
  range.select();
}

/**
 * In modern non-IE browsers, we can support both forward and backward
 * selections.
 *
 * Note: IE10+ supports the Selection object, but it does not support
 * the `extend` method, which means that even in modern IE, it's not possible
 * to programmatically create a backward selection. Thus, for all IE
 * versions, we use the old IE API to create our selections.
 *
 * @param {DOMElement|DOMTextNode} node
 * @param {object} offsets
 */
function setModernOffsets(node, offsets) {
  if (!window.getSelection) {
    return;
  }

  var selection = window.getSelection();
  var length = node[getTextContentAccessor()].length;
  var start = Math.min(offsets.start, length);
  var end = offsets.end === undefined ? start : Math.min(offsets.end, length);

  // IE 11 uses modern selection, but doesn't support the extend method.
  // Flip backward selections, so we can set with a single range.
  if (!selection.extend && start > end) {
    var temp = end;
    end = start;
    start = temp;
  }

  var startMarker = getNodeForCharacterOffset(node, start);
  var endMarker = getNodeForCharacterOffset(node, end);

  if (startMarker && endMarker) {
    var range = document.createRange();
    range.setStart(startMarker.node, startMarker.offset);
    selection.removeAllRanges();

    if (start > end) {
      selection.addRange(range);
      selection.extend(endMarker.node, endMarker.offset);
    } else {
      range.setEnd(endMarker.node, endMarker.offset);
      selection.addRange(range);
    }
  }
}

var useIEOffsets = ExecutionEnvironment.canUseDOM && 'selection' in document && !('getSelection' in window);

var ReactDOMSelection = {
  /**
   * @param {DOMElement} node
   */
  getOffsets: useIEOffsets ? getIEOffsets : getModernOffsets,

  /**
   * @param {DOMElement|DOMTextNode} node
   * @param {object} offsets
   */
  setOffsets: useIEOffsets ? setIEOffsets : setModernOffsets
};

module.exports = ReactDOMSelection;
},{"./getNodeForCharacterOffset":642,"./getTextContentAccessor":643,"fbjs/lib/ExecutionEnvironment":388}],574:[function(require,module,exports){
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */

'use strict';

var _prodInvariant = require('./reactProdInvariant'),
    _assign = require('object-assign');

var DOMChildrenOperations = require('./DOMChildrenOperations');
var DOMLazyTree = require('./DOMLazyTree');
var ReactDOMComponentTree = require('./ReactDOMComponentTree');

var escapeTextContentForBrowser = require('./escapeTextContentForBrowser');
var invariant = require('fbjs/lib/invariant');
var validateDOMNesting = require('./validateDOMNesting');

/**
 * Text nodes violate a couple assumptions that React makes about components:
 *
 *  - When mounting text into the DOM, adjacent text nodes are merged.
 *  - Text nodes cannot be assigned a React root ID.
 *
 * This component is used to wrap strings between comment nodes so that they
 * can undergo the same reconciliation that is applied to elements.
 *
 * TODO: Investigate representing React components in the DOM with text nodes.
 *
 * @class ReactDOMTextComponent
 * @extends ReactComponent
 * @internal
 */
var ReactDOMTextComponent = function (text) {
  // TODO: This is really a ReactText (ReactNode), not a ReactElement
  this._currentElement = text;
  this._stringText = '' + text;
  // ReactDOMComponentTree uses these:
  this._hostNode = null;
  this._hostParent = null;

  // Properties
  this._domID = 0;
  this._mountIndex = 0;
  this._closingComment = null;
  this._commentNodes = null;
};

_assign(ReactDOMTextComponent.prototype, {
  /**
   * Creates the markup for this text node. This node is not intended to have
   * any features besides containing text content.
   *
   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
   * @return {string} Markup for this text node.
   * @internal
   */
  mountComponent: function (transaction, hostParent, hostContainerInfo, context) {
    if ("production" !== 'production') {
      var parentInfo;
      if (hostParent != null) {
        parentInfo = hostParent._ancestorInfo;
      } else if (hostContainerInfo != null) {
        parentInfo = hostContainerInfo._ancestorInfo;
      }
      if (parentInfo) {
        // parentInfo should always be present except for the top-level
        // component when server rendering
        validateDOMNesting(null, this._stringText, this, parentInfo);
      }
    }

    var domID = hostContainerInfo._idCounter++;
    var openingValue = ' react-text: ' + domID + ' ';
    var closingValue = ' /react-text ';
    this._domID = domID;
    this._hostParent = hostParent;
    if (transaction.useCreateElement) {
      var ownerDocument = hostContainerInfo._ownerDocument;
      var openingComment = ownerDocument.createComment(openingValue);
      var closingComment = ownerDocument.createComment(closingValue);
      var lazyTree = DOMLazyTree(ownerDocument.createDocumentFragment());
      DOMLazyTree.queueChild(lazyTree, DOMLazyTree(openingComment));
      if (this._stringText) {
        DOMLazyTree.queueChild(lazyTree, DOMLazyTree(ownerDocument.createTextNode(this._stringText)));
      }
      DOMLazyTree.queueChild(lazyTree, DOMLazyTree(closingComment));
      ReactDOMComponentTree.precacheNode(this, openingComment);
      this._closingComment = closingComment;
      return lazyTree;
    } else {
      var escapedText = escapeTextContentForBrowser(this._stringText);

      if (transaction.renderToStaticMarkup) {
        // Normally we'd wrap this between comment nodes for the reasons stated
        // above, but since this is a situation where React won't take over
        // (static pages), we can simply return the text as it is.
        return escapedText;
      }

      return '<!--' + openingValue + '-->' + escapedText + '<!--' + closingValue + '-->';
    }
  },

  /**
   * Updates this component by updating the text content.
   *
   * @param {ReactText} nextText The next text content
   * @param {ReactReconcileTransaction} transaction
   * @internal
   */
  receiveComponent: function (nextText, transaction) {
    if (nextText !== this._currentElement) {
      this._currentElement = nextText;
      var nextStringText = '' + nextText;
      if (nextStringText !== this._stringText) {
        // TODO: Save this as pending props and use performUpdateIfNecessary
        // and/or updateComponent to do the actual update for consistency with
        // other component types?
        this._stringText = nextStringText;
        var commentNodes = this.getHostNode();
        DOMChildrenOperations.replaceDelimitedText(commentNodes[0], commentNodes[1], nextStringText);
      }
    }
  },

  getHostNode: function () {
    var hostNode = this._commentNodes;
    if (hostNode) {
      return hostNode;
    }
    if (!this._closingComment) {
      var openingComment = ReactDOMComponentTree.getNodeFromInstance(this);
      var node = openingComment.nextSibling;
      while (true) {
        !(node != null) ? "production" !== 'production' ? invariant(false, 'Missing closing comment for text component %s', this._domID) : _prodInvariant('67', this._domID) : void 0;
        if (node.nodeType === 8 && node.nodeValue === ' /react-text ') {
          this._closingComment = node;
          break;
        }
        node = node.nextSibling;
      }
    }
    hostNode = [this._hostNode, this._closingComment];
    this._commentNodes = hostNode;
    return hostNode;
  },

  unmountComponent: function () {
    this._closingComment = null;
    this._commentNodes = null;
    ReactDOMComponentTree.uncacheNode(this);
  }
});

module.exports = ReactDOMTextComponent;
},{"./DOMChildrenOperations":538,"./DOMLazyTree":539,"./ReactDOMComponentTree":563,"./escapeTextContentForBrowser":632,"./reactProdInvariant":650,"./validateDOMNesting":656,"fbjs/lib/invariant":402,"object-assign":489}],575:[function(require,module,exports){
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */

'use strict';

var _prodInvariant = require('./reactProdInvariant'),
    _assign = require('object-assign');

var LinkedValueUtils = require('./LinkedValueUtils');
var ReactDOMComponentTree = require('./ReactDOMComponentTree');
var ReactUpdates = require('./ReactUpdates');

var invariant = require('fbjs/lib/invariant');
var warning = require('fbjs/lib/warning');

var didWarnValueLink = false;
var didWarnValDefaultVal = false;

function forceUpdateIfMounted() {
  if (this._rootNodeID) {
    // DOM component is still mounted; update
    ReactDOMTextarea.updateWrapper(this);
  }
}

/**
 * Implements a <textarea> host component that allows setting `value`, and
 * `defaultValue`. This differs from the traditional DOM API because value is
 * usually set as PCDATA children.
 *
 * If `value` is not supplied (or null/undefined), user actions that affect the
 * value will trigger updates to the element.
 *
 * If `value` is supplied (and not null/undefined), the rendered element will
 * not trigger updates to the element. Instead, the `value` prop must change in
 * order for the rendered element to be updated.
 *
 * The rendered element will be initialized with an empty value, the prop
 * `defaultValue` if specified, or the children content (deprecated).
 */
var ReactDOMTextarea = {
  getHostProps: function (inst, props) {
    !(props.dangerouslySetInnerHTML == null) ? "production" !== 'production' ? invariant(false, '`dangerouslySetInnerHTML` does not make sense on <textarea>.') : _prodInvariant('91') : void 0;

    // Always set children to the same thing. In IE9, the selection range will
    // get reset if `textContent` is mutated.  We could add a check in setTextContent
    // to only set the value if/when the value differs from the node value (which would
    // completely solve this IE9 bug), but Sebastian+Ben seemed to like this solution.
    // The value can be a boolean or object so that's why it's forced to be a string.
    var hostProps = _assign({}, props, {
      value: undefined,
      defaultValue: undefined,
      children: '' + inst._wrapperState.initialValue,
      onChange: inst._wrapperState.onChange
    });

    return hostProps;
  },

  mountWrapper: function (inst, props) {
    if ("production" !== 'production') {
      LinkedValueUtils.checkPropTypes('textarea', props, inst._currentElement._owner);
      if (props.valueLink !== undefined && !didWarnValueLink) {
        "production" !== 'production' ? warning(false, '`valueLink` prop on `textarea` is deprecated; set `value` and `onChange` instead.') : void 0;
        didWarnValueLink = true;
      }
      if (props.value !== undefined && props.defaultValue !== undefined && !didWarnValDefaultVal) {
        "production" !== 'production' ? warning(false, 'Textarea elements must be either controlled or uncontrolled ' + '(specify either the value prop, or the defaultValue prop, but not ' + 'both). Decide between using a controlled or uncontrolled textarea ' + 'and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components') : void 0;
        didWarnValDefaultVal = true;
      }
    }

    var value = LinkedValueUtils.getValue(props);
    var initialValue = value;

    // Only bother fetching default value if we're going to use it
    if (value == null) {
      var defaultValue = props.defaultValue;
      // TODO (yungsters): Remove support for children content in <textarea>.
      var children = props.children;
      if (children != null) {
        if ("production" !== 'production') {
          "production" !== 'production' ? warning(false, 'Use the `defaultValue` or `value` props instead of setting ' + 'children on <textarea>.') : void 0;
        }
        !(defaultValue == null) ? "production" !== 'production' ? invariant(false, 'If you supply `defaultValue` on a <textarea>, do not pass children.') : _prodInvariant('92') : void 0;
        if (Array.isArray(children)) {
          !(children.length <= 1) ? "production" !== 'production' ? invariant(false, '<textarea> can only have at most one child.') : _prodInvariant('93') : void 0;
          children = children[0];
        }

        defaultValue = '' + children;
      }
      if (defaultValue == null) {
        defaultValue = '';
      }
      initialValue = defaultValue;
    }

    inst._wrapperState = {
      initialValue: '' + initialValue,
      listeners: null,
      onChange: _handleChange.bind(inst)
    };
  },

  updateWrapper: function (inst) {
    var props = inst._currentElement.props;

    var node = ReactDOMComponentTree.getNodeFromInstance(inst);
    var value = LinkedValueUtils.getValue(props);
    if (value != null) {
      // Cast `value` to a string to ensure the value is set correctly. While
      // browsers typically do this as necessary, jsdom doesn't.
      var newValue = '' + value;

      // To avoid side effects (such as losing text selection), only set value if changed
      if (newValue !== node.value) {
        node.value = newValue;
      }
      if (props.defaultValue == null) {
        node.defaultValue = newValue;
      }
    }
    if (props.defaultValue != null) {
      node.defaultValue = props.defaultValue;
    }
  },

  postMountWrapper: function (inst) {
    // This is in postMount because we need access to the DOM node, which is not
    // available until after the component has mounted.
    var node = ReactDOMComponentTree.getNodeFromInstance(inst);
    var textContent = node.textContent;

    // Only set node.value if textContent is equal to the expected
    // initial value. In IE10/IE11 there is a bug where the placeholder attribute
    // will populate textContent as well.
    // https://developer.microsoft.com/microsoft-edge/platform/issues/101525/
    if (textContent === inst._wrapperState.initialValue) {
      node.value = textContent;
    }
  }
};

function _handleChange(event) {
  var props = this._currentElement.props;
  var returnValue = LinkedValueUtils.executeOnChange(props, event);
  ReactUpdates.asap(forceUpdateIfMounted, this);
  return returnValue;
}

module.exports = ReactDOMTextarea;
},{"./LinkedValueUtils":553,"./ReactDOMComponentTree":563,"./ReactUpdates":607,"./reactProdInvariant":650,"fbjs/lib/invariant":402,"fbjs/lib/warning":409,"object-assign":489}],576:[function(require,module,exports){
/**
 * Copyright (c) 2015-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */

'use strict';

var _prodInvariant = require('./reactProdInvariant');

var invariant = require('fbjs/lib/invariant');

/**
 * Return the lowest common ancestor of A and B, or null if they are in
 * different trees.
 */
function getLowestCommonAncestor(instA, instB) {
  !('_hostNode' in instA) ? "production" !== 'production' ? invariant(false, 'getNodeFromInstance: Invalid argument.') : _prodInvariant('33') : void 0;
  !('_hostNode' in instB) ? "production" !== 'production' ? invariant(false, 'getNodeFromInstance: Invalid argument.') : _prodInvariant('33') : void 0;

  var depthA = 0;
  for (var tempA = instA; tempA; tempA = tempA._hostParent) {
    depthA++;
  }
  var depthB = 0;
  for (var tempB = instB; tempB; tempB = tempB._hostParent) {
    depthB++;
  }

  // If A is deeper, crawl up.
  while (depthA - depthB > 0) {
    instA = instA._hostParent;
    depthA--;
  }

  // If B is deeper, crawl up.
  while (depthB - depthA > 0) {
    instB = instB._hostParent;
    depthB--;
  }

  // Walk in lockstep until we find a match.
  var depth = depthA;
  while (depth--) {
    if (instA === instB) {
      return instA;
    }
    instA = instA._hostParent;
    instB = instB._hostParent;
  }
  return null;
}

/**
 * Return if A is an ancestor of B.
 */
function isAncestor(instA, instB) {
  !('_hostNode' in instA) ? "production" !== 'production' ? invariant(false, 'isAncestor: Invalid argument.') : _prodInvariant('35') : void 0;
  !('_hostNode' in instB) ? "production" !== 'production' ? invariant(false, 'isAncestor: Invalid argument.') : _prodInvariant('35') : void 0;

  while (instB) {
    if (instB === instA) {
      return true;
    }
    instB = instB._hostParent;
  }
  return false;
}

/**
 * Return the parent instance of the passed-in instance.
 */
function getParentInstance(inst) {
  !('_hostNode' in inst) ? "production" !== 'production' ? invariant(false, 'getParentInstance: Invalid argument.') : _prodInvariant('36') : void 0;

  return inst._hostParent;
}

/**
 * Simulates the traversal of a two-phase, capture/bubble event dispatch.
 */
function traverseTwoPhase(inst, fn, arg) {
  var path = [];
  while (inst) {
    path.push(inst);
    inst = inst._hostParent;
  }
  var i;
  for (i = path.length; i-- > 0;) {
    fn(path[i], 'captured', arg);
  }
  for (i = 0; i < path.length; i++) {
    fn(path[i], 'bubbled', arg);
  }
}

/**
 * Traverses the ID hierarchy and invokes the supplied `cb` on any IDs that
 * should would receive a `mouseEnter` or `mouseLeave` event.
 *
 * Does not invoke the callback on the nearest common ancestor because nothing
 * "entered" or "left" that element.
 */
function traverseEnterLeave(from, to, fn, argFrom, argTo) {
  var common = from && to ? getLowestCommonAncestor(from, to) : null;
  var pathFrom = [];
  while (from && from !== common) {
    pathFrom.push(from);
    from = from._hostParent;
  }
  var pathTo = [];
  while (to && to !== common) {
    pathTo.push(to);
    to = to._hostParent;
  }
  var i;
  for (i = 0; i < pathFrom.length; i++) {
    fn(pathFrom[i], 'bubbled', argFrom);
  }
  for (i = pathTo.length; i-- > 0;) {
    fn(pathTo[i], 'captured', argTo);
  }
}

module.exports = {
  isAncestor: isAncestor,
  getLowestCommonAncestor: getLowestCommonAncestor,
  getParentInstance: getParentInstance,
  traverseTwoPhase: traverseTwoPhase,
  traverseEnterLeave: traverseEnterLeave
};
},{"./reactProdInvariant":650,"fbjs/lib/invariant":402}],577:[function(require,module,exports){
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */

'use strict';

var DOMProperty = require('./DOMProperty');
var EventPluginRegistry = require('./EventPluginRegistry');
var ReactComponentTreeHook = require('react/lib/ReactComponentTreeHook');

var warning = require('fbjs/lib/warning');

if ("production" !== 'production') {
  var reactProps = {
    children: true,
    dangerouslySetInnerHTML: true,
    key: true,
    ref: true,

    autoFocus: true,
    defaultValue: true,
    valueLink: true,
    defaultChecked: true,
    checkedLink: true,
    innerHTML: true,
    suppressContentEditableWarning: true,
    onFocusIn: true,
    onFocusOut: true
  };
  var warnedProperties = {};

  var validateProperty = function (tagName, name, debugID) {
    if (DOMProperty.properties.hasOwnProperty(name) || DOMProperty.isCustomAttribute(name)) {
      return true;
    }
    if (reactProps.hasOwnProperty(name) && reactProps[name] || warnedProperties.hasOwnProperty(name) && warnedProperties[name]) {
      return true;
    }
    if (EventPluginRegistry.registrationNameModules.hasOwnProperty(name)) {
      return true;
    }
    warnedProperties[name] = true;
    var lowerCasedName = name.toLowerCase();

    // data-* attributes should be lowercase; suggest the lowercase version
    var standardName = DOMProperty.isCustomAttribute(lowerCasedName) ? lowerCasedName : DOMProperty.getPossibleStandardName.hasOwnProperty(lowerCasedName) ? DOMProperty.getPossibleStandardName[lowerCasedName] : null;

    var registrationName = EventPluginRegistry.possibleRegistrationNames.hasOwnProperty(lowerCasedName) ? EventPluginRegistry.possibleRegistrationNames[lowerCasedName] : null;

    if (standardName != null) {
      "production" !== 'production' ? warning(false, 'Unknown DOM property %s. Did you mean %s?%s', name, standardName, ReactComponentTreeHook.getStackAddendumByID(debugID)) : void 0;
      return true;
    } else if (registrationName != null) {
      "production" !== 'production' ? warning(false, 'Unknown event handler property %s. Did you mean `%s`?%s', name, registrationName, ReactComponentTreeHook.getStackAddendumByID(debugID)) : void 0;
      return true;
    } else {
      // We were unable to guess which prop the user intended.
      // It is likely that the user was just blindly spreading/forwarding props
      // Components should be careful to only render valid props/attributes.
      // Warning will be invoked in warnUnknownProperties to allow grouping.
      return false;
    }
  };
}

var warnUnknownProperties = function (debugID, element) {
  var unknownProps = [];
  for (var key in element.props) {
    var isValid = validateProperty(element.type, key, debugID);
    if (!isValid) {
      unknownProps.push(key);
    }
  }

  var unknownPropString = unknownProps.map(function (prop) {
    return '`' + prop + '`';
  }).join(', ');

  if (unknownProps.length === 1) {
    "production" !== 'production' ? warning(false, 'Unknown prop %s on <%s> tag. Remove this prop from the element. ' + 'For details, see https://fb.me/react-unknown-prop%s', unknownPropString, element.type, ReactComponentTreeHook.getStackAddendumByID(debugID)) : void 0;
  } else if (unknownProps.length > 1) {
    "production" !== 'production' ? warning(false, 'Unknown props %s on <%s> tag. Remove these props from the element. ' + 'For details, see https://fb.me/react-unknown-prop%s', unknownPropString, element.type, ReactComponentTreeHook.getStackAddendumByID(debugID)) : void 0;
  }
};

function handleElement(debugID, element) {
  if (element == null || typeof element.type !== 'string') {
    return;
  }
  if (element.type.indexOf('-') >= 0 || element.props.is) {
    return;
  }
  warnUnknownProperties(debugID, element);
}

var ReactDOMUnknownPropertyHook = {
  onBeforeMountComponent: function (debugID, element) {
    handleElement(debugID, element);
  },
  onBeforeUpdateComponent: function (debugID, element) {
    handleElement(debugID, element);
  }
};

module.exports = ReactDOMUnknownPropertyHook;
},{"./DOMProperty":541,"./EventPluginRegistry":547,"fbjs/lib/warning":409,"react/lib/ReactComponentTreeHook":677}],578:[function(require,module,exports){
/**
 * Copyright (c) 2016-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

'use strict';

var ReactInvalidSetStateWarningHook = require('./ReactInvalidSetStateWarningHook');
var ReactHostOperationHistoryHook = require('./ReactHostOperationHistoryHook');
var ReactComponentTreeHook = require('react/lib/ReactComponentTreeHook');
var ExecutionEnvironment = require('fbjs/lib/ExecutionEnvironment');

var performanceNow = require('fbjs/lib/performanceNow');
var warning = require('fbjs/lib/warning');

var hooks = [];
var didHookThrowForEvent = {};

function callHook(event, fn, context, arg1, arg2, arg3, arg4, arg5) {
  try {
    fn.call(context, arg1, arg2, arg3, arg4, arg5);
  } catch (e) {
    "production" !== 'production' ? warning(didHookThrowForEvent[event], 'Exception thrown by hook while handling %s: %s', event, e + '\n' + e.stack) : void 0;
    didHookThrowForEvent[event] = true;
  }
}

function emitEvent(event, arg1, arg2, arg3, arg4, arg5) {
  for (var i = 0; i < hooks.length; i++) {
    var hook = hooks[i];
    var fn = hook[event];
    if (fn) {
      callHook(event, fn, hook, arg1, arg2, arg3, arg4, arg5);
    }
  }
}

var isProfiling = false;
var flushHistory = [];
var lifeCycleTimerStack = [];
var currentFlushNesting = 0;
var currentFlushMeasurements = [];
var currentFlushStartTime = 0;
var currentTimerDebugID = null;
var currentTimerStartTime = 0;
var currentTimerNestedFlushDuration = 0;
var currentTimerType = null;

var lifeCycleTimerHasWarned = false;

function clearHistory() {
  ReactComponentTreeHook.purgeUnmountedComponents();
  ReactHostOperationHistoryHook.clearHistory();
}

function getTreeSnapshot(registeredIDs) {
  return registeredIDs.reduce(function (tree, id) {
    var ownerID = ReactComponentTreeHook.getOwnerID(id);
    var parentID = ReactComponentTreeHook.getParentID(id);
    tree[id] = {
      displayName: ReactComponentTreeHook.getDisplayName(id),
      text: ReactComponentTreeHook.getText(id),
      updateCount: ReactComponentTreeHook.getUpdateCount(id),
      childIDs: ReactComponentTreeHook.getChildIDs(id),
      // Text nodes don't have owners but this is close enough.
      ownerID: ownerID || parentID && ReactComponentTreeHook.getOwnerID(parentID) || 0,
      parentID: parentID
    };
    return tree;
  }, {});
}

function resetMeasurements() {
  var previousStartTime = currentFlushStartTime;
  var previousMeasurements = currentFlushMeasurements;
  var previousOperations = ReactHostOperationHistoryHook.getHistory();

  if (currentFlushNesting === 0) {
    currentFlushStartTime = 0;
    currentFlushMeasurements = [];
    clearHistory();
    return;
  }

  if (previousMeasurements.length || previousOperations.length) {
    var registeredIDs = ReactComponentTreeHook.getRegisteredIDs();
    flushHistory.push({
      duration: performanceNow() - previousStartTime,
      measurements: previousMeasurements || [],
      operations: previousOperations || [],
      treeSnapshot: getTreeSnapshot(registeredIDs)
    });
  }

  clearHistory();
  currentFlushStartTime = performanceNow();
  currentFlushMeasurements = [];
}

function checkDebugID(debugID) {
  var allowRoot = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

  if (allowRoot && debugID === 0) {
    return;
  }
  if (!debugID) {
    "production" !== 'production' ? warning(false, 'ReactDebugTool: debugID may not be empty.') : void 0;
  }
}

function beginLifeCycleTimer(debugID, timerType) {
  if (currentFlushNesting === 0) {
    return;
  }
  if (currentTimerType && !lifeCycleTimerHasWarned) {
    "production" !== 'production' ? warning(false, 'There is an internal error in the React performance measurement code. ' + 'Did not expect %s timer to start while %s timer is still in ' + 'progress for %s instance.', timerType, currentTimerType || 'no', debugID === currentTimerDebugID ? 'the same' : 'another') : void 0;
    lifeCycleTimerHasWarned = true;
  }
  currentTimerStartTime = performanceNow();
  currentTimerNestedFlushDuration = 0;
  currentTimerDebugID = debugID;
  currentTimerType = timerType;
}

function endLifeCycleTimer(debugID, timerType) {
  if (currentFlushNesting === 0) {
    return;
  }
  if (currentTimerType !== timerType && !lifeCycleTimerHasWarned) {
    "production" !== 'production' ? warning(false, 'There is an internal error in the React performance measurement code. ' + 'We did not expect %s timer to stop while %s timer is still in ' + 'progress for %s instance. Please report this as a bug in React.', timerType, currentTimerType || 'no', debugID === currentTimerDebugID ? 'the same' : 'another') : void 0;
    lifeCycleTimerHasWarned = true;
  }
  if (isProfiling) {
    currentFlushMeasurements.push({
      timerType: timerType,
      instanceID: debugID,
      duration: performanceNow() - currentTimerStartTime - currentTimerNestedFlushDuration
    });
  }
  currentTimerStartTime = 0;
  currentTimerNestedFlushDuration = 0;
  currentTimerDebugID = null;
  currentTimerType = null;
}

function pauseCurrentLifeCycleTimer() {
  var currentTimer = {
    startTime: currentTimerStartTime,
    nestedFlushStartTime: performanceNow(),
    debugID: currentTimerDebugID,
    timerType: currentTimerType
  };
  lifeCycleTimerStack.push(currentTimer);
  currentTimerStartTime = 0;
  currentTimerNestedFlushDuration = 0;
  currentTimerDebugID = null;
  currentTimerType = null;
}

function resumeCurrentLifeCycleTimer() {
  var _lifeCycleTimerStack$ = lifeCycleTimerStack.pop(),
      startTime = _lifeCycleTimerStack$.startTime,
      nestedFlushStartTime = _lifeCycleTimerStack$.nestedFlushStartTime,
      debugID = _lifeCycleTimerStack$.debugID,
      timerType = _lifeCycleTimerStack$.timerType;

  var nestedFlushDuration = performanceNow() - nestedFlushStartTime;
  currentTimerStartTime = startTime;
  currentTimerNestedFlushDuration += nestedFlushDuration;
  currentTimerDebugID = debugID;
  currentTimerType = timerType;
}

var lastMarkTimeStamp = 0;
var canUsePerformanceMeasure = typeof performance !== 'undefined' && typeof performance.mark === 'function' && typeof performance.clearMarks === 'function' && typeof performance.measure === 'function' && typeof performance.clearMeasures === 'function';

function shouldMark(debugID) {
  if (!isProfiling || !canUsePerformanceMeasure) {
    return false;
  }
  var element = ReactComponentTreeHook.getElement(debugID);
  if (element == null || typeof element !== 'object') {
    return false;
  }
  var isHostElement = typeof element.type === 'string';
  if (isHostElement) {
    return false;
  }
  return true;
}

function markBegin(debugID, markType) {
  if (!shouldMark(debugID)) {
    return;
  }

  var markName = debugID + '::' + markType;
  lastMarkTimeStamp = performanceNow();
  performance.mark(markName);
}

function markEnd(debugID, markType) {
  if (!shouldMark(debugID)) {
    return;
  }

  var markName = debugID + '::' + markType;
  var displayName = ReactComponentTreeHook.getDisplayName(debugID) || 'Unknown';

  // Chrome has an issue of dropping markers recorded too fast:
  // https://bugs.chromium.org/p/chromium/issues/detail?id=640652
  // To work around this, we will not report very small measurements.
  // I determined the magic number by tweaking it back and forth.
  // 0.05ms was enough to prevent the issue, but I set it to 0.1ms to be safe.
  // When the bug is fixed, we can `measure()` unconditionally if we want to.
  var timeStamp = performanceNow();
  if (timeStamp - lastMarkTimeStamp > 0.1) {
    var measurementName = displayName + ' [' + markType + ']';
    performance.measure(measurementName, markName);
  }

  performance.clearMarks(markName);
  if (measurementName) {
    performance.clearMeasures(measurementName);
  }
}

var ReactDebugTool = {
  addHook: function (hook) {
    hooks.push(hook);
  },
  removeHook: function (hook) {
    for (var i = 0; i < hooks.length; i++) {
      if (hooks[i] === hook) {
        hooks.splice(i, 1);
        i--;
      }
    }
  },
  isProfiling: function () {
    return isProfiling;
  },
  beginProfiling: function () {
    if (isProfiling) {
      return;
    }

    isProfiling = true;
    flushHistory.length = 0;
    resetMeasurements();
    ReactDebugTool.addHook(ReactHostOperationHistoryHook);
  },
  endProfiling: function () {
    if (!isProfiling) {
      return;
    }

    isProfiling = false;
    resetMeasurements();
    ReactDebugTool.removeHook(ReactHostOperationHistoryHook);
  },
  getFlushHistory: function () {
    return flushHistory;
  },
  onBeginFlush: function () {
    currentFlushNesting++;
    resetMeasurements();
    pauseCurrentLifeCycleTimer();
    emitEvent('onBeginFlush');
  },
  onEndFlush: function () {
    resetMeasurements();
    currentFlushNesting--;
    resumeCurrentLifeCycleTimer();
    emitEvent('onEndFlush');
  },
  onBeginLifeCycleTimer: function (debugID, timerType) {
    checkDebugID(debugID);
    emitEvent('onBeginLifeCycleTimer', debugID, timerType);
    markBegin(debugID, timerType);
    beginLifeCycleTimer(debugID, timerType);
  },
  onEndLifeCycleTimer: function (debugID, timerType) {
    checkDebugID(debugID);
    endLifeCycleTimer(debugID, timerType);
    markEnd(debugID, timerType);
    emitEvent('onEndLifeCycleTimer', debugID, timerType);
  },
  onBeginProcessingChildContext: function () {
    emitEvent('onBeginProcessingChildContext');
  },
  onEndProcessingChildContext: function () {
    emitEvent('onEndProcessingChildContext');
  },
  onHostOperation: function (operation) {
    checkDebugID(operation.instanceID);
    emitEvent('onHostOperation', operation);
  },
  onSetState: function () {
    emitEvent('onSetState');
  },
  onSetChildren: function (debugID, childDebugIDs) {
    checkDebugID(debugID);
    childDebugIDs.forEach(checkDebugID);
    emitEvent('onSetChildren', debugID, childDebugIDs);
  },
  onBeforeMountComponent: function (debugID, element, parentDebugID) {
    checkDebugID(debugID);
    checkDebugID(parentDebugID, true);
    emitEvent('onBeforeMountComponent', debugID, element, parentDebugID);
    markBegin(debugID, 'mount');
  },
  onMountComponent: function (debugID) {
    checkDebugID(debugID);
    markEnd(debugID, 'mount');
    emitEvent('onMountComponent', debugID);
  },
  onBeforeUpdateComponent: function (debugID, element) {
    checkDebugID(debugID);
    emitEvent('onBeforeUpdateComponent', debugID, element);
    markBegin(debugID, 'update');
  },
  onUpdateComponent: function (debugID) {
    checkDebugID(debugID);
    markEnd(debugID, 'update');
    emitEvent('onUpdateComponent', debugID);
  },
  onBeforeUnmountComponent: function (debugID) {
    checkDebugID(debugID);
    emitEvent('onBeforeUnmountComponent', debugID);
    markBegin(debugID, 'unmount');
  },
  onUnmountComponent: function (debugID) {
    checkDebugID(debugID);
    markEnd(debugID, 'unmount');
    emitEvent('onUnmountComponent', debugID);
  },
  onTestEvent: function () {
    emitEvent('onTestEvent');
  }
};

// TODO remove these when RN/www gets updated
ReactDebugTool.addDevtool = ReactDebugTool.addHook;
ReactDebugTool.removeDevtool = ReactDebugTool.removeHook;

ReactDebugTool.addHook(ReactInvalidSetStateWarningHook);
ReactDebugTool.addHook(ReactComponentTreeHook);
var url = ExecutionEnvironment.canUseDOM && window.location.href || '';
if (/[?&]react_perf\b/.test(url)) {
  ReactDebugTool.beginProfiling();
}

module.exports = ReactDebugTool;
},{"./ReactHostOperationHistoryHook":588,"./ReactInvalidSetStateWarningHook":593,"fbjs/lib/ExecutionEnvironment":388,"fbjs/lib/performanceNow":407,"fbjs/lib/warning":409,"react/lib/ReactComponentTreeHook":677}],579:[function(require,module,exports){
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */

'use strict';

var _assign = require('object-assign');

var ReactUpdates = require('./ReactUpdates');
var Transaction = require('./Transaction');

var emptyFunction = require('fbjs/lib/emptyFunction');

var RESET_BATCHED_UPDATES = {
  initialize: emptyFunction,
  close: function () {
    ReactDefaultBatchingStrategy.isBatchingUpdates = false;
  }
};

var FLUSH_BATCHED_UPDATES = {
  initialize: emptyFunction,
  close: ReactUpdates.flushBatchedUpdates.bind(ReactUpdates)
};

var TRANSACTION_WRAPPERS = [FLUSH_BATCHED_UPDATES, RESET_BATCHED_UPDATES];

function ReactDefaultBatchingStrategyTransaction() {
  this.reinitializeTransaction();
}

_assign(ReactDefaultBatchingStrategyTransaction.prototype, Transaction, {
  getTransactionWrappers: function () {
    return TRANSACTION_WRAPPERS;
  }
});

var transaction = new ReactDefaultBatchingStrategyTransaction();

var ReactDefaultBatchingStrategy = {
  isBatchingUpdates: false,

  /**
   * Call the provided function in a context within which calls to `setState`
   * and friends are batched such that components aren't updated unnecessarily.
   */
  batchedUpdates: function (callback, a, b, c, d, e) {
    var alreadyBatchingUpdates = ReactDefaultBatchingStrategy.isBatchingUpdates;

    ReactDefaultBatchingStrategy.isBatchingUpdates = true;

    // The code is written this way to avoid extra allocations
    if (alreadyBatchingUpdates) {
      return callback(a, b, c, d, e);
    } else {
      return transaction.perform(callback, null, a, b, c, d, e);
    }
  }
};

module.exports = ReactDefaultBatchingStrategy;
},{"./ReactUpdates":607,"./Transaction":625,"fbjs/lib/emptyFunction":394,"object-assign":489}],580:[function(require,module,exports){
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */

'use strict';

var ARIADOMPropertyConfig = require('./ARIADOMPropertyConfig');
var BeforeInputEventPlugin = require('./BeforeInputEventPlugin');
var ChangeEventPlugin = require('./ChangeEventPlugin');
var DefaultEventPluginOrder = require('./DefaultEventPluginOrder');
var EnterLeaveEventPlugin = require('./EnterLeaveEventPlugin');
var HTMLDOMPropertyConfig = require('./HTMLDOMPropertyConfig');
var ReactComponentBrowserEnvironment = require('./ReactComponentBrowserEnvironment');
var ReactDOMComponent = require('./ReactDOMComponent');
var ReactDOMComponentTree = require('./ReactDOMComponentTree');
var ReactDOMEmptyComponent = require('./ReactDOMEmptyComponent');
var ReactDOMTreeTraversal = require('./ReactDOMTreeTraversal');
var ReactDOMTextComponent = require('./ReactDOMTextComponent');
var ReactDefaultBatchingStrategy = require('./ReactDefaultBatchingStrategy');
var ReactEventListener = require('./ReactEventListener');
var ReactInjection = require('./ReactInjection');
var ReactReconcileTransaction = require('./ReactReconcileTransaction');
var SVGDOMPropertyConfig = require('./SVGDOMPropertyConfig');
var SelectEventPlugin = require('./SelectEventPlugin');
var SimpleEventPlugin = require('./SimpleEventPlugin');

var alreadyInjected = false;

function inject() {
  if (alreadyInjected) {
    // TODO: This is currently true because these injections are shared between
    // the client and the server package. They should be built independently
    // and not share any injection state. Then this problem will be solved.
    return;
  }
  alreadyInjected = true;

  ReactInjection.EventEmitter.injectReactEventListener(ReactEventListener);

  /**
   * Inject modules for resolving DOM hierarchy and plugin ordering.
   */
  ReactInjection.EventPluginHub.injectEventPluginOrder(DefaultEventPluginOrder);
  ReactInjection.EventPluginUtils.injectComponentTree(ReactDOMComponentTree);
  ReactInjection.EventPluginUtils.injectTreeTraversal(ReactDOMTreeTraversal);

  /**
   * Some important event plugins included by default (without having to require
   * them).
   */
  ReactInjection.EventPluginHub.injectEventPluginsByName({
    SimpleEventPlugin: SimpleEventPlugin,
    EnterLeaveEventPlugin: EnterLeaveEventPlugin,
    ChangeEventPlugin: ChangeEventPlugin,
    SelectEventPlugin: SelectEventPlugin,
    BeforeInputEventPlugin: BeforeInputEventPlugin
  });

  ReactInjection.HostComponent.injectGenericComponentClass(ReactDOMComponent);

  ReactInjection.HostComponent.injectTextComponentClass(ReactDOMTextComponent);

  ReactInjection.DOMProperty.injectDOMPropertyConfig(ARIADOMPropertyConfig);
  ReactInjection.DOMProperty.injectDOMPropertyConfig(HTMLDOMPropertyConfig);
  ReactInjection.DOMProperty.injectDOMPropertyConfig(SVGDOMPropertyConfig);

  ReactInjection.EmptyComponent.injectEmptyComponentFactory(function (instantiate) {
    return new ReactDOMEmptyComponent(instantiate);
  });

  ReactInjection.Updates.injectReconcileTransaction(ReactReconcileTransaction);
  ReactInjection.Updates.injectBatchingStrategy(ReactDefaultBatchingStrategy);

  ReactInjection.Component.injectEnvironment(ReactComponentBrowserEnvironment);
}

module.exports = {
  inject: inject
};
},{"./ARIADOMPropertyConfig":531,"./BeforeInputEventPlugin":533,"./ChangeEventPlugin":537,"./DefaultEventPluginOrder":544,"./EnterLeaveEventPlugin":545,"./HTMLDOMPropertyConfig":551,"./ReactComponentBrowserEnvironment":557,"./ReactDOMComponent":561,"./ReactDOMComponentTree":563,"./ReactDOMEmptyComponent":565,"./ReactDOMTextComponent":574,"./ReactDOMTreeTraversal":576,"./ReactDefaultBatchingStrategy":579,"./ReactEventListener":585,"./ReactInjection":589,"./ReactReconcileTransaction":601,"./SVGDOMPropertyConfig":609,"./SelectEventPlugin":610,"./SimpleEventPlugin":611}],581:[function(require,module,exports){
/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

'use strict';

// The Symbol used to tag the ReactElement type. If there is no native Symbol
// nor polyfill, then a plain number is used for performance.

var REACT_ELEMENT_TYPE = typeof Symbol === 'function' && Symbol['for'] && Symbol['for']('react.element') || 0xeac7;

module.exports = REACT_ELEMENT_TYPE;
},{}],582:[function(require,module,exports){
/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */

'use strict';

var emptyComponentFactory;

var ReactEmptyComponentInjection = {
  injectEmptyComponentFactory: function (factory) {
    emptyComponentFactory = factory;
  }
};

var ReactEmptyComponent = {
  create: function (instantiate) {
    return emptyComponentFactory(instantiate);
  }
};

ReactEmptyComponent.injection = ReactEmptyComponentInjection;

module.exports = ReactEmptyComponent;
},{}],583:[function(require,module,exports){
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

'use strict';

var caughtError = null;

/**
 * Call a function while guarding against errors that happens within it.
 *
 * @param {String} name of the guard to use for logging or debugging
 * @param {Function} func The function to invoke
 * @param {*} a First argument
 * @param {*} b Second argument
 */
function invokeGuardedCallback(name, func, a) {
  try {
    func(a);
  } catch (x) {
    if (caughtError === null) {
      caughtError = x;
    }
  }
}

var ReactErrorUtils = {
  invokeGuardedCallback: invokeGuardedCallback,

  /**
   * Invoked by ReactTestUtils.Simulate so that any errors thrown by the event
   * handler are sure to be rethrown by rethrowCaughtError.
   */
  invokeGuardedCallbackWithCatch: invokeGuardedCallback,

  /**
   * During execution of guarded functions we will capture the first error which
   * we will rethrow to be handled by the top level error handler.
   */
  rethrowCaughtError: function () {
    if (caughtError) {
      var error = caughtError;
      caughtError = null;
      throw error;
    }
  }
};

if ("production" !== 'production') {
  /**
   * To help development we can get better devtools integration by simulating a
   * real browser event.
   */
  if (typeof window !== 'undefined' && typeof window.dispatchEvent === 'function' && typeof document !== 'undefined' && typeof document.createEvent === 'function') {
    var fakeNode = document.createElement('react');
    ReactErrorUtils.invokeGuardedCallback = function (name, func, a) {
      var boundFunc = function () {
        func(a);
      };
      var evtType = 'react-' + name;
      fakeNode.addEventListener(evtType, boundFunc, false);
      var evt = document.createEvent('Event');
      evt.initEvent(evtType, false, false);
      fakeNode.dispatchEvent(evt);
      fakeNode.removeEventListener(evtType, boundFunc, false);
    };
  }
}

module.exports = ReactErrorUtils;
},{}],584:[function(require,module,exports){
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */

'use strict';

var EventPluginHub = require('./EventPluginHub');

function runEventQueueInBatch(events) {
  EventPluginHub.enqueueEvents(events);
  EventPluginHub.processEventQueue(false);
}

var ReactEventEmitterMixin = {
  /**
   * Streams a fired top-level event to `EventPluginHub` where plugins have the
   * opportunity to create `ReactEvent`s to be dispatched.
   */
  handleTopLevel: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
    var events = EventPluginHub.extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget);
    runEventQueueInBatch(events);
  }
};

module.exports = ReactEventEmitterMixin;
},{"./EventPluginHub":546}],585:[function(require,module,exports){
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */

'use strict';

var _assign = require('object-assign');

var EventListener = require('fbjs/lib/EventListener');
var ExecutionEnvironment = require('fbjs/lib/ExecutionEnvironment');
var PooledClass = require('./PooledClass');
var ReactDOMComponentTree = require('./ReactDOMComponentTree');
var ReactUpdates = require('./ReactUpdates');

var getEventTarget = require('./getEventTarget');
var getUnboundedScrollPosition = require('fbjs/lib/getUnboundedScrollPosition');

/**
 * Find the deepest React component completely containing the root of the
 * passed-in instance (for use when entire React trees are nested within each
 * other). If React trees are not nested, returns null.
 */
function findParent(inst) {
  // TODO: It may be a good idea to cache this to prevent unnecessary DOM
  // traversal, but caching is difficult to do correctly without using a
  // mutation observer to listen for all DOM changes.
  while (inst._hostParent) {
    inst = inst._hostParent;
  }
  var rootNode = ReactDOMComponentTree.getNodeFromInstance(inst);
  var container = rootNode.parentNode;
  return ReactDOMComponentTree.getClosestInstanceFromNode(container);
}

// Used to store ancestor hierarchy in top level callback
function TopLevelCallbackBookKeeping(topLevelType, nativeEvent) {
  this.topLevelType = topLevelType;
  this.nativeEvent = nativeEvent;
  this.ancestors = [];
}
_assign(TopLevelCallbackBookKeeping.prototype, {
  destructor: function () {
    this.topLevelType = null;
    this.nativeEvent = null;
    this.ancestors.length = 0;
  }
});
PooledClass.addPoolingTo(TopLevelCallbackBookKeeping, PooledClass.twoArgumentPooler);

function handleTopLevelImpl(bookKeeping) {
  var nativeEventTarget = getEventTarget(bookKeeping.nativeEvent);
  var targetInst = ReactDOMComponentTree.getClosestInstanceFromNode(nativeEventTarget);

  // Loop through the hierarchy, in case there's any nested components.
  // It's important that we build the array of ancestors before calling any
  // event handlers, because event handlers can modify the DOM, leading to
  // inconsistencies with ReactMount's node cache. See #1105.
  var ancestor = targetInst;
  do {
    bookKeeping.ancestors.push(ancestor);
    ancestor = ancestor && findParent(ancestor);
  } while (ancestor);

  for (var i = 0; i < bookKeeping.ancestors.length; i++) {
    targetInst = bookKeeping.ancestors[i];
    ReactEventListener._handleTopLevel(bookKeeping.topLevelType, targetInst, bookKeeping.nativeEvent, getEventTarget(bookKeeping.nativeEvent));
  }
}

function scrollValueMonitor(cb) {
  var scrollPosition = getUnboundedScrollPosition(window);
  cb(scrollPosition);
}

var ReactEventListener = {
  _enabled: true,
  _handleTopLevel: null,

  WINDOW_HANDLE: ExecutionEnvironment.canUseDOM ? window : null,

  setHandleTopLevel: function (handleTopLevel) {
    ReactEventListener._handleTopLevel = handleTopLevel;
  },

  setEnabled: function (enabled) {
    ReactEventListener._enabled = !!enabled;
  },

  isEnabled: function () {
    return ReactEventListener._enabled;
  },

  /**
   * Traps top-level events by using event bubbling.
   *
   * @param {string} topLevelType Record from `EventConstants`.
   * @param {string} handlerBaseName Event name (e.g. "click").
   * @param {object} element Element on which to attach listener.
   * @return {?object} An object with a remove function which will forcefully
   *                  remove the listener.
   * @internal
   */
  trapBubbledEvent: function (topLevelType, handlerBaseName, element) {
    if (!element) {
      return null;
    }
    return EventListener.listen(element, handlerBaseName, ReactEventListener.dispatchEvent.bind(null, topLevelType));
  },

  /**
   * Traps a top-level event by using event capturing.
   *
   * @param {string} topLevelType Record from `EventConstants`.
   * @param {string} handlerBaseName Event name (e.g. "click").
   * @param {object} element Element on which to attach listener.
   * @return {?object} An object with a remove function which will forcefully
   *                  remove the listener.
   * @internal
   */
  trapCapturedEvent: function (topLevelType, handlerBaseName, element) {
    if (!element) {
      return null;
    }
    return EventListener.capture(element, handlerBaseName, ReactEventListener.dispatchEvent.bind(null, topLevelType));
  },

  monitorScrollValue: function (refresh) {
    var callback = scrollValueMonitor.bind(null, refresh);
    EventListener.listen(window, 'scroll', callback);
  },

  dispatchEvent: function (topLevelType, nativeEvent) {
    if (!ReactEventListener._enabled) {
      return;
    }

    var bookKeeping = TopLevelCallbackBookKeeping.getPooled(topLevelType, nativeEvent);
    try {
      // Event queue being processed in the same cycle allows
      // `preventDefault`.
      ReactUpdates.batchedUpdates(handleTopLevelImpl, bookKeeping);
    } finally {
      TopLevelCallbackBookKeeping.release(bookKeeping);
    }
  }
};

module.exports = ReactEventListener;
},{"./PooledClass":554,"./ReactDOMComponentTree":563,"./ReactUpdates":607,"./getEventTarget":639,"fbjs/lib/EventListener":387,"fbjs/lib/ExecutionEnvironment":388,"fbjs/lib/getUnboundedScrollPosition":399,"object-assign":489}],586:[function(require,module,exports){
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

'use strict';

var ReactFeatureFlags = {
  // When true, call console.time() before and .timeEnd() after each top-level
  // render (both initial renders and updates). Useful when looking at prod-mode
  // timeline profiles in Chrome, for example.
  logTopLevelRenders: false
};

module.exports = ReactFeatureFlags;
},{}],587:[function(require,module,exports){
/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */

'use strict';

var _prodInvariant = require('./reactProdInvariant');

var invariant = require('fbjs/lib/invariant');

var genericComponentClass = null;
var textComponentClass = null;

var ReactHostComponentInjection = {
  // This accepts a class that receives the tag string. This is a catch all
  // that can render any kind of tag.
  injectGenericComponentClass: function (componentClass) {
    genericComponentClass = componentClass;
  },
  // This accepts a text component class that takes the text string to be
  // rendered as props.
  injectTextComponentClass: function (componentClass) {
    textComponentClass = componentClass;
  }
};

/**
 * Get a host internal component class for a specific tag.
 *
 * @param {ReactElement} element The element to create.
 * @return {function} The internal class constructor function.
 */
function createInternalComponent(element) {
  !genericComponentClass ? "production" !== 'production' ? invariant(false, 'There is no registered component for the tag %s', element.type) : _prodInvariant('111', element.type) : void 0;
  return new genericComponentClass(element);
}

/**
 * @param {ReactText} text
 * @return {ReactComponent}
 */
function createInstanceForText(text) {
  return new textComponentClass(text);
}

/**
 * @param {ReactComponent} component
 * @return {boolean}
 */
function isTextComponent(component) {
  return component instanceof textComponentClass;
}

var ReactHostComponent = {
  createInternalComponent: createInternalComponent,
  createInstanceForText: createInstanceForText,
  isTextComponent: isTextComponent,
  injection: ReactHostComponentInjection
};

module.exports = ReactHostComponent;
},{"./reactProdInvariant":650,"fbjs/lib/invariant":402}],588:[function(require,module,exports){
/**
 * Copyright (c) 2016-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

'use strict';

var history = [];

var ReactHostOperationHistoryHook = {
  onHostOperation: function (operation) {
    history.push(operation);
  },
  clearHistory: function () {
    if (ReactHostOperationHistoryHook._preventClearing) {
      // Should only be used for tests.
      return;
    }

    history = [];
  },
  getHistory: function () {
    return history;
  }
};

module.exports = ReactHostOperationHistoryHook;
},{}],589:[function(require,module,exports){
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */

'use strict';

var DOMProperty = require('./DOMProperty');
var EventPluginHub = require('./EventPluginHub');
var EventPluginUtils = require('./EventPluginUtils');
var ReactComponentEnvironment = require('./ReactComponentEnvironment');
var ReactEmptyComponent = require('./ReactEmptyComponent');
var ReactBrowserEventEmitter = require('./ReactBrowserEventEmitter');
var ReactHostComponent = require('./ReactHostComponent');
var ReactUpdates = require('./ReactUpdates');

var ReactInjection = {
  Component: ReactComponentEnvironment.injection,
  DOMProperty: DOMProperty.injection,
  EmptyComponent: ReactEmptyComponent.injection,
  EventPluginHub: EventPluginHub.injection,
  EventPluginUtils: EventPluginUtils.injection,
  EventEmitter: ReactBrowserEventEmitter.injection,
  HostComponent: ReactHostComponent.injection,
  Updates: ReactUpdates.injection
};

module.exports = ReactInjection;
},{"./DOMProperty":541,"./EventPluginHub":546,"./EventPluginUtils":548,"./ReactBrowserEventEmitter":555,"./ReactComponentEnvironment":558,"./ReactEmptyComponent":582,"./ReactHostComponent":587,"./ReactUpdates":607}],590:[function(require,module,exports){
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */

'use strict';

var ReactDOMSelection = require('./ReactDOMSelection');

var containsNode = require('fbjs/lib/containsNode');
var focusNode = require('fbjs/lib/focusNode');
var getActiveElement = require('fbjs/lib/getActiveElement');

function isInDocument(node) {
  return containsNode(document.documentElement, node);
}

/**
 * @ReactInputSelection: React input selection module. Based on Selection.js,
 * but modified to be suitable for react and has a couple of bug fixes (doesn't
 * assume buttons have range selections allowed).
 * Input selection module for React.
 */
var ReactInputSelection = {
  hasSelectionCapabilities: function (elem) {
    var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
    return nodeName && (nodeName === 'input' && elem.type === 'text' || nodeName === 'textarea' || elem.contentEditable === 'true');
  },

  getSelectionInformation: function () {
    var focusedElem = getActiveElement();
    return {
      focusedElem: focusedElem,
      selectionRange: ReactInputSelection.hasSelectionCapabilities(focusedElem) ? ReactInputSelection.getSelection(focusedElem) : null
    };
  },

  /**
   * @restoreSelection: If any selection information was potentially lost,
   * restore it. This is useful when performing operations that could remove dom
   * nodes and place them back in, resulting in focus being lost.
   */
  restoreSelection: function (priorSelectionInformation) {
    var curFocusedElem = getActiveElement();
    var priorFocusedElem = priorSelectionInformation.focusedElem;
    var priorSelectionRange = priorSelectionInformation.selectionRange;
    if (curFocusedElem !== priorFocusedElem && isInDocument(priorFocusedElem)) {
      if (ReactInputSelection.hasSelectionCapabilities(priorFocusedElem)) {
        ReactInputSelection.setSelection(priorFocusedElem, priorSelectionRange);
      }
      focusNode(priorFocusedElem);
    }
  },

  /**
   * @getSelection: Gets the selection bounds of a focused textarea, input or
   * contentEditable node.
   * -@input: Look up selection bounds of this input
   * -@return {start: selectionStart, end: selectionEnd}
   */
  getSelection: function (input) {
    var selection;

    if ('selectionStart' in input) {
      // Modern browser with input or textarea.
      selection = {
        start: input.selectionStart,
        end: input.selectionEnd
      };
    } else if (document.selection && input.nodeName && input.nodeName.toLowerCase() === 'input') {
      // IE8 input.
      var range = document.selection.createRange();
      // There can only be one selection per document in IE, so it must
      // be in our element.
      if (range.parentElement() === input) {
        selection = {
          start: -range.moveStart('character', -input.value.length),
          end: -range.moveEnd('character', -input.value.length)
        };
      }
    } else {
      // Content editable or old IE textarea.
      selection = ReactDOMSelection.getOffsets(input);
    }

    return selection || { start: 0, end: 0 };
  },

  /**
   * @setSelection: Sets the selection bounds of a textarea or input and focuses
   * the input.
   * -@input     Set selection bounds of this input or textarea
   * -@offsets   Object of same form that is returned from get*
   */
  setSelection: function (input, offsets) {
    var start = offsets.start;
    var end = offsets.end;
    if (end === undefined) {
      end = start;
    }

    if ('selectionStart' in input) {
      input.selectionStart = start;
      input.selectionEnd = Math.min(end, input.value.length);
    } else if (document.selection && input.nodeName && input.nodeName.toLowerCase() === 'input') {
      var range = input.createTextRange();
      range.collapse(true);
      range.moveStart('character', start);
      range.moveEnd('character', end - start);
      range.select();
    } else {
      ReactDOMSelection.setOffsets(input, offsets);
    }
  }
};

module.exports = ReactInputSelection;
},{"./ReactDOMSelection":573,"fbjs/lib/containsNode":391,"fbjs/lib/focusNode":396,"fbjs/lib/getActiveElement":397}],591:[function(require,module,exports){
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */

'use strict';

/**
 * `ReactInstanceMap` maintains a mapping from a public facing stateful
 * instance (key) and the internal representation (value). This allows public
 * methods to accept the user facing instance as an argument and map them back
 * to internal methods.
 */

// TODO: Replace this with ES6: var ReactInstanceMap = new Map();

var ReactInstanceMap = {
  /**
   * This API should be called `delete` but we'd have to make sure to always
   * transform these to strings for IE support. When this transform is fully
   * supported we can rename it.
   */
  remove: function (key) {
    key._reactInternalInstance = undefined;
  },

  get: function (key) {
    return key._reactInternalInstance;
  },

  has: function (key) {
    return key._reactInternalInstance !== undefined;
  },

  set: function (key, value) {
    key._reactInternalInstance = value;
  }
};

module.exports = ReactInstanceMap;
},{}],592:[function(require,module,exports){
/**
 * Copyright (c) 2016-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

'use strict';

// Trust the developer to only use ReactInstrumentation with a __DEV__ check

var debugTool = null;

if ("production" !== 'production') {
  var ReactDebugTool = require('./ReactDebugTool');
  debugTool = ReactDebugTool;
}

module.exports = { debugTool: debugTool };
},{"./ReactDebugTool":578}],593:[function(require,module,exports){
/**
 * Copyright (c) 2016-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

'use strict';

var warning = require('fbjs/lib/warning');

if ("production" !== 'production') {
  var processingChildContext = false;

  var warnInvalidSetState = function () {
    "production" !== 'production' ? warning(!processingChildContext, 'setState(...): Cannot call setState() inside getChildContext()') : void 0;
  };
}

var ReactInvalidSetStateWarningHook = {
  onBeginProcessingChildContext: function () {
    processingChildContext = true;
  },
  onEndProcessingChildContext: function () {
    processingChildContext = false;
  },
  onSetState: function () {
    warnInvalidSetState();
  }
};

module.exports = ReactInvalidSetStateWarningHook;
},{"fbjs/lib/warning":409}],594:[function(require,module,exports){
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */

'use strict';

var adler32 = require('./adler32');

var TAG_END = /\/?>/;
var COMMENT_START = /^<\!\-\-/;

var ReactMarkupChecksum = {
  CHECKSUM_ATTR_NAME: 'data-react-checksum',

  /**
   * @param {string} markup Markup string
   * @return {string} Markup string with checksum attribute attached
   */
  addChecksumToMarkup: function (markup) {
    var checksum = adler32(markup);

    // Add checksum (handle both parent tags, comments and self-closing tags)
    if (COMMENT_START.test(markup)) {
      return markup;
    } else {
      return markup.replace(TAG_END, ' ' + ReactMarkupChecksum.CHECKSUM_ATTR_NAME + '="' + checksum + '"$&');
    }
  },

  /**
   * @param {string} markup to use
   * @param {DOMElement} element root React element
   * @returns {boolean} whether or not the markup is the same
   */
  canReuseMarkup: function (markup, element) {
    var existingChecksum = element.getAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME);
    existingChecksum = existingChecksum && parseInt(existingChecksum, 10);
    var markupChecksum = adler32(markup);
    return markupChecksum === existingChecksum;
  }
};

module.exports = ReactMarkupChecksum;
},{"./adler32":628}],595:[function(require,module,exports){
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */

'use strict';

var _prodInvariant = require('./reactProdInvariant');

var DOMLazyTree = require('./DOMLazyTree');
var DOMProperty = require('./DOMProperty');
var React = require('react/lib/React');
var ReactBrowserEventEmitter = require('./ReactBrowserEventEmitter');
var ReactCurrentOwner = require('react/lib/ReactCurrentOwner');
var ReactDOMComponentTree = require('./ReactDOMComponentTree');
var ReactDOMContainerInfo = require('./ReactDOMContainerInfo');
var ReactDOMFeatureFlags = require('./ReactDOMFeatureFlags');
var ReactFeatureFlags = require('./ReactFeatureFlags');
var ReactInstanceMap = require('./ReactInstanceMap');
var ReactInstrumentation = require('./ReactInstrumentation');
var ReactMarkupChecksum = require('./ReactMarkupChecksum');
var ReactReconciler = require('./ReactReconciler');
var ReactUpdateQueue = require('./ReactUpdateQueue');
var ReactUpdates = require('./ReactUpdates');

var emptyObject = require('fbjs/lib/emptyObject');
var instantiateReactComponent = require('./instantiateReactComponent');
var invariant = require('fbjs/lib/invariant');
var setInnerHTML = require('./setInnerHTML');
var shouldUpdateReactComponent = require('./shouldUpdateReactComponent');
var warning = require('fbjs/lib/warning');

var ATTR_NAME = DOMProperty.ID_ATTRIBUTE_NAME;
var ROOT_ATTR_NAME = DOMProperty.ROOT_ATTRIBUTE_NAME;

var ELEMENT_NODE_TYPE = 1;
var DOC_NODE_TYPE = 9;
var DOCUMENT_FRAGMENT_NODE_TYPE = 11;

var instancesByReactRootID = {};

/**
 * Finds the index of the first character
 * that's not common between the two given strings.
 *
 * @return {number} the index of the character where the strings diverge
 */
function firstDifferenceIndex(string1, string2) {
  var minLen = Math.min(string1.length, string2.length);
  for (var i = 0; i < minLen; i++) {
    if (string1.charAt(i) !== string2.charAt(i)) {
      return i;
    }
  }
  return string1.length === string2.length ? -1 : minLen;
}

/**
 * @param {DOMElement|DOMDocument} container DOM element that may contain
 * a React component
 * @return {?*} DOM element that may have the reactRoot ID, or null.
 */
function getReactRootElementInContainer(container) {
  if (!container) {
    return null;
  }

  if (container.nodeType === DOC_NODE_TYPE) {
    return container.documentElement;
  } else {
    return container.firstChild;
  }
}

function internalGetID(node) {
  // If node is something like a window, document, or text node, none of
  // which support attributes or a .getAttribute method, gracefully return
  // the empty string, as if the attribute were missing.
  return node.getAttribute && node.getAttribute(ATTR_NAME) || '';
}

/**
 * Mounts this component and inserts it into the DOM.
 *
 * @param {ReactComponent} componentInstance The instance to mount.
 * @param {DOMElement} container DOM element to mount into.
 * @param {ReactReconcileTransaction} transaction
 * @param {boolean} shouldReuseMarkup If true, do not insert markup
 */
function mountComponentIntoNode(wrapperInstance, container, transaction, shouldReuseMarkup, context) {
  var markerName;
  if (ReactFeatureFlags.logTopLevelRenders) {
    var wrappedElement = wrapperInstance._currentElement.props.child;
    var type = wrappedElement.type;
    markerName = 'React mount: ' + (typeof type === 'string' ? type : type.displayName || type.name);
    console.time(markerName);
  }

  var markup = ReactReconciler.mountComponent(wrapperInstance, transaction, null, ReactDOMContainerInfo(wrapperInstance, container), context, 0 /* parentDebugID */
  );

  if (markerName) {
    console.timeEnd(markerName);
  }

  wrapperInstance._renderedComponent._topLevelWrapper = wrapperInstance;
  ReactMount._mountImageIntoNode(markup, container, wrapperInstance, shouldReuseMarkup, transaction);
}

/**
 * Batched mount.
 *
 * @param {ReactComponent} componentInstance The instance to mount.
 * @param {DOMElement} container DOM element to mount into.
 * @param {boolean} shouldReuseMarkup If true, do not insert markup
 */
function batchedMountComponentIntoNode(componentInstance, container, shouldReuseMarkup, context) {
  var transaction = ReactUpdates.ReactReconcileTransaction.getPooled(
  /* useCreateElement */
  !shouldReuseMarkup && ReactDOMFeatureFlags.useCreateElement);
  transaction.perform(mountComponentIntoNode, null, componentInstance, container, transaction, shouldReuseMarkup, context);
  ReactUpdates.ReactReconcileTransaction.release(transaction);
}

/**
 * Unmounts a component and removes it from the DOM.
 *
 * @param {ReactComponent} instance React component instance.
 * @param {DOMElement} container DOM element to unmount from.
 * @final
 * @internal
 * @see {ReactMount.unmountComponentAtNode}
 */
function unmountComponentFromNode(instance, container, safely) {
  if ("production" !== 'production') {
    ReactInstrumentation.debugTool.onBeginFlush();
  }
  ReactReconciler.unmountComponent(instance, safely);
  if ("production" !== 'production') {
    ReactInstrumentation.debugTool.onEndFlush();
  }

  if (container.nodeType === DOC_NODE_TYPE) {
    container = container.documentElement;
  }

  // http://jsperf.com/emptying-a-node
  while (container.lastChild) {
    container.removeChild(container.lastChild);
  }
}

/**
 * True if the supplied DOM node has a direct React-rendered child that is
 * not a React root element. Useful for warning in `render`,
 * `unmountComponentAtNode`, etc.
 *
 * @param {?DOMElement} node The candidate DOM node.
 * @return {boolean} True if the DOM element contains a direct child that was
 * rendered by React but is not a root element.
 * @internal
 */
function hasNonRootReactChild(container) {
  var rootEl = getReactRootElementInContainer(container);
  if (rootEl) {
    var inst = ReactDOMComponentTree.getInstanceFromNode(rootEl);
    return !!(inst && inst._hostParent);
  }
}

/**
 * True if the supplied DOM node is a React DOM element and
 * it has been rendered by another copy of React.
 *
 * @param {?DOMElement} node The candidate DOM node.
 * @return {boolean} True if the DOM has been rendered by another copy of React
 * @internal
 */
function nodeIsRenderedByOtherInstance(container) {
  var rootEl = getReactRootElementInContainer(container);
  return !!(rootEl && isReactNode(rootEl) && !ReactDOMComponentTree.getInstanceFromNode(rootEl));
}

/**
 * True if the supplied DOM node is a valid node element.
 *
 * @param {?DOMElement} node The candidate DOM node.
 * @return {boolean} True if the DOM is a valid DOM node.
 * @internal
 */
function isValidContainer(node) {
  return !!(node && (node.nodeType === ELEMENT_NODE_TYPE || node.nodeType === DOC_NODE_TYPE || node.nodeType === DOCUMENT_FRAGMENT_NODE_TYPE));
}

/**
 * True if the supplied DOM node is a valid React node element.
 *
 * @param {?DOMElement} node The candidate DOM node.
 * @return {boolean} True if the DOM is a valid React DOM node.
 * @internal
 */
function isReactNode(node) {
  return isValidContainer(node) && (node.hasAttribute(ROOT_ATTR_NAME) || node.hasAttribute(ATTR_NAME));
}

function getHostRootInstanceInContainer(container) {
  var rootEl = getReactRootElementInContainer(container);
  var prevHostInstance = rootEl && ReactDOMComponentTree.getInstanceFromNode(rootEl);
  return prevHostInstance && !prevHostInstance._hostParent ? prevHostInstance : null;
}

function getTopLevelWrapperInContainer(container) {
  var root = getHostRootInstanceInContainer(container);
  return root ? root._hostContainerInfo._topLevelWrapper : null;
}

/**
 * Temporary (?) hack so that we can store all top-level pending updates on
 * composites instead of having to worry about different types of components
 * here.
 */
var topLevelRootCounter = 1;
var TopLevelWrapper = function () {
  this.rootID = topLevelRootCounter++;
};
TopLevelWrapper.prototype.isReactComponent = {};
if ("production" !== 'production') {
  TopLevelWrapper.displayName = 'TopLevelWrapper';
}
TopLevelWrapper.prototype.render = function () {
  return this.props.child;
};
TopLevelWrapper.isReactTopLevelWrapper = true;

/**
 * Mounting is the process of initializing a React component by creating its
 * representative DOM elements and inserting them into a supplied `container`.
 * Any prior content inside `container` is destroyed in the process.
 *
 *   ReactMount.render(
 *     component,
 *     document.getElementById('container')
 *   );
 *
 *   <div id="container">                   <-- Supplied `container`.
 *     <div data-reactid=".3">              <-- Rendered reactRoot of React
 *       // ...                                 component.
 *     </div>
 *   </div>
 *
 * Inside of `container`, the first element rendered is the "reactRoot".
 */
var ReactMount = {
  TopLevelWrapper: TopLevelWrapper,

  /**
   * Used by devtools. The keys are not important.
   */
  _instancesByReactRootID: instancesByReactRootID,

  /**
   * This is a hook provided to support rendering React components while
   * ensuring that the apparent scroll position of its `container` does not
   * change.
   *
   * @param {DOMElement} container The `container` being rendered into.
   * @param {function} renderCallback This must be called once to do the render.
   */
  scrollMonitor: function (container, renderCallback) {
    renderCallback();
  },

  /**
   * Take a component that's already mounted into the DOM and replace its props
   * @param {ReactComponent} prevComponent component instance already in the DOM
   * @param {ReactElement} nextElement component instance to render
   * @param {DOMElement} container container to render into
   * @param {?function} callback function triggered on completion
   */
  _updateRootComponent: function (prevComponent, nextElement, nextContext, container, callback) {
    ReactMount.scrollMonitor(container, function () {
      ReactUpdateQueue.enqueueElementInternal(prevComponent, nextElement, nextContext);
      if (callback) {
        ReactUpdateQueue.enqueueCallbackInternal(prevComponent, callback);
      }
    });

    return prevComponent;
  },

  /**
   * Render a new component into the DOM. Hooked by hooks!
   *
   * @param {ReactElement} nextElement element to render
   * @param {DOMElement} container container to render into
   * @param {boolean} shouldReuseMarkup if we should skip the markup insertion
   * @return {ReactComponent} nextComponent
   */
  _renderNewRootComponent: function (nextElement, container, shouldReuseMarkup, context) {
    // Various parts of our code (such as ReactCompositeComponent's
    // _renderValidatedComponent) assume that calls to render aren't nested;
    // verify that that's the case.
    "production" !== 'production' ? warning(ReactCurrentOwner.current == null, '_renderNewRootComponent(): Render methods should be a pure function ' + 'of props and state; triggering nested component updates from ' + 'render is not allowed. If necessary, trigger nested updates in ' + 'componentDidUpdate. Check the render method of %s.', ReactCurrentOwner.current && ReactCurrentOwner.current.getName() || 'ReactCompositeComponent') : void 0;

    !isValidContainer(container) ? "production" !== 'production' ? invariant(false, '_registerComponent(...): Target container is not a DOM element.') : _prodInvariant('37') : void 0;

    ReactBrowserEventEmitter.ensureScrollValueMonitoring();
    var componentInstance = instantiateReactComponent(nextElement, false);

    // The initial render is synchronous but any updates that happen during
    // rendering, in componentWillMount or componentDidMount, will be batched
    // according to the current batching strategy.

    ReactUpdates.batchedUpdates(batchedMountComponentIntoNode, componentInstance, container, shouldReuseMarkup, context);

    var wrapperID = componentInstance._instance.rootID;
    instancesByReactRootID[wrapperID] = componentInstance;

    return componentInstance;
  },

  /**
   * Renders a React component into the DOM in the supplied `container`.
   *
   * If the React component was previously rendered into `container`, this will
   * perform an update on it and only mutate the DOM as necessary to reflect the
   * latest React component.
   *
   * @param {ReactComponent} parentComponent The conceptual parent of this render tree.
   * @param {ReactElement} nextElement Component element to render.
   * @param {DOMElement} container DOM element to render into.
   * @param {?function} callback function triggered on completion
   * @return {ReactComponent} Component instance rendered in `container`.
   */
  renderSubtreeIntoContainer: function (parentComponent, nextElement, container, callback) {
    !(parentComponent != null && ReactInstanceMap.has(parentComponent)) ? "production" !== 'production' ? invariant(false, 'parentComponent must be a valid React Component') : _prodInvariant('38') : void 0;
    return ReactMount._renderSubtreeIntoContainer(parentComponent, nextElement, container, callback);
  },

  _renderSubtreeIntoContainer: function (parentComponent, nextElement, container, callback) {
    ReactUpdateQueue.validateCallback(callback, 'ReactDOM.render');
    !React.isValidElement(nextElement) ? "production" !== 'production' ? invariant(false, 'ReactDOM.render(): Invalid component element.%s', typeof nextElement === 'string' ? " Instead of passing a string like 'div', pass " + "React.createElement('div') or <div />." : typeof nextElement === 'function' ? ' Instead of passing a class like Foo, pass ' + 'React.createElement(Foo) or <Foo />.' : // Check if it quacks like an element
    nextElement != null && nextElement.props !== undefined ? ' This may be caused by unintentionally loading two independent ' + 'copies of React.' : '') : _prodInvariant('39', typeof nextElement === 'string' ? " Instead of passing a string like 'div', pass " + "React.createElement('div') or <div />." : typeof nextElement === 'function' ? ' Instead of passing a class like Foo, pass ' + 'React.createElement(Foo) or <Foo />.' : nextElement != null && nextElement.props !== undefined ? ' This may be caused by unintentionally loading two independent ' + 'copies of React.' : '') : void 0;

    "production" !== 'production' ? warning(!container || !container.tagName || container.tagName.toUpperCase() !== 'BODY', 'render(): Rendering components directly into document.body is ' + 'discouraged, since its children are often manipulated by third-party ' + 'scripts and browser extensions. This may lead to subtle ' + 'reconciliation issues. Try rendering into a container element created ' + 'for your app.') : void 0;

    var nextWrappedElement = React.createElement(TopLevelWrapper, {
      child: nextElement
    });

    var nextContext;
    if (parentComponent) {
      var parentInst = ReactInstanceMap.get(parentComponent);
      nextContext = parentInst._processChildContext(parentInst._context);
    } else {
      nextContext = emptyObject;
    }

    var prevComponent = getTopLevelWrapperInContainer(container);

    if (prevComponent) {
      var prevWrappedElement = prevComponent._currentElement;
      var prevElement = prevWrappedElement.props.child;
      if (shouldUpdateReactComponent(prevElement, nextElement)) {
        var publicInst = prevComponent._renderedComponent.getPublicInstance();
        var updatedCallback = callback && function () {
          callback.call(publicInst);
        };
        ReactMount._updateRootComponent(prevComponent, nextWrappedElement, nextContext, container, updatedCallback);
        return publicInst;
      } else {
        ReactMount.unmountComponentAtNode(container);
      }
    }

    var reactRootElement = getReactRootElementInContainer(container);
    var containerHasReactMarkup = reactRootElement && !!internalGetID(reactRootElement);
    var containerHasNonRootReactChild = hasNonRootReactChild(container);

    if ("production" !== 'production') {
      "production" !== 'production' ? warning(!containerHasNonRootReactChild, 'render(...): Replacing React-rendered children with a new root ' + 'component. If you intended to update the children of this node, ' + 'you should instead have the existing children update their state ' + 'and render the new components instead of calling ReactDOM.render.') : void 0;

      if (!containerHasReactMarkup || reactRootElement.nextSibling) {
        var rootElementSibling = reactRootElement;
        while (rootElementSibling) {
          if (internalGetID(rootElementSibling)) {
            "production" !== 'production' ? warning(false, 'render(): Target node has markup rendered by React, but there ' + 'are unrelated nodes as well. This is most commonly caused by ' + 'white-space inserted around server-rendered markup.') : void 0;
            break;
          }
          rootElementSibling = rootElementSibling.nextSibling;
        }
      }
    }

    var shouldReuseMarkup = containerHasReactMarkup && !prevComponent && !containerHasNonRootReactChild;
    var component = ReactMount._renderNewRootComponent(nextWrappedElement, container, shouldReuseMarkup, nextContext)._renderedComponent.getPublicInstance();
    if (callback) {
      callback.call(component);
    }
    return component;
  },

  /**
   * Renders a React component into the DOM in the supplied `container`.
   * See https://facebook.github.io/react/docs/top-level-api.html#reactdom.render
   *
   * If the React component was previously rendered into `container`, this will
   * perform an update on it and only mutate the DOM as necessary to reflect the
   * latest React component.
   *
   * @param {ReactElement} nextElement Component element to render.
   * @param {DOMElement} container DOM element to render into.
   * @param {?function} callback function triggered on completion
   * @return {ReactComponent} Component instance rendered in `container`.
   */
  render: function (nextElement, container, callback) {
    return ReactMount._renderSubtreeIntoContainer(null, nextElement, container, callback);
  },

  /**
   * Unmounts and destroys the React component rendered in the `container`.
   * See https://facebook.github.io/react/docs/top-level-api.html#reactdom.unmountcomponentatnode
   *
   * @param {DOMElement} container DOM element containing a React component.
   * @return {boolean} True if a component was found in and unmounted from
   *                   `container`
   */
  unmountComponentAtNode: function (container) {
    // Various parts of our code (such as ReactCompositeComponent's
    // _renderValidatedComponent) assume that calls to render aren't nested;
    // verify that that's the case. (Strictly speaking, unmounting won't cause a
    // render but we still don't expect to be in a render call here.)
    "production" !== 'production' ? warning(ReactCurrentOwner.current == null, 'unmountComponentAtNode(): Render methods should be a pure function ' + 'of props and state; triggering nested component updates from render ' + 'is not allowed. If necessary, trigger nested updates in ' + 'componentDidUpdate. Check the render method of %s.', ReactCurrentOwner.current && ReactCurrentOwner.current.getName() || 'ReactCompositeComponent') : void 0;

    !isValidContainer(container) ? "production" !== 'production' ? invariant(false, 'unmountComponentAtNode(...): Target container is not a DOM element.') : _prodInvariant('40') : void 0;

    if ("production" !== 'production') {
      "production" !== 'production' ? warning(!nodeIsRenderedByOtherInstance(container), "unmountComponentAtNode(): The node you're attempting to unmount " + 'was rendered by another copy of React.') : void 0;
    }

    var prevComponent = getTopLevelWrapperInContainer(container);
    if (!prevComponent) {
      // Check if the node being unmounted was rendered by React, but isn't a
      // root node.
      var containerHasNonRootReactChild = hasNonRootReactChild(container);

      // Check if the container itself is a React root node.
      var isContainerReactRoot = container.nodeType === 1 && container.hasAttribute(ROOT_ATTR_NAME);

      if ("production" !== 'production') {
        "production" !== 'production' ? warning(!containerHasNonRootReactChild, "unmountComponentAtNode(): The node you're attempting to unmount " + 'was rendered by React and is not a top-level container. %s', isContainerReactRoot ? 'You may have accidentally passed in a React root node instead ' + 'of its container.' : 'Instead, have the parent component update its state and ' + 'rerender in order to remove this component.') : void 0;
      }

      return false;
    }
    delete instancesByReactRootID[prevComponent._instance.rootID];
    ReactUpdates.batchedUpdates(unmountComponentFromNode, prevComponent, container, false);
    return true;
  },

  _mountImageIntoNode: function (markup, container, instance, shouldReuseMarkup, transaction) {
    !isValidContainer(container) ? "production" !== 'production' ? invariant(false, 'mountComponentIntoNode(...): Target container is not valid.') : _prodInvariant('41') : void 0;

    if (shouldReuseMarkup) {
      var rootElement = getReactRootElementInContainer(container);
      if (ReactMarkupChecksum.canReuseMarkup(markup, rootElement)) {
        ReactDOMComponentTree.precacheNode(instance, rootElement);
        return;
      } else {
        var checksum = rootElement.getAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME);
        rootElement.removeAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME);

        var rootMarkup = rootElement.outerHTML;
        rootElement.setAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME, checksum);

        var normalizedMarkup = markup;
        if ("production" !== 'production') {
          // because rootMarkup is retrieved from the DOM, various normalizations
          // will have occurred which will not be present in `markup`. Here,
          // insert markup into a <div> or <iframe> depending on the container
          // type to perform the same normalizations before comparing.
          var normalizer;
          if (container.nodeType === ELEMENT_NODE_TYPE) {
            normalizer = document.createElement('div');
            normalizer.innerHTML = markup;
            normalizedMarkup = normalizer.innerHTML;
          } else {
            normalizer = document.createElement('iframe');
            document.body.appendChild(normalizer);
            normalizer.contentDocument.write(markup);
            normalizedMarkup = normalizer.contentDocument.documentElement.outerHTML;
            document.body.removeChild(normalizer);
          }
        }

        var diffIndex = firstDifferenceIndex(normalizedMarkup, rootMarkup);
        var difference = ' (client) ' + normalizedMarkup.substring(diffIndex - 20, diffIndex + 20) + '\n (server) ' + rootMarkup.substring(diffIndex - 20, diffIndex + 20);

        !(container.nodeType !== DOC_NODE_TYPE) ? "production" !== 'production' ? invariant(false, 'You\'re trying to render a component to the document using server rendering but the checksum was invalid. This usually means you rendered a different component type or props on the client from the one on the server, or your render() methods are impure. React cannot handle this case due to cross-browser quirks by rendering at the document root. You should look for environment dependent code in your components and ensure the props are the same client and server side:\n%s', difference) : _prodInvariant('42', difference) : void 0;

        if ("production" !== 'production') {
          "production" !== 'production' ? warning(false, 'React attempted to reuse markup in a container but the ' + 'checksum was invalid. This generally means that you are ' + 'using server rendering and the markup generated on the ' + 'server was not what the client was expecting. React injected ' + 'new markup to compensate which works but you have lost many ' + 'of the benefits of server rendering. Instead, figure out ' + 'why the markup being generated is different on the client ' + 'or server:\n%s', difference) : void 0;
        }
      }
    }

    !(container.nodeType !== DOC_NODE_TYPE) ? "production" !== 'production' ? invariant(false, 'You\'re trying to render a component to the document but you didn\'t use server rendering. We can\'t do this without using server rendering due to cross-browser quirks. See ReactDOMServer.renderToString() for server rendering.') : _prodInvariant('43') : void 0;

    if (transaction.useCreateElement) {
      while (container.lastChild) {
        container.removeChild(container.lastChild);
      }
      DOMLazyTree.insertTreeBefore(container, markup, null);
    } else {
      setInnerHTML(container, markup);
      ReactDOMComponentTree.precacheNode(instance, container.firstChild);
    }

    if ("production" !== 'production') {
      var hostNode = ReactDOMComponentTree.getInstanceFromNode(container.firstChild);
      if (hostNode._debugID !== 0) {
        ReactInstrumentation.debugTool.onHostOperation({
          instanceID: hostNode._debugID,
          type: 'mount',
          payload: markup.toString()
        });
      }
    }
  }
};

module.exports = ReactMount;
},{"./DOMLazyTree":539,"./DOMProperty":541,"./ReactBrowserEventEmitter":555,"./ReactDOMComponentTree":563,"./ReactDOMContainerInfo":564,"./ReactDOMFeatureFlags":566,"./ReactFeatureFlags":586,"./ReactInstanceMap":591,"./ReactInstrumentation":592,"./ReactMarkupChecksum":594,"./ReactReconciler":602,"./ReactUpdateQueue":606,"./ReactUpdates":607,"./instantiateReactComponent":646,"./reactProdInvariant":650,"./setInnerHTML":652,"./shouldUpdateReactComponent":654,"fbjs/lib/emptyObject":395,"fbjs/lib/invariant":402,"fbjs/lib/warning":409,"react/lib/React":674,"react/lib/ReactCurrentOwner":678}],596:[function(require,module,exports){
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */

'use strict';

var _prodInvariant = require('./reactProdInvariant');

var ReactComponentEnvironment = require('./ReactComponentEnvironment');
var ReactInstanceMap = require('./ReactInstanceMap');
var ReactInstrumentation = require('./ReactInstrumentation');

var ReactCurrentOwner = require('react/lib/ReactCurrentOwner');
var ReactReconciler = require('./ReactReconciler');
var ReactChildReconciler = require('./ReactChildReconciler');

var emptyFunction = require('fbjs/lib/emptyFunction');
var flattenChildren = require('./flattenChildren');
var invariant = require('fbjs/lib/invariant');

/**
 * Make an update for markup to be rendered and inserted at a supplied index.
 *
 * @param {string} markup Markup that renders into an element.
 * @param {number} toIndex Destination index.
 * @private
 */
function makeInsertMarkup(markup, afterNode, toIndex) {
  // NOTE: Null values reduce hidden classes.
  return {
    type: 'INSERT_MARKUP',
    content: markup,
    fromIndex: null,
    fromNode: null,
    toIndex: toIndex,
    afterNode: afterNode
  };
}

/**
 * Make an update for moving an existing element to another index.
 *
 * @param {number} fromIndex Source index of the existing element.
 * @param {number} toIndex Destination index of the element.
 * @private
 */
function makeMove(child, afterNode, toIndex) {
  // NOTE: Null values reduce hidden classes.
  return {
    type: 'MOVE_EXISTING',
    content: null,
    fromIndex: child._mountIndex,
    fromNode: ReactReconciler.getHostNode(child),
    toIndex: toIndex,
    afterNode: afterNode
  };
}

/**
 * Make an update for removing an element at an index.
 *
 * @param {number} fromIndex Index of the element to remove.
 * @private
 */
function makeRemove(child, node) {
  // NOTE: Null values reduce hidden classes.
  return {
    type: 'REMOVE_NODE',
    content: null,
    fromIndex: child._mountIndex,
    fromNode: node,
    toIndex: null,
    afterNode: null
  };
}

/**
 * Make an update for setting the markup of a node.
 *
 * @param {string} markup Markup that renders into an element.
 * @private
 */
function makeSetMarkup(markup) {
  // NOTE: Null values reduce hidden classes.
  return {
    type: 'SET_MARKUP',
    content: markup,
    fromIndex: null,
    fromNode: null,
    toIndex: null,
    afterNode: null
  };
}

/**
 * Make an update for setting the text content.
 *
 * @param {string} textContent Text content to set.
 * @private
 */
function makeTextContent(textContent) {
  // NOTE: Null values reduce hidden classes.
  return {
    type: 'TEXT_CONTENT',
    content: textContent,
    fromIndex: null,
    fromNode: null,
    toIndex: null,
    afterNode: null
  };
}

/**
 * Push an update, if any, onto the queue. Creates a new queue if none is
 * passed and always returns the queue. Mutative.
 */
function enqueue(queue, update) {
  if (update) {
    queue = queue || [];
    queue.push(update);
  }
  return queue;
}

/**
 * Processes any enqueued updates.
 *
 * @private
 */
function processQueue(inst, updateQueue) {
  ReactComponentEnvironment.processChildrenUpdates(inst, updateQueue);
}

var setChildrenForInstrumentation = emptyFunction;
if ("production" !== 'production') {
  var getDebugID = function (inst) {
    if (!inst._debugID) {
      // Check for ART-like instances. TODO: This is silly/gross.
      var internal;
      if (internal = ReactInstanceMap.get(inst)) {
        inst = internal;
      }
    }
    return inst._debugID;
  };
  setChildrenForInstrumentation = function (children) {
    var debugID = getDebugID(this);
    // TODO: React Native empty components are also multichild.
    // This means they still get into this method but don't have _debugID.
    if (debugID !== 0) {
      ReactInstrumentation.debugTool.onSetChildren(debugID, children ? Object.keys(children).map(function (key) {
        return children[key]._debugID;
      }) : []);
    }
  };
}

/**
 * ReactMultiChild are capable of reconciling multiple children.
 *
 * @class ReactMultiChild
 * @internal
 */
var ReactMultiChild = {
  /**
   * Provides common functionality for components that must reconcile multiple
   * children. This is used by `ReactDOMComponent` to mount, update, and
   * unmount child components.
   *
   * @lends {ReactMultiChild.prototype}
   */
  Mixin: {
    _reconcilerInstantiateChildren: function (nestedChildren, transaction, context) {
      if ("production" !== 'production') {
        var selfDebugID = getDebugID(this);
        if (this._currentElement) {
          try {
            ReactCurrentOwner.current = this._currentElement._owner;
            return ReactChildReconciler.instantiateChildren(nestedChildren, transaction, context, selfDebugID);
          } finally {
            ReactCurrentOwner.current = null;
          }
        }
      }
      return ReactChildReconciler.instantiateChildren(nestedChildren, transaction, context);
    },

    _reconcilerUpdateChildren: function (prevChildren, nextNestedChildrenElements, mountImages, removedNodes, transaction, context) {
      var nextChildren;
      var selfDebugID = 0;
      if ("production" !== 'production') {
        selfDebugID = getDebugID(this);
        if (this._currentElement) {
          try {
            ReactCurrentOwner.current = this._currentElement._owner;
            nextChildren = flattenChildren(nextNestedChildrenElements, selfDebugID);
          } finally {
            ReactCurrentOwner.current = null;
          }
          ReactChildReconciler.updateChildren(prevChildren, nextChildren, mountImages, removedNodes, transaction, this, this._hostContainerInfo, context, selfDebugID);
          return nextChildren;
        }
      }
      nextChildren = flattenChildren(nextNestedChildrenElements, selfDebugID);
      ReactChildReconciler.updateChildren(prevChildren, nextChildren, mountImages, removedNodes, transaction, this, this._hostContainerInfo, context, selfDebugID);
      return nextChildren;
    },

    /**
     * Generates a "mount image" for each of the supplied children. In the case
     * of `ReactDOMComponent`, a mount image is a string of markup.
     *
     * @param {?object} nestedChildren Nested child maps.
     * @return {array} An array of mounted representations.
     * @internal
     */
    mountChildren: function (nestedChildren, transaction, context) {
      var children = this._reconcilerInstantiateChildren(nestedChildren, transaction, context);
      this._renderedChildren = children;

      var mountImages = [];
      var index = 0;
      for (var name in children) {
        if (children.hasOwnProperty(name)) {
          var child = children[name];
          var selfDebugID = 0;
          if ("production" !== 'production') {
            selfDebugID = getDebugID(this);
          }
          var mountImage = ReactReconciler.mountComponent(child, transaction, this, this._hostContainerInfo, context, selfDebugID);
          child._mountIndex = index++;
          mountImages.push(mountImage);
        }
      }

      if ("production" !== 'production') {
        setChildrenForInstrumentation.call(this, children);
      }

      return mountImages;
    },

    /**
     * Replaces any rendered children with a text content string.
     *
     * @param {string} nextContent String of content.
     * @internal
     */
    updateTextContent: function (nextContent) {
      var prevChildren = this._renderedChildren;
      // Remove any rendered children.
      ReactChildReconciler.unmountChildren(prevChildren, false);
      for (var name in prevChildren) {
        if (prevChildren.hasOwnProperty(name)) {
          !false ? "production" !== 'production' ? invariant(false, 'updateTextContent called on non-empty component.') : _prodInvariant('118') : void 0;
        }
      }
      // Set new text content.
      var updates = [makeTextContent(nextContent)];
      processQueue(this, updates);
    },

    /**
     * Replaces any rendered children with a markup string.
     *
     * @param {string} nextMarkup String of markup.
     * @internal
     */
    updateMarkup: function (nextMarkup) {
      var prevChildren = this._renderedChildren;
      // Remove any rendered children.
      ReactChildReconciler.unmountChildren(prevChildren, false);
      for (var name in prevChildren) {
        if (prevChildren.hasOwnProperty(name)) {
          !false ? "production" !== 'production' ? invariant(false, 'updateTextContent called on non-empty component.') : _prodInvariant('118') : void 0;
        }
      }
      var updates = [makeSetMarkup(nextMarkup)];
      processQueue(this, updates);
    },

    /**
     * Updates the rendered children with new children.
     *
     * @param {?object} nextNestedChildrenElements Nested child element maps.
     * @param {ReactReconcileTransaction} transaction
     * @internal
     */
    updateChildren: function (nextNestedChildrenElements, transaction, context) {
      // Hook used by React ART
      this._updateChildren(nextNestedChildrenElements, transaction, context);
    },

    /**
     * @param {?object} nextNestedChildrenElements Nested child element maps.
     * @param {ReactReconcileTransaction} transaction
     * @final
     * @protected
     */
    _updateChildren: function (nextNestedChildrenElements, transaction, context) {
      var prevChildren = this._renderedChildren;
      var removedNodes = {};
      var mountImages = [];
      var nextChildren = this._reconcilerUpdateChildren(prevChildren, nextNestedChildrenElements, mountImages, removedNodes, transaction, context);
      if (!nextChildren && !prevChildren) {
        return;
      }
      var updates = null;
      var name;
      // `nextIndex` will increment for each child in `nextChildren`, but
      // `lastIndex` will be the last index visited in `prevChildren`.
      var nextIndex = 0;
      var lastIndex = 0;
      // `nextMountIndex` will increment for each newly mounted child.
      var nextMountIndex = 0;
      var lastPlacedNode = null;
      for (name in nextChildren) {
        if (!nextChildren.hasOwnProperty(name)) {
          continue;
        }
        var prevChild = prevChildren && prevChildren[name];
        var nextChild = nextChildren[name];
        if (prevChild === nextChild) {
          updates = enqueue(updates, this.moveChild(prevChild, lastPlacedNode, nextIndex, lastIndex));
          lastIndex = Math.max(prevChild._mountIndex, lastIndex);
          prevChild._mountIndex = nextIndex;
        } else {
          if (prevChild) {
            // Update `lastIndex` before `_mountIndex` gets unset by unmounting.
            lastIndex = Math.max(prevChild._mountIndex, lastIndex);
            // The `removedNodes` loop below will actually remove the child.
          }
          // The child must be instantiated before it's mounted.
          updates = enqueue(updates, this._mountChildAtIndex(nextChild, mountImages[nextMountIndex], lastPlacedNode, nextIndex, transaction, context));
          nextMountIndex++;
        }
        nextIndex++;
        lastPlacedNode = ReactReconciler.getHostNode(nextChild);
      }
      // Remove children that are no longer present.
      for (name in removedNodes) {
        if (removedNodes.hasOwnProperty(name)) {
          updates = enqueue(updates, this._unmountChild(prevChildren[name], removedNodes[name]));
        }
      }
      if (updates) {
        processQueue(this, updates);
      }
      this._renderedChildren = nextChildren;

      if ("production" !== 'production') {
        setChildrenForInstrumentation.call(this, nextChildren);
      }
    },

    /**
     * Unmounts all rendered children. This should be used to clean up children
     * when this component is unmounted. It does not actually perform any
     * backend operations.
     *
     * @internal
     */
    unmountChildren: function (safely) {
      var renderedChildren = this._renderedChildren;
      ReactChildReconciler.unmountChildren(renderedChildren, safely);
      this._renderedChildren = null;
    },

    /**
     * Moves a child component to the supplied index.
     *
     * @param {ReactComponent} child Component to move.
     * @param {number} toIndex Destination index of the element.
     * @param {number} lastIndex Last index visited of the siblings of `child`.
     * @protected
     */
    moveChild: function (child, afterNode, toIndex, lastIndex) {
      // If the index of `child` is less than `lastIndex`, then it needs to
      // be moved. Otherwise, we do not need to move it because a child will be
      // inserted or moved before `child`.
      if (child._mountIndex < lastIndex) {
        return makeMove(child, afterNode, toIndex);
      }
    },

    /**
     * Creates a child component.
     *
     * @param {ReactComponent} child Component to create.
     * @param {string} mountImage Markup to insert.
     * @protected
     */
    createChild: function (child, afterNode, mountImage) {
      return makeInsertMarkup(mountImage, afterNode, child._mountIndex);
    },

    /**
     * Removes a child component.
     *
     * @param {ReactComponent} child Child to remove.
     * @protected
     */
    removeChild: function (child, node) {
      return makeRemove(child, node);
    },

    /**
     * Mounts a child with the supplied name.
     *
     * NOTE: This is part of `updateChildren` and is here for readability.
     *
     * @param {ReactComponent} child Component to mount.
     * @param {string} name Name of the child.
     * @param {number} index Index at which to insert the child.
     * @param {ReactReconcileTransaction} transaction
     * @private
     */
    _mountChildAtIndex: function (child, mountImage, afterNode, index, transaction, context) {
      child._mountIndex = index;
      return this.createChild(child, afterNode, mountImage);
    },

    /**
     * Unmounts a rendered child.
     *
     * NOTE: This is part of `updateChildren` and is here for readability.
     *
     * @param {ReactComponent} child Component to unmount.
     * @private
     */
    _unmountChild: function (child, node) {
      var update = this.removeChild(child, node);
      child._mountIndex = null;
      return update;
    }
  }
};

module.exports = ReactMultiChild;
},{"./ReactChildReconciler":556,"./ReactComponentEnvironment":558,"./ReactInstanceMap":591,"./ReactInstrumentation":592,"./ReactReconciler":602,"./flattenChildren":634,"./reactProdInvariant":650,"fbjs/lib/emptyFunction":394,"fbjs/lib/invariant":402,"react/lib/ReactCurrentOwner":678}],597:[function(require,module,exports){
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

'use strict';

var _prodInvariant = require('./reactProdInvariant');

var React = require('react/lib/React');

var invariant = require('fbjs/lib/invariant');

var ReactNodeTypes = {
  HOST: 0,
  COMPOSITE: 1,
  EMPTY: 2,

  getType: function (node) {
    if (node === null || node === false) {
      return ReactNodeTypes.EMPTY;
    } else if (React.isValidElement(node)) {
      if (typeof node.type === 'function') {
        return ReactNodeTypes.COMPOSITE;
      } else {
        return ReactNodeTypes.HOST;
      }
    }
    !false ? "production" !== 'production' ? invariant(false, 'Unexpected node: %s', node) : _prodInvariant('26', node) : void 0;
  }
};

module.exports = ReactNodeTypes;
},{"./reactProdInvariant":650,"fbjs/lib/invariant":402,"react/lib/React":674}],598:[function(require,module,exports){
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

'use strict';

var _prodInvariant = require('./reactProdInvariant');

var invariant = require('fbjs/lib/invariant');

/**
 * @param {?object} object
 * @return {boolean} True if `object` is a valid owner.
 * @final
 */
function isValidOwner(object) {
  return !!(object && typeof object.attachRef === 'function' && typeof object.detachRef === 'function');
}

/**
 * ReactOwners are capable of storing references to owned components.
 *
 * All components are capable of //being// referenced by owner components, but
 * only ReactOwner components are capable of //referencing// owned components.
 * The named reference is known as a "ref".
 *
 * Refs are available when mounted and updated during reconciliation.
 *
 *   var MyComponent = React.createClass({
 *     render: function() {
 *       return (
 *         <div onClick={this.handleClick}>
 *           <CustomComponent ref="custom" />
 *         </div>
 *       );
 *     },
 *     handleClick: function() {
 *       this.refs.custom.handleClick();
 *     },
 *     componentDidMount: function() {
 *       this.refs.custom.initialize();
 *     }
 *   });
 *
 * Refs should rarely be used. When refs are used, they should only be done to
 * control data that is not handled by React's data flow.
 *
 * @class ReactOwner
 */
var ReactOwner = {
  /**
   * Adds a component by ref to an owner component.
   *
   * @param {ReactComponent} component Component to reference.
   * @param {string} ref Name by which to refer to the component.
   * @param {ReactOwner} owner Component on which to record the ref.
   * @final
   * @internal
   */
  addComponentAsRefTo: function (component, ref, owner) {
    !isValidOwner(owner) ? "production" !== 'production' ? invariant(false, 'addComponentAsRefTo(...): Only a ReactOwner can have refs. You might be adding a ref to a component that was not created inside a component\'s `render` method, or you have multiple copies of React loaded (details: https://fb.me/react-refs-must-have-owner).') : _prodInvariant('119') : void 0;
    owner.attachRef(ref, component);
  },

  /**
   * Removes a component by ref from an owner component.
   *
   * @param {ReactComponent} component Component to dereference.
   * @param {string} ref Name of the ref to remove.
   * @param {ReactOwner} owner Component on which the ref is recorded.
   * @final
   * @internal
   */
  removeComponentAsRefFrom: function (component, ref, owner) {
    !isValidOwner(owner) ? "production" !== 'production' ? invariant(false, 'removeComponentAsRefFrom(...): Only a ReactOwner can have refs. You might be removing a ref to a component that was not created inside a component\'s `render` method, or you have multiple copies of React loaded (details: https://fb.me/react-refs-must-have-owner).') : _prodInvariant('120') : void 0;
    var ownerPublicInstance = owner.getPublicInstance();
    // Check that `component`'s owner is still alive and that `component` is still the current ref
    // because we do not want to detach the ref if another component stole it.
    if (ownerPublicInstance && ownerPublicInstance.refs[ref] === component.getPublicInstance()) {
      owner.detachRef(ref);
    }
  }
};

module.exports = ReactOwner;
},{"./reactProdInvariant":650,"fbjs/lib/invariant":402}],599:[function(require,module,exports){
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

'use strict';

var ReactPropTypeLocationNames = {};

if ("production" !== 'production') {
  ReactPropTypeLocationNames = {
    prop: 'prop',
    context: 'context',
    childContext: 'child context'
  };
}

module.exports = ReactPropTypeLocationNames;
},{}],600:[function(require,module,exports){
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

'use strict';

var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';

module.exports = ReactPropTypesSecret;
},{}],601:[function(require,module,exports){
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */

'use strict';

var _assign = require('object-assign');

var CallbackQueue = require('./CallbackQueue');
var PooledClass = require('./PooledClass');
var ReactBrowserEventEmitter = require('./ReactBrowserEventEmitter');
var ReactInputSelection = require('./ReactInputSelection');
var ReactInstrumentation = require('./ReactInstrumentation');
var Transaction = require('./Transaction');
var ReactUpdateQueue = require('./ReactUpdateQueue');

/**
 * Ensures that, when possible, the selection range (currently selected text
 * input) is not disturbed by performing the transaction.
 */
var SELECTION_RESTORATION = {
  /**
   * @return {Selection} Selection information.
   */
  initialize: ReactInputSelection.getSelectionInformation,
  /**
   * @param {Selection} sel Selection information returned from `initialize`.
   */
  close: ReactInputSelection.restoreSelection
};

/**
 * Suppresses events (blur/focus) that could be inadvertently dispatched due to
 * high level DOM manipulations (like temporarily removing a text input from the
 * DOM).
 */
var EVENT_SUPPRESSION = {
  /**
   * @return {boolean} The enabled status of `ReactBrowserEventEmitter` before
   * the reconciliation.
   */
  initialize: function () {
    var currentlyEnabled = ReactBrowserEventEmitter.isEnabled();
    ReactBrowserEventEmitter.setEnabled(false);
    return currentlyEnabled;
  },

  /**
   * @param {boolean} previouslyEnabled Enabled status of
   *   `ReactBrowserEventEmitter` before the reconciliation occurred. `close`
   *   restores the previous value.
   */
  close: function (previouslyEnabled) {
    ReactBrowserEventEmitter.setEnabled(previouslyEnabled);
  }
};

/**
 * Provides a queue for collecting `componentDidMount` and
 * `componentDidUpdate` callbacks during the transaction.
 */
var ON_DOM_READY_QUEUEING = {
  /**
   * Initializes the internal `onDOMReady` queue.
   */
  initialize: function () {
    this.reactMountReady.reset();
  },

  /**
   * After DOM is flushed, invoke all registered `onDOMReady` callbacks.
   */
  close: function () {
    this.reactMountReady.notifyAll();
  }
};

/**
 * Executed within the scope of the `Transaction` instance. Consider these as
 * being member methods, but with an implied ordering while being isolated from
 * each other.
 */
var TRANSACTION_WRAPPERS = [SELECTION_RESTORATION, EVENT_SUPPRESSION, ON_DOM_READY_QUEUEING];

if ("production" !== 'production') {
  TRANSACTION_WRAPPERS.push({
    initialize: ReactInstrumentation.debugTool.onBeginFlush,
    close: ReactInstrumentation.debugTool.onEndFlush
  });
}

/**
 * Currently:
 * - The order that these are listed in the transaction is critical:
 * - Suppresses events.
 * - Restores selection range.
 *
 * Future:
 * - Restore document/overflow scroll positions that were unintentionally
 *   modified via DOM insertions above the top viewport boundary.
 * - Implement/integrate with customized constraint based layout system and keep
 *   track of which dimensions must be remeasured.
 *
 * @class ReactReconcileTransaction
 */
function ReactReconcileTransaction(useCreateElement) {
  this.reinitializeTransaction();
  // Only server-side rendering really needs this option (see
  // `ReactServerRendering`), but server-side uses
  // `ReactServerRenderingTransaction` instead. This option is here so that it's
  // accessible and defaults to false when `ReactDOMComponent` and
  // `ReactDOMTextComponent` checks it in `mountComponent`.`
  this.renderToStaticMarkup = false;
  this.reactMountReady = CallbackQueue.getPooled(null);
  this.useCreateElement = useCreateElement;
}

var Mixin = {
  /**
   * @see Transaction
   * @abstract
   * @final
   * @return {array<object>} List of operation wrap procedures.
   *   TODO: convert to array<TransactionWrapper>
   */
  getTransactionWrappers: function () {
    return TRANSACTION_WRAPPERS;
  },

  /**
   * @return {object} The queue to collect `onDOMReady` callbacks with.
   */
  getReactMountReady: function () {
    return this.reactMountReady;
  },

  /**
   * @return {object} The queue to collect React async events.
   */
  getUpdateQueue: function () {
    return ReactUpdateQueue;
  },

  /**
   * Save current transaction state -- if the return value from this method is
   * passed to `rollback`, the transaction will be reset to that state.
   */
  checkpoint: function () {
    // reactMountReady is the our only stateful wrapper
    return this.reactMountReady.checkpoint();
  },

  rollback: function (checkpoint) {
    this.reactMountReady.rollback(checkpoint);
  },

  /**
   * `PooledClass` looks for this, and will invoke this before allowing this
   * instance to be reused.
   */
  destructor: function () {
    CallbackQueue.release(this.reactMountReady);
    this.reactMountReady = null;
  }
};

_assign(ReactReconcileTransaction.prototype, Transaction, Mixin);

PooledClass.addPoolingTo(ReactReconcileTransaction);

module.exports = ReactReconcileTransaction;
},{"./CallbackQueue":536,"./PooledClass":554,"./ReactBrowserEventEmitter":555,"./ReactInputSelection":590,"./ReactInstrumentation":592,"./ReactUpdateQueue":606,"./Transaction":625,"object-assign":489}],602:[function(require,module,exports){
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */

'use strict';

var ReactRef = require('./ReactRef');
var ReactInstrumentation = require('./ReactInstrumentation');

var warning = require('fbjs/lib/warning');

/**
 * Helper to call ReactRef.attachRefs with this composite component, split out
 * to avoid allocations in the transaction mount-ready queue.
 */
function attachRefs() {
  ReactRef.attachRefs(this, this._currentElement);
}

var ReactReconciler = {
  /**
   * Initializes the component, renders markup, and registers event listeners.
   *
   * @param {ReactComponent} internalInstance
   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
   * @param {?object} the containing host component instance
   * @param {?object} info about the host container
   * @return {?string} Rendered markup to be inserted into the DOM.
   * @final
   * @internal
   */
  mountComponent: function (internalInstance, transaction, hostParent, hostContainerInfo, context, parentDebugID) // 0 in production and for roots
  {
    if ("production" !== 'production') {
      if (internalInstance._debugID !== 0) {
        ReactInstrumentation.debugTool.onBeforeMountComponent(internalInstance._debugID, internalInstance._currentElement, parentDebugID);
      }
    }
    var markup = internalInstance.mountComponent(transaction, hostParent, hostContainerInfo, context, parentDebugID);
    if (internalInstance._currentElement && internalInstance._currentElement.ref != null) {
      transaction.getReactMountReady().enqueue(attachRefs, internalInstance);
    }
    if ("production" !== 'production') {
      if (internalInstance._debugID !== 0) {
        ReactInstrumentation.debugTool.onMountComponent(internalInstance._debugID);
      }
    }
    return markup;
  },

  /**
   * Returns a value that can be passed to
   * ReactComponentEnvironment.replaceNodeWithMarkup.
   */
  getHostNode: function (internalInstance) {
    return internalInstance.getHostNode();
  },

  /**
   * Releases any resources allocated by `mountComponent`.
   *
   * @final
   * @internal
   */
  unmountComponent: function (internalInstance, safely) {
    if ("production" !== 'production') {
      if (internalInstance._debugID !== 0) {
        ReactInstrumentation.debugTool.onBeforeUnmountComponent(internalInstance._debugID);
      }
    }
    ReactRef.detachRefs(internalInstance, internalInstance._currentElement);
    internalInstance.unmountComponent(safely);
    if ("production" !== 'production') {
      if (internalInstance._debugID !== 0) {
        ReactInstrumentation.debugTool.onUnmountComponent(internalInstance._debugID);
      }
    }
  },

  /**
   * Update a component using a new element.
   *
   * @param {ReactComponent} internalInstance
   * @param {ReactElement} nextElement
   * @param {ReactReconcileTransaction} transaction
   * @param {object} context
   * @internal
   */
  receiveComponent: function (internalInstance, nextElement, transaction, context) {
    var prevElement = internalInstance._currentElement;

    if (nextElement === prevElement && context === internalInstance._context) {
      // Since elements are immutable after the owner is rendered,
      // we can do a cheap identity compare here to determine if this is a
      // superfluous reconcile. It's possible for state to be mutable but such
      // change should trigger an update of the owner which would recreate
      // the element. We explicitly check for the existence of an owner since
      // it's possible for an element created outside a composite to be
      // deeply mutated and reused.

      // TODO: Bailing out early is just a perf optimization right?
      // TODO: Removing the return statement should affect correctness?
      return;
    }

    if ("production" !== 'production') {
      if (internalInstance._debugID !== 0) {
        ReactInstrumentation.debugTool.onBeforeUpdateComponent(internalInstance._debugID, nextElement);
      }
    }

    var refsChanged = ReactRef.shouldUpdateRefs(prevElement, nextElement);

    if (refsChanged) {
      ReactRef.detachRefs(internalInstance, prevElement);
    }

    internalInstance.receiveComponent(nextElement, transaction, context);

    if (refsChanged && internalInstance._currentElement && internalInstance._currentElement.ref != null) {
      transaction.getReactMountReady().enqueue(attachRefs, internalInstance);
    }

    if ("production" !== 'production') {
      if (internalInstance._debugID !== 0) {
        ReactInstrumentation.debugTool.onUpdateComponent(internalInstance._debugID);
      }
    }
  },

  /**
   * Flush any dirty changes in a component.
   *
   * @param {ReactComponent} internalInstance
   * @param {ReactReconcileTransaction} transaction
   * @internal
   */
  performUpdateIfNecessary: function (internalInstance, transaction, updateBatchNumber) {
    if (internalInstance._updateBatchNumber !== updateBatchNumber) {
      // The component's enqueued batch number should always be the current
      // batch or the following one.
      "production" !== 'production' ? warning(internalInstance._updateBatchNumber == null || internalInstance._updateBatchNumber === updateBatchNumber + 1, 'performUpdateIfNecessary: Unexpected batch number (current %s, ' + 'pending %s)', updateBatchNumber, internalInstance._updateBatchNumber) : void 0;
      return;
    }
    if ("production" !== 'production') {
      if (internalInstance._debugID !== 0) {
        ReactInstrumentation.debugTool.onBeforeUpdateComponent(internalInstance._debugID, internalInstance._currentElement);
      }
    }
    internalInstance.performUpdateIfNecessary(transaction);
    if ("production" !== 'production') {
      if (internalInstance._debugID !== 0) {
        ReactInstrumentation.debugTool.onUpdateComponent(internalInstance._debugID);
      }
    }
  }
};

module.exports = ReactReconciler;
},{"./ReactInstrumentation":592,"./ReactRef":603,"fbjs/lib/warning":409}],603:[function(require,module,exports){
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

'use strict';

var ReactOwner = require('./ReactOwner');

var ReactRef = {};

function attachRef(ref, component, owner) {
  if (typeof ref === 'function') {
    ref(component.getPublicInstance());
  } else {
    // Legacy ref
    ReactOwner.addComponentAsRefTo(component, ref, owner);
  }
}

function detachRef(ref, component, owner) {
  if (typeof ref === 'function') {
    ref(null);
  } else {
    // Legacy ref
    ReactOwner.removeComponentAsRefFrom(component, ref, owner);
  }
}

ReactRef.attachRefs = function (instance, element) {
  if (element === null || typeof element !== 'object') {
    return;
  }
  var ref = element.ref;
  if (ref != null) {
    attachRef(ref, instance, element._owner);
  }
};

ReactRef.shouldUpdateRefs = function (prevElement, nextElement) {
  // If either the owner or a `ref` has changed, make sure the newest owner
  // has stored a reference to `this`, and the previous owner (if different)
  // has forgotten the reference to `this`. We use the element instead
  // of the public this.props because the post processing cannot determine
  // a ref. The ref conceptually lives on the element.

  // TODO: Should this even be possible? The owner cannot change because
  // it's forbidden by shouldUpdateReactComponent. The ref can change
  // if you swap the keys of but not the refs. Reconsider where this check
  // is made. It probably belongs where the key checking and
  // instantiateReactComponent is done.

  var prevRef = null;
  var prevOwner = null;
  if (prevElement !== null && typeof prevElement === 'object') {
    prevRef = prevElement.ref;
    prevOwner = prevElement._owner;
  }

  var nextRef = null;
  var nextOwner = null;
  if (nextElement !== null && typeof nextElement === 'object') {
    nextRef = nextElement.ref;
    nextOwner = nextElement._owner;
  }

  return prevRef !== nextRef ||
  // If owner changes but we have an unchanged function ref, don't update refs
  typeof nextRef === 'string' && nextOwner !== prevOwner;
};

ReactRef.detachRefs = function (instance, element) {
  if (element === null || typeof element !== 'object') {
    return;
  }
  var ref = element.ref;
  if (ref != null) {
    detachRef(ref, instance, element._owner);
  }
};

module.exports = ReactRef;
},{"./ReactOwner":598}],604:[function(require,module,exports){
/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */

'use strict';

var _assign = require('object-assign');

var PooledClass = require('./PooledClass');
var Transaction = require('./Transaction');
var ReactInstrumentation = require('./ReactInstrumentation');
var ReactServerUpdateQueue = require('./ReactServerUpdateQueue');

/**
 * Executed within the scope of the `Transaction` instance. Consider these as
 * being member methods, but with an implied ordering while being isolated from
 * each other.
 */
var TRANSACTION_WRAPPERS = [];

if ("production" !== 'production') {
  TRANSACTION_WRAPPERS.push({
    initialize: ReactInstrumentation.debugTool.onBeginFlush,
    close: ReactInstrumentation.debugTool.onEndFlush
  });
}

var noopCallbackQueue = {
  enqueue: function () {}
};

/**
 * @class ReactServerRenderingTransaction
 * @param {boolean} renderToStaticMarkup
 */
function ReactServerRenderingTransaction(renderToStaticMarkup) {
  this.reinitializeTransaction();
  this.renderToStaticMarkup = renderToStaticMarkup;
  this.useCreateElement = false;
  this.updateQueue = new ReactServerUpdateQueue(this);
}

var Mixin = {
  /**
   * @see Transaction
   * @abstract
   * @final
   * @return {array} Empty list of operation wrap procedures.
   */
  getTransactionWrappers: function () {
    return TRANSACTION_WRAPPERS;
  },

  /**
   * @return {object} The queue to collect `onDOMReady` callbacks with.
   */
  getReactMountReady: function () {
    return noopCallbackQueue;
  },

  /**
   * @return {object} The queue to collect React async events.
   */
  getUpdateQueue: function () {
    return this.updateQueue;
  },

  /**
   * `PooledClass` looks for this, and will invoke this before allowing this
   * instance to be reused.
   */
  destructor: function () {},

  checkpoint: function () {},

  rollback: function () {}
};

_assign(ReactServerRenderingTransaction.prototype, Transaction, Mixin);

PooledClass.addPoolingTo(ReactServerRenderingTransaction);

module.exports = ReactServerRenderingTransaction;
},{"./PooledClass":554,"./ReactInstrumentation":592,"./ReactServerUpdateQueue":605,"./Transaction":625,"object-assign":489}],605:[function(require,module,exports){
/**
 * Copyright (c) 2015-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

'use strict';

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var ReactUpdateQueue = require('./ReactUpdateQueue');

var warning = require('fbjs/lib/warning');

function warnNoop(publicInstance, callerName) {
  if ("production" !== 'production') {
    var constructor = publicInstance.constructor;
    "production" !== 'production' ? warning(false, '%s(...): Can only update a mounting component. ' + 'This usually means you called %s() outside componentWillMount() on the server. ' + 'This is a no-op. Please check the code for the %s component.', callerName, callerName, constructor && (constructor.displayName || constructor.name) || 'ReactClass') : void 0;
  }
}

/**
 * This is the update queue used for server rendering.
 * It delegates to ReactUpdateQueue while server rendering is in progress and
 * switches to ReactNoopUpdateQueue after the transaction has completed.
 * @class ReactServerUpdateQueue
 * @param {Transaction} transaction
 */

var ReactServerUpdateQueue = function () {
  function ReactServerUpdateQueue(transaction) {
    _classCallCheck(this, ReactServerUpdateQueue);

    this.transaction = transaction;
  }

  /**
   * Checks whether or not this composite component is mounted.
   * @param {ReactClass} publicInstance The instance we want to test.
   * @return {boolean} True if mounted, false otherwise.
   * @protected
   * @final
   */


  ReactServerUpdateQueue.prototype.isMounted = function isMounted(publicInstance) {
    return false;
  };

  /**
   * Enqueue a callback that will be executed after all the pending updates
   * have processed.
   *
   * @param {ReactClass} publicInstance The instance to use as `this` context.
   * @param {?function} callback Called after state is updated.
   * @internal
   */


  ReactServerUpdateQueue.prototype.enqueueCallback = function enqueueCallback(publicInstance, callback, callerName) {
    if (this.transaction.isInTransaction()) {
      ReactUpdateQueue.enqueueCallback(publicInstance, callback, callerName);
    }
  };

  /**
   * Forces an update. This should only be invoked when it is known with
   * certainty that we are **not** in a DOM transaction.
   *
   * You may want to call this when you know that some deeper aspect of the
   * component's state has changed but `setState` was not called.
   *
   * This will not invoke `shouldComponentUpdate`, but it will invoke
   * `componentWillUpdate` and `componentDidUpdate`.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @internal
   */


  ReactServerUpdateQueue.prototype.enqueueForceUpdate = function enqueueForceUpdate(publicInstance) {
    if (this.transaction.isInTransaction()) {
      ReactUpdateQueue.enqueueForceUpdate(publicInstance);
    } else {
      warnNoop(publicInstance, 'forceUpdate');
    }
  };

  /**
   * Replaces all of the state. Always use this or `setState` to mutate state.
   * You should treat `this.state` as immutable.
   *
   * There is no guarantee that `this.state` will be immediately updated, so
   * accessing `this.state` after calling this method may return the old value.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {object|function} completeState Next state.
   * @internal
   */


  ReactServerUpdateQueue.prototype.enqueueReplaceState = function enqueueReplaceState(publicInstance, completeState) {
    if (this.transaction.isInTransaction()) {
      ReactUpdateQueue.enqueueReplaceState(publicInstance, completeState);
    } else {
      warnNoop(publicInstance, 'replaceState');
    }
  };

  /**
   * Sets a subset of the state. This only exists because _pendingState is
   * internal. This provides a merging strategy that is not available to deep
   * properties which is confusing. TODO: Expose pendingState or don't use it
   * during the merge.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {object|function} partialState Next partial state to be merged with state.
   * @internal
   */


  ReactServerUpdateQueue.prototype.enqueueSetState = function enqueueSetState(publicInstance, partialState) {
    if (this.transaction.isInTransaction()) {
      ReactUpdateQueue.enqueueSetState(publicInstance, partialState);
    } else {
      warnNoop(publicInstance, 'setState');
    }
  };

  return ReactServerUpdateQueue;
}();

module.exports = ReactServerUpdateQueue;
},{"./ReactUpdateQueue":606,"fbjs/lib/warning":409}],606:[function(require,module,exports){
/**
 * Copyright (c) 2015-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */

'use strict';

var _prodInvariant = require('./reactProdInvariant');

var ReactCurrentOwner = require('react/lib/ReactCurrentOwner');
var ReactInstanceMap = require('./ReactInstanceMap');
var ReactInstrumentation = require('./ReactInstrumentation');
var ReactUpdates = require('./ReactUpdates');

var invariant = require('fbjs/lib/invariant');
var warning = require('fbjs/lib/warning');

function enqueueUpdate(internalInstance) {
  ReactUpdates.enqueueUpdate(internalInstance);
}

function formatUnexpectedArgument(arg) {
  var type = typeof arg;
  if (type !== 'object') {
    return type;
  }
  var displayName = arg.constructor && arg.constructor.name || type;
  var keys = Object.keys(arg);
  if (keys.length > 0 && keys.length < 20) {
    return displayName + ' (keys: ' + keys.join(', ') + ')';
  }
  return displayName;
}

function getInternalInstanceReadyForUpdate(publicInstance, callerName) {
  var internalInstance = ReactInstanceMap.get(publicInstance);
  if (!internalInstance) {
    if ("production" !== 'production') {
      var ctor = publicInstance.constructor;
      // Only warn when we have a callerName. Otherwise we should be silent.
      // We're probably calling from enqueueCallback. We don't want to warn
      // there because we already warned for the corresponding lifecycle method.
      "production" !== 'production' ? warning(!callerName, '%s(...): Can only update a mounted or mounting component. ' + 'This usually means you called %s() on an unmounted component. ' + 'This is a no-op. Please check the code for the %s component.', callerName, callerName, ctor && (ctor.displayName || ctor.name) || 'ReactClass') : void 0;
    }
    return null;
  }

  if ("production" !== 'production') {
    "production" !== 'production' ? warning(ReactCurrentOwner.current == null, '%s(...): Cannot update during an existing state transition (such as ' + "within `render` or another component's constructor). Render methods " + 'should be a pure function of props and state; constructor ' + 'side-effects are an anti-pattern, but can be moved to ' + '`componentWillMount`.', callerName) : void 0;
  }

  return internalInstance;
}

/**
 * ReactUpdateQueue allows for state updates to be scheduled into a later
 * reconciliation step.
 */
var ReactUpdateQueue = {
  /**
   * Checks whether or not this composite component is mounted.
   * @param {ReactClass} publicInstance The instance we want to test.
   * @return {boolean} True if mounted, false otherwise.
   * @protected
   * @final
   */
  isMounted: function (publicInstance) {
    if ("production" !== 'production') {
      var owner = ReactCurrentOwner.current;
      if (owner !== null) {
        "production" !== 'production' ? warning(owner._warnedAboutRefsInRender, '%s is accessing isMounted inside its render() function. ' + 'render() should be a pure function of props and state. It should ' + 'never access something that requires stale data from the previous ' + 'render, such as refs. Move this logic to componentDidMount and ' + 'componentDidUpdate instead.', owner.getName() || 'A component') : void 0;
        owner._warnedAboutRefsInRender = true;
      }
    }
    var internalInstance = ReactInstanceMap.get(publicInstance);
    if (internalInstance) {
      // During componentWillMount and render this will still be null but after
      // that will always render to something. At least for now. So we can use
      // this hack.
      return !!internalInstance._renderedComponent;
    } else {
      return false;
    }
  },

  /**
   * Enqueue a callback that will be executed after all the pending updates
   * have processed.
   *
   * @param {ReactClass} publicInstance The instance to use as `this` context.
   * @param {?function} callback Called after state is updated.
   * @param {string} callerName Name of the calling function in the public API.
   * @internal
   */
  enqueueCallback: function (publicInstance, callback, callerName) {
    ReactUpdateQueue.validateCallback(callback, callerName);
    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance);

    // Previously we would throw an error if we didn't have an internal
    // instance. Since we want to make it a no-op instead, we mirror the same
    // behavior we have in other enqueue* methods.
    // We also need to ignore callbacks in componentWillMount. See
    // enqueueUpdates.
    if (!internalInstance) {
      return null;
    }

    if (internalInstance._pendingCallbacks) {
      internalInstance._pendingCallbacks.push(callback);
    } else {
      internalInstance._pendingCallbacks = [callback];
    }
    // TODO: The callback here is ignored when setState is called from
    // componentWillMount. Either fix it or disallow doing so completely in
    // favor of getInitialState. Alternatively, we can disallow
    // componentWillMount during server-side rendering.
    enqueueUpdate(internalInstance);
  },

  enqueueCallbackInternal: function (internalInstance, callback) {
    if (internalInstance._pendingCallbacks) {
      internalInstance._pendingCallbacks.push(callback);
    } else {
      internalInstance._pendingCallbacks = [callback];
    }
    enqueueUpdate(internalInstance);
  },

  /**
   * Forces an update. This should only be invoked when it is known with
   * certainty that we are **not** in a DOM transaction.
   *
   * You may want to call this when you know that some deeper aspect of the
   * component's state has changed but `setState` was not called.
   *
   * This will not invoke `shouldComponentUpdate`, but it will invoke
   * `componentWillUpdate` and `componentDidUpdate`.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @internal
   */
  enqueueForceUpdate: function (publicInstance) {
    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'forceUpdate');

    if (!internalInstance) {
      return;
    }

    internalInstance._pendingForceUpdate = true;

    enqueueUpdate(internalInstance);
  },

  /**
   * Replaces all of the state. Always use this or `setState` to mutate state.
   * You should treat `this.state` as immutable.
   *
   * There is no guarantee that `this.state` will be immediately updated, so
   * accessing `this.state` after calling this method may return the old value.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {object} completeState Next state.
   * @internal
   */
  enqueueReplaceState: function (publicInstance, completeState, callback) {
    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'replaceState');

    if (!internalInstance) {
      return;
    }

    internalInstance._pendingStateQueue = [completeState];
    internalInstance._pendingReplaceState = true;

    // Future-proof 15.5
    if (callback !== undefined && callback !== null) {
      ReactUpdateQueue.validateCallback(callback, 'replaceState');
      if (internalInstance._pendingCallbacks) {
        internalInstance._pendingCallbacks.push(callback);
      } else {
        internalInstance._pendingCallbacks = [callback];
      }
    }

    enqueueUpdate(internalInstance);
  },

  /**
   * Sets a subset of the state. This only exists because _pendingState is
   * internal. This provides a merging strategy that is not available to deep
   * properties which is confusing. TODO: Expose pendingState or don't use it
   * during the merge.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {object} partialState Next partial state to be merged with state.
   * @internal
   */
  enqueueSetState: function (publicInstance, partialState) {
    if ("production" !== 'production') {
      ReactInstrumentation.debugTool.onSetState();
      "production" !== 'production' ? warning(partialState != null, 'setState(...): You passed an undefined or null state object; ' + 'instead, use forceUpdate().') : void 0;
    }

    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'setState');

    if (!internalInstance) {
      return;
    }

    var queue = internalInstance._pendingStateQueue || (internalInstance._pendingStateQueue = []);
    queue.push(partialState);

    enqueueUpdate(internalInstance);
  },

  enqueueElementInternal: function (internalInstance, nextElement, nextContext) {
    internalInstance._pendingElement = nextElement;
    // TODO: introduce _pendingContext instead of setting it directly.
    internalInstance._context = nextContext;
    enqueueUpdate(internalInstance);
  },

  validateCallback: function (callback, callerName) {
    !(!callback || typeof callback === 'function') ? "production" !== 'production' ? invariant(false, '%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.', callerName, formatUnexpectedArgument(callback)) : _prodInvariant('122', callerName, formatUnexpectedArgument(callback)) : void 0;
  }
};

module.exports = ReactUpdateQueue;
},{"./ReactInstanceMap":591,"./ReactInstrumentation":592,"./ReactUpdates":607,"./reactProdInvariant":650,"fbjs/lib/invariant":402,"fbjs/lib/warning":409,"react/lib/ReactCurrentOwner":678}],607:[function(require,module,exports){
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */

'use strict';

var _prodInvariant = require('./reactProdInvariant'),
    _assign = require('object-assign');

var CallbackQueue = require('./CallbackQueue');
var PooledClass = require('./PooledClass');
var ReactFeatureFlags = require('./ReactFeatureFlags');
var ReactReconciler = require('./ReactReconciler');
var Transaction = require('./Transaction');

var invariant = require('fbjs/lib/invariant');

var dirtyComponents = [];
var updateBatchNumber = 0;
var asapCallbackQueue = CallbackQueue.getPooled();
var asapEnqueued = false;

var batchingStrategy = null;

function ensureInjected() {
  !(ReactUpdates.ReactReconcileTransaction && batchingStrategy) ? "production" !== 'production' ? invariant(false, 'ReactUpdates: must inject a reconcile transaction class and batching strategy') : _prodInvariant('123') : void 0;
}

var NESTED_UPDATES = {
  initialize: function () {
    this.dirtyComponentsLength = dirtyComponents.length;
  },
  close: function () {
    if (this.dirtyComponentsLength !== dirtyComponents.length) {
      // Additional updates were enqueued by componentDidUpdate handlers or
      // similar; before our own UPDATE_QUEUEING wrapper closes, we want to run
      // these new updates so that if A's componentDidUpdate calls setState on
      // B, B will update before the callback A's updater provided when calling
      // setState.
      dirtyComponents.splice(0, this.dirtyComponentsLength);
      flushBatchedUpdates();
    } else {
      dirtyComponents.length = 0;
    }
  }
};

var UPDATE_QUEUEING = {
  initialize: function () {
    this.callbackQueue.reset();
  },
  close: function () {
    this.callbackQueue.notifyAll();
  }
};

var TRANSACTION_WRAPPERS = [NESTED_UPDATES, UPDATE_QUEUEING];

function ReactUpdatesFlushTransaction() {
  this.reinitializeTransaction();
  this.dirtyComponentsLength = null;
  this.callbackQueue = CallbackQueue.getPooled();
  this.reconcileTransaction = ReactUpdates.ReactReconcileTransaction.getPooled(
  /* useCreateElement */true);
}

_assign(ReactUpdatesFlushTransaction.prototype, Transaction, {
  getTransactionWrappers: function () {
    return TRANSACTION_WRAPPERS;
  },

  destructor: function () {
    this.dirtyComponentsLength = null;
    CallbackQueue.release(this.callbackQueue);
    this.callbackQueue = null;
    ReactUpdates.ReactReconcileTransaction.release(this.reconcileTransaction);
    this.reconcileTransaction = null;
  },

  perform: function (method, scope, a) {
    // Essentially calls `this.reconcileTransaction.perform(method, scope, a)`
    // with this transaction's wrappers around it.
    return Transaction.perform.call(this, this.reconcileTransaction.perform, this.reconcileTransaction, method, scope, a);
  }
});

PooledClass.addPoolingTo(ReactUpdatesFlushTransaction);

function batchedUpdates(callback, a, b, c, d, e) {
  ensureInjected();
  return batchingStrategy.batchedUpdates(callback, a, b, c, d, e);
}

/**
 * Array comparator for ReactComponents by mount ordering.
 *
 * @param {ReactComponent} c1 first component you're comparing
 * @param {ReactComponent} c2 second component you're comparing
 * @return {number} Return value usable by Array.prototype.sort().
 */
function mountOrderComparator(c1, c2) {
  return c1._mountOrder - c2._mountOrder;
}

function runBatchedUpdates(transaction) {
  var len = transaction.dirtyComponentsLength;
  !(len === dirtyComponents.length) ? "production" !== 'production' ? invariant(false, 'Expected flush transaction\'s stored dirty-components length (%s) to match dirty-components array length (%s).', len, dirtyComponents.length) : _prodInvariant('124', len, dirtyComponents.length) : void 0;

  // Since reconciling a component higher in the owner hierarchy usually (not
  // always -- see shouldComponentUpdate()) will reconcile children, reconcile
  // them before their children by sorting the array.
  dirtyComponents.sort(mountOrderComparator);

  // Any updates enqueued while reconciling must be performed after this entire
  // batch. Otherwise, if dirtyComponents is [A, B] where A has children B and
  // C, B could update twice in a single batch if C's render enqueues an update
  // to B (since B would have already updated, we should skip it, and the only
  // way we can know to do so is by checking the batch counter).
  updateBatchNumber++;

  for (var i = 0; i < len; i++) {
    // If a component is unmounted before pending changes apply, it will still
    // be here, but we assume that it has cleared its _pendingCallbacks and
    // that performUpdateIfNecessary is a noop.
    var component = dirtyComponents[i];

    // If performUpdateIfNecessary happens to enqueue any new updates, we
    // shouldn't execute the callbacks until the next render happens, so
    // stash the callbacks first
    var callbacks = component._pendingCallbacks;
    component._pendingCallbacks = null;

    var markerName;
    if (ReactFeatureFlags.logTopLevelRenders) {
      var namedComponent = component;
      // Duck type TopLevelWrapper. This is probably always true.
      if (component._currentElement.type.isReactTopLevelWrapper) {
        namedComponent = component._renderedComponent;
      }
      markerName = 'React update: ' + namedComponent.getName();
      console.time(markerName);
    }

    ReactReconciler.performUpdateIfNecessary(component, transaction.reconcileTransaction, updateBatchNumber);

    if (markerName) {
      console.timeEnd(markerName);
    }

    if (callbacks) {
      for (var j = 0; j < callbacks.length; j++) {
        transaction.callbackQueue.enqueue(callbacks[j], component.getPublicInstance());
      }
    }
  }
}

var flushBatchedUpdates = function () {
  // ReactUpdatesFlushTransaction's wrappers will clear the dirtyComponents
  // array and perform any updates enqueued by mount-ready handlers (i.e.,
  // componentDidUpdate) but we need to check here too in order to catch
  // updates enqueued by setState callbacks and asap calls.
  while (dirtyComponents.length || asapEnqueued) {
    if (dirtyComponents.length) {
      var transaction = ReactUpdatesFlushTransaction.getPooled();
      transaction.perform(runBatchedUpdates, null, transaction);
      ReactUpdatesFlushTransaction.release(transaction);
    }

    if (asapEnqueued) {
      asapEnqueued = false;
      var queue = asapCallbackQueue;
      asapCallbackQueue = CallbackQueue.getPooled();
      queue.notifyAll();
      CallbackQueue.release(queue);
    }
  }
};

/**
 * Mark a component as needing a rerender, adding an optional callback to a
 * list of functions which will be executed once the rerender occurs.
 */
function enqueueUpdate(component) {
  ensureInjected();

  // Various parts of our code (such as ReactCompositeComponent's
  // _renderValidatedComponent) assume that calls to render aren't nested;
  // verify that that's the case. (This is called by each top-level update
  // function, like setState, forceUpdate, etc.; creation and
  // destruction of top-level components is guarded in ReactMount.)

  if (!batchingStrategy.isBatchingUpdates) {
    batchingStrategy.batchedUpdates(enqueueUpdate, component);
    return;
  }

  dirtyComponents.push(component);
  if (component._updateBatchNumber == null) {
    component._updateBatchNumber = updateBatchNumber + 1;
  }
}

/**
 * Enqueue a callback to be run at the end of the current batching cycle. Throws
 * if no updates are currently being performed.
 */
function asap(callback, context) {
  invariant(batchingStrategy.isBatchingUpdates, "ReactUpdates.asap: Can't enqueue an asap callback in a context where" + 'updates are not being batched.');
  asapCallbackQueue.enqueue(callback, context);
  asapEnqueued = true;
}

var ReactUpdatesInjection = {
  injectReconcileTransaction: function (ReconcileTransaction) {
    !ReconcileTransaction ? "production" !== 'production' ? invariant(false, 'ReactUpdates: must provide a reconcile transaction class') : _prodInvariant('126') : void 0;
    ReactUpdates.ReactReconcileTransaction = ReconcileTransaction;
  },

  injectBatchingStrategy: function (_batchingStrategy) {
    !_batchingStrategy ? "production" !== 'production' ? invariant(false, 'ReactUpdates: must provide a batching strategy') : _prodInvariant('127') : void 0;
    !(typeof _batchingStrategy.batchedUpdates === 'function') ? "production" !== 'production' ? invariant(false, 'ReactUpdates: must provide a batchedUpdates() function') : _prodInvariant('128') : void 0;
    !(typeof _batchingStrategy.isBatchingUpdates === 'boolean') ? "production" !== 'production' ? invariant(false, 'ReactUpdates: must provide an isBatchingUpdates boolean attribute') : _prodInvariant('129') : void 0;
    batchingStrategy = _batchingStrategy;
  }
};

var ReactUpdates = {
  /**
   * React references `ReactReconcileTransaction` using this property in order
   * to allow dependency injection.
   *
   * @internal
   */
  ReactReconcileTransaction: null,

  batchedUpdates: batchedUpdates,
  enqueueUpdate: enqueueUpdate,
  flushBatchedUpdates: flushBatchedUpdates,
  injection: ReactUpdatesInjection,
  asap: asap
};

module.exports = ReactUpdates;
},{"./CallbackQueue":536,"./PooledClass":554,"./ReactFeatureFlags":586,"./ReactReconciler":602,"./Transaction":625,"./reactProdInvariant":650,"fbjs/lib/invariant":402,"object-assign":489}],608:[function(require,module,exports){
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */

'use strict';

module.exports = '15.6.2';
},{}],609:[function(require,module,exports){
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */

'use strict';

var NS = {
  xlink: 'http://www.w3.org/1999/xlink',
  xml: 'http://www.w3.org/XML/1998/namespace'
};

// We use attributes for everything SVG so let's avoid some duplication and run
// code instead.
// The following are all specified in the HTML config already so we exclude here.
// - class (as className)
// - color
// - height
// - id
// - lang
// - max
// - media
// - method
// - min
// - name
// - style
// - target
// - type
// - width
var ATTRS = {
  accentHeight: 'accent-height',
  accumulate: 0,
  additive: 0,
  alignmentBaseline: 'alignment-baseline',
  allowReorder: 'allowReorder',
  alphabetic: 0,
  amplitude: 0,
  arabicForm: 'arabic-form',
  ascent: 0,
  attributeName: 'attributeName',
  attributeType: 'attributeType',
  autoReverse: 'autoReverse',
  azimuth: 0,
  baseFrequency: 'baseFrequency',
  baseProfile: 'baseProfile',
  baselineShift: 'baseline-shift',
  bbox: 0,
  begin: 0,
  bias: 0,
  by: 0,
  calcMode: 'calcMode',
  capHeight: 'cap-height',
  clip: 0,
  clipPath: 'clip-path',
  clipRule: 'clip-rule',
  clipPathUnits: 'clipPathUnits',
  colorInterpolation: 'color-interpolation',
  colorInterpolationFilters: 'color-interpolation-filters',
  colorProfile: 'color-profile',
  colorRendering: 'color-rendering',
  contentScriptType: 'contentScriptType',
  contentStyleType: 'contentStyleType',
  cursor: 0,
  cx: 0,
  cy: 0,
  d: 0,
  decelerate: 0,
  descent: 0,
  diffuseConstant: 'diffuseConstant',
  direction: 0,
  display: 0,
  divisor: 0,
  dominantBaseline: 'dominant-baseline',
  dur: 0,
  dx: 0,
  dy: 0,
  edgeMode: 'edgeMode',
  elevation: 0,
  enableBackground: 'enable-background',
  end: 0,
  exponent: 0,
  externalResourcesRequired: 'externalResourcesRequired',
  fill: 0,
  fillOpacity: 'fill-opacity',
  fillRule: 'fill-rule',
  filter: 0,
  filterRes: 'filterRes',
  filterUnits: 'filterUnits',
  floodColor: 'flood-color',
  floodOpacity: 'flood-opacity',
  focusable: 0,
  fontFamily: 'font-family',
  fontSize: 'font-size',
  fontSizeAdjust: 'font-size-adjust',
  fontStretch: 'font-stretch',
  fontStyle: 'font-style',
  fontVariant: 'font-variant',
  fontWeight: 'font-weight',
  format: 0,
  from: 0,
  fx: 0,
  fy: 0,
  g1: 0,
  g2: 0,
  glyphName: 'glyph-name',
  glyphOrientationHorizontal: 'glyph-orientation-horizontal',
  glyphOrientationVertical: 'glyph-orientation-vertical',
  glyphRef: 'glyphRef',
  gradientTransform: 'gradientTransform',
  gradientUnits: 'gradientUnits',
  hanging: 0,
  horizAdvX: 'horiz-adv-x',
  horizOriginX: 'horiz-origin-x',
  ideographic: 0,
  imageRendering: 'image-rendering',
  'in': 0,
  in2: 0,
  intercept: 0,
  k: 0,
  k1: 0,
  k2: 0,
  k3: 0,
  k4: 0,
  kernelMatrix: 'kernelMatrix',
  kernelUnitLength: 'kernelUnitLength',
  kerning: 0,
  keyPoints: 'keyPoints',
  keySplines: 'keySplines',
  keyTimes: 'keyTimes',
  lengthAdjust: 'lengthAdjust',
  letterSpacing: 'letter-spacing',
  lightingColor: 'lighting-color',
  limitingConeAngle: 'limitingConeAngle',
  local: 0,
  markerEnd: 'marker-end',
  markerMid: 'marker-mid',
  markerStart: 'marker-start',
  markerHeight: 'markerHeight',
  markerUnits: 'markerUnits',
  markerWidth: 'markerWidth',
  mask: 0,
  maskContentUnits: 'maskContentUnits',
  maskUnits: 'maskUnits',
  mathematical: 0,
  mode: 0,
  numOctaves: 'numOctaves',
  offset: 0,
  opacity: 0,
  operator: 0,
  order: 0,
  orient: 0,
  orientation: 0,
  origin: 0,
  overflow: 0,
  overlinePosition: 'overline-position',
  overlineThickness: 'overline-thickness',
  paintOrder: 'paint-order',
  panose1: 'panose-1',
  pathLength: 'pathLength',
  patternContentUnits: 'patternContentUnits',
  patternTransform: 'patternTransform',
  patternUnits: 'patternUnits',
  pointerEvents: 'pointer-events',
  points: 0,
  pointsAtX: 'pointsAtX',
  pointsAtY: 'pointsAtY',
  pointsAtZ: 'pointsAtZ',
  preserveAlpha: 'preserveAlpha',
  preserveAspectRatio: 'preserveAspectRatio',
  primitiveUnits: 'primitiveUnits',
  r: 0,
  radius: 0,
  refX: 'refX',
  refY: 'refY',
  renderingIntent: 'rendering-intent',
  repeatCount: 'repeatCount',
  repeatDur: 'repeatDur',
  requiredExtensions: 'requiredExtensions',
  requiredFeatures: 'requiredFeatures',
  restart: 0,
  result: 0,
  rotate: 0,
  rx: 0,
  ry: 0,
  scale: 0,
  seed: 0,
  shapeRendering: 'shape-rendering',
  slope: 0,
  spacing: 0,
  specularConstant: 'specularConstant',
  specularExponent: 'specularExponent',
  speed: 0,
  spreadMethod: 'spreadMethod',
  startOffset: 'startOffset',
  stdDeviation: 'stdDeviation',
  stemh: 0,
  stemv: 0,
  stitchTiles: 'stitchTiles',
  stopColor: 'stop-color',
  stopOpacity: 'stop-opacity',
  strikethroughPosition: 'strikethrough-position',
  strikethroughThickness: 'strikethrough-thickness',
  string: 0,
  stroke: 0,
  strokeDasharray: 'stroke-dasharray',
  strokeDashoffset: 'stroke-dashoffset',
  strokeLinecap: 'stroke-linecap',
  strokeLinejoin: 'stroke-linejoin',
  strokeMiterlimit: 'stroke-miterlimit',
  strokeOpacity: 'stroke-opacity',
  strokeWidth: 'stroke-width',
  surfaceScale: 'surfaceScale',
  systemLanguage: 'systemLanguage',
  tableValues: 'tableValues',
  targetX: 'targetX',
  targetY: 'targetY',
  textAnchor: 'text-anchor',
  textDecoration: 'text-decoration',
  textRendering: 'text-rendering',
  textLength: 'textLength',
  to: 0,
  transform: 0,
  u1: 0,
  u2: 0,
  underlinePosition: 'underline-position',
  underlineThickness: 'underline-thickness',
  unicode: 0,
  unicodeBidi: 'unicode-bidi',
  unicodeRange: 'unicode-range',
  unitsPerEm: 'units-per-em',
  vAlphabetic: 'v-alphabetic',
  vHanging: 'v-hanging',
  vIdeographic: 'v-ideographic',
  vMathematical: 'v-mathematical',
  values: 0,
  vectorEffect: 'vector-effect',
  version: 0,
  vertAdvY: 'vert-adv-y',
  vertOriginX: 'vert-origin-x',
  vertOriginY: 'vert-origin-y',
  viewBox: 'viewBox',
  viewTarget: 'viewTarget',
  visibility: 0,
  widths: 0,
  wordSpacing: 'word-spacing',
  writingMode: 'writing-mode',
  x: 0,
  xHeight: 'x-height',
  x1: 0,
  x2: 0,
  xChannelSelector: 'xChannelSelector',
  xlinkActuate: 'xlink:actuate',
  xlinkArcrole: 'xlink:arcrole',
  xlinkHref: 'xlink:href',
  xlinkRole: 'xlink:role',
  xlinkShow: 'xlink:show',
  xlinkTitle: 'xlink:title',
  xlinkType: 'xlink:type',
  xmlBase: 'xml:base',
  xmlns: 0,
  xmlnsXlink: 'xmlns:xlink',
  xmlLang: 'xml:lang',
  xmlSpace: 'xml:space',
  y: 0,
  y1: 0,
  y2: 0,
  yChannelSelector: 'yChannelSelector',
  z: 0,
  zoomAndPan: 'zoomAndPan'
};

var SVGDOMPropertyConfig = {
  Properties: {},
  DOMAttributeNamespaces: {
    xlinkActuate: NS.xlink,
    xlinkArcrole: NS.xlink,
    xlinkHref: NS.xlink,
    xlinkRole: NS.xlink,
    xlinkShow: NS.xlink,
    xlinkTitle: NS.xlink,
    xlinkType: NS.xlink,
    xmlBase: NS.xml,
    xmlLang: NS.xml,
    xmlSpace: NS.xml
  },
  DOMAttributeNames: {}
};

Object.keys(ATTRS).forEach(function (key) {
  SVGDOMPropertyConfig.Properties[key] = 0;
  if (ATTRS[key]) {
    SVGDOMPropertyConfig.DOMAttributeNames[key] = ATTRS[key];
  }
});

module.exports = SVGDOMPropertyConfig;
},{}],610:[function(require,module,exports){
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */

'use strict';

var EventPropagators = require('./EventPropagators');
var ExecutionEnvironment = require('fbjs/lib/ExecutionEnvironment');
var ReactDOMComponentTree = require('./ReactDOMComponentTree');
var ReactInputSelection = require('./ReactInputSelection');
var SyntheticEvent = require('./SyntheticEvent');

var getActiveElement = require('fbjs/lib/getActiveElement');
var isTextInputElement = require('./isTextInputElement');
var shallowEqual = require('fbjs/lib/shallowEqual');

var skipSelectionChangeEvent = ExecutionEnvironment.canUseDOM && 'documentMode' in document && document.documentMode <= 11;

var eventTypes = {
  select: {
    phasedRegistrationNames: {
      bubbled: 'onSelect',
      captured: 'onSelectCapture'
    },
    dependencies: ['topBlur', 'topContextMenu', 'topFocus', 'topKeyDown', 'topKeyUp', 'topMouseDown', 'topMouseUp', 'topSelectionChange']
  }
};

var activeElement = null;
var activeElementInst = null;
var lastSelection = null;
var mouseDown = false;

// Track whether a listener exists for this plugin. If none exist, we do
// not extract events. See #3639.
var hasListener = false;

/**
 * Get an object which is a unique representation of the current selection.
 *
 * The return value will not be consistent across nodes or browsers, but
 * two identical selections on the same node will return identical objects.
 *
 * @param {DOMElement} node
 * @return {object}
 */
function getSelection(node) {
  if ('selectionStart' in node && ReactInputSelection.hasSelectionCapabilities(node)) {
    return {
      start: node.selectionStart,
      end: node.selectionEnd
    };
  } else if (window.getSelection) {
    var selection = window.getSelection();
    return {
      anchorNode: selection.anchorNode,
      anchorOffset: selection.anchorOffset,
      focusNode: selection.focusNode,
      focusOffset: selection.focusOffset
    };
  } else if (document.selection) {
    var range = document.selection.createRange();
    return {
      parentElement: range.parentElement(),
      text: range.text,
      top: range.boundingTop,
      left: range.boundingLeft
    };
  }
}

/**
 * Poll selection to see whether it's changed.
 *
 * @param {object} nativeEvent
 * @return {?SyntheticEvent}
 */
function constructSelectEvent(nativeEvent, nativeEventTarget) {
  // Ensure we have the right element, and that the user is not dragging a
  // selection (this matches native `select` event behavior). In HTML5, select
  // fires only on input and textarea thus if there's no focused element we
  // won't dispatch.
  if (mouseDown || activeElement == null || activeElement !== getActiveElement()) {
    return null;
  }

  // Only fire when selection has actually changed.
  var currentSelection = getSelection(activeElement);
  if (!lastSelection || !shallowEqual(lastSelection, currentSelection)) {
    lastSelection = currentSelection;

    var syntheticEvent = SyntheticEvent.getPooled(eventTypes.select, activeElementInst, nativeEvent, nativeEventTarget);

    syntheticEvent.type = 'select';
    syntheticEvent.target = activeElement;

    EventPropagators.accumulateTwoPhaseDispatches(syntheticEvent);

    return syntheticEvent;
  }

  return null;
}

/**
 * This plugin creates an `onSelect` event that normalizes select events
 * across form elements.
 *
 * Supported elements are:
 * - input (see `isTextInputElement`)
 * - textarea
 * - contentEditable
 *
 * This differs from native browser implementations in the following ways:
 * - Fires on contentEditable fields as well as inputs.
 * - Fires for collapsed selection.
 * - Fires after user input.
 */
var SelectEventPlugin = {
  eventTypes: eventTypes,

  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
    if (!hasListener) {
      return null;
    }

    var targetNode = targetInst ? ReactDOMComponentTree.getNodeFromInstance(targetInst) : window;

    switch (topLevelType) {
      // Track the input node that has focus.
      case 'topFocus':
        if (isTextInputElement(targetNode) || targetNode.contentEditable === 'true') {
          activeElement = targetNode;
          activeElementInst = targetInst;
          lastSelection = null;
        }
        break;
      case 'topBlur':
        activeElement = null;
        activeElementInst = null;
        lastSelection = null;
        break;
      // Don't fire the event while the user is dragging. This matches the
      // semantics of the native select event.
      case 'topMouseDown':
        mouseDown = true;
        break;
      case 'topContextMenu':
      case 'topMouseUp':
        mouseDown = false;
        return constructSelectEvent(nativeEvent, nativeEventTarget);
      // Chrome and IE fire non-standard event when selection is changed (and
      // sometimes when it hasn't). IE's event fires out of order with respect
      // to key and input events on deletion, so we discard it.
      //
      // Firefox doesn't support selectionchange, so check selection status
      // after each key entry. The selection changes after keydown and before
      // keyup, but we check on keydown as well in the case of holding down a
      // key, when multiple keydown events are fired but only one keyup is.
      // This is also our approach for IE handling, for the reason above.
      case 'topSelectionChange':
        if (skipSelectionChangeEvent) {
          break;
        }
      // falls through
      case 'topKeyDown':
      case 'topKeyUp':
        return constructSelectEvent(nativeEvent, nativeEventTarget);
    }

    return null;
  },

  didPutListener: function (inst, registrationName, listener) {
    if (registrationName === 'onSelect') {
      hasListener = true;
    }
  }
};

module.exports = SelectEventPlugin;
},{"./EventPropagators":549,"./ReactDOMComponentTree":563,"./ReactInputSelection":590,"./SyntheticEvent":616,"./isTextInputElement":648,"fbjs/lib/ExecutionEnvironment":388,"fbjs/lib/getActiveElement":397,"fbjs/lib/shallowEqual":408}],611:[function(require,module,exports){
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

'use strict';

var _prodInvariant = require('./reactProdInvariant');

var EventListener = require('fbjs/lib/EventListener');
var EventPropagators = require('./EventPropagators');
var ReactDOMComponentTree = require('./ReactDOMComponentTree');
var SyntheticAnimationEvent = require('./SyntheticAnimationEvent');
var SyntheticClipboardEvent = require('./SyntheticClipboardEvent');
var SyntheticEvent = require('./SyntheticEvent');
var SyntheticFocusEvent = require('./SyntheticFocusEvent');
var SyntheticKeyboardEvent = require('./SyntheticKeyboardEvent');
var SyntheticMouseEvent = require('./SyntheticMouseEvent');
var SyntheticDragEvent = require('./SyntheticDragEvent');
var SyntheticTouchEvent = require('./SyntheticTouchEvent');
var SyntheticTransitionEvent = require('./SyntheticTransitionEvent');
var SyntheticUIEvent = require('./SyntheticUIEvent');
var SyntheticWheelEvent = require('./SyntheticWheelEvent');

var emptyFunction = require('fbjs/lib/emptyFunction');
var getEventCharCode = require('./getEventCharCode');
var invariant = require('fbjs/lib/invariant');

/**
 * Turns
 * ['abort', ...]
 * into
 * eventTypes = {
 *   'abort': {
 *     phasedRegistrationNames: {
 *       bubbled: 'onAbort',
 *       captured: 'onAbortCapture',
 *     },
 *     dependencies: ['topAbort'],
 *   },
 *   ...
 * };
 * topLevelEventsToDispatchConfig = {
 *   'topAbort': { sameConfig }
 * };
 */
var eventTypes = {};
var topLevelEventsToDispatchConfig = {};
['abort', 'animationEnd', 'animationIteration', 'animationStart', 'blur', 'canPlay', 'canPlayThrough', 'click', 'contextMenu', 'copy', 'cut', 'doubleClick', 'drag', 'dragEnd', 'dragEnter', 'dragExit', 'dragLeave', 'dragOver', 'dragStart', 'drop', 'durationChange', 'emptied', 'encrypted', 'ended', 'error', 'focus', 'input', 'invalid', 'keyDown', 'keyPress', 'keyUp', 'load', 'loadedData', 'loadedMetadata', 'loadStart', 'mouseDown', 'mouseMove', 'mouseOut', 'mouseOver', 'mouseUp', 'paste', 'pause', 'play', 'playing', 'progress', 'rateChange', 'reset', 'scroll', 'seeked', 'seeking', 'stalled', 'submit', 'suspend', 'timeUpdate', 'touchCancel', 'touchEnd', 'touchMove', 'touchStart', 'transitionEnd', 'volumeChange', 'waiting', 'wheel'].forEach(function (event) {
  var capitalizedEvent = event[0].toUpperCase() + event.slice(1);
  var onEvent = 'on' + capitalizedEvent;
  var topEvent = 'top' + capitalizedEvent;

  var type = {
    phasedRegistrationNames: {
      bubbled: onEvent,
      captured: onEvent + 'Capture'
    },
    dependencies: [topEvent]
  };
  eventTypes[event] = type;
  topLevelEventsToDispatchConfig[topEvent] = type;
});

var onClickListeners = {};

function getDictionaryKey(inst) {
  // Prevents V8 performance issue:
  // https://github.com/facebook/react/pull/7232
  return '.' + inst._rootNodeID;
}

function isInteractive(tag) {
  return tag === 'button' || tag === 'input' || tag === 'select' || tag === 'textarea';
}

var SimpleEventPlugin = {
  eventTypes: eventTypes,

  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
    var dispatchConfig = topLevelEventsToDispatchConfig[topLevelType];
    if (!dispatchConfig) {
      return null;
    }
    var EventConstructor;
    switch (topLevelType) {
      case 'topAbort':
      case 'topCanPlay':
      case 'topCanPlayThrough':
      case 'topDurationChange':
      case 'topEmptied':
      case 'topEncrypted':
      case 'topEnded':
      case 'topError':
      case 'topInput':
      case 'topInvalid':
      case 'topLoad':
      case 'topLoadedData':
      case 'topLoadedMetadata':
      case 'topLoadStart':
      case 'topPause':
      case 'topPlay':
      case 'topPlaying':
      case 'topProgress':
      case 'topRateChange':
      case 'topReset':
      case 'topSeeked':
      case 'topSeeking':
      case 'topStalled':
      case 'topSubmit':
      case 'topSuspend':
      case 'topTimeUpdate':
      case 'topVolumeChange':
      case 'topWaiting':
        // HTML Events
        // @see http://www.w3.org/TR/html5/index.html#events-0
        EventConstructor = SyntheticEvent;
        break;
      case 'topKeyPress':
        // Firefox creates a keypress event for function keys too. This removes
        // the unwanted keypress events. Enter is however both printable and
        // non-printable. One would expect Tab to be as well (but it isn't).
        if (getEventCharCode(nativeEvent) === 0) {
          return null;
        }
      /* falls through */
      case 'topKeyDown':
      case 'topKeyUp':
        EventConstructor = SyntheticKeyboardEvent;
        break;
      case 'topBlur':
      case 'topFocus':
        EventConstructor = SyntheticFocusEvent;
        break;
      case 'topClick':
        // Firefox creates a click event on right mouse clicks. This removes the
        // unwanted click events.
        if (nativeEvent.button === 2) {
          return null;
        }
      /* falls through */
      case 'topDoubleClick':
      case 'topMouseDown':
      case 'topMouseMove':
      case 'topMouseUp':
      // TODO: Disabled elements should not respond to mouse events
      /* falls through */
      case 'topMouseOut':
      case 'topMouseOver':
      case 'topContextMenu':
        EventConstructor = SyntheticMouseEvent;
        break;
      case 'topDrag':
      case 'topDragEnd':
      case 'topDragEnter':
      case 'topDragExit':
      case 'topDragLeave':
      case 'topDragOver':
      case 'topDragStart':
      case 'topDrop':
        EventConstructor = SyntheticDragEvent;
        break;
      case 'topTouchCancel':
      case 'topTouchEnd':
      case 'topTouchMove':
      case 'topTouchStart':
        EventConstructor = SyntheticTouchEvent;
        break;
      case 'topAnimationEnd':
      case 'topAnimationIteration':
      case 'topAnimationStart':
        EventConstructor = SyntheticAnimationEvent;
        break;
      case 'topTransitionEnd':
        EventConstructor = SyntheticTransitionEvent;
        break;
      case 'topScroll':
        EventConstructor = SyntheticUIEvent;
        break;
      case 'topWheel':
        EventConstructor = SyntheticWheelEvent;
        break;
      case 'topCopy':
      case 'topCut':
      case 'topPaste':
        EventConstructor = SyntheticClipboardEvent;
        break;
    }
    !EventConstructor ? "production" !== 'production' ? invariant(false, 'SimpleEventPlugin: Unhandled event type, `%s`.', topLevelType) : _prodInvariant('86', topLevelType) : void 0;
    var event = EventConstructor.getPooled(dispatchConfig, targetInst, nativeEvent, nativeEventTarget);
    EventPropagators.accumulateTwoPhaseDispatches(event);
    return event;
  },

  didPutListener: function (inst, registrationName, listener) {
    // Mobile Safari does not fire properly bubble click events on
    // non-interactive elements, which means delegated click listeners do not
    // fire. The workaround for this bug involves attaching an empty click
    // listener on the target node.
    // http://www.quirksmode.org/blog/archives/2010/09/click_event_del.html
    if (registrationName === 'onClick' && !isInteractive(inst._tag)) {
      var key = getDictionaryKey(inst);
      var node = ReactDOMComponentTree.getNodeFromInstance(inst);
      if (!onClickListeners[key]) {
        onClickListeners[key] = EventListener.listen(node, 'click', emptyFunction);
      }
    }
  },

  willDeleteListener: function (inst, registrationName) {
    if (registrationName === 'onClick' && !isInteractive(inst._tag)) {
      var key = getDictionaryKey(inst);
      onClickListeners[key].remove();
      delete onClickListeners[key];
    }
  }
};

module.exports = SimpleEventPlugin;
},{"./EventPropagators":549,"./ReactDOMComponentTree":563,"./SyntheticAnimationEvent":612,"./SyntheticClipboardEvent":613,"./SyntheticDragEvent":615,"./SyntheticEvent":616,"./SyntheticFocusEvent":617,"./SyntheticKeyboardEvent":619,"./SyntheticMouseEvent":620,"./SyntheticTouchEvent":621,"./SyntheticTransitionEvent":622,"./SyntheticUIEvent":623,"./SyntheticWheelEvent":624,"./getEventCharCode":636,"./reactProdInvariant":650,"fbjs/lib/EventListener":387,"fbjs/lib/emptyFunction":394,"fbjs/lib/invariant":402}],612:[function(require,module,exports){
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */

'use strict';

var SyntheticEvent = require('./SyntheticEvent');

/**
 * @interface Event
 * @see http://www.w3.org/TR/css3-animations/#AnimationEvent-interface
 * @see https://developer.mozilla.org/en-US/docs/Web/API/AnimationEvent
 */
var AnimationEventInterface = {
  animationName: null,
  elapsedTime: null,
  pseudoElement: null
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticEvent}
 */
function SyntheticAnimationEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticEvent.augmentClass(SyntheticAnimationEvent, AnimationEventInterface);

module.exports = SyntheticAnimationEvent;
},{"./SyntheticEvent":616}],613:[function(require,module,exports){
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */

'use strict';

var SyntheticEvent = require('./SyntheticEvent');

/**
 * @interface Event
 * @see http://www.w3.org/TR/clipboard-apis/
 */
var ClipboardEventInterface = {
  clipboardData: function (event) {
    return 'clipboardData' in event ? event.clipboardData : window.clipboardData;
  }
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticUIEvent}
 */
function SyntheticClipboardEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticEvent.augmentClass(SyntheticClipboardEvent, ClipboardEventInterface);

module.exports = SyntheticClipboardEvent;
},{"./SyntheticEvent":616}],614:[function(require,module,exports){
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */

'use strict';

var SyntheticEvent = require('./SyntheticEvent');

/**
 * @interface Event
 * @see http://www.w3.org/TR/DOM-Level-3-Events/#events-compositionevents
 */
var CompositionEventInterface = {
  data: null
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticUIEvent}
 */
function SyntheticCompositionEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticEvent.augmentClass(SyntheticCompositionEvent, CompositionEventInterface);

module.exports = SyntheticCompositionEvent;
},{"./SyntheticEvent":616}],615:[function(require,module,exports){
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */

'use strict';

var SyntheticMouseEvent = require('./SyntheticMouseEvent');

/**
 * @interface DragEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */
var DragEventInterface = {
  dataTransfer: null
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticUIEvent}
 */
function SyntheticDragEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticMouseEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticMouseEvent.augmentClass(SyntheticDragEvent, DragEventInterface);

module.exports = SyntheticDragEvent;
},{"./SyntheticMouseEvent":620}],616:[function(require,module,exports){
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */

'use strict';

var _assign = require('object-assign');

var PooledClass = require('./PooledClass');

var emptyFunction = require('fbjs/lib/emptyFunction');
var warning = require('fbjs/lib/warning');

var didWarnForAddedNewProperty = false;
var isProxySupported = typeof Proxy === 'function';

var shouldBeReleasedProperties = ['dispatchConfig', '_targetInst', 'nativeEvent', 'isDefaultPrevented', 'isPropagationStopped', '_dispatchListeners', '_dispatchInstances'];

/**
 * @interface Event
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */
var EventInterface = {
  type: null,
  target: null,
  // currentTarget is set when dispatching; no use in copying it here
  currentTarget: emptyFunction.thatReturnsNull,
  eventPhase: null,
  bubbles: null,
  cancelable: null,
  timeStamp: function (event) {
    return event.timeStamp || Date.now();
  },
  defaultPrevented: null,
  isTrusted: null
};

/**
 * Synthetic events are dispatched by event plugins, typically in response to a
 * top-level event delegation handler.
 *
 * These systems should generally use pooling to reduce the frequency of garbage
 * collection. The system should check `isPersistent` to determine whether the
 * event should be released into the pool after being dispatched. Users that
 * need a persisted event should invoke `persist`.
 *
 * Synthetic events (and subclasses) implement the DOM Level 3 Events API by
 * normalizing browser quirks. Subclasses do not necessarily have to implement a
 * DOM interface; custom application-specific events can also subclass this.
 *
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {*} targetInst Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @param {DOMEventTarget} nativeEventTarget Target node.
 */
function SyntheticEvent(dispatchConfig, targetInst, nativeEvent, nativeEventTarget) {
  if ("production" !== 'production') {
    // these have a getter/setter for warnings
    delete this.nativeEvent;
    delete this.preventDefault;
    delete this.stopPropagation;
  }

  this.dispatchConfig = dispatchConfig;
  this._targetInst = targetInst;
  this.nativeEvent = nativeEvent;

  var Interface = this.constructor.Interface;
  for (var propName in Interface) {
    if (!Interface.hasOwnProperty(propName)) {
      continue;
    }
    if ("production" !== 'production') {
      delete this[propName]; // this has a getter/setter for warnings
    }
    var normalize = Interface[propName];
    if (normalize) {
      this[propName] = normalize(nativeEvent);
    } else {
      if (propName === 'target') {
        this.target = nativeEventTarget;
      } else {
        this[propName] = nativeEvent[propName];
      }
    }
  }

  var defaultPrevented = nativeEvent.defaultPrevented != null ? nativeEvent.defaultPrevented : nativeEvent.returnValue === false;
  if (defaultPrevented) {
    this.isDefaultPrevented = emptyFunction.thatReturnsTrue;
  } else {
    this.isDefaultPrevented = emptyFunction.thatReturnsFalse;
  }
  this.isPropagationStopped = emptyFunction.thatReturnsFalse;
  return this;
}

_assign(SyntheticEvent.prototype, {
  preventDefault: function () {
    this.defaultPrevented = true;
    var event = this.nativeEvent;
    if (!event) {
      return;
    }

    if (event.preventDefault) {
      event.preventDefault();
      // eslint-disable-next-line valid-typeof
    } else if (typeof event.returnValue !== 'unknown') {
      event.returnValue = false;
    }
    this.isDefaultPrevented = emptyFunction.thatReturnsTrue;
  },

  stopPropagation: function () {
    var event = this.nativeEvent;
    if (!event) {
      return;
    }

    if (event.stopPropagation) {
      event.stopPropagation();
      // eslint-disable-next-line valid-typeof
    } else if (typeof event.cancelBubble !== 'unknown') {
      // The ChangeEventPlugin registers a "propertychange" event for
      // IE. This event does not support bubbling or cancelling, and
      // any references to cancelBubble throw "Member not found".  A
      // typeof check of "unknown" circumvents this issue (and is also
      // IE specific).
      event.cancelBubble = true;
    }

    this.isPropagationStopped = emptyFunction.thatReturnsTrue;
  },

  /**
   * We release all dispatched `SyntheticEvent`s after each event loop, adding
   * them back into the pool. This allows a way to hold onto a reference that
   * won't be added back into the pool.
   */
  persist: function () {
    this.isPersistent = emptyFunction.thatReturnsTrue;
  },

  /**
   * Checks if this event should be released back into the pool.
   *
   * @return {boolean} True if this should not be released, false otherwise.
   */
  isPersistent: emptyFunction.thatReturnsFalse,

  /**
   * `PooledClass` looks for `destructor` on each instance it releases.
   */
  destructor: function () {
    var Interface = this.constructor.Interface;
    for (var propName in Interface) {
      if ("production" !== 'production') {
        Object.defineProperty(this, propName, getPooledWarningPropertyDefinition(propName, Interface[propName]));
      } else {
        this[propName] = null;
      }
    }
    for (var i = 0; i < shouldBeReleasedProperties.length; i++) {
      this[shouldBeReleasedProperties[i]] = null;
    }
    if ("production" !== 'production') {
      Object.defineProperty(this, 'nativeEvent', getPooledWarningPropertyDefinition('nativeEvent', null));
      Object.defineProperty(this, 'preventDefault', getPooledWarningPropertyDefinition('preventDefault', emptyFunction));
      Object.defineProperty(this, 'stopPropagation', getPooledWarningPropertyDefinition('stopPropagation', emptyFunction));
    }
  }
});

SyntheticEvent.Interface = EventInterface;

/**
 * Helper to reduce boilerplate when creating subclasses.
 *
 * @param {function} Class
 * @param {?object} Interface
 */
SyntheticEvent.augmentClass = function (Class, Interface) {
  var Super = this;

  var E = function () {};
  E.prototype = Super.prototype;
  var prototype = new E();

  _assign(prototype, Class.prototype);
  Class.prototype = prototype;
  Class.prototype.constructor = Class;

  Class.Interface = _assign({}, Super.Interface, Interface);
  Class.augmentClass = Super.augmentClass;

  PooledClass.addPoolingTo(Class, PooledClass.fourArgumentPooler);
};

/** Proxying after everything set on SyntheticEvent
  * to resolve Proxy issue on some WebKit browsers
  * in which some Event properties are set to undefined (GH#10010)
  */
if ("production" !== 'production') {
  if (isProxySupported) {
    /*eslint-disable no-func-assign */
    SyntheticEvent = new Proxy(SyntheticEvent, {
      construct: function (target, args) {
        return this.apply(target, Object.create(target.prototype), args);
      },
      apply: function (constructor, that, args) {
        return new Proxy(constructor.apply(that, args), {
          set: function (target, prop, value) {
            if (prop !== 'isPersistent' && !target.constructor.Interface.hasOwnProperty(prop) && shouldBeReleasedProperties.indexOf(prop) === -1) {
              "production" !== 'production' ? warning(didWarnForAddedNewProperty || target.isPersistent(), "This synthetic event is reused for performance reasons. If you're " + "seeing this, you're adding a new property in the synthetic event object. " + 'The property is never released. See ' + 'https://fb.me/react-event-pooling for more information.') : void 0;
              didWarnForAddedNewProperty = true;
            }
            target[prop] = value;
            return true;
          }
        });
      }
    });
    /*eslint-enable no-func-assign */
  }
}

PooledClass.addPoolingTo(SyntheticEvent, PooledClass.fourArgumentPooler);

module.exports = SyntheticEvent;

/**
  * Helper to nullify syntheticEvent instance properties when destructing
  *
  * @param {object} SyntheticEvent
  * @param {String} propName
  * @return {object} defineProperty object
  */
function getPooledWarningPropertyDefinition(propName, getVal) {
  var isFunction = typeof getVal === 'function';
  return {
    configurable: true,
    set: set,
    get: get
  };

  function set(val) {
    var action = isFunction ? 'setting the method' : 'setting the property';
    warn(action, 'This is effectively a no-op');
    return val;
  }

  function get() {
    var action = isFunction ? 'accessing the method' : 'accessing the property';
    var result = isFunction ? 'This is a no-op function' : 'This is set to null';
    warn(action, result);
    return getVal;
  }

  function warn(action, result) {
    var warningCondition = false;
    "production" !== 'production' ? warning(warningCondition, "This synthetic event is reused for performance reasons. If you're seeing this, " + "you're %s `%s` on a released/nullified synthetic event. %s. " + 'If you must keep the original synthetic event around, use event.persist(). ' + 'See https://fb.me/react-event-pooling for more information.', action, propName, result) : void 0;
  }
}
},{"./PooledClass":554,"fbjs/lib/emptyFunction":394,"fbjs/lib/warning":409,"object-assign":489}],617:[function(require,module,exports){
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */

'use strict';

var SyntheticUIEvent = require('./SyntheticUIEvent');

/**
 * @interface FocusEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */
var FocusEventInterface = {
  relatedTarget: null
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticUIEvent}
 */
function SyntheticFocusEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticUIEvent.augmentClass(SyntheticFocusEvent, FocusEventInterface);

module.exports = SyntheticFocusEvent;
},{"./SyntheticUIEvent":623}],618:[function(require,module,exports){
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */

'use strict';

var SyntheticEvent = require('./SyntheticEvent');

/**
 * @interface Event
 * @see http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105
 *      /#events-inputevents
 */
var InputEventInterface = {
  data: null
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticUIEvent}
 */
function SyntheticInputEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticEvent.augmentClass(SyntheticInputEvent, InputEventInterface);

module.exports = SyntheticInputEvent;
},{"./SyntheticEvent":616}],619:[function(require,module,exports){
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */

'use strict';

var SyntheticUIEvent = require('./SyntheticUIEvent');

var getEventCharCode = require('./getEventCharCode');
var getEventKey = require('./getEventKey');
var getEventModifierState = require('./getEventModifierState');

/**
 * @interface KeyboardEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */
var KeyboardEventInterface = {
  key: getEventKey,
  location: null,
  ctrlKey: null,
  shiftKey: null,
  altKey: null,
  metaKey: null,
  repeat: null,
  locale: null,
  getModifierState: getEventModifierState,
  // Legacy Interface
  charCode: function (event) {
    // `charCode` is the result of a KeyPress event and represents the value of
    // the actual printable character.

    // KeyPress is deprecated, but its replacement is not yet final and not
    // implemented in any major browser. Only KeyPress has charCode.
    if (event.type === 'keypress') {
      return getEventCharCode(event);
    }
    return 0;
  },
  keyCode: function (event) {
    // `keyCode` is the result of a KeyDown/Up event and represents the value of
    // physical keyboard key.

    // The actual meaning of the value depends on the users' keyboard layout
    // which cannot be detected. Assuming that it is a US keyboard layout
    // provides a surprisingly accurate mapping for US and European users.
    // Due to this, it is left to the user to implement at this time.
    if (event.type === 'keydown' || event.type === 'keyup') {
      return event.keyCode;
    }
    return 0;
  },
  which: function (event) {
    // `which` is an alias for either `keyCode` or `charCode` depending on the
    // type of the event.
    if (event.type === 'keypress') {
      return getEventCharCode(event);
    }
    if (event.type === 'keydown' || event.type === 'keyup') {
      return event.keyCode;
    }
    return 0;
  }
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticUIEvent}
 */
function SyntheticKeyboardEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticUIEvent.augmentClass(SyntheticKeyboardEvent, KeyboardEventInterface);

module.exports = SyntheticKeyboardEvent;
},{"./SyntheticUIEvent":623,"./getEventCharCode":636,"./getEventKey":637,"./getEventModifierState":638}],620:[function(require,module,exports){
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */

'use strict';

var SyntheticUIEvent = require('./SyntheticUIEvent');
var ViewportMetrics = require('./ViewportMetrics');

var getEventModifierState = require('./getEventModifierState');

/**
 * @interface MouseEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */
var MouseEventInterface = {
  screenX: null,
  screenY: null,
  clientX: null,
  clientY: null,
  ctrlKey: null,
  shiftKey: null,
  altKey: null,
  metaKey: null,
  getModifierState: getEventModifierState,
  button: function (event) {
    // Webkit, Firefox, IE9+
    // which:  1 2 3
    // button: 0 1 2 (standard)
    var button = event.button;
    if ('which' in event) {
      return button;
    }
    // IE<9
    // which:  undefined
    // button: 0 0 0
    // button: 1 4 2 (onmouseup)
    return button === 2 ? 2 : button === 4 ? 1 : 0;
  },
  buttons: null,
  relatedTarget: function (event) {
    return event.relatedTarget || (event.fromElement === event.srcElement ? event.toElement : event.fromElement);
  },
  // "Proprietary" Interface.
  pageX: function (event) {
    return 'pageX' in event ? event.pageX : event.clientX + ViewportMetrics.currentScrollLeft;
  },
  pageY: function (event) {
    return 'pageY' in event ? event.pageY : event.clientY + ViewportMetrics.currentScrollTop;
  }
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticUIEvent}
 */
function SyntheticMouseEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticUIEvent.augmentClass(SyntheticMouseEvent, MouseEventInterface);

module.exports = SyntheticMouseEvent;
},{"./SyntheticUIEvent":623,"./ViewportMetrics":626,"./getEventModifierState":638}],621:[function(require,module,exports){
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */

'use strict';

var SyntheticUIEvent = require('./SyntheticUIEvent');

var getEventModifierState = require('./getEventModifierState');

/**
 * @interface TouchEvent
 * @see http://www.w3.org/TR/touch-events/
 */
var TouchEventInterface = {
  touches: null,
  targetTouches: null,
  changedTouches: null,
  altKey: null,
  metaKey: null,
  ctrlKey: null,
  shiftKey: null,
  getModifierState: getEventModifierState
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticUIEvent}
 */
function SyntheticTouchEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticUIEvent.augmentClass(SyntheticTouchEvent, TouchEventInterface);

module.exports = SyntheticTouchEvent;
},{"./SyntheticUIEvent":623,"./getEventModifierState":638}],622:[function(require,module,exports){
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */

'use strict';

var SyntheticEvent = require('./SyntheticEvent');

/**
 * @interface Event
 * @see http://www.w3.org/TR/2009/WD-css3-transitions-20090320/#transition-events-
 * @see https://developer.mozilla.org/en-US/docs/Web/API/TransitionEvent
 */
var TransitionEventInterface = {
  propertyName: null,
  elapsedTime: null,
  pseudoElement: null
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticEvent}
 */
function SyntheticTransitionEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticEvent.augmentClass(SyntheticTransitionEvent, TransitionEventInterface);

module.exports = SyntheticTransitionEvent;
},{"./SyntheticEvent":616}],623:[function(require,module,exports){
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */

'use strict';

var SyntheticEvent = require('./SyntheticEvent');

var getEventTarget = require('./getEventTarget');

/**
 * @interface UIEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */
var UIEventInterface = {
  view: function (event) {
    if (event.view) {
      return event.view;
    }

    var target = getEventTarget(event);
    if (target.window === target) {
      // target is a window object
      return target;
    }

    var doc = target.ownerDocument;
    // TODO: Figure out why `ownerDocument` is sometimes undefined in IE8.
    if (doc) {
      return doc.defaultView || doc.parentWindow;
    } else {
      return window;
    }
  },
  detail: function (event) {
    return event.detail || 0;
  }
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticEvent}
 */
function SyntheticUIEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticEvent.augmentClass(SyntheticUIEvent, UIEventInterface);

module.exports = SyntheticUIEvent;
},{"./SyntheticEvent":616,"./getEventTarget":639}],624:[function(require,module,exports){
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */

'use strict';

var SyntheticMouseEvent = require('./SyntheticMouseEvent');

/**
 * @interface WheelEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */
var WheelEventInterface = {
  deltaX: function (event) {
    return 'deltaX' in event ? event.deltaX : // Fallback to `wheelDeltaX` for Webkit and normalize (right is positive).
    'wheelDeltaX' in event ? -event.wheelDeltaX : 0;
  },
  deltaY: function (event) {
    return 'deltaY' in event ? event.deltaY : // Fallback to `wheelDeltaY` for Webkit and normalize (down is positive).
    'wheelDeltaY' in event ? -event.wheelDeltaY : // Fallback to `wheelDelta` for IE<9 and normalize (down is positive).
    'wheelDelta' in event ? -event.wheelDelta : 0;
  },
  deltaZ: null,

  // Browsers without "deltaMode" is reporting in raw wheel delta where one
  // notch on the scroll is always +/- 120, roughly equivalent to pixels.
  // A good approximation of DOM_DELTA_LINE (1) is 5% of viewport size or
  // ~40 pixels, for DOM_DELTA_SCREEN (2) it is 87.5% of viewport size.
  deltaMode: null
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticMouseEvent}
 */
function SyntheticWheelEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticMouseEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticMouseEvent.augmentClass(SyntheticWheelEvent, WheelEventInterface);

module.exports = SyntheticWheelEvent;
},{"./SyntheticMouseEvent":620}],625:[function(require,module,exports){
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

'use strict';

var _prodInvariant = require('./reactProdInvariant');

var invariant = require('fbjs/lib/invariant');

var OBSERVED_ERROR = {};

/**
 * `Transaction` creates a black box that is able to wrap any method such that
 * certain invariants are maintained before and after the method is invoked
 * (Even if an exception is thrown while invoking the wrapped method). Whoever
 * instantiates a transaction can provide enforcers of the invariants at
 * creation time. The `Transaction` class itself will supply one additional
 * automatic invariant for you - the invariant that any transaction instance
 * should not be run while it is already being run. You would typically create a
 * single instance of a `Transaction` for reuse multiple times, that potentially
 * is used to wrap several different methods. Wrappers are extremely simple -
 * they only require implementing two methods.
 *
 * <pre>
 *                       wrappers (injected at creation time)
 *                                      +        +
 *                                      |        |
 *                    +-----------------|--------|--------------+
 *                    |                 v        |              |
 *                    |      +---------------+   |              |
 *                    |   +--|    wrapper1   |---|----+         |
 *                    |   |  +---------------+   v    |         |
 *                    |   |          +-------------+  |         |
 *                    |   |     +----|   wrapper2  |--------+   |
 *                    |   |     |    +-------------+  |     |   |
 *                    |   |     |                     |     |   |
 *                    |   v     v                     v     v   | wrapper
 *                    | +---+ +---+   +---------+   +---+ +---+ | invariants
 * perform(anyMethod) | |   | |   |   |         |   |   | |   | | maintained
 * +----------------->|-|---|-|---|-->|anyMethod|---|---|-|---|-|-------->
 *                    | |   | |   |   |         |   |   | |   | |
 *                    | |   | |   |   |         |   |   | |   | |
 *                    | |   | |   |   |         |   |   | |   | |
 *                    | +---+ +---+   +---------+   +---+ +---+ |
 *                    |  initialize                    close    |
 *                    +-----------------------------------------+
 * </pre>
 *
 * Use cases:
 * - Preserving the input selection ranges before/after reconciliation.
 *   Restoring selection even in the event of an unexpected error.
 * - Deactivating events while rearranging the DOM, preventing blurs/focuses,
 *   while guaranteeing that afterwards, the event system is reactivated.
 * - Flushing a queue of collected DOM mutations to the main UI thread after a
 *   reconciliation takes place in a worker thread.
 * - Invoking any collected `componentDidUpdate` callbacks after rendering new
 *   content.
 * - (Future use case): Wrapping particular flushes of the `ReactWorker` queue
 *   to preserve the `scrollTop` (an automatic scroll aware DOM).
 * - (Future use case): Layout calculations before and after DOM updates.
 *
 * Transactional plugin API:
 * - A module that has an `initialize` method that returns any precomputation.
 * - and a `close` method that accepts the precomputation. `close` is invoked
 *   when the wrapped process is completed, or has failed.
 *
 * @param {Array<TransactionalWrapper>} transactionWrapper Wrapper modules
 * that implement `initialize` and `close`.
 * @return {Transaction} Single transaction for reuse in thread.
 *
 * @class Transaction
 */
var TransactionImpl = {
  /**
   * Sets up this instance so that it is prepared for collecting metrics. Does
   * so such that this setup method may be used on an instance that is already
   * initialized, in a way that does not consume additional memory upon reuse.
   * That can be useful if you decide to make your subclass of this mixin a
   * "PooledClass".
   */
  reinitializeTransaction: function () {
    this.transactionWrappers = this.getTransactionWrappers();
    if (this.wrapperInitData) {
      this.wrapperInitData.length = 0;
    } else {
      this.wrapperInitData = [];
    }
    this._isInTransaction = false;
  },

  _isInTransaction: false,

  /**
   * @abstract
   * @return {Array<TransactionWrapper>} Array of transaction wrappers.
   */
  getTransactionWrappers: null,

  isInTransaction: function () {
    return !!this._isInTransaction;
  },

  /* eslint-disable space-before-function-paren */

  /**
   * Executes the function within a safety window. Use this for the top level
   * methods that result in large amounts of computation/mutations that would
   * need to be safety checked. The optional arguments helps prevent the need
   * to bind in many cases.
   *
   * @param {function} method Member of scope to call.
   * @param {Object} scope Scope to invoke from.
   * @param {Object?=} a Argument to pass to the method.
   * @param {Object?=} b Argument to pass to the method.
   * @param {Object?=} c Argument to pass to the method.
   * @param {Object?=} d Argument to pass to the method.
   * @param {Object?=} e Argument to pass to the method.
   * @param {Object?=} f Argument to pass to the method.
   *
   * @return {*} Return value from `method`.
   */
  perform: function (method, scope, a, b, c, d, e, f) {
    /* eslint-enable space-before-function-paren */
    !!this.isInTransaction() ? "production" !== 'production' ? invariant(false, 'Transaction.perform(...): Cannot initialize a transaction when there is already an outstanding transaction.') : _prodInvariant('27') : void 0;
    var errorThrown;
    var ret;
    try {
      this._isInTransaction = true;
      // Catching errors makes debugging more difficult, so we start with
      // errorThrown set to true before setting it to false after calling
      // close -- if it's still set to true in the finally block, it means
      // one of these calls threw.
      errorThrown = true;
      this.initializeAll(0);
      ret = method.call(scope, a, b, c, d, e, f);
      errorThrown = false;
    } finally {
      try {
        if (errorThrown) {
          // If `method` throws, prefer to show that stack trace over any thrown
          // by invoking `closeAll`.
          try {
            this.closeAll(0);
          } catch (err) {}
        } else {
          // Since `method` didn't throw, we don't want to silence the exception
          // here.
          this.closeAll(0);
        }
      } finally {
        this._isInTransaction = false;
      }
    }
    return ret;
  },

  initializeAll: function (startIndex) {
    var transactionWrappers = this.transactionWrappers;
    for (var i = startIndex; i < transactionWrappers.length; i++) {
      var wrapper = transactionWrappers[i];
      try {
        // Catching errors makes debugging more difficult, so we start with the
        // OBSERVED_ERROR state before overwriting it with the real return value
        // of initialize -- if it's still set to OBSERVED_ERROR in the finally
        // block, it means wrapper.initialize threw.
        this.wrapperInitData[i] = OBSERVED_ERROR;
        this.wrapperInitData[i] = wrapper.initialize ? wrapper.initialize.call(this) : null;
      } finally {
        if (this.wrapperInitData[i] === OBSERVED_ERROR) {
          // The initializer for wrapper i threw an error; initialize the
          // remaining wrappers but silence any exceptions from them to ensure
          // that the first error is the one to bubble up.
          try {
            this.initializeAll(i + 1);
          } catch (err) {}
        }
      }
    }
  },

  /**
   * Invokes each of `this.transactionWrappers.close[i]` functions, passing into
   * them the respective return values of `this.transactionWrappers.init[i]`
   * (`close`rs that correspond to initializers that failed will not be
   * invoked).
   */
  closeAll: function (startIndex) {
    !this.isInTransaction() ? "production" !== 'production' ? invariant(false, 'Transaction.closeAll(): Cannot close transaction when none are open.') : _prodInvariant('28') : void 0;
    var transactionWrappers = this.transactionWrappers;
    for (var i = startIndex; i < transactionWrappers.length; i++) {
      var wrapper = transactionWrappers[i];
      var initData = this.wrapperInitData[i];
      var errorThrown;
      try {
        // Catching errors makes debugging more difficult, so we start with
        // errorThrown set to true before setting it to false after calling
        // close -- if it's still set to true in the finally block, it means
        // wrapper.close threw.
        errorThrown = true;
        if (initData !== OBSERVED_ERROR && wrapper.close) {
          wrapper.close.call(this, initData);
        }
        errorThrown = false;
      } finally {
        if (errorThrown) {
          // The closer for wrapper i threw an error; close the remaining
          // wrappers but silence any exceptions from them to ensure that the
          // first error is the one to bubble up.
          try {
            this.closeAll(i + 1);
          } catch (e) {}
        }
      }
    }
    this.wrapperInitData.length = 0;
  }
};

module.exports = TransactionImpl;
},{"./reactProdInvariant":650,"fbjs/lib/invariant":402}],626:[function(require,module,exports){
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */

'use strict';

var ViewportMetrics = {
  currentScrollLeft: 0,

  currentScrollTop: 0,

  refreshScrollValues: function (scrollPosition) {
    ViewportMetrics.currentScrollLeft = scrollPosition.x;
    ViewportMetrics.currentScrollTop = scrollPosition.y;
  }
};

module.exports = ViewportMetrics;
},{}],627:[function(require,module,exports){
/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

'use strict';

var _prodInvariant = require('./reactProdInvariant');

var invariant = require('fbjs/lib/invariant');

/**
 * Accumulates items that must not be null or undefined into the first one. This
 * is used to conserve memory by avoiding array allocations, and thus sacrifices
 * API cleanness. Since `current` can be null before being passed in and not
 * null after this function, make sure to assign it back to `current`:
 *
 * `a = accumulateInto(a, b);`
 *
 * This API should be sparingly used. Try `accumulate` for something cleaner.
 *
 * @return {*|array<*>} An accumulation of items.
 */

function accumulateInto(current, next) {
  !(next != null) ? "production" !== 'production' ? invariant(false, 'accumulateInto(...): Accumulated items must not be null or undefined.') : _prodInvariant('30') : void 0;

  if (current == null) {
    return next;
  }

  // Both are not empty. Warning: Never call x.concat(y) when you are not
  // certain that x is an Array (x could be a string with concat method).
  if (Array.isArray(current)) {
    if (Array.isArray(next)) {
      current.push.apply(current, next);
      return current;
    }
    current.push(next);
    return current;
  }

  if (Array.isArray(next)) {
    // A bit too dangerous to mutate `next`.
    return [current].concat(next);
  }

  return [current, next];
}

module.exports = accumulateInto;
},{"./reactProdInvariant":650,"fbjs/lib/invariant":402}],628:[function(require,module,exports){
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

'use strict';

var MOD = 65521;

// adler32 is not cryptographically strong, and is only used to sanity check that
// markup generated on the server matches the markup generated on the client.
// This implementation (a modified version of the SheetJS version) has been optimized
// for our use case, at the expense of conforming to the adler32 specification
// for non-ascii inputs.
function adler32(data) {
  var a = 1;
  var b = 0;
  var i = 0;
  var l = data.length;
  var m = l & ~0x3;
  while (i < m) {
    var n = Math.min(i + 4096, m);
    for (; i < n; i += 4) {
      b += (a += data.charCodeAt(i)) + (a += data.charCodeAt(i + 1)) + (a += data.charCodeAt(i + 2)) + (a += data.charCodeAt(i + 3));
    }
    a %= MOD;
    b %= MOD;
  }
  for (; i < l; i++) {
    b += a += data.charCodeAt(i);
  }
  a %= MOD;
  b %= MOD;
  return a | b << 16;
}

module.exports = adler32;
},{}],629:[function(require,module,exports){
(function (process){
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */

'use strict';

var _prodInvariant = require('./reactProdInvariant');

var ReactPropTypeLocationNames = require('./ReactPropTypeLocationNames');
var ReactPropTypesSecret = require('./ReactPropTypesSecret');

var invariant = require('fbjs/lib/invariant');
var warning = require('fbjs/lib/warning');

var ReactComponentTreeHook;

if (typeof process !== 'undefined' && process.env && "production" === 'test') {
  // Temporary hack.
  // Inline requires don't work well with Jest:
  // https://github.com/facebook/react/issues/7240
  // Remove the inline requires when we don't need them anymore:
  // https://github.com/facebook/react/pull/7178
  ReactComponentTreeHook = require('react/lib/ReactComponentTreeHook');
}

var loggedTypeFailures = {};

/**
 * Assert that the values match with the type specs.
 * Error messages are memorized and will only be shown once.
 *
 * @param {object} typeSpecs Map of name to a ReactPropType
 * @param {object} values Runtime values that need to be type-checked
 * @param {string} location e.g. "prop", "context", "child context"
 * @param {string} componentName Name of the component for error messages.
 * @param {?object} element The React element that is being type-checked
 * @param {?number} debugID The React component instance that is being type-checked
 * @private
 */
function checkReactTypeSpec(typeSpecs, values, location, componentName, element, debugID) {
  for (var typeSpecName in typeSpecs) {
    if (typeSpecs.hasOwnProperty(typeSpecName)) {
      var error;
      // Prop type validation may throw. In case they do, we don't want to
      // fail the render phase where it didn't fail before. So we log it.
      // After these have been cleaned up, we'll let them throw.
      try {
        // This is intentionally an invariant that gets caught. It's the same
        // behavior as without this statement except with a better message.
        !(typeof typeSpecs[typeSpecName] === 'function') ? "production" !== 'production' ? invariant(false, '%s: %s type `%s` is invalid; it must be a function, usually from React.PropTypes.', componentName || 'React class', ReactPropTypeLocationNames[location], typeSpecName) : _prodInvariant('84', componentName || 'React class', ReactPropTypeLocationNames[location], typeSpecName) : void 0;
        error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);
      } catch (ex) {
        error = ex;
      }
      "production" !== 'production' ? warning(!error || error instanceof Error, '%s: type specification of %s `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', ReactPropTypeLocationNames[location], typeSpecName, typeof error) : void 0;
      if (error instanceof Error && !(error.message in loggedTypeFailures)) {
        // Only monitor this failure once because there tends to be a lot of the
        // same error.
        loggedTypeFailures[error.message] = true;

        var componentStackInfo = '';

        if ("production" !== 'production') {
          if (!ReactComponentTreeHook) {
            ReactComponentTreeHook = require('react/lib/ReactComponentTreeHook');
          }
          if (debugID !== null) {
            componentStackInfo = ReactComponentTreeHook.getStackAddendumByID(debugID);
          } else if (element !== null) {
            componentStackInfo = ReactComponentTreeHook.getCurrentStackAddendum(element);
          }
        }

        "production" !== 'production' ? warning(false, 'Failed %s type: %s%s', location, error.message, componentStackInfo) : void 0;
      }
    }
  }
}

module.exports = checkReactTypeSpec;
}).call(this,require('_process'))
},{"./ReactPropTypeLocationNames":599,"./ReactPropTypesSecret":600,"./reactProdInvariant":650,"_process":490,"fbjs/lib/invariant":402,"fbjs/lib/warning":409,"react/lib/ReactComponentTreeHook":677}],630:[function(require,module,exports){
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */

/* globals MSApp */

'use strict';

/**
 * Create a function which has 'unsafe' privileges (required by windows8 apps)
 */

var createMicrosoftUnsafeLocalFunction = function (func) {
  if (typeof MSApp !== 'undefined' && MSApp.execUnsafeLocalFunction) {
    return function (arg0, arg1, arg2, arg3) {
      MSApp.execUnsafeLocalFunction(function () {
        return func(arg0, arg1, arg2, arg3);
      });
    };
  } else {
    return func;
  }
};

module.exports = createMicrosoftUnsafeLocalFunction;
},{}],631:[function(require,module,exports){
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */

'use strict';

var CSSProperty = require('./CSSProperty');
var warning = require('fbjs/lib/warning');

var isUnitlessNumber = CSSProperty.isUnitlessNumber;
var styleWarnings = {};

/**
 * Convert a value into the proper css writable value. The style name `name`
 * should be logical (no hyphens), as specified
 * in `CSSProperty.isUnitlessNumber`.
 *
 * @param {string} name CSS property name such as `topMargin`.
 * @param {*} value CSS property value such as `10px`.
 * @param {ReactDOMComponent} component
 * @return {string} Normalized style value with dimensions applied.
 */
function dangerousStyleValue(name, value, component, isCustomProperty) {
  // Note that we've removed escapeTextForBrowser() calls here since the
  // whole string will be escaped when the attribute is injected into
  // the markup. If you provide unsafe user data here they can inject
  // arbitrary CSS which may be problematic (I couldn't repro this):
  // https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet
  // http://www.thespanner.co.uk/2007/11/26/ultimate-xss-css-injection/
  // This is not an XSS hole but instead a potential CSS injection issue
  // which has lead to a greater discussion about how we're going to
  // trust URLs moving forward. See #2115901

  var isEmpty = value == null || typeof value === 'boolean' || value === '';
  if (isEmpty) {
    return '';
  }

  var isNonNumeric = isNaN(value);
  if (isCustomProperty || isNonNumeric || value === 0 || isUnitlessNumber.hasOwnProperty(name) && isUnitlessNumber[name]) {
    return '' + value; // cast to string
  }

  if (typeof value === 'string') {
    if ("production" !== 'production') {
      // Allow '0' to pass through without warning. 0 is already special and
      // doesn't require units, so we don't need to warn about it.
      if (component && value !== '0') {
        var owner = component._currentElement._owner;
        var ownerName = owner ? owner.getName() : null;
        if (ownerName && !styleWarnings[ownerName]) {
          styleWarnings[ownerName] = {};
        }
        var warned = false;
        if (ownerName) {
          var warnings = styleWarnings[ownerName];
          warned = warnings[name];
          if (!warned) {
            warnings[name] = true;
          }
        }
        if (!warned) {
          "production" !== 'production' ? warning(false, 'a `%s` tag (owner: `%s`) was passed a numeric string value ' + 'for CSS property `%s` (value: `%s`) which will be treated ' + 'as a unitless number in a future version of React.', component._currentElement.type, ownerName || 'unknown', name, value) : void 0;
        }
      }
    }
    value = value.trim();
  }
  return value + 'px';
}

module.exports = dangerousStyleValue;
},{"./CSSProperty":534,"fbjs/lib/warning":409}],632:[function(require,module,exports){
/**
 * Copyright (c) 2016-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * Based on the escape-html library, which is used under the MIT License below:
 *
 * Copyright (c) 2012-2013 TJ Holowaychuk
 * Copyright (c) 2015 Andreas Lubbe
 * Copyright (c) 2015 Tiancheng "Timothy" Gu
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * 'Software'), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
 * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 */

'use strict';

// code copied and modified from escape-html
/**
 * Module variables.
 * @private
 */

var matchHtmlRegExp = /["'&<>]/;

/**
 * Escape special characters in the given string of html.
 *
 * @param  {string} string The string to escape for inserting into HTML
 * @return {string}
 * @public
 */

function escapeHtml(string) {
  var str = '' + string;
  var match = matchHtmlRegExp.exec(str);

  if (!match) {
    return str;
  }

  var escape;
  var html = '';
  var index = 0;
  var lastIndex = 0;

  for (index = match.index; index < str.length; index++) {
    switch (str.charCodeAt(index)) {
      case 34:
        // "
        escape = '&quot;';
        break;
      case 38:
        // &
        escape = '&amp;';
        break;
      case 39:
        // '
        escape = '&#x27;'; // modified from escape-html; used to be '&#39'
        break;
      case 60:
        // <
        escape = '&lt;';
        break;
      case 62:
        // >
        escape = '&gt;';
        break;
      default:
        continue;
    }

    if (lastIndex !== index) {
      html += str.substring(lastIndex, index);
    }

    lastIndex = index + 1;
    html += escape;
  }

  return lastIndex !== index ? html + str.substring(lastIndex, index) : html;
}
// end code copied and modified from escape-html

/**
 * Escapes text to prevent scripting attacks.
 *
 * @param {*} text Text value to escape.
 * @return {string} An escaped string.
 */
function escapeTextContentForBrowser(text) {
  if (typeof text === 'boolean' || typeof text === 'number') {
    // this shortcircuit helps perf for types that we know will never have
    // special characters, especially given that this function is used often
    // for numeric dom ids.
    return '' + text;
  }
  return escapeHtml(text);
}

module.exports = escapeTextContentForBrowser;
},{}],633:[function(require,module,exports){
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */

'use strict';

var _prodInvariant = require('./reactProdInvariant');

var ReactCurrentOwner = require('react/lib/ReactCurrentOwner');
var ReactDOMComponentTree = require('./ReactDOMComponentTree');
var ReactInstanceMap = require('./ReactInstanceMap');

var getHostComponentFromComposite = require('./getHostComponentFromComposite');
var invariant = require('fbjs/lib/invariant');
var warning = require('fbjs/lib/warning');

/**
 * Returns the DOM node rendered by this element.
 *
 * See https://facebook.github.io/react/docs/top-level-api.html#reactdom.finddomnode
 *
 * @param {ReactComponent|DOMElement} componentOrElement
 * @return {?DOMElement} The root node of this element.
 */
function findDOMNode(componentOrElement) {
  if ("production" !== 'production') {
    var owner = ReactCurrentOwner.current;
    if (owner !== null) {
      "production" !== 'production' ? warning(owner._warnedAboutRefsInRender, '%s is accessing findDOMNode inside its render(). ' + 'render() should be a pure function of props and state. It should ' + 'never access something that requires stale data from the previous ' + 'render, such as refs. Move this logic to componentDidMount and ' + 'componentDidUpdate instead.', owner.getName() || 'A component') : void 0;
      owner._warnedAboutRefsInRender = true;
    }
  }
  if (componentOrElement == null) {
    return null;
  }
  if (componentOrElement.nodeType === 1) {
    return componentOrElement;
  }

  var inst = ReactInstanceMap.get(componentOrElement);
  if (inst) {
    inst = getHostComponentFromComposite(inst);
    return inst ? ReactDOMComponentTree.getNodeFromInstance(inst) : null;
  }

  if (typeof componentOrElement.render === 'function') {
    !false ? "production" !== 'production' ? invariant(false, 'findDOMNode was called on an unmounted component.') : _prodInvariant('44') : void 0;
  } else {
    !false ? "production" !== 'production' ? invariant(false, 'Element appears to be neither ReactComponent nor DOMNode (keys: %s)', Object.keys(componentOrElement)) : _prodInvariant('45', Object.keys(componentOrElement)) : void 0;
  }
}

module.exports = findDOMNode;
},{"./ReactDOMComponentTree":563,"./ReactInstanceMap":591,"./getHostComponentFromComposite":640,"./reactProdInvariant":650,"fbjs/lib/invariant":402,"fbjs/lib/warning":409,"react/lib/ReactCurrentOwner":678}],634:[function(require,module,exports){
(function (process){
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

'use strict';

var KeyEscapeUtils = require('./KeyEscapeUtils');
var traverseAllChildren = require('./traverseAllChildren');
var warning = require('fbjs/lib/warning');

var ReactComponentTreeHook;

if (typeof process !== 'undefined' && process.env && "production" === 'test') {
  // Temporary hack.
  // Inline requires don't work well with Jest:
  // https://github.com/facebook/react/issues/7240
  // Remove the inline requires when we don't need them anymore:
  // https://github.com/facebook/react/pull/7178
  ReactComponentTreeHook = require('react/lib/ReactComponentTreeHook');
}

/**
 * @param {function} traverseContext Context passed through traversal.
 * @param {?ReactComponent} child React child component.
 * @param {!string} name String name of key path to child.
 * @param {number=} selfDebugID Optional debugID of the current internal instance.
 */
function flattenSingleChildIntoContext(traverseContext, child, name, selfDebugID) {
  // We found a component instance.
  if (traverseContext && typeof traverseContext === 'object') {
    var result = traverseContext;
    var keyUnique = result[name] === undefined;
    if ("production" !== 'production') {
      if (!ReactComponentTreeHook) {
        ReactComponentTreeHook = require('react/lib/ReactComponentTreeHook');
      }
      if (!keyUnique) {
        "production" !== 'production' ? warning(false, 'flattenChildren(...): Encountered two children with the same key, ' + '`%s`. Child keys must be unique; when two children share a key, only ' + 'the first child will be used.%s', KeyEscapeUtils.unescape(name), ReactComponentTreeHook.getStackAddendumByID(selfDebugID)) : void 0;
      }
    }
    if (keyUnique && child != null) {
      result[name] = child;
    }
  }
}

/**
 * Flattens children that are typically specified as `props.children`. Any null
 * children will not be included in the resulting object.
 * @return {!object} flattened children keyed by name.
 */
function flattenChildren(children, selfDebugID) {
  if (children == null) {
    return children;
  }
  var result = {};

  if ("production" !== 'production') {
    traverseAllChildren(children, function (traverseContext, child, name) {
      return flattenSingleChildIntoContext(traverseContext, child, name, selfDebugID);
    }, result);
  } else {
    traverseAllChildren(children, flattenSingleChildIntoContext, result);
  }
  return result;
}

module.exports = flattenChildren;
}).call(this,require('_process'))
},{"./KeyEscapeUtils":552,"./traverseAllChildren":655,"_process":490,"fbjs/lib/warning":409,"react/lib/ReactComponentTreeHook":677}],635:[function(require,module,exports){
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

'use strict';

/**
 * @param {array} arr an "accumulation" of items which is either an Array or
 * a single item. Useful when paired with the `accumulate` module. This is a
 * simple utility that allows us to reason about a collection of items, but
 * handling the case when there is exactly one item (and we do not need to
 * allocate an array).
 */

function forEachAccumulated(arr, cb, scope) {
  if (Array.isArray(arr)) {
    arr.forEach(cb, scope);
  } else if (arr) {
    cb.call(scope, arr);
  }
}

module.exports = forEachAccumulated;
},{}],636:[function(require,module,exports){
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */

'use strict';

/**
 * `charCode` represents the actual "character code" and is safe to use with
 * `String.fromCharCode`. As such, only keys that correspond to printable
 * characters produce a valid `charCode`, the only exception to this is Enter.
 * The Tab-key is considered non-printable and does not have a `charCode`,
 * presumably because it does not produce a tab-character in browsers.
 *
 * @param {object} nativeEvent Native browser event.
 * @return {number} Normalized `charCode` property.
 */

function getEventCharCode(nativeEvent) {
  var charCode;
  var keyCode = nativeEvent.keyCode;

  if ('charCode' in nativeEvent) {
    charCode = nativeEvent.charCode;

    // FF does not set `charCode` for the Enter-key, check against `keyCode`.
    if (charCode === 0 && keyCode === 13) {
      charCode = 13;
    }
  } else {
    // IE8 does not implement `charCode`, but `keyCode` has the correct value.
    charCode = keyCode;
  }

  // Some non-printable keys are reported in `charCode`/`keyCode`, discard them.
  // Must not discard the (non-)printable Enter-key.
  if (charCode >= 32 || charCode === 13) {
    return charCode;
  }

  return 0;
}

module.exports = getEventCharCode;
},{}],637:[function(require,module,exports){
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */

'use strict';

var getEventCharCode = require('./getEventCharCode');

/**
 * Normalization of deprecated HTML5 `key` values
 * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names
 */
var normalizeKey = {
  Esc: 'Escape',
  Spacebar: ' ',
  Left: 'ArrowLeft',
  Up: 'ArrowUp',
  Right: 'ArrowRight',
  Down: 'ArrowDown',
  Del: 'Delete',
  Win: 'OS',
  Menu: 'ContextMenu',
  Apps: 'ContextMenu',
  Scroll: 'ScrollLock',
  MozPrintableKey: 'Unidentified'
};

/**
 * Translation from legacy `keyCode` to HTML5 `key`
 * Only special keys supported, all others depend on keyboard layout or browser
 * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names
 */
var translateToKey = {
  8: 'Backspace',
  9: 'Tab',
  12: 'Clear',
  13: 'Enter',
  16: 'Shift',
  17: 'Control',
  18: 'Alt',
  19: 'Pause',
  20: 'CapsLock',
  27: 'Escape',
  32: ' ',
  33: 'PageUp',
  34: 'PageDown',
  35: 'End',
  36: 'Home',
  37: 'ArrowLeft',
  38: 'ArrowUp',
  39: 'ArrowRight',
  40: 'ArrowDown',
  45: 'Insert',
  46: 'Delete',
  112: 'F1',
  113: 'F2',
  114: 'F3',
  115: 'F4',
  116: 'F5',
  117: 'F6',
  118: 'F7',
  119: 'F8',
  120: 'F9',
  121: 'F10',
  122: 'F11',
  123: 'F12',
  144: 'NumLock',
  145: 'ScrollLock',
  224: 'Meta'
};

/**
 * @param {object} nativeEvent Native browser event.
 * @return {string} Normalized `key` property.
 */
function getEventKey(nativeEvent) {
  if (nativeEvent.key) {
    // Normalize inconsistent values reported by browsers due to
    // implementations of a working draft specification.

    // FireFox implements `key` but returns `MozPrintableKey` for all
    // printable characters (normalized to `Unidentified`), ignore it.
    var key = normalizeKey[nativeEvent.key] || nativeEvent.key;
    if (key !== 'Unidentified') {
      return key;
    }
  }

  // Browser does not implement `key`, polyfill as much of it as we can.
  if (nativeEvent.type === 'keypress') {
    var charCode = getEventCharCode(nativeEvent);

    // The enter-key is technically both printable and non-printable and can
    // thus be captured by `keypress`, no other non-printable key should.
    return charCode === 13 ? 'Enter' : String.fromCharCode(charCode);
  }
  if (nativeEvent.type === 'keydown' || nativeEvent.type === 'keyup') {
    // While user keyboard layout determines the actual meaning of each
    // `keyCode` value, almost all function keys have a universal value.
    return translateToKey[nativeEvent.keyCode] || 'Unidentified';
  }
  return '';
}

module.exports = getEventKey;
},{"./getEventCharCode":636}],638:[function(require,module,exports){
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */

'use strict';

/**
 * Translation from modifier key to the associated property in the event.
 * @see http://www.w3.org/TR/DOM-Level-3-Events/#keys-Modifiers
 */

var modifierKeyToProp = {
  Alt: 'altKey',
  Control: 'ctrlKey',
  Meta: 'metaKey',
  Shift: 'shiftKey'
};

// IE8 does not implement getModifierState so we simply map it to the only
// modifier keys exposed by the event itself, does not support Lock-keys.
// Currently, all major browsers except Chrome seems to support Lock-keys.
function modifierStateGetter(keyArg) {
  var syntheticEvent = this;
  var nativeEvent = syntheticEvent.nativeEvent;
  if (nativeEvent.getModifierState) {
    return nativeEvent.getModifierState(keyArg);
  }
  var keyProp = modifierKeyToProp[keyArg];
  return keyProp ? !!nativeEvent[keyProp] : false;
}

function getEventModifierState(nativeEvent) {
  return modifierStateGetter;
}

module.exports = getEventModifierState;
},{}],639:[function(require,module,exports){
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */

'use strict';

/**
 * Gets the target node from a native browser event by accounting for
 * inconsistencies in browser DOM APIs.
 *
 * @param {object} nativeEvent Native browser event.
 * @return {DOMEventTarget} Target node.
 */

function getEventTarget(nativeEvent) {
  var target = nativeEvent.target || nativeEvent.srcElement || window;

  // Normalize SVG <use> element events #4963
  if (target.correspondingUseElement) {
    target = target.correspondingUseElement;
  }

  // Safari may fire events on text nodes (Node.TEXT_NODE is 3).
  // @see http://www.quirksmode.org/js/events_properties.html
  return target.nodeType === 3 ? target.parentNode : target;
}

module.exports = getEventTarget;
},{}],640:[function(require,module,exports){
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */

'use strict';

var ReactNodeTypes = require('./ReactNodeTypes');

function getHostComponentFromComposite(inst) {
  var type;

  while ((type = inst._renderedNodeType) === ReactNodeTypes.COMPOSITE) {
    inst = inst._renderedComponent;
  }

  if (type === ReactNodeTypes.HOST) {
    return inst._renderedComponent;
  } else if (type === ReactNodeTypes.EMPTY) {
    return null;
  }
}

module.exports = getHostComponentFromComposite;
},{"./ReactNodeTypes":597}],641:[function(require,module,exports){
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

'use strict';

/* global Symbol */

var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.

/**
 * Returns the iterator method function contained on the iterable object.
 *
 * Be sure to invoke the function with the iterable as context:
 *
 *     var iteratorFn = getIteratorFn(myIterable);
 *     if (iteratorFn) {
 *       var iterator = iteratorFn.call(myIterable);
 *       ...
 *     }
 *
 * @param {?object} maybeIterable
 * @return {?function}
 */
function getIteratorFn(maybeIterable) {
  var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
  if (typeof iteratorFn === 'function') {
    return iteratorFn;
  }
}

module.exports = getIteratorFn;
},{}],642:[function(require,module,exports){
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */

'use strict';

/**
 * Given any node return the first leaf node without children.
 *
 * @param {DOMElement|DOMTextNode} node
 * @return {DOMElement|DOMTextNode}
 */

function getLeafNode(node) {
  while (node && node.firstChild) {
    node = node.firstChild;
  }
  return node;
}

/**
 * Get the next sibling within a container. This will walk up the
 * DOM if a node's siblings have been exhausted.
 *
 * @param {DOMElement|DOMTextNode} node
 * @return {?DOMElement|DOMTextNode}
 */
function getSiblingNode(node) {
  while (node) {
    if (node.nextSibling) {
      return node.nextSibling;
    }
    node = node.parentNode;
  }
}

/**
 * Get object describing the nodes which contain characters at offset.
 *
 * @param {DOMElement|DOMTextNode} root
 * @param {number} offset
 * @return {?object}
 */
function getNodeForCharacterOffset(root, offset) {
  var node = getLeafNode(root);
  var nodeStart = 0;
  var nodeEnd = 0;

  while (node) {
    if (node.nodeType === 3) {
      nodeEnd = nodeStart + node.textContent.length;

      if (nodeStart <= offset && nodeEnd >= offset) {
        return {
          node: node,
          offset: offset - nodeStart
        };
      }

      nodeStart = nodeEnd;
    }

    node = getLeafNode(getSiblingNode(node));
  }
}

module.exports = getNodeForCharacterOffset;
},{}],643:[function(require,module,exports){
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */

'use strict';

var ExecutionEnvironment = require('fbjs/lib/ExecutionEnvironment');

var contentKey = null;

/**
 * Gets the key used to access text content on a DOM node.
 *
 * @return {?string} Key used to access text content.
 * @internal
 */
function getTextContentAccessor() {
  if (!contentKey && ExecutionEnvironment.canUseDOM) {
    // Prefer textContent to innerText because many browsers support both but
    // SVG <text> elements don't support innerText even when <div> does.
    contentKey = 'textContent' in document.documentElement ? 'textContent' : 'innerText';
  }
  return contentKey;
}

module.exports = getTextContentAccessor;
},{"fbjs/lib/ExecutionEnvironment":388}],644:[function(require,module,exports){
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */

'use strict';

var ExecutionEnvironment = require('fbjs/lib/ExecutionEnvironment');

/**
 * Generate a mapping of standard vendor prefixes using the defined style property and event name.
 *
 * @param {string} styleProp
 * @param {string} eventName
 * @returns {object}
 */
function makePrefixMap(styleProp, eventName) {
  var prefixes = {};

  prefixes[styleProp.toLowerCase()] = eventName.toLowerCase();
  prefixes['Webkit' + styleProp] = 'webkit' + eventName;
  prefixes['Moz' + styleProp] = 'moz' + eventName;
  prefixes['ms' + styleProp] = 'MS' + eventName;
  prefixes['O' + styleProp] = 'o' + eventName.toLowerCase();

  return prefixes;
}

/**
 * A list of event names to a configurable list of vendor prefixes.
 */
var vendorPrefixes = {
  animationend: makePrefixMap('Animation', 'AnimationEnd'),
  animationiteration: makePrefixMap('Animation', 'AnimationIteration'),
  animationstart: makePrefixMap('Animation', 'AnimationStart'),
  transitionend: makePrefixMap('Transition', 'TransitionEnd')
};

/**
 * Event names that have already been detected and prefixed (if applicable).
 */
var prefixedEventNames = {};

/**
 * Element to check for prefixes on.
 */
var style = {};

/**
 * Bootstrap if a DOM exists.
 */
if (ExecutionEnvironment.canUseDOM) {
  style = document.createElement('div').style;

  // On some platforms, in particular some releases of Android 4.x,
  // the un-prefixed "animation" and "transition" properties are defined on the
  // style object but the events that fire will still be prefixed, so we need
  // to check if the un-prefixed events are usable, and if not remove them from the map.
  if (!('AnimationEvent' in window)) {
    delete vendorPrefixes.animationend.animation;
    delete vendorPrefixes.animationiteration.animation;
    delete vendorPrefixes.animationstart.animation;
  }

  // Same as above
  if (!('TransitionEvent' in window)) {
    delete vendorPrefixes.transitionend.transition;
  }
}

/**
 * Attempts to determine the correct vendor prefixed event name.
 *
 * @param {string} eventName
 * @returns {string}
 */
function getVendorPrefixedEventName(eventName) {
  if (prefixedEventNames[eventName]) {
    return prefixedEventNames[eventName];
  } else if (!vendorPrefixes[eventName]) {
    return eventName;
  }

  var prefixMap = vendorPrefixes[eventName];

  for (var styleProp in prefixMap) {
    if (prefixMap.hasOwnProperty(styleProp) && styleProp in style) {
      return prefixedEventNames[eventName] = prefixMap[styleProp];
    }
  }

  return '';
}

module.exports = getVendorPrefixedEventName;
},{"fbjs/lib/ExecutionEnvironment":388}],645:[function(require,module,exports){
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */

'use strict';

var ReactDOMComponentTree = require('./ReactDOMComponentTree');

function isCheckable(elem) {
  var type = elem.type;
  var nodeName = elem.nodeName;
  return nodeName && nodeName.toLowerCase() === 'input' && (type === 'checkbox' || type === 'radio');
}

function getTracker(inst) {
  return inst._wrapperState.valueTracker;
}

function attachTracker(inst, tracker) {
  inst._wrapperState.valueTracker = tracker;
}

function detachTracker(inst) {
  inst._wrapperState.valueTracker = null;
}

function getValueFromNode(node) {
  var value;
  if (node) {
    value = isCheckable(node) ? '' + node.checked : node.value;
  }
  return value;
}

var inputValueTracking = {
  // exposed for testing
  _getTrackerFromNode: function (node) {
    return getTracker(ReactDOMComponentTree.getInstanceFromNode(node));
  },


  track: function (inst) {
    if (getTracker(inst)) {
      return;
    }

    var node = ReactDOMComponentTree.getNodeFromInstance(inst);
    var valueField = isCheckable(node) ? 'checked' : 'value';
    var descriptor = Object.getOwnPropertyDescriptor(node.constructor.prototype, valueField);

    var currentValue = '' + node[valueField];

    // if someone has already defined a value or Safari, then bail
    // and don't track value will cause over reporting of changes,
    // but it's better then a hard failure
    // (needed for certain tests that spyOn input values and Safari)
    if (node.hasOwnProperty(valueField) || typeof descriptor.get !== 'function' || typeof descriptor.set !== 'function') {
      return;
    }

    Object.defineProperty(node, valueField, {
      enumerable: descriptor.enumerable,
      configurable: true,
      get: function () {
        return descriptor.get.call(this);
      },
      set: function (value) {
        currentValue = '' + value;
        descriptor.set.call(this, value);
      }
    });

    attachTracker(inst, {
      getValue: function () {
        return currentValue;
      },
      setValue: function (value) {
        currentValue = '' + value;
      },
      stopTracking: function () {
        detachTracker(inst);
        delete node[valueField];
      }
    });
  },

  updateValueIfChanged: function (inst) {
    if (!inst) {
      return false;
    }
    var tracker = getTracker(inst);

    if (!tracker) {
      inputValueTracking.track(inst);
      return true;
    }

    var lastValue = tracker.getValue();
    var nextValue = getValueFromNode(ReactDOMComponentTree.getNodeFromInstance(inst));

    if (nextValue !== lastValue) {
      tracker.setValue(nextValue);
      return true;
    }

    return false;
  },
  stopTracking: function (inst) {
    var tracker = getTracker(inst);
    if (tracker) {
      tracker.stopTracking();
    }
  }
};

module.exports = inputValueTracking;
},{"./ReactDOMComponentTree":563}],646:[function(require,module,exports){
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */

'use strict';

var _prodInvariant = require('./reactProdInvariant'),
    _assign = require('object-assign');

var ReactCompositeComponent = require('./ReactCompositeComponent');
var ReactEmptyComponent = require('./ReactEmptyComponent');
var ReactHostComponent = require('./ReactHostComponent');

var getNextDebugID = require('react/lib/getNextDebugID');
var invariant = require('fbjs/lib/invariant');
var warning = require('fbjs/lib/warning');

// To avoid a cyclic dependency, we create the final class in this module
var ReactCompositeComponentWrapper = function (element) {
  this.construct(element);
};

function getDeclarationErrorAddendum(owner) {
  if (owner) {
    var name = owner.getName();
    if (name) {
      return ' Check the render method of `' + name + '`.';
    }
  }
  return '';
}

/**
 * Check if the type reference is a known internal type. I.e. not a user
 * provided composite type.
 *
 * @param {function} type
 * @return {boolean} Returns true if this is a valid internal type.
 */
function isInternalComponentType(type) {
  return typeof type === 'function' && typeof type.prototype !== 'undefined' && typeof type.prototype.mountComponent === 'function' && typeof type.prototype.receiveComponent === 'function';
}

/**
 * Given a ReactNode, create an instance that will actually be mounted.
 *
 * @param {ReactNode} node
 * @param {boolean} shouldHaveDebugID
 * @return {object} A new instance of the element's constructor.
 * @protected
 */
function instantiateReactComponent(node, shouldHaveDebugID) {
  var instance;

  if (node === null || node === false) {
    instance = ReactEmptyComponent.create(instantiateReactComponent);
  } else if (typeof node === 'object') {
    var element = node;
    var type = element.type;
    if (typeof type !== 'function' && typeof type !== 'string') {
      var info = '';
      if ("production" !== 'production') {
        if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {
          info += ' You likely forgot to export your component from the file ' + "it's defined in.";
        }
      }
      info += getDeclarationErrorAddendum(element._owner);
      !false ? "production" !== 'production' ? invariant(false, 'Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s', type == null ? type : typeof type, info) : _prodInvariant('130', type == null ? type : typeof type, info) : void 0;
    }

    // Special case string values
    if (typeof element.type === 'string') {
      instance = ReactHostComponent.createInternalComponent(element);
    } else if (isInternalComponentType(element.type)) {
      // This is temporarily available for custom components that are not string
      // representations. I.e. ART. Once those are updated to use the string
      // representation, we can drop this code path.
      instance = new element.type(element);

      // We renamed this. Allow the old name for compat. :(
      if (!instance.getHostNode) {
        instance.getHostNode = instance.getNativeNode;
      }
    } else {
      instance = new ReactCompositeComponentWrapper(element);
    }
  } else if (typeof node === 'string' || typeof node === 'number') {
    instance = ReactHostComponent.createInstanceForText(node);
  } else {
    !false ? "production" !== 'production' ? invariant(false, 'Encountered invalid React node of type %s', typeof node) : _prodInvariant('131', typeof node) : void 0;
  }

  if ("production" !== 'production') {
    "production" !== 'production' ? warning(typeof instance.mountComponent === 'function' && typeof instance.receiveComponent === 'function' && typeof instance.getHostNode === 'function' && typeof instance.unmountComponent === 'function', 'Only React Components can be mounted.') : void 0;
  }

  // These two fields are used by the DOM and ART diffing algorithms
  // respectively. Instead of using expandos on components, we should be
  // storing the state needed by the diffing algorithms elsewhere.
  instance._mountIndex = 0;
  instance._mountImage = null;

  if ("production" !== 'production') {
    instance._debugID = shouldHaveDebugID ? getNextDebugID() : 0;
  }

  // Internal instances should fully constructed at this point, so they should
  // not get any new fields added to them at this point.
  if ("production" !== 'production') {
    if (Object.preventExtensions) {
      Object.preventExtensions(instance);
    }
  }

  return instance;
}

_assign(ReactCompositeComponentWrapper.prototype, ReactCompositeComponent, {
  _instantiateReactComponent: instantiateReactComponent
});

module.exports = instantiateReactComponent;
},{"./ReactCompositeComponent":559,"./ReactEmptyComponent":582,"./ReactHostComponent":587,"./reactProdInvariant":650,"fbjs/lib/invariant":402,"fbjs/lib/warning":409,"object-assign":489,"react/lib/getNextDebugID":692}],647:[function(require,module,exports){
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */

'use strict';

var ExecutionEnvironment = require('fbjs/lib/ExecutionEnvironment');

var useHasFeature;
if (ExecutionEnvironment.canUseDOM) {
  useHasFeature = document.implementation && document.implementation.hasFeature &&
  // always returns true in newer browsers as per the standard.
  // @see http://dom.spec.whatwg.org/#dom-domimplementation-hasfeature
  document.implementation.hasFeature('', '') !== true;
}

/**
 * Checks if an event is supported in the current execution environment.
 *
 * NOTE: This will not work correctly for non-generic events such as `change`,
 * `reset`, `load`, `error`, and `select`.
 *
 * Borrows from Modernizr.
 *
 * @param {string} eventNameSuffix Event name, e.g. "click".
 * @param {?boolean} capture Check if the capture phase is supported.
 * @return {boolean} True if the event is supported.
 * @internal
 * @license Modernizr 3.0.0pre (Custom Build) | MIT
 */
function isEventSupported(eventNameSuffix, capture) {
  if (!ExecutionEnvironment.canUseDOM || capture && !('addEventListener' in document)) {
    return false;
  }

  var eventName = 'on' + eventNameSuffix;
  var isSupported = eventName in document;

  if (!isSupported) {
    var element = document.createElement('div');
    element.setAttribute(eventName, 'return;');
    isSupported = typeof element[eventName] === 'function';
  }

  if (!isSupported && useHasFeature && eventNameSuffix === 'wheel') {
    // This is the only way to test support for the `wheel` event in IE9+.
    isSupported = document.implementation.hasFeature('Events.wheel', '3.0');
  }

  return isSupported;
}

module.exports = isEventSupported;
},{"fbjs/lib/ExecutionEnvironment":388}],648:[function(require,module,exports){
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

'use strict';

/**
 * @see http://www.whatwg.org/specs/web-apps/current-work/multipage/the-input-element.html#input-type-attr-summary
 */

var supportedInputTypes = {
  color: true,
  date: true,
  datetime: true,
  'datetime-local': true,
  email: true,
  month: true,
  number: true,
  password: true,
  range: true,
  search: true,
  tel: true,
  text: true,
  time: true,
  url: true,
  week: true
};

function isTextInputElement(elem) {
  var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();

  if (nodeName === 'input') {
    return !!supportedInputTypes[elem.type];
  }

  if (nodeName === 'textarea') {
    return true;
  }

  return false;
}

module.exports = isTextInputElement;
},{}],649:[function(require,module,exports){
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */

'use strict';

var escapeTextContentForBrowser = require('./escapeTextContentForBrowser');

/**
 * Escapes attribute value to prevent scripting attacks.
 *
 * @param {*} value Value to escape.
 * @return {string} An escaped string.
 */
function quoteAttributeValueForBrowser(value) {
  return '"' + escapeTextContentForBrowser(value) + '"';
}

module.exports = quoteAttributeValueForBrowser;
},{"./escapeTextContentForBrowser":632}],650:[function(require,module,exports){
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
'use strict';

/**
 * WARNING: DO NOT manually require this module.
 * This is a replacement for `invariant(...)` used by the error code system
 * and will _only_ be required by the corresponding babel pass.
 * It always throws.
 */

function reactProdInvariant(code) {
  var argCount = arguments.length - 1;

  var message = 'Minified React error #' + code + '; visit ' + 'http://facebook.github.io/react/docs/error-decoder.html?invariant=' + code;

  for (var argIdx = 0; argIdx < argCount; argIdx++) {
    message += '&args[]=' + encodeURIComponent(arguments[argIdx + 1]);
  }

  message += ' for the full message or use the non-minified dev environment' + ' for full errors and additional helpful warnings.';

  var error = new Error(message);
  error.name = 'Invariant Violation';
  error.framesToPop = 1; // we don't care about reactProdInvariant's own frame

  throw error;
}

module.exports = reactProdInvariant;
},{}],651:[function(require,module,exports){
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */

'use strict';

var ReactMount = require('./ReactMount');

module.exports = ReactMount.renderSubtreeIntoContainer;
},{"./ReactMount":595}],652:[function(require,module,exports){
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */

'use strict';

var ExecutionEnvironment = require('fbjs/lib/ExecutionEnvironment');
var DOMNamespaces = require('./DOMNamespaces');

var WHITESPACE_TEST = /^[ \r\n\t\f]/;
var NONVISIBLE_TEST = /<(!--|link|noscript|meta|script|style)[ \r\n\t\f\/>]/;

var createMicrosoftUnsafeLocalFunction = require('./createMicrosoftUnsafeLocalFunction');

// SVG temp container for IE lacking innerHTML
var reusableSVGContainer;

/**
 * Set the innerHTML property of a node, ensuring that whitespace is preserved
 * even in IE8.
 *
 * @param {DOMElement} node
 * @param {string} html
 * @internal
 */
var setInnerHTML = createMicrosoftUnsafeLocalFunction(function (node, html) {
  // IE does not have innerHTML for SVG nodes, so instead we inject the
  // new markup in a temp node and then move the child nodes across into
  // the target node
  if (node.namespaceURI === DOMNamespaces.svg && !('innerHTML' in node)) {
    reusableSVGContainer = reusableSVGContainer || document.createElement('div');
    reusableSVGContainer.innerHTML = '<svg>' + html + '</svg>';
    var svgNode = reusableSVGContainer.firstChild;
    while (svgNode.firstChild) {
      node.appendChild(svgNode.firstChild);
    }
  } else {
    node.innerHTML = html;
  }
});

if (ExecutionEnvironment.canUseDOM) {
  // IE8: When updating a just created node with innerHTML only leading
  // whitespace is removed. When updating an existing node with innerHTML
  // whitespace in root TextNodes is also collapsed.
  // @see quirksmode.org/bugreports/archives/2004/11/innerhtml_and_t.html

  // Feature detection; only IE8 is known to behave improperly like this.
  var testElement = document.createElement('div');
  testElement.innerHTML = ' ';
  if (testElement.innerHTML === '') {
    setInnerHTML = function (node, html) {
      // Magic theory: IE8 supposedly differentiates between added and updated
      // nodes when processing innerHTML, innerHTML on updated nodes suffers
      // from worse whitespace behavior. Re-adding a node like this triggers
      // the initial and more favorable whitespace behavior.
      // TODO: What to do on a detached node?
      if (node.parentNode) {
        node.parentNode.replaceChild(node, node);
      }

      // We also implement a workaround for non-visible tags disappearing into
      // thin air on IE8, this only happens if there is no visible text
      // in-front of the non-visible tags. Piggyback on the whitespace fix
      // and simply check if any non-visible tags appear in the source.
      if (WHITESPACE_TEST.test(html) || html[0] === '<' && NONVISIBLE_TEST.test(html)) {
        // Recover leading whitespace by temporarily prepending any character.
        // \uFEFF has the potential advantage of being zero-width/invisible.
        // UglifyJS drops U+FEFF chars when parsing, so use String.fromCharCode
        // in hopes that this is preserved even if "\uFEFF" is transformed to
        // the actual Unicode character (by Babel, for example).
        // https://github.com/mishoo/UglifyJS2/blob/v2.4.20/lib/parse.js#L216
        node.innerHTML = String.fromCharCode(0xfeff) + html;

        // deleteData leaves an empty `TextNode` which offsets the index of all
        // children. Definitely want to avoid this.
        var textNode = node.firstChild;
        if (textNode.data.length === 1) {
          node.removeChild(textNode);
        } else {
          textNode.deleteData(0, 1);
        }
      } else {
        node.innerHTML = html;
      }
    };
  }
  testElement = null;
}

module.exports = setInnerHTML;
},{"./DOMNamespaces":540,"./createMicrosoftUnsafeLocalFunction":630,"fbjs/lib/ExecutionEnvironment":388}],653:[function(require,module,exports){
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */

'use strict';

var ExecutionEnvironment = require('fbjs/lib/ExecutionEnvironment');
var escapeTextContentForBrowser = require('./escapeTextContentForBrowser');
var setInnerHTML = require('./setInnerHTML');

/**
 * Set the textContent property of a node, ensuring that whitespace is preserved
 * even in IE8. innerText is a poor substitute for textContent and, among many
 * issues, inserts <br> instead of the literal newline chars. innerHTML behaves
 * as it should.
 *
 * @param {DOMElement} node
 * @param {string} text
 * @internal
 */
var setTextContent = function (node, text) {
  if (text) {
    var firstChild = node.firstChild;

    if (firstChild && firstChild === node.lastChild && firstChild.nodeType === 3) {
      firstChild.nodeValue = text;
      return;
    }
  }
  node.textContent = text;
};

if (ExecutionEnvironment.canUseDOM) {
  if (!('textContent' in document.documentElement)) {
    setTextContent = function (node, text) {
      if (node.nodeType === 3) {
        node.nodeValue = text;
        return;
      }
      setInnerHTML(node, escapeTextContentForBrowser(text));
    };
  }
}

module.exports = setTextContent;
},{"./escapeTextContentForBrowser":632,"./setInnerHTML":652,"fbjs/lib/ExecutionEnvironment":388}],654:[function(require,module,exports){
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */

'use strict';

/**
 * Given a `prevElement` and `nextElement`, determines if the existing
 * instance should be updated as opposed to being destroyed or replaced by a new
 * instance. Both arguments are elements. This ensures that this logic can
 * operate on stateless trees without any backing instance.
 *
 * @param {?object} prevElement
 * @param {?object} nextElement
 * @return {boolean} True if the existing instance should be updated.
 * @protected
 */

function shouldUpdateReactComponent(prevElement, nextElement) {
  var prevEmpty = prevElement === null || prevElement === false;
  var nextEmpty = nextElement === null || nextElement === false;
  if (prevEmpty || nextEmpty) {
    return prevEmpty === nextEmpty;
  }

  var prevType = typeof prevElement;
  var nextType = typeof nextElement;
  if (prevType === 'string' || prevType === 'number') {
    return nextType === 'string' || nextType === 'number';
  } else {
    return nextType === 'object' && prevElement.type === nextElement.type && prevElement.key === nextElement.key;
  }
}

module.exports = shouldUpdateReactComponent;
},{}],655:[function(require,module,exports){
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */

'use strict';

var _prodInvariant = require('./reactProdInvariant');

var ReactCurrentOwner = require('react/lib/ReactCurrentOwner');
var REACT_ELEMENT_TYPE = require('./ReactElementSymbol');

var getIteratorFn = require('./getIteratorFn');
var invariant = require('fbjs/lib/invariant');
var KeyEscapeUtils = require('./KeyEscapeUtils');
var warning = require('fbjs/lib/warning');

var SEPARATOR = '.';
var SUBSEPARATOR = ':';

/**
 * This is inlined from ReactElement since this file is shared between
 * isomorphic and renderers. We could extract this to a
 *
 */

/**
 * TODO: Test that a single child and an array with one item have the same key
 * pattern.
 */

var didWarnAboutMaps = false;

/**
 * Generate a key string that identifies a component within a set.
 *
 * @param {*} component A component that could contain a manual key.
 * @param {number} index Index that is used if a manual key is not provided.
 * @return {string}
 */
function getComponentKey(component, index) {
  // Do some typechecking here since we call this blindly. We want to ensure
  // that we don't block potential future ES APIs.
  if (component && typeof component === 'object' && component.key != null) {
    // Explicit key
    return KeyEscapeUtils.escape(component.key);
  }
  // Implicit key determined by the index in the set
  return index.toString(36);
}

/**
 * @param {?*} children Children tree container.
 * @param {!string} nameSoFar Name of the key path so far.
 * @param {!function} callback Callback to invoke with each child found.
 * @param {?*} traverseContext Used to pass information throughout the traversal
 * process.
 * @return {!number} The number of children in this subtree.
 */
function traverseAllChildrenImpl(children, nameSoFar, callback, traverseContext) {
  var type = typeof children;

  if (type === 'undefined' || type === 'boolean') {
    // All of the above are perceived as null.
    children = null;
  }

  if (children === null || type === 'string' || type === 'number' ||
  // The following is inlined from ReactElement. This means we can optimize
  // some checks. React Fiber also inlines this logic for similar purposes.
  type === 'object' && children.$$typeof === REACT_ELEMENT_TYPE) {
    callback(traverseContext, children,
    // If it's the only child, treat the name as if it was wrapped in an array
    // so that it's consistent if the number of children grows.
    nameSoFar === '' ? SEPARATOR + getComponentKey(children, 0) : nameSoFar);
    return 1;
  }

  var child;
  var nextName;
  var subtreeCount = 0; // Count of children found in the current subtree.
  var nextNamePrefix = nameSoFar === '' ? SEPARATOR : nameSoFar + SUBSEPARATOR;

  if (Array.isArray(children)) {
    for (var i = 0; i < children.length; i++) {
      child = children[i];
      nextName = nextNamePrefix + getComponentKey(child, i);
      subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
    }
  } else {
    var iteratorFn = getIteratorFn(children);
    if (iteratorFn) {
      var iterator = iteratorFn.call(children);
      var step;
      if (iteratorFn !== children.entries) {
        var ii = 0;
        while (!(step = iterator.next()).done) {
          child = step.value;
          nextName = nextNamePrefix + getComponentKey(child, ii++);
          subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
        }
      } else {
        if ("production" !== 'production') {
          var mapsAsChildrenAddendum = '';
          if (ReactCurrentOwner.current) {
            var mapsAsChildrenOwnerName = ReactCurrentOwner.current.getName();
            if (mapsAsChildrenOwnerName) {
              mapsAsChildrenAddendum = ' Check the render method of `' + mapsAsChildrenOwnerName + '`.';
            }
          }
          "production" !== 'production' ? warning(didWarnAboutMaps, 'Using Maps as children is not yet fully supported. It is an ' + 'experimental feature that might be removed. Convert it to a ' + 'sequence / iterable of keyed ReactElements instead.%s', mapsAsChildrenAddendum) : void 0;
          didWarnAboutMaps = true;
        }
        // Iterator will provide entry [k,v] tuples rather than values.
        while (!(step = iterator.next()).done) {
          var entry = step.value;
          if (entry) {
            child = entry[1];
            nextName = nextNamePrefix + KeyEscapeUtils.escape(entry[0]) + SUBSEPARATOR + getComponentKey(child, 0);
            subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
          }
        }
      }
    } else if (type === 'object') {
      var addendum = '';
      if ("production" !== 'production') {
        addendum = ' If you meant to render a collection of children, use an array ' + 'instead or wrap the object using createFragment(object) from the ' + 'React add-ons.';
        if (children._isReactElement) {
          addendum = " It looks like you're using an element created by a different " + 'version of React. Make sure to use only one copy of React.';
        }
        if (ReactCurrentOwner.current) {
          var name = ReactCurrentOwner.current.getName();
          if (name) {
            addendum += ' Check the render method of `' + name + '`.';
          }
        }
      }
      var childrenString = String(children);
      !false ? "production" !== 'production' ? invariant(false, 'Objects are not valid as a React child (found: %s).%s', childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString, addendum) : _prodInvariant('31', childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString, addendum) : void 0;
    }
  }

  return subtreeCount;
}

/**
 * Traverses children that are typically specified as `props.children`, but
 * might also be specified through attributes:
 *
 * - `traverseAllChildren(this.props.children, ...)`
 * - `traverseAllChildren(this.props.leftPanelChildren, ...)`
 *
 * The `traverseContext` is an optional argument that is passed through the
 * entire traversal. It can be used to store accumulations or anything else that
 * the callback might find relevant.
 *
 * @param {?*} children Children tree object.
 * @param {!function} callback To invoke upon traversing each child.
 * @param {?*} traverseContext Context for traversal.
 * @return {!number} The number of children in this subtree.
 */
function traverseAllChildren(children, callback, traverseContext) {
  if (children == null) {
    return 0;
  }

  return traverseAllChildrenImpl(children, '', callback, traverseContext);
}

module.exports = traverseAllChildren;
},{"./KeyEscapeUtils":552,"./ReactElementSymbol":581,"./getIteratorFn":641,"./reactProdInvariant":650,"fbjs/lib/invariant":402,"fbjs/lib/warning":409,"react/lib/ReactCurrentOwner":678}],656:[function(require,module,exports){
/**
 * Copyright (c) 2015-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */

'use strict';

var _assign = require('object-assign');

var emptyFunction = require('fbjs/lib/emptyFunction');
var warning = require('fbjs/lib/warning');

var validateDOMNesting = emptyFunction;

if ("production" !== 'production') {
  // This validation code was written based on the HTML5 parsing spec:
  // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-scope
  //
  // Note: this does not catch all invalid nesting, nor does it try to (as it's
  // not clear what practical benefit doing so provides); instead, we warn only
  // for cases where the parser will give a parse tree differing from what React
  // intended. For example, <b><div></div></b> is invalid but we don't warn
  // because it still parses correctly; we do warn for other cases like nested
  // <p> tags where the beginning of the second element implicitly closes the
  // first, causing a confusing mess.

  // https://html.spec.whatwg.org/multipage/syntax.html#special
  var specialTags = ['address', 'applet', 'area', 'article', 'aside', 'base', 'basefont', 'bgsound', 'blockquote', 'body', 'br', 'button', 'caption', 'center', 'col', 'colgroup', 'dd', 'details', 'dir', 'div', 'dl', 'dt', 'embed', 'fieldset', 'figcaption', 'figure', 'footer', 'form', 'frame', 'frameset', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'html', 'iframe', 'img', 'input', 'isindex', 'li', 'link', 'listing', 'main', 'marquee', 'menu', 'menuitem', 'meta', 'nav', 'noembed', 'noframes', 'noscript', 'object', 'ol', 'p', 'param', 'plaintext', 'pre', 'script', 'section', 'select', 'source', 'style', 'summary', 'table', 'tbody', 'td', 'template', 'textarea', 'tfoot', 'th', 'thead', 'title', 'tr', 'track', 'ul', 'wbr', 'xmp'];

  // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-scope
  var inScopeTags = ['applet', 'caption', 'html', 'table', 'td', 'th', 'marquee', 'object', 'template',

  // https://html.spec.whatwg.org/multipage/syntax.html#html-integration-point
  // TODO: Distinguish by namespace here -- for <title>, including it here
  // errs on the side of fewer warnings
  'foreignObject', 'desc', 'title'];

  // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-button-scope
  var buttonScopeTags = inScopeTags.concat(['button']);

  // https://html.spec.whatwg.org/multipage/syntax.html#generate-implied-end-tags
  var impliedEndTags = ['dd', 'dt', 'li', 'option', 'optgroup', 'p', 'rp', 'rt'];

  var emptyAncestorInfo = {
    current: null,

    formTag: null,
    aTagInScope: null,
    buttonTagInScope: null,
    nobrTagInScope: null,
    pTagInButtonScope: null,

    listItemTagAutoclosing: null,
    dlItemTagAutoclosing: null
  };

  var updatedAncestorInfo = function (oldInfo, tag, instance) {
    var ancestorInfo = _assign({}, oldInfo || emptyAncestorInfo);
    var info = { tag: tag, instance: instance };

    if (inScopeTags.indexOf(tag) !== -1) {
      ancestorInfo.aTagInScope = null;
      ancestorInfo.buttonTagInScope = null;
      ancestorInfo.nobrTagInScope = null;
    }
    if (buttonScopeTags.indexOf(tag) !== -1) {
      ancestorInfo.pTagInButtonScope = null;
    }

    // See rules for 'li', 'dd', 'dt' start tags in
    // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody
    if (specialTags.indexOf(tag) !== -1 && tag !== 'address' && tag !== 'div' && tag !== 'p') {
      ancestorInfo.listItemTagAutoclosing = null;
      ancestorInfo.dlItemTagAutoclosing = null;
    }

    ancestorInfo.current = info;

    if (tag === 'form') {
      ancestorInfo.formTag = info;
    }
    if (tag === 'a') {
      ancestorInfo.aTagInScope = info;
    }
    if (tag === 'button') {
      ancestorInfo.buttonTagInScope = info;
    }
    if (tag === 'nobr') {
      ancestorInfo.nobrTagInScope = info;
    }
    if (tag === 'p') {
      ancestorInfo.pTagInButtonScope = info;
    }
    if (tag === 'li') {
      ancestorInfo.listItemTagAutoclosing = info;
    }
    if (tag === 'dd' || tag === 'dt') {
      ancestorInfo.dlItemTagAutoclosing = info;
    }

    return ancestorInfo;
  };

  /**
   * Returns whether
   */
  var isTagValidWithParent = function (tag, parentTag) {
    // First, let's check if we're in an unusual parsing mode...
    switch (parentTag) {
      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inselect
      case 'select':
        return tag === 'option' || tag === 'optgroup' || tag === '#text';
      case 'optgroup':
        return tag === 'option' || tag === '#text';
      // Strictly speaking, seeing an <option> doesn't mean we're in a <select>
      // but
      case 'option':
        return tag === '#text';
      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intd
      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incaption
      // No special behavior since these rules fall back to "in body" mode for
      // all except special table nodes which cause bad parsing behavior anyway.

      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intr
      case 'tr':
        return tag === 'th' || tag === 'td' || tag === 'style' || tag === 'script' || tag === 'template';
      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intbody
      case 'tbody':
      case 'thead':
      case 'tfoot':
        return tag === 'tr' || tag === 'style' || tag === 'script' || tag === 'template';
      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incolgroup
      case 'colgroup':
        return tag === 'col' || tag === 'template';
      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intable
      case 'table':
        return tag === 'caption' || tag === 'colgroup' || tag === 'tbody' || tag === 'tfoot' || tag === 'thead' || tag === 'style' || tag === 'script' || tag === 'template';
      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inhead
      case 'head':
        return tag === 'base' || tag === 'basefont' || tag === 'bgsound' || tag === 'link' || tag === 'meta' || tag === 'title' || tag === 'noscript' || tag === 'noframes' || tag === 'style' || tag === 'script' || tag === 'template';
      // https://html.spec.whatwg.org/multipage/semantics.html#the-html-element
      case 'html':
        return tag === 'head' || tag === 'body';
      case '#document':
        return tag === 'html';
    }

    // Probably in the "in body" parsing mode, so we outlaw only tag combos
    // where the parsing rules cause implicit opens or closes to be added.
    // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody
    switch (tag) {
      case 'h1':
      case 'h2':
      case 'h3':
      case 'h4':
      case 'h5':
      case 'h6':
        return parentTag !== 'h1' && parentTag !== 'h2' && parentTag !== 'h3' && parentTag !== 'h4' && parentTag !== 'h5' && parentTag !== 'h6';

      case 'rp':
      case 'rt':
        return impliedEndTags.indexOf(parentTag) === -1;

      case 'body':
      case 'caption':
      case 'col':
      case 'colgroup':
      case 'frame':
      case 'head':
      case 'html':
      case 'tbody':
      case 'td':
      case 'tfoot':
      case 'th':
      case 'thead':
      case 'tr':
        // These tags are only valid with a few parents that have special child
        // parsing rules -- if we're down here, then none of those matched and
        // so we allow it only if we don't know what the parent is, as all other
        // cases are invalid.
        return parentTag == null;
    }

    return true;
  };

  /**
   * Returns whether
   */
  var findInvalidAncestorForTag = function (tag, ancestorInfo) {
    switch (tag) {
      case 'address':
      case 'article':
      case 'aside':
      case 'blockquote':
      case 'center':
      case 'details':
      case 'dialog':
      case 'dir':
      case 'div':
      case 'dl':
      case 'fieldset':
      case 'figcaption':
      case 'figure':
      case 'footer':
      case 'header':
      case 'hgroup':
      case 'main':
      case 'menu':
      case 'nav':
      case 'ol':
      case 'p':
      case 'section':
      case 'summary':
      case 'ul':
      case 'pre':
      case 'listing':
      case 'table':
      case 'hr':
      case 'xmp':
      case 'h1':
      case 'h2':
      case 'h3':
      case 'h4':
      case 'h5':
      case 'h6':
        return ancestorInfo.pTagInButtonScope;

      case 'form':
        return ancestorInfo.formTag || ancestorInfo.pTagInButtonScope;

      case 'li':
        return ancestorInfo.listItemTagAutoclosing;

      case 'dd':
      case 'dt':
        return ancestorInfo.dlItemTagAutoclosing;

      case 'button':
        return ancestorInfo.buttonTagInScope;

      case 'a':
        // Spec says something about storing a list of markers, but it sounds
        // equivalent to this check.
        return ancestorInfo.aTagInScope;

      case 'nobr':
        return ancestorInfo.nobrTagInScope;
    }

    return null;
  };

  /**
   * Given a ReactCompositeComponent instance, return a list of its recursive
   * owners, starting at the root and ending with the instance itself.
   */
  var findOwnerStack = function (instance) {
    if (!instance) {
      return [];
    }

    var stack = [];
    do {
      stack.push(instance);
    } while (instance = instance._currentElement._owner);
    stack.reverse();
    return stack;
  };

  var didWarn = {};

  validateDOMNesting = function (childTag, childText, childInstance, ancestorInfo) {
    ancestorInfo = ancestorInfo || emptyAncestorInfo;
    var parentInfo = ancestorInfo.current;
    var parentTag = parentInfo && parentInfo.tag;

    if (childText != null) {
      "production" !== 'production' ? warning(childTag == null, 'validateDOMNesting: when childText is passed, childTag should be null') : void 0;
      childTag = '#text';
    }

    var invalidParent = isTagValidWithParent(childTag, parentTag) ? null : parentInfo;
    var invalidAncestor = invalidParent ? null : findInvalidAncestorForTag(childTag, ancestorInfo);
    var problematic = invalidParent || invalidAncestor;

    if (problematic) {
      var ancestorTag = problematic.tag;
      var ancestorInstance = problematic.instance;

      var childOwner = childInstance && childInstance._currentElement._owner;
      var ancestorOwner = ancestorInstance && ancestorInstance._currentElement._owner;

      var childOwners = findOwnerStack(childOwner);
      var ancestorOwners = findOwnerStack(ancestorOwner);

      var minStackLen = Math.min(childOwners.length, ancestorOwners.length);
      var i;

      var deepestCommon = -1;
      for (i = 0; i < minStackLen; i++) {
        if (childOwners[i] === ancestorOwners[i]) {
          deepestCommon = i;
        } else {
          break;
        }
      }

      var UNKNOWN = '(unknown)';
      var childOwnerNames = childOwners.slice(deepestCommon + 1).map(function (inst) {
        return inst.getName() || UNKNOWN;
      });
      var ancestorOwnerNames = ancestorOwners.slice(deepestCommon + 1).map(function (inst) {
        return inst.getName() || UNKNOWN;
      });
      var ownerInfo = [].concat(
      // If the parent and child instances have a common owner ancestor, start
      // with that -- otherwise we just start with the parent's owners.
      deepestCommon !== -1 ? childOwners[deepestCommon].getName() || UNKNOWN : [], ancestorOwnerNames, ancestorTag,
      // If we're warning about an invalid (non-parent) ancestry, add '...'
      invalidAncestor ? ['...'] : [], childOwnerNames, childTag).join(' > ');

      var warnKey = !!invalidParent + '|' + childTag + '|' + ancestorTag + '|' + ownerInfo;
      if (didWarn[warnKey]) {
        return;
      }
      didWarn[warnKey] = true;

      var tagDisplayName = childTag;
      var whitespaceInfo = '';
      if (childTag === '#text') {
        if (/\S/.test(childText)) {
          tagDisplayName = 'Text nodes';
        } else {
          tagDisplayName = 'Whitespace text nodes';
          whitespaceInfo = " Make sure you don't have any extra whitespace between tags on " + 'each line of your source code.';
        }
      } else {
        tagDisplayName = '<' + childTag + '>';
      }

      if (invalidParent) {
        var info = '';
        if (ancestorTag === 'table' && childTag === 'tr') {
          info += ' Add a <tbody> to your code to match the DOM tree generated by ' + 'the browser.';
        }
        "production" !== 'production' ? warning(false, 'validateDOMNesting(...): %s cannot appear as a child of <%s>.%s ' + 'See %s.%s', tagDisplayName, ancestorTag, whitespaceInfo, ownerInfo, info) : void 0;
      } else {
        "production" !== 'production' ? warning(false, 'validateDOMNesting(...): %s cannot appear as a descendant of ' + '<%s>. See %s.', tagDisplayName, ancestorTag, ownerInfo) : void 0;
      }
    }
  };

  validateDOMNesting.updatedAncestorInfo = updatedAncestorInfo;

  // For testing
  validateDOMNesting.isTagValidInContext = function (tag, ancestorInfo) {
    ancestorInfo = ancestorInfo || emptyAncestorInfo;
    var parentInfo = ancestorInfo.current;
    var parentTag = parentInfo && parentInfo.tag;
    return isTagValidWithParent(tag, parentTag) && !findInvalidAncestorForTag(tag, ancestorInfo);
  };
}

module.exports = validateDOMNesting;
},{"fbjs/lib/emptyFunction":394,"fbjs/lib/warning":409,"object-assign":489}],657:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports.createProvider = createProvider;

var _react = require('react');

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

var _PropTypes = require('../utils/PropTypes');

var _warning = require('../utils/warning');

var _warning2 = _interopRequireDefault(_warning);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var didWarnAboutReceivingStore = false;
function warnAboutReceivingStore() {
  if (didWarnAboutReceivingStore) {
    return;
  }
  didWarnAboutReceivingStore = true;

  (0, _warning2.default)('<Provider> does not support changing `store` on the fly. ' + 'It is most likely that you see this error because you updated to ' + 'Redux 2.x and React Redux 2.x which no longer hot reload reducers ' + 'automatically. See https://github.com/reactjs/react-redux/releases/' + 'tag/v2.0.0 for the migration instructions.');
}

function createProvider() {
  var _Provider$childContex;

  var storeKey = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'store';
  var subKey = arguments[1];

  var subscriptionKey = subKey || storeKey + 'Subscription';

  var Provider = function (_Component) {
    _inherits(Provider, _Component);

    Provider.prototype.getChildContext = function getChildContext() {
      var _ref;

      return _ref = {}, _ref[storeKey] = this[storeKey], _ref[subscriptionKey] = null, _ref;
    };

    function Provider(props, context) {
      _classCallCheck(this, Provider);

      var _this = _possibleConstructorReturn(this, _Component.call(this, props, context));

      _this[storeKey] = props.store;
      return _this;
    }

    Provider.prototype.render = function render() {
      return _react.Children.only(this.props.children);
    };

    return Provider;
  }(_react.Component);

  if ("production" !== 'production') {
    Provider.prototype.componentWillReceiveProps = function (nextProps) {
      if (this[storeKey] !== nextProps.store) {
        warnAboutReceivingStore();
      }
    };
  }

  Provider.propTypes = {
    store: _PropTypes.storeShape.isRequired,
    children: _propTypes2.default.element.isRequired
  };
  Provider.childContextTypes = (_Provider$childContex = {}, _Provider$childContex[storeKey] = _PropTypes.storeShape.isRequired, _Provider$childContex[subscriptionKey] = _PropTypes.subscriptionShape, _Provider$childContex);

  return Provider;
}

exports.default = createProvider();
},{"../utils/PropTypes":667,"../utils/warning":671,"prop-types":495,"react":697}],658:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.default = connectAdvanced;

var _hoistNonReactStatics = require('hoist-non-react-statics');

var _hoistNonReactStatics2 = _interopRequireDefault(_hoistNonReactStatics);

var _invariant = require('invariant');

var _invariant2 = _interopRequireDefault(_invariant);

var _react = require('react');

var _Subscription = require('../utils/Subscription');

var _Subscription2 = _interopRequireDefault(_Subscription);

var _PropTypes = require('../utils/PropTypes');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

var hotReloadingVersion = 0;
var dummyState = {};
function noop() {}
function makeSelectorStateful(sourceSelector, store) {
  // wrap the selector in an object that tracks its results between runs.
  var selector = {
    run: function runComponentSelector(props) {
      try {
        var nextProps = sourceSelector(store.getState(), props);
        if (nextProps !== selector.props || selector.error) {
          selector.shouldComponentUpdate = true;
          selector.props = nextProps;
          selector.error = null;
        }
      } catch (error) {
        selector.shouldComponentUpdate = true;
        selector.error = error;
      }
    }
  };

  return selector;
}

function connectAdvanced(
/*
  selectorFactory is a func that is responsible for returning the selector function used to
  compute new props from state, props, and dispatch. For example:
     export default connectAdvanced((dispatch, options) => (state, props) => ({
      thing: state.things[props.thingId],
      saveThing: fields => dispatch(actionCreators.saveThing(props.thingId, fields)),
    }))(YourComponent)
   Access to dispatch is provided to the factory so selectorFactories can bind actionCreators
  outside of their selector as an optimization. Options passed to connectAdvanced are passed to
  the selectorFactory, along with displayName and WrappedComponent, as the second argument.
   Note that selectorFactory is responsible for all caching/memoization of inbound and outbound
  props. Do not use connectAdvanced directly without memoizing results between calls to your
  selector, otherwise the Connect component will re-render on every state or props change.
*/
selectorFactory) {
  var _contextTypes, _childContextTypes;

  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      _ref$getDisplayName = _ref.getDisplayName,
      getDisplayName = _ref$getDisplayName === undefined ? function (name) {
    return 'ConnectAdvanced(' + name + ')';
  } : _ref$getDisplayName,
      _ref$methodName = _ref.methodName,
      methodName = _ref$methodName === undefined ? 'connectAdvanced' : _ref$methodName,
      _ref$renderCountProp = _ref.renderCountProp,
      renderCountProp = _ref$renderCountProp === undefined ? undefined : _ref$renderCountProp,
      _ref$shouldHandleStat = _ref.shouldHandleStateChanges,
      shouldHandleStateChanges = _ref$shouldHandleStat === undefined ? true : _ref$shouldHandleStat,
      _ref$storeKey = _ref.storeKey,
      storeKey = _ref$storeKey === undefined ? 'store' : _ref$storeKey,
      _ref$withRef = _ref.withRef,
      withRef = _ref$withRef === undefined ? false : _ref$withRef,
      connectOptions = _objectWithoutProperties(_ref, ['getDisplayName', 'methodName', 'renderCountProp', 'shouldHandleStateChanges', 'storeKey', 'withRef']);

  var subscriptionKey = storeKey + 'Subscription';
  var version = hotReloadingVersion++;

  var contextTypes = (_contextTypes = {}, _contextTypes[storeKey] = _PropTypes.storeShape, _contextTypes[subscriptionKey] = _PropTypes.subscriptionShape, _contextTypes);
  var childContextTypes = (_childContextTypes = {}, _childContextTypes[subscriptionKey] = _PropTypes.subscriptionShape, _childContextTypes);

  return function wrapWithConnect(WrappedComponent) {
    (0, _invariant2.default)(typeof WrappedComponent == 'function', 'You must pass a component to the function returned by ' + ('connect. Instead received ' + JSON.stringify(WrappedComponent)));

    var wrappedComponentName = WrappedComponent.displayName || WrappedComponent.name || 'Component';

    var displayName = getDisplayName(wrappedComponentName);

    var selectorFactoryOptions = _extends({}, connectOptions, {
      getDisplayName: getDisplayName,
      methodName: methodName,
      renderCountProp: renderCountProp,
      shouldHandleStateChanges: shouldHandleStateChanges,
      storeKey: storeKey,
      withRef: withRef,
      displayName: displayName,
      wrappedComponentName: wrappedComponentName,
      WrappedComponent: WrappedComponent
    });

    var Connect = function (_Component) {
      _inherits(Connect, _Component);

      function Connect(props, context) {
        _classCallCheck(this, Connect);

        var _this = _possibleConstructorReturn(this, _Component.call(this, props, context));

        _this.version = version;
        _this.state = {};
        _this.renderCount = 0;
        _this.store = props[storeKey] || context[storeKey];
        _this.propsMode = Boolean(props[storeKey]);
        _this.setWrappedInstance = _this.setWrappedInstance.bind(_this);

        (0, _invariant2.default)(_this.store, 'Could not find "' + storeKey + '" in either the context or props of ' + ('"' + displayName + '". Either wrap the root component in a <Provider>, ') + ('or explicitly pass "' + storeKey + '" as a prop to "' + displayName + '".'));

        _this.initSelector();
        _this.initSubscription();
        return _this;
      }

      Connect.prototype.getChildContext = function getChildContext() {
        var _ref2;

        // If this component received store from props, its subscription should be transparent
        // to any descendants receiving store+subscription from context; it passes along
        // subscription passed to it. Otherwise, it shadows the parent subscription, which allows
        // Connect to control ordering of notifications to flow top-down.
        var subscription = this.propsMode ? null : this.subscription;
        return _ref2 = {}, _ref2[subscriptionKey] = subscription || this.context[subscriptionKey], _ref2;
      };

      Connect.prototype.componentDidMount = function componentDidMount() {
        if (!shouldHandleStateChanges) return;

        // componentWillMount fires during server side rendering, but componentDidMount and
        // componentWillUnmount do not. Because of this, trySubscribe happens during ...didMount.
        // Otherwise, unsubscription would never take place during SSR, causing a memory leak.
        // To handle the case where a child component may have triggered a state change by
        // dispatching an action in its componentWillMount, we have to re-run the select and maybe
        // re-render.
        this.subscription.trySubscribe();
        this.selector.run(this.props);
        if (this.selector.shouldComponentUpdate) this.forceUpdate();
      };

      Connect.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
        this.selector.run(nextProps);
      };

      Connect.prototype.shouldComponentUpdate = function shouldComponentUpdate() {
        return this.selector.shouldComponentUpdate;
      };

      Connect.prototype.componentWillUnmount = function componentWillUnmount() {
        if (this.subscription) this.subscription.tryUnsubscribe();
        this.subscription = null;
        this.notifyNestedSubs = noop;
        this.store = null;
        this.selector.run = noop;
        this.selector.shouldComponentUpdate = false;
      };

      Connect.prototype.getWrappedInstance = function getWrappedInstance() {
        (0, _invariant2.default)(withRef, 'To access the wrapped instance, you need to specify ' + ('{ withRef: true } in the options argument of the ' + methodName + '() call.'));
        return this.wrappedInstance;
      };

      Connect.prototype.setWrappedInstance = function setWrappedInstance(ref) {
        this.wrappedInstance = ref;
      };

      Connect.prototype.initSelector = function initSelector() {
        var sourceSelector = selectorFactory(this.store.dispatch, selectorFactoryOptions);
        this.selector = makeSelectorStateful(sourceSelector, this.store);
        this.selector.run(this.props);
      };

      Connect.prototype.initSubscription = function initSubscription() {
        if (!shouldHandleStateChanges) return;

        // parentSub's source should match where store came from: props vs. context. A component
        // connected to the store via props shouldn't use subscription from context, or vice versa.
        var parentSub = (this.propsMode ? this.props : this.context)[subscriptionKey];
        this.subscription = new _Subscription2.default(this.store, parentSub, this.onStateChange.bind(this));

        // `notifyNestedSubs` is duplicated to handle the case where the component is  unmounted in
        // the middle of the notification loop, where `this.subscription` will then be null. An
        // extra null check every change can be avoided by copying the method onto `this` and then
        // replacing it with a no-op on unmount. This can probably be avoided if Subscription's
        // listeners logic is changed to not call listeners that have been unsubscribed in the
        // middle of the notification loop.
        this.notifyNestedSubs = this.subscription.notifyNestedSubs.bind(this.subscription);
      };

      Connect.prototype.onStateChange = function onStateChange() {
        this.selector.run(this.props);

        if (!this.selector.shouldComponentUpdate) {
          this.notifyNestedSubs();
        } else {
          this.componentDidUpdate = this.notifyNestedSubsOnComponentDidUpdate;
          this.setState(dummyState);
        }
      };

      Connect.prototype.notifyNestedSubsOnComponentDidUpdate = function notifyNestedSubsOnComponentDidUpdate() {
        // `componentDidUpdate` is conditionally implemented when `onStateChange` determines it
        // needs to notify nested subs. Once called, it unimplements itself until further state
        // changes occur. Doing it this way vs having a permanent `componentDidUpdate` that does
        // a boolean check every time avoids an extra method call most of the time, resulting
        // in some perf boost.
        this.componentDidUpdate = undefined;
        this.notifyNestedSubs();
      };

      Connect.prototype.isSubscribed = function isSubscribed() {
        return Boolean(this.subscription) && this.subscription.isSubscribed();
      };

      Connect.prototype.addExtraProps = function addExtraProps(props) {
        if (!withRef && !renderCountProp && !(this.propsMode && this.subscription)) return props;
        // make a shallow copy so that fields added don't leak to the original selector.
        // this is especially important for 'ref' since that's a reference back to the component
        // instance. a singleton memoized selector would then be holding a reference to the
        // instance, preventing the instance from being garbage collected, and that would be bad
        var withExtras = _extends({}, props);
        if (withRef) withExtras.ref = this.setWrappedInstance;
        if (renderCountProp) withExtras[renderCountProp] = this.renderCount++;
        if (this.propsMode && this.subscription) withExtras[subscriptionKey] = this.subscription;
        return withExtras;
      };

      Connect.prototype.render = function render() {
        var selector = this.selector;
        selector.shouldComponentUpdate = false;

        if (selector.error) {
          throw selector.error;
        } else {
          return (0, _react.createElement)(WrappedComponent, this.addExtraProps(selector.props));
        }
      };

      return Connect;
    }(_react.Component);

    Connect.WrappedComponent = WrappedComponent;
    Connect.displayName = displayName;
    Connect.childContextTypes = childContextTypes;
    Connect.contextTypes = contextTypes;
    Connect.propTypes = contextTypes;

    if ("production" !== 'production') {
      Connect.prototype.componentWillUpdate = function componentWillUpdate() {
        var _this2 = this;

        // We are hot reloading!
        if (this.version !== version) {
          this.version = version;
          this.initSelector();

          // If any connected descendants don't hot reload (and resubscribe in the process), their
          // listeners will be lost when we unsubscribe. Unfortunately, by copying over all
          // listeners, this does mean that the old versions of connected descendants will still be
          // notified of state changes; however, their onStateChange function is a no-op so this
          // isn't a huge deal.
          var oldListeners = [];

          if (this.subscription) {
            oldListeners = this.subscription.listeners.get();
            this.subscription.tryUnsubscribe();
          }
          this.initSubscription();
          if (shouldHandleStateChanges) {
            this.subscription.trySubscribe();
            oldListeners.forEach(function (listener) {
              return _this2.subscription.listeners.subscribe(listener);
            });
          }
        }
      };
    }

    return (0, _hoistNonReactStatics2.default)(Connect, WrappedComponent);
  };
}
},{"../utils/PropTypes":667,"../utils/Subscription":668,"hoist-non-react-statics":430,"invariant":431,"react":697}],659:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.createConnect = createConnect;

var _connectAdvanced = require('../components/connectAdvanced');

var _connectAdvanced2 = _interopRequireDefault(_connectAdvanced);

var _shallowEqual = require('../utils/shallowEqual');

var _shallowEqual2 = _interopRequireDefault(_shallowEqual);

var _mapDispatchToProps = require('./mapDispatchToProps');

var _mapDispatchToProps2 = _interopRequireDefault(_mapDispatchToProps);

var _mapStateToProps = require('./mapStateToProps');

var _mapStateToProps2 = _interopRequireDefault(_mapStateToProps);

var _mergeProps = require('./mergeProps');

var _mergeProps2 = _interopRequireDefault(_mergeProps);

var _selectorFactory = require('./selectorFactory');

var _selectorFactory2 = _interopRequireDefault(_selectorFactory);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

/*
  connect is a facade over connectAdvanced. It turns its args into a compatible
  selectorFactory, which has the signature:

    (dispatch, options) => (nextState, nextOwnProps) => nextFinalProps
  
  connect passes its args to connectAdvanced as options, which will in turn pass them to
  selectorFactory each time a Connect component instance is instantiated or hot reloaded.

  selectorFactory returns a final props selector from its mapStateToProps,
  mapStateToPropsFactories, mapDispatchToProps, mapDispatchToPropsFactories, mergeProps,
  mergePropsFactories, and pure args.

  The resulting final props selector is called by the Connect component instance whenever
  it receives new props or store state.
 */

function match(arg, factories, name) {
  for (var i = factories.length - 1; i >= 0; i--) {
    var result = factories[i](arg);
    if (result) return result;
  }

  return function (dispatch, options) {
    throw new Error('Invalid value of type ' + typeof arg + ' for ' + name + ' argument when connecting component ' + options.wrappedComponentName + '.');
  };
}

function strictEqual(a, b) {
  return a === b;
}

// createConnect with default args builds the 'official' connect behavior. Calling it with
// different options opens up some testing and extensibility scenarios
function createConnect() {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      _ref$connectHOC = _ref.connectHOC,
      connectHOC = _ref$connectHOC === undefined ? _connectAdvanced2.default : _ref$connectHOC,
      _ref$mapStateToPropsF = _ref.mapStateToPropsFactories,
      mapStateToPropsFactories = _ref$mapStateToPropsF === undefined ? _mapStateToProps2.default : _ref$mapStateToPropsF,
      _ref$mapDispatchToPro = _ref.mapDispatchToPropsFactories,
      mapDispatchToPropsFactories = _ref$mapDispatchToPro === undefined ? _mapDispatchToProps2.default : _ref$mapDispatchToPro,
      _ref$mergePropsFactor = _ref.mergePropsFactories,
      mergePropsFactories = _ref$mergePropsFactor === undefined ? _mergeProps2.default : _ref$mergePropsFactor,
      _ref$selectorFactory = _ref.selectorFactory,
      selectorFactory = _ref$selectorFactory === undefined ? _selectorFactory2.default : _ref$selectorFactory;

  return function connect(mapStateToProps, mapDispatchToProps, mergeProps) {
    var _ref2 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {},
        _ref2$pure = _ref2.pure,
        pure = _ref2$pure === undefined ? true : _ref2$pure,
        _ref2$areStatesEqual = _ref2.areStatesEqual,
        areStatesEqual = _ref2$areStatesEqual === undefined ? strictEqual : _ref2$areStatesEqual,
        _ref2$areOwnPropsEqua = _ref2.areOwnPropsEqual,
        areOwnPropsEqual = _ref2$areOwnPropsEqua === undefined ? _shallowEqual2.default : _ref2$areOwnPropsEqua,
        _ref2$areStatePropsEq = _ref2.areStatePropsEqual,
        areStatePropsEqual = _ref2$areStatePropsEq === undefined ? _shallowEqual2.default : _ref2$areStatePropsEq,
        _ref2$areMergedPropsE = _ref2.areMergedPropsEqual,
        areMergedPropsEqual = _ref2$areMergedPropsE === undefined ? _shallowEqual2.default : _ref2$areMergedPropsE,
        extraOptions = _objectWithoutProperties(_ref2, ['pure', 'areStatesEqual', 'areOwnPropsEqual', 'areStatePropsEqual', 'areMergedPropsEqual']);

    var initMapStateToProps = match(mapStateToProps, mapStateToPropsFactories, 'mapStateToProps');
    var initMapDispatchToProps = match(mapDispatchToProps, mapDispatchToPropsFactories, 'mapDispatchToProps');
    var initMergeProps = match(mergeProps, mergePropsFactories, 'mergeProps');

    return connectHOC(selectorFactory, _extends({
      // used in error messages
      methodName: 'connect',

      // used to compute Connect's displayName from the wrapped component's displayName.
      getDisplayName: function getDisplayName(name) {
        return 'Connect(' + name + ')';
      },

      // if mapStateToProps is falsy, the Connect component doesn't subscribe to store state changes
      shouldHandleStateChanges: Boolean(mapStateToProps),

      // passed through to selectorFactory
      initMapStateToProps: initMapStateToProps,
      initMapDispatchToProps: initMapDispatchToProps,
      initMergeProps: initMergeProps,
      pure: pure,
      areStatesEqual: areStatesEqual,
      areOwnPropsEqual: areOwnPropsEqual,
      areStatePropsEqual: areStatePropsEqual,
      areMergedPropsEqual: areMergedPropsEqual

    }, extraOptions));
  };
}

exports.default = createConnect();
},{"../components/connectAdvanced":658,"../utils/shallowEqual":669,"./mapDispatchToProps":660,"./mapStateToProps":661,"./mergeProps":662,"./selectorFactory":663}],660:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports.whenMapDispatchToPropsIsFunction = whenMapDispatchToPropsIsFunction;
exports.whenMapDispatchToPropsIsMissing = whenMapDispatchToPropsIsMissing;
exports.whenMapDispatchToPropsIsObject = whenMapDispatchToPropsIsObject;

var _redux = require('redux');

var _wrapMapToProps = require('./wrapMapToProps');

function whenMapDispatchToPropsIsFunction(mapDispatchToProps) {
  return typeof mapDispatchToProps === 'function' ? (0, _wrapMapToProps.wrapMapToPropsFunc)(mapDispatchToProps, 'mapDispatchToProps') : undefined;
}

function whenMapDispatchToPropsIsMissing(mapDispatchToProps) {
  return !mapDispatchToProps ? (0, _wrapMapToProps.wrapMapToPropsConstant)(function (dispatch) {
    return { dispatch: dispatch };
  }) : undefined;
}

function whenMapDispatchToPropsIsObject(mapDispatchToProps) {
  return mapDispatchToProps && typeof mapDispatchToProps === 'object' ? (0, _wrapMapToProps.wrapMapToPropsConstant)(function (dispatch) {
    return (0, _redux.bindActionCreators)(mapDispatchToProps, dispatch);
  }) : undefined;
}

exports.default = [whenMapDispatchToPropsIsFunction, whenMapDispatchToPropsIsMissing, whenMapDispatchToPropsIsObject];
},{"./wrapMapToProps":665,"redux":709}],661:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports.whenMapStateToPropsIsFunction = whenMapStateToPropsIsFunction;
exports.whenMapStateToPropsIsMissing = whenMapStateToPropsIsMissing;

var _wrapMapToProps = require('./wrapMapToProps');

function whenMapStateToPropsIsFunction(mapStateToProps) {
  return typeof mapStateToProps === 'function' ? (0, _wrapMapToProps.wrapMapToPropsFunc)(mapStateToProps, 'mapStateToProps') : undefined;
}

function whenMapStateToPropsIsMissing(mapStateToProps) {
  return !mapStateToProps ? (0, _wrapMapToProps.wrapMapToPropsConstant)(function () {
    return {};
  }) : undefined;
}

exports.default = [whenMapStateToPropsIsFunction, whenMapStateToPropsIsMissing];
},{"./wrapMapToProps":665}],662:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.defaultMergeProps = defaultMergeProps;
exports.wrapMergePropsFunc = wrapMergePropsFunc;
exports.whenMergePropsIsFunction = whenMergePropsIsFunction;
exports.whenMergePropsIsOmitted = whenMergePropsIsOmitted;

var _verifyPlainObject = require('../utils/verifyPlainObject');

var _verifyPlainObject2 = _interopRequireDefault(_verifyPlainObject);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function defaultMergeProps(stateProps, dispatchProps, ownProps) {
  return _extends({}, ownProps, stateProps, dispatchProps);
}

function wrapMergePropsFunc(mergeProps) {
  return function initMergePropsProxy(dispatch, _ref) {
    var displayName = _ref.displayName,
        pure = _ref.pure,
        areMergedPropsEqual = _ref.areMergedPropsEqual;

    var hasRunOnce = false;
    var mergedProps = void 0;

    return function mergePropsProxy(stateProps, dispatchProps, ownProps) {
      var nextMergedProps = mergeProps(stateProps, dispatchProps, ownProps);

      if (hasRunOnce) {
        if (!pure || !areMergedPropsEqual(nextMergedProps, mergedProps)) mergedProps = nextMergedProps;
      } else {
        hasRunOnce = true;
        mergedProps = nextMergedProps;

        if ("production" !== 'production') (0, _verifyPlainObject2.default)(mergedProps, displayName, 'mergeProps');
      }

      return mergedProps;
    };
  };
}

function whenMergePropsIsFunction(mergeProps) {
  return typeof mergeProps === 'function' ? wrapMergePropsFunc(mergeProps) : undefined;
}

function whenMergePropsIsOmitted(mergeProps) {
  return !mergeProps ? function () {
    return defaultMergeProps;
  } : undefined;
}

exports.default = [whenMergePropsIsFunction, whenMergePropsIsOmitted];
},{"../utils/verifyPlainObject":670}],663:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports.impureFinalPropsSelectorFactory = impureFinalPropsSelectorFactory;
exports.pureFinalPropsSelectorFactory = pureFinalPropsSelectorFactory;
exports.default = finalPropsSelectorFactory;

var _verifySubselectors = require('./verifySubselectors');

var _verifySubselectors2 = _interopRequireDefault(_verifySubselectors);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function impureFinalPropsSelectorFactory(mapStateToProps, mapDispatchToProps, mergeProps, dispatch) {
  return function impureFinalPropsSelector(state, ownProps) {
    return mergeProps(mapStateToProps(state, ownProps), mapDispatchToProps(dispatch, ownProps), ownProps);
  };
}

function pureFinalPropsSelectorFactory(mapStateToProps, mapDispatchToProps, mergeProps, dispatch, _ref) {
  var areStatesEqual = _ref.areStatesEqual,
      areOwnPropsEqual = _ref.areOwnPropsEqual,
      areStatePropsEqual = _ref.areStatePropsEqual;

  var hasRunAtLeastOnce = false;
  var state = void 0;
  var ownProps = void 0;
  var stateProps = void 0;
  var dispatchProps = void 0;
  var mergedProps = void 0;

  function handleFirstCall(firstState, firstOwnProps) {
    state = firstState;
    ownProps = firstOwnProps;
    stateProps = mapStateToProps(state, ownProps);
    dispatchProps = mapDispatchToProps(dispatch, ownProps);
    mergedProps = mergeProps(stateProps, dispatchProps, ownProps);
    hasRunAtLeastOnce = true;
    return mergedProps;
  }

  function handleNewPropsAndNewState() {
    stateProps = mapStateToProps(state, ownProps);

    if (mapDispatchToProps.dependsOnOwnProps) dispatchProps = mapDispatchToProps(dispatch, ownProps);

    mergedProps = mergeProps(stateProps, dispatchProps, ownProps);
    return mergedProps;
  }

  function handleNewProps() {
    if (mapStateToProps.dependsOnOwnProps) stateProps = mapStateToProps(state, ownProps);

    if (mapDispatchToProps.dependsOnOwnProps) dispatchProps = mapDispatchToProps(dispatch, ownProps);

    mergedProps = mergeProps(stateProps, dispatchProps, ownProps);
    return mergedProps;
  }

  function handleNewState() {
    var nextStateProps = mapStateToProps(state, ownProps);
    var statePropsChanged = !areStatePropsEqual(nextStateProps, stateProps);
    stateProps = nextStateProps;

    if (statePropsChanged) mergedProps = mergeProps(stateProps, dispatchProps, ownProps);

    return mergedProps;
  }

  function handleSubsequentCalls(nextState, nextOwnProps) {
    var propsChanged = !areOwnPropsEqual(nextOwnProps, ownProps);
    var stateChanged = !areStatesEqual(nextState, state);
    state = nextState;
    ownProps = nextOwnProps;

    if (propsChanged && stateChanged) return handleNewPropsAndNewState();
    if (propsChanged) return handleNewProps();
    if (stateChanged) return handleNewState();
    return mergedProps;
  }

  return function pureFinalPropsSelector(nextState, nextOwnProps) {
    return hasRunAtLeastOnce ? handleSubsequentCalls(nextState, nextOwnProps) : handleFirstCall(nextState, nextOwnProps);
  };
}

// TODO: Add more comments

// If pure is true, the selector returned by selectorFactory will memoize its results,
// allowing connectAdvanced's shouldComponentUpdate to return false if final
// props have not changed. If false, the selector will always return a new
// object and shouldComponentUpdate will always return true.

function finalPropsSelectorFactory(dispatch, _ref2) {
  var initMapStateToProps = _ref2.initMapStateToProps,
      initMapDispatchToProps = _ref2.initMapDispatchToProps,
      initMergeProps = _ref2.initMergeProps,
      options = _objectWithoutProperties(_ref2, ['initMapStateToProps', 'initMapDispatchToProps', 'initMergeProps']);

  var mapStateToProps = initMapStateToProps(dispatch, options);
  var mapDispatchToProps = initMapDispatchToProps(dispatch, options);
  var mergeProps = initMergeProps(dispatch, options);

  if ("production" !== 'production') {
    (0, _verifySubselectors2.default)(mapStateToProps, mapDispatchToProps, mergeProps, options.displayName);
  }

  var selectorFactory = options.pure ? pureFinalPropsSelectorFactory : impureFinalPropsSelectorFactory;

  return selectorFactory(mapStateToProps, mapDispatchToProps, mergeProps, dispatch, options);
}
},{"./verifySubselectors":664}],664:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports.default = verifySubselectors;

var _warning = require('../utils/warning');

var _warning2 = _interopRequireDefault(_warning);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function verify(selector, methodName, displayName) {
  if (!selector) {
    throw new Error('Unexpected value for ' + methodName + ' in ' + displayName + '.');
  } else if (methodName === 'mapStateToProps' || methodName === 'mapDispatchToProps') {
    if (!selector.hasOwnProperty('dependsOnOwnProps')) {
      (0, _warning2.default)('The selector for ' + methodName + ' of ' + displayName + ' did not specify a value for dependsOnOwnProps.');
    }
  }
}

function verifySubselectors(mapStateToProps, mapDispatchToProps, mergeProps, displayName) {
  verify(mapStateToProps, 'mapStateToProps', displayName);
  verify(mapDispatchToProps, 'mapDispatchToProps', displayName);
  verify(mergeProps, 'mergeProps', displayName);
}
},{"../utils/warning":671}],665:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports.wrapMapToPropsConstant = wrapMapToPropsConstant;
exports.getDependsOnOwnProps = getDependsOnOwnProps;
exports.wrapMapToPropsFunc = wrapMapToPropsFunc;

var _verifyPlainObject = require('../utils/verifyPlainObject');

var _verifyPlainObject2 = _interopRequireDefault(_verifyPlainObject);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function wrapMapToPropsConstant(getConstant) {
  return function initConstantSelector(dispatch, options) {
    var constant = getConstant(dispatch, options);

    function constantSelector() {
      return constant;
    }
    constantSelector.dependsOnOwnProps = false;
    return constantSelector;
  };
}

// dependsOnOwnProps is used by createMapToPropsProxy to determine whether to pass props as args
// to the mapToProps function being wrapped. It is also used by makePurePropsSelector to determine
// whether mapToProps needs to be invoked when props have changed.
// 
// A length of one signals that mapToProps does not depend on props from the parent component.
// A length of zero is assumed to mean mapToProps is getting args via arguments or ...args and
// therefore not reporting its length accurately..
function getDependsOnOwnProps(mapToProps) {
  return mapToProps.dependsOnOwnProps !== null && mapToProps.dependsOnOwnProps !== undefined ? Boolean(mapToProps.dependsOnOwnProps) : mapToProps.length !== 1;
}

// Used by whenMapStateToPropsIsFunction and whenMapDispatchToPropsIsFunction,
// this function wraps mapToProps in a proxy function which does several things:
// 
//  * Detects whether the mapToProps function being called depends on props, which
//    is used by selectorFactory to decide if it should reinvoke on props changes.
//    
//  * On first call, handles mapToProps if returns another function, and treats that
//    new function as the true mapToProps for subsequent calls.
//    
//  * On first call, verifies the first result is a plain object, in order to warn
//    the developer that their mapToProps function is not returning a valid result.
//    
function wrapMapToPropsFunc(mapToProps, methodName) {
  return function initProxySelector(dispatch, _ref) {
    var displayName = _ref.displayName;

    var proxy = function mapToPropsProxy(stateOrDispatch, ownProps) {
      return proxy.dependsOnOwnProps ? proxy.mapToProps(stateOrDispatch, ownProps) : proxy.mapToProps(stateOrDispatch);
    };

    // allow detectFactoryAndVerify to get ownProps
    proxy.dependsOnOwnProps = true;

    proxy.mapToProps = function detectFactoryAndVerify(stateOrDispatch, ownProps) {
      proxy.mapToProps = mapToProps;
      proxy.dependsOnOwnProps = getDependsOnOwnProps(mapToProps);
      var props = proxy(stateOrDispatch, ownProps);

      if (typeof props === 'function') {
        proxy.mapToProps = props;
        proxy.dependsOnOwnProps = getDependsOnOwnProps(props);
        props = proxy(stateOrDispatch, ownProps);
      }

      if ("production" !== 'production') (0, _verifyPlainObject2.default)(props, displayName, methodName);

      return props;
    };

    return proxy;
  };
}
},{"../utils/verifyPlainObject":670}],666:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports.connect = exports.connectAdvanced = exports.createProvider = exports.Provider = undefined;

var _Provider = require('./components/Provider');

var _Provider2 = _interopRequireDefault(_Provider);

var _connectAdvanced = require('./components/connectAdvanced');

var _connectAdvanced2 = _interopRequireDefault(_connectAdvanced);

var _connect = require('./connect/connect');

var _connect2 = _interopRequireDefault(_connect);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.Provider = _Provider2.default;
exports.createProvider = _Provider.createProvider;
exports.connectAdvanced = _connectAdvanced2.default;
exports.connect = _connect2.default;
},{"./components/Provider":657,"./components/connectAdvanced":658,"./connect/connect":659}],667:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports.storeShape = exports.subscriptionShape = undefined;

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var subscriptionShape = exports.subscriptionShape = _propTypes2.default.shape({
  trySubscribe: _propTypes2.default.func.isRequired,
  tryUnsubscribe: _propTypes2.default.func.isRequired,
  notifyNestedSubs: _propTypes2.default.func.isRequired,
  isSubscribed: _propTypes2.default.func.isRequired
});

var storeShape = exports.storeShape = _propTypes2.default.shape({
  subscribe: _propTypes2.default.func.isRequired,
  dispatch: _propTypes2.default.func.isRequired,
  getState: _propTypes2.default.func.isRequired
});
},{"prop-types":495}],668:[function(require,module,exports){
"use strict";

exports.__esModule = true;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// encapsulates the subscription logic for connecting a component to the redux store, as
// well as nesting subscriptions of descendant components, so that we can ensure the
// ancestor components re-render before descendants

var CLEARED = null;
var nullListeners = {
  notify: function notify() {}
};

function createListenerCollection() {
  // the current/next pattern is copied from redux's createStore code.
  // TODO: refactor+expose that code to be reusable here?
  var current = [];
  var next = [];

  return {
    clear: function clear() {
      next = CLEARED;
      current = CLEARED;
    },
    notify: function notify() {
      var listeners = current = next;
      for (var i = 0; i < listeners.length; i++) {
        listeners[i]();
      }
    },
    get: function get() {
      return next;
    },
    subscribe: function subscribe(listener) {
      var isSubscribed = true;
      if (next === current) next = current.slice();
      next.push(listener);

      return function unsubscribe() {
        if (!isSubscribed || current === CLEARED) return;
        isSubscribed = false;

        if (next === current) next = current.slice();
        next.splice(next.indexOf(listener), 1);
      };
    }
  };
}

var Subscription = function () {
  function Subscription(store, parentSub, onStateChange) {
    _classCallCheck(this, Subscription);

    this.store = store;
    this.parentSub = parentSub;
    this.onStateChange = onStateChange;
    this.unsubscribe = null;
    this.listeners = nullListeners;
  }

  Subscription.prototype.addNestedSub = function addNestedSub(listener) {
    this.trySubscribe();
    return this.listeners.subscribe(listener);
  };

  Subscription.prototype.notifyNestedSubs = function notifyNestedSubs() {
    this.listeners.notify();
  };

  Subscription.prototype.isSubscribed = function isSubscribed() {
    return Boolean(this.unsubscribe);
  };

  Subscription.prototype.trySubscribe = function trySubscribe() {
    if (!this.unsubscribe) {
      this.unsubscribe = this.parentSub ? this.parentSub.addNestedSub(this.onStateChange) : this.store.subscribe(this.onStateChange);

      this.listeners = createListenerCollection();
    }
  };

  Subscription.prototype.tryUnsubscribe = function tryUnsubscribe() {
    if (this.unsubscribe) {
      this.unsubscribe();
      this.unsubscribe = null;
      this.listeners.clear();
      this.listeners = nullListeners;
    }
  };

  return Subscription;
}();

exports.default = Subscription;
},{}],669:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports.default = shallowEqual;
var hasOwn = Object.prototype.hasOwnProperty;

function is(x, y) {
  if (x === y) {
    return x !== 0 || y !== 0 || 1 / x === 1 / y;
  } else {
    return x !== x && y !== y;
  }
}

function shallowEqual(objA, objB) {
  if (is(objA, objB)) return true;

  if (typeof objA !== 'object' || objA === null || typeof objB !== 'object' || objB === null) {
    return false;
  }

  var keysA = Object.keys(objA);
  var keysB = Object.keys(objB);

  if (keysA.length !== keysB.length) return false;

  for (var i = 0; i < keysA.length; i++) {
    if (!hasOwn.call(objB, keysA[i]) || !is(objA[keysA[i]], objB[keysA[i]])) {
      return false;
    }
  }

  return true;
}
},{}],670:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports.default = verifyPlainObject;

var _isPlainObject = require('lodash/isPlainObject');

var _isPlainObject2 = _interopRequireDefault(_isPlainObject);

var _warning = require('./warning');

var _warning2 = _interopRequireDefault(_warning);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function verifyPlainObject(value, displayName, methodName) {
  if (!(0, _isPlainObject2.default)(value)) {
    (0, _warning2.default)(methodName + '() in ' + displayName + ' must return a plain object. Instead received ' + value + '.');
  }
}
},{"./warning":671,"lodash/isPlainObject":441}],671:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports.default = warning;
/**
 * Prints a warning in the console if it exists.
 *
 * @param {String} message The warning message.
 * @returns {void}
 */
function warning(message) {
  /* eslint-disable no-console */
  if (typeof console !== 'undefined' && typeof console.error === 'function') {
    console.error(message);
  }
  /* eslint-enable no-console */
  try {
    // This error was thrown as a convenience so that if you enable
    // "break on all exceptions" in your console,
    // it would pause the execution at this line.
    throw new Error(message);
    /* eslint-disable no-empty */
  } catch (e) {}
  /* eslint-enable no-empty */
}
},{}],672:[function(require,module,exports){
arguments[4][552][0].apply(exports,arguments)
},{"dup":552}],673:[function(require,module,exports){
arguments[4][554][0].apply(exports,arguments)
},{"./reactProdInvariant":695,"dup":554,"fbjs/lib/invariant":402}],674:[function(require,module,exports){
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */

'use strict';

var _assign = require('object-assign');

var ReactBaseClasses = require('./ReactBaseClasses');
var ReactChildren = require('./ReactChildren');
var ReactDOMFactories = require('./ReactDOMFactories');
var ReactElement = require('./ReactElement');
var ReactPropTypes = require('./ReactPropTypes');
var ReactVersion = require('./ReactVersion');

var createReactClass = require('./createClass');
var onlyChild = require('./onlyChild');

var createElement = ReactElement.createElement;
var createFactory = ReactElement.createFactory;
var cloneElement = ReactElement.cloneElement;

if ("production" !== 'production') {
  var lowPriorityWarning = require('./lowPriorityWarning');
  var canDefineProperty = require('./canDefineProperty');
  var ReactElementValidator = require('./ReactElementValidator');
  var didWarnPropTypesDeprecated = false;
  createElement = ReactElementValidator.createElement;
  createFactory = ReactElementValidator.createFactory;
  cloneElement = ReactElementValidator.cloneElement;
}

var __spread = _assign;
var createMixin = function (mixin) {
  return mixin;
};

if ("production" !== 'production') {
  var warnedForSpread = false;
  var warnedForCreateMixin = false;
  __spread = function () {
    lowPriorityWarning(warnedForSpread, 'React.__spread is deprecated and should not be used. Use ' + 'Object.assign directly or another helper function with similar ' + 'semantics. You may be seeing this warning due to your compiler. ' + 'See https://fb.me/react-spread-deprecation for more details.');
    warnedForSpread = true;
    return _assign.apply(null, arguments);
  };

  createMixin = function (mixin) {
    lowPriorityWarning(warnedForCreateMixin, 'React.createMixin is deprecated and should not be used. ' + 'In React v16.0, it will be removed. ' + 'You can use this mixin directly instead. ' + 'See https://fb.me/createmixin-was-never-implemented for more info.');
    warnedForCreateMixin = true;
    return mixin;
  };
}

var React = {
  // Modern

  Children: {
    map: ReactChildren.map,
    forEach: ReactChildren.forEach,
    count: ReactChildren.count,
    toArray: ReactChildren.toArray,
    only: onlyChild
  },

  Component: ReactBaseClasses.Component,
  PureComponent: ReactBaseClasses.PureComponent,

  createElement: createElement,
  cloneElement: cloneElement,
  isValidElement: ReactElement.isValidElement,

  // Classic

  PropTypes: ReactPropTypes,
  createClass: createReactClass,
  createFactory: createFactory,
  createMixin: createMixin,

  // This looks DOM specific but these are actually isomorphic helpers
  // since they are just generating DOM strings.
  DOM: ReactDOMFactories,

  version: ReactVersion,

  // Deprecated hook for JSX spread, don't use this for anything.
  __spread: __spread
};

if ("production" !== 'production') {
  var warnedForCreateClass = false;
  if (canDefineProperty) {
    Object.defineProperty(React, 'PropTypes', {
      get: function () {
        lowPriorityWarning(didWarnPropTypesDeprecated, 'Accessing PropTypes via the main React package is deprecated,' + ' and will be removed in  React v16.0.' + ' Use the latest available v15.* prop-types package from npm instead.' + ' For info on usage, compatibility, migration and more, see ' + 'https://fb.me/prop-types-docs');
        didWarnPropTypesDeprecated = true;
        return ReactPropTypes;
      }
    });

    Object.defineProperty(React, 'createClass', {
      get: function () {
        lowPriorityWarning(warnedForCreateClass, 'Accessing createClass via the main React package is deprecated,' + ' and will be removed in React v16.0.' + " Use a plain JavaScript class instead. If you're not yet " + 'ready to migrate, create-react-class v15.* is available ' + 'on npm as a temporary, drop-in replacement. ' + 'For more info see https://fb.me/react-create-class');
        warnedForCreateClass = true;
        return createReactClass;
      }
    });
  }

  // React.DOM factories are deprecated. Wrap these methods so that
  // invocations of the React.DOM namespace and alert users to switch
  // to the `react-dom-factories` package.
  React.DOM = {};
  var warnedForFactories = false;
  Object.keys(ReactDOMFactories).forEach(function (factory) {
    React.DOM[factory] = function () {
      if (!warnedForFactories) {
        lowPriorityWarning(false, 'Accessing factories like React.DOM.%s has been deprecated ' + 'and will be removed in v16.0+. Use the ' + 'react-dom-factories package instead. ' + ' Version 1.0 provides a drop-in replacement.' + ' For more info, see https://fb.me/react-dom-factories', factory);
        warnedForFactories = true;
      }
      return ReactDOMFactories[factory].apply(ReactDOMFactories, arguments);
    };
  });
}

module.exports = React;
},{"./ReactBaseClasses":675,"./ReactChildren":676,"./ReactDOMFactories":679,"./ReactElement":680,"./ReactElementValidator":682,"./ReactPropTypes":685,"./ReactVersion":687,"./canDefineProperty":688,"./createClass":690,"./lowPriorityWarning":693,"./onlyChild":694,"object-assign":489}],675:[function(require,module,exports){
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */

'use strict';

var _prodInvariant = require('./reactProdInvariant'),
    _assign = require('object-assign');

var ReactNoopUpdateQueue = require('./ReactNoopUpdateQueue');

var canDefineProperty = require('./canDefineProperty');
var emptyObject = require('fbjs/lib/emptyObject');
var invariant = require('fbjs/lib/invariant');
var lowPriorityWarning = require('./lowPriorityWarning');

/**
 * Base class helpers for the updating state of a component.
 */
function ReactComponent(props, context, updater) {
  this.props = props;
  this.context = context;
  this.refs = emptyObject;
  // We initialize the default updater but the real one gets injected by the
  // renderer.
  this.updater = updater || ReactNoopUpdateQueue;
}

ReactComponent.prototype.isReactComponent = {};

/**
 * Sets a subset of the state. Always use this to mutate
 * state. You should treat `this.state` as immutable.
 *
 * There is no guarantee that `this.state` will be immediately updated, so
 * accessing `this.state` after calling this method may return the old value.
 *
 * There is no guarantee that calls to `setState` will run synchronously,
 * as they may eventually be batched together.  You can provide an optional
 * callback that will be executed when the call to setState is actually
 * completed.
 *
 * When a function is provided to setState, it will be called at some point in
 * the future (not synchronously). It will be called with the up to date
 * component arguments (state, props, context). These values can be different
 * from this.* because your function may be called after receiveProps but before
 * shouldComponentUpdate, and this new state, props, and context will not yet be
 * assigned to this.
 *
 * @param {object|function} partialState Next partial state or function to
 *        produce next partial state to be merged with current state.
 * @param {?function} callback Called after state is updated.
 * @final
 * @protected
 */
ReactComponent.prototype.setState = function (partialState, callback) {
  !(typeof partialState === 'object' || typeof partialState === 'function' || partialState == null) ? "production" !== 'production' ? invariant(false, 'setState(...): takes an object of state variables to update or a function which returns an object of state variables.') : _prodInvariant('85') : void 0;
  this.updater.enqueueSetState(this, partialState);
  if (callback) {
    this.updater.enqueueCallback(this, callback, 'setState');
  }
};

/**
 * Forces an update. This should only be invoked when it is known with
 * certainty that we are **not** in a DOM transaction.
 *
 * You may want to call this when you know that some deeper aspect of the
 * component's state has changed but `setState` was not called.
 *
 * This will not invoke `shouldComponentUpdate`, but it will invoke
 * `componentWillUpdate` and `componentDidUpdate`.
 *
 * @param {?function} callback Called after update is complete.
 * @final
 * @protected
 */
ReactComponent.prototype.forceUpdate = function (callback) {
  this.updater.enqueueForceUpdate(this);
  if (callback) {
    this.updater.enqueueCallback(this, callback, 'forceUpdate');
  }
};

/**
 * Deprecated APIs. These APIs used to exist on classic React classes but since
 * we would like to deprecate them, we're not going to move them over to this
 * modern base class. Instead, we define a getter that warns if it's accessed.
 */
if ("production" !== 'production') {
  var deprecatedAPIs = {
    isMounted: ['isMounted', 'Instead, make sure to clean up subscriptions and pending requests in ' + 'componentWillUnmount to prevent memory leaks.'],
    replaceState: ['replaceState', 'Refactor your code to use setState instead (see ' + 'https://github.com/facebook/react/issues/3236).']
  };
  var defineDeprecationWarning = function (methodName, info) {
    if (canDefineProperty) {
      Object.defineProperty(ReactComponent.prototype, methodName, {
        get: function () {
          lowPriorityWarning(false, '%s(...) is deprecated in plain JavaScript React classes. %s', info[0], info[1]);
          return undefined;
        }
      });
    }
  };
  for (var fnName in deprecatedAPIs) {
    if (deprecatedAPIs.hasOwnProperty(fnName)) {
      defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
    }
  }
}

/**
 * Base class helpers for the updating state of a component.
 */
function ReactPureComponent(props, context, updater) {
  // Duplicated from ReactComponent.
  this.props = props;
  this.context = context;
  this.refs = emptyObject;
  // We initialize the default updater but the real one gets injected by the
  // renderer.
  this.updater = updater || ReactNoopUpdateQueue;
}

function ComponentDummy() {}
ComponentDummy.prototype = ReactComponent.prototype;
ReactPureComponent.prototype = new ComponentDummy();
ReactPureComponent.prototype.constructor = ReactPureComponent;
// Avoid an extra prototype jump for these methods.
_assign(ReactPureComponent.prototype, ReactComponent.prototype);
ReactPureComponent.prototype.isPureReactComponent = true;

module.exports = {
  Component: ReactComponent,
  PureComponent: ReactPureComponent
};
},{"./ReactNoopUpdateQueue":683,"./canDefineProperty":688,"./lowPriorityWarning":693,"./reactProdInvariant":695,"fbjs/lib/emptyObject":395,"fbjs/lib/invariant":402,"object-assign":489}],676:[function(require,module,exports){
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */

'use strict';

var PooledClass = require('./PooledClass');
var ReactElement = require('./ReactElement');

var emptyFunction = require('fbjs/lib/emptyFunction');
var traverseAllChildren = require('./traverseAllChildren');

var twoArgumentPooler = PooledClass.twoArgumentPooler;
var fourArgumentPooler = PooledClass.fourArgumentPooler;

var userProvidedKeyEscapeRegex = /\/+/g;
function escapeUserProvidedKey(text) {
  return ('' + text).replace(userProvidedKeyEscapeRegex, '$&/');
}

/**
 * PooledClass representing the bookkeeping associated with performing a child
 * traversal. Allows avoiding binding callbacks.
 *
 * @constructor ForEachBookKeeping
 * @param {!function} forEachFunction Function to perform traversal with.
 * @param {?*} forEachContext Context to perform context with.
 */
function ForEachBookKeeping(forEachFunction, forEachContext) {
  this.func = forEachFunction;
  this.context = forEachContext;
  this.count = 0;
}
ForEachBookKeeping.prototype.destructor = function () {
  this.func = null;
  this.context = null;
  this.count = 0;
};
PooledClass.addPoolingTo(ForEachBookKeeping, twoArgumentPooler);

function forEachSingleChild(bookKeeping, child, name) {
  var func = bookKeeping.func,
      context = bookKeeping.context;

  func.call(context, child, bookKeeping.count++);
}

/**
 * Iterates through children that are typically specified as `props.children`.
 *
 * See https://facebook.github.io/react/docs/top-level-api.html#react.children.foreach
 *
 * The provided forEachFunc(child, index) will be called for each
 * leaf child.
 *
 * @param {?*} children Children tree container.
 * @param {function(*, int)} forEachFunc
 * @param {*} forEachContext Context for forEachContext.
 */
function forEachChildren(children, forEachFunc, forEachContext) {
  if (children == null) {
    return children;
  }
  var traverseContext = ForEachBookKeeping.getPooled(forEachFunc, forEachContext);
  traverseAllChildren(children, forEachSingleChild, traverseContext);
  ForEachBookKeeping.release(traverseContext);
}

/**
 * PooledClass representing the bookkeeping associated with performing a child
 * mapping. Allows avoiding binding callbacks.
 *
 * @constructor MapBookKeeping
 * @param {!*} mapResult Object containing the ordered map of results.
 * @param {!function} mapFunction Function to perform mapping with.
 * @param {?*} mapContext Context to perform mapping with.
 */
function MapBookKeeping(mapResult, keyPrefix, mapFunction, mapContext) {
  this.result = mapResult;
  this.keyPrefix = keyPrefix;
  this.func = mapFunction;
  this.context = mapContext;
  this.count = 0;
}
MapBookKeeping.prototype.destructor = function () {
  this.result = null;
  this.keyPrefix = null;
  this.func = null;
  this.context = null;
  this.count = 0;
};
PooledClass.addPoolingTo(MapBookKeeping, fourArgumentPooler);

function mapSingleChildIntoContext(bookKeeping, child, childKey) {
  var result = bookKeeping.result,
      keyPrefix = bookKeeping.keyPrefix,
      func = bookKeeping.func,
      context = bookKeeping.context;


  var mappedChild = func.call(context, child, bookKeeping.count++);
  if (Array.isArray(mappedChild)) {
    mapIntoWithKeyPrefixInternal(mappedChild, result, childKey, emptyFunction.thatReturnsArgument);
  } else if (mappedChild != null) {
    if (ReactElement.isValidElement(mappedChild)) {
      mappedChild = ReactElement.cloneAndReplaceKey(mappedChild,
      // Keep both the (mapped) and old keys if they differ, just as
      // traverseAllChildren used to do for objects as children
      keyPrefix + (mappedChild.key && (!child || child.key !== mappedChild.key) ? escapeUserProvidedKey(mappedChild.key) + '/' : '') + childKey);
    }
    result.push(mappedChild);
  }
}

function mapIntoWithKeyPrefixInternal(children, array, prefix, func, context) {
  var escapedPrefix = '';
  if (prefix != null) {
    escapedPrefix = escapeUserProvidedKey(prefix) + '/';
  }
  var traverseContext = MapBookKeeping.getPooled(array, escapedPrefix, func, context);
  traverseAllChildren(children, mapSingleChildIntoContext, traverseContext);
  MapBookKeeping.release(traverseContext);
}

/**
 * Maps children that are typically specified as `props.children`.
 *
 * See https://facebook.github.io/react/docs/top-level-api.html#react.children.map
 *
 * The provided mapFunction(child, key, index) will be called for each
 * leaf child.
 *
 * @param {?*} children Children tree container.
 * @param {function(*, int)} func The map function.
 * @param {*} context Context for mapFunction.
 * @return {object} Object containing the ordered map of results.
 */
function mapChildren(children, func, context) {
  if (children == null) {
    return children;
  }
  var result = [];
  mapIntoWithKeyPrefixInternal(children, result, null, func, context);
  return result;
}

function forEachSingleChildDummy(traverseContext, child, name) {
  return null;
}

/**
 * Count the number of children that are typically specified as
 * `props.children`.
 *
 * See https://facebook.github.io/react/docs/top-level-api.html#react.children.count
 *
 * @param {?*} children Children tree container.
 * @return {number} The number of children.
 */
function countChildren(children, context) {
  return traverseAllChildren(children, forEachSingleChildDummy, null);
}

/**
 * Flatten a children object (typically specified as `props.children`) and
 * return an array with appropriately re-keyed children.
 *
 * See https://facebook.github.io/react/docs/top-level-api.html#react.children.toarray
 */
function toArray(children) {
  var result = [];
  mapIntoWithKeyPrefixInternal(children, result, null, emptyFunction.thatReturnsArgument);
  return result;
}

var ReactChildren = {
  forEach: forEachChildren,
  map: mapChildren,
  mapIntoWithKeyPrefixInternal: mapIntoWithKeyPrefixInternal,
  count: countChildren,
  toArray: toArray
};

module.exports = ReactChildren;
},{"./PooledClass":673,"./ReactElement":680,"./traverseAllChildren":696,"fbjs/lib/emptyFunction":394}],677:[function(require,module,exports){
/**
 * Copyright (c) 2016-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

'use strict';

var _prodInvariant = require('./reactProdInvariant');

var ReactCurrentOwner = require('./ReactCurrentOwner');

var invariant = require('fbjs/lib/invariant');
var warning = require('fbjs/lib/warning');

function isNative(fn) {
  // Based on isNative() from Lodash
  var funcToString = Function.prototype.toString;
  var hasOwnProperty = Object.prototype.hasOwnProperty;
  var reIsNative = RegExp('^' + funcToString
  // Take an example native function source for comparison
  .call(hasOwnProperty
  // Strip regex characters so we can use it for regex
  ).replace(/[\\^$.*+?()[\]{}|]/g, '\\$&'
  // Remove hasOwnProperty from the template to make it generic
  ).replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');
  try {
    var source = funcToString.call(fn);
    return reIsNative.test(source);
  } catch (err) {
    return false;
  }
}

var canUseCollections =
// Array.from
typeof Array.from === 'function' &&
// Map
typeof Map === 'function' && isNative(Map) &&
// Map.prototype.keys
Map.prototype != null && typeof Map.prototype.keys === 'function' && isNative(Map.prototype.keys) &&
// Set
typeof Set === 'function' && isNative(Set) &&
// Set.prototype.keys
Set.prototype != null && typeof Set.prototype.keys === 'function' && isNative(Set.prototype.keys);

var setItem;
var getItem;
var removeItem;
var getItemIDs;
var addRoot;
var removeRoot;
var getRootIDs;

if (canUseCollections) {
  var itemMap = new Map();
  var rootIDSet = new Set();

  setItem = function (id, item) {
    itemMap.set(id, item);
  };
  getItem = function (id) {
    return itemMap.get(id);
  };
  removeItem = function (id) {
    itemMap['delete'](id);
  };
  getItemIDs = function () {
    return Array.from(itemMap.keys());
  };

  addRoot = function (id) {
    rootIDSet.add(id);
  };
  removeRoot = function (id) {
    rootIDSet['delete'](id);
  };
  getRootIDs = function () {
    return Array.from(rootIDSet.keys());
  };
} else {
  var itemByKey = {};
  var rootByKey = {};

  // Use non-numeric keys to prevent V8 performance issues:
  // https://github.com/facebook/react/pull/7232
  var getKeyFromID = function (id) {
    return '.' + id;
  };
  var getIDFromKey = function (key) {
    return parseInt(key.substr(1), 10);
  };

  setItem = function (id, item) {
    var key = getKeyFromID(id);
    itemByKey[key] = item;
  };
  getItem = function (id) {
    var key = getKeyFromID(id);
    return itemByKey[key];
  };
  removeItem = function (id) {
    var key = getKeyFromID(id);
    delete itemByKey[key];
  };
  getItemIDs = function () {
    return Object.keys(itemByKey).map(getIDFromKey);
  };

  addRoot = function (id) {
    var key = getKeyFromID(id);
    rootByKey[key] = true;
  };
  removeRoot = function (id) {
    var key = getKeyFromID(id);
    delete rootByKey[key];
  };
  getRootIDs = function () {
    return Object.keys(rootByKey).map(getIDFromKey);
  };
}

var unmountedIDs = [];

function purgeDeep(id) {
  var item = getItem(id);
  if (item) {
    var childIDs = item.childIDs;

    removeItem(id);
    childIDs.forEach(purgeDeep);
  }
}

function describeComponentFrame(name, source, ownerName) {
  return '\n    in ' + (name || 'Unknown') + (source ? ' (at ' + source.fileName.replace(/^.*[\\\/]/, '') + ':' + source.lineNumber + ')' : ownerName ? ' (created by ' + ownerName + ')' : '');
}

function getDisplayName(element) {
  if (element == null) {
    return '#empty';
  } else if (typeof element === 'string' || typeof element === 'number') {
    return '#text';
  } else if (typeof element.type === 'string') {
    return element.type;
  } else {
    return element.type.displayName || element.type.name || 'Unknown';
  }
}

function describeID(id) {
  var name = ReactComponentTreeHook.getDisplayName(id);
  var element = ReactComponentTreeHook.getElement(id);
  var ownerID = ReactComponentTreeHook.getOwnerID(id);
  var ownerName;
  if (ownerID) {
    ownerName = ReactComponentTreeHook.getDisplayName(ownerID);
  }
  "production" !== 'production' ? warning(element, 'ReactComponentTreeHook: Missing React element for debugID %s when ' + 'building stack', id) : void 0;
  return describeComponentFrame(name, element && element._source, ownerName);
}

var ReactComponentTreeHook = {
  onSetChildren: function (id, nextChildIDs) {
    var item = getItem(id);
    !item ? "production" !== 'production' ? invariant(false, 'Item must have been set') : _prodInvariant('144') : void 0;
    item.childIDs = nextChildIDs;

    for (var i = 0; i < nextChildIDs.length; i++) {
      var nextChildID = nextChildIDs[i];
      var nextChild = getItem(nextChildID);
      !nextChild ? "production" !== 'production' ? invariant(false, 'Expected hook events to fire for the child before its parent includes it in onSetChildren().') : _prodInvariant('140') : void 0;
      !(nextChild.childIDs != null || typeof nextChild.element !== 'object' || nextChild.element == null) ? "production" !== 'production' ? invariant(false, 'Expected onSetChildren() to fire for a container child before its parent includes it in onSetChildren().') : _prodInvariant('141') : void 0;
      !nextChild.isMounted ? "production" !== 'production' ? invariant(false, 'Expected onMountComponent() to fire for the child before its parent includes it in onSetChildren().') : _prodInvariant('71') : void 0;
      if (nextChild.parentID == null) {
        nextChild.parentID = id;
        // TODO: This shouldn't be necessary but mounting a new root during in
        // componentWillMount currently causes not-yet-mounted components to
        // be purged from our tree data so their parent id is missing.
      }
      !(nextChild.parentID === id) ? "production" !== 'production' ? invariant(false, 'Expected onBeforeMountComponent() parent and onSetChildren() to be consistent (%s has parents %s and %s).', nextChildID, nextChild.parentID, id) : _prodInvariant('142', nextChildID, nextChild.parentID, id) : void 0;
    }
  },
  onBeforeMountComponent: function (id, element, parentID) {
    var item = {
      element: element,
      parentID: parentID,
      text: null,
      childIDs: [],
      isMounted: false,
      updateCount: 0
    };
    setItem(id, item);
  },
  onBeforeUpdateComponent: function (id, element) {
    var item = getItem(id);
    if (!item || !item.isMounted) {
      // We may end up here as a result of setState() in componentWillUnmount().
      // In this case, ignore the element.
      return;
    }
    item.element = element;
  },
  onMountComponent: function (id) {
    var item = getItem(id);
    !item ? "production" !== 'production' ? invariant(false, 'Item must have been set') : _prodInvariant('144') : void 0;
    item.isMounted = true;
    var isRoot = item.parentID === 0;
    if (isRoot) {
      addRoot(id);
    }
  },
  onUpdateComponent: function (id) {
    var item = getItem(id);
    if (!item || !item.isMounted) {
      // We may end up here as a result of setState() in componentWillUnmount().
      // In this case, ignore the element.
      return;
    }
    item.updateCount++;
  },
  onUnmountComponent: function (id) {
    var item = getItem(id);
    if (item) {
      // We need to check if it exists.
      // `item` might not exist if it is inside an error boundary, and a sibling
      // error boundary child threw while mounting. Then this instance never
      // got a chance to mount, but it still gets an unmounting event during
      // the error boundary cleanup.
      item.isMounted = false;
      var isRoot = item.parentID === 0;
      if (isRoot) {
        removeRoot(id);
      }
    }
    unmountedIDs.push(id);
  },
  purgeUnmountedComponents: function () {
    if (ReactComponentTreeHook._preventPurging) {
      // Should only be used for testing.
      return;
    }

    for (var i = 0; i < unmountedIDs.length; i++) {
      var id = unmountedIDs[i];
      purgeDeep(id);
    }
    unmountedIDs.length = 0;
  },
  isMounted: function (id) {
    var item = getItem(id);
    return item ? item.isMounted : false;
  },
  getCurrentStackAddendum: function (topElement) {
    var info = '';
    if (topElement) {
      var name = getDisplayName(topElement);
      var owner = topElement._owner;
      info += describeComponentFrame(name, topElement._source, owner && owner.getName());
    }

    var currentOwner = ReactCurrentOwner.current;
    var id = currentOwner && currentOwner._debugID;

    info += ReactComponentTreeHook.getStackAddendumByID(id);
    return info;
  },
  getStackAddendumByID: function (id) {
    var info = '';
    while (id) {
      info += describeID(id);
      id = ReactComponentTreeHook.getParentID(id);
    }
    return info;
  },
  getChildIDs: function (id) {
    var item = getItem(id);
    return item ? item.childIDs : [];
  },
  getDisplayName: function (id) {
    var element = ReactComponentTreeHook.getElement(id);
    if (!element) {
      return null;
    }
    return getDisplayName(element);
  },
  getElement: function (id) {
    var item = getItem(id);
    return item ? item.element : null;
  },
  getOwnerID: function (id) {
    var element = ReactComponentTreeHook.getElement(id);
    if (!element || !element._owner) {
      return null;
    }
    return element._owner._debugID;
  },
  getParentID: function (id) {
    var item = getItem(id);
    return item ? item.parentID : null;
  },
  getSource: function (id) {
    var item = getItem(id);
    var element = item ? item.element : null;
    var source = element != null ? element._source : null;
    return source;
  },
  getText: function (id) {
    var element = ReactComponentTreeHook.getElement(id);
    if (typeof element === 'string') {
      return element;
    } else if (typeof element === 'number') {
      return '' + element;
    } else {
      return null;
    }
  },
  getUpdateCount: function (id) {
    var item = getItem(id);
    return item ? item.updateCount : 0;
  },


  getRootIDs: getRootIDs,
  getRegisteredIDs: getItemIDs,

  pushNonStandardWarningStack: function (isCreatingElement, currentSource) {
    if (typeof console.reactStack !== 'function') {
      return;
    }

    var stack = [];
    var currentOwner = ReactCurrentOwner.current;
    var id = currentOwner && currentOwner._debugID;

    try {
      if (isCreatingElement) {
        stack.push({
          name: id ? ReactComponentTreeHook.getDisplayName(id) : null,
          fileName: currentSource ? currentSource.fileName : null,
          lineNumber: currentSource ? currentSource.lineNumber : null
        });
      }

      while (id) {
        var element = ReactComponentTreeHook.getElement(id);
        var parentID = ReactComponentTreeHook.getParentID(id);
        var ownerID = ReactComponentTreeHook.getOwnerID(id);
        var ownerName = ownerID ? ReactComponentTreeHook.getDisplayName(ownerID) : null;
        var source = element && element._source;
        stack.push({
          name: ownerName,
          fileName: source ? source.fileName : null,
          lineNumber: source ? source.lineNumber : null
        });
        id = parentID;
      }
    } catch (err) {
      // Internal state is messed up.
      // Stop building the stack (it's just a nice to have).
    }

    console.reactStack(stack);
  },
  popNonStandardWarningStack: function () {
    if (typeof console.reactStackEnd !== 'function') {
      return;
    }
    console.reactStackEnd();
  }
};

module.exports = ReactComponentTreeHook;
},{"./ReactCurrentOwner":678,"./reactProdInvariant":695,"fbjs/lib/invariant":402,"fbjs/lib/warning":409}],678:[function(require,module,exports){
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

'use strict';

/**
 * Keeps track of the current owner.
 *
 * The current owner is the component who should own any components that are
 * currently being constructed.
 */
var ReactCurrentOwner = {
  /**
   * @internal
   * @type {ReactComponent}
   */
  current: null
};

module.exports = ReactCurrentOwner;
},{}],679:[function(require,module,exports){
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */

'use strict';

var ReactElement = require('./ReactElement');

/**
 * Create a factory that creates HTML tag elements.
 *
 * @private
 */
var createDOMFactory = ReactElement.createFactory;
if ("production" !== 'production') {
  var ReactElementValidator = require('./ReactElementValidator');
  createDOMFactory = ReactElementValidator.createFactory;
}

/**
 * Creates a mapping from supported HTML tags to `ReactDOMComponent` classes.
 *
 * @public
 */
var ReactDOMFactories = {
  a: createDOMFactory('a'),
  abbr: createDOMFactory('abbr'),
  address: createDOMFactory('address'),
  area: createDOMFactory('area'),
  article: createDOMFactory('article'),
  aside: createDOMFactory('aside'),
  audio: createDOMFactory('audio'),
  b: createDOMFactory('b'),
  base: createDOMFactory('base'),
  bdi: createDOMFactory('bdi'),
  bdo: createDOMFactory('bdo'),
  big: createDOMFactory('big'),
  blockquote: createDOMFactory('blockquote'),
  body: createDOMFactory('body'),
  br: createDOMFactory('br'),
  button: createDOMFactory('button'),
  canvas: createDOMFactory('canvas'),
  caption: createDOMFactory('caption'),
  cite: createDOMFactory('cite'),
  code: createDOMFactory('code'),
  col: createDOMFactory('col'),
  colgroup: createDOMFactory('colgroup'),
  data: createDOMFactory('data'),
  datalist: createDOMFactory('datalist'),
  dd: createDOMFactory('dd'),
  del: createDOMFactory('del'),
  details: createDOMFactory('details'),
  dfn: createDOMFactory('dfn'),
  dialog: createDOMFactory('dialog'),
  div: createDOMFactory('div'),
  dl: createDOMFactory('dl'),
  dt: createDOMFactory('dt'),
  em: createDOMFactory('em'),
  embed: createDOMFactory('embed'),
  fieldset: createDOMFactory('fieldset'),
  figcaption: createDOMFactory('figcaption'),
  figure: createDOMFactory('figure'),
  footer: createDOMFactory('footer'),
  form: createDOMFactory('form'),
  h1: createDOMFactory('h1'),
  h2: createDOMFactory('h2'),
  h3: createDOMFactory('h3'),
  h4: createDOMFactory('h4'),
  h5: createDOMFactory('h5'),
  h6: createDOMFactory('h6'),
  head: createDOMFactory('head'),
  header: createDOMFactory('header'),
  hgroup: createDOMFactory('hgroup'),
  hr: createDOMFactory('hr'),
  html: createDOMFactory('html'),
  i: createDOMFactory('i'),
  iframe: createDOMFactory('iframe'),
  img: createDOMFactory('img'),
  input: createDOMFactory('input'),
  ins: createDOMFactory('ins'),
  kbd: createDOMFactory('kbd'),
  keygen: createDOMFactory('keygen'),
  label: createDOMFactory('label'),
  legend: createDOMFactory('legend'),
  li: createDOMFactory('li'),
  link: createDOMFactory('link'),
  main: createDOMFactory('main'),
  map: createDOMFactory('map'),
  mark: createDOMFactory('mark'),
  menu: createDOMFactory('menu'),
  menuitem: createDOMFactory('menuitem'),
  meta: createDOMFactory('meta'),
  meter: createDOMFactory('meter'),
  nav: createDOMFactory('nav'),
  noscript: createDOMFactory('noscript'),
  object: createDOMFactory('object'),
  ol: createDOMFactory('ol'),
  optgroup: createDOMFactory('optgroup'),
  option: createDOMFactory('option'),
  output: createDOMFactory('output'),
  p: createDOMFactory('p'),
  param: createDOMFactory('param'),
  picture: createDOMFactory('picture'),
  pre: createDOMFactory('pre'),
  progress: createDOMFactory('progress'),
  q: createDOMFactory('q'),
  rp: createDOMFactory('rp'),
  rt: createDOMFactory('rt'),
  ruby: createDOMFactory('ruby'),
  s: createDOMFactory('s'),
  samp: createDOMFactory('samp'),
  script: createDOMFactory('script'),
  section: createDOMFactory('section'),
  select: createDOMFactory('select'),
  small: createDOMFactory('small'),
  source: createDOMFactory('source'),
  span: createDOMFactory('span'),
  strong: createDOMFactory('strong'),
  style: createDOMFactory('style'),
  sub: createDOMFactory('sub'),
  summary: createDOMFactory('summary'),
  sup: createDOMFactory('sup'),
  table: createDOMFactory('table'),
  tbody: createDOMFactory('tbody'),
  td: createDOMFactory('td'),
  textarea: createDOMFactory('textarea'),
  tfoot: createDOMFactory('tfoot'),
  th: createDOMFactory('th'),
  thead: createDOMFactory('thead'),
  time: createDOMFactory('time'),
  title: createDOMFactory('title'),
  tr: createDOMFactory('tr'),
  track: createDOMFactory('track'),
  u: createDOMFactory('u'),
  ul: createDOMFactory('ul'),
  'var': createDOMFactory('var'),
  video: createDOMFactory('video'),
  wbr: createDOMFactory('wbr'),

  // SVG
  circle: createDOMFactory('circle'),
  clipPath: createDOMFactory('clipPath'),
  defs: createDOMFactory('defs'),
  ellipse: createDOMFactory('ellipse'),
  g: createDOMFactory('g'),
  image: createDOMFactory('image'),
  line: createDOMFactory('line'),
  linearGradient: createDOMFactory('linearGradient'),
  mask: createDOMFactory('mask'),
  path: createDOMFactory('path'),
  pattern: createDOMFactory('pattern'),
  polygon: createDOMFactory('polygon'),
  polyline: createDOMFactory('polyline'),
  radialGradient: createDOMFactory('radialGradient'),
  rect: createDOMFactory('rect'),
  stop: createDOMFactory('stop'),
  svg: createDOMFactory('svg'),
  text: createDOMFactory('text'),
  tspan: createDOMFactory('tspan')
};

module.exports = ReactDOMFactories;
},{"./ReactElement":680,"./ReactElementValidator":682}],680:[function(require,module,exports){
/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */

'use strict';

var _assign = require('object-assign');

var ReactCurrentOwner = require('./ReactCurrentOwner');

var warning = require('fbjs/lib/warning');
var canDefineProperty = require('./canDefineProperty');
var hasOwnProperty = Object.prototype.hasOwnProperty;

var REACT_ELEMENT_TYPE = require('./ReactElementSymbol');

var RESERVED_PROPS = {
  key: true,
  ref: true,
  __self: true,
  __source: true
};

var specialPropKeyWarningShown, specialPropRefWarningShown;

function hasValidRef(config) {
  if ("production" !== 'production') {
    if (hasOwnProperty.call(config, 'ref')) {
      var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;
      if (getter && getter.isReactWarning) {
        return false;
      }
    }
  }
  return config.ref !== undefined;
}

function hasValidKey(config) {
  if ("production" !== 'production') {
    if (hasOwnProperty.call(config, 'key')) {
      var getter = Object.getOwnPropertyDescriptor(config, 'key').get;
      if (getter && getter.isReactWarning) {
        return false;
      }
    }
  }
  return config.key !== undefined;
}

function defineKeyPropWarningGetter(props, displayName) {
  var warnAboutAccessingKey = function () {
    if (!specialPropKeyWarningShown) {
      specialPropKeyWarningShown = true;
      "production" !== 'production' ? warning(false, '%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://fb.me/react-special-props)', displayName) : void 0;
    }
  };
  warnAboutAccessingKey.isReactWarning = true;
  Object.defineProperty(props, 'key', {
    get: warnAboutAccessingKey,
    configurable: true
  });
}

function defineRefPropWarningGetter(props, displayName) {
  var warnAboutAccessingRef = function () {
    if (!specialPropRefWarningShown) {
      specialPropRefWarningShown = true;
      "production" !== 'production' ? warning(false, '%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://fb.me/react-special-props)', displayName) : void 0;
    }
  };
  warnAboutAccessingRef.isReactWarning = true;
  Object.defineProperty(props, 'ref', {
    get: warnAboutAccessingRef,
    configurable: true
  });
}

/**
 * Factory method to create a new React element. This no longer adheres to
 * the class pattern, so do not use new to call it. Also, no instanceof check
 * will work. Instead test $$typeof field against Symbol.for('react.element') to check
 * if something is a React Element.
 *
 * @param {*} type
 * @param {*} key
 * @param {string|object} ref
 * @param {*} self A *temporary* helper to detect places where `this` is
 * different from the `owner` when React.createElement is called, so that we
 * can warn. We want to get rid of owner and replace string `ref`s with arrow
 * functions, and as long as `this` and owner are the same, there will be no
 * change in behavior.
 * @param {*} source An annotation object (added by a transpiler or otherwise)
 * indicating filename, line number, and/or other information.
 * @param {*} owner
 * @param {*} props
 * @internal
 */
var ReactElement = function (type, key, ref, self, source, owner, props) {
  var element = {
    // This tag allow us to uniquely identify this as a React Element
    $$typeof: REACT_ELEMENT_TYPE,

    // Built-in properties that belong on the element
    type: type,
    key: key,
    ref: ref,
    props: props,

    // Record the component responsible for creating this element.
    _owner: owner
  };

  if ("production" !== 'production') {
    // The validation flag is currently mutative. We put it on
    // an external backing store so that we can freeze the whole object.
    // This can be replaced with a WeakMap once they are implemented in
    // commonly used development environments.
    element._store = {};

    // To make comparing ReactElements easier for testing purposes, we make
    // the validation flag non-enumerable (where possible, which should
    // include every environment we run tests in), so the test framework
    // ignores it.
    if (canDefineProperty) {
      Object.defineProperty(element._store, 'validated', {
        configurable: false,
        enumerable: false,
        writable: true,
        value: false
      });
      // self and source are DEV only properties.
      Object.defineProperty(element, '_self', {
        configurable: false,
        enumerable: false,
        writable: false,
        value: self
      });
      // Two elements created in two different places should be considered
      // equal for testing purposes and therefore we hide it from enumeration.
      Object.defineProperty(element, '_source', {
        configurable: false,
        enumerable: false,
        writable: false,
        value: source
      });
    } else {
      element._store.validated = false;
      element._self = self;
      element._source = source;
    }
    if (Object.freeze) {
      Object.freeze(element.props);
      Object.freeze(element);
    }
  }

  return element;
};

/**
 * Create and return a new ReactElement of the given type.
 * See https://facebook.github.io/react/docs/top-level-api.html#react.createelement
 */
ReactElement.createElement = function (type, config, children) {
  var propName;

  // Reserved names are extracted
  var props = {};

  var key = null;
  var ref = null;
  var self = null;
  var source = null;

  if (config != null) {
    if (hasValidRef(config)) {
      ref = config.ref;
    }
    if (hasValidKey(config)) {
      key = '' + config.key;
    }

    self = config.__self === undefined ? null : config.__self;
    source = config.__source === undefined ? null : config.__source;
    // Remaining properties are added to a new props object
    for (propName in config) {
      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
        props[propName] = config[propName];
      }
    }
  }

  // Children can be more than one argument, and those are transferred onto
  // the newly allocated props object.
  var childrenLength = arguments.length - 2;
  if (childrenLength === 1) {
    props.children = children;
  } else if (childrenLength > 1) {
    var childArray = Array(childrenLength);
    for (var i = 0; i < childrenLength; i++) {
      childArray[i] = arguments[i + 2];
    }
    if ("production" !== 'production') {
      if (Object.freeze) {
        Object.freeze(childArray);
      }
    }
    props.children = childArray;
  }

  // Resolve default props
  if (type && type.defaultProps) {
    var defaultProps = type.defaultProps;
    for (propName in defaultProps) {
      if (props[propName] === undefined) {
        props[propName] = defaultProps[propName];
      }
    }
  }
  if ("production" !== 'production') {
    if (key || ref) {
      if (typeof props.$$typeof === 'undefined' || props.$$typeof !== REACT_ELEMENT_TYPE) {
        var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;
        if (key) {
          defineKeyPropWarningGetter(props, displayName);
        }
        if (ref) {
          defineRefPropWarningGetter(props, displayName);
        }
      }
    }
  }
  return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);
};

/**
 * Return a function that produces ReactElements of a given type.
 * See https://facebook.github.io/react/docs/top-level-api.html#react.createfactory
 */
ReactElement.createFactory = function (type) {
  var factory = ReactElement.createElement.bind(null, type);
  // Expose the type on the factory and the prototype so that it can be
  // easily accessed on elements. E.g. `<Foo />.type === Foo`.
  // This should not be named `constructor` since this may not be the function
  // that created the element, and it may not even be a constructor.
  // Legacy hook TODO: Warn if this is accessed
  factory.type = type;
  return factory;
};

ReactElement.cloneAndReplaceKey = function (oldElement, newKey) {
  var newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);

  return newElement;
};

/**
 * Clone and return a new ReactElement using element as the starting point.
 * See https://facebook.github.io/react/docs/top-level-api.html#react.cloneelement
 */
ReactElement.cloneElement = function (element, config, children) {
  var propName;

  // Original props are copied
  var props = _assign({}, element.props);

  // Reserved names are extracted
  var key = element.key;
  var ref = element.ref;
  // Self is preserved since the owner is preserved.
  var self = element._self;
  // Source is preserved since cloneElement is unlikely to be targeted by a
  // transpiler, and the original source is probably a better indicator of the
  // true owner.
  var source = element._source;

  // Owner will be preserved, unless ref is overridden
  var owner = element._owner;

  if (config != null) {
    if (hasValidRef(config)) {
      // Silently steal the ref from the parent.
      ref = config.ref;
      owner = ReactCurrentOwner.current;
    }
    if (hasValidKey(config)) {
      key = '' + config.key;
    }

    // Remaining properties override existing props
    var defaultProps;
    if (element.type && element.type.defaultProps) {
      defaultProps = element.type.defaultProps;
    }
    for (propName in config) {
      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
        if (config[propName] === undefined && defaultProps !== undefined) {
          // Resolve default props
          props[propName] = defaultProps[propName];
        } else {
          props[propName] = config[propName];
        }
      }
    }
  }

  // Children can be more than one argument, and those are transferred onto
  // the newly allocated props object.
  var childrenLength = arguments.length - 2;
  if (childrenLength === 1) {
    props.children = children;
  } else if (childrenLength > 1) {
    var childArray = Array(childrenLength);
    for (var i = 0; i < childrenLength; i++) {
      childArray[i] = arguments[i + 2];
    }
    props.children = childArray;
  }

  return ReactElement(element.type, key, ref, self, source, owner, props);
};

/**
 * Verifies the object is a ReactElement.
 * See https://facebook.github.io/react/docs/top-level-api.html#react.isvalidelement
 * @param {?object} object
 * @return {boolean} True if `object` is a valid component.
 * @final
 */
ReactElement.isValidElement = function (object) {
  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
};

module.exports = ReactElement;
},{"./ReactCurrentOwner":678,"./ReactElementSymbol":681,"./canDefineProperty":688,"fbjs/lib/warning":409,"object-assign":489}],681:[function(require,module,exports){
arguments[4][581][0].apply(exports,arguments)
},{"dup":581}],682:[function(require,module,exports){
/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */

/**
 * ReactElementValidator provides a wrapper around a element factory
 * which validates the props passed to the element. This is intended to be
 * used only in DEV and could be replaced by a static type checker for languages
 * that support it.
 */

'use strict';

var ReactCurrentOwner = require('./ReactCurrentOwner');
var ReactComponentTreeHook = require('./ReactComponentTreeHook');
var ReactElement = require('./ReactElement');

var checkReactTypeSpec = require('./checkReactTypeSpec');

var canDefineProperty = require('./canDefineProperty');
var getIteratorFn = require('./getIteratorFn');
var warning = require('fbjs/lib/warning');
var lowPriorityWarning = require('./lowPriorityWarning');

function getDeclarationErrorAddendum() {
  if (ReactCurrentOwner.current) {
    var name = ReactCurrentOwner.current.getName();
    if (name) {
      return ' Check the render method of `' + name + '`.';
    }
  }
  return '';
}

function getSourceInfoErrorAddendum(elementProps) {
  if (elementProps !== null && elementProps !== undefined && elementProps.__source !== undefined) {
    var source = elementProps.__source;
    var fileName = source.fileName.replace(/^.*[\\\/]/, '');
    var lineNumber = source.lineNumber;
    return ' Check your code at ' + fileName + ':' + lineNumber + '.';
  }
  return '';
}

/**
 * Warn if there's no key explicitly set on dynamic arrays of children or
 * object keys are not valid. This allows us to keep track of children between
 * updates.
 */
var ownerHasKeyUseWarning = {};

function getCurrentComponentErrorInfo(parentType) {
  var info = getDeclarationErrorAddendum();

  if (!info) {
    var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;
    if (parentName) {
      info = ' Check the top-level render call using <' + parentName + '>.';
    }
  }
  return info;
}

/**
 * Warn if the element doesn't have an explicit key assigned to it.
 * This element is in an array. The array could grow and shrink or be
 * reordered. All children that haven't already been validated are required to
 * have a "key" property assigned to it. Error statuses are cached so a warning
 * will only be shown once.
 *
 * @internal
 * @param {ReactElement} element Element that requires a key.
 * @param {*} parentType element's parent's type.
 */
function validateExplicitKey(element, parentType) {
  if (!element._store || element._store.validated || element.key != null) {
    return;
  }
  element._store.validated = true;

  var memoizer = ownerHasKeyUseWarning.uniqueKey || (ownerHasKeyUseWarning.uniqueKey = {});

  var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);
  if (memoizer[currentComponentErrorInfo]) {
    return;
  }
  memoizer[currentComponentErrorInfo] = true;

  // Usually the current owner is the offender, but if it accepts children as a
  // property, it may be the creator of the child that's responsible for
  // assigning it a key.
  var childOwner = '';
  if (element && element._owner && element._owner !== ReactCurrentOwner.current) {
    // Give the component that originally created this child.
    childOwner = ' It was passed a child from ' + element._owner.getName() + '.';
  }

  "production" !== 'production' ? warning(false, 'Each child in an array or iterator should have a unique "key" prop.' + '%s%s See https://fb.me/react-warning-keys for more information.%s', currentComponentErrorInfo, childOwner, ReactComponentTreeHook.getCurrentStackAddendum(element)) : void 0;
}

/**
 * Ensure that every element either is passed in a static location, in an
 * array with an explicit keys property defined, or in an object literal
 * with valid key property.
 *
 * @internal
 * @param {ReactNode} node Statically passed child of any type.
 * @param {*} parentType node's parent's type.
 */
function validateChildKeys(node, parentType) {
  if (typeof node !== 'object') {
    return;
  }
  if (Array.isArray(node)) {
    for (var i = 0; i < node.length; i++) {
      var child = node[i];
      if (ReactElement.isValidElement(child)) {
        validateExplicitKey(child, parentType);
      }
    }
  } else if (ReactElement.isValidElement(node)) {
    // This element was passed in a valid location.
    if (node._store) {
      node._store.validated = true;
    }
  } else if (node) {
    var iteratorFn = getIteratorFn(node);
    // Entry iterators provide implicit keys.
    if (iteratorFn) {
      if (iteratorFn !== node.entries) {
        var iterator = iteratorFn.call(node);
        var step;
        while (!(step = iterator.next()).done) {
          if (ReactElement.isValidElement(step.value)) {
            validateExplicitKey(step.value, parentType);
          }
        }
      }
    }
  }
}

/**
 * Given an element, validate that its props follow the propTypes definition,
 * provided by the type.
 *
 * @param {ReactElement} element
 */
function validatePropTypes(element) {
  var componentClass = element.type;
  if (typeof componentClass !== 'function') {
    return;
  }
  var name = componentClass.displayName || componentClass.name;
  if (componentClass.propTypes) {
    checkReactTypeSpec(componentClass.propTypes, element.props, 'prop', name, element, null);
  }
  if (typeof componentClass.getDefaultProps === 'function') {
    "production" !== 'production' ? warning(componentClass.getDefaultProps.isReactClassApproved, 'getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.') : void 0;
  }
}

var ReactElementValidator = {
  createElement: function (type, props, children) {
    var validType = typeof type === 'string' || typeof type === 'function';
    // We warn in this case but don't throw. We expect the element creation to
    // succeed and there will likely be errors in render.
    if (!validType) {
      if (typeof type !== 'function' && typeof type !== 'string') {
        var info = '';
        if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {
          info += ' You likely forgot to export your component from the file ' + "it's defined in.";
        }

        var sourceInfo = getSourceInfoErrorAddendum(props);
        if (sourceInfo) {
          info += sourceInfo;
        } else {
          info += getDeclarationErrorAddendum();
        }

        info += ReactComponentTreeHook.getCurrentStackAddendum();

        var currentSource = props !== null && props !== undefined && props.__source !== undefined ? props.__source : null;
        ReactComponentTreeHook.pushNonStandardWarningStack(true, currentSource);
        "production" !== 'production' ? warning(false, 'React.createElement: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', type == null ? type : typeof type, info) : void 0;
        ReactComponentTreeHook.popNonStandardWarningStack();
      }
    }

    var element = ReactElement.createElement.apply(this, arguments);

    // The result can be nullish if a mock or a custom function is used.
    // TODO: Drop this when these are no longer allowed as the type argument.
    if (element == null) {
      return element;
    }

    // Skip key warning if the type isn't valid since our key validation logic
    // doesn't expect a non-string/function type and can throw confusing errors.
    // We don't want exception behavior to differ between dev and prod.
    // (Rendering will throw with a helpful message and as soon as the type is
    // fixed, the key warnings will appear.)
    if (validType) {
      for (var i = 2; i < arguments.length; i++) {
        validateChildKeys(arguments[i], type);
      }
    }

    validatePropTypes(element);

    return element;
  },

  createFactory: function (type) {
    var validatedFactory = ReactElementValidator.createElement.bind(null, type);
    // Legacy hook TODO: Warn if this is accessed
    validatedFactory.type = type;

    if ("production" !== 'production') {
      if (canDefineProperty) {
        Object.defineProperty(validatedFactory, 'type', {
          enumerable: false,
          get: function () {
            lowPriorityWarning(false, 'Factory.type is deprecated. Access the class directly ' + 'before passing it to createFactory.');
            Object.defineProperty(this, 'type', {
              value: type
            });
            return type;
          }
        });
      }
    }

    return validatedFactory;
  },

  cloneElement: function (element, props, children) {
    var newElement = ReactElement.cloneElement.apply(this, arguments);
    for (var i = 2; i < arguments.length; i++) {
      validateChildKeys(arguments[i], newElement.type);
    }
    validatePropTypes(newElement);
    return newElement;
  }
};

module.exports = ReactElementValidator;
},{"./ReactComponentTreeHook":677,"./ReactCurrentOwner":678,"./ReactElement":680,"./canDefineProperty":688,"./checkReactTypeSpec":689,"./getIteratorFn":691,"./lowPriorityWarning":693,"fbjs/lib/warning":409}],683:[function(require,module,exports){
/**
 * Copyright (c) 2015-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */

'use strict';

var warning = require('fbjs/lib/warning');

function warnNoop(publicInstance, callerName) {
  if ("production" !== 'production') {
    var constructor = publicInstance.constructor;
    "production" !== 'production' ? warning(false, '%s(...): Can only update a mounted or mounting component. ' + 'This usually means you called %s() on an unmounted component. ' + 'This is a no-op. Please check the code for the %s component.', callerName, callerName, constructor && (constructor.displayName || constructor.name) || 'ReactClass') : void 0;
  }
}

/**
 * This is the abstract API for an update queue.
 */
var ReactNoopUpdateQueue = {
  /**
   * Checks whether or not this composite component is mounted.
   * @param {ReactClass} publicInstance The instance we want to test.
   * @return {boolean} True if mounted, false otherwise.
   * @protected
   * @final
   */
  isMounted: function (publicInstance) {
    return false;
  },

  /**
   * Enqueue a callback that will be executed after all the pending updates
   * have processed.
   *
   * @param {ReactClass} publicInstance The instance to use as `this` context.
   * @param {?function} callback Called after state is updated.
   * @internal
   */
  enqueueCallback: function (publicInstance, callback) {},

  /**
   * Forces an update. This should only be invoked when it is known with
   * certainty that we are **not** in a DOM transaction.
   *
   * You may want to call this when you know that some deeper aspect of the
   * component's state has changed but `setState` was not called.
   *
   * This will not invoke `shouldComponentUpdate`, but it will invoke
   * `componentWillUpdate` and `componentDidUpdate`.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @internal
   */
  enqueueForceUpdate: function (publicInstance) {
    warnNoop(publicInstance, 'forceUpdate');
  },

  /**
   * Replaces all of the state. Always use this or `setState` to mutate state.
   * You should treat `this.state` as immutable.
   *
   * There is no guarantee that `this.state` will be immediately updated, so
   * accessing `this.state` after calling this method may return the old value.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {object} completeState Next state.
   * @internal
   */
  enqueueReplaceState: function (publicInstance, completeState) {
    warnNoop(publicInstance, 'replaceState');
  },

  /**
   * Sets a subset of the state. This only exists because _pendingState is
   * internal. This provides a merging strategy that is not available to deep
   * properties which is confusing. TODO: Expose pendingState or don't use it
   * during the merge.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {object} partialState Next partial state to be merged with state.
   * @internal
   */
  enqueueSetState: function (publicInstance, partialState) {
    warnNoop(publicInstance, 'setState');
  }
};

module.exports = ReactNoopUpdateQueue;
},{"fbjs/lib/warning":409}],684:[function(require,module,exports){
arguments[4][599][0].apply(exports,arguments)
},{"dup":599}],685:[function(require,module,exports){
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */

'use strict';

var _require = require('./ReactElement'),
    isValidElement = _require.isValidElement;

var factory = require('prop-types/factory');

module.exports = factory(isValidElement);
},{"./ReactElement":680,"prop-types/factory":492}],686:[function(require,module,exports){
arguments[4][600][0].apply(exports,arguments)
},{"dup":600}],687:[function(require,module,exports){
arguments[4][608][0].apply(exports,arguments)
},{"dup":608}],688:[function(require,module,exports){
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

'use strict';

var canDefineProperty = false;
if ("production" !== 'production') {
  try {
    // $FlowFixMe https://github.com/facebook/flow/issues/285
    Object.defineProperty({}, 'x', { get: function () {} });
    canDefineProperty = true;
  } catch (x) {
    // IE will fail on defineProperty
  }
}

module.exports = canDefineProperty;
},{}],689:[function(require,module,exports){
(function (process){
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */

'use strict';

var _prodInvariant = require('./reactProdInvariant');

var ReactPropTypeLocationNames = require('./ReactPropTypeLocationNames');
var ReactPropTypesSecret = require('./ReactPropTypesSecret');

var invariant = require('fbjs/lib/invariant');
var warning = require('fbjs/lib/warning');

var ReactComponentTreeHook;

if (typeof process !== 'undefined' && process.env && "production" === 'test') {
  // Temporary hack.
  // Inline requires don't work well with Jest:
  // https://github.com/facebook/react/issues/7240
  // Remove the inline requires when we don't need them anymore:
  // https://github.com/facebook/react/pull/7178
  ReactComponentTreeHook = require('./ReactComponentTreeHook');
}

var loggedTypeFailures = {};

/**
 * Assert that the values match with the type specs.
 * Error messages are memorized and will only be shown once.
 *
 * @param {object} typeSpecs Map of name to a ReactPropType
 * @param {object} values Runtime values that need to be type-checked
 * @param {string} location e.g. "prop", "context", "child context"
 * @param {string} componentName Name of the component for error messages.
 * @param {?object} element The React element that is being type-checked
 * @param {?number} debugID The React component instance that is being type-checked
 * @private
 */
function checkReactTypeSpec(typeSpecs, values, location, componentName, element, debugID) {
  for (var typeSpecName in typeSpecs) {
    if (typeSpecs.hasOwnProperty(typeSpecName)) {
      var error;
      // Prop type validation may throw. In case they do, we don't want to
      // fail the render phase where it didn't fail before. So we log it.
      // After these have been cleaned up, we'll let them throw.
      try {
        // This is intentionally an invariant that gets caught. It's the same
        // behavior as without this statement except with a better message.
        !(typeof typeSpecs[typeSpecName] === 'function') ? "production" !== 'production' ? invariant(false, '%s: %s type `%s` is invalid; it must be a function, usually from React.PropTypes.', componentName || 'React class', ReactPropTypeLocationNames[location], typeSpecName) : _prodInvariant('84', componentName || 'React class', ReactPropTypeLocationNames[location], typeSpecName) : void 0;
        error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);
      } catch (ex) {
        error = ex;
      }
      "production" !== 'production' ? warning(!error || error instanceof Error, '%s: type specification of %s `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', ReactPropTypeLocationNames[location], typeSpecName, typeof error) : void 0;
      if (error instanceof Error && !(error.message in loggedTypeFailures)) {
        // Only monitor this failure once because there tends to be a lot of the
        // same error.
        loggedTypeFailures[error.message] = true;

        var componentStackInfo = '';

        if ("production" !== 'production') {
          if (!ReactComponentTreeHook) {
            ReactComponentTreeHook = require('./ReactComponentTreeHook');
          }
          if (debugID !== null) {
            componentStackInfo = ReactComponentTreeHook.getStackAddendumByID(debugID);
          } else if (element !== null) {
            componentStackInfo = ReactComponentTreeHook.getCurrentStackAddendum(element);
          }
        }

        "production" !== 'production' ? warning(false, 'Failed %s type: %s%s', location, error.message, componentStackInfo) : void 0;
      }
    }
  }
}

module.exports = checkReactTypeSpec;
}).call(this,require('_process'))
},{"./ReactComponentTreeHook":677,"./ReactPropTypeLocationNames":684,"./ReactPropTypesSecret":686,"./reactProdInvariant":695,"_process":490,"fbjs/lib/invariant":402,"fbjs/lib/warning":409}],690:[function(require,module,exports){
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */

'use strict';

var _require = require('./ReactBaseClasses'),
    Component = _require.Component;

var _require2 = require('./ReactElement'),
    isValidElement = _require2.isValidElement;

var ReactNoopUpdateQueue = require('./ReactNoopUpdateQueue');
var factory = require('create-react-class/factory');

module.exports = factory(Component, isValidElement, ReactNoopUpdateQueue);
},{"./ReactBaseClasses":675,"./ReactElement":680,"./ReactNoopUpdateQueue":683,"create-react-class/factory":382}],691:[function(require,module,exports){
arguments[4][641][0].apply(exports,arguments)
},{"dup":641}],692:[function(require,module,exports){
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

'use strict';

var nextDebugID = 1;

function getNextDebugID() {
  return nextDebugID++;
}

module.exports = getNextDebugID;
},{}],693:[function(require,module,exports){
/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */

'use strict';

/**
 * Forked from fbjs/warning:
 * https://github.com/facebook/fbjs/blob/e66ba20ad5be433eb54423f2b097d829324d9de6/packages/fbjs/src/__forks__/warning.js
 *
 * Only change is we use console.warn instead of console.error,
 * and do nothing when 'console' is not supported.
 * This really simplifies the code.
 * ---
 * Similar to invariant but only logs a warning if the condition is not met.
 * This can be used to log issues in development environments in critical
 * paths. Removing the logging code for production environments will keep the
 * same logic and follow the same code paths.
 */

var lowPriorityWarning = function () {};

if ("production" !== 'production') {
  var printWarning = function (format) {
    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    var argIndex = 0;
    var message = 'Warning: ' + format.replace(/%s/g, function () {
      return args[argIndex++];
    });
    if (typeof console !== 'undefined') {
      console.warn(message);
    }
    try {
      // --- Welcome to debugging React ---
      // This error was thrown as a convenience so that you can use this stack
      // to find the callsite that caused this warning to fire.
      throw new Error(message);
    } catch (x) {}
  };

  lowPriorityWarning = function (condition, format) {
    if (format === undefined) {
      throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');
    }
    if (!condition) {
      for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
        args[_key2 - 2] = arguments[_key2];
      }

      printWarning.apply(undefined, [format].concat(args));
    }
  };
}

module.exports = lowPriorityWarning;
},{}],694:[function(require,module,exports){
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */
'use strict';

var _prodInvariant = require('./reactProdInvariant');

var ReactElement = require('./ReactElement');

var invariant = require('fbjs/lib/invariant');

/**
 * Returns the first child in a collection of children and verifies that there
 * is only one child in the collection.
 *
 * See https://facebook.github.io/react/docs/top-level-api.html#react.children.only
 *
 * The current implementation of this function assumes that a single child gets
 * passed without a wrapper, but the purpose of this helper function is to
 * abstract away the particular structure of children.
 *
 * @param {?object} children Child collection structure.
 * @return {ReactElement} The first and only `ReactElement` contained in the
 * structure.
 */
function onlyChild(children) {
  !ReactElement.isValidElement(children) ? "production" !== 'production' ? invariant(false, 'React.Children.only expected to receive a single React element child.') : _prodInvariant('143') : void 0;
  return children;
}

module.exports = onlyChild;
},{"./ReactElement":680,"./reactProdInvariant":695,"fbjs/lib/invariant":402}],695:[function(require,module,exports){
arguments[4][650][0].apply(exports,arguments)
},{"dup":650}],696:[function(require,module,exports){
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */

'use strict';

var _prodInvariant = require('./reactProdInvariant');

var ReactCurrentOwner = require('./ReactCurrentOwner');
var REACT_ELEMENT_TYPE = require('./ReactElementSymbol');

var getIteratorFn = require('./getIteratorFn');
var invariant = require('fbjs/lib/invariant');
var KeyEscapeUtils = require('./KeyEscapeUtils');
var warning = require('fbjs/lib/warning');

var SEPARATOR = '.';
var SUBSEPARATOR = ':';

/**
 * This is inlined from ReactElement since this file is shared between
 * isomorphic and renderers. We could extract this to a
 *
 */

/**
 * TODO: Test that a single child and an array with one item have the same key
 * pattern.
 */

var didWarnAboutMaps = false;

/**
 * Generate a key string that identifies a component within a set.
 *
 * @param {*} component A component that could contain a manual key.
 * @param {number} index Index that is used if a manual key is not provided.
 * @return {string}
 */
function getComponentKey(component, index) {
  // Do some typechecking here since we call this blindly. We want to ensure
  // that we don't block potential future ES APIs.
  if (component && typeof component === 'object' && component.key != null) {
    // Explicit key
    return KeyEscapeUtils.escape(component.key);
  }
  // Implicit key determined by the index in the set
  return index.toString(36);
}

/**
 * @param {?*} children Children tree container.
 * @param {!string} nameSoFar Name of the key path so far.
 * @param {!function} callback Callback to invoke with each child found.
 * @param {?*} traverseContext Used to pass information throughout the traversal
 * process.
 * @return {!number} The number of children in this subtree.
 */
function traverseAllChildrenImpl(children, nameSoFar, callback, traverseContext) {
  var type = typeof children;

  if (type === 'undefined' || type === 'boolean') {
    // All of the above are perceived as null.
    children = null;
  }

  if (children === null || type === 'string' || type === 'number' ||
  // The following is inlined from ReactElement. This means we can optimize
  // some checks. React Fiber also inlines this logic for similar purposes.
  type === 'object' && children.$$typeof === REACT_ELEMENT_TYPE) {
    callback(traverseContext, children,
    // If it's the only child, treat the name as if it was wrapped in an array
    // so that it's consistent if the number of children grows.
    nameSoFar === '' ? SEPARATOR + getComponentKey(children, 0) : nameSoFar);
    return 1;
  }

  var child;
  var nextName;
  var subtreeCount = 0; // Count of children found in the current subtree.
  var nextNamePrefix = nameSoFar === '' ? SEPARATOR : nameSoFar + SUBSEPARATOR;

  if (Array.isArray(children)) {
    for (var i = 0; i < children.length; i++) {
      child = children[i];
      nextName = nextNamePrefix + getComponentKey(child, i);
      subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
    }
  } else {
    var iteratorFn = getIteratorFn(children);
    if (iteratorFn) {
      var iterator = iteratorFn.call(children);
      var step;
      if (iteratorFn !== children.entries) {
        var ii = 0;
        while (!(step = iterator.next()).done) {
          child = step.value;
          nextName = nextNamePrefix + getComponentKey(child, ii++);
          subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
        }
      } else {
        if ("production" !== 'production') {
          var mapsAsChildrenAddendum = '';
          if (ReactCurrentOwner.current) {
            var mapsAsChildrenOwnerName = ReactCurrentOwner.current.getName();
            if (mapsAsChildrenOwnerName) {
              mapsAsChildrenAddendum = ' Check the render method of `' + mapsAsChildrenOwnerName + '`.';
            }
          }
          "production" !== 'production' ? warning(didWarnAboutMaps, 'Using Maps as children is not yet fully supported. It is an ' + 'experimental feature that might be removed. Convert it to a ' + 'sequence / iterable of keyed ReactElements instead.%s', mapsAsChildrenAddendum) : void 0;
          didWarnAboutMaps = true;
        }
        // Iterator will provide entry [k,v] tuples rather than values.
        while (!(step = iterator.next()).done) {
          var entry = step.value;
          if (entry) {
            child = entry[1];
            nextName = nextNamePrefix + KeyEscapeUtils.escape(entry[0]) + SUBSEPARATOR + getComponentKey(child, 0);
            subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
          }
        }
      }
    } else if (type === 'object') {
      var addendum = '';
      if ("production" !== 'production') {
        addendum = ' If you meant to render a collection of children, use an array ' + 'instead or wrap the object using createFragment(object) from the ' + 'React add-ons.';
        if (children._isReactElement) {
          addendum = " It looks like you're using an element created by a different " + 'version of React. Make sure to use only one copy of React.';
        }
        if (ReactCurrentOwner.current) {
          var name = ReactCurrentOwner.current.getName();
          if (name) {
            addendum += ' Check the render method of `' + name + '`.';
          }
        }
      }
      var childrenString = String(children);
      !false ? "production" !== 'production' ? invariant(false, 'Objects are not valid as a React child (found: %s).%s', childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString, addendum) : _prodInvariant('31', childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString, addendum) : void 0;
    }
  }

  return subtreeCount;
}

/**
 * Traverses children that are typically specified as `props.children`, but
 * might also be specified through attributes:
 *
 * - `traverseAllChildren(this.props.children, ...)`
 * - `traverseAllChildren(this.props.leftPanelChildren, ...)`
 *
 * The `traverseContext` is an optional argument that is passed through the
 * entire traversal. It can be used to store accumulations or anything else that
 * the callback might find relevant.
 *
 * @param {?*} children Children tree object.
 * @param {!function} callback To invoke upon traversing each child.
 * @param {?*} traverseContext Context for traversal.
 * @return {!number} The number of children in this subtree.
 */
function traverseAllChildren(children, callback, traverseContext) {
  if (children == null) {
    return 0;
  }

  return traverseAllChildrenImpl(children, '', callback, traverseContext);
}

module.exports = traverseAllChildren;
},{"./KeyEscapeUtils":672,"./ReactCurrentOwner":678,"./ReactElementSymbol":681,"./getIteratorFn":691,"./reactProdInvariant":695,"fbjs/lib/invariant":402,"fbjs/lib/warning":409}],697:[function(require,module,exports){
'use strict';

module.exports = require('./lib/React');

},{"./lib/React":674}],698:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports.printBuffer = printBuffer;

var _helpers = require('./helpers');

var _diff = require('./diff');

var _diff2 = _interopRequireDefault(_diff);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

/**
 * Get log level string based on supplied params
 *
 * @param {string | function | object} level - console[level]
 * @param {object} action - selected action
 * @param {array} payload - selected payload
 * @param {string} type - log entry type
 *
 * @returns {string} level
 */
function getLogLevel(level, action, payload, type) {
  switch (typeof level === 'undefined' ? 'undefined' : _typeof(level)) {
    case 'object':
      return typeof level[type] === 'function' ? level[type].apply(level, _toConsumableArray(payload)) : level[type];
    case 'function':
      return level(action);
    default:
      return level;
  }
}

function defaultTitleFormatter(options) {
  var timestamp = options.timestamp,
      duration = options.duration;


  return function (action, time, took) {
    var parts = ['action'];

    if (timestamp) parts.push('@ ' + time);
    parts.push(String(action.type));
    if (duration) parts.push('(in ' + took.toFixed(2) + ' ms)');

    return parts.join(' ');
  };
}

function printBuffer(buffer, options) {
  var logger = options.logger,
      actionTransformer = options.actionTransformer,
      _options$titleFormatt = options.titleFormatter,
      titleFormatter = _options$titleFormatt === undefined ? defaultTitleFormatter(options) : _options$titleFormatt,
      collapsed = options.collapsed,
      colors = options.colors,
      level = options.level,
      diff = options.diff;


  buffer.forEach(function (logEntry, key) {
    var started = logEntry.started,
        startedTime = logEntry.startedTime,
        action = logEntry.action,
        prevState = logEntry.prevState,
        error = logEntry.error;
    var took = logEntry.took,
        nextState = logEntry.nextState;

    var nextEntry = buffer[key + 1];

    if (nextEntry) {
      nextState = nextEntry.prevState;
      took = nextEntry.started - started;
    }

    // Message
    var formattedAction = actionTransformer(action);
    var isCollapsed = typeof collapsed === 'function' ? collapsed(function () {
      return nextState;
    }, action, logEntry) : collapsed;

    var formattedTime = (0, _helpers.formatTime)(startedTime);
    var titleCSS = colors.title ? 'color: ' + colors.title(formattedAction) + ';' : null;
    var title = titleFormatter(formattedAction, formattedTime, took);

    // Render
    try {
      if (isCollapsed) {
        if (colors.title) logger.groupCollapsed('%c ' + title, titleCSS);else logger.groupCollapsed(title);
      } else {
        if (colors.title) logger.group('%c ' + title, titleCSS);else logger.group(title);
      }
    } catch (e) {
      logger.log(title);
    }

    var prevStateLevel = getLogLevel(level, formattedAction, [prevState], 'prevState');
    var actionLevel = getLogLevel(level, formattedAction, [formattedAction], 'action');
    var errorLevel = getLogLevel(level, formattedAction, [error, prevState], 'error');
    var nextStateLevel = getLogLevel(level, formattedAction, [nextState], 'nextState');

    if (prevStateLevel) {
      if (colors.prevState) logger[prevStateLevel]('%c prev state', 'color: ' + colors.prevState(prevState) + '; font-weight: bold', prevState);else logger[prevStateLevel]('prev state', prevState);
    }

    if (actionLevel) {
      if (colors.action) logger[actionLevel]('%c action', 'color: ' + colors.action(formattedAction) + '; font-weight: bold', formattedAction);else logger[actionLevel]('action', formattedAction);
    }

    if (error && errorLevel) {
      if (colors.error) logger[errorLevel]('%c error', 'color: ' + colors.error(error, prevState) + '; font-weight: bold', error);else logger[errorLevel]('error', error);
    }

    if (nextStateLevel) {
      if (colors.nextState) logger[nextStateLevel]('%c next state', 'color: ' + colors.nextState(nextState) + '; font-weight: bold', nextState);else logger[nextStateLevel]('next state', nextState);
    }

    if (diff) {
      (0, _diff2.default)(prevState, nextState, logger, isCollapsed);
    }

    try {
      logger.groupEnd();
    } catch (e) {
      logger.log('\u2014\u2014 log end \u2014\u2014');
    }
  });
}
},{"./diff":700,"./helpers":701}],699:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = {
  level: "log",
  logger: console,
  logErrors: true,
  collapsed: undefined,
  predicate: undefined,
  duration: false,
  timestamp: true,
  stateTransformer: function stateTransformer(state) {
    return state;
  },
  actionTransformer: function actionTransformer(action) {
    return action;
  },
  errorTransformer: function errorTransformer(error) {
    return error;
  },
  colors: {
    title: function title() {
      return "inherit";
    },
    prevState: function prevState() {
      return "#9E9E9E";
    },
    action: function action() {
      return "#03A9F4";
    },
    nextState: function nextState() {
      return "#4CAF50";
    },
    error: function error() {
      return "#F20404";
    }
  },
  diff: false,
  diffPredicate: undefined,

  // Deprecated options
  transformer: undefined
};
module.exports = exports["default"];
},{}],700:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = diffLogger;

var _deepDiff = require('deep-diff');

var _deepDiff2 = _interopRequireDefault(_deepDiff);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

// https://github.com/flitbit/diff#differences
var dictionary = {
  'E': {
    color: '#2196F3',
    text: 'CHANGED:'
  },
  'N': {
    color: '#4CAF50',
    text: 'ADDED:'
  },
  'D': {
    color: '#F44336',
    text: 'DELETED:'
  },
  'A': {
    color: '#2196F3',
    text: 'ARRAY:'
  }
};

function style(kind) {
  return 'color: ' + dictionary[kind].color + '; font-weight: bold';
}

function render(diff) {
  var kind = diff.kind,
      path = diff.path,
      lhs = diff.lhs,
      rhs = diff.rhs,
      index = diff.index,
      item = diff.item;


  switch (kind) {
    case 'E':
      return [path.join('.'), lhs, '\u2192', rhs];
    case 'N':
      return [path.join('.'), rhs];
    case 'D':
      return [path.join('.')];
    case 'A':
      return [path.join('.') + '[' + index + ']', item];
    default:
      return [];
  }
}

function diffLogger(prevState, newState, logger, isCollapsed) {
  var diff = (0, _deepDiff2.default)(prevState, newState);

  try {
    if (isCollapsed) {
      logger.groupCollapsed('diff');
    } else {
      logger.group('diff');
    }
  } catch (e) {
    logger.log('diff');
  }

  if (diff) {
    diff.forEach(function (elem) {
      var kind = elem.kind;

      var output = render(elem);

      logger.log.apply(logger, ['%c ' + dictionary[kind].text, style(kind)].concat(_toConsumableArray(output)));
    });
  } else {
    logger.log('\u2014\u2014 no diff \u2014\u2014');
  }

  try {
    logger.groupEnd();
  } catch (e) {
    logger.log('\u2014\u2014 diff end \u2014\u2014 ');
  }
}
module.exports = exports['default'];
},{"deep-diff":385}],701:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
var repeat = exports.repeat = function repeat(str, times) {
  return new Array(times + 1).join(str);
};

var pad = exports.pad = function pad(num, maxLength) {
  return repeat("0", maxLength - num.toString().length) + num;
};

var formatTime = exports.formatTime = function formatTime(time) {
  return pad(time.getHours(), 2) + ":" + pad(time.getMinutes(), 2) + ":" + pad(time.getSeconds(), 2) + "." + pad(time.getMilliseconds(), 3);
};

// Use performance API if it's available in order to get better precision
var timer = exports.timer = typeof performance !== "undefined" && performance !== null && typeof performance.now === "function" ? performance : Date;
},{}],702:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _core = require('./core');

var _helpers = require('./helpers');

var _defaults = require('./defaults');

var _defaults2 = _interopRequireDefault(_defaults);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Creates logger with following options
 *
 * @namespace
 * @param {object} options - options for logger
 * @param {string | function | object} options.level - console[level]
 * @param {boolean} options.duration - print duration of each action?
 * @param {boolean} options.timestamp - print timestamp with each action?
 * @param {object} options.colors - custom colors
 * @param {object} options.logger - implementation of the `console` API
 * @param {boolean} options.logErrors - should errors in action execution be caught, logged, and re-thrown?
 * @param {boolean} options.collapsed - is group collapsed?
 * @param {boolean} options.predicate - condition which resolves logger behavior
 * @param {function} options.stateTransformer - transform state before print
 * @param {function} options.actionTransformer - transform action before print
 * @param {function} options.errorTransformer - transform error before print
 *
 * @returns {function} logger middleware
 */
function createLogger() {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  var loggerOptions = _extends({}, _defaults2.default, options);

  var logger = loggerOptions.logger,
      transformer = loggerOptions.transformer,
      stateTransformer = loggerOptions.stateTransformer,
      errorTransformer = loggerOptions.errorTransformer,
      predicate = loggerOptions.predicate,
      logErrors = loggerOptions.logErrors,
      diffPredicate = loggerOptions.diffPredicate;

  // Return if 'console' object is not defined

  if (typeof logger === 'undefined') {
    return function () {
      return function (next) {
        return function (action) {
          return next(action);
        };
      };
    };
  }

  if (transformer) {
    console.error('Option \'transformer\' is deprecated, use \'stateTransformer\' instead!'); // eslint-disable-line no-console
  }

  // Detect if 'createLogger' was passed directly to 'applyMiddleware'.
  if (options.getState && options.dispatch) {
    // eslint-disable-next-line no-console
    console.error('redux-logger not installed. Make sure to pass logger instance as middleware:\n\nimport createLogger from \'redux-logger\';\n\nconst logger = createLogger();\nconst store = createStore(\n  reducer,\n  applyMiddleware(logger)\n);');

    return function () {
      return function (next) {
        return function (action) {
          return next(action);
        };
      };
    };
  }

  var logBuffer = [];

  return function (_ref) {
    var getState = _ref.getState;
    return function (next) {
      return function (action) {
        // Exit early if predicate function returns 'false'
        if (typeof predicate === 'function' && !predicate(getState, action)) {
          return next(action);
        }

        var logEntry = {};
        logBuffer.push(logEntry);

        logEntry.started = _helpers.timer.now();
        logEntry.startedTime = new Date();
        logEntry.prevState = stateTransformer(getState());
        logEntry.action = action;

        var returnedValue = void 0;
        if (logErrors) {
          try {
            returnedValue = next(action);
          } catch (e) {
            logEntry.error = errorTransformer(e);
          }
        } else {
          returnedValue = next(action);
        }

        logEntry.took = _helpers.timer.now() - logEntry.started;
        logEntry.nextState = stateTransformer(getState());

        var diff = loggerOptions.diff && typeof diffPredicate === 'function' ? diffPredicate(getState, action) : loggerOptions.diff;

        (0, _core.printBuffer)(logBuffer, _extends({}, loggerOptions, { diff: diff }));
        logBuffer.length = 0;

        if (logEntry.error) throw logEntry.error;
        return returnedValue;
      };
    };
  };
}

exports.default = createLogger;
module.exports = exports['default'];
},{"./core":698,"./defaults":699,"./helpers":701}],703:[function(require,module,exports){
'use strict';

function thunkMiddleware(_ref) {
  var dispatch = _ref.dispatch;
  var getState = _ref.getState;

  return function (next) {
    return function (action) {
      return typeof action === 'function' ? action(dispatch, getState) : next(action);
    };
  };
}

module.exports = thunkMiddleware;
},{}],704:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports['default'] = applyMiddleware;

var _compose = require('./compose');

var _compose2 = _interopRequireDefault(_compose);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

/**
 * Creates a store enhancer that applies middleware to the dispatch method
 * of the Redux store. This is handy for a variety of tasks, such as expressing
 * asynchronous actions in a concise manner, or logging every action payload.
 *
 * See `redux-thunk` package as an example of the Redux middleware.
 *
 * Because middleware is potentially asynchronous, this should be the first
 * store enhancer in the composition chain.
 *
 * Note that each middleware will be given the `dispatch` and `getState` functions
 * as named arguments.
 *
 * @param {...Function} middlewares The middleware chain to be applied.
 * @returns {Function} A store enhancer applying the middleware.
 */
function applyMiddleware() {
  for (var _len = arguments.length, middlewares = Array(_len), _key = 0; _key < _len; _key++) {
    middlewares[_key] = arguments[_key];
  }

  return function (createStore) {
    return function (reducer, preloadedState, enhancer) {
      var store = createStore(reducer, preloadedState, enhancer);
      var _dispatch = store.dispatch;
      var chain = [];

      var middlewareAPI = {
        getState: store.getState,
        dispatch: function dispatch(action) {
          return _dispatch(action);
        }
      };
      chain = middlewares.map(function (middleware) {
        return middleware(middlewareAPI);
      });
      _dispatch = _compose2['default'].apply(undefined, chain)(store.dispatch);

      return _extends({}, store, {
        dispatch: _dispatch
      });
    };
  };
}
},{"./compose":707}],705:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports['default'] = bindActionCreators;
function bindActionCreator(actionCreator, dispatch) {
  return function () {
    return dispatch(actionCreator.apply(undefined, arguments));
  };
}

/**
 * Turns an object whose values are action creators, into an object with the
 * same keys, but with every function wrapped into a `dispatch` call so they
 * may be invoked directly. This is just a convenience method, as you can call
 * `store.dispatch(MyActionCreators.doSomething())` yourself just fine.
 *
 * For convenience, you can also pass a single function as the first argument,
 * and get a function in return.
 *
 * @param {Function|Object} actionCreators An object whose values are action
 * creator functions. One handy way to obtain it is to use ES6 `import * as`
 * syntax. You may also pass a single function.
 *
 * @param {Function} dispatch The `dispatch` function available on your Redux
 * store.
 *
 * @returns {Function|Object} The object mimicking the original object, but with
 * every action creator wrapped into the `dispatch` call. If you passed a
 * function as `actionCreators`, the return value will also be a single
 * function.
 */
function bindActionCreators(actionCreators, dispatch) {
  if (typeof actionCreators === 'function') {
    return bindActionCreator(actionCreators, dispatch);
  }

  if (typeof actionCreators !== 'object' || actionCreators === null) {
    throw new Error('bindActionCreators expected an object or a function, instead received ' + (actionCreators === null ? 'null' : typeof actionCreators) + '. ' + 'Did you write "import ActionCreators from" instead of "import * as ActionCreators from"?');
  }

  var keys = Object.keys(actionCreators);
  var boundActionCreators = {};
  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];
    var actionCreator = actionCreators[key];
    if (typeof actionCreator === 'function') {
      boundActionCreators[key] = bindActionCreator(actionCreator, dispatch);
    }
  }
  return boundActionCreators;
}
},{}],706:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports['default'] = combineReducers;

var _createStore = require('./createStore');

var _isPlainObject = require('lodash/isPlainObject');

var _isPlainObject2 = _interopRequireDefault(_isPlainObject);

var _warning = require('./utils/warning');

var _warning2 = _interopRequireDefault(_warning);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function getUndefinedStateErrorMessage(key, action) {
  var actionType = action && action.type;
  var actionName = actionType && '"' + actionType.toString() + '"' || 'an action';

  return 'Given action ' + actionName + ', reducer "' + key + '" returned undefined. ' + 'To ignore an action, you must explicitly return the previous state.';
}

function getUnexpectedStateShapeWarningMessage(inputState, reducers, action, unexpectedKeyCache) {
  var reducerKeys = Object.keys(reducers);
  var argumentName = action && action.type === _createStore.ActionTypes.INIT ? 'preloadedState argument passed to createStore' : 'previous state received by the reducer';

  if (reducerKeys.length === 0) {
    return 'Store does not have a valid reducer. Make sure the argument passed ' + 'to combineReducers is an object whose values are reducers.';
  }

  if (!(0, _isPlainObject2['default'])(inputState)) {
    return 'The ' + argumentName + ' has unexpected type of "' + {}.toString.call(inputState).match(/\s([a-z|A-Z]+)/)[1] + '". Expected argument to be an object with the following ' + ('keys: "' + reducerKeys.join('", "') + '"');
  }

  var unexpectedKeys = Object.keys(inputState).filter(function (key) {
    return !reducers.hasOwnProperty(key) && !unexpectedKeyCache[key];
  });

  unexpectedKeys.forEach(function (key) {
    unexpectedKeyCache[key] = true;
  });

  if (unexpectedKeys.length > 0) {
    return 'Unexpected ' + (unexpectedKeys.length > 1 ? 'keys' : 'key') + ' ' + ('"' + unexpectedKeys.join('", "') + '" found in ' + argumentName + '. ') + 'Expected to find one of the known reducer keys instead: ' + ('"' + reducerKeys.join('", "') + '". Unexpected keys will be ignored.');
  }
}

function assertReducerSanity(reducers) {
  Object.keys(reducers).forEach(function (key) {
    var reducer = reducers[key];
    var initialState = reducer(undefined, { type: _createStore.ActionTypes.INIT });

    if (typeof initialState === 'undefined') {
      throw new Error('Reducer "' + key + '" returned undefined during initialization. ' + 'If the state passed to the reducer is undefined, you must ' + 'explicitly return the initial state. The initial state may ' + 'not be undefined.');
    }

    var type = '@@redux/PROBE_UNKNOWN_ACTION_' + Math.random().toString(36).substring(7).split('').join('.');
    if (typeof reducer(undefined, { type: type }) === 'undefined') {
      throw new Error('Reducer "' + key + '" returned undefined when probed with a random type. ' + ('Don\'t try to handle ' + _createStore.ActionTypes.INIT + ' or other actions in "redux/*" ') + 'namespace. They are considered private. Instead, you must return the ' + 'current state for any unknown actions, unless it is undefined, ' + 'in which case you must return the initial state, regardless of the ' + 'action type. The initial state may not be undefined.');
    }
  });
}

/**
 * Turns an object whose values are different reducer functions, into a single
 * reducer function. It will call every child reducer, and gather their results
 * into a single state object, whose keys correspond to the keys of the passed
 * reducer functions.
 *
 * @param {Object} reducers An object whose values correspond to different
 * reducer functions that need to be combined into one. One handy way to obtain
 * it is to use ES6 `import * as reducers` syntax. The reducers may never return
 * undefined for any action. Instead, they should return their initial state
 * if the state passed to them was undefined, and the current state for any
 * unrecognized action.
 *
 * @returns {Function} A reducer function that invokes every reducer inside the
 * passed object, and builds a state object with the same shape.
 */
function combineReducers(reducers) {
  var reducerKeys = Object.keys(reducers);
  var finalReducers = {};
  for (var i = 0; i < reducerKeys.length; i++) {
    var key = reducerKeys[i];

    if ("production" !== 'production') {
      if (typeof reducers[key] === 'undefined') {
        (0, _warning2['default'])('No reducer provided for key "' + key + '"');
      }
    }

    if (typeof reducers[key] === 'function') {
      finalReducers[key] = reducers[key];
    }
  }
  var finalReducerKeys = Object.keys(finalReducers);

  if ("production" !== 'production') {
    var unexpectedKeyCache = {};
  }

  var sanityError;
  try {
    assertReducerSanity(finalReducers);
  } catch (e) {
    sanityError = e;
  }

  return function combination() {
    var state = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
    var action = arguments[1];

    if (sanityError) {
      throw sanityError;
    }

    if ("production" !== 'production') {
      var warningMessage = getUnexpectedStateShapeWarningMessage(state, finalReducers, action, unexpectedKeyCache);
      if (warningMessage) {
        (0, _warning2['default'])(warningMessage);
      }
    }

    var hasChanged = false;
    var nextState = {};
    for (var i = 0; i < finalReducerKeys.length; i++) {
      var key = finalReducerKeys[i];
      var reducer = finalReducers[key];
      var previousStateForKey = state[key];
      var nextStateForKey = reducer(previousStateForKey, action);
      if (typeof nextStateForKey === 'undefined') {
        var errorMessage = getUndefinedStateErrorMessage(key, action);
        throw new Error(errorMessage);
      }
      nextState[key] = nextStateForKey;
      hasChanged = hasChanged || nextStateForKey !== previousStateForKey;
    }
    return hasChanged ? nextState : state;
  };
}
},{"./createStore":708,"./utils/warning":710,"lodash/isPlainObject":441}],707:[function(require,module,exports){
"use strict";

exports.__esModule = true;
exports["default"] = compose;
/**
 * Composes single-argument functions from right to left. The rightmost
 * function can take multiple arguments as it provides the signature for
 * the resulting composite function.
 *
 * @param {...Function} funcs The functions to compose.
 * @returns {Function} A function obtained by composing the argument functions
 * from right to left. For example, compose(f, g, h) is identical to doing
 * (...args) => f(g(h(...args))).
 */

function compose() {
  for (var _len = arguments.length, funcs = Array(_len), _key = 0; _key < _len; _key++) {
    funcs[_key] = arguments[_key];
  }

  if (funcs.length === 0) {
    return function (arg) {
      return arg;
    };
  }

  if (funcs.length === 1) {
    return funcs[0];
  }

  var last = funcs[funcs.length - 1];
  var rest = funcs.slice(0, -1);
  return function () {
    return rest.reduceRight(function (composed, f) {
      return f(composed);
    }, last.apply(undefined, arguments));
  };
}
},{}],708:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports.ActionTypes = undefined;
exports['default'] = createStore;

var _isPlainObject = require('lodash/isPlainObject');

var _isPlainObject2 = _interopRequireDefault(_isPlainObject);

var _symbolObservable = require('symbol-observable');

var _symbolObservable2 = _interopRequireDefault(_symbolObservable);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

/**
 * These are private action types reserved by Redux.
 * For any unknown actions, you must return the current state.
 * If the current state is undefined, you must return the initial state.
 * Do not reference these action types directly in your code.
 */
var ActionTypes = exports.ActionTypes = {
  INIT: '@@redux/INIT'
};

/**
 * Creates a Redux store that holds the state tree.
 * The only way to change the data in the store is to call `dispatch()` on it.
 *
 * There should only be a single store in your app. To specify how different
 * parts of the state tree respond to actions, you may combine several reducers
 * into a single reducer function by using `combineReducers`.
 *
 * @param {Function} reducer A function that returns the next state tree, given
 * the current state tree and the action to handle.
 *
 * @param {any} [preloadedState] The initial state. You may optionally specify it
 * to hydrate the state from the server in universal apps, or to restore a
 * previously serialized user session.
 * If you use `combineReducers` to produce the root reducer function, this must be
 * an object with the same shape as `combineReducers` keys.
 *
 * @param {Function} enhancer The store enhancer. You may optionally specify it
 * to enhance the store with third-party capabilities such as middleware,
 * time travel, persistence, etc. The only store enhancer that ships with Redux
 * is `applyMiddleware()`.
 *
 * @returns {Store} A Redux store that lets you read the state, dispatch actions
 * and subscribe to changes.
 */
function createStore(reducer, preloadedState, enhancer) {
  var _ref2;

  if (typeof preloadedState === 'function' && typeof enhancer === 'undefined') {
    enhancer = preloadedState;
    preloadedState = undefined;
  }

  if (typeof enhancer !== 'undefined') {
    if (typeof enhancer !== 'function') {
      throw new Error('Expected the enhancer to be a function.');
    }

    return enhancer(createStore)(reducer, preloadedState);
  }

  if (typeof reducer !== 'function') {
    throw new Error('Expected the reducer to be a function.');
  }

  var currentReducer = reducer;
  var currentState = preloadedState;
  var currentListeners = [];
  var nextListeners = currentListeners;
  var isDispatching = false;

  function ensureCanMutateNextListeners() {
    if (nextListeners === currentListeners) {
      nextListeners = currentListeners.slice();
    }
  }

  /**
   * Reads the state tree managed by the store.
   *
   * @returns {any} The current state tree of your application.
   */
  function getState() {
    return currentState;
  }

  /**
   * Adds a change listener. It will be called any time an action is dispatched,
   * and some part of the state tree may potentially have changed. You may then
   * call `getState()` to read the current state tree inside the callback.
   *
   * You may call `dispatch()` from a change listener, with the following
   * caveats:
   *
   * 1. The subscriptions are snapshotted just before every `dispatch()` call.
   * If you subscribe or unsubscribe while the listeners are being invoked, this
   * will not have any effect on the `dispatch()` that is currently in progress.
   * However, the next `dispatch()` call, whether nested or not, will use a more
   * recent snapshot of the subscription list.
   *
   * 2. The listener should not expect to see all state changes, as the state
   * might have been updated multiple times during a nested `dispatch()` before
   * the listener is called. It is, however, guaranteed that all subscribers
   * registered before the `dispatch()` started will be called with the latest
   * state by the time it exits.
   *
   * @param {Function} listener A callback to be invoked on every dispatch.
   * @returns {Function} A function to remove this change listener.
   */
  function subscribe(listener) {
    if (typeof listener !== 'function') {
      throw new Error('Expected listener to be a function.');
    }

    var isSubscribed = true;

    ensureCanMutateNextListeners();
    nextListeners.push(listener);

    return function unsubscribe() {
      if (!isSubscribed) {
        return;
      }

      isSubscribed = false;

      ensureCanMutateNextListeners();
      var index = nextListeners.indexOf(listener);
      nextListeners.splice(index, 1);
    };
  }

  /**
   * Dispatches an action. It is the only way to trigger a state change.
   *
   * The `reducer` function, used to create the store, will be called with the
   * current state tree and the given `action`. Its return value will
   * be considered the **next** state of the tree, and the change listeners
   * will be notified.
   *
   * The base implementation only supports plain object actions. If you want to
   * dispatch a Promise, an Observable, a thunk, or something else, you need to
   * wrap your store creating function into the corresponding middleware. For
   * example, see the documentation for the `redux-thunk` package. Even the
   * middleware will eventually dispatch plain object actions using this method.
   *
   * @param {Object} action A plain object representing “what changed”. It is
   * a good idea to keep actions serializable so you can record and replay user
   * sessions, or use the time travelling `redux-devtools`. An action must have
   * a `type` property which may not be `undefined`. It is a good idea to use
   * string constants for action types.
   *
   * @returns {Object} For convenience, the same action object you dispatched.
   *
   * Note that, if you use a custom middleware, it may wrap `dispatch()` to
   * return something else (for example, a Promise you can await).
   */
  function dispatch(action) {
    if (!(0, _isPlainObject2['default'])(action)) {
      throw new Error('Actions must be plain objects. ' + 'Use custom middleware for async actions.');
    }

    if (typeof action.type === 'undefined') {
      throw new Error('Actions may not have an undefined "type" property. ' + 'Have you misspelled a constant?');
    }

    if (isDispatching) {
      throw new Error('Reducers may not dispatch actions.');
    }

    try {
      isDispatching = true;
      currentState = currentReducer(currentState, action);
    } finally {
      isDispatching = false;
    }

    var listeners = currentListeners = nextListeners;
    for (var i = 0; i < listeners.length; i++) {
      listeners[i]();
    }

    return action;
  }

  /**
   * Replaces the reducer currently used by the store to calculate the state.
   *
   * You might need this if your app implements code splitting and you want to
   * load some of the reducers dynamically. You might also need this if you
   * implement a hot reloading mechanism for Redux.
   *
   * @param {Function} nextReducer The reducer for the store to use instead.
   * @returns {void}
   */
  function replaceReducer(nextReducer) {
    if (typeof nextReducer !== 'function') {
      throw new Error('Expected the nextReducer to be a function.');
    }

    currentReducer = nextReducer;
    dispatch({ type: ActionTypes.INIT });
  }

  /**
   * Interoperability point for observable/reactive libraries.
   * @returns {observable} A minimal observable of state changes.
   * For more information, see the observable proposal:
   * https://github.com/zenparsing/es-observable
   */
  function observable() {
    var _ref;

    var outerSubscribe = subscribe;
    return _ref = {
      /**
       * The minimal observable subscription method.
       * @param {Object} observer Any object that can be used as an observer.
       * The observer object should have a `next` method.
       * @returns {subscription} An object with an `unsubscribe` method that can
       * be used to unsubscribe the observable from the store, and prevent further
       * emission of values from the observable.
       */
      subscribe: function subscribe(observer) {
        if (typeof observer !== 'object') {
          throw new TypeError('Expected the observer to be an object.');
        }

        function observeState() {
          if (observer.next) {
            observer.next(getState());
          }
        }

        observeState();
        var unsubscribe = outerSubscribe(observeState);
        return { unsubscribe: unsubscribe };
      }
    }, _ref[_symbolObservable2['default']] = function () {
      return this;
    }, _ref;
  }

  // When a store is created, an "INIT" action is dispatched so that every
  // reducer returns their initial state. This effectively populates
  // the initial state tree.
  dispatch({ type: ActionTypes.INIT });

  return _ref2 = {
    dispatch: dispatch,
    subscribe: subscribe,
    getState: getState,
    replaceReducer: replaceReducer
  }, _ref2[_symbolObservable2['default']] = observable, _ref2;
}
},{"lodash/isPlainObject":441,"symbol-observable":735}],709:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports.compose = exports.applyMiddleware = exports.bindActionCreators = exports.combineReducers = exports.createStore = undefined;

var _createStore = require('./createStore');

var _createStore2 = _interopRequireDefault(_createStore);

var _combineReducers = require('./combineReducers');

var _combineReducers2 = _interopRequireDefault(_combineReducers);

var _bindActionCreators = require('./bindActionCreators');

var _bindActionCreators2 = _interopRequireDefault(_bindActionCreators);

var _applyMiddleware = require('./applyMiddleware');

var _applyMiddleware2 = _interopRequireDefault(_applyMiddleware);

var _compose = require('./compose');

var _compose2 = _interopRequireDefault(_compose);

var _warning = require('./utils/warning');

var _warning2 = _interopRequireDefault(_warning);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

/*
* This is a dummy function to check if the function name has been altered by minification.
* If the function has been minified and NODE_ENV !== 'production', warn the user.
*/
function isCrushed() {}

if ("production" !== 'production' && typeof isCrushed.name === 'string' && isCrushed.name !== 'isCrushed') {
  (0, _warning2['default'])('You are currently using minified code outside of NODE_ENV === \'production\'. ' + 'This means that you are running a slower development build of Redux. ' + 'You can use loose-envify (https://github.com/zertosh/loose-envify) for browserify ' + 'or DefinePlugin for webpack (http://stackoverflow.com/questions/30030031) ' + 'to ensure you have the correct code for your production build.');
}

exports.createStore = _createStore2['default'];
exports.combineReducers = _combineReducers2['default'];
exports.bindActionCreators = _bindActionCreators2['default'];
exports.applyMiddleware = _applyMiddleware2['default'];
exports.compose = _compose2['default'];
},{"./applyMiddleware":704,"./bindActionCreators":705,"./combineReducers":706,"./compose":707,"./createStore":708,"./utils/warning":710}],710:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports['default'] = warning;
/**
 * Prints a warning in the console if it exists.
 *
 * @param {String} message The warning message.
 * @returns {void}
 */
function warning(message) {
  /* eslint-disable no-console */
  if (typeof console !== 'undefined' && typeof console.error === 'function') {
    console.error(message);
  }
  /* eslint-enable no-console */
  try {
    // This error was thrown as a convenience so that if you enable
    // "break on all exceptions" in your console,
    // it would pause the execution at this line.
    throw new Error(message);
    /* eslint-disable no-empty */
  } catch (e) {}
  /* eslint-enable no-empty */
}
},{}],711:[function(require,module,exports){
/*
Slick Finder
*/"use strict"

// Notable changes from Slick.Finder 1.0.x

// faster bottom -> up expression matching
// prefers mental sanity over *obsessive compulsive* milliseconds savings
// uses prototypes instead of objects
// tries to use matchesSelector smartly, whenever available
// can populate objects as well as arrays
// lots of stuff is broken or not implemented

var parse = require("./parser")

// utilities

var index = 0,
    counter = document.__counter = (parseInt(document.__counter || -1, 36) + 1).toString(36),
    key = "uid:" + counter

var uniqueID = function(n, xml){
    if (n === window) return "window"
    if (n === document) return "document"
    if (n === document.documentElement) return "html"

    if (xml) {
        var uid = n.getAttribute(key)
        if (!uid) {
            uid = (index++).toString(36)
            n.setAttribute(key, uid)
        }
        return uid
    } else {
        return n[key] || (n[key] = (index++).toString(36))
    }
}

var uniqueIDXML = function(n) {
    return uniqueID(n, true)
}

var isArray = Array.isArray || function(object){
    return Object.prototype.toString.call(object) === "[object Array]"
}

// tests

var uniqueIndex = 0;

var HAS = {

    GET_ELEMENT_BY_ID: function(test, id){
        id = "slick_" + (uniqueIndex++);
        // checks if the document has getElementById, and it works
        test.innerHTML = '<a id="' + id + '"></a>'
        return !!this.getElementById(id)
    },

    QUERY_SELECTOR: function(test){
        // this supposedly fixes a webkit bug with matchesSelector / querySelector & nth-child
        test.innerHTML = '_<style>:nth-child(2){}</style>'

        // checks if the document has querySelectorAll, and it works
        test.innerHTML = '<a class="MiX"></a>'

        return test.querySelectorAll('.MiX').length === 1
    },

    EXPANDOS: function(test, id){
        id = "slick_" + (uniqueIndex++);
        // checks if the document has elements that support expandos
        test._custom_property_ = id
        return test._custom_property_ === id
    },

    // TODO: use this ?

    // CHECKED_QUERY_SELECTOR: function(test){
    //
    //     // checks if the document supports the checked query selector
    //     test.innerHTML = '<select><option selected="selected">a</option></select>'
    //     return test.querySelectorAll(':checked').length === 1
    // },

    // TODO: use this ?

    // EMPTY_ATTRIBUTE_QUERY_SELECTOR: function(test){
    //
    //     // checks if the document supports the empty attribute query selector
    //     test.innerHTML = '<a class=""></a>'
    //     return test.querySelectorAll('[class*=""]').length === 1
    // },

    MATCHES_SELECTOR: function(test){

        test.className = "MiX"

        // checks if the document has matchesSelector, and we can use it.

        var matches = test.matchesSelector || test.mozMatchesSelector || test.webkitMatchesSelector

        // if matchesSelector trows errors on incorrect syntax we can use it
        if (matches) try {
            matches.call(test, ':slick')
        } catch(e){
            // just as a safety precaution, also test if it works on mixedcase (like querySelectorAll)
            return matches.call(test, ".MiX") ? matches : false
        }

        return false
    },

    GET_ELEMENTS_BY_CLASS_NAME: function(test){
        test.innerHTML = '<a class="f"></a><a class="b"></a>'
        if (test.getElementsByClassName('b').length !== 1) return false

        test.firstChild.className = 'b'
        if (test.getElementsByClassName('b').length !== 2) return false

        // Opera 9.6 getElementsByClassName doesnt detects the class if its not the first one
        test.innerHTML = '<a class="a"></a><a class="f b a"></a>'
        if (test.getElementsByClassName('a').length !== 2) return false

        // tests passed
        return true
    },

    // no need to know

    // GET_ELEMENT_BY_ID_NOT_NAME: function(test, id){
    //     test.innerHTML = '<a name="'+ id +'"></a><b id="'+ id +'"></b>'
    //     return this.getElementById(id) !== test.firstChild
    // },

    // this is always checked for and fixed

    // STAR_GET_ELEMENTS_BY_TAG_NAME: function(test){
    //
    //     // IE returns comment nodes for getElementsByTagName('*') for some documents
    //     test.appendChild(this.createComment(''))
    //     if (test.getElementsByTagName('*').length > 0) return false
    //
    //     // IE returns closed nodes (EG:"</foo>") for getElementsByTagName('*') for some documents
    //     test.innerHTML = 'foo</foo>'
    //     if (test.getElementsByTagName('*').length) return false
    //
    //     // tests passed
    //     return true
    // },

    // this is always checked for and fixed

    // STAR_QUERY_SELECTOR: function(test){
    //
    //     // returns closed nodes (EG:"</foo>") for querySelector('*') for some documents
    //     test.innerHTML = 'foo</foo>'
    //     return !!(test.querySelectorAll('*').length)
    // },

    GET_ATTRIBUTE: function(test){
        // tests for working getAttribute implementation
        var shout = "fus ro dah"
        test.innerHTML = '<a class="' + shout + '"></a>'
        return test.firstChild.getAttribute('class') === shout
    }

}

// Finder

var Finder = function Finder(document){

    this.document        = document
    var root = this.root = document.documentElement
    this.tested          = {}

    // uniqueID

    this.uniqueID = this.has("EXPANDOS") ? uniqueID : uniqueIDXML

    // getAttribute

    this.getAttribute = (this.has("GET_ATTRIBUTE")) ? function(node, name){

        return node.getAttribute(name)

    } : function(node, name){

        node = node.getAttributeNode(name)
        return (node && node.specified) ? node.value : null

    }

    // hasAttribute

    this.hasAttribute = (root.hasAttribute) ? function(node, attribute){

        return node.hasAttribute(attribute)

    } : function(node, attribute) {

        node = node.getAttributeNode(attribute)
        return !!(node && node.specified)

    }

    // contains

    this.contains = (document.contains && root.contains) ? function(context, node){

        return context.contains(node)

    } : (root.compareDocumentPosition) ? function(context, node){

        return context === node || !!(context.compareDocumentPosition(node) & 16)

    } : function(context, node){

        do {
            if (node === context) return true
        } while ((node = node.parentNode))

        return false
    }

    // sort
    // credits to Sizzle (http://sizzlejs.com/)

    this.sorter = (root.compareDocumentPosition) ? function(a, b){

        if (!a.compareDocumentPosition || !b.compareDocumentPosition) return 0
        return a.compareDocumentPosition(b) & 4 ? -1 : a === b ? 0 : 1

    } : ('sourceIndex' in root) ? function(a, b){

        if (!a.sourceIndex || !b.sourceIndex) return 0
        return a.sourceIndex - b.sourceIndex

    } : (document.createRange) ? function(a, b){

        if (!a.ownerDocument || !b.ownerDocument) return 0
        var aRange = a.ownerDocument.createRange(),
            bRange = b.ownerDocument.createRange()

        aRange.setStart(a, 0)
        aRange.setEnd(a, 0)
        bRange.setStart(b, 0)
        bRange.setEnd(b, 0)
        return aRange.compareBoundaryPoints(Range.START_TO_END, bRange)

    } : null

    this.failed = {}

    var nativeMatches = this.has("MATCHES_SELECTOR")

    if (nativeMatches) this.matchesSelector = function(node, expression){

        if (this.failed[expression]) return null

        try {
            return nativeMatches.call(node, expression)
        } catch(e){
            if (slick.debug) console.warn("matchesSelector failed on " + expression)
            this.failed[expression] = true
            return null
        }

    }

    if (this.has("QUERY_SELECTOR")){

        this.querySelectorAll = function(node, expression){

            if (this.failed[expression]) return true

            var result, _id, _expression, _combinator, _node


            // non-document rooted QSA
            // credits to Andrew Dupont

            if (node !== this.document){

                _combinator = expression[0].combinator

                _id         = node.getAttribute("id")
                _expression = expression

                if (!_id){
                    _node = node
                    _id = "__slick__"
                    _node.setAttribute("id", _id)
                }

                expression = "#" + _id + " " + _expression


                // these combinators need a parentNode due to how querySelectorAll works, which is:
                // finding all the elements that match the given selector
                // then filtering by the ones that have the specified element as an ancestor
                if (_combinator.indexOf("~") > -1 || _combinator.indexOf("+") > -1){

                    node = node.parentNode
                    if (!node) result = true
                    // if node has no parentNode, we return "true" as if it failed, without polluting the failed cache

                }

            }

            if (!result) try {
                result = node.querySelectorAll(expression.toString())
            } catch(e){
                if (slick.debug) console.warn("querySelectorAll failed on " + (_expression || expression))
                result = this.failed[_expression || expression] = true
            }

            if (_node) _node.removeAttribute("id")

            return result

        }

    }

}

Finder.prototype.has = function(FEATURE){

    var tested        = this.tested,
        testedFEATURE = tested[FEATURE]

    if (testedFEATURE != null) return testedFEATURE

    var root     = this.root,
        document = this.document,
        testNode = document.createElement("div")

    testNode.setAttribute("style", "display: none;")

    root.appendChild(testNode)

    var TEST = HAS[FEATURE], result = false

    if (TEST) try {
        result = TEST.call(document, testNode)
    } catch(e){}

    if (slick.debug && !result) console.warn("document has no " + FEATURE)

    root.removeChild(testNode)

    return tested[FEATURE] = result

}

var combinators = {

    " ": function(node, part, push){

        var item, items

        var noId = !part.id, noTag = !part.tag, noClass = !part.classes

        if (part.id && node.getElementById && this.has("GET_ELEMENT_BY_ID")){
            item = node.getElementById(part.id)

            // return only if id is found, else keep checking
            // might be a tad slower on non-existing ids, but less insane

            if (item && item.getAttribute('id') === part.id){
                items = [item]
                noId = true
                // if tag is star, no need to check it in match()
                if (part.tag === "*") noTag = true
            }
        }

        if (!items){

            if (part.classes && node.getElementsByClassName && this.has("GET_ELEMENTS_BY_CLASS_NAME")){
                items = node.getElementsByClassName(part.classList)
                noClass = true
                // if tag is star, no need to check it in match()
                if (part.tag === "*") noTag = true
            } else {
                items = node.getElementsByTagName(part.tag)
                // if tag is star, need to check it in match because it could select junk, boho
                if (part.tag !== "*") noTag = true
            }

            if (!items || !items.length) return false

        }

        for (var i = 0; item = items[i++];)
            if ((noTag && noId && noClass && !part.attributes && !part.pseudos) || this.match(item, part, noTag, noId, noClass))
                push(item)

        return true

    },

    ">": function(node, part, push){ // direct children
        if ((node = node.firstChild)) do {
            if (node.nodeType == 1 && this.match(node, part)) push(node)
        } while ((node = node.nextSibling))
    },

    "+": function(node, part, push){ // next sibling
        while ((node = node.nextSibling)) if (node.nodeType == 1){
            if (this.match(node, part)) push(node)
            break
        }
    },

    "^": function(node, part, push){ // first child
        node = node.firstChild
        if (node){
            if (node.nodeType === 1){
                if (this.match(node, part)) push(node)
            } else {
                combinators['+'].call(this, node, part, push)
            }
        }
    },

    "~": function(node, part, push){ // next siblings
        while ((node = node.nextSibling)){
            if (node.nodeType === 1 && this.match(node, part)) push(node)
        }
    },

    "++": function(node, part, push){ // next sibling and previous sibling
        combinators['+'].call(this, node, part, push)
        combinators['!+'].call(this, node, part, push)
    },

    "~~": function(node, part, push){ // next siblings and previous siblings
        combinators['~'].call(this, node, part, push)
        combinators['!~'].call(this, node, part, push)
    },

    "!": function(node, part, push){ // all parent nodes up to document
        while ((node = node.parentNode)) if (node !== this.document && this.match(node, part)) push(node)
    },

    "!>": function(node, part, push){ // direct parent (one level)
        node = node.parentNode
        if (node !== this.document && this.match(node, part)) push(node)
    },

    "!+": function(node, part, push){ // previous sibling
        while ((node = node.previousSibling)) if (node.nodeType == 1){
            if (this.match(node, part)) push(node)
            break
        }
    },

    "!^": function(node, part, push){ // last child
        node = node.lastChild
        if (node){
            if (node.nodeType == 1){
                if (this.match(node, part)) push(node)
            } else {
                combinators['!+'].call(this, node, part, push)
            }
        }
    },

    "!~": function(node, part, push){ // previous siblings
        while ((node = node.previousSibling)){
            if (node.nodeType === 1 && this.match(node, part)) push(node)
        }
    }

}

Finder.prototype.search = function(context, expression, found){

    if (!context) context = this.document
    else if (!context.nodeType && context.document) context = context.document

    var expressions = parse(expression)

    // no expressions were parsed. todo: is this really necessary?
    if (!expressions || !expressions.length) throw new Error("invalid expression")

    if (!found) found = []

    var uniques, push = isArray(found) ? function(node){
        found[found.length] = node
    } : function(node){
        found[found.length++] = node
    }

    // if there is more than one expression we need to check for duplicates when we push to found
    // this simply saves the old push and wraps it around an uid dupe check.
    if (expressions.length > 1){
        uniques = {}
        var plush = push
        push = function(node){
            var uid = uniqueID(node)
            if (!uniques[uid]){
                uniques[uid] = true
                plush(node)
            }
        }
    }

    // walker

    var node, nodes, part

    main: for (var i = 0; expression = expressions[i++];){

        // querySelector

        // TODO: more functional tests

        // if there is querySelectorAll (and the expression does not fail) use it.
        if (!slick.noQSA && this.querySelectorAll){

            nodes = this.querySelectorAll(context, expression)
            if (nodes !== true){
                if (nodes && nodes.length) for (var j = 0; node = nodes[j++];) if (node.nodeName > '@'){
                    push(node)
                }
                continue main
            }
        }

        // if there is only one part in the expression we don't need to check each part for duplicates.
        // todo: this might be too naive. while solid, there can be expression sequences that do not
        // produce duplicates. "body div" for instance, can never give you each div more than once.
        // "body div a" on the other hand might.
        if (expression.length === 1){

            part = expression[0]
            combinators[part.combinator].call(this, context, part, push)

        } else {

            var cs = [context], c, f, u, p = function(node){
                var uid = uniqueID(node)
                if (!u[uid]){
                    u[uid] = true
                    f[f.length] = node
                }
            }

            // loop the expression parts
            for (var j = 0; part = expression[j++];){
                f = []; u = {}
                // loop the contexts
                for (var k = 0; c = cs[k++];) combinators[part.combinator].call(this, c, part, p)
                // nothing was found, the expression failed, continue to the next expression.
                if (!f.length) continue main
                cs = f // set the contexts for future parts (if any)
            }

            if (i === 0) found = f // first expression. directly set found.
            else for (var l = 0; l < f.length; l++) push(f[l]) // any other expression needs to push to found.
        }

    }

    if (uniques && found && found.length > 1) this.sort(found)

    return found

}

Finder.prototype.sort = function(nodes){
    return this.sorter ? Array.prototype.sort.call(nodes, this.sorter) : nodes
}

// TODO: most of these pseudo selectors include <html> and qsa doesnt. fixme.

var pseudos = {


    // TODO: returns different results than qsa empty.

    'empty': function(){
        return !(this && this.nodeType === 1) && !(this.innerText || this.textContent || '').length
    },

    'not': function(expression){
        return !slick.matches(this, expression)
    },

    'contains': function(text){
        return (this.innerText || this.textContent || '').indexOf(text) > -1
    },

    'first-child': function(){
        var node = this
        while ((node = node.previousSibling)) if (node.nodeType == 1) return false
        return true
    },

    'last-child': function(){
        var node = this
        while ((node = node.nextSibling)) if (node.nodeType == 1) return false
        return true
    },

    'only-child': function(){
        var prev = this
        while ((prev = prev.previousSibling)) if (prev.nodeType == 1) return false

        var next = this
        while ((next = next.nextSibling)) if (next.nodeType == 1) return false

        return true
    },

    'first-of-type': function(){
        var node = this, nodeName = node.nodeName
        while ((node = node.previousSibling)) if (node.nodeName == nodeName) return false
        return true
    },

    'last-of-type': function(){
        var node = this, nodeName = node.nodeName
        while ((node = node.nextSibling)) if (node.nodeName == nodeName) return false
        return true
    },

    'only-of-type': function(){
        var prev = this, nodeName = this.nodeName
        while ((prev = prev.previousSibling)) if (prev.nodeName == nodeName) return false
        var next = this
        while ((next = next.nextSibling)) if (next.nodeName == nodeName) return false
        return true
    },

    'enabled': function(){
        return !this.disabled
    },

    'disabled': function(){
        return this.disabled
    },

    'checked': function(){
        return this.checked || this.selected
    },

    'selected': function(){
        return this.selected
    },

    'focus': function(){
        var doc = this.ownerDocument
        return doc.activeElement === this && (this.href || this.type || slick.hasAttribute(this, 'tabindex'))
    },

    'root': function(){
        return (this === this.ownerDocument.documentElement)
    }

}

Finder.prototype.match = function(node, bit, noTag, noId, noClass){

    // TODO: more functional tests ?

    if (!slick.noQSA && this.matchesSelector){
        var matches = this.matchesSelector(node, bit)
        if (matches !== null) return matches
    }

    // normal matching

    if (!noTag && bit.tag){

        var nodeName = node.nodeName.toLowerCase()
        if (bit.tag === "*"){
            if (nodeName < "@") return false
        } else if (nodeName != bit.tag){
            return false
        }

    }

    if (!noId && bit.id && node.getAttribute('id') !== bit.id) return false

    var i, part

    if (!noClass && bit.classes){

        var className = this.getAttribute(node, "class")
        if (!className) return false

        for (part in bit.classes) if (!RegExp('(^|\\s)' + bit.classes[part] + '(\\s|$)').test(className)) return false
    }

    var name, value

    if (bit.attributes) for (i = 0; part = bit.attributes[i++];){

        var operator  = part.operator,
            escaped   = part.escapedValue

        name  = part.name
        value = part.value

        if (!operator){

            if (!this.hasAttribute(node, name)) return false

        } else {

            var actual = this.getAttribute(node, name)
            if (actual == null) return false

            switch (operator){
                case '^=' : if (!RegExp(      '^' + escaped            ).test(actual)) return false; break
                case '$=' : if (!RegExp(            escaped + '$'      ).test(actual)) return false; break
                case '~=' : if (!RegExp('(^|\\s)' + escaped + '(\\s|$)').test(actual)) return false; break
                case '|=' : if (!RegExp(      '^' + escaped + '(-|$)'  ).test(actual)) return false; break

                case '='  : if (actual !== value) return false; break
                case '*=' : if (actual.indexOf(value) === -1) return false; break
                default   : return false
            }

        }
    }

    if (bit.pseudos) for (i = 0; part = bit.pseudos[i++];){

        name  = part.name
        value = part.value

        if (pseudos[name]) return pseudos[name].call(node, value)

        if (value != null){
            if (this.getAttribute(node, name) !== value) return false
        } else {
            if (!this.hasAttribute(node, name)) return false
        }

    }

    return true

}

Finder.prototype.matches = function(node, expression){

    var expressions = parse(expression)

    if (expressions.length === 1 && expressions[0].length === 1){ // simplest match
        return this.match(node, expressions[0][0])
    }

    // TODO: more functional tests ?

    if (!slick.noQSA && this.matchesSelector){
        var matches = this.matchesSelector(node, expressions)
        if (matches !== null) return matches
    }

    var nodes = this.search(this.document, expression, {length: 0})

    for (var i = 0, res; res = nodes[i++];) if (node === res) return true
    return false

}

var finders = {}

var finder = function(context){
    var doc = context || document
    if (doc.ownerDocument) doc = doc.ownerDocument
    else if (doc.document) doc = doc.document

    if (doc.nodeType !== 9) throw new TypeError("invalid document")

    var uid = uniqueID(doc)
    return finders[uid] || (finders[uid] = new Finder(doc))
}

// ... API ...

var slick = function(expression, context){
    return slick.search(expression, context)
}

slick.search = function(expression, context, found){
    return finder(context).search(context, expression, found)
}

slick.find = function(expression, context){
    return finder(context).search(context, expression)[0] || null
}

slick.getAttribute = function(node, name){
    return finder(node).getAttribute(node, name)
}

slick.hasAttribute = function(node, name){
    return finder(node).hasAttribute(node, name)
}

slick.contains = function(context, node){
    return finder(context).contains(context, node)
}

slick.matches = function(node, expression){
    return finder(node).matches(node, expression)
}

slick.sort = function(nodes){
    if (nodes && nodes.length > 1) finder(nodes[0]).sort(nodes)
    return nodes
}

slick.parse = parse;

// slick.debug = true
// slick.noQSA  = true

module.exports = slick

},{"./parser":713}],712:[function(require,module,exports){
(function (global){
/*
slick
*/"use strict"

module.exports = "document" in global ? require("./finder") : { parse: require("./parser") }

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./finder":711,"./parser":713}],713:[function(require,module,exports){
/*
Slick Parser
 - originally created by the almighty Thomas Aylott <@subtlegradient> (http://subtlegradient.com)
*/"use strict"

// Notable changes from Slick.Parser 1.0.x

// The parser now uses 2 classes: Expressions and Expression
// `new Expressions` produces an array-like object containing a list of Expression objects
// - Expressions::toString() produces a cleaned up expressions string
// `new Expression` produces an array-like object
// - Expression::toString() produces a cleaned up expression string
// The only exposed method is parse, which produces a (cached) `new Expressions` instance
// parsed.raw is no longer present, use .toString()
// parsed.expression is now useless, just use the indices
// parsed.reverse() has been removed for now, due to its apparent uselessness
// Other changes in the Expressions object:
// - classNames are now unique, and save both escaped and unescaped values
// - attributes now save both escaped and unescaped values
// - pseudos now save both escaped and unescaped values

var escapeRe   = /([-.*+?^${}()|[\]\/\\])/g,
    unescapeRe = /\\/g

var escape = function(string){
    // XRegExp v2.0.0-beta-3
    // « https://github.com/slevithan/XRegExp/blob/master/src/xregexp.js
    return (string + "").replace(escapeRe, '\\$1')
}

var unescape = function(string){
    return (string + "").replace(unescapeRe, '')
}

var slickRe = RegExp(
/*
#!/usr/bin/env ruby
puts "\t\t" + DATA.read.gsub(/\(\?x\)|\s+#.*$|\s+|\\$|\\n/,'')
__END__
    "(?x)^(?:\
      \\s* ( , ) \\s*               # Separator          \n\
    | \\s* ( <combinator>+ ) \\s*   # Combinator         \n\
    |      ( \\s+ )                 # CombinatorChildren \n\
    |      ( <unicode>+ | \\* )     # Tag                \n\
    | \\#  ( <unicode>+       )     # ID                 \n\
    | \\.  ( <unicode>+       )     # ClassName          \n\
    |                               # Attribute          \n\
    \\[  \
        \\s* (<unicode1>+)  (?:  \
            \\s* ([*^$!~|]?=)  (?:  \
                \\s* (?:\
                    ([\"']?)(.*?)\\9 \
                )\
            )  \
        )?  \\s*  \
    \\](?!\\]) \n\
    |   :+ ( <unicode>+ )(?:\
    \\( (?:\
        (?:([\"'])([^\\12]*)\\12)|((?:\\([^)]+\\)|[^()]*)+)\
    ) \\)\
    )?\
    )"
*/
"^(?:\\s*(,)\\s*|\\s*(<combinator>+)\\s*|(\\s+)|(<unicode>+|\\*)|\\#(<unicode>+)|\\.(<unicode>+)|\\[\\s*(<unicode1>+)(?:\\s*([*^$!~|]?=)(?:\\s*(?:([\"']?)(.*?)\\9)))?\\s*\\](?!\\])|(:+)(<unicode>+)(?:\\((?:(?:([\"'])([^\\13]*)\\13)|((?:\\([^)]+\\)|[^()]*)+))\\))?)"
    .replace(/<combinator>/, '[' + escape(">+~`!@$%^&={}\\;</") + ']')
    .replace(/<unicode>/g, '(?:[\\w\\u00a1-\\uFFFF-]|\\\\[^\\s0-9a-f])')
    .replace(/<unicode1>/g, '(?:[:\\w\\u00a1-\\uFFFF-]|\\\\[^\\s0-9a-f])')
)

// Part

var Part = function Part(combinator){
    this.combinator = combinator || " "
    this.tag = "*"
}

Part.prototype.toString = function(){

    if (!this.raw){

        var xpr = "", k, part

        xpr += this.tag || "*"
        if (this.id) xpr += "#" + this.id
        if (this.classes) xpr += "." + this.classList.join(".")
        if (this.attributes) for (k = 0; part = this.attributes[k++];){
            xpr += "[" + part.name + (part.operator ? part.operator + '"' + part.value + '"' : '') + "]"
        }
        if (this.pseudos) for (k = 0; part = this.pseudos[k++];){
            xpr += ":" + part.name
            if (part.value) xpr += "(" + part.value + ")"
        }

        this.raw = xpr

    }

    return this.raw
}

// Expression

var Expression = function Expression(){
    this.length = 0
}

Expression.prototype.toString = function(){

    if (!this.raw){

        var xpr = ""

        for (var j = 0, bit; bit = this[j++];){
            if (j !== 1) xpr += " "
            if (bit.combinator !== " ") xpr += bit.combinator + " "
            xpr += bit
        }

        this.raw = xpr

    }

    return this.raw
}

var replacer = function(
    rawMatch,

    separator,
    combinator,
    combinatorChildren,

    tagName,
    id,
    className,

    attributeKey,
    attributeOperator,
    attributeQuote,
    attributeValue,

    pseudoMarker,
    pseudoClass,
    pseudoQuote,
    pseudoClassQuotedValue,
    pseudoClassValue
){

    var expression, current

    if (separator || !this.length){
        expression = this[this.length++] = new Expression
        if (separator) return ''
    }

    if (!expression) expression = this[this.length - 1]

    if (combinator || combinatorChildren || !expression.length){
        current = expression[expression.length++] = new Part(combinator)
    }

    if (!current) current = expression[expression.length - 1]

    if (tagName){

        current.tag = unescape(tagName)

    } else if (id){

        current.id = unescape(id)

    } else if (className){

        var unescaped = unescape(className)

        var classes = current.classes || (current.classes = {})
        if (!classes[unescaped]){
            classes[unescaped] = escape(className)
            var classList = current.classList || (current.classList = [])
            classList.push(unescaped)
            classList.sort()
        }

    } else if (pseudoClass){

        pseudoClassValue = pseudoClassValue || pseudoClassQuotedValue

        ;(current.pseudos || (current.pseudos = [])).push({
            type         : pseudoMarker.length == 1 ? 'class' : 'element',
            name         : unescape(pseudoClass),
            escapedName  : escape(pseudoClass),
            value        : pseudoClassValue ? unescape(pseudoClassValue) : null,
            escapedValue : pseudoClassValue ? escape(pseudoClassValue) : null
        })

    } else if (attributeKey){

        attributeValue = attributeValue ? escape(attributeValue) : null

        ;(current.attributes || (current.attributes = [])).push({
            operator     : attributeOperator,
            name         : unescape(attributeKey),
            escapedName  : escape(attributeKey),
            value        : attributeValue ? unescape(attributeValue) : null,
            escapedValue : attributeValue ? escape(attributeValue) : null
        })

    }

    return ''

}

// Expressions

var Expressions = function Expressions(expression){
    this.length = 0

    var self = this

    var original = expression, replaced

    while (expression){
        replaced = expression.replace(slickRe, function(){
            return replacer.apply(self, arguments)
        })
        if (replaced === expression) throw new Error(original + ' is an invalid expression')
        expression = replaced
    }
}

Expressions.prototype.toString = function(){
    if (!this.raw){
        var expressions = []
        for (var i = 0, expression; expression = this[i++];) expressions.push(expression)
        this.raw = expressions.join(", ")
    }

    return this.raw
}

var cache = {}

var parse = function(expression){
    if (expression == null) return null
    expression = ('' + expression).replace(/^\s+|\s+$/g, '')
    return cache[expression] || (cache[expression] = new Expressions(expression))
}

module.exports = parse

},{}],714:[function(require,module,exports){

/**
 * `Batch' constructor
 *
 * @api public
 * @param {Number} max - optional (Default: Infinity)
 */

module.exports = Batch;
function Batch (max) {
  if (!(this instanceof Batch)) {
    return new Batch(max);
  }

  var self = this;

  this.m = 0; // max
  this.c = 0; // concurrency
  this.jobs = [];

  this.concurrency(Infinity);
  this.max(max);

  Object.defineProperty(this, 'length', {
    get: function () {
      return self.jobs.length;
    }
  });
}

/**
 * Set batch concurrency
 *
 * @api public
 * @param {Number} n
 */

Batch.prototype.concurrency = function (n) {
  if (n > 0) {
    this.c = n;
  }
  return this;
};

/**
 * Set max job limit
 *
 * @api publc
 * @param {Number} n
 */

Batch.prototype.max = function (n) {
  this.m = 'number' == typeof n && n > 0 ? n : Infinity;
  return this;
};

/**
 * Push job onto queue
 *
 * @api publc
 * @param {Function} fn
 */

Batch.prototype.push = function (fn) {
  if ('function' != typeof fn) {
    throw new TypeError("expecting a function");
  } else if (this.length < this.m) {
    this.jobs.push(fn);
  }
  return this;
};

/**
 * Shift job off of queue
 *
 * @api public
 */

Batch.prototype.shift = function () {
  return this.jobs.shift();
};

/**
 * Dequeues all queued jobs
 *
 * @api public
 * @param {Function} done - optional
 */

Batch.prototype.run = function (done) {
  done = 'function' == typeof done ? done : Function();
  var self = this;
  var c = this.c;
  var i = 0;

  // empty queue
  if (0 == this.length) {
    return done(null);
  }

  function dequeue  () {
    var job = null;
    if (0 == self.length) {
      return false;
    }

    job = self.shift();

    if ('function' != typeof job) {
      return;
    }

    try { job(next); }
    catch (err) {
      done(err)
      return false;
    }

    function next (err) {
      if (err) {
        done(err);
      } else if (self.length) {
        dequeue();
      } else {
        done();
      }
    }
  }

  while (i++ < c) {
    if (false === dequeue()) {
      break;
    }
  }

  return this;
};

},{}],715:[function(require,module,exports){
/*jslint node: true */

'use strict';

var ClientRequest = require('./request').ClientRequest;

/**
 * An autoincremented id that is used to distinguish Resolver instances.
 *
 * @type {number}
 * @private
 */
var resolverUID = 0;

/**
 * A resolver takes a request for a resources and sends it through the
 * transport.
 *
 * @constructs Resolver
 */
function Resolver() {
  if (!(this instanceof Resolver))
    return new Resolver();

  /**
   * The resolver's id.
   *
   * @type {number}
   * @protected
   */
  this._id = resolverUID++;

  /**
   * An incrementing ID used for tracking requests.
   *
   * @type {number}
   * @protected
   */
  this._requestID = 0;

  /**
   * Storage for the sent request handlers waiting for a response.
   *
   * @type {Object.<string, function>}
   * @protected
   */
  this._handlers = {};
}
exports.Resolver = Resolver;

/**
 * Adds a handler to the internal storage.
 *
 * @param {number} requestID The identifier for the request.
 * @param {ClientRequest} handler The handler for the request.
 * @protected
 */
Resolver.prototype._addHandler = function(requestID, handler) {
  this._handlers[requestID] = handler;
  return this;
};

/**
 * Removes a handler from the internal storage.
 *
 * @param {number} requestID The identifier for the request.
 * @protected
 */
Resolver.prototype._removeHandler = function(requestID) {
  this._handlers[requestID] = null;
  return this;
};

/**
 * Sends a request through the transport.
 *
 * Subclasses of this class need to implement this method.
 *
 * @param {number} requestID The id of the request.
 * @param {Object} data The payload data for the request.
 * @protected
 */
Resolver.prototype._sendRequest = function(requestID, data) {
  throw new Error('Resolver _sendRequest not implemented.');
};

/**
 * Handles a response from the transport.
 *
 * @param {Object} response The response from the transport.
 * @protected
 */
Resolver.prototype._handleResponse = function(response) {
  throw new Error('Resolver _handleResponse not implemented.');
};

/**
 * Dispatches a request handler with some data.
 *
 * @param {number} requestID The request handler to dispatch.
 * @param {Object} data The response data to send back.
 * @protected
 */
Resolver.prototype._dispatchResponse = function(requestID, requestType, data) {
  var handler = this._handlers[requestID];
  if (!handler) return;
  handler._handleResponse(requestType, data);
};

/**
 * Resolves a request (represented by the data) through the transport.
 *
 * @param {Object} data The data representing the request.
 * @param {function} onsuccess The success handler for the request.
 * @param {function} onerror The error handler for the request.
 */
Resolver.prototype._resolve = function(data, onsuccess, onerror) {
  if (!data || !onsuccess || !onerror ||
      typeof onsuccess != 'function' || typeof onerror != 'function')
    throw new TypeError('Invalid argument length for `resolve`.');

  var requestID = ++this._requestID;
  var request = new ClientRequest(this, requestID, data, onsuccess, onerror);

  this._addHandler(requestID, request);

  request.onClose = this._removeHandler.bind(this);
  request.open();

  return request;
};

/**
 * Resolves a single request (represented by the data) through the transport.
 *
 * @param {Object} data The data representing the request.
 * @param {function} onsuccess The success handler for the request.
 * @param {function} onerror The error handler for the request.
 */
Resolver.prototype.resolve = function(data, onsuccess, onerror) {
  throw new Error('Resolver resolve not implemented.');
};

/**
 * Resolves a subscription request (represented by the data) through the transport.
 *
 * @param {Object} data The data representing the request.
 * @param {function} onsuccess The success handler for the request.
 * @param {function} onerror The error handler for the request.
 */
Resolver.prototype.subscribe = function(data, onsuccess, onerror) {
  throw new Error('Resolver subscribe not implemented.');
};

},{"./request":719}],716:[function(require,module,exports){
(function (global){
/*jslint node: true */

'use strict';

var defer = require('spotify-deferred');
var Resolver = require('./bootstrap').Resolver;

/**
 * A mock resolver for a nodejs environment.
 *
 * This resolver uses regular callbacks as a transport.
 *
 * @constructs Cosmos.MockResolver
 * @extends Cosmos.Resolver
 */
function MockResolver() {
  if (!(this instanceof MockResolver))
    return new MockResolver();
  Resolver.call(this);

  // rebind the _handleResponse method so that we can reuse it for both
  // addEventListener and removeEventListener
  this._handleResponse = this._handleResponse.bind(this);

  /**
   * The identifier for request messages.
   *
   * @type {string}
   * @protected
   */
  this._requestMessageType = 'cosmos-request';

  /**
   * The identifier for response messages.
   *
   * @type {string}
   * @protected
   */
  this._responseMessageType = 'cosmos-response';

  /**
   * Prefix for the requests ids to prevent clashes
   * with bridge requests in webplayer
   *
   * @type {string}
   * @private
   */
  this._requestIdPrefix = 'cosmos_';

  this._handlersMap = {};

  // attach the handler
  this.attach();
}
MockResolver.prototype = new Resolver();
MockResolver.prototype.constructor = MockResolver;
exports.MockResolver = MockResolver;

/**
 * @inheritDoc
 */
MockResolver.prototype._sendRequest = function(requestName, requestID, data) {
  var self = this;

  var message = {
    type: this._requestMessageType,
    resolver: this._id,
    id: this._requestIdPrefix + requestID,
    name: requestName,
    payload: data.serialize ? data.serialize() : data
  };

  if (!this._handlersMap[data._action]) {
    return;
  }

  if (!this._handlersMap[data._action][data._uri]) {
    return;
  }

  this._handlersMap[data._action][data._uri](data, function (status, resp) {
    message.payload = {
      body: typeof resp !== 'undefined' ? resp : status,
      uri: data._uri,
      status: typeof resp !== 'undefined' ? status : 200
    };
    message.type = self._responseMessageType;

    var response = {
      data: message
    };
    self._handleResponse(response);
  });
};

/**
 * @inheritDoc
 */
MockResolver.prototype._handleResponse = function(response) {
  var data = response.data;
  if (typeof data == 'string') {
    try {
      data = JSON.parse(response.data);
    } catch (e) {
      return;
    }
  }
  if (data.type != this._responseMessageType ||
      data.resolver != this._id ||
      !data.payload) return;
  var id = data.id || '';
  var requestID = parseInt(id.replace(this._requestIdPrefix, ''), 10);
  var requestName = data.name || '';
  if (!requestID || !requestName) return;
  this._dispatchResponse(requestID, requestName, data.payload);
};

/**
 * Attaches the resolver so that it could process calls from the window object.
 */
MockResolver.prototype.attach = function() {
  var win = global.window;
  if (win) {
    win._cosmosRequest = this.resolve.bind(this);
  }
};

/**
 * Detaches the resolver so that it doesn't process calls from the window object.
 */
MockResolver.prototype.detach = function() {
  var win = global.window;
  if (win) {
    delete win._cosmosRequest;
  }
};

/**
 * Specific method for the mock resolver to add request handlers
 *
 * @param {string}   method       Type of method (GET, POST, PUT, SUB)
 * @param {string}   uri          Request to handle
 * @param {Function} fn           Function that handles the request
 */
MockResolver.prototype.addHandler = function(method, uri, fn) {
  if (!this._handlersMap[method]) {
    this._handlersMap[method] = {};
  }

  this._handlersMap[method][uri] = fn;
};

/**
 * Specific method for the mock resolver to remove a specific request handler
 *
 * @param {string}   method       Type of method (GET, POST, PUT, SUB)
 * @param {string}   uri          Request to handle
 */
MockResolver.prototype.removeHandler = function(method, uri) {
  if (!this._handlersMap[method]) {
    return;
  }

  if (this._handlersMap[method][uri]) {
    delete this._handlersMap[method][uri];
  }
};

/**
 * Specific method for the mock resolver to remove all handlers
 */
MockResolver.prototype.clearHandlers = function() {
  this._handlersMap = {};
};

/**
 * Resolves a single request (represented by the data) through the transport.
 * Single requests need to be closed immediately after the response is
 * received.
 *
 * @param {Object} data The data representing the request.
 * @param {function} onsuccess The success handler for the request.
 * @param {function} onerror The error handler for the request.
 */
MockResolver.prototype.resolve = function(data, onsuccess, onerror) {
  function onResult(callback, response) {
    defer(callback.bind(this, response));
    request.close();
  }

  var request = this._resolve(data, onResult.bind(this, onsuccess), onResult.bind(this, onerror));
  return request;
};

/**
 * Resolves a  subscription request (represented by the data) through the transport.
 * Subscriptions stay open until they're explicitly closed.
 * Every time the request returns some data pull for next
 * batch is sent.
 *
 * @param {Object} data The data representing the request.
 * @param {function} onsuccess The success handler for the request.
 * @param {function} onerror The error handler for the request.
 */
MockResolver.prototype.subscribe = function(data, onsuccess, onerror) {
  return this._resolve(data, onsuccess, onerror);
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./bootstrap":715,"spotify-deferred":721}],717:[function(require,module,exports){
/*jslint node: true */

'use strict';

var Resolver = require('./bootstrap').Resolver;
var defer = require('spotify-deferred');

/**
 * A resolver for a native environment.
 *
 * This resolver uses the Stitch bridge as a transport
 *
 * @constructs Cosmos.NativeResolver
 * @extends Cosmos.Resolver
 * @param {Object} spBridge Spotify CPP/JS bridge
 */
function NativeResolver(spBridge) {
  if (!(this instanceof NativeResolver))
    return new NativeResolver();
  if (!spBridge) {
    throw new TypeError('Missing `spBridge` parameter');
  }
  Resolver.call(this);

  this._bridge = spBridge;
}
NativeResolver.prototype = new Resolver();
NativeResolver.prototype.constructor = NativeResolver;
exports.NativeResolver = NativeResolver;

/**
 * Defer the function call.
 * TODO: Move to the separate module
 */
NativeResolver.prototype._defer = function(context, callback) {
  defer(callback.bind(context));
};

/**
 * Construct and send Cosmos message.
 */
NativeResolver.prototype._sendRequest = function(requestName, requestId, data) {
  var self = this;
  data = (data.serialize ? data.serialize() : data);

  var args = [requestId, data];
  var caller = { self: this, id: requestId, type: requestName };

  this._sendCosmosRequest(requestName, args, caller, this._handleResponse, this._handleError);
};


/**
 * Talk to bridge directly from Cosmos
 * TODO: Move to the separate module
 */
NativeResolver.prototype._sendCosmosRequest = function(requestName, args, caller, onSuccess, onError) {
  var message = JSON.stringify({
    name: requestName,
    args: args
  });

  this._sendBridgeRequest(message, {
    onSuccess: function(data) {
      onSuccess.call(caller, JSON.parse(data));
    },
    onFailure: function(data) {
      data = JSON.parse(data);
      onError.call(caller, data);
    }
  });
};

/**
 * Send message to the bridge
 * @param {string} message The message to send to the bridge.
 * @param {Object.<string, function>} callbackMap The `onSuccess`
 * and `onFailure` functions to be executed after request is completed.
 * TODO: Use proxy that will handle Cosmos/Stitch calls for the resolver.
 */
NativeResolver.prototype._sendBridgeRequest = function(message, callbackMap) {
  this._bridge.executeRequest(message, callbackMap || {});
};

/**
 * Handles successful responses from the bridge
 * @param {Object} data The response data.
 */
NativeResolver.prototype._handleResponse = function(data) {
  this.self._dispatchResponse(this.id, this.type, data.responses && data.responses[0] || data);
};

/**
 * Handles failed responses from the bridge
 * @param {Object} error The error data.
 */
NativeResolver.prototype._handleError = function(error) {
  this.self._dispatchResponse(this.id, this.type, error);
};

/**
 * Resolves a single request (represented by the data) through the transport.
 * Single requests need to be closed immediately after the response is
 * received.
 *
 * @param {Object} data The data representing the request.
 * @param {function} onsuccess The success handler for the request.
 * @param {function} onerror The error handler for the request.
 */
NativeResolver.prototype.resolve = function(data, onsuccess, onerror) {
  function onResult(callback, response) {
    this._defer(this, callback.bind(this, response));
    request.close();
  }

  var request = this._resolve(data, onResult.bind(this, onsuccess), onResult.bind(this, onerror));
  return request;
};

/**
 * Resolves a  subscription request (represented by the data) through the transport.
 * Subscriptions stay open until they're explicitly closed.
 * Every time the request returns some data pull for next
 * batch is sent.
 *
 * @param {Object} data The data representing the request.
 * @param {function} onsuccess The success handler for the request.
 * @param {function} onerror The error handler for the request.
 */
NativeResolver.prototype.subscribe = function(data, onsuccess, onerror) {
  function onResult(callback, response) {
    callback.call(this, response);
    request.pull();
  }

  var request = this._resolve(data, onResult.bind(this, onsuccess), onResult.bind(this, onerror));
  return request;
};

},{"./bootstrap":715,"spotify-deferred":721}],718:[function(require,module,exports){
(function (global){
/*jslint node: true */

'use strict';

var defer = require('spotify-deferred');
var Resolver = require('./bootstrap').Resolver;

/**
 * A resolver for a web-based environment.
 *
 * This resolver uses postMessage as a transport.
 *
 * @constructs Cosmos.WebResolver
 * @extends Cosmos.Resolver
 * @type {string=} opt_target The optional target for the postMessage calls.
 */
function WebResolver(opt_target) {
  if (!(this instanceof WebResolver))
    return new WebResolver(opt_target);
  Resolver.call(this);

  /**
   * The target for postMessage calls.
   *
   * @type {string}
   * @protected
   */
  this._target = opt_target || '*';

  // rebind the _handleResponse method so that we can reuse it for both
  // addEventListener and removeEventListener
  this._handleResponse = this._handleResponse.bind(this);

  /**
   * The identifier for request messages.
   *
   * @type {string}
   * @protected
   */
  this._requestMessageType = 'cosmos-request';

  /**
   * The identifier for response messages.
   *
   * @type {string}
   * @protected
   */
  this._responseMessageType = 'cosmos-response';

  /**
   * Prefix for the requests ids to prevent clashes
   * with bridge requests in webplayer
   *
   * @type {string}
   * @private
   */
  this._requestIdPrefix = 'cosmos_';

  // attach the handler
  this.attach();
}
WebResolver.prototype = new Resolver();
WebResolver.prototype.constructor = WebResolver;
exports.WebResolver = WebResolver;

/**
 * @inheritDoc
 */
WebResolver.prototype._sendRequest = function(requestName, requestID, data) {
  var top = global.window.top;

  var message = {
    type: this._requestMessageType,
    resolver: this._id,
    id: this._requestIdPrefix + requestID,
    name: requestName,
    payload: data.serialize ? data.serialize() : data
  };
  top.postMessage(JSON.stringify(message), this._target);
};

/**
 * @inheritDoc
 */
WebResolver.prototype._handleResponse = function(response) {
  var data = response.data;
  if (typeof data == 'string') {
    try {
      data = JSON.parse(response.data);
    } catch (e) {
      return;
    }
  }
  if (data.type != this._responseMessageType ||
      data.resolver != this._id ||
      !data.payload) return;
  var id = data.id || '';
  var requestID = parseInt(id.replace(this._requestIdPrefix, ''), 10);
  var requestName = data.name || '';
  if (!requestID || !requestName) return;
  this._dispatchResponse(requestID, requestName, data.payload);
};

/**
 * Attaches the resolver so that it could process postMessage calls.
 */
WebResolver.prototype.attach = function() {
  var win = global.window;
  if (win.addEvent && !win.addEventListener) {
    win.addEvent('onmessage', this._handleResponse);
  } else {
    win.addEventListener('message', this._handleResponse, false);
  }
};

/**
 * Detaches the resolver so that it doesn't process postMessage calls.
 */
WebResolver.prototype.detach = function() {
  var win = global.window;
  if (win.removeEvent && !win.removeEventListener) {
    win.removeEvent('onmessage', this._handleResponse);
  } else {
    win.removeEventListener('message', this._handleResponse, false);
  }
};

/**
 * Resolves a single request (represented by the data) through the transport.
 * Single requests need to be closed immediately after the response is
 * received.
 *
 * @param {Object} data The data representing the request.
 * @param {function} onsuccess The success handler for the request.
 * @param {function} onerror The error handler for the request.
 */
WebResolver.prototype.resolve = function(data, onsuccess, onerror) {
  function onResult(callback, response) {
    defer(callback.bind(this, response));
    request.close();
  }

  var request = this._resolve(data, onResult.bind(this, onsuccess), onResult.bind(this, onerror));
  return request;
};

/**
 * Resolves a  subscription request (represented by the data) through the transport.
 * Subscriptions stay open until they're explicitly closed.
 * Every time the request returns some data pull for next
 * batch is sent.
 *
 * @param {Object} data The data representing the request.
 * @param {function} onsuccess The success handler for the request.
 * @param {function} onerror The error handler for the request.
 */
WebResolver.prototype.subscribe = function(data, onsuccess, onerror) {
  return this._resolve(data, onsuccess, onerror);
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./bootstrap":715,"spotify-deferred":721}],719:[function(require,module,exports){
/*jslint node: true */

'use strict';

var defer = require('spotify-deferred');

/**
 * The representation of the connection to the client.
 * With introduction of Cosmos subscription the model of making
 * client requests changed.
 * Each Cosmos requests now needs to be explicitly cancelled to
 * close the connection.
 * Simple requests that only send or retrieve data (e.g POST and GET)
 * need to send 'cosmos_request_cancel' message immediately after the response
 * is received.
 * Subscription requests need to send a 'cosmos_request_pull' message every time
 * they receive data. The consumer of the subscription needs to cancel the subscription
 * when no more data should be sent from the provider.
 */
function ClientRequest(resolver, requestId, data, onsuccess, onerror) {

  /**
   * Request identifier.
   * @type {number}
   */
  this._requestId = requestId;

  /**
   * Either web or native request resolver.
   * @type {Cosmos.Resolver}
   */
  this._resolver = resolver;

  /**
   * Data that should be passed with every request.
   * @type {*}
   */
  this._requestData = data;

  /**
   * Triggered on success
   * @type {function}
   */
  this._successCallback = onsuccess;

  /**
   * Triggered on error
   * @type {function}
   */
  this._errorCallback = onerror;

  /**
   * Current state of the request.
   * @type {ClientRequest.status}
   */
  this._status = ClientRequest.status.INITIALIZED;
}
exports.ClientRequest = ClientRequest;

/**
 * Possible state of the ClientRequest instance.
 */
ClientRequest.status = {
  INITIALIZED: 'INITIALIZED',
  CLOSED: 'CLOSED',
  OPEN: 'OPEN'
};

/**
 * Possible desktop bridge messages.
 */
ClientRequest.messages = {
  OPEN: 'cosmos_request_create',
  PULL: 'cosmos_request_pull',
  CLOSE: 'cosmos_request_cancel'
};

/**
 * Opens the connection with the client.
 */
ClientRequest.prototype.open = function() {
  if (this._status === ClientRequest.status.INITIALIZED) {
    this._status = ClientRequest.status.OPEN;
    this._sendRequest(ClientRequest.messages.OPEN, this._requestData);
  }
};

/**
 * Send pull request for the open connection.
 * For subscriptions pull should resolve to a
 * piece of data.
 */
ClientRequest.prototype.pull = function() {
  if (this._status === ClientRequest.status.OPEN) {
    this._sendRequest(ClientRequest.messages.PULL, this._requestData);
  }
  return this._status;
};

/**
 * Closes the connection with the client.
 */
ClientRequest.prototype.close = function() {
  if (this._status === ClientRequest.status.OPEN) {
    this._status = ClientRequest.status.CLOSE;
    this._sendRequest(ClientRequest.messages.CLOSE);
  }
};

ClientRequest.prototype.onClose = function() {};

/**
 * Sends the request to the platform specific resolver
 * @param {string} requestName The message type. One of the {ClientRequest.messages}.
 * @param {object?} data The data to send with the request.
 */
ClientRequest.prototype._sendRequest = function(requestName, data) {
  this._resolver._sendRequest(requestName, this._requestId, data || {});
};

/**
 * Handles the response for the given request
 * @param {String} requestName The message type. One of the {ClientRequest.messages}.
 * @param {Object} data The response data.
 */
ClientRequest.prototype._handleResponse = function(requestName, data) {
  var self = this;
  var status = data && data.status;
  var callback;

  if (requestName === ClientRequest.messages.CLOSE) {
    this._successCallback = null;
    this._errorCallback = null;
    this._requestData = null;
    this.onClose(this._requestId);
    return;
  }

  callback = this._successCallback;
  callback = typeof callback === 'function' ? callback : function() {};
  defer(callback.bind(this, data));
};

},{"spotify-deferred":721}],720:[function(require,module,exports){
(function (global){
'use strict';

var window = global.window || {};
var process = global.process;

var common = require('cosmos-common-js');
var Resolver = require('./scripts/resolver').Resolver;

var SPResolver = null;
var spResolver = null;

var hasNativeBridge = window._getSpotifyModule &&
    typeof window._getSpotifyModule === 'function' &&
    window._getSpotifyModule('bridge');

var nodeRegex = /(node)|(grunt)|(iojs)(\.exe)*$/;
var isNodeJs = process && process.title && nodeRegex.test(process.argv[0]);

if (!isNodeJs) {
  if (hasNativeBridge) {
    SPResolver = require('./env/bootstrap.native.js').NativeResolver;
    spResolver = new SPResolver(hasNativeBridge);
  } else {
    SPResolver = require('./env/bootstrap.web.js').WebResolver;
    spResolver = new SPResolver();
  }
} else {
  SPResolver = require('./env/bootstrap.mock.js').MockResolver;
  spResolver = new SPResolver();

  exports.mockResolver = {
    addHandler: spResolver.addHandler.bind(spResolver),
    removeHandler: spResolver.removeHandler.bind(spResolver),
    clearHandlers: spResolver.clearHandlers.bind(spResolver)
  };
}

exports.Resolver = Resolver;
exports.Action = common.request.Action;
exports.Request = common.request.Request;
exports.Response = common.response.Response;
exports.resolver = spResolver ? new Resolver(spResolver) : null;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./env/bootstrap.mock.js":716,"./env/bootstrap.native.js":717,"./env/bootstrap.web.js":718,"./scripts/resolver":722,"cosmos-common-js":377}],721:[function(require,module,exports){
(function() {
  /**
   * @file
   * Introduces a function called "defer" that allows functions to be
   * executed in the next available tick.
   *
   * Unlike "setTimeout", "defer" executes the function at the nearest
   * possible time without clamping.
   *
   * @see Spotify.defer
   */
  'use strict';

  var hasWindow = typeof window != 'undefined';
  var hasDefineProperty = typeof Object.defineProperty == 'function';

  if (hasWindow && window.__modDefFn) {
    // If deferred has been attached to the global scope
    module.exports = window.__modDefFn;
    return;
  }

  /**
   * Storage for deferred functions to be executed.
   *
   * @type {Array.<function()>}
   * @private
   */
  var deferred = [];


  /**
   * A bound version of the postMessage routine used to trigger deferred
   * execution.
   *
   * @type {function()}
   * @private
   */
  var send;
  var origin;

  if (hasWindow && window.postMessage) {
    origin = (window.location.origin ||
          window.location.protocol + '//' + window.location.hostname);
    send = window.postMessage.bind(window, '@execute_deferreds', origin);
    if (!window.__hasDeferredHandler) {
      if (hasDefineProperty) {
        Object.defineProperty(window, '__hasDeferredHandler', {value: 1});
      } else {
        window.__hasDeferredHandler = 1;
      }
      var handler = function(e) {
        if (e.origin != origin && e.data != '@execute_deferreds') {
          return;
        }
        executeDeferreds();
      };
      if (window.addEventListener) {
        window.addEventListener('message', handler);
      } else {
        window.attachEvent('onmessage', handler);
      }
    }
  } else if (typeof setImmediate != 'undefined') {
    send = setImmediate.bind(null, executeDeferreds);
  } else {
    send = setTimeout.bind(null, executeDeferreds, 10);
  }


  /**
   * Executes the deferred functions when the window
   * receives an 'execute_deferreds' message.
   *
   * @private
   */
  function executeDeferreds() {
    var fns = deferred.splice(0);
    if (!fns.length) return;
    for (var i = 0, l = fns.length; i < l; i++) {
      try {
        fns[i]();
      } finally {
        // Do nothing.
        null;
      }
    }
  }


  /**
   * Executes the function applied at the nearest possible time without
   * clamping.
   *
   * @param {function()} fn The function to execute.
   */
  var defer = function(fn) {
    var trigger = !deferred.length;
    deferred.push(fn);
    if (trigger) send();
  };

  if (hasWindow && !window.__modDefFn) {
    if (hasDefineProperty) {
      Object.defineProperty(window, '__modDefFn', {value: defer});
    } else {
      window.__modDefFn = defer;
    }
  }

  /**
   * Export public interface
   */
  module.exports = defer;

})();

},{}],722:[function(require,module,exports){
var common = require('cosmos-common-js');

var Request = common.request.Request;
var Action = common.request.Action;
var Response = common.response.Response;

/**
 * Checks whether a status is successful.
 *
 * We define a successful status to be something within the 200 to 299 range.
 *
 * @param {number} status The status to check.
 */
function _isSuccessStatus(status) {
  // This constitutes a successfull status.
  return (status >= 200 && status <= 299);
};


function Resolver(spResolver) {
  if (!spResolver || typeof spResolver.resolve !== 'function') {
    throw TypeError('Incorrect resolver argument');
  }

  this._resolver = spResolver;
}

/**
 * The basic, generic method of sending the requests.
 *
 * For params description:
 * @borrows Resolver#_resolve as Resolver#resolve
 */
Resolver.prototype.resolve = function(request, callback) {
  return this._resolve(request, callback);
};

/**
 * Convenience method for doing GET requests.
 * resolver.get('sp://player') is an equivalent of
 * resolver.resolve(new Request('GET', 'sp://player')).
 *
 * @param {string|Object.<string, object>} options If is a string
 * will be parsed as url. If more data is needed, object notation
 * should be used.
 *  param options.url {string} The url of the request.
 *  param options.body {object=} The request body.
 *  param options.headers {object=} The request headers.
 * @param {function(error=, object?)} callback The function
 * executed after the request has been completed.
 *
 * @return {RequestHandler} The cancellable request handler.
 */
Resolver.prototype.get = function(options, callback) {
  return this._resolveFromParams(Action.GET, options, callback);
};

/**
 * Convenience method for doing POST requests.
 * resolver.post('sp://player') is an equivalent of
 * resolver.resolve(new Request('POST', 'sp://player'))
 *
 * @see Resolver#get for params description and returned value.
 */
Resolver.prototype.post = function(options, callback) {
  return this._resolveFromParams(Action.POST, options, callback);
};

/**
 * Convenience method for doing SUB requests.
 * resolver.subscribe('sp://player') is an equivalent of
 * resolver.resolve(new Request('SUB', 'sp://player'))
 *
 * @see Resolver#get for params description and returned value.
 */
Resolver.prototype.subscribe = function(options, callback) {
  return this._resolveFromParams(Action.SUB, options, callback);
};

/**
 * Convenience method for doing PUT requests.
 * resolver.put('sp://ads/v1/settings/session') is an equivalent of
 * resolver.resolve(new Request('PUT', 'sp://ads/v1/settings/session'))
 *
 * @see Resolver#get for params description and returned value.
 */
Resolver.prototype.put = function(options, callback) {
  return this._resolveFromParams(Action.PUT, options, callback);
};

/**
 * Convenience method for doing PATCH requests.
 * resolver.patch('sp://ads/v1/settings/session') is an equivalent of
 * resolver.resolve(new Request('PATCH', 'sp://ads/v1/settings/session'))
 *
 * @see Resolver#get for params description and returned value.
 */
Resolver.prototype.patch = function(options, callback) {
  return this._resolveFromParams(Action.PATCH, options, callback);
};

/**
 * Convenience method for doing DELETE requests.
 * resolver.delete('sp://player') is an equivalent of
 * resolver.resolve(new Request('DELETE', 'sp://player'))
 *
 * @see Resolver#get for params description and returned value.
 */
Resolver.prototype.delete = function(options, callback) {
  return this._resolveFromParams(Action.DELETE, options, callback);
};

/**
 * @private
 * Sends the request to the platform specific request resolver.
 * If the request action is 'SUB' it will send subscribe request
 * In any other case it will send simple resolve request.
 *
 * @param {Cosmos.Request} request A request object.
 * @param {function(error=, object?)} callback The function
 * executed after the request has been completed.
 *
 * @return {RequestHandler} The cancellable request handler.
 */
Resolver.prototype._resolve = function(request, callback) {
  if (!callback || typeof callback !== 'function') {
    callback = function() {};
  }

  var requestHandler;

  function onSuccess(serverResponse) {
    if (!requestHandler._request) {
      return;
    }

    var response = Response.fromObject(serverResponse);
    if (!response) {
      var error = new Error(
        'Failed to parse response: ' + JSON.stringify(serverResponse));
      return callback(error);
    }

    if (_isSuccessStatus(response.getStatusCode())) {
      return callback(null, response);
    } else {
      // Extract just the initial part of the request uri. It's good to have something
      // but it is also good to avoid having everything, since that can hurt dashboards
      // that group error messages.
      var requestEndpoint = request.toJSON().uri.match(/[^\:]*(\:\/\/)?[^\/]*/)[0];
      var errorMessage = (
        response.getHeader("error") ||
        "Request to " + requestEndpoint + " failed with status code " + response.getStatusCode());
      var error = new Error(errorMessage);
      error.response = response;
      return callback(error, response);
    }
  }

  function onError(serverResponse) {
    return callback(serverResponse instanceof Error ?
      serverResponse :
      new Error('Request failed: ' + JSON.stringify(serverResponse)));
  }

  var resolveFn = request.getAction() === Action.SUB ?
      this._resolver.subscribe : this._resolver.resolve;

  var clientRequest = resolveFn.call(this._resolver, request, onSuccess, onError);

  requestHandler = new RequestHandler(clientRequest);
  return requestHandler;
};

/**
 * @private
 * Creates Request object from supplied params.
 * @param {string} method Request method. One of the Request.Action.
 * @param {string|Object.<string, object>} options If is a string
 * will be parsed as url. If more data is needed, object notation
 * should be used.
 *  param options.url {string} The url of the request.
 *  param options.body {object=} The request body.
 *  param options.headers {object=} The request headers.
 * @param {function(error=, object?)} callback The function
 * executed after the request has been completed.
 *
 * @return {RequestHandler} The cancellable request handler.
 */
Resolver.prototype._resolveFromParams = function(method, options, callback) {
  options = options || {};

  var url = typeof options === 'string' ? options : options.url;
  var headers = options.headers;
  var body = options.body;

  var request = new Request(method, url, headers, body);

  return this._resolve(request, callback);
};

/**
 * The object that wraps the clientRequest
 * in a very simple interface.
 * Separates the implementation of the ClientRequest
 * from the request handler returned by Cosmos API.
 *
 * @param {Cosmos.ClientRequest} request The object
 * representing the newly opened request to the client.
 * Usually a request will be a subscription that
 * needs a close handler.
 */
function RequestHandler(request) {
  if (!request || typeof request.close !== 'function')
    throw new TypeError('Invalid `request` argument.');

  this._request = request;
}

/**
 * Closes the request and removes the object.
 */
RequestHandler.prototype.cancel = function() {
  if (this._request) {
    this._request.close();
    this._request = null;
  }
};

exports.Resolver = Resolver;

},{"cosmos-common-js":377}],723:[function(require,module,exports){
'use strict';

/**
 * The Base62 Converter
 *
 * @class Base62
 * @constructor
 *
 */

var digits = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';
var invHexDigits = {};
var invDigits = {};

// Prepare tables.
(function() {
  var i;
  var l;
  for (i = 0, l = digits.length; i < l; ++i) { invDigits[digits[i]] = i; }
  for (i = 0; i < 16; ++i) { invHexDigits['0123456789abcdef'[i]] = i; }
  for (i = 0; i < 16; ++i) { invHexDigits['0123456789ABCDEF'[i]] = i; }
})();


/**
 * lhs *= rhs
 * @private
 */
function mul(lhs, rhs, base) {
  var rest = 0;
  for (var i = 0; i < lhs.length; ++i) {
    var tmp = lhs[i] * rhs + rest;
    lhs[i] = tmp % base;
    rest = ~~(tmp / base);
  }
  while (rest) {
    lhs.push(rest % base);
    rest = ~~(rest / base);
  }
}

/**
 * acc += lhs * rhs
 * @private
 */
function madd(acc, lhs, rhs, base) {
  var rest = 0;
  var tmp;
  var i;
  for (i = 0; i < lhs.length; ++i) {
    tmp = ~~acc[i] + lhs[i] * rhs + rest;
    acc[i] = tmp % base;
    rest = ~~(tmp / base);
  }
  while (rest) {
    tmp = ~~acc[i] + rest;
    acc[i] = tmp % base;
    rest = ~~(tmp / base);
    ++i;
  }
}

/**
 * Change base
 * @private
 */
function convert(data, fromBase, toBase) {
  var r = [0];
  var b = [1];
  for (var i = 0; i < data.length; ++i) {
    madd(r, b, data[i], toBase);
    mul(b, fromBase, toBase);
  }
  return r;
}

/**
 * Decode to
 * @private
 */
function mapr(data, mapping) {
  var r = [];
  for (var i = 0; i < data.length; ++i) {
    r.push(mapping[data[i]]);
  }
  return r.reverse();
}

/**
 * Pad with 0s
 * @private
 */
function pad(data, length) {
  while (data.length < length) { data.push(0); }
  return data;
}

module.exports = {

  /**
   * Converts from array of bytes to base62 encoded string.
   *
   * @public
   * @name Spotify.Utils.Base62#fromBytes
   * @function
   * @param {Array.<number>} data Array of byte numbers.
   * @param {?number} length Do zeropadding until at least this length.
   * @return {string} Base62 encoded string.
  **/
  fromBytes: function(data, length) {
    var r = convert(data.slice(0).reverse(), 256, 62);
    return mapr(pad(r, length), digits).join('');
  },

  /**
   * Converts from base62 encoded string to array of bytes
   *
   * @public
   * @name Spotify.Utils.Base62#toBytes
   * @function
   * @param {string} str Base62 encoded string.
   * @param {?number} length Do zeropadding until at least this length.
   * @return {Array.<number>} Array of byte numbers.
  **/
  toBytes: function(str, length) {
    var r = convert(mapr(str, invDigits), 62, 256);
    return pad(r, length).reverse();
  },

  /**
   * Converts from base62 encoded string to hex encoded string
   *
   * @public
   * @name Spotify.Utils.Base62#toHex
   * @function
   * @param {string} str Base62 encoded string.
   * @param {?number} length Do zeropadding until at least this length.
   * @return {string} Hex encoded string.
  **/
  toHex: function(str, length) {
    var r = convert(mapr(str, invDigits), 62, 16);
    return mapr(pad(r, length), digits).join('');
  },

  /**
   * Converts from hex encoded strign to base62 encoded string
   *
   * @public
   * @name Spotify.Utils.Base62#fromHex
   * @function
   * @param {string} str Hex encoded string.
   * @param {?number} length Do zeropadding until at least this length.
   * @return {string} Base62 encoded string.
  **/
  fromHex: function(str, length) {
    var r = convert(mapr(str, invHexDigits), 16, 62);
    return mapr(pad(r, length), digits).join('');
  }

};

},{}],724:[function(require,module,exports){
(function() {
  /**
   * @file
   * Introduces a function called "defer" that allows functions to be
   * executed in the next available tick.
   *
   * Unlike "setTimeout", "defer" executes the function at the nearest
   * possible time without clamping.
   *
   * @see Spotify.defer
   */
  'use strict';

  var hasWindow = typeof window != 'undefined';
  var hasDefineProperty = typeof Object.defineProperty == 'function';

  if (hasWindow && window.__modDefFn) {
    // If deferred has been attached to the global scope
    module.exports = window.__modDefFn;
    return;
  }

  /**
   * Storage for deferred functions to be executed.
   *
   * @type {Array.<function()>}
   * @private
   */
  var deferred = [];


  /**
   * A bound version of the postMessage routine used to trigger deferred
   * execution.
   *
   * @type {function()}
   * @private
   */
  var send;
  var origin;

  function bindSendDom() {
    origin = (window.location.origin ||
          window.location.protocol + '//' + window.location.hostname);
    send = window.postMessage.bind(window, '@execute_deferreds', origin);
    if (!window.__hasDeferredHandler) {
      if (hasDefineProperty) {
        Object.defineProperty(window, '__hasDeferredHandler', {value: 1});
      } else {
        window.__hasDeferredHandler = 1;
      }
      var handler = function(e) {
        if (e.origin != origin && e.data != '@execute_deferreds') {
          return;
        }
        executeDeferreds();
      };
      if (window.addEventListener) {
        window.addEventListener('message', handler);
      } else {
        window.attachEvent('onmessage', handler);
      }
    }
  }

  function bindSendImmediate() {
    send = setImmediate.bind(null, executeDeferreds);
  }

  function bindSendTimeout() {
    send = setTimeout.bind(null, executeDeferreds, 10);
  }

  function bindSendAuto() {
    if (hasWindow && window.postMessage) {
      bindSendDom();
    } else if (typeof setImmediate != 'undefined') {
      bindSendImmediate();
    } else {
      bindSendTimeout();
    }
  }

  bindSendAuto();

  /**
   * Executes the deferred functions when the window
   * receives an 'execute_deferreds' message.
   *
   * @private
   */
  function executeDeferreds() {
    var fns = deferred.splice(0);
    if (!fns.length) return;
    for (var i = 0, l = fns.length; i < l; i++) {
      try {
        fns[i]();
      } finally {
        // Do nothing.
        null;
      }
    }
  }


  /**
   * Executes the function applied at the nearest possible time without
   * clamping.
   *
   * @param {function()} fn The function to execute.
   */
  var defer = function(fn) {
    var trigger = !deferred.length;
    deferred.push(fn);
    if (trigger) send();
  };

  if (hasWindow && !window.__modDefFn) {
    if (hasDefineProperty) {
      Object.defineProperty(window, '__modDefFn', {value: defer});
    } else {
      window.__modDefFn = defer;
    }
  }

  /**
   * Export interface for binding send method to a particular implementation,
   * which is intended primarily for use by integration tests where the send method
   * can be explicitly set to immediate/timeout, even if mock DOM globals exist.
   */
  defer.use = {
    auto: bindSendAuto,
    dom: bindSendDom,
    immediate: bindSendImmediate,
    timeout: bindSendTimeout,
  };

  /**
   * Export public interface
   */
  module.exports = defer;

})();

},{}],725:[function(require,module,exports){
arguments[4][721][0].apply(exports,arguments)
},{"dup":721}],726:[function(require,module,exports){
/**
 * @module spotify-eventemitter
 */
'use strict';

/**
 * @private
 */
var _defer = require('spotify-deferred');

/**
 * The event handlers.
 *
 * @typedef {Array.<function>}
 * @private
 */
var EventHandlers;

/**
 * Represents an Event.
 *
 * **NOTE**: The Event class is an internal class: you cannot instantiate it
 * directly. Instead, you should use the provided
 * {@link module:spotify-eventemitter.createEvent} function.
 *
 * @constructor
 * @param {string} type The type name of the event object.
 * @param {Object} props An object that will be added as properties of the
 *     event object.
 * @see {@link module:spotify-eventemitter.createEvent}
 */
function Event(type, props) {
  /**
   * The type of the event.
   *
   * @type {string}
   */
  this.type = type;

  /**
   * A flag for whether preventDefault was called.
   *
   * @type {boolean}
   * @private
   */
  this._prevented = false;

  /**
   * A flag for whether stopPropagation was called
   *
   * @type {boolean}
   * @private
   */
  this._stopped = false;

  /**
   * A flag for whether stopImmediatePropagation was called.
   *
   * @type {boolean}
   * @private
   */
  this._immediateStopped = false;

  if (props) {
    for (var key in props) {
      if (key == 'type') {
        continue;
      }
      this[key] = props[key];
    }
  }
}

/**
 * Prevents the default operation for the event.
 */
Event.prototype.preventDefault = function() {
  this._prevented = true;
};

/**
 * Returns whether preventDefault was called on the event.
 *
 * @return {boolean} True if preventDefault was called, false otherwise.
 */
Event.prototype.isDefaultPrevented = function() {
  return this._prevented;
};

/**
 * Stops the propagation of the event.
 */
Event.prototype.stopPropagation = function() {
  this._stopped = true;
};

/**
 * Returns whether stopPropagation was called on the event.
 *
 * @return {boolean} True if stopPropagation was called, false otherwise.
 */
Event.prototype.isPropagationStopped = function() {
  return this._stopped;
};

/**
 * Stops the immediate propagation of the event.
 *
 * Handlers added after any event handler calling this method will not receive
 * the event.
 */
Event.prototype.stopImmediatePropagation = function() {
  this._immediateStopped = true;
};

/**
 * Returns whether stopImmediatePropagation was called on the event.
 *
 * @return {boolean} True if stopImmediatePropagation was called, false
 *     otherwise.
 */
Event.prototype.isImmediatePropagationStopped = function() {
  return this._immediateStopped;
};

/**
 * An EventEmitter is an object that can be listened to for events.
 *
 * Instances of this class are not usually used directly; instead, a class that
 * needs EventEmitter functionality would inherit from the EventEmitter class
 * so that it's instances can use events.
 *
 * @constructor
 * @alias module:spotify-eventemitter
 *
 * @example <caption>Direct usage</caption>
 * var EventEmitter = require('spotify-eventemitter');
 * var emitter = new EventEmitter();
 * emitter.addListener('someEvent', function() {
 *     console.log('someEvent fired!');
 * });
 * emitter.emit('someEvent');
 * @example <caption>Inheritance</caption>
 * var EventEmitter = require('spotify-eventemitter');
 * var inherit = require('spotify-inherit/inherit');
 *
 * function MyClass() {
 *   EventEmitter.call(this);
 * }
 * inherit(MyClass, EventEmitter);
 *
 * var instance = new MyClass();
 * instance.addListener('someEvent', function() {
 *     console.log('someEvent fired!');
 * });
 * instance.emit('someEvent');
 */
function EventEmitter() {
  /**
   * A map of event names to event handlers.
   *
   * @type {Object.<string, module:spotify-eventemitter~EventHandlers>}
   * @private
   */
  this._listenerMap = {};
}

/**
 * Creates a new Event object.
 *
 * @param {string} type The type name of the event.
 * @param {Object=} opt_params An object containing properties for the new event
 *     object.
 * @return {module:spotify-eventemitter~Event} The new event object.
 */
EventEmitter.createEvent = function(type, opt_params) {
  return new Event(type, opt_params);
};

/**
 * Adds an event listener to the emitter.
 *
 * This method is idempotent: calling it multiple times using the same type
 * and listener arguments will only set the listener once. This behaviour is
 * done to prevent accidental additions of the same event listener.
 *
 * @param {string} type The type of event to listen to.
 * @param {function} listener A function to be called when the emitter fires
 *     the event specified in the type.
 * @return {module:spotify-eventemitter} The event emitter.
 */
EventEmitter.prototype.addListener = function(type, listener) {
  var _listenerMap = this._listenerMap || (this._listenerMap = {});
  var listeners = _listenerMap[type] || (_listenerMap[type] = []);
  if (listeners.indexOf(listener) != -1) {
    // Handler already added, return quickly.
    return this;
  }
  listeners.push(listener);
  return this;
};

/**
 * Adds multiple event listeners to the emitter.
 *
 * @param {Object.<string, function>} eventListeners An object, the keys of
 *     which correspond to the name of events to listen to, and the value of
 *     each of these keys should be a function that would be added as the
 *     listener for that event.
 * @return {module:spotify-eventemitter} The event emitter.
 */
EventEmitter.prototype.addListeners = function(eventListeners) {
  for (var type in eventListeners) {
    this.addListener(type, eventListeners[type]);
  }
  return this;
};

/**
 * Adds a "once" event listener to the emitter, which will be removed right
 * after it has been fired.
 *
 * In order to achieve the "once" behaviour, the listener argument passed to
 * this method is wrapped in a function, which is then returned by the method.
 *
 * Because of this wrapping, this method is not idempotent: calling it multiple
 * times with the same type and listener arguments will result to multiple
 * event listeners attached.
 *
 * @param {string} type The type of event to listen to.
 * @param {function} listener A function to be called when the emitter fires
 *     the event specified in the type and then automatically removed.
 * @return {function} The function used to wrap the listener function argument.
 *     This function can be used as an argument to removeEvent.
 */
EventEmitter.prototype.addOnceListener = function(type, listener) {
  var wrapper = function() {
    this.removeListener(type, wrapper);
    return listener.apply(this, arguments);
  };
  this.addListener(type, wrapper);
  return wrapper;
};

/**
 * Removes an event listener from the emitter.
 *
 * @param {string} type The type of event to remove.
 * @param {function} listener The listener function to remove. This must be a
 *     function that was added previously using addEvent.
 * @return {module:spotify-eventemitter} The event emitter.
 */
EventEmitter.prototype.removeListener = function(type, listener) {
  var _listenerMap = this._listenerMap;
  var listeners = _listenerMap && _listenerMap[type];
  if (!listeners) {
    return this;
  }
  var index = listeners.indexOf(listener);
  if (index == -1) {
    return this;
  }
  listeners.splice(index, 1);
  if (!listeners.length) {
    _listenerMap[type] = null;
  }
  return this;
};

/**
 * Removes all event listeners from the emitter for a particular type.
 * If no event type is given, all event listeners will be removed.
 * 
 * @param {string=} opt_type The event type to remove.
 * @return {module:spotify-eventemitter} The event emitter.
 */
EventEmitter.prototype.removeAllListeners = function(opt_type) {
  var _listenerMap = this._listenerMap;
  if (!_listenerMap) {
    return this;
  }

  if (opt_type === undefined) {
    this._listenerMap = {};
    return this;
  }

  _listenerMap[opt_type] = null;
  return this;
};

/**
 * Removes multiple event listeners from the emitter.
 *
 * @param {Object.<string, function>} eventListeners An object, the keys of
 *     which correspond to the name of events to listen to, and the value of
 *     each of these keys should be a function that would be added as the
 *     listener for that event.
 * @return {module:spotify-eventemitter} The event emitter.
 */
EventEmitter.prototype.removeListeners = function(eventListeners) {
  for (var type in eventListeners) {
    this.removeListener(type, eventListeners[type]);
  }
  return this;
};

/**
 * Creates and emits an event on the emitter.
 *
 * This method invokes all the added event listeners of the `type` provided in
 * the order they were added, passing in a new Event object created using the
 * provided `type` and `opt_params` arguments.
 *
 * This method emits events asynchronously: the listeners are not called until
 * the next run loop.
 *
 * @param {string} type The type name of the event to emit.
 * @param {Object=} opt_params An object containing parameters for the Event
 *     object.
 * @return {module:spotify-eventemitter~Event} The Event object that was
 *     created.
 */
EventEmitter.prototype.emit = function(type, opt_params) {
  var event = new Event(type, opt_params);
  _defer(function() {
    this.emitEventSync(event);
  }.bind(this));
  return event;
};

/**
 * Emits an event on the emitter.
 *
 * This method invokes all the added event listeners of the `type` of the 
 * `event` provided in the order they were added, passing in the `event` as an
 * argument.
 *
 * This method emits events asynchronously: the listeners are not called until
 * the next run loop.
 *
 * @param {module:spotify-eventemitter~Event} event The Event object.
 * @return {module:spotify-eventemitter~Event} The Event object that was passed.
 */
EventEmitter.prototype.emitEvent = function(event) {
  _defer(function() {
    this.emitEventSync(event);
  }.bind(this));
  return event;
};

/**
 * Creates and synchronously emits an event on the emitter.
 *
 * This method invokes all the added event listeners of the `type` provided in
 * the order they were added, passing in a new Event object created using the
 * provided `type` and `opt_params` arguments.
 *
 * @param {string} type The type name of event to emit.
 * @param {Object=} opt_params An object containing parameters for the event
 *     object.
 * @return {module:spotify-eventemitter~Event} The Event object that was
 *     created.
 */
EventEmitter.prototype.emitSync = function(type, opt_params) {
  var event = new Event(type, opt_params);
  this.emitEventSync(event);
  return event;
};

/**
 * Synchronously emits an event on the emitter.
 *
 * This method invokes all the added event listeners of the `type` of the
 * `event` provided in the order they were added, passing in the `event` as an
 * argument.
 *
 * @param {module:spotify-eventemitter~Event} event The Event object.
 * @return {module:spotify-eventemitter~Event} The Event object that was passed.
 */
EventEmitter.prototype.emitEventSync = function(event) {
  var type = event.type;
  var _listenerMap = this._listenerMap;
  var listeners = _listenerMap && _listenerMap[type];
  if (!listeners || !listeners.length) {
    return event;
  }
  listeners = listeners.slice(0);
  for (var i = 0, l = listeners.length; i < l; i++) {
    listeners[i].call(this, event);
    if (event.isImmediatePropagationStopped()) {
      break;
    }
  }
  return event;
};

/**
 * Adds an event listener to the emitter.
 *
 * **NOTE**: This method is an alias of
 * {@link module:spotify-eventemitter#addListener}.
 *
 * This method is idempotent: calling it multiple times using the same type
 * and listener arguments will only set the listener once. This behaviour is
 * done to prevent accidental additions of the same event listener.
 *
 * @param {string} type The type of event to listen to.
 * @param {function} listener A function to be called when the emitter fires
 *     the event specified in the type.
 * @return {module:spotify-eventemitter} The event emitter.
 * @see {@link module:spotify-eventemitter#addListener}
 */
EventEmitter.prototype.on = function(type, listener) {
  return this.addListener(type, listener);
};

/**
 * Adds a "once" event listener to the emitter, which will be removed right
 * after it has been fired.
 *
 * **NOTE**: This method is an alias of
 * {@link module:spotify-eventemitter#addOnceListener}.
 *
 * In order to achieve the "once" behaviour, the listener argument passed to
 * this method is wrapped in a function, which is then returned by the method.
 *
 * Because of this wrapping, this method is not idempotent: calling it multiple
 * times with the same type and listener arguments will result to multiple
 * event listeners attached.
 *
 * @param {string} type The type of event to listen to.
 * @param {function} listener A function to be called when the emitter fires
 *     the event specified in the type and then automatically removed.
 * @return {function} The function used to wrap the listener function argument.
 *     This function can be used as an argument to removeEvent.
 * @see {@link module:spotify-eventemitter#addOnceListener}
 */
EventEmitter.prototype.once = function(type, listener) {
  return this.addOnceListener(type, listener);
};

// DEPRECATED METHODS:

/**
 * Adds an event listener to the emitter.
 *
 * **NOTE**: This method has been deprecated in favor of
 * {@link module:spotify-eventemitter#addListener}.
 *
 * This method is idempotent: calling it multiple times using the same type
 * and listener arguments will only set the listener once. This behaviour is
 * done to prevent accidental additions of the same event listener.
 *
 * @deprecated since v2.0.0.
 * @param {string} type The type of event to listen to.
 * @param {function} listener A function to be called when the emitter fires
 *     the event specified in the type.
 * @return {module:spotify-eventemitter} The event emitter.
 * @see {@link module:spotify-eventemitter#addListener}
 */
EventEmitter.prototype.addEvent = function(type, listener) {
  return this.addListener(type, listener);
};

/**
 * Adds multiple event listeners to the emitter.
 *
 * **NOTE**: This method has been deprecated in favor of
 * {@link module:spotify-eventemitter#addListeners}.
 *
 * @deprecated since v2.0.0.
 * @param {Object.<string, function>} eventListeners An object, the keys of
 *     which correspond to the name of events to listen to, and the value of
 *     each of these keys should be a function that would be added as the
 *     listener for that event.
 * @return {module:spotify-eventemitter} The event emitter.
 * @see {@link module:spotify-eventemitter#addListeners}
 */
EventEmitter.prototype.addEvents = function(eventListeners) {
  return this.addListeners(eventListeners);
};

/**
 * Adds a "once" event listener to the emitter, which will be removed right
 * after it has been fired.
 *
 * **NOTE**: This method has been deprecated in favor of
 * {@link module:spotify-eventemitter#addOnceListener}.
 *
 * In order to achieve the "once" behaviour, the listener argument passed to
 * this method is wrapped in a function, which is then returned by the method.
 *
 * Because of this wrapping, this method is not idempotent: calling it multiple
 * times with the same type and listener arguments will result to multiple
 * event listeners attached.
 *
 * @deprecated since v2.0.0.
 * @param {string} type The type of event to listen to.
 * @param {function} listener A function to be called when the emitter fires
 *     the event specified in the type and then automatically removed.
 * @return {function} The function used to wrap the listener function argument.
 *     This function can be used as an argument to removeEvent.
 * @see {@link module:spotify-eventemitter#addOnceListener}
 */
EventEmitter.prototype.addOnceEvent = function(type, listener) {
  return this.addOnceListener(type, listener);
};

/**
 * Removes an event listener from the emitter.
 *
 * **NOTE**: This method has been deprecated in favor of
 * {@link module:spotify-eventemitter#removeListener}.
 *
 * @deprecated since v2.0.0.
 * @param {string} type The type of event to remove.
 * @param {function} listener The listener function to remove. This must be a
 *     function that was added previously using addEvent.
 * @return {module:spotify-eventemitter} The event emitter.
 * @see {@link module:spotify-eventemitter#removeListener}
 */
EventEmitter.prototype.removeEvent = function(type, listener) {
  return this.removeListener(type, listener);
};

/**
 * Removes multiple event listeners from the emitter.
 *
 * **NOTE**: This method has been deprecated in favor of
 * {@link module:spotify-eventemitter#removeListeners}.
 *
 * @deprecated since v2.0.0.
 * @param {Object.<string, function>} events An object, the keys of which
 *     correspond to the name of events to remove, and the value of each of
 *     these keys should be a function that would be removed as a listener.
 * @return {module:spotify-eventemitter} The event emitter.
 * @see {@link module:spotify-eventemitter#removeListeners}
 */
EventEmitter.prototype.removeEvents = function(eventListeners) {
  return this.removeListeners(eventListeners);
};

/**
 * Fires an event on the emitter, optionally passing arguments to the listeners.
 *
 * **NOTE**: This method has been deprecated in favor of
 * {@link module:spotify-eventemitter#emit}.
 *
 * This method fire events asynchronously: the listeners are not called until
 * the next run loop. A third boolean parameter can be passed to change this
 * behaviour.
 *
 * @deprecated since v2.0.0.
 * @param {string} type The type of event to fire.
 * @param {Array.<*>=} opt_args A set of objects that would be passed to the
 *     event listeners as arguments.
 * @param {boolean=} opt_priority Passing true will fire the event synchronously.
 * @return {module:spotify-eventemitter} The event emitter.
 * @see {@link module:spotify-eventemitter#emit}
 */
EventEmitter.prototype.fireEvent = function(type, opt_args, opt_priority) {
  if (opt_priority) {
    this.fireEventSync(type, opt_args);
  } else {
    var self = this;
    _defer(function() { self.fireEventSync(type, opt_args); });
  }
  return this;
};

/**
 * Fires an event on the emitter synchronously, optionally passing arguments to
 * the listeners.
 *
 * **NOTE**: This method has been deprecated in favor of
 * {@link module:spotify-eventemitter#emitSync}.
 *
 * @deprecated since v2.0.0.
 * @param {string} type The type of event to fire.
 * @param {Array.<*>=} opt_args A set of objects that would be passed to the
 *     event listeners as arguments.
 * @return {module:spotify-eventemitter} The event emitter.
 * @see {@link module:spotify-eventemitter#emitSync}
 */
EventEmitter.prototype.fireEventSync = function(type, opt_args) {
  var self = this;
  var events = this._listenerMap && this._listenerMap[type];
  if (!events || !events.length) return this;
  events = events.slice(0);
  var i, l;
  if (!opt_args) {
    for (i = 0, l = events.length; i < l; i++) {
      events[i].call(self);
    }
  } else {
    if (!Array.isArray(opt_args)) {
      opt_args = [opt_args];
    }
    for (i = 0, l = events.length; i < l; i++) {
      events[i].apply(self, opt_args);
    }
  }
  return this;
};

/**
 * Removes an event listener or all event listeners from the emitter.
 *
 * **NOTE**: This method has been deprecated in favor of
 * {@link module:spotify-eventemitter#removeListener}.
 *
 * @deprecated since v2.0.0.
 * @param {string} type The type of event to remove.
 * @param {function=} opt_listener The listener function to remove. This must be
 *     a function that was added previously using addEvent. If this parameter is
 *     not given, all event listeners of the corresponding `type` argument will
 *     be removed.
 * @return {module:spotify-eventemitter} The event emitter.
 * @see {@link module:spotify-eventemitter#removeListener}
 * @see {@link module:spotify-eventemitter#removeListeners}
 */
EventEmitter.prototype.off = function(type, opt_listener) {
  if (typeof opt_listener === 'function') {
    return this.removeEvent(type, opt_listener);
  }
  // if no listener set, remove all the listeners from the event
  this._listenerMap[type] = null;
  return this;
};

/**
 * Exporting
 */
module.exports = EventEmitter;

},{"spotify-deferred":725}],727:[function(require,module,exports){
'use strict';

/**
 * Function to add properties to an object
 * @param {Object} obj The input object
 * @param {Object} args The objects which are going to be injected
 * @return {Object} The extended object
 */
var extend = function(obj, args) {
  var source;

  for (var i = 1; i < arguments.length; i++) {
    source = arguments[i];
    if (source) {
      for (var prop in source) {
        if (source.hasOwnProperty(prop)) {
          obj[prop] = source[prop];
        }
      }
    }
  }
  return obj;
};


/**
 * Export public interface
 */
module.exports = extend;

},{}],728:[function(require,module,exports){
'use strict';

module.exports = {
  inherit: require('./inherit'),
  extend: require('./extend')
};

},{"./extend":727,"./inherit":729}],729:[function(require,module,exports){
'use strict';

/**
 * Makes a class inherit from a superclass' prototype indirectly.
 *
 * @param {Spotify.ClassLike} Sub The class that will inherit.
 * @param {Spotify.ClassLike} Super The class to inherit from.
 */
var inherit = function(Sub, Super) {
  var superProto = Super.prototype;
  function Superclass() {}
  Superclass.prototype = Sub._super = superProto;
  Superclass.prototype.constructor = Super;
  Sub.prototype = new Superclass();
};


/**
 * Export public interface
 */
module.exports = inherit;

},{}],730:[function(require,module,exports){
'use strict';

/**
 * @private
 */
var Base62 = require('spotify-crypto/base62');

/**
 * The URI prefix for URIs.
 *
 * @const
 * @private
 */
var URI_PREFIX = 'spotify:';

/**
 * The URL prefix for Play.
 *
 * @const
 * @private
 */
var PLAY_HTTP_PREFIX = 'http://play.spotify.com/';

/**
 * The HTTPS URL prefix for Play.
 *
 * @const
 * @private
 */
var PLAY_HTTPS_PREFIX = 'https://play.spotify.com/';

/**
 * The URL prefix for Open.
 *
 * @const
 * @private
 */
var OPEN_HTTP_PREFIX = 'http://open.spotify.com/';

/**
 * The HTTPS URL prefix for Open.
 *
 * @const
 * @private
 */
var OPEN_HTTPS_PREFIX = 'https://open.spotify.com/';

var ERROR_INVALID = new TypeError('Invalid Spotify URI!');
var ERROR_NOT_IMPLEMENTED = new TypeError('Not implemented!');


/**
 * The format for the URI to parse.
 *
 * @enum {number}
 * @private
 */
var Format = {
  URI: 0,
  URL: 1
};

/**
 * Represents the result of a URI splitting operation.
 *
 * @typedef {{
 *    format: Format,
 *    components: Array.<string>
 * }}
 * @see _splitIntoComponents
 * @private
 */
var SplittedURI;

/**
 * Split an string URI or HTTP/HTTPS URL into components, skipping the prefix.
 *
 * @param {string} str A string URI to split.
 * @return {SplittedURI} The parsed URI.
 * @private
 */
var _splitIntoComponents = function(str) {
  var components;
  var format;
  var query;
  var anchor;

  var querySplit = str.split('?');
  if (querySplit.length > 1) {
    str = querySplit.shift();
    query = querySplit.pop();

    var queryHashSplit = query.split('#');
    if (queryHashSplit.length > 1) {
      query = queryHashSplit.shift();
      anchor = queryHashSplit.pop();
    }

    query = decodeQueryString(query);
  }

  var hashSplit = str.split('#');
  if (hashSplit.length > 1) {
    // first token
    str = hashSplit.shift();
    // last token
    anchor = hashSplit.pop();
  }

  if (str.indexOf(URI_PREFIX) === 0) {
    components = str.slice(URI_PREFIX.length).split(':');
    format = Format.URI;
  } else {
    // For HTTP URLs, ignore any query string argument
    str = str.split('?')[0];

    if (str.indexOf(PLAY_HTTP_PREFIX) === 0) {
      components = str.slice(PLAY_HTTP_PREFIX.length).split('/');
    } else if (str.indexOf(PLAY_HTTPS_PREFIX) === 0) {
      components = str.slice(PLAY_HTTPS_PREFIX.length).split('/');
    } else if (str.indexOf(OPEN_HTTP_PREFIX) === 0) {
      components = str.slice(OPEN_HTTP_PREFIX.length).split('/');
    } else if (str.indexOf(OPEN_HTTPS_PREFIX) === 0) {
      components = str.slice(OPEN_HTTPS_PREFIX.length).split('/');
    } else {
      throw ERROR_INVALID;
    }
    format = Format.URL;
  }

  if (anchor) {
    components.push(anchor);
  }

  return {
    format: format,
    components: components,
    query: query
  };
};

/**
 * Encodes a component according to a format.
 *
 * @param {string} component A component string.
 * @param {Format} format A format.
 * @return {string} An encoded component string.
 * @private
 */
var _encodeComponent = function(component, format) {
  component = encodeURIComponent(component);
  if (format === Format.URI) {
    component = component.replace(/%20/g, '+');
  }

  // encode characters that are not encoded by default by encodeURIComponent
  // but that the Spotify URI spec encodes: !'*()
  component = component.replace(/[!'()]/g, escape);
  component = component.replace(/\*/g, '%2A');

  return component;
};

/**
 * Decodes a component according to a format.
 *
 * @param {string} component An encoded component string.
 * @param {Format} format A format.
 * @return {string} An decoded component string.
 * @private
 */
var _decodeComponent = function(component, format) {
  var part = format == Format.URI ? component.replace(/\+/g, '%20') : component;
  return decodeURIComponent(part);
};

/**
 * Returns the components of a URI as an array.
 *
 * @param {URI} uri A uri.
 * @param {Format} format The output format.
 * @return {Array.<string>} An array of uri components.
 * @private
 */
var _getComponents = function(uri, format) {
  var base62;
  if (uri.id) {
    base62 = uri._base62Id;
  }

  var components;
  var i;
  var len;
  switch (uri.type) {
    case URI.Type.ALBUM:
      components = [URI.Type.ALBUM, base62];
      if (uri.disc) {
        components.push(uri.disc);
      }
      return components;
    case URI.Type.AD:
      return [URI.Type.AD, uri._base62Id];
    case URI.Type.ARTIST:
      return [URI.Type.ARTIST, base62];
    case URI.Type.ARTIST_TOPLIST:
      return [URI.Type.ARTIST, base62, URI.Type.TOP, uri.toplist];
    case URI.Type.SEARCH:
      return [URI.Type.SEARCH, _encodeComponent(uri.query, format)];
    case URI.Type.TRACK:
      if (uri.context || uri.play) {
        base62 += encodeQueryString({
          context: uri.context,
          play: uri.play
        });
      }
      if (uri.anchor) {
        base62 += '#' + uri.anchor;
      }
      return [URI.Type.TRACK, base62];
    case URI.Type.TRACKSET:
      var trackIds = [];
      for (i = 0, len = uri.tracks.length; i < len; i++) {
        trackIds.push(uri.tracks[i]._base62Id);
      }
      trackIds = [trackIds.join(',')];
      // Index can be 0 sometimes (required for trackset)
      if (uri.index !== null) {
        trackIds.push('#', uri.index);
      }
      return [URI.Type.TRACKSET, _encodeComponent(uri.name)].concat(trackIds);
    case URI.Type.FACEBOOK:
      return [URI.Type.USER, URI.Type.FACEBOOK, uri.uid];
    case URI.Type.AUDIO_FILE:
      return [URI.Type.AUDIO_FILE, uri.extension, uri._base62Id];
    case URI.Type.FOLDER:
      return [URI.Type.USER, _encodeComponent(uri.username, format), URI.Type.FOLDER, uri._base62Id];
    case URI.Type.FOLLOWERS:
      return [URI.Type.USER, _encodeComponent(uri.username, format), URI.Type.FOLLOWERS];
    case URI.Type.FOLLOWING:
      return [URI.Type.USER, _encodeComponent(uri.username, format), URI.Type.FOLLOWING];
    case URI.Type.PLAYLIST:
      return [URI.Type.USER, _encodeComponent(uri.username, format), URI.Type.PLAYLIST, base62];
    case URI.Type.STARRED:
      return [URI.Type.USER, _encodeComponent(uri.username, format), URI.Type.STARRED];
    case URI.Type.TEMP_PLAYLIST:
      return [URI.Type.TEMP_PLAYLIST, uri.origin, uri.data];
    case URI.Type.CONTEXT_GROUP:
      return [URI.Type.CONTEXT_GROUP, uri.origin, uri.name];
    case URI.Type.USER_TOPLIST:
      return [URI.Type.USER, _encodeComponent(uri.username, format), URI.Type.TOP, uri.toplist];
    // Legacy Toplist
    case URI.Type.USER_TOP_TRACKS:
      return [URI.Type.USER, _encodeComponent(uri.username, format), URI.Type.TOPLIST];
    case URI.Type.TOPLIST:
      return [URI.Type.TOP, uri.toplist].concat(uri.global ? [URI.Type.GLOBAL] : ['country', uri.country]);
    case URI.Type.INBOX:
      return [URI.Type.USER, _encodeComponent(uri.username, format), URI.Type.INBOX];
    case URI.Type.ROOTLIST:
      return [URI.Type.USER, _encodeComponent(uri.username, format), URI.Type.ROOTLIST];
    case URI.Type.PUBLISHED_ROOTLIST:
      return [URI.Type.USER, _encodeComponent(uri.username, format), URI.Type.PUBLISHED_ROOTLIST];
    case URI.Type.COLLECTION_TRACK_LIST:
      return [URI.Type.USER, _encodeComponent(uri.username, format), URI.Type.COLLECTION_TRACK_LIST, base62];
    case URI.Type.PROFILE:
      if (uri.args && uri.args.length > 0)
        return [URI.Type.USER, _encodeComponent(uri.username, format)].concat(uri.args);
      return [URI.Type.USER, _encodeComponent(uri.username, format)];
    case URI.Type.LOCAL_ARTIST:
      return [URI.Type.LOCAL, _encodeComponent(uri.artist, format)];
    case URI.Type.LOCAL_ALBUM:
      return [URI.Type.LOCAL, _encodeComponent(uri.artist, format), _encodeComponent(uri.album, format)];
    case URI.Type.LOCAL:
      return [URI.Type.LOCAL,
        _encodeComponent(uri.artist, format),
        _encodeComponent(uri.album, format),
        _encodeComponent(uri.track, format),
        uri.duration];
    case URI.Type.LIBRARY:
      return [URI.Type.USER, _encodeComponent(uri.username, format), URI.Type.LIBRARY].concat(uri.category ? [uri.category] : []);
    case URI.Type.IMAGE:
      return [URI.Type.IMAGE, uri._base62Id];
    case URI.Type.MOSAIC:
      components = uri.ids.slice(0);
      components.unshift(URI.Type.MOSAIC);
      return components;
    case URI.Type.RADIO:
      return [URI.Type.RADIO, uri.args];
    case URI.Type.SPECIAL:
      components = [URI.Type.SPECIAL];
      var args = uri.args || [];
      for (i = 0, len = args.length; i < len; ++i)
        components.push(_encodeComponent(args[i], format));
      return components;
    case URI.Type.STATION:
      components = [URI.Type.STATION];
      var args = uri.args || [];
      for (i = 0, len = args.length; i < len; i++) {
        components.push(_encodeComponent(args[i], format));
      }
      return components;
    case URI.Type.APPLICATION:
      components = [URI.Type.APP, uri._base62Id];
      var args = uri.args || [];
      for (i = 0, len = args.length; i < len; ++i)
        components.push(_encodeComponent(args[i], format));
      return components;
    case URI.Type.COLLECTION_ALBUM:
      return [URI.Type.USER, _encodeComponent(uri.username, format), URI.Type.COLLECTION, URI.Type.ALBUM, base62];
    case URI.Type.COLLECTION_MISSING_ALBUM:
      return [URI.Type.USER, _encodeComponent(uri.username, format), URI.Type.COLLECTION, URI.Type.ALBUM, base62, 'missing'];
    case URI.Type.COLLECTION_ARTIST:
      return [URI.Type.USER, _encodeComponent(uri.username, format), URI.Type.COLLECTION, URI.Type.ARTIST, base62];
    case URI.Type.COLLECTION:
      return [URI.Type.USER, _encodeComponent(uri.username, format), URI.Type.COLLECTION].concat(uri.category ? [uri.category] : []);
    case URI.Type.EPISODE:
      if (uri.context || uri.play) {
        base62 += encodeQueryString({
          context: uri.context,
          play: uri.play
        });
      }
      return [URI.Type.EPISODE, base62];
    case URI.Type.SHOW:
      return [URI.Type.SHOW, base62];
    case URI.Type.CONCERT:
      return [URI.Type.CONCERT, base62];
    default:
      throw ERROR_INVALID;
  }
};

var encodeQueryString = function(values) {
  var str = '?';
  for (var i in values) {
    if (values.hasOwnProperty(i) && values[i] !== undefined) {
      if (str.length > 1) {
        str += '&';
      }
      str += i + '=' + encodeURIComponent(values[i]);
    }
  }
  return str;
};

var decodeQueryString = function(str) {
  return str.split('&').reduce(function(object, pair) {
    pair = pair.split('=');
    object[pair[0]] = decodeURIComponent(pair[1]);
    return object;
  }, {});
};

/**
 * Parses the components of a URI into a real URI object.
 *
 * @param {Array.<string>} components The components of the URI as a string
 *     array.
 * @param {Format} format The format of the source string.
 * @return {URI} The URI object.
 * @private
 */
var _parseFromComponents = function(components, format, query) {
  var _current = 0;
  query = query || {};

  var _getNextComponent = function() {
    return components[_current++];
  };

  var _getIdComponent = function() {
    var component = _getNextComponent();

    if (component.length > 22) {
      throw new Error('Invalid ID');
    }
    return component;
  };

  var _getRemainingComponents = function() {
    return components.slice(_current);
  };

  var _getRemainingString = function() {
    var separator = (format == Format.URI) ? ':' : '/';
    return components.slice(_current).join(separator);
  };

  var part = _getNextComponent();
  var id;
  var i;
  var len;

  switch (part) {
    case URI.Type.ALBUM:
      return URI.albumURI(_getIdComponent(), parseInt(_getNextComponent(), 10));
    case URI.Type.AD:
      return URI.adURI(_getNextComponent());
    case URI.Type.ARTIST:
      id = _getIdComponent();
      if (_getNextComponent() == URI.Type.TOP) {
        return URI.artistToplistURI(id, _getNextComponent());
      } else {
        return URI.artistURI(id);
      }
    case URI.Type.AUDIO_FILE:
      return URI.audioFileURI(_getNextComponent(), _getNextComponent());
    case URI.Type.TEMP_PLAYLIST:
      return URI.temporaryPlaylistURI(_getNextComponent(), _getRemainingString());
    case URI.Type.SEARCH:
      return URI.searchURI(_decodeComponent(_getRemainingString(), format));
    case URI.Type.TRACK:
      return URI.trackURI(_getIdComponent(), _getNextComponent(), query.context, query.play);
    case URI.Type.TRACKSET:
      var name = _decodeComponent(_getNextComponent());
      var tracksArray = _getNextComponent();
      var hashSign = _getNextComponent();
      var index = parseInt(_getNextComponent(), 10);
      // Sanity check: %23 is URL code for "#"
      if (hashSign !== '%23' || isNaN(index)) {
        index = null;
      }
      var tracksetTracks = [];
      if (tracksArray) {
        tracksArray = _decodeComponent(tracksArray).split(',');
        for (i = 0, len = tracksArray.length; i < len; i++) {
          var trackId = tracksArray[i];
          tracksetTracks.push(URI.trackURI(trackId));
        }
      }
      return URI.tracksetURI(tracksetTracks, name, index);
    case URI.Type.CONTEXT_GROUP:
      return URI.contextGroupURI(_getNextComponent(), _getNextComponent());
    case URI.Type.TOP:
      var type = _getNextComponent();
      if (_getNextComponent() == URI.Type.GLOBAL) {
        return URI.toplistURI(type, null, true);
      } else {
        return URI.toplistURI(type, _getNextComponent(), false);
      }
    case URI.Type.USER:
      var username = _decodeComponent(_getNextComponent(), format);
      var text = _getNextComponent();
      if (username == URI.Type.FACEBOOK && text != null) {
        return URI.facebookURI(parseInt(text, 10));
      } else if (text != null) {
        switch (text) {
          case URI.Type.PLAYLIST:
            return URI.playlistURI(username, _getIdComponent());
          case URI.Type.FOLDER:
            return URI.folderURI(username, _getIdComponent());
          case URI.Type.COLLECTION_TRACK_LIST:
            return URI.collectionTrackList(username, _getIdComponent());
          case URI.Type.COLLECTION:
            var collectionItemType = _getNextComponent();
            switch (collectionItemType) {
              case URI.Type.ALBUM:
                id = _getIdComponent();
                if (_getNextComponent() === 'missing') {
                  return URI.collectionMissingAlbumURI(username, id);
                } else {
                  return URI.collectionAlbumURI(username, id);
                }
              case URI.Type.ARTIST:
                return URI.collectionArtistURI(username, _getIdComponent());
              default:
                return URI.collectionURI(username, collectionItemType);
            }
          case URI.Type.STARRED:
            return URI.starredURI(username);
          case URI.Type.FOLLOWERS:
            return URI.followersURI(username);
          case URI.Type.FOLLOWING:
            return URI.followingURI(username);
          case URI.Type.TOP:
            return URI.userToplistURI(username, _getNextComponent());
          case URI.Type.INBOX:
            return URI.inboxURI(username);
          case URI.Type.ROOTLIST:
            return URI.rootlistURI(username);
          case URI.Type.PUBLISHED_ROOTLIST:
            return URI.publishedRootlistURI(username);
          case URI.Type.TOPLIST:
            // legacy toplist
            return URI.userTopTracksURI(username);
          case URI.Type.LIBRARY:
            return URI.libraryURI(username, _getNextComponent());
        }
      }
      var rem = _getRemainingComponents();
      if (text != null && rem.length > 0) {
        return URI.profileURI(username, [text].concat(rem));
      } else if (text != null) {
        return URI.profileURI(username, [text]);
      } else {
        return URI.profileURI(username);
      }
    case URI.Type.LOCAL:
      var artistNameComponent = _getNextComponent();
      var artistName = artistNameComponent && _decodeComponent(artistNameComponent, format);
      var albumNameComponent = _getNextComponent();
      var albumName = albumNameComponent && _decodeComponent(albumNameComponent, format);
      var trackNameComponent = _getNextComponent();
      var trackName = trackNameComponent && _decodeComponent(trackNameComponent, format);
      var durationComponent = _getNextComponent();
      var duration = parseInt(durationComponent, 10);
      if (trackNameComponent !== undefined) {
        return URI.localURI(artistName, albumName, trackName, duration);
      } else if (albumNameComponent !== undefined) {
        return URI.localAlbumURI(artistName, albumName);
      } else {
        return URI.localArtistURI(artistName);
      }
    case URI.Type.IMAGE:
      return URI.imageURI(_getIdComponent());
    case URI.Type.MOSAIC:
      return URI.mosaicURI(components.slice(_current));
    case URI.Type.RADIO:
      return URI.radioURI(_getRemainingString());
    case URI.Type.SPECIAL:
      var args = _getRemainingComponents();
      for (i = 0, len = args.length; i < len; ++i)
        args[i] = _decodeComponent(args[i], format);
      return URI.specialURI(args);
    case URI.Type.STATION:
      return URI.stationURI(_getRemainingComponents());
    case URI.Type.EPISODE:
      return URI.episodeURI(_getIdComponent(), query.context, query.play);
    case URI.Type.SHOW:
      return URI.showURI(_getIdComponent());
    case URI.Type.CONCERT:
      return URI.concertURI(_getIdComponent());
    case '':
      break;
    default:
      if (part === URI.Type.APP) {
        id = _getNextComponent();
      } else {
        id = part;
      }
      var decodedId = _decodeComponent(id, format);
      if (_encodeComponent(decodedId, format) !== id) {
        break;
      }
      var args = _getRemainingComponents();
      for (i = 0, len = args.length; i < len; ++i)
        args[i] = _decodeComponent(args[i], format);
      return URI.applicationURI(decodedId, args);
  }

  throw ERROR_INVALID;
};

/**
 * A class holding information about a uri.
 *
 * @constructor
 * @param {URI.Type} type
 * @param {Object} props
 */
function URI(type, props) {
  this.type = type;

  // Merge properties into URI object.
  for (var prop in props) {
    if (typeof props[prop] == 'function') {
      continue;
    }
    this[prop] = props[prop];
  }
}

// Lazy convert the id to hexadecimal only when requested
Object.defineProperty(URI.prototype, 'id', {
  get: function() {
    if (!this._hexId) {
      this._hexId = this._base62Id ? URI.idToHex(this._base62Id) : undefined;
    }
    return this._hexId;
  },
  set: function(id) {
    this._base62Id = id ? URI.hexToId(id) : undefined;
    this._hexId = undefined;
  },
  enumerable: true,
  configurable: true
});

/**
 * Creates an application URI object from the current URI object.
 *
 * If the current URI object is already an application type, a copy is made.
 *
 * @return {URI} The current URI as an application URI.
 */
URI.prototype.toAppType = function() {
  if (this.type == URI.Type.APPLICATION) {
    return URI.applicationURI(this.id, this.args);
  } else {
    var components = _getComponents(this, Format.URL);
    var id = components.shift();
    var len = components.length;
    if (len) {
      while (len--) {
        components[len] = _decodeComponent(components[len], Format.URL);
      }
    }
    if (this.type == URI.Type.RADIO) {
      components = components.shift().split(':');
    }
    var result = URI.applicationURI(id, components);
    return result;
  }
};

/**
 * Creates a URI object from an application URI object.
 *
 * If the current URI object is not an application type, a copy is made.
 *
 * @return {URI} The current URI as a real typed URI.
 */
URI.prototype.toRealType = function() {
  if (this.type == URI.Type.APPLICATION) {
    return _parseFromComponents([this.id].concat(this.args), Format.URI);
  } else {
    return new URI(null, this);
  }
};

/**
 * Returns the URI representation of this URI.
 *
 * @return {String} The URI representation of this uri.
 */
URI.prototype.toURI = function() {
  return URI_PREFIX + _getComponents(this, Format.URI).join(':');
};

/**
 * Returns the String representation of this URI.
 *
 * @return {String} The URI representation of this uri.
 * @see {URI#toURI}
 */
URI.prototype.toString = function() {
  return this.toURI();
};

/**
 * Get the URL path of this uri.
 *
 * @param {boolean} opt_leadingSlash True if a leading slash should be prepended.
 * @return {String} The path of this uri.
 */
URI.prototype.toURLPath = function(opt_leadingSlash) {
  var components = _getComponents(this, Format.URL);
  if (components[0] === URI.Type.APP) {
    components.shift();
  }

  // Some URIs are allowed to have empty components. It should be investigated
  // whether we need to strip empty components at all from any URIs. For now,
  // we check specifically for tracksets and local tracks and strip empty
  // components for all other URIs.
  //
  // For tracksets, it's permissible to have a path that looks like
  // 'trackset//trackURI' because the identifier parameter for a trackset can
  // be blank. For local tracks, some metadata can be missing, like missing
  // album name would be 'spotify:local:artist::track:duration'.
  var isTrackset = components[0] === URI.Type.TRACKSET;
  var isLocalTrack = components[0] === URI.Type.LOCAL;
  var shouldStripEmptyComponents = !isTrackset && !isLocalTrack;

  if (shouldStripEmptyComponents) {
    var _temp = [];
    for (var i = 0, l = components.length; i < l; i++) {
      var component = components[i];
      if (!!component) {
        _temp.push(component);
      }
    }
    components = _temp;
  }
  var path = components.join('/');
  return opt_leadingSlash ? '/' + path : path;
};

/**
 * Returns the Play URL string for the uri.
 *
 * @return {string} The Play URL string for the uri.
 */
URI.prototype.toPlayURL = function() {
    return PLAY_HTTPS_PREFIX + this.toURLPath();
};

/**
 * Returns the URL string for the uri.
 *
 * @return {string} The URL string for the uri.
 * @see {URL#toPlayURL}
 */
URI.prototype.toURL = function() {
  return this.toPlayURL();
};

/**
 * Returns the Open URL string for the uri.
 *
 * @return {string} The Open URL string for the uri.
 */
URI.prototype.toOpenURL = function() {
  return OPEN_HTTPS_PREFIX + this.toURLPath();
};

/**
 * Returns the Play HTTPS URL string for the uri.
 *
 * @return {string} The Play HTTPS URL string for the uri.
 */
URI.prototype.toSecurePlayURL = function() {
    return this.toPlayURL();
};

/**
 * Returns the HTTPS URL string for the uri.
 *
 * @return {string} The HTTPS URL string for the uri.
 * @see {URL#toSecurePlayURL}
 */
URI.prototype.toSecureURL = function() {
  return this.toPlayURL();
};

/**
 * Returns the Open HTTPS URL string for the uri.
 *
 * @return {string} The Open HTTPS URL string for the uri.
 */
URI.prototype.toSecureOpenURL = function() {
  return this.toOpenURL();
};

/**
 * Returns the id of the uri as a bytestring.
 *
 * @return {Array} The id of the uri as a bytestring.
 */
URI.prototype.idToByteString = function() {
  var data = Base62.toBytes(this._base62Id);
  data = data.map(function(i) {
    return String.fromCharCode(i);
  }).join('');
  while (data.length < 16) {
    data = String.fromCharCode(0) + data;
  }
  return data;
};

URI.prototype.getPath = function() {
  var uri = this.toString().replace(/[#?].*/, '');
  return uri;
}

URI.prototype.getBase62Id = function() {
  return this._base62Id;
}

/**
 * The various URI Types.
 *
 * Note that some of the types in this enum are not real URI types, but are
 * actually URI particles. They are marked so.
 *
 * @enum {string}
 */
URI.Type = {
  EMPTY: 'empty',
  ALBUM: 'album',
  AD: 'ad',
  /** URI particle; not an actual URI. */
  APP: 'app',
  APPLICATION: 'application',
  ARTIST: 'artist',
  ARTIST_TOPLIST: 'artist-toplist',
  AUDIO_FILE: 'audiofile',
  COLLECTION: 'collection',
  COLLECTION_ALBUM: 'collection-album',
  COLLECTION_MISSING_ALBUM: 'collection-missing-album',
  COLLECTION_ARTIST: 'collection-artist',
  CONTEXT_GROUP: 'context-group',
  EPISODE: 'episode',
  /** URI particle; not an actual URI. */
  FACEBOOK: 'facebook',
  FOLDER: 'folder',
  FOLLOWERS: 'followers',
  FOLLOWING: 'following',
  /** URI particle; not an actual URI. */
  GLOBAL: 'global',
  IMAGE: 'image',
  INBOX: 'inbox',
  LOCAL_ARTIST: 'local-artist',
  LOCAL_ALBUM: 'local-album',
  LOCAL: 'local',
  LIBRARY: 'library',
  MOSAIC: 'mosaic',
  PLAYLIST: 'playlist',
  PROFILE: 'profile',
  PUBLISHED_ROOTLIST: 'published-rootlist',
  RADIO: 'radio',
  ROOTLIST: 'rootlist',
  COLLECTION_TRACK_LIST: 'collectiontracklist',
  SEARCH: 'search',
  SHOW: 'show',
  CONCERT: 'concert',
  SPECIAL: 'special',
  STARRED: 'starred',
  STATION: 'station',
  TEMP_PLAYLIST: 'temp-playlist',
  /** URI particle; not an actual URI. */
  TOP: 'top',
  TOPLIST: 'toplist',
  TRACK: 'track',
  TRACKSET: 'trackset',
  /** URI particle; not an actual URI. */
  USER: 'user',
  USER_TOPLIST: 'user-toplist',
  USER_TOP_TRACKS: 'user-top-tracks',
  /** Deprecated contant. Please use USER_TOP_TRACKS. */
  USET_TOP_TRACKS: 'user-top-tracks'
};

/**
 * Creates a new URI object from a parsed string argument.
 *
 * @param {string} str The string that will be parsed into a URI object.
 * @throws TypeError If the string argument is not a valid URI, a TypeError will
 *     be thrown.
 * @return {URI} The parsed URI object.
 */
URI.fromString = function(str) {
  var splitted = _splitIntoComponents(str);
  return _parseFromComponents(splitted.components, splitted.format, splitted.query);
};

/**
 * Parses a given object into a URI instance.
 *
 * Unlike URI.fromString, this function could receive any kind of value. If
 * the value is already a URI instance, it is simply returned.
 * Otherwise the value will be stringified before parsing.
 *
 * This function also does not throw an error like URI.fromString, but
 * instead simply returns null if it can't parse the value.
 *
 * @param {*} value The value to parse.
 * @return {URI?} The corresponding URI instance, or null if the
 *     passed value is not a valid value.
 */
URI.from = function(value) {
  try {
    if (value instanceof URI) {
      return value;
    }
    if (typeof value == 'object' && value.type) {
      return new URI(null, value);
    }
    return URI.fromString(value.toString());
  } catch(e) {
    return null;
  }
};

/**
 * Creates a new URI from a bytestring.
 *
 * @param {URI.Type} type The type of the URI.
 * @param {ByteString} idByteString The ID of the URI as a bytestring.
 * @param {Object} opt_args Optional arguments to the URI constructor.
 * @return {URI} The URI object created.
 */
URI.fromByteString = function(type, idByteString, opt_args) {
  var bytes = [];
  for (var i = 0; i < idByteString.length; i++) {
    bytes.push(idByteString.charCodeAt(i));
  }
  var id = Base62.fromBytes(bytes, 22);
  var args = opt_args || {};
  args.id = id;
  return new URI(type, args);
};

/**
 * Clones a given SpotifyURI instance.
 *
 * @param {URI} uri The uri to clone.
 * @return {URI?} An instance of URI.
 */
URI.clone = function(uri) {
  if (!(uri instanceof URI)) {
    return null;
  }
  return new URI(null, uri);
};

/**
 * @deprecated
 */
URI.getCanonical = function(username) {
  return this.getCanonical(username);
};

/**
 * Returns the canonical representation of a username.
 *
 * @param {string} username The username to encode.
 * @return {string} The encoded canonical representation of the username.
 */
URI.getCanonicalUsername = function(username) {
  return _encodeComponent(username, Format.URI);
};

/**
 * Returns the non-canonical representation of a username.
 *
 * @param {string} username The username to encode.
 * @return {string} The unencoded canonical representation of the username.
 */
URI.getDisplayUsername = function(username) {
  return _decodeComponent(username, Format.URI);
};

/**
 * Returns the hex representation of a Base62 encoded id.
 *
 * @param {string} id The base62 encoded id.
 * @return {string} The hex representation of the base62 id.
 */
URI.idToHex = function(id) {
  if (id.length == 22) {
    return Base62.toHex(id, 32);
  }
  return id;
};

/**
 * Returns the base62 representation of a hex encoded id.
 *
 * @param {string} hex The hex encoded id.
 * @return {string} The base62 representation of the id.
 */
URI.hexToId = function(hex) {
  if (hex.length == 32) {
    return Base62.fromHex(hex, 22);
  }
  return hex;
};

/**
 * Creates a new empty URI.
 *
 * @return {URI} The empty URI.
 */
URI.emptyURI = function() {
  return new URI(URI.Type.EMPTY, {});
};

/**
 * Creates a new 'album' type URI.
 *
 * @param {string} id The id of the album.
 * @param {number} disc The disc number of the album.
 * @return {URI} The album URI.
 */
URI.albumURI = function(id, disc) {
  return new URI(URI.Type.ALBUM, {id: id, disc: disc});
};

/**
 * Creates a new 'ad' type URI.
 *
 * @param {string} id The id of the ad.
 * @return {URI} The ad URI.
 */
URI.adURI = function(id) {
  return new URI(URI.Type.AD, {id: id});
};

/**
 * Creates a new 'audiofile' type URI.
 *
 * @param {string} extension The extension of the audiofile.
 * @param {string} id The id of the extension.
 * @return {URI} The audiofile URI.
 */
URI.audioFileURI = function(extension, id) {
  return new URI(URI.Type.AUDIO_FILE, {id: id, extension: extension});
};

/**
 * Creates a new 'artist' type URI.
 *
 * @param {string} id The id of the artist.
 * @return {URI} The artist URI.
 */
URI.artistURI = function(id) {
  return new URI(URI.Type.ARTIST, {id: id});
};

/**
 * Creates a new 'artist-toplist' type URI.
 *
 * @param {string} id The id of the artist.
 * @param {string} toplist The toplist type.
 * @return {URI} The artist-toplist URI.
 */
URI.artistToplistURI = function(id, toplist) {
  return new URI(URI.Type.ARTIST_TOPLIST, {id: id, toplist: toplist});
};

/**
 * Creates a new 'search' type URI.
 *
 * @param {string} query The unencoded search query.
 * @return {URI} The search URI
 */
URI.searchURI = function(query) {
  return new URI(URI.Type.SEARCH, {query: query});
};

/**
 * Creates a new 'track' type URI.
 *
 * @param {string} id The id of the track.
 * @param {string} anchor The point in the track formatted as mm:ss
 * @return {URI} The track URI.
 */
URI.trackURI = function(id, anchor, context, play) {
  return new URI(URI.Type.TRACK, {
    id: id,
    anchor: anchor,
    context: context ? URI.fromString(context) : context,
    play: play
  });
};

/**
 * Creates a new 'trackset' type URI.
 *
 * @param {Array.<URI>} tracks An array of 'track' type URIs.
 * @param {string} name The name of the trackset.
 * @param {number} index The index in the trackset.
 * @return {URI} The trackset URI.
 */
URI.tracksetURI = function(tracks, name, index) {
  return new URI(URI.Type.TRACKSET, {
    tracks: tracks,
    name: name || '',
    index: isNaN(index) ? null : index
  });
};

/**
 * Creates a new 'facebook' type URI.
 *
 * @param {string} uid The user id.
 * @return {URI} The facebook URI.
 */
URI.facebookURI = function(uid) {
  return new URI(URI.Type.FACEBOOK, {uid: uid});
};

/**
 * Creates a new 'followers' type URI.
 *
 * @param {string} username The non-canonical username.
 * @return {URI} The followers URI.
 */
URI.followersURI = function(username) {
  return new URI(URI.Type.FOLLOWERS, {username: username});
};

/**
 * Creates a new 'following' type URI.
 *
 * @param {string} username The non-canonical username.
 * @return {URI} The following URI.
 */
URI.followingURI = function(username) {
  return new URI(URI.Type.FOLLOWING, {username: username});
};

/**
 * Creates a new 'playlist' type URI.
 *
 * @param {string} username The non-canonical username of the playlist owner.
 * @param {string} id The id of the playlist.
 * @return {URI} The playlist URI.
 */
URI.playlistURI = function(username, id) {
  return new URI(URI.Type.PLAYLIST, {username: username, id: id});
};

/**
 * Creates a new 'folder' type URI.
 *
 * @param {string} username The non-canonical username of the folder owner.
 * @param {string} id The id of the folder.
 * @return {URI} The folder URI.
 */
URI.folderURI = function(username, id) {
  return new URI(URI.Type.FOLDER, {username: username, id: id});
};

/**
 * Creates a new 'collectiontracklist' type URI.
 *
 * @param {string} username The non-canonical username of the collection owner.
 * @param {string} id The id of the tracklist.
 * @return {URI} The collectiontracklist URI.
 */
URI.collectionTrackList = function(username, id) {
  return new URI(URI.Type.COLLECTION_TRACK_LIST, {username: username, id: id});
};

/**
 * Creates a new 'starred' type URI.
 *
 * @param {string} username The non-canonical username of the starred list owner.
 * @return {URI} The starred URI.
 */
URI.starredURI = function(username) {
  return new URI(URI.Type.STARRED, {username: username});
};

/**
 * Creates a new 'user-toplist' type URI.
 *
 * @param {string} username The non-canonical username of the toplist owner.
 * @param {string} toplist The toplist type.
 * @return {URI} The user-toplist URI.
 */
URI.userToplistURI = function(username, toplist) {
  return new URI(URI.Type.USER_TOPLIST, {username: username, toplist: toplist});
};

/**
 * Creates a new 'user-top-tracks' type URI.
 *
 * @deprecated
 * @param {string} username The non-canonical username of the toplist owner.
 * @return {URI} The user-top-tracks URI.
 */
URI.userTopTracksURI = function(username) {
  return new URI(URI.Type.USER_TOP_TRACKS, {username: username});
};

/**
 * Creates a new 'toplist' type URI.
 *
 * @param {string} toplist The toplist type.
 * @param {string} country The country code for the toplist.
 * @param {boolean} global True if this is a global rather than a country list.
 * @return {URI} The toplist URI.
 */
URI.toplistURI = function(toplist, country, global) {
  return new URI(URI.Type.TOPLIST, {toplist: toplist, country: country, global: !!global});
};

/**
 * Creates a new 'inbox' type URI.
 *
 * @param {string} username The non-canonical username of the inbox owner.
 * @return {URI} The inbox URI.
 */
URI.inboxURI = function(username) {
  return new URI(URI.Type.INBOX, {username: username});
};

/**
 * Creates a new 'rootlist' type URI.
 *
 * @param {string} username The non-canonical username of the rootlist owner.
 * @return {URI} The rootlist URI.
 */
URI.rootlistURI = function(username) {
  return new URI(URI.Type.ROOTLIST, {username: username});
};

/**
 * Creates a new 'published-rootlist' type URI.
 *
 * @param {string} username The non-canonical username of the published-rootlist owner.
 * @return {URI} The published-rootlist URI.
 */
URI.publishedRootlistURI = function(username) {
  return new URI(URI.Type.PUBLISHED_ROOTLIST, {username: username});
};

/**
 * Creates a new 'local-artist' type URI.
 *
 * @param {string} artist The artist name.
 * @return {URI} The local-artist URI.
 */
URI.localArtistURI = function(artist) {
  return new URI(URI.Type.LOCAL_ARTIST, {artist: artist});
};

/**
 * Creates a new 'local-album' type URI.
 *
 * @param {string} artist The artist name.
 * @param {string} album The album name.
 * @return {URI} The local-album URI.
 */
URI.localAlbumURI = function(artist, album) {
  return new URI(URI.Type.LOCAL_ALBUM, {artist: artist, album: album});
};

/**
 * Creates a new 'local' type URI.
 *
 * @param {string} artist The artist name.
 * @param {string} album The album name.
 * @param {string} track The track name.
 * @param {number} duration The track duration in ms.
 * @return {URI} The local URI.
 */
URI.localURI = function(artist, album, track, duration) {
  return new URI(URI.Type.LOCAL, {
    artist: artist,
    album: album,
    track: track,
    duration: duration
  });
};

/**
 * Creates a new 'library' type URI.
 *
 * @param {string} username The non-canonical username of the rootlist owner.
 * @param {string} category The category of the library.
 * @return {URI} The library URI.
 */
URI.libraryURI = function(username, category) {
  return new URI(URI.Type.LIBRARY, {username: username, category: category});
};

/**
 * Creates a new 'collection' type URI.
 *
 * @param {string} username The non-canonical username of the rootlist owner.
 * @param {string} category The category of the collection.
 * @return {URI} The collection URI.
 */
URI.collectionURI = function(username, category) {
  return new URI(URI.Type.COLLECTION, {username: username, category: category});
};

/**
 * Creates a new 'temp-playlist' type URI.
 *
 * @param {string} origin The origin of the temporary playlist.
 * @param {string} data Additional data for the playlist.
 * @return {URI} The temp-playlist URI.
 */
URI.temporaryPlaylistURI = function(origin, data) {
  return new URI(URI.Type.TEMP_PLAYLIST, {origin: origin, data: data});
};

/**
 * Creates a new 'context-group' type URI.
 *
 * @deprecated
 * @param {string} origin The origin of the temporary playlist.
 * @param {string} name The name of the context group.
 * @return {URI} The context-group URI.
 */
URI.contextGroupURI = function(origin, name) {
  return new URI(URI.Type.CONTEXT_GROUP, {origin: origin, name: name});
};

/**
 * Creates a new 'profile' type URI.
 *
 * @param {string} username The non-canonical username of the rootlist owner.
 * @param {Array.<string>} args A list of arguments.
 * @return {URI} The profile URI.
 */
URI.profileURI = function(username, args) {
  return new URI(URI.Type.PROFILE, {username: username, args: args});
};

/**
 * Creates a new 'image' type URI.
 *
 * @param {string} id The id of the image.
 * @return {URI} The image URI.
 */
URI.imageURI = function(id) {
  return new URI(URI.Type.IMAGE, {id: id});
};

/**
 * Creates a new 'mosaic' type URI.
 *
 * @param {Array.<string>} ids The ids of the mosaic immages.
 * @return {URI} The mosaic URI.
 */
URI.mosaicURI = function(ids) {
  return new URI(URI.Type.MOSAIC, {ids: ids});
};

/**
 * Creates a new 'radio' type URI.
 *
 * @param {string} args The radio seed arguments.
 * @return {URI} The radio URI.
 */
URI.radioURI = function(args) {
  args = typeof args === 'undefined' ? '' : args;
  return new URI(URI.Type.RADIO, {args: args});
};

/**
 * Creates a new 'special' type URI.
 *
 * @param {Array.<string>} args An array containing the other arguments.
 * @return {URI} The special URI.
 */
URI.specialURI = function(args) {
  args = typeof args === 'undefined' ? [] : args;
  return new URI(URI.Type.SPECIAL, {args: args});
};

/**
 * Creates a new 'station' type URI.
 *
 * @param {Array.<string>} args An array of arguments for the station.
 * @return {URI} The station URI.
 */
URI.stationURI = function(args) {
  args = typeof args === 'undefined' ? [] : args;
  return new URI(URI.Type.STATION, {args: args});
};

/**
 * Creates a new 'application' type URI.
 *
 * @param {string} id The id of the application.
 * @param {Array.<string>} args An array containing the arguments to the app.
 * @return {URI} The application URI.
 */
URI.applicationURI = function(id, args) {
  args = typeof args === 'undefined' ? [] : args;
  return new URI(URI.Type.APPLICATION, {id: id, args: args});
};

/**
 * Creates a new 'collection-album' type URI.
 *
 * @param {string} username The non-canonical username of the rootlist owner.
 * @param {string} id The id of the album.
 * @return {URI} The collection-album URI.
 */
URI.collectionAlbumURI = function(username, id) {
  return new URI(URI.Type.COLLECTION_ALBUM, {username: username, id: id});
};

/**
 * Creates a new 'collection-album-missing' type URI.
 *
 * @param {string} username The non-canonical username of the rootlist owner.
 * @param {string} id The id of the album.
 * @return {URI} The collection-album-missing URI.
 */
URI.collectionMissingAlbumURI = function(username, id) {
  return new URI(URI.Type.COLLECTION_MISSING_ALBUM, {username: username, id: id});
};

/**
 * Creates a new 'collection-artist' type URI.
 *
 * @param {string} username The non-canonical username of the rootlist owner.
 * @param {string} id The id of the artist.
 * @return {URI} The collection-artist URI.
 */
URI.collectionArtistURI = function(username, id) {
  return new URI(URI.Type.COLLECTION_ARTIST, {username: username, id: id});
};

/**
 * Creates a new 'episode' type URI.
 *
 * @param {string} id The id of the episode.
 * @param {string} context An optional context URI
 * @param {boolean} play Toggles autoplay in the episode URI
 * @return {URI} The episode URI.
 */
URI.episodeURI = function(id, context, play) {
  return new URI(URI.Type.EPISODE, {
    id: id,
    context: context ? URI.fromString(context) : context,
    play: play
  });
};

/**
 * Creates a new 'show' type URI.
 *
 * @param {string} id The id of the show.
 * @return {URI} The show URI.
 */
URI.showURI = function(id) {
  return new URI(URI.Type.SHOW, {id: id});
};

/**
 * Creates a new 'concert' type URI.
 *
 * @param {string} id The id of the concert.
 * @return {URI} The concert URI.
 */
URI.concertURI = function(id) {
  return new URI(URI.Type.CONCERT, {id: id});
};

/**
 * Export public interface
 */
module.exports = URI;

},{"spotify-crypto/base62":723}],731:[function(require,module,exports){
var player = require("./player");
var types = require("./types");
var play = require("./play");

exports.Play = play.Play;
exports.Player = player.Player;
exports.PlayerContext = types.Context;
exports.PlayOptions = types.PlayOptions;
exports.PlayerRestrictions = types.Restrictions;
exports.PlayerSuppressions = types.Suppressions;
exports.PlayerTrack = types.Track;
exports.PlayerContextPage = types.ContextPage;
exports.IndexPath = types.IndexPath;

},{"./play":732,"./player":733,"./types":734}],732:[function(require,module,exports){
var cosmos = require('spotify-cosmos-api');
var nodefn = require('when/node');

/**
 * Play is exposed as Player.Play. It represents a prepared playback action.
 * Play objects are obtained from the preparePlay method on the Player; the
 * constructor is not a public API.
 *
 * Instantiating a Play object does not make a Cosmos request, the caller is
 * expected to make that call and pass in a promise of the result in the
 * createSessionPromise parameter.
 *
 * @param {Cosmos.resolver} resolver The resolver to send requests to.
 * @param {Promise} createSessionPromise A promise of a Cosmos.Response for
 *     the call to sp://player/v2/xyz/session.
 * @param {Player} player The player that initiated the call.
 * @param {function()=Number} getTime Clock. Should usually return
 *     new Date().getTime()
 * @param {module:spotify-player/types.Context} The context that was passed
 *     to the preparePlay call.
 * @param {Cosmos.PlayOptions=} opt_options The options that were passed to
 *     the preparePlay call.
 */
function Play(resolver, createSessionPromise, player, getTime, context, opt_options) {
  if (!(this instanceof Play)) {
    return new Play(resolver, createSessionPromise, player, getTime, context, opt_options);
  }

  if (!resolver || !createSessionPromise || !player || !getTime || !context) {
    throw new TypeError('Missing parameters for Play');
  }

  /**
   * @type {Cosmos.resolver}
   */
  this._resolver = resolver;

  /**
   * @type {Promise}
   */
  this._createSessionPromise = createSessionPromise;

  /**
   * @type {Player}
   */
  this._player = player;

  /**
   * @type {function()=Number}
   */
  this._getTime = getTime;

  /**
   * @type {module:spotify-player/types.Context}
   */
  this._context = context;

  /**
   * @type {Cosmos.PlayOptions=}
   */
  this._opt_options = opt_options;
}

/**
 * @return Promise of the session URL
 */
Play.prototype._sessionUrl = function() {
  return this._createSessionPromise.then(function(response) {
    return response.getJSONBody().session;
  });
};

Play.prototype._createPlayRequest = function(sessionUrl) {
  var body = {
    logging_params: {
      command_initiated_time: this._getTime()
    }
  };
  return new cosmos.Request(cosmos.Action.POST, sessionUrl + '/play', null, body);
};

Play.prototype._createUpdateRequest = function(sessionUrl, body) {
  body.logging_params = {
    command_initiated_time: this._getTime()
  };
  return new cosmos.Request(cosmos.Action.POST, sessionUrl + '/update', null, body);
};

/**
 * Perform the playback action that this handle represents.
 *
 * It is legal to call play more than once, but the playback action is only
 * prefetched the first time. If subsequent preparation is required, a new
 * Play object should be obtained.
 */
Play.prototype.play = function(opt_callback) {
  opt_callback = opt_callback || function() {};

  var self = this;
  if (this._createSessionPromise) {
    this._sessionUrl()
      .then(function(sessionUrl) {
        return nodefn.call(
          self._resolver.resolve.bind(self._resolver), self._createPlayRequest(sessionUrl));
      })
      .done(function() {
          opt_callback(null);
        }, function(error) {
          if (error.response && error.response.getStatusCode() === 404) {
            // The session has been invalidated. Try again without prefetching.
            self._createSessionPromise = null;
            self.play(opt_callback);
          } else {
            var wrappedError = new Error('Failed to prepare player session: ' + error.message);
            wrappedError.cause = function() { return error; };
            opt_callback(wrappedError);
          }
        });
  } else {
    this._player.play(this._context, this._opt_options, opt_callback);
  }
};

Play.prototype._update = function(body, opt_callback) {
  opt_callback = opt_callback || function() {};

  var self = this;
  if (!this._createSessionPromise) {
    return opt_callback(new Error('Cannot update invalidated Play'));
  }

  this._sessionUrl()
    .then(function(sessionUrl) {
      return nodefn.call(
        self._resolver.resolve.bind(self._resolver), self._createUpdateRequest(sessionUrl, body));
    })
    .done(function() {
        opt_callback(null);
      }, function(error) {
        var wrappedError = new Error('Failed to update player session: ' + error.message);
        wrappedError.cause = function() { return error; };
        opt_callback(wrappedError);
      });
};

Play.prototype.updateContext = function(context, opt_callback) {
  this._update({ context: context }, opt_callback);
};

Play.prototype.updatePage = function(page, opt_callback) {
  this._update({ page: page }, opt_callback);
};

Play.prototype.updateTrack = function(track, opt_callback) {
  this._update({ track: track }, opt_callback);
};

Play.prototype.updateViewUri = function(view_uri, opt_callback) {
  this._update({ view_uri: view_uri }, opt_callback);
};

/**
 * Invalidate the handle. This will cause any ongoing prefetching work to be
 * cancelled. It is good if any holder of a handle calls this method as soon
 * as it knows that it is not interested in its play action anymore.
 *
 * It is illegal to call play after this has been called. Invalidating an
 * invalidated Play is a no-op.
 */
Play.prototype.invalidate = function(opt_callback) {
  if (!this._createSessionPromise) {
    // Already invalidated
    return;
  }

  opt_callback = opt_callback || function() {};

  var self = this;
  this._sessionUrl().done(function(sessionUrl) {
    var request = new cosmos.Request(
      cosmos.Action.DELETE, sessionUrl, null, null);
    self._resolver.resolve(request, function() {
      opt_callback(null);
    });
  }, function() {
    // Ignore errors
    opt_callback(null);
  });

  this._createSessionPromise = null;
};

exports.Play = Play;

},{"spotify-cosmos-api":720,"when/node":757}],733:[function(require,module,exports){
var cosmos = require('spotify-cosmos-api');
var nodefn = require('when/node');
var play = require('./play');

var PLAYER_URI = 'sp://player/v2/';
var DEFAULT_PLAYER_ID = 'main';

/**
 * The object decribing the context for the playback
 * Can be used to pass viewUri or externalReferrer specific
 * for the play action.
 *
 * @typedef {Object} ContextConfig
 * @property {Cosmos.PlayerContext} context The context to play
 * @property {string=} opt_viewId Optional. Set to override the default viewUri
 * @property {string=} opt_externalReferrer Optional. Set to indicate that
 *      the playback is owne by external website/app.
 */

/**
 * Player is the main entry point to control music playback with cosmos.
 *
 * Player in itself isn't what deals with playback; it is merely an object
 * that controls playback and provides ability to observe the player state.
 * There can be more than one Player object at the same time, and they
 * will sync up as one would expect.
 *
 * In practice there will be at least one Player object per feature that
 * wants to control playback. The feature can choose to create one per view
 * or have only one object, it doesn't really matter.
 *
 * @param {Cosmos.resolver} resolver The resolver to send requests to.
 * @param {String} viewUri The uri of the view that owns the playback.
 * @param {String} featureIdentifier The identifier of the feature that started
 *     playback. This is arguably the most important field of this class. It is
 *     used for logging messages, in particular EndSong and EndVideo. (In EndSong,
 *     it ends up in source_start / source_end.) It should be a short human
 *     readable name of the feature, for example "radio", "album", "playlist".
 *     Ideally, it should be the same for a given feature across platforms.
 *
 *     Each feature should have only one string constant that it passes in here.
 *     You must not pass lots of distinct values here; for instance do not send
 *     something that contains the username or artist identifier.
 * @param {String} featureVersion The version of the feature. It often makes sense to set
 *     this value to the version of the spm package, for instance "0.7.5".
 * @param {{playerId: string}} opt_options The additional parameters for the player.
 *  param {string} options.playerId Can be used to override the id of the player
 *      which will result in a different endpoint for the player requests.
 */
function Player(resolver, viewUri, featureIdentifier, featureVersion, opt_options) {
  if (!(this instanceof Player)) {
    return new Player(resolver, viewUri, featureIdentifier, featureVersion);
  }

  if (!resolver || !viewUri || !featureIdentifier || !featureVersion) {
    throw new TypeError('Missing parameters for Player');
  }

  this._getTime = opt_options && opt_options.getTime || function() {
    return new Date().getTime();
  };

  /**
   * @type {string}
   */
  this._id = opt_options && opt_options.playerId || DEFAULT_PLAYER_ID;

  /**
   * @type {string}
   */
  this._referrerIdentifier = opt_options && opt_options.referrerIdentifier;

  /**
   * @type {Cosmos.resolver}
   */
  this._resolver = resolver;

  /**
   * @type {string}
   */
  this._viewUri = viewUri;

  /**
   * @type {string}
   */
  this._featureId = featureIdentifier;

  /**
   * @type {string}
   */
  this._featureVersion = featureVersion;
}

/**
 * The actions that can be understood by the PlayerResolver
 * in Cosmos Router.
 */
Player.Actions = {
  PROBE_PLAY: 'probe_play',
  PLAY: 'play',
  SESSION: 'session',
  STOP: 'stop',
  UPDATE: 'update',
  PAUSE: 'pause',
  RESUME: 'resume',
  SKIP_NEXT: 'skip_next',
  SKIP_PREV: 'skip_prev',
  SHUFFLE: 'set_shuffling_context',
  REPEAT_CONTEXT: 'set_repeating_context',
  REPEAT_TRACK: 'set_repeating_track',
  SEEK_TO: 'seek_to'
};

/**
 * Private helper method for probe_play, play, and preparePlay
 */
Player.prototype._playOrPrepareOrProbe = function(action, context, opt_options, opt_callback) {
  if (!context)
    throw new TypeError('Invalid `context` object');

  // Allow to not send the opt_options
  if (opt_options instanceof Function && !opt_callback) {
    opt_callback = opt_options;
    opt_options = null;
  }

  var params = {};
  params.context = context;
  params.play_origin = this._makePlayOrigin();
  params.options = opt_options;

  return this._sendRequestWithParams(action, params, opt_callback);
};

/**
 * Add a track to the manually queued tracks.
 *
 * @param {string} state The track to queue.
 * @param {function(Error, Cosmos.Response=)} opt_callback If specified will be
 * executed
 *    after request is resolved.
 * @return {Cosmos.RequestHandler} The object representing current request.
 */
Player.prototype.addToQueue = function(track, opt_callback) {
  var requestUri = this.getPlayerEndpointUri() + '/add_to_queue';
  var request =
      new cosmos.Request(cosmos.Action.POST, requestUri, null, {track : track});
  return this._resolver.resolve(request, opt_callback);
};

/**
 * Asks the player if the given context is allowed to be played. This presents
 * the same API as play, but it will not actually initiate playback. Rather the
 * response status code will indicate if playback is permitted (200 OK) or not
 * (403 Forbidden).
 *
 * @see {@link Player#play}
 */
Player.prototype.probePlay = function(context, opt_options, opt_callback) {
  return this._playOrPrepareOrProbe(Player.Actions.PROBE_PLAY, context, opt_options, opt_callback);
};

/**
 * Plays the given context.
 * Since both options and callback are optional this method can
 * take from 1 to 3 arguments. if callback is specified, it has to be
 * the last argument:
 *
 *    player.play(myContext);
 *    player.play(myContext, myPlayOptions);
 *    player.play(myContext, function myCallback() {});
 *    player.play(myContext, myPlayOptions, function myCallback() {});
 *
 * @param {module:spotify-player/types.Context} context The context to play.
 * @param {Cosmos.PlayOptions=} opt_options Optional play options.
 * @param {function(Error, Cosmos.Response?)=} opt_callback Optional
 *    callback that will be executed after player request is resolved.
 *
 *    NOTE: The reponse in the callback only has information about the
 *    request itself (i.e. if it was resolved correctly). If you want to have
 *    information about currently playing context you should subscribe to
 *    player events or fetch the current state using. getContext.
 *
 * @return {Cosmos.RequestHandler} The object representing current request.
 */
Player.prototype.play = function(context, opt_options, opt_callback) {
  return this._playOrPrepareOrProbe(Player.Actions.PLAY, context, opt_options, opt_callback);
};

/**
 * This method is like play, but it doesn't actually initiate playback, it
 * merely expresses intent that the user is rather likely going to do a play
 * action like this soon.
 *
 * @return {Player.Play} A handle that is used for actually performing the
 *     playback action. When the object will no longer be used, the user is
 *     responsible for calling invalidate on it, otherwise it will keep
 *     holding resources. As long as this object is not invalidated, the
 *     playback system will take that as a hint that it should try to prepare
 *     playback like this.
 */
Player.prototype.preparePlay = function(context, opt_options) {
  var sessionPromise = nodefn.call(
    this._playOrPrepareOrProbe.bind(this), Player.Actions.SESSION, context, opt_options);

  return new play.Play(this._resolver, sessionPromise, this, this._getTime, context, opt_options);
};

/**
 * Stop the playback and clear the context.
 *
 * @param {function=} opt_callback If specified will be executed
 *    after request is resolved.
 * @return {Cosmos.RequestHandler} The object representing current request.
 */
Player.prototype.stop = function(opt_callback) {
  return this._sendRequestWithAction(Player.Actions.STOP, opt_callback);
};

/**
 * Update the current context.
 *
 * @see https://short.spotify.net/0I for more detailed information on the
 *    implementation.
 *
 * @param {module:spotify-player/types.Context} context The context to update to.
 * @param {function=} opt_callback If specified will be executed
 *    after request is resolved.
 * @return {Cosmos.RequestHandler} The object representing current request.
 */
Player.prototype.update = function(context, opt_callback) {
  if (!context)
    throw new TypeError('Invalid `context` object');

  var params = { context: context };
  return this._sendRequestWithParams(Player.Actions.UPDATE, params, opt_callback);
};

/**
 * Resume the playback.
 *
 * @param {function=} opt_callback If specified will be executed
 *    after request is resolved.
 * @return {Cosmos.RequestHandler} The object representing current request.
 */
Player.prototype.resume = function(opt_callback) {
  return this._sendRequestWithAction(Player.Actions.RESUME, opt_callback);
};

/**
 * Pause the playback.
 *
 * @param {function=} opt_callback If specified will be executed
 *    after request is resolved.
 * @return {Cosmos.RequestHandler} The object representing current request.
 */
Player.prototype.pause = function(opt_callback) {
  return this._sendRequestWithAction(Player.Actions.PAUSE, opt_callback);
};

/**
 * Skip to the previous song.
 *
 * @param {Object=} opt_skip_options The object with the skip options
 *    like allow_seeking
 * @param {function=} opt_callback If specified will be executed
 *    after request is resolved.
 * @return {Cosmos.RequestHandler} The object representing current request.
 */
Player.prototype.skipToPrevTrack = function(opt_skip_options, opt_callback) {
  if (arguments.length === 1) {
    // In order to keep backwards compatibility we still need to support
    // passing just the callback as the first parameter
    if (typeof opt_skip_options === 'function') {
      opt_callback = opt_skip_options;
      opt_skip_options = null;
    }
  }
  var params = {};
  if (opt_skip_options) {
    params.options = opt_skip_options;
  }
  return this._sendRequestWithParams(Player.Actions.SKIP_PREV, params, opt_callback);
};

/**
 * Skip to the next song.
 *
 * @param {function=} opt_callback If specified will be executed
 *    after request is resolved.
 * @return {Cosmos.RequestHandler} The object representing current request.
 */
Player.prototype.skipToNextTrack = function(opt_options, opt_callback) {
  if (arguments.length === 1) {
    // In order to keep backwards compatibility we still need to support
    // passing just the callback as the first parameter
    if (typeof opt_options === 'function') {
      opt_callback = opt_options;
      opt_options = null;
    }
  }
  var params = {};
  if (opt_options) {
    params.options = opt_options;
  }
  return this._sendRequestWithParams(Player.Actions.SKIP_NEXT, params, opt_callback);
};

/**
 * Skip backwards until it gets to the specified track. This method never skips
 * to the beginning of the current track. For that, use seekTo.
 *
 * @discussion If the reverse runs out of tracks or skipping becomes disallowed
 *    for some other reason, this method will give up when it can no longer
 *    continue. This means that calling this for MFT users will almost
 *    certainly be a bad idea.
 *
 *    The intended purpose of this method is to make it possible to implement
 *    a view of the current future/reverse and allow the user to skip in it.
 *
 *    This method will look at the track URI and the track's UID (if present)
 *    to determine when it has reached its goal.
 *
 * @param {Object} track The track object, as it was provided from the
 *    player state reverse.
 * @param {function=} opt_callback If specified will be executed
 *    after request is resolved.
 * @return {Cosmos.RequestHandler} The object representing current request.
 */
Player.prototype.skipToSpecificPrevTrack = function(track, opt_callback) {
  return this._sendRequestWithParams(Player.Actions.SKIP_PREV, { track: track }, opt_callback);
};

/**
 * Skip forwards until it gets to the specified track.
 *
 * @discussion See discussion for -skipToPreviousTrack:
 *
 * @param {Object} track The track object, as it was provided from the
 *    player state reverse.
 * @param {function=} opt_callback If specified will be executed
 *    after request is resolved.
 * @return {Cosmos.RequestHandler} The object representing current request.
 */
Player.prototype.skipToSpecificNextTrack = function(track, opt_callback) {
  return this._sendRequestWithParams(Player.Actions.SKIP_NEXT, { track: track }, opt_callback);
};

/**
 * Deprecated alias for skipToPrevTrack
 */
Player.prototype.skipToPrev = Player.prototype.skipToPrevTrack;

/**
 * Deprecated alias for skipToNextTrack
 */
Player.prototype.skipToNext = Player.prototype.skipToNextTrack;

/**
 * Set the shuffle flag
 *
 * @param {boolean} isShuffling The value of the flag to set.
 * @param {function=} opt_callback If specified will be executed
 *    after request is resolved.
 * @return {Cosmos.RequestHandler} The object representing current request.
 */
Player.prototype.setShufflingContext = function(isShuffling, opt_callback) {
  return this._sendRequestWithParam(Player.Actions.SHUFFLE, isShuffling, opt_callback);
};

/**
 * Repeat the whole context
 *
 * @param {boolean} isRepeating The value of the flag to set.
 * @param {function=} opt_callback If specified will be executed
 *    after request is resolved.
 * @return {Cosmos.RequestHandler} The object representing current request.
 */
Player.prototype.setRepeatingContext = function(isRepeating, opt_callback) {
  return this._sendRequestWithParam(Player.Actions.REPEAT_CONTEXT, isRepeating, opt_callback);
};

/**
 * Repeat the single track
 *
 * @param {boolean} isRepeating The value of the flag to set.
 * @param {function=} opt_callback If specified will be executed
 *    after request is resolved.
 * @return {Cosmos.RequestHandler} The object representing current request.
 */
Player.prototype.setRepeatingTrack = function(isRepeating, opt_callback) {
  return this._sendRequestWithParam(Player.Actions.REPEAT_TRACK, isRepeating, opt_callback);
};

/**
 * Set the seek position. It should be set in seconds.
 *
 * @param {boolean} positionInMs Position to seek to in miliseconds.
 * @param {function=} opt_callback If specified will be executed
 *    after request is resolved.
 * @return {Cosmos.RequestHandler} The object representing current request.
 */
Player.prototype.seekTo = function(positionInMs, opt_callback) {
  return this._sendRequestWithParam(Player.Actions.SEEK_TO, positionInMs, opt_callback);
};

/**
 * Gets the current player state as an opaque string that can later be used to restore the
 * current state.
 *
 * @param {function(Error, Cosmos.Response=)} callback The function
 *    that will be called when the snapshot is available.
 * @return {Cosmos.RequestHandler} The object representing current request.
 */
Player.prototype.save = function(callback) {
  var requestUri = this.getPlayerEndpointUri() + '/snapshot';
  var request = new cosmos.Request(cosmos.Action.GET, requestUri);
  return this._resolver.resolve(request, callback);
};

/**
 * Restores a state string that was previously saved by save().
 *
 * @param {string} state The state to restore.
 * @param {function(Error, Cosmos.Response=)} opt_callback If specified will be executed
 *    after request is resolved.
 * @return {Cosmos.RequestHandler} The object representing current request.
 */
Player.prototype.restore = function(state, opt_callback) {
  var requestUri = this.getPlayerEndpointUri() + '/snapshot';
  var request = new cosmos.Request(cosmos.Action.PUT, requestUri, null, state);
  return this._resolver.resolve(request, opt_callback);
};

/**
 * Gets the current player queue as an string that can later be modified to replace
 * the current queue.
 *
 * @param {function(Error, Cosmos.Response=)} callback The function
 *    that will be called when the queue is available.
 * @return {Cosmos.RequestHandler} The object representing current request.
 */

Player.prototype.getQueue = function(callback) {
  var requestUri = this.getPlayerEndpointUri() + '/queue';
  var request = new cosmos.Request(cosmos.Action.GET, requestUri);
  return this._resolver.resolve(request, callback);
};

/**
 * Replace the player queue. The state will not replace the current one of the player if
 * the revision does not match the current revision of the player. This happens when
 * the player queue was changed elsewhere by the time it was received until it was set.
 * A response-status of 409 will inform about this situation.
 *
 * @param {string} state The queue-state to replace with.
 * @param {function(Error, Cosmos.Response=)} opt_callback If specified will be executed
 *    after request is resolved.
 * @return {Cosmos.RequestHandler} The object representing current request.
 */
Player.prototype.setQueue = function(state, opt_callback) {
  var requestUri = this.getPlayerEndpointUri() + '/queue';
  var request = new cosmos.Request(cosmos.Action.PUT, requestUri, null, state);
  return this._resolver.resolve(request, opt_callback);
};

/**
 * Subscribe to queue changes. There will be an initial callback when subscribing.
 */
Player.prototype.subscribeToQueue = function(callback) {
  var request = new cosmos.Request(cosmos.Action.SUB, this.getPlayerEndpointUri() + '/queue');
  return this._resolver.resolve(request, callback);
};

/**
 * Get the current player state.
 *
 * @param {function(Error, Cosmos.Response=)} callback The function
 *    that will be called when the state is available.
 * @param {Object=} opt_params The additional parameters for the request.
 * @return {Cosmos.RequestHandler} The object representing current request.
 */
Player.prototype.getState = function(callback, opt_params) {
  var request = new cosmos.Request(
    cosmos.Action.GET, this.getPlayerEndpointUriWithParams(opt_params));
  return this._resolver.resolve(request, callback);
};

/**
 * Subscribe to the player events
 *
 * @param {function(Error, Cosmos.Response=)} callback The function
 *    that will be called every time the event occurs.
 * @param {Object=} opt_params The additional parameters for the request.
 * @return {RequestHandle} The subscription handle.
 *
 *    This object can be used to cancel the subscription
 *    by calling 'cancel()' on it:
 *
 *    var sub = player.subscribe(function(err, response) { });
 *    sub.cancel();
 */
Player.prototype.subscribe = function(callback, opt_params) {
  var request = new cosmos.Request(
    cosmos.Action.SUB, this.getPlayerEndpointUriWithParams(opt_params));
  return this._resolver.resolve(request, callback);
};

/**
 * Subscribe to player error events
 */
Player.prototype.onError = function(callback) {
  var request = new cosmos.Request(cosmos.Action.SUB, this.getPlayerEndpointUri() + '/error');
  return this._resolver.resolve(request, callback);
};

Player.prototype._makePlayOrigin = function() {
  return {
    view_uri: this._viewUri,
    feature_identifier: this._featureId,
    feature_version: this._featureVersion,
    referrer_identifier: this._referrerIdentifier
  };
};

Player.prototype.getPlayerEndpointUri = function() {
  return PLAYER_URI + this._id;
};

Player.prototype.getPlayerEndpointUriWithParams = function(params) {
  params = params || {};

  var paramsArray = Object.keys(params).reduce(function(arr, key) {
    arr.push(key + '=' + encodeURIComponent(params[key]));
    return arr;
  }, []);

  if (paramsArray.length > 0) {
    return this.getPlayerEndpointUri() + '?' + paramsArray.join('&');
  } else {
    return this.getPlayerEndpointUri();
  }
};

/**
 * @private
 * Sends context-less request.
 *
 * @param {string} action The action to perform on the player.
 * @param {function=} opt_callback If specified will be executed
 *    after request is resolved.
 * @return {Cosmos.RequestHandler} The object representing current request.
 */
Player.prototype._sendRequestWithAction = function(action, opt_callback) {
  return this._sendRequestWithParams(action, null, opt_callback);
};

/**
 * @private
 * Sends the request that only expects the single value in the body.
 *
 * @param {string} action The action to perform on the player.
 * @param {*} paramValue The value to send to the player.
 * @param {function=} opt_callback If specified will be executed
 *    after request is resolved.
 * @return {Cosmos.RequestHandler} The object representing current request.
 */
Player.prototype._sendRequestWithParam = function(action, paramValue, opt_callback) {
  var params = {
    value: paramValue
  };
  return this._sendRequestWithParams(action, params, opt_callback);
};

/**
 * @private
 * Sends request with context and optional options.
 *
 * @param {string} action The action to perform on the player.
 * @param {Object?} params The context to play.
 * @param {function=} opt_callback If specified will be executed
 *    after request is resolved.
 * @return {Cosmos.RequestHandler} The object representing current request.
 */
Player.prototype._sendRequestWithParams = function(action, params, opt_callback) {
  var requestUri = this.getPlayerEndpointUri() + '/' + action;
  var body = params || {};
  body.logging_params = {
    command_initiated_time: this._getTime()
  };
  var request = new cosmos.Request(
    cosmos.Action.POST, requestUri, null, body);
  return this._resolver.resolve(request, opt_callback);
};

exports.Player = Player;

},{"./play":732,"spotify-cosmos-api":720,"when/node":757}],734:[function(require,module,exports){
/**
 * A PlayerTrack represents a single track in a context.
 *
 * @typedef {Object}
 * @property {String} uri
 *    The URI of the track. This will be one of the Spotify URIs, such as
 *    spotify:track:GID or spotify:local:DATA.
 * @property {String} album_uri
 *    The URI of the album that the track appears on. This property must always
 *    be set if the track URI is set. This is a requirement so that functions
 *    like MFT rules and biased shuffle can operate without having to fetch
 *    additional metadata for each track.
 * @property {String} artist_uri
 *    The URI of the main artist of the track. This property must always be set
 *    if the track URI is set. This is a requirement so that functions like MFT
 *    rules and biased shuffle can operate without having to fetch additional
 *    metadata for each track.
 * @property {Object} metadata
 *    A map with custom metadata for the track. This map can hold anything that
 *    the feature decides to put in it. Features should be prepared that the
 *    metadata can disappear and be able to work around that situation.
 *    The metadata is passed around and persisted, so it will usually stick
 *    around, but there are certain situations where the data is lost because of
 *    transferring the track over legacy protocols, to Connect enabled speakers
 *    and back.
 */
exports.Track;

/**
 * PlayerRestrictions is used to encapsulate limitations of a player or a
 * context. The caller can specify that restrictions should apply when playing a
 * given context (see PlayerContext.restrictions), and a player can notify that
 * restrictions (see PlayState.restrictions).
 *
 * @typedef {Object}
 * @property {Array.<String>} disallow_skipping_prev_reasons
 *    The reasons why skipping to the previous track should be / is disallowed.
 * @property {Array.<String>} disallow_skipping_next_reasons
 *    The reasons why skipping to the next track should be / is disallowed.
 * @property {Array.<String>} disallow_peeking_prev_reasons
 *    The reasons why peeking at the previous track should be / is disallowed.
 * @property {Array.<String>} disallow_peeking_next_reasons
 *    The reasons why peeking at the next track should be / is disallowed.
 * @property {Array.<String>} disallow_skipping_to_reasons
 *    The reasons why skipping to a specific track should be / is disallowed.
 * @property {Array.<String>} disallow_pausing_reasons
 *    The reasons why pausing playback should be / is disallowed.
 * @property {Array.<String>} disallow_resuming_reasons
 *    The reasons why resuming playback should be / is disallowed.
 * @property {Array.<String>} disallow_toggling_repeat_context_reasons
 *    The reasons why toggling repeat context should be / is disallowed.
 * @property {Array.<String>} disallow_toggling_repeat_track_reasons
 *    The reasons why toggling repeat track should be / is disallowed.
 * @property {Array.<String>} disallow_toggling_shuffle_reasons
 *    The reasons why toggling shuffle should be / is disallowed.
 * @property {Array.<String>} disallow_seeking_reasons
 *    The reasons why seeking within a track should be / is disallowed.
 * @property {Array.<String>} disallow_muting_reasons
 *    The reasons why muting audio should be / is disallowed.
 */
exports.Restrictions;

/**
 * PlayerSuppressions are used to disable certain player rules while playing a
 * context. The caller can specify that suppressions should apply when playing a
 * context (see PlayerOptions.suppressions), and a player can notify those
 * suppressions (see PlayState.suppressions).
 *
 * @typedef {Object}
 * @property {Array.<String>} providers
 *    The provider identifiers of the rules that should be disabled.
 */
exports.Suppressions;

/**
 * An object representing the index of the track to play within a context.
 * In the simplest case there is only one page thus its index should be 0.
 *
 * @typedef {Object}
 * @property {Number} page The index of the page to find the track in.
 * @property {Number} track The index of the track in the page.
 */
exports.IndexPath;

/**
 * This structure holds options that should be applied to the player: they are
 * either specified at a global or per-context level. When they are specified
 * globally, finishing the current context or starting to play a new context
 * does not change the player options: specifying them at a context-level means
 * that the previous global setting will be restored when the player is asked to
 * play another context.
 *
 * @typedef {Object}
 * @property {Boolean} shuffling_context
 *    Specifies if the player should shuffle the context or not.
 * @property {Boolean} repeating_context
 *    Specifies if the player should repeat the context or not.
 * @property {Boolean} repeating_track
 *    Specifies if the player should repeat the current track or not.
 */
exports.PlayerOptions;

/**
 * Options for a specific playback request. This object can specify for instance
 * which track to play within the given context, where to seek within the track
 * etc.
 *
 * @typedef {Object}
 * @property {module:spotify-player/types.IndexPath} skip_to_index
 *    The index in the context to start playing from. It is possible to specify
 *    a page that is not yet loaded, in which case the page will be downloaded
 *    before playback starts. The context player state will indicate that the
 *    playback is delayed because of loading the page.
 * @property {Number} seek_to
 *    The number of milliseconds to seek into the track when starting to
 *    play it.
 * @property {Boolean} initially_paused
 *    When this property is set, the context player will load the context but
 *    will not start playing audio for the first track. The is_paused property
 *    is set in the context player state to indicate that playback is paused. To
 *    start playing the track, call the `resume` method on the context player.
 * @property {module:spotify-player/types.PlayerOptions} player_options_override
 *    Use this to temporarily override the player options for this play request
 *    only. This can for instance be used to implement shuffle play buttons that
 *    enable shuffling but only for this particular context.
 */
exports.PlayOptions;

/**
 * Allows the list of tracks that will be played to be split up into chunks.
 * Pages may loaded or unloaded: an unloaded page will be loaded by the player
 * when it needs more tracks to play.
 *
 * @typedef {Object}
 * @property {String} page_url
 *     The URL of this page. If this property is set to a valid URL, it will be
 *     used to fetch the tracks of the page. The URL must be something that is
 *     supported by the context page loader in use, e.g., Hermes endpoints or
 *     Spotify playlist URIs. In the latter case, the context page loader will
 *     trigger the loaded signal each time the underlying playlist changes. If
 *     the tracks for the (static) context page are already provided in the
 *     tracks property, the page is considered loaded and the URL can be left
 *     empty.
 * @property {String} next_page_url
 *     The URL of the next context page. When the context page is stored in a
 *     context, the next page URL will be used to automatically append new pages
 *     at the end of the pages (or the fallback page) array. The new page
 *     will have its page URL set according to the next page URL of the last
 *     page in the context. The context page loaded will be used at some point
 *     to fetch the tracks for the new page. When the new page is fetched from
 *     the backend, it can also have the next page URL set, and yet another page
 *     is added to the context.
 * @property {Array<module:spotify-player/types.Track>} tracks
 *     An optional array with the tracks of this context page. When the context
 *     page is not loaded, the property is not initialized, and a context page
 *     loader will be used to fetch a loaded version of the page. In a loaded
 *     page this property will be set to an array of tracks. Note that the array
 *     can be empty, which means that the page does not have any tracks. This is
 *     not the same as a page that is not loaded, which may or may not have
 *     tracks.
 */
exports.ContextPage;

/**
 * Describes a set of tracks to be played.
 *
 * @typedef {Object}
 * @property {String} entity_uri
 *    An optional Spotify URI that represents what this entire context contains.
 *    For established entities like playlist, album, artist, this should be their
 *    respective URIs. This can be used for inter-feature playback status
 *    indication.
 *
 *    For instance, when the search page starts to play an artist, it should
 *    provide the artist URI in this field. The playback status indication for
 *    that artist in the search result list should be set if the current context
 *    entity URI matches the artist URI. On the artist page, the artist play
 *    button should also look at the entity URI for playback indication.
 * @property {Object} metadata
 *    A map with custom metadata for the track. This map can hold anything that
 *    the feature decides to put in it. Features should be prepared that the
 *    metadata can disappear and be able to work around that situation.
 *    The metadata is passed around and persisted, so it will usually stick
 *    around, but there are certain situations where the data is lost because of
 *    transferring the track over legacy protocols, to Connect enabled speakers
 *    and back.
 * @property {Array<module:spotify-player/types.ContextPage>} pages
 *    An array of context pages that contain the tracks that should be played
 *    for this context. The context pages may or may not be loaded when passing
 *    the context to the player for playback. Note that if the last context page
 *    has a next page URL, at some point a new context page will be added to the
 *    end of the array, for that page URL. This will happen when playback is
 *    nearing the end of the available context pages.
 * @property {module:spotify-player/types.Restricitions} restrictions
 *    The restrictons that should be applied to the player when playing tracks
 *    from the context, e.g., whether the user is allowed to skip backward and
 *    forward in the context or enable shuffling and repeating. Note that the
 *    actual restrictions of the player at any given moment is decided not only
 *    by the context restrictions but also by the rules that are applied, e.g.,
 *    the MFT rules will always disable skipping backward, and will disable
 *    skipping forward as well when the user has reached the maximum number of
 *    skips allowed per time period.
 */
exports.Context;

},{}],735:[function(require,module,exports){
module.exports = require('./lib/index');

},{"./lib/index":736}],736:[function(require,module,exports){
(function (global){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _ponyfill = require('./ponyfill');

var _ponyfill2 = _interopRequireDefault(_ponyfill);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var root; /* global window */


if (typeof self !== 'undefined') {
  root = self;
} else if (typeof window !== 'undefined') {
  root = window;
} else if (typeof global !== 'undefined') {
  root = global;
} else if (typeof module !== 'undefined') {
  root = module;
} else {
  root = Function('return this')();
}

var result = (0, _ponyfill2['default'])(root);
exports['default'] = result;
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./ponyfill":737}],737:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});
exports['default'] = symbolObservablePonyfill;
function symbolObservablePonyfill(root) {
	var result;
	var _Symbol = root.Symbol;

	if (typeof _Symbol === 'function') {
		if (_Symbol.observable) {
			result = _Symbol.observable;
		} else {
			result = _Symbol('observable');
			_Symbol.observable = result;
		}
	} else {
		result = '@@observable';
	}

	return result;
};
},{}],738:[function(require,module,exports){
/*
 * UUID-js: A js library to generate and parse UUIDs, TimeUUIDs and generate
 * TimeUUID based on dates for range selections.
 * @see http://www.ietf.org/rfc/rfc4122.txt
 **/

function UUIDjs() {
};

UUIDjs.maxFromBits = function(bits) {
  return Math.pow(2, bits);
};

UUIDjs.limitUI04 = UUIDjs.maxFromBits(4);
UUIDjs.limitUI06 = UUIDjs.maxFromBits(6);
UUIDjs.limitUI08 = UUIDjs.maxFromBits(8);
UUIDjs.limitUI12 = UUIDjs.maxFromBits(12);
UUIDjs.limitUI14 = UUIDjs.maxFromBits(14);
UUIDjs.limitUI16 = UUIDjs.maxFromBits(16);
UUIDjs.limitUI32 = UUIDjs.maxFromBits(32);
UUIDjs.limitUI40 = UUIDjs.maxFromBits(40);
UUIDjs.limitUI48 = UUIDjs.maxFromBits(48);

// Returns a random integer between min and max
// Using Math.round() will give you a non-uniform distribution!
// @see https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Math/random
function getRandomInt(min, max) {
  return Math.floor(Math.random() * (max - min + 1)) + min;
}

UUIDjs.randomUI04 = function() {
  return getRandomInt(0, UUIDjs.limitUI04-1);
};
UUIDjs.randomUI06 = function() {
  return getRandomInt(0, UUIDjs.limitUI06-1);
};
UUIDjs.randomUI08 = function() {
  return getRandomInt(0, UUIDjs.limitUI08-1);
};
UUIDjs.randomUI12 = function() {
  return getRandomInt(0, UUIDjs.limitUI12-1);
};
UUIDjs.randomUI14 = function() {
  return getRandomInt(0, UUIDjs.limitUI14-1);
};
UUIDjs.randomUI16 = function() {
  return getRandomInt(0, UUIDjs.limitUI16-1);
};
UUIDjs.randomUI32 = function() {
  return getRandomInt(0, UUIDjs.limitUI32-1);
};
UUIDjs.randomUI40 = function() {
  return (0 | Math.random() * (1 << 30)) + (0 | Math.random() * (1 << 40 - 30)) * (1 << 30);
};
UUIDjs.randomUI48 = function() {
  return (0 | Math.random() * (1 << 30)) + (0 | Math.random() * (1 << 48 - 30)) * (1 << 30);
};

UUIDjs.paddedString = function(string, length, z) {
  string = String(string);
  z = (!z) ? '0' : z;
  var i = length - string.length;
  for (; i > 0; i >>>= 1, z += z) {
    if (i & 1) {
      string = z + string;
    }
  }
  return string;
};

UUIDjs.prototype.fromParts = function(timeLow, timeMid, timeHiAndVersion, clockSeqHiAndReserved, clockSeqLow, node) {
  this.version = (timeHiAndVersion >> 12) & 0xF;
  this.hex = UUIDjs.paddedString(timeLow.toString(16), 8)
             + '-'
             + UUIDjs.paddedString(timeMid.toString(16), 4)
             + '-'
             + UUIDjs.paddedString(timeHiAndVersion.toString(16), 4)
             + '-'
             + UUIDjs.paddedString(clockSeqHiAndReserved.toString(16), 2)
             + UUIDjs.paddedString(clockSeqLow.toString(16), 2)
             + '-'
             + UUIDjs.paddedString(node.toString(16), 12);
  return this;
};

UUIDjs.prototype.toString = function() {
  return this.hex;
};
UUIDjs.prototype.toURN = function() {
  return 'urn:uuid:' + this.hex;
};

UUIDjs.prototype.toBytes = function() {
  var parts = this.hex.split('-');
  var ints = [];
  var intPos = 0;
  for (var i = 0; i < parts.length; i++) {
    for (var j = 0; j < parts[i].length; j+=2) {
      ints[intPos++] = parseInt(parts[i].substr(j, 2), 16);
    }
  }
  return ints;
};

UUIDjs.prototype.equals = function(uuid) {
  if (!(uuid instanceof UUID)) {
    return false;
  }
  if (this.hex !== uuid.hex) {
    return false;
  }
  return true;
};

UUIDjs.getTimeFieldValues = function(time) {
  var ts = time - Date.UTC(1582, 9, 15);
  var hm = ((ts / 0x100000000) * 10000) & 0xFFFFFFF;
  return { low: ((ts & 0xFFFFFFF) * 10000) % 0x100000000,
            mid: hm & 0xFFFF, hi: hm >>> 16, timestamp: ts };
};

UUIDjs._create4 = function() {
  return new UUIDjs().fromParts(
    UUIDjs.randomUI32(),
    UUIDjs.randomUI16(),
    0x4000 | UUIDjs.randomUI12(),
    0x80   | UUIDjs.randomUI06(),
    UUIDjs.randomUI08(),
    UUIDjs.randomUI48()
  );
};

UUIDjs._create1 = function() {
  var now = new Date().getTime();
  var sequence = UUIDjs.randomUI14();
  var node = (UUIDjs.randomUI08() | 1) * 0x10000000000 + UUIDjs.randomUI40();
  var tick = UUIDjs.randomUI04();
  var timestamp = 0;
  var timestampRatio = 1/4;

  if (now != timestamp) {
    if (now < timestamp) {
      sequence++;
    }
    timestamp = now;
    tick = UUIDjs.randomUI04();
  } else if (Math.random() < timestampRatio && tick < 9984) {
    tick += 1 + UUIDjs.randomUI04();
  } else {
    sequence++;
  }

  var tf = UUIDjs.getTimeFieldValues(timestamp);
  var tl = tf.low + tick;
  var thav = (tf.hi & 0xFFF) | 0x1000;

  sequence &= 0x3FFF;
  var cshar = (sequence >>> 8) | 0x80;
  var csl = sequence & 0xFF;

  return new UUIDjs().fromParts(tl, tf.mid, thav, cshar, csl, node);
};

UUIDjs.create = function(version) {
  version = version || 4;
  return this['_create' + version]();
};

UUIDjs.fromTime = function(time, last) {
  last = (!last) ? false : last;
  var tf = UUIDjs.getTimeFieldValues(time);
  var tl = tf.low;
  var thav = (tf.hi & 0xFFF) | 0x1000;  // set version '0001'
  if (last === false) {
    return new UUIDjs().fromParts(tl, tf.mid, thav, 0, 0, 0);
  } else {
    return new UUIDjs().fromParts(tl, tf.mid, thav, 0x80 | UUIDjs.limitUI06, UUIDjs.limitUI08 - 1, UUIDjs.limitUI48 - 1);
  }
};

UUIDjs.firstFromTime = function(time) {
  return UUIDjs.fromTime(time, false);
};
UUIDjs.lastFromTime = function(time) {
  return UUIDjs.fromTime(time, true);
};

UUIDjs.fromURN = function(strId) {
  var r, p = /^(?:urn:uuid:|\{)?([0-9a-f]{8})-([0-9a-f]{4})-([0-9a-f]{4})-([0-9a-f]{2})([0-9a-f]{2})-([0-9a-f]{12})(?:\})?$/i;
  if ((r = p.exec(strId))) {
    return new UUIDjs().fromParts(parseInt(r[1], 16), parseInt(r[2], 16),
                            parseInt(r[3], 16), parseInt(r[4], 16),
                            parseInt(r[5], 16), parseInt(r[6], 16));
  }
  return null;
};

UUIDjs.fromBytes = function(ints) {
  if (ints.length < 5) {
    return null;
  }
  var str = '';
  var pos = 0;
  var parts = [4, 2, 2, 2, 6];
  for (var i = 0; i < parts.length; i++) {
    for (var j = 0; j < parts[i]; j++) {
      var octet = ints[pos++].toString(16);
      if (octet.length == 1) {
        octet = '0' + octet;
      }
      str += octet;
    }
    if (parts[i] !== 6) {
      str += '-';
    }
  }
  return UUIDjs.fromURN(str);
};

UUIDjs.fromBinary = function(binary) {
  var ints = [];
  for (var i = 0; i < binary.length; i++) {
    ints[i] = binary.charCodeAt(i);
    if (ints[i] > 255 || ints[i] < 0) {
      throw new Error('Unexpected byte in binary data.');
    }
  }
  return UUIDjs.fromBytes(ints);
};

// Aliases to support legacy code. Do not use these when writing new code as
// they may be removed in future versions!
UUIDjs.new = function() {
  return this.create(4);
};
UUIDjs.newTS = function() {
  return this.create(1);
};

module.exports = UUIDjs;

},{}],739:[function(require,module,exports){
/** @license MIT License (c) copyright 2010-2014 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

(function(define) { 'use strict';
define(function (require) {

	var makePromise = require('./makePromise');
	var Scheduler = require('./Scheduler');
	var async = require('./env').asap;

	return makePromise({
		scheduler: new Scheduler(async)
	});

});
})(typeof define === 'function' && define.amd ? define : function (factory) { module.exports = factory(require); });

},{"./Scheduler":740,"./env":752,"./makePromise":755}],740:[function(require,module,exports){
/** @license MIT License (c) copyright 2010-2014 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

(function(define) { 'use strict';
define(function() {

	// Credit to Twisol (https://github.com/Twisol) for suggesting
	// this type of extensible queue + trampoline approach for next-tick conflation.

	/**
	 * Async task scheduler
	 * @param {function} async function to schedule a single async function
	 * @constructor
	 */
	function Scheduler(async) {
		this._async = async;
		this._running = false;

		this._queue = this;
		this._queueLen = 0;
		this._afterQueue = {};
		this._afterQueueLen = 0;

		var self = this;
		this.drain = function() {
			self._drain();
		};
	}

	/**
	 * Enqueue a task
	 * @param {{ run:function }} task
	 */
	Scheduler.prototype.enqueue = function(task) {
		this._queue[this._queueLen++] = task;
		this.run();
	};

	/**
	 * Enqueue a task to run after the main task queue
	 * @param {{ run:function }} task
	 */
	Scheduler.prototype.afterQueue = function(task) {
		this._afterQueue[this._afterQueueLen++] = task;
		this.run();
	};

	Scheduler.prototype.run = function() {
		if (!this._running) {
			this._running = true;
			this._async(this.drain);
		}
	};

	/**
	 * Drain the handler queue entirely, and then the after queue
	 */
	Scheduler.prototype._drain = function() {
		var i = 0;
		for (; i < this._queueLen; ++i) {
			this._queue[i].run();
			this._queue[i] = void 0;
		}

		this._queueLen = 0;
		this._running = false;

		for (i = 0; i < this._afterQueueLen; ++i) {
			this._afterQueue[i].run();
			this._afterQueue[i] = void 0;
		}

		this._afterQueueLen = 0;
	};

	return Scheduler;

});
}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(); }));

},{}],741:[function(require,module,exports){
/** @license MIT License (c) copyright 2010-2014 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

(function(define) { 'use strict';
define(function() {

	/**
	 * Custom error type for promises rejected by promise.timeout
	 * @param {string} message
	 * @constructor
	 */
	function TimeoutError (message) {
		Error.call(this);
		this.message = message;
		this.name = TimeoutError.name;
		if (typeof Error.captureStackTrace === 'function') {
			Error.captureStackTrace(this, TimeoutError);
		}
	}

	TimeoutError.prototype = Object.create(Error.prototype);
	TimeoutError.prototype.constructor = TimeoutError;

	return TimeoutError;
});
}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(); }));
},{}],742:[function(require,module,exports){
/** @license MIT License (c) copyright 2010-2014 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

(function(define) { 'use strict';
define(function() {

	makeApply.tryCatchResolve = tryCatchResolve;

	return makeApply;

	function makeApply(Promise, call) {
		if(arguments.length < 2) {
			call = tryCatchResolve;
		}

		return apply;

		function apply(f, thisArg, args) {
			var p = Promise._defer();
			var l = args.length;
			var params = new Array(l);
			callAndResolve({ f:f, thisArg:thisArg, args:args, params:params, i:l-1, call:call }, p._handler);

			return p;
		}

		function callAndResolve(c, h) {
			if(c.i < 0) {
				return call(c.f, c.thisArg, c.params, h);
			}

			var handler = Promise._handler(c.args[c.i]);
			handler.fold(callAndResolveNext, c, void 0, h);
		}

		function callAndResolveNext(c, x, h) {
			c.params[c.i] = x;
			c.i -= 1;
			callAndResolve(c, h);
		}
	}

	function tryCatchResolve(f, thisArg, args, resolver) {
		try {
			resolver.resolve(f.apply(thisArg, args));
		} catch(e) {
			resolver.reject(e);
		}
	}

});
}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(); }));



},{}],743:[function(require,module,exports){
/** @license MIT License (c) copyright 2010-2014 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

(function(define) { 'use strict';
define(function(require) {

	var state = require('../state');
	var applier = require('../apply');

	return function array(Promise) {

		var applyFold = applier(Promise);
		var toPromise = Promise.resolve;
		var all = Promise.all;

		var ar = Array.prototype.reduce;
		var arr = Array.prototype.reduceRight;
		var slice = Array.prototype.slice;

		// Additional array combinators

		Promise.any = any;
		Promise.some = some;
		Promise.settle = settle;

		Promise.map = map;
		Promise.filter = filter;
		Promise.reduce = reduce;
		Promise.reduceRight = reduceRight;

		/**
		 * When this promise fulfills with an array, do
		 * onFulfilled.apply(void 0, array)
		 * @param {function} onFulfilled function to apply
		 * @returns {Promise} promise for the result of applying onFulfilled
		 */
		Promise.prototype.spread = function(onFulfilled) {
			return this.then(all).then(function(array) {
				return onFulfilled.apply(this, array);
			});
		};

		return Promise;

		/**
		 * One-winner competitive race.
		 * Return a promise that will fulfill when one of the promises
		 * in the input array fulfills, or will reject when all promises
		 * have rejected.
		 * @param {array} promises
		 * @returns {Promise} promise for the first fulfilled value
		 */
		function any(promises) {
			var p = Promise._defer();
			var resolver = p._handler;
			var l = promises.length>>>0;

			var pending = l;
			var errors = [];

			for (var h, x, i = 0; i < l; ++i) {
				x = promises[i];
				if(x === void 0 && !(i in promises)) {
					--pending;
					continue;
				}

				h = Promise._handler(x);
				if(h.state() > 0) {
					resolver.become(h);
					Promise._visitRemaining(promises, i, h);
					break;
				} else {
					h.visit(resolver, handleFulfill, handleReject);
				}
			}

			if(pending === 0) {
				resolver.reject(new RangeError('any(): array must not be empty'));
			}

			return p;

			function handleFulfill(x) {
				/*jshint validthis:true*/
				errors = null;
				this.resolve(x); // this === resolver
			}

			function handleReject(e) {
				/*jshint validthis:true*/
				if(this.resolved) { // this === resolver
					return;
				}

				errors.push(e);
				if(--pending === 0) {
					this.reject(errors);
				}
			}
		}

		/**
		 * N-winner competitive race
		 * Return a promise that will fulfill when n input promises have
		 * fulfilled, or will reject when it becomes impossible for n
		 * input promises to fulfill (ie when promises.length - n + 1
		 * have rejected)
		 * @param {array} promises
		 * @param {number} n
		 * @returns {Promise} promise for the earliest n fulfillment values
		 *
		 * @deprecated
		 */
		function some(promises, n) {
			/*jshint maxcomplexity:7*/
			var p = Promise._defer();
			var resolver = p._handler;

			var results = [];
			var errors = [];

			var l = promises.length>>>0;
			var nFulfill = 0;
			var nReject;
			var x, i; // reused in both for() loops

			// First pass: count actual array items
			for(i=0; i<l; ++i) {
				x = promises[i];
				if(x === void 0 && !(i in promises)) {
					continue;
				}
				++nFulfill;
			}

			// Compute actual goals
			n = Math.max(n, 0);
			nReject = (nFulfill - n + 1);
			nFulfill = Math.min(n, nFulfill);

			if(n > nFulfill) {
				resolver.reject(new RangeError('some(): array must contain at least '
				+ n + ' item(s), but had ' + nFulfill));
			} else if(nFulfill === 0) {
				resolver.resolve(results);
			}

			// Second pass: observe each array item, make progress toward goals
			for(i=0; i<l; ++i) {
				x = promises[i];
				if(x === void 0 && !(i in promises)) {
					continue;
				}

				Promise._handler(x).visit(resolver, fulfill, reject, resolver.notify);
			}

			return p;

			function fulfill(x) {
				/*jshint validthis:true*/
				if(this.resolved) { // this === resolver
					return;
				}

				results.push(x);
				if(--nFulfill === 0) {
					errors = null;
					this.resolve(results);
				}
			}

			function reject(e) {
				/*jshint validthis:true*/
				if(this.resolved) { // this === resolver
					return;
				}

				errors.push(e);
				if(--nReject === 0) {
					results = null;
					this.reject(errors);
				}
			}
		}

		/**
		 * Apply f to the value of each promise in a list of promises
		 * and return a new list containing the results.
		 * @param {array} promises
		 * @param {function(x:*, index:Number):*} f mapping function
		 * @returns {Promise}
		 */
		function map(promises, f) {
			return Promise._traverse(f, promises);
		}

		/**
		 * Filter the provided array of promises using the provided predicate.  Input may
		 * contain promises and values
		 * @param {Array} promises array of promises and values
		 * @param {function(x:*, index:Number):boolean} predicate filtering predicate.
		 *  Must return truthy (or promise for truthy) for items to retain.
		 * @returns {Promise} promise that will fulfill with an array containing all items
		 *  for which predicate returned truthy.
		 */
		function filter(promises, predicate) {
			var a = slice.call(promises);
			return Promise._traverse(predicate, a).then(function(keep) {
				return filterSync(a, keep);
			});
		}

		function filterSync(promises, keep) {
			// Safe because we know all promises have fulfilled if we've made it this far
			var l = keep.length;
			var filtered = new Array(l);
			for(var i=0, j=0; i<l; ++i) {
				if(keep[i]) {
					filtered[j++] = Promise._handler(promises[i]).value;
				}
			}
			filtered.length = j;
			return filtered;

		}

		/**
		 * Return a promise that will always fulfill with an array containing
		 * the outcome states of all input promises.  The returned promise
		 * will never reject.
		 * @param {Array} promises
		 * @returns {Promise} promise for array of settled state descriptors
		 */
		function settle(promises) {
			return all(promises.map(settleOne));
		}

		function settleOne(p) {
			var h = Promise._handler(p);
			if(h.state() === 0) {
				return toPromise(p).then(state.fulfilled, state.rejected);
			}

			h._unreport();
			return state.inspect(h);
		}

		/**
		 * Traditional reduce function, similar to `Array.prototype.reduce()`, but
		 * input may contain promises and/or values, and reduceFunc
		 * may return either a value or a promise, *and* initialValue may
		 * be a promise for the starting value.
		 * @param {Array|Promise} promises array or promise for an array of anything,
		 *      may contain a mix of promises and values.
		 * @param {function(accumulated:*, x:*, index:Number):*} f reduce function
		 * @returns {Promise} that will resolve to the final reduced value
		 */
		function reduce(promises, f /*, initialValue */) {
			return arguments.length > 2 ? ar.call(promises, liftCombine(f), arguments[2])
					: ar.call(promises, liftCombine(f));
		}

		/**
		 * Traditional reduce function, similar to `Array.prototype.reduceRight()`, but
		 * input may contain promises and/or values, and reduceFunc
		 * may return either a value or a promise, *and* initialValue may
		 * be a promise for the starting value.
		 * @param {Array|Promise} promises array or promise for an array of anything,
		 *      may contain a mix of promises and values.
		 * @param {function(accumulated:*, x:*, index:Number):*} f reduce function
		 * @returns {Promise} that will resolve to the final reduced value
		 */
		function reduceRight(promises, f /*, initialValue */) {
			return arguments.length > 2 ? arr.call(promises, liftCombine(f), arguments[2])
					: arr.call(promises, liftCombine(f));
		}

		function liftCombine(f) {
			return function(z, x, i) {
				return applyFold(f, void 0, [z,x,i]);
			};
		}
	};

});
}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(require); }));

},{"../apply":742,"../state":756}],744:[function(require,module,exports){
/** @license MIT License (c) copyright 2010-2014 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

(function(define) { 'use strict';
define(function() {

	return function flow(Promise) {

		var resolve = Promise.resolve;
		var reject = Promise.reject;
		var origCatch = Promise.prototype['catch'];

		/**
		 * Handle the ultimate fulfillment value or rejection reason, and assume
		 * responsibility for all errors.  If an error propagates out of result
		 * or handleFatalError, it will be rethrown to the host, resulting in a
		 * loud stack track on most platforms and a crash on some.
		 * @param {function?} onResult
		 * @param {function?} onError
		 * @returns {undefined}
		 */
		Promise.prototype.done = function(onResult, onError) {
			this._handler.visit(this._handler.receiver, onResult, onError);
		};

		/**
		 * Add Error-type and predicate matching to catch.  Examples:
		 * promise.catch(TypeError, handleTypeError)
		 *   .catch(predicate, handleMatchedErrors)
		 *   .catch(handleRemainingErrors)
		 * @param onRejected
		 * @returns {*}
		 */
		Promise.prototype['catch'] = Promise.prototype.otherwise = function(onRejected) {
			if (arguments.length < 2) {
				return origCatch.call(this, onRejected);
			}

			if(typeof onRejected !== 'function') {
				return this.ensure(rejectInvalidPredicate);
			}

			return origCatch.call(this, createCatchFilter(arguments[1], onRejected));
		};

		/**
		 * Wraps the provided catch handler, so that it will only be called
		 * if the predicate evaluates truthy
		 * @param {?function} handler
		 * @param {function} predicate
		 * @returns {function} conditional catch handler
		 */
		function createCatchFilter(handler, predicate) {
			return function(e) {
				return evaluatePredicate(e, predicate)
					? handler.call(this, e)
					: reject(e);
			};
		}

		/**
		 * Ensures that onFulfilledOrRejected will be called regardless of whether
		 * this promise is fulfilled or rejected.  onFulfilledOrRejected WILL NOT
		 * receive the promises' value or reason.  Any returned value will be disregarded.
		 * onFulfilledOrRejected may throw or return a rejected promise to signal
		 * an additional error.
		 * @param {function} handler handler to be called regardless of
		 *  fulfillment or rejection
		 * @returns {Promise}
		 */
		Promise.prototype['finally'] = Promise.prototype.ensure = function(handler) {
			if(typeof handler !== 'function') {
				return this;
			}

			return this.then(function(x) {
				return runSideEffect(handler, this, identity, x);
			}, function(e) {
				return runSideEffect(handler, this, reject, e);
			});
		};

		function runSideEffect (handler, thisArg, propagate, value) {
			var result = handler.call(thisArg);
			return maybeThenable(result)
				? propagateValue(result, propagate, value)
				: propagate(value);
		}

		function propagateValue (result, propagate, x) {
			return resolve(result).then(function () {
				return propagate(x);
			});
		}

		/**
		 * Recover from a failure by returning a defaultValue.  If defaultValue
		 * is a promise, it's fulfillment value will be used.  If defaultValue is
		 * a promise that rejects, the returned promise will reject with the
		 * same reason.
		 * @param {*} defaultValue
		 * @returns {Promise} new promise
		 */
		Promise.prototype['else'] = Promise.prototype.orElse = function(defaultValue) {
			return this.then(void 0, function() {
				return defaultValue;
			});
		};

		/**
		 * Shortcut for .then(function() { return value; })
		 * @param  {*} value
		 * @return {Promise} a promise that:
		 *  - is fulfilled if value is not a promise, or
		 *  - if value is a promise, will fulfill with its value, or reject
		 *    with its reason.
		 */
		Promise.prototype['yield'] = function(value) {
			return this.then(function() {
				return value;
			});
		};

		/**
		 * Runs a side effect when this promise fulfills, without changing the
		 * fulfillment value.
		 * @param {function} onFulfilledSideEffect
		 * @returns {Promise}
		 */
		Promise.prototype.tap = function(onFulfilledSideEffect) {
			return this.then(onFulfilledSideEffect)['yield'](this);
		};

		return Promise;
	};

	function rejectInvalidPredicate() {
		throw new TypeError('catch predicate must be a function');
	}

	function evaluatePredicate(e, predicate) {
		return isError(predicate) ? e instanceof predicate : predicate(e);
	}

	function isError(predicate) {
		return predicate === Error
			|| (predicate != null && predicate.prototype instanceof Error);
	}

	function maybeThenable(x) {
		return (typeof x === 'object' || typeof x === 'function') && x !== null;
	}

	function identity(x) {
		return x;
	}

});
}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(); }));

},{}],745:[function(require,module,exports){
/** @license MIT License (c) copyright 2010-2014 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */
/** @author Jeff Escalante */

(function(define) { 'use strict';
define(function() {

	return function fold(Promise) {

		Promise.prototype.fold = function(f, z) {
			var promise = this._beget();

			this._handler.fold(function(z, x, to) {
				Promise._handler(z).fold(function(x, z, to) {
					to.resolve(f.call(this, z, x));
				}, x, this, to);
			}, z, promise._handler.receiver, promise._handler);

			return promise;
		};

		return Promise;
	};

});
}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(); }));

},{}],746:[function(require,module,exports){
/** @license MIT License (c) copyright 2010-2014 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

(function(define) { 'use strict';
define(function(require) {

	var inspect = require('../state').inspect;

	return function inspection(Promise) {

		Promise.prototype.inspect = function() {
			return inspect(Promise._handler(this));
		};

		return Promise;
	};

});
}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(require); }));

},{"../state":756}],747:[function(require,module,exports){
/** @license MIT License (c) copyright 2010-2014 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

(function(define) { 'use strict';
define(function() {

	return function generate(Promise) {

		var resolve = Promise.resolve;

		Promise.iterate = iterate;
		Promise.unfold = unfold;

		return Promise;

		/**
		 * @deprecated Use github.com/cujojs/most streams and most.iterate
		 * Generate a (potentially infinite) stream of promised values:
		 * x, f(x), f(f(x)), etc. until condition(x) returns true
		 * @param {function} f function to generate a new x from the previous x
		 * @param {function} condition function that, given the current x, returns
		 *  truthy when the iterate should stop
		 * @param {function} handler function to handle the value produced by f
		 * @param {*|Promise} x starting value, may be a promise
		 * @return {Promise} the result of the last call to f before
		 *  condition returns true
		 */
		function iterate(f, condition, handler, x) {
			return unfold(function(x) {
				return [x, f(x)];
			}, condition, handler, x);
		}

		/**
		 * @deprecated Use github.com/cujojs/most streams and most.unfold
		 * Generate a (potentially infinite) stream of promised values
		 * by applying handler(generator(seed)) iteratively until
		 * condition(seed) returns true.
		 * @param {function} unspool function that generates a [value, newSeed]
		 *  given a seed.
		 * @param {function} condition function that, given the current seed, returns
		 *  truthy when the unfold should stop
		 * @param {function} handler function to handle the value produced by unspool
		 * @param x {*|Promise} starting value, may be a promise
		 * @return {Promise} the result of the last value produced by unspool before
		 *  condition returns true
		 */
		function unfold(unspool, condition, handler, x) {
			return resolve(x).then(function(seed) {
				return resolve(condition(seed)).then(function(done) {
					return done ? seed : resolve(unspool(seed)).spread(next);
				});
			});

			function next(item, newSeed) {
				return resolve(handler(item)).then(function() {
					return unfold(unspool, condition, handler, newSeed);
				});
			}
		}
	};

});
}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(); }));

},{}],748:[function(require,module,exports){
/** @license MIT License (c) copyright 2010-2014 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

(function(define) { 'use strict';
define(function() {

	return function progress(Promise) {

		/**
		 * @deprecated
		 * Register a progress handler for this promise
		 * @param {function} onProgress
		 * @returns {Promise}
		 */
		Promise.prototype.progress = function(onProgress) {
			return this.then(void 0, void 0, onProgress);
		};

		return Promise;
	};

});
}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(); }));

},{}],749:[function(require,module,exports){
/** @license MIT License (c) copyright 2010-2014 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

(function(define) { 'use strict';
define(function(require) {

	var env = require('../env');
	var TimeoutError = require('../TimeoutError');

	function setTimeout(f, ms, x, y) {
		return env.setTimer(function() {
			f(x, y, ms);
		}, ms);
	}

	return function timed(Promise) {
		/**
		 * Return a new promise whose fulfillment value is revealed only
		 * after ms milliseconds
		 * @param {number} ms milliseconds
		 * @returns {Promise}
		 */
		Promise.prototype.delay = function(ms) {
			var p = this._beget();
			this._handler.fold(handleDelay, ms, void 0, p._handler);
			return p;
		};

		function handleDelay(ms, x, h) {
			setTimeout(resolveDelay, ms, x, h);
		}

		function resolveDelay(x, h) {
			h.resolve(x);
		}

		/**
		 * Return a new promise that rejects after ms milliseconds unless
		 * this promise fulfills earlier, in which case the returned promise
		 * fulfills with the same value.
		 * @param {number} ms milliseconds
		 * @param {Error|*=} reason optional rejection reason to use, defaults
		 *   to a TimeoutError if not provided
		 * @returns {Promise}
		 */
		Promise.prototype.timeout = function(ms, reason) {
			var p = this._beget();
			var h = p._handler;

			var t = setTimeout(onTimeout, ms, reason, p._handler);

			this._handler.visit(h,
				function onFulfill(x) {
					env.clearTimer(t);
					this.resolve(x); // this = h
				},
				function onReject(x) {
					env.clearTimer(t);
					this.reject(x); // this = h
				},
				h.notify);

			return p;
		};

		function onTimeout(reason, h, ms) {
			var e = typeof reason === 'undefined'
				? new TimeoutError('timed out after ' + ms + 'ms')
				: reason;
			h.reject(e);
		}

		return Promise;
	};

});
}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(require); }));

},{"../TimeoutError":741,"../env":752}],750:[function(require,module,exports){
/** @license MIT License (c) copyright 2010-2014 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

(function(define) { 'use strict';
define(function(require) {

	var setTimer = require('../env').setTimer;
	var format = require('../format');

	return function unhandledRejection(Promise) {

		var logError = noop;
		var logInfo = noop;
		var localConsole;

		if(typeof console !== 'undefined') {
			// Alias console to prevent things like uglify's drop_console option from
			// removing console.log/error. Unhandled rejections fall into the same
			// category as uncaught exceptions, and build tools shouldn't silence them.
			localConsole = console;
			logError = typeof localConsole.error !== 'undefined'
				? function (e) { localConsole.error(e); }
				: function (e) { localConsole.log(e); };

			logInfo = typeof localConsole.info !== 'undefined'
				? function (e) { localConsole.info(e); }
				: function (e) { localConsole.log(e); };
		}

		Promise.onPotentiallyUnhandledRejection = function(rejection) {
			enqueue(report, rejection);
		};

		Promise.onPotentiallyUnhandledRejectionHandled = function(rejection) {
			enqueue(unreport, rejection);
		};

		Promise.onFatalRejection = function(rejection) {
			enqueue(throwit, rejection.value);
		};

		var tasks = [];
		var reported = [];
		var running = null;

		function report(r) {
			if(!r.handled) {
				reported.push(r);
				logError('Potentially unhandled rejection [' + r.id + '] ' + format.formatError(r.value));
			}
		}

		function unreport(r) {
			var i = reported.indexOf(r);
			if(i >= 0) {
				reported.splice(i, 1);
				logInfo('Handled previous rejection [' + r.id + '] ' + format.formatObject(r.value));
			}
		}

		function enqueue(f, x) {
			tasks.push(f, x);
			if(running === null) {
				running = setTimer(flush, 0);
			}
		}

		function flush() {
			running = null;
			while(tasks.length > 0) {
				tasks.shift()(tasks.shift());
			}
		}

		return Promise;
	};

	function throwit(e) {
		throw e;
	}

	function noop() {}

});
}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(require); }));

},{"../env":752,"../format":753}],751:[function(require,module,exports){
/** @license MIT License (c) copyright 2010-2014 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

(function(define) { 'use strict';
define(function() {

	return function addWith(Promise) {
		/**
		 * Returns a promise whose handlers will be called with `this` set to
		 * the supplied receiver.  Subsequent promises derived from the
		 * returned promise will also have their handlers called with receiver
		 * as `this`. Calling `with` with undefined or no arguments will return
		 * a promise whose handlers will again be called in the usual Promises/A+
		 * way (no `this`) thus safely undoing any previous `with` in the
		 * promise chain.
		 *
		 * WARNING: Promises returned from `with`/`withThis` are NOT Promises/A+
		 * compliant, specifically violating 2.2.5 (http://promisesaplus.com/#point-41)
		 *
		 * @param {object} receiver `this` value for all handlers attached to
		 *  the returned promise.
		 * @returns {Promise}
		 */
		Promise.prototype['with'] = Promise.prototype.withThis = function(receiver) {
			var p = this._beget();
			var child = p._handler;
			child.receiver = receiver;
			this._handler.chain(child, receiver);
			return p;
		};

		return Promise;
	};

});
}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(); }));


},{}],752:[function(require,module,exports){
(function (process){
/** @license MIT License (c) copyright 2010-2014 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

/*global process,document,setTimeout,clearTimeout,MutationObserver,WebKitMutationObserver*/
(function(define) { 'use strict';
define(function(require) {
	/*jshint maxcomplexity:6*/

	// Sniff "best" async scheduling option
	// Prefer process.nextTick or MutationObserver, then check for
	// setTimeout, and finally vertx, since its the only env that doesn't
	// have setTimeout

	var MutationObs;
	var capturedSetTimeout = typeof setTimeout !== 'undefined' && setTimeout;

	// Default env
	var setTimer = function(f, ms) { return setTimeout(f, ms); };
	var clearTimer = function(t) { return clearTimeout(t); };
	var asap = function (f) { return capturedSetTimeout(f, 0); };

	// Detect specific env
	if (isNode()) { // Node
		asap = function (f) { return process.nextTick(f); };

	} else if (MutationObs = hasMutationObserver()) { // Modern browser
		asap = initMutationObserver(MutationObs);

	} else if (!capturedSetTimeout) { // vert.x
		var vertxRequire = require;
		var vertx = vertxRequire('vertx');
		setTimer = function (f, ms) { return vertx.setTimer(ms, f); };
		clearTimer = vertx.cancelTimer;
		asap = vertx.runOnLoop || vertx.runOnContext;
	}

	return {
		setTimer: setTimer,
		clearTimer: clearTimer,
		asap: asap
	};

	function isNode () {
		return typeof process !== 'undefined' &&
			Object.prototype.toString.call(process) === '[object process]';
	}

	function hasMutationObserver () {
		return (typeof MutationObserver === 'function' && MutationObserver) ||
			(typeof WebKitMutationObserver === 'function' && WebKitMutationObserver);
	}

	function initMutationObserver(MutationObserver) {
		var scheduled;
		var node = document.createTextNode('');
		var o = new MutationObserver(run);
		o.observe(node, { characterData: true });

		function run() {
			var f = scheduled;
			scheduled = void 0;
			f();
		}

		var i = 0;
		return function (f) {
			scheduled = f;
			node.data = (i ^= 1);
		};
	}
});
}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(require); }));

}).call(this,require('_process'))
},{"_process":490}],753:[function(require,module,exports){
/** @license MIT License (c) copyright 2010-2014 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

(function(define) { 'use strict';
define(function() {

	return {
		formatError: formatError,
		formatObject: formatObject,
		tryStringify: tryStringify
	};

	/**
	 * Format an error into a string.  If e is an Error and has a stack property,
	 * it's returned.  Otherwise, e is formatted using formatObject, with a
	 * warning added about e not being a proper Error.
	 * @param {*} e
	 * @returns {String} formatted string, suitable for output to developers
	 */
	function formatError(e) {
		var s = typeof e === 'object' && e !== null && (e.stack || e.message) ? e.stack || e.message : formatObject(e);
		return e instanceof Error ? s : s + ' (WARNING: non-Error used)';
	}

	/**
	 * Format an object, detecting "plain" objects and running them through
	 * JSON.stringify if possible.
	 * @param {Object} o
	 * @returns {string}
	 */
	function formatObject(o) {
		var s = String(o);
		if(s === '[object Object]' && typeof JSON !== 'undefined') {
			s = tryStringify(o, s);
		}
		return s;
	}

	/**
	 * Try to return the result of JSON.stringify(x).  If that fails, return
	 * defaultValue
	 * @param {*} x
	 * @param {*} defaultValue
	 * @returns {String|*} JSON.stringify(x) or defaultValue
	 */
	function tryStringify(x, defaultValue) {
		try {
			return JSON.stringify(x);
		} catch(e) {
			return defaultValue;
		}
	}

});
}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(); }));

},{}],754:[function(require,module,exports){
/** @license MIT License (c) copyright 2010-2014 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

(function(define) { 'use strict';
define(function() {

	return function liftAll(liftOne, combine, dst, src) {
		if(typeof combine === 'undefined') {
			combine = defaultCombine;
		}

		return Object.keys(src).reduce(function(dst, key) {
			var f = src[key];
			return typeof f === 'function' ? combine(dst, liftOne(f), key) : dst;
		}, typeof dst === 'undefined' ? defaultDst(src) : dst);
	};

	function defaultCombine(o, f, k) {
		o[k] = f;
		return o;
	}

	function defaultDst(src) {
		return typeof src === 'function' ? src.bind() : Object.create(src);
	}
});
}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(); }));

},{}],755:[function(require,module,exports){
(function (process){
/** @license MIT License (c) copyright 2010-2014 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

(function(define) { 'use strict';
define(function() {

	return function makePromise(environment) {

		var tasks = environment.scheduler;
		var emitRejection = initEmitRejection();

		var objectCreate = Object.create ||
			function(proto) {
				function Child() {}
				Child.prototype = proto;
				return new Child();
			};

		/**
		 * Create a promise whose fate is determined by resolver
		 * @constructor
		 * @returns {Promise} promise
		 * @name Promise
		 */
		function Promise(resolver, handler) {
			this._handler = resolver === Handler ? handler : init(resolver);
		}

		/**
		 * Run the supplied resolver
		 * @param resolver
		 * @returns {Pending}
		 */
		function init(resolver) {
			var handler = new Pending();

			try {
				resolver(promiseResolve, promiseReject, promiseNotify);
			} catch (e) {
				promiseReject(e);
			}

			return handler;

			/**
			 * Transition from pre-resolution state to post-resolution state, notifying
			 * all listeners of the ultimate fulfillment or rejection
			 * @param {*} x resolution value
			 */
			function promiseResolve (x) {
				handler.resolve(x);
			}
			/**
			 * Reject this promise with reason, which will be used verbatim
			 * @param {Error|*} reason rejection reason, strongly suggested
			 *   to be an Error type
			 */
			function promiseReject (reason) {
				handler.reject(reason);
			}

			/**
			 * @deprecated
			 * Issue a progress event, notifying all progress listeners
			 * @param {*} x progress event payload to pass to all listeners
			 */
			function promiseNotify (x) {
				handler.notify(x);
			}
		}

		// Creation

		Promise.resolve = resolve;
		Promise.reject = reject;
		Promise.never = never;

		Promise._defer = defer;
		Promise._handler = getHandler;

		/**
		 * Returns a trusted promise. If x is already a trusted promise, it is
		 * returned, otherwise returns a new trusted Promise which follows x.
		 * @param  {*} x
		 * @return {Promise} promise
		 */
		function resolve(x) {
			return isPromise(x) ? x
				: new Promise(Handler, new Async(getHandler(x)));
		}

		/**
		 * Return a reject promise with x as its reason (x is used verbatim)
		 * @param {*} x
		 * @returns {Promise} rejected promise
		 */
		function reject(x) {
			return new Promise(Handler, new Async(new Rejected(x)));
		}

		/**
		 * Return a promise that remains pending forever
		 * @returns {Promise} forever-pending promise.
		 */
		function never() {
			return foreverPendingPromise; // Should be frozen
		}

		/**
		 * Creates an internal {promise, resolver} pair
		 * @private
		 * @returns {Promise}
		 */
		function defer() {
			return new Promise(Handler, new Pending());
		}

		// Transformation and flow control

		/**
		 * Transform this promise's fulfillment value, returning a new Promise
		 * for the transformed result.  If the promise cannot be fulfilled, onRejected
		 * is called with the reason.  onProgress *may* be called with updates toward
		 * this promise's fulfillment.
		 * @param {function=} onFulfilled fulfillment handler
		 * @param {function=} onRejected rejection handler
		 * @param {function=} onProgress @deprecated progress handler
		 * @return {Promise} new promise
		 */
		Promise.prototype.then = function(onFulfilled, onRejected, onProgress) {
			var parent = this._handler;
			var state = parent.join().state();

			if ((typeof onFulfilled !== 'function' && state > 0) ||
				(typeof onRejected !== 'function' && state < 0)) {
				// Short circuit: value will not change, simply share handler
				return new this.constructor(Handler, parent);
			}

			var p = this._beget();
			var child = p._handler;

			parent.chain(child, parent.receiver, onFulfilled, onRejected, onProgress);

			return p;
		};

		/**
		 * If this promise cannot be fulfilled due to an error, call onRejected to
		 * handle the error. Shortcut for .then(undefined, onRejected)
		 * @param {function?} onRejected
		 * @return {Promise}
		 */
		Promise.prototype['catch'] = function(onRejected) {
			return this.then(void 0, onRejected);
		};

		/**
		 * Creates a new, pending promise of the same type as this promise
		 * @private
		 * @returns {Promise}
		 */
		Promise.prototype._beget = function() {
			return begetFrom(this._handler, this.constructor);
		};

		function begetFrom(parent, Promise) {
			var child = new Pending(parent.receiver, parent.join().context);
			return new Promise(Handler, child);
		}

		// Array combinators

		Promise.all = all;
		Promise.race = race;
		Promise._traverse = traverse;

		/**
		 * Return a promise that will fulfill when all promises in the
		 * input array have fulfilled, or will reject when one of the
		 * promises rejects.
		 * @param {array} promises array of promises
		 * @returns {Promise} promise for array of fulfillment values
		 */
		function all(promises) {
			return traverseWith(snd, null, promises);
		}

		/**
		 * Array<Promise<X>> -> Promise<Array<f(X)>>
		 * @private
		 * @param {function} f function to apply to each promise's value
		 * @param {Array} promises array of promises
		 * @returns {Promise} promise for transformed values
		 */
		function traverse(f, promises) {
			return traverseWith(tryCatch2, f, promises);
		}

		function traverseWith(tryMap, f, promises) {
			var handler = typeof f === 'function' ? mapAt : settleAt;

			var resolver = new Pending();
			var pending = promises.length >>> 0;
			var results = new Array(pending);

			for (var i = 0, x; i < promises.length && !resolver.resolved; ++i) {
				x = promises[i];

				if (x === void 0 && !(i in promises)) {
					--pending;
					continue;
				}

				traverseAt(promises, handler, i, x, resolver);
			}

			if(pending === 0) {
				resolver.become(new Fulfilled(results));
			}

			return new Promise(Handler, resolver);

			function mapAt(i, x, resolver) {
				if(!resolver.resolved) {
					traverseAt(promises, settleAt, i, tryMap(f, x, i), resolver);
				}
			}

			function settleAt(i, x, resolver) {
				results[i] = x;
				if(--pending === 0) {
					resolver.become(new Fulfilled(results));
				}
			}
		}

		function traverseAt(promises, handler, i, x, resolver) {
			if (maybeThenable(x)) {
				var h = getHandlerMaybeThenable(x);
				var s = h.state();

				if (s === 0) {
					h.fold(handler, i, void 0, resolver);
				} else if (s > 0) {
					handler(i, h.value, resolver);
				} else {
					resolver.become(h);
					visitRemaining(promises, i+1, h);
				}
			} else {
				handler(i, x, resolver);
			}
		}

		Promise._visitRemaining = visitRemaining;
		function visitRemaining(promises, start, handler) {
			for(var i=start; i<promises.length; ++i) {
				markAsHandled(getHandler(promises[i]), handler);
			}
		}

		function markAsHandled(h, handler) {
			if(h === handler) {
				return;
			}

			var s = h.state();
			if(s === 0) {
				h.visit(h, void 0, h._unreport);
			} else if(s < 0) {
				h._unreport();
			}
		}

		/**
		 * Fulfill-reject competitive race. Return a promise that will settle
		 * to the same state as the earliest input promise to settle.
		 *
		 * WARNING: The ES6 Promise spec requires that race()ing an empty array
		 * must return a promise that is pending forever.  This implementation
		 * returns a singleton forever-pending promise, the same singleton that is
		 * returned by Promise.never(), thus can be checked with ===
		 *
		 * @param {array} promises array of promises to race
		 * @returns {Promise} if input is non-empty, a promise that will settle
		 * to the same outcome as the earliest input promise to settle. if empty
		 * is empty, returns a promise that will never settle.
		 */
		function race(promises) {
			if(typeof promises !== 'object' || promises === null) {
				return reject(new TypeError('non-iterable passed to race()'));
			}

			// Sigh, race([]) is untestable unless we return *something*
			// that is recognizable without calling .then() on it.
			return promises.length === 0 ? never()
				 : promises.length === 1 ? resolve(promises[0])
				 : runRace(promises);
		}

		function runRace(promises) {
			var resolver = new Pending();
			var i, x, h;
			for(i=0; i<promises.length; ++i) {
				x = promises[i];
				if (x === void 0 && !(i in promises)) {
					continue;
				}

				h = getHandler(x);
				if(h.state() !== 0) {
					resolver.become(h);
					visitRemaining(promises, i+1, h);
					break;
				} else {
					h.visit(resolver, resolver.resolve, resolver.reject);
				}
			}
			return new Promise(Handler, resolver);
		}

		// Promise internals
		// Below this, everything is @private

		/**
		 * Get an appropriate handler for x, without checking for cycles
		 * @param {*} x
		 * @returns {object} handler
		 */
		function getHandler(x) {
			if(isPromise(x)) {
				return x._handler.join();
			}
			return maybeThenable(x) ? getHandlerUntrusted(x) : new Fulfilled(x);
		}

		/**
		 * Get a handler for thenable x.
		 * NOTE: You must only call this if maybeThenable(x) == true
		 * @param {object|function|Promise} x
		 * @returns {object} handler
		 */
		function getHandlerMaybeThenable(x) {
			return isPromise(x) ? x._handler.join() : getHandlerUntrusted(x);
		}

		/**
		 * Get a handler for potentially untrusted thenable x
		 * @param {*} x
		 * @returns {object} handler
		 */
		function getHandlerUntrusted(x) {
			try {
				var untrustedThen = x.then;
				return typeof untrustedThen === 'function'
					? new Thenable(untrustedThen, x)
					: new Fulfilled(x);
			} catch(e) {
				return new Rejected(e);
			}
		}

		/**
		 * Handler for a promise that is pending forever
		 * @constructor
		 */
		function Handler() {}

		Handler.prototype.when
			= Handler.prototype.become
			= Handler.prototype.notify // deprecated
			= Handler.prototype.fail
			= Handler.prototype._unreport
			= Handler.prototype._report
			= noop;

		Handler.prototype._state = 0;

		Handler.prototype.state = function() {
			return this._state;
		};

		/**
		 * Recursively collapse handler chain to find the handler
		 * nearest to the fully resolved value.
		 * @returns {object} handler nearest the fully resolved value
		 */
		Handler.prototype.join = function() {
			var h = this;
			while(h.handler !== void 0) {
				h = h.handler;
			}
			return h;
		};

		Handler.prototype.chain = function(to, receiver, fulfilled, rejected, progress) {
			this.when({
				resolver: to,
				receiver: receiver,
				fulfilled: fulfilled,
				rejected: rejected,
				progress: progress
			});
		};

		Handler.prototype.visit = function(receiver, fulfilled, rejected, progress) {
			this.chain(failIfRejected, receiver, fulfilled, rejected, progress);
		};

		Handler.prototype.fold = function(f, z, c, to) {
			this.when(new Fold(f, z, c, to));
		};

		/**
		 * Handler that invokes fail() on any handler it becomes
		 * @constructor
		 */
		function FailIfRejected() {}

		inherit(Handler, FailIfRejected);

		FailIfRejected.prototype.become = function(h) {
			h.fail();
		};

		var failIfRejected = new FailIfRejected();

		/**
		 * Handler that manages a queue of consumers waiting on a pending promise
		 * @constructor
		 */
		function Pending(receiver, inheritedContext) {
			Promise.createContext(this, inheritedContext);

			this.consumers = void 0;
			this.receiver = receiver;
			this.handler = void 0;
			this.resolved = false;
		}

		inherit(Handler, Pending);

		Pending.prototype._state = 0;

		Pending.prototype.resolve = function(x) {
			this.become(getHandler(x));
		};

		Pending.prototype.reject = function(x) {
			if(this.resolved) {
				return;
			}

			this.become(new Rejected(x));
		};

		Pending.prototype.join = function() {
			if (!this.resolved) {
				return this;
			}

			var h = this;

			while (h.handler !== void 0) {
				h = h.handler;
				if (h === this) {
					return this.handler = cycle();
				}
			}

			return h;
		};

		Pending.prototype.run = function() {
			var q = this.consumers;
			var handler = this.handler;
			this.handler = this.handler.join();
			this.consumers = void 0;

			for (var i = 0; i < q.length; ++i) {
				handler.when(q[i]);
			}
		};

		Pending.prototype.become = function(handler) {
			if(this.resolved) {
				return;
			}

			this.resolved = true;
			this.handler = handler;
			if(this.consumers !== void 0) {
				tasks.enqueue(this);
			}

			if(this.context !== void 0) {
				handler._report(this.context);
			}
		};

		Pending.prototype.when = function(continuation) {
			if(this.resolved) {
				tasks.enqueue(new ContinuationTask(continuation, this.handler));
			} else {
				if(this.consumers === void 0) {
					this.consumers = [continuation];
				} else {
					this.consumers.push(continuation);
				}
			}
		};

		/**
		 * @deprecated
		 */
		Pending.prototype.notify = function(x) {
			if(!this.resolved) {
				tasks.enqueue(new ProgressTask(x, this));
			}
		};

		Pending.prototype.fail = function(context) {
			var c = typeof context === 'undefined' ? this.context : context;
			this.resolved && this.handler.join().fail(c);
		};

		Pending.prototype._report = function(context) {
			this.resolved && this.handler.join()._report(context);
		};

		Pending.prototype._unreport = function() {
			this.resolved && this.handler.join()._unreport();
		};

		/**
		 * Wrap another handler and force it into a future stack
		 * @param {object} handler
		 * @constructor
		 */
		function Async(handler) {
			this.handler = handler;
		}

		inherit(Handler, Async);

		Async.prototype.when = function(continuation) {
			tasks.enqueue(new ContinuationTask(continuation, this));
		};

		Async.prototype._report = function(context) {
			this.join()._report(context);
		};

		Async.prototype._unreport = function() {
			this.join()._unreport();
		};

		/**
		 * Handler that wraps an untrusted thenable and assimilates it in a future stack
		 * @param {function} then
		 * @param {{then: function}} thenable
		 * @constructor
		 */
		function Thenable(then, thenable) {
			Pending.call(this);
			tasks.enqueue(new AssimilateTask(then, thenable, this));
		}

		inherit(Pending, Thenable);

		/**
		 * Handler for a fulfilled promise
		 * @param {*} x fulfillment value
		 * @constructor
		 */
		function Fulfilled(x) {
			Promise.createContext(this);
			this.value = x;
		}

		inherit(Handler, Fulfilled);

		Fulfilled.prototype._state = 1;

		Fulfilled.prototype.fold = function(f, z, c, to) {
			runContinuation3(f, z, this, c, to);
		};

		Fulfilled.prototype.when = function(cont) {
			runContinuation1(cont.fulfilled, this, cont.receiver, cont.resolver);
		};

		var errorId = 0;

		/**
		 * Handler for a rejected promise
		 * @param {*} x rejection reason
		 * @constructor
		 */
		function Rejected(x) {
			Promise.createContext(this);

			this.id = ++errorId;
			this.value = x;
			this.handled = false;
			this.reported = false;

			this._report();
		}

		inherit(Handler, Rejected);

		Rejected.prototype._state = -1;

		Rejected.prototype.fold = function(f, z, c, to) {
			to.become(this);
		};

		Rejected.prototype.when = function(cont) {
			if(typeof cont.rejected === 'function') {
				this._unreport();
			}
			runContinuation1(cont.rejected, this, cont.receiver, cont.resolver);
		};

		Rejected.prototype._report = function(context) {
			tasks.afterQueue(new ReportTask(this, context));
		};

		Rejected.prototype._unreport = function() {
			if(this.handled) {
				return;
			}
			this.handled = true;
			tasks.afterQueue(new UnreportTask(this));
		};

		Rejected.prototype.fail = function(context) {
			this.reported = true;
			emitRejection('unhandledRejection', this);
			Promise.onFatalRejection(this, context === void 0 ? this.context : context);
		};

		function ReportTask(rejection, context) {
			this.rejection = rejection;
			this.context = context;
		}

		ReportTask.prototype.run = function() {
			if(!this.rejection.handled && !this.rejection.reported) {
				this.rejection.reported = true;
				emitRejection('unhandledRejection', this.rejection) ||
					Promise.onPotentiallyUnhandledRejection(this.rejection, this.context);
			}
		};

		function UnreportTask(rejection) {
			this.rejection = rejection;
		}

		UnreportTask.prototype.run = function() {
			if(this.rejection.reported) {
				emitRejection('rejectionHandled', this.rejection) ||
					Promise.onPotentiallyUnhandledRejectionHandled(this.rejection);
			}
		};

		// Unhandled rejection hooks
		// By default, everything is a noop

		Promise.createContext
			= Promise.enterContext
			= Promise.exitContext
			= Promise.onPotentiallyUnhandledRejection
			= Promise.onPotentiallyUnhandledRejectionHandled
			= Promise.onFatalRejection
			= noop;

		// Errors and singletons

		var foreverPendingHandler = new Handler();
		var foreverPendingPromise = new Promise(Handler, foreverPendingHandler);

		function cycle() {
			return new Rejected(new TypeError('Promise cycle'));
		}

		// Task runners

		/**
		 * Run a single consumer
		 * @constructor
		 */
		function ContinuationTask(continuation, handler) {
			this.continuation = continuation;
			this.handler = handler;
		}

		ContinuationTask.prototype.run = function() {
			this.handler.join().when(this.continuation);
		};

		/**
		 * Run a queue of progress handlers
		 * @constructor
		 */
		function ProgressTask(value, handler) {
			this.handler = handler;
			this.value = value;
		}

		ProgressTask.prototype.run = function() {
			var q = this.handler.consumers;
			if(q === void 0) {
				return;
			}

			for (var c, i = 0; i < q.length; ++i) {
				c = q[i];
				runNotify(c.progress, this.value, this.handler, c.receiver, c.resolver);
			}
		};

		/**
		 * Assimilate a thenable, sending it's value to resolver
		 * @param {function} then
		 * @param {object|function} thenable
		 * @param {object} resolver
		 * @constructor
		 */
		function AssimilateTask(then, thenable, resolver) {
			this._then = then;
			this.thenable = thenable;
			this.resolver = resolver;
		}

		AssimilateTask.prototype.run = function() {
			var h = this.resolver;
			tryAssimilate(this._then, this.thenable, _resolve, _reject, _notify);

			function _resolve(x) { h.resolve(x); }
			function _reject(x)  { h.reject(x); }
			function _notify(x)  { h.notify(x); }
		};

		function tryAssimilate(then, thenable, resolve, reject, notify) {
			try {
				then.call(thenable, resolve, reject, notify);
			} catch (e) {
				reject(e);
			}
		}

		/**
		 * Fold a handler value with z
		 * @constructor
		 */
		function Fold(f, z, c, to) {
			this.f = f; this.z = z; this.c = c; this.to = to;
			this.resolver = failIfRejected;
			this.receiver = this;
		}

		Fold.prototype.fulfilled = function(x) {
			this.f.call(this.c, this.z, x, this.to);
		};

		Fold.prototype.rejected = function(x) {
			this.to.reject(x);
		};

		Fold.prototype.progress = function(x) {
			this.to.notify(x);
		};

		// Other helpers

		/**
		 * @param {*} x
		 * @returns {boolean} true iff x is a trusted Promise
		 */
		function isPromise(x) {
			return x instanceof Promise;
		}

		/**
		 * Test just enough to rule out primitives, in order to take faster
		 * paths in some code
		 * @param {*} x
		 * @returns {boolean} false iff x is guaranteed *not* to be a thenable
		 */
		function maybeThenable(x) {
			return (typeof x === 'object' || typeof x === 'function') && x !== null;
		}

		function runContinuation1(f, h, receiver, next) {
			if(typeof f !== 'function') {
				return next.become(h);
			}

			Promise.enterContext(h);
			tryCatchReject(f, h.value, receiver, next);
			Promise.exitContext();
		}

		function runContinuation3(f, x, h, receiver, next) {
			if(typeof f !== 'function') {
				return next.become(h);
			}

			Promise.enterContext(h);
			tryCatchReject3(f, x, h.value, receiver, next);
			Promise.exitContext();
		}

		/**
		 * @deprecated
		 */
		function runNotify(f, x, h, receiver, next) {
			if(typeof f !== 'function') {
				return next.notify(x);
			}

			Promise.enterContext(h);
			tryCatchReturn(f, x, receiver, next);
			Promise.exitContext();
		}

		function tryCatch2(f, a, b) {
			try {
				return f(a, b);
			} catch(e) {
				return reject(e);
			}
		}

		/**
		 * Return f.call(thisArg, x), or if it throws return a rejected promise for
		 * the thrown exception
		 */
		function tryCatchReject(f, x, thisArg, next) {
			try {
				next.become(getHandler(f.call(thisArg, x)));
			} catch(e) {
				next.become(new Rejected(e));
			}
		}

		/**
		 * Same as above, but includes the extra argument parameter.
		 */
		function tryCatchReject3(f, x, y, thisArg, next) {
			try {
				f.call(thisArg, x, y, next);
			} catch(e) {
				next.become(new Rejected(e));
			}
		}

		/**
		 * @deprecated
		 * Return f.call(thisArg, x), or if it throws, *return* the exception
		 */
		function tryCatchReturn(f, x, thisArg, next) {
			try {
				next.notify(f.call(thisArg, x));
			} catch(e) {
				next.notify(e);
			}
		}

		function inherit(Parent, Child) {
			Child.prototype = objectCreate(Parent.prototype);
			Child.prototype.constructor = Child;
		}

		function snd(x, y) {
			return y;
		}

		function noop() {}

		function initEmitRejection() {
			/*global process, self, CustomEvent*/
			if(typeof process !== 'undefined' && process !== null
				&& typeof process.emit === 'function') {
				// Returning falsy here means to call the default
				// onPotentiallyUnhandledRejection API.  This is safe even in
				// browserify since process.emit always returns falsy in browserify:
				// https://github.com/defunctzombie/node-process/blob/master/browser.js#L40-L46
				return function(type, rejection) {
					return type === 'unhandledRejection'
						? process.emit(type, rejection.value, rejection)
						: process.emit(type, rejection);
				};
			} else if(typeof self !== 'undefined' && typeof CustomEvent === 'function') {
				return (function(noop, self, CustomEvent) {
					var hasCustomEvent = false;
					try {
						var ev = new CustomEvent('unhandledRejection');
						hasCustomEvent = ev instanceof CustomEvent;
					} catch (e) {}

					return !hasCustomEvent ? noop : function(type, rejection) {
						var ev = new CustomEvent(type, {
							detail: {
								reason: rejection.value,
								key: rejection
							},
							bubbles: false,
							cancelable: true
						});

						return !self.dispatchEvent(ev);
					};
				}(noop, self, CustomEvent));
			}

			return noop;
		}

		return Promise;
	};
});
}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(); }));

}).call(this,require('_process'))
},{"_process":490}],756:[function(require,module,exports){
/** @license MIT License (c) copyright 2010-2014 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

(function(define) { 'use strict';
define(function() {

	return {
		pending: toPendingState,
		fulfilled: toFulfilledState,
		rejected: toRejectedState,
		inspect: inspect
	};

	function toPendingState() {
		return { state: 'pending' };
	}

	function toRejectedState(e) {
		return { state: 'rejected', reason: e };
	}

	function toFulfilledState(x) {
		return { state: 'fulfilled', value: x };
	}

	function inspect(handler) {
		var state = handler.state();
		return state === 0 ? toPendingState()
			 : state > 0   ? toFulfilledState(handler.value)
			               : toRejectedState(handler.value);
	}

});
}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(); }));

},{}],757:[function(require,module,exports){
/** @license MIT License (c) copyright 2013 original author or authors */

/**
 * Collection of helpers for interfacing with node-style asynchronous functions
 * using promises.
 *
 * @author Brian Cavalier
 * @contributor Renato Zannon
 */

(function(define) {
define(function(require) {

	var when = require('./when');
	var _liftAll = require('./lib/liftAll');
	var setTimer = require('./lib/env').setTimer;
	var slice = Array.prototype.slice;

	var _apply = require('./lib/apply')(when.Promise, dispatch);

	return {
		lift: lift,
		liftAll: liftAll,
		apply: apply,
		call: call,
		createCallback: createCallback,
		bindCallback: bindCallback,
		liftCallback: liftCallback
	};

	/**
	 * Takes a node-style async function and calls it immediately (with an optional
	 * array of arguments or promises for arguments). It returns a promise whose
	 * resolution depends on whether the async functions calls its callback with the
	 * conventional error argument or not.
	 *
	 * With this it becomes possible to leverage existing APIs while still reaping
	 * the benefits of promises.
	 *
	 * @example
	 *    function onlySmallNumbers(n, callback) {
	 *		if(n < 10) {
	 *			callback(null, n + 10);
	 *		} else {
	 *			callback(new Error("Calculation failed"));
	 *		}
	 *	}
	 *
	 *    var nodefn = require("when/node/function");
	 *
	 *    // Logs '15'
	 *    nodefn.apply(onlySmallNumbers, [5]).then(console.log, console.error);
	 *
	 *    // Logs 'Calculation failed'
	 *    nodefn.apply(onlySmallNumbers, [15]).then(console.log, console.error);
	 *
	 * @param {function} f node-style function that will be called
	 * @param {Array} [args] array of arguments to func
	 * @returns {Promise} promise for the value func passes to its callback
	 */
	function apply(f, args) {
		return _apply(f, this, args || []);
	}

	function dispatch(f, thisArg, args, h) {
		var cb = createCallback(h);
		try {
			switch(args.length) {
				case 2: f.call(thisArg, args[0], args[1], cb); break;
				case 1: f.call(thisArg, args[0], cb); break;
				case 0: f.call(thisArg, cb); break;
				default:
					args.push(cb);
					f.apply(thisArg, args);
			}
		} catch(e) {
			h.reject(e);
		}
	}

	/**
	 * Has the same behavior that {@link apply} has, with the difference that the
	 * arguments to the function are provided individually, while {@link apply} accepts
	 * a single array.
	 *
	 * @example
	 *    function sumSmallNumbers(x, y, callback) {
	 *		var result = x + y;
	 *		if(result < 10) {
	 *			callback(null, result);
	 *		} else {
	 *			callback(new Error("Calculation failed"));
	 *		}
	 *	}
	 *
	 *    // Logs '5'
	 *    nodefn.call(sumSmallNumbers, 2, 3).then(console.log, console.error);
	 *
	 *    // Logs 'Calculation failed'
	 *    nodefn.call(sumSmallNumbers, 5, 10).then(console.log, console.error);
	 *
	 * @param {function} f node-style function that will be called
	 * @param {...*} [args] arguments that will be forwarded to the function
	 * @returns {Promise} promise for the value func passes to its callback
	 */
	function call(f /*, args... */) {
		return _apply(f, this, slice.call(arguments, 1));
	}

	/**
	 * Takes a node-style function and returns new function that wraps the
	 * original and, instead of taking a callback, returns a promise. Also, it
	 * knows how to handle promises given as arguments, waiting for their
	 * resolution before executing.
	 *
	 * Upon execution, the orginal function is executed as well. If it passes
	 * a truthy value as the first argument to the callback, it will be
	 * interpreted as an error condition, and the promise will be rejected
	 * with it. Otherwise, the call is considered a resolution, and the promise
	 * is resolved with the callback's second argument.
	 *
	 * @example
	 *    var fs = require("fs"), nodefn = require("when/node/function");
	 *
	 *    var promiseRead = nodefn.lift(fs.readFile);
	 *
	 *    // The promise is resolved with the contents of the file if everything
	 *    // goes ok
	 *    promiseRead('exists.txt').then(console.log, console.error);
	 *
	 *    // And will be rejected if something doesn't work out
	 *    // (e.g. the files does not exist)
	 *    promiseRead('doesnt_exist.txt').then(console.log, console.error);
	 *
	 *
	 * @param {Function} f node-style function to be lifted
	 * @param {...*} [args] arguments to be prepended for the new function @deprecated
	 * @returns {Function} a promise-returning function
	 */
	function lift(f /*, args... */) {
		var args1 = arguments.length > 1 ? slice.call(arguments, 1) : [];
		return function() {
			// TODO: Simplify once partialing has been removed
			var l = args1.length;
			var al = arguments.length;
			var args = new Array(al + l);
			var i;
			for(i=0; i<l; ++i) {
				args[i] = args1[i];
			}
			for(i=0; i<al; ++i) {
				args[i+l] = arguments[i];
			}
			return _apply(f, this, args);
		};
	}

	/**
	 * Lift all the functions/methods on src
	 * @param {object|function} src source whose functions will be lifted
	 * @param {function?} combine optional function for customizing the lifting
	 *  process. It is passed dst, the lifted function, and the property name of
	 *  the original function on src.
	 * @param {(object|function)?} dst option destination host onto which to place lifted
	 *  functions. If not provided, liftAll returns a new object.
	 * @returns {*} If dst is provided, returns dst with lifted functions as
	 *  properties.  If dst not provided, returns a new object with lifted functions.
	 */
	function liftAll(src, combine, dst) {
		return _liftAll(lift, combine, dst, src);
	}

	/**
	 * Takes an object that responds to the resolver interface, and returns
	 * a function that will resolve or reject it depending on how it is called.
	 *
	 * @example
	 *	function callbackTakingFunction(callback) {
	 *		if(somethingWrongHappened) {
	 *			callback(error);
	 *		} else {
	 *			callback(null, interestingValue);
	 *		}
	 *	}
	 *
	 *	var when = require('when'), nodefn = require('when/node/function');
	 *
	 *	var deferred = when.defer();
	 *	callbackTakingFunction(nodefn.createCallback(deferred.resolver));
	 *
	 *	deferred.promise.then(function(interestingValue) {
	 *		// Use interestingValue
	 *	});
	 *
	 * @param {Resolver} resolver that will be 'attached' to the callback
	 * @returns {Function} a node-style callback function
	 */
	function createCallback(resolver) {
		return function(err, value) {
			if(err) {
				resolver.reject(err);
			} else if(arguments.length > 2) {
				resolver.resolve(slice.call(arguments, 1));
			} else {
				resolver.resolve(value);
			}
		};
	}

	/**
	 * Attaches a node-style callback to a promise, ensuring the callback is
	 * called for either fulfillment or rejection. Returns a promise with the same
	 * state as the passed-in promise.
	 *
	 * @example
	 *	var deferred = when.defer();
	 *
	 *	function callback(err, value) {
	 *		// Handle err or use value
	 *	}
	 *
	 *	bindCallback(deferred.promise, callback);
	 *
	 *	deferred.resolve('interesting value');
	 *
	 * @param {Promise} promise The promise to be attached to.
	 * @param {Function} callback The node-style callback to attach.
	 * @returns {Promise} A promise with the same state as the passed-in promise.
	 */
	function bindCallback(promise, callback) {
		promise = when(promise);

		if (callback) {
			promise.then(success, wrapped);
		}

		return promise;

		function success(value) {
			wrapped(null, value);
		}

		function wrapped(err, value) {
			setTimer(function () {
				callback(err, value);
			}, 0);
		}
	}

	/**
	 * Takes a node-style callback and returns new function that accepts a
	 * promise, calling the original callback when the promise is either
	 * fulfilled or rejected with the appropriate arguments.
	 *
	 * @example
	 *	var deferred = when.defer();
	 *
	 *	function callback(err, value) {
	 *		// Handle err or use value
	 *	}
	 *
	 *	var wrapped = liftCallback(callback);
	 *
	 *	// `wrapped` can now be passed around at will
	 *	wrapped(deferred.promise);
	 *
	 *	deferred.resolve('interesting value');
	 *
	 * @param {Function} callback The node-style callback to wrap.
	 * @returns {Function} The lifted, promise-accepting function.
	 */
	function liftCallback(callback) {
		return function(promise) {
			return bindCallback(promise, callback);
		};
	}
});

})(typeof define === 'function' && define.amd ? define : function (factory) { module.exports = factory(require); });




},{"./lib/apply":742,"./lib/env":752,"./lib/liftAll":754,"./when":758}],758:[function(require,module,exports){
/** @license MIT License (c) copyright 2010-2014 original author or authors */

/**
 * Promises/A+ and when() implementation
 * when is part of the cujoJS family of libraries (http://cujojs.com/)
 * @author Brian Cavalier
 * @author John Hann
 */
(function(define) { 'use strict';
define(function (require) {

	var timed = require('./lib/decorators/timed');
	var array = require('./lib/decorators/array');
	var flow = require('./lib/decorators/flow');
	var fold = require('./lib/decorators/fold');
	var inspect = require('./lib/decorators/inspect');
	var generate = require('./lib/decorators/iterate');
	var progress = require('./lib/decorators/progress');
	var withThis = require('./lib/decorators/with');
	var unhandledRejection = require('./lib/decorators/unhandledRejection');
	var TimeoutError = require('./lib/TimeoutError');

	var Promise = [array, flow, fold, generate, progress,
		inspect, withThis, timed, unhandledRejection]
		.reduce(function(Promise, feature) {
			return feature(Promise);
		}, require('./lib/Promise'));

	var apply = require('./lib/apply')(Promise);

	// Public API

	when.promise     = promise;              // Create a pending promise
	when.resolve     = Promise.resolve;      // Create a resolved promise
	when.reject      = Promise.reject;       // Create a rejected promise

	when.lift        = lift;                 // lift a function to return promises
	when['try']      = attempt;              // call a function and return a promise
	when.attempt     = attempt;              // alias for when.try

	when.iterate     = Promise.iterate;      // DEPRECATED (use cujojs/most streams) Generate a stream of promises
	when.unfold      = Promise.unfold;       // DEPRECATED (use cujojs/most streams) Generate a stream of promises

	when.join        = join;                 // Join 2 or more promises

	when.all         = all;                  // Resolve a list of promises
	when.settle      = settle;               // Settle a list of promises

	when.any         = lift(Promise.any);    // One-winner race
	when.some        = lift(Promise.some);   // Multi-winner race
	when.race        = lift(Promise.race);   // First-to-settle race

	when.map         = map;                  // Array.map() for promises
	when.filter      = filter;               // Array.filter() for promises
	when.reduce      = lift(Promise.reduce);       // Array.reduce() for promises
	when.reduceRight = lift(Promise.reduceRight);  // Array.reduceRight() for promises

	when.isPromiseLike = isPromiseLike;      // Is something promise-like, aka thenable

	when.Promise     = Promise;              // Promise constructor
	when.defer       = defer;                // Create a {promise, resolve, reject} tuple

	// Error types

	when.TimeoutError = TimeoutError;

	/**
	 * Get a trusted promise for x, or by transforming x with onFulfilled
	 *
	 * @param {*} x
	 * @param {function?} onFulfilled callback to be called when x is
	 *   successfully fulfilled.  If promiseOrValue is an immediate value, callback
	 *   will be invoked immediately.
	 * @param {function?} onRejected callback to be called when x is
	 *   rejected.
	 * @param {function?} onProgress callback to be called when progress updates
	 *   are issued for x. @deprecated
	 * @returns {Promise} a new promise that will fulfill with the return
	 *   value of callback or errback or the completion value of promiseOrValue if
	 *   callback and/or errback is not supplied.
	 */
	function when(x, onFulfilled, onRejected, onProgress) {
		var p = Promise.resolve(x);
		if (arguments.length < 2) {
			return p;
		}

		return p.then(onFulfilled, onRejected, onProgress);
	}

	/**
	 * Creates a new promise whose fate is determined by resolver.
	 * @param {function} resolver function(resolve, reject, notify)
	 * @returns {Promise} promise whose fate is determine by resolver
	 */
	function promise(resolver) {
		return new Promise(resolver);
	}

	/**
	 * Lift the supplied function, creating a version of f that returns
	 * promises, and accepts promises as arguments.
	 * @param {function} f
	 * @returns {Function} version of f that returns promises
	 */
	function lift(f) {
		return function() {
			for(var i=0, l=arguments.length, a=new Array(l); i<l; ++i) {
				a[i] = arguments[i];
			}
			return apply(f, this, a);
		};
	}

	/**
	 * Call f in a future turn, with the supplied args, and return a promise
	 * for the result.
	 * @param {function} f
	 * @returns {Promise}
	 */
	function attempt(f /*, args... */) {
		/*jshint validthis:true */
		for(var i=0, l=arguments.length-1, a=new Array(l); i<l; ++i) {
			a[i] = arguments[i+1];
		}
		return apply(f, this, a);
	}

	/**
	 * Creates a {promise, resolver} pair, either or both of which
	 * may be given out safely to consumers.
	 * @return {{promise: Promise, resolve: function, reject: function, notify: function}}
	 */
	function defer() {
		return new Deferred();
	}

	function Deferred() {
		var p = Promise._defer();

		function resolve(x) { p._handler.resolve(x); }
		function reject(x) { p._handler.reject(x); }
		function notify(x) { p._handler.notify(x); }

		this.promise = p;
		this.resolve = resolve;
		this.reject = reject;
		this.notify = notify;
		this.resolver = { resolve: resolve, reject: reject, notify: notify };
	}

	/**
	 * Determines if x is promise-like, i.e. a thenable object
	 * NOTE: Will return true for *any thenable object*, and isn't truly
	 * safe, since it may attempt to access the `then` property of x (i.e.
	 *  clever/malicious getters may do weird things)
	 * @param {*} x anything
	 * @returns {boolean} true if x is promise-like
	 */
	function isPromiseLike(x) {
		return x && typeof x.then === 'function';
	}

	/**
	 * Return a promise that will resolve only once all the supplied arguments
	 * have resolved. The resolution value of the returned promise will be an array
	 * containing the resolution values of each of the arguments.
	 * @param {...*} arguments may be a mix of promises and values
	 * @returns {Promise}
	 */
	function join(/* ...promises */) {
		return Promise.all(arguments);
	}

	/**
	 * Return a promise that will fulfill once all input promises have
	 * fulfilled, or reject when any one input promise rejects.
	 * @param {array|Promise} promises array (or promise for an array) of promises
	 * @returns {Promise}
	 */
	function all(promises) {
		return when(promises, Promise.all);
	}

	/**
	 * Return a promise that will always fulfill with an array containing
	 * the outcome states of all input promises.  The returned promise
	 * will only reject if `promises` itself is a rejected promise.
	 * @param {array|Promise} promises array (or promise for an array) of promises
	 * @returns {Promise} promise for array of settled state descriptors
	 */
	function settle(promises) {
		return when(promises, Promise.settle);
	}

	/**
	 * Promise-aware array map function, similar to `Array.prototype.map()`,
	 * but input array may contain promises or values.
	 * @param {Array|Promise} promises array of anything, may contain promises and values
	 * @param {function(x:*, index:Number):*} mapFunc map function which may
	 *  return a promise or value
	 * @returns {Promise} promise that will fulfill with an array of mapped values
	 *  or reject if any input promise rejects.
	 */
	function map(promises, mapFunc) {
		return when(promises, function(promises) {
			return Promise.map(promises, mapFunc);
		});
	}

	/**
	 * Filter the provided array of promises using the provided predicate.  Input may
	 * contain promises and values
	 * @param {Array|Promise} promises array of promises and values
	 * @param {function(x:*, index:Number):boolean} predicate filtering predicate.
	 *  Must return truthy (or promise for truthy) for items to retain.
	 * @returns {Promise} promise that will fulfill with an array containing all items
	 *  for which predicate returned truthy.
	 */
	function filter(promises, predicate) {
		return when(promises, function(promises) {
			return Promise.filter(promises, predicate);
		});
	}

	return when;
});
})(typeof define === 'function' && define.amd ? define : function (factory) { module.exports = factory(require); });

},{"./lib/Promise":739,"./lib/TimeoutError":741,"./lib/apply":742,"./lib/decorators/array":743,"./lib/decorators/flow":744,"./lib/decorators/fold":745,"./lib/decorators/inspect":746,"./lib/decorators/iterate":747,"./lib/decorators/progress":748,"./lib/decorators/timed":749,"./lib/decorators/unhandledRejection":750,"./lib/decorators/with":751}],759:[function(require,module,exports){
"use strict";

// Licensed to the Apache Software Foundation (ASF) under one or more
// contributor license agreements.  See the NOTICE file distributed with
// this work for additional information regarding copyright ownership.
// The ASF licenses this file to You under the Apache License, Version 2.0
// (the "License"); you may not use this file except in compliance with
// the License.  You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

if (typeof require !== "undefined") {
  var has = require("ramda/src/has");
  var rType = require("ramda/src/type");
  var equals = require("ramda/src/equals");
  var contains = require("ramda/src/contains");
  var all = require("ramda/src/all");
  var pluck = require("ramda/src/pluck");
}

function isString(a) {
  return rType(a) === "String";
}
function isObject(a) {
  return rType(a) === "Object";
}
function isNull(a) {
  return rType(a) === "Null";
}
function isUndefined(a) {
  return a === void 0;
}
function isNumber(a) {
  return rType(a) === "Number";
}
function isBoolean(a) {
  return rType(a) === "Boolean";
}

const AvroSpec = {
  PrimitiveTypes: ["null", "boolean", "int", "long", "float", "double", "bytes", "string"],
  ComplexTypes: ["record", "enum", "array", "map", "union", "fixed"]
};

const hexRegEx = /([0-9]|[a-f]|[A-F])/gm;

AvroSpec.Types = AvroSpec.PrimitiveTypes.concat(AvroSpec.ComplexTypes);

const InvalidSchemaError = function (msg) {
  return new Error(`InvalidSchemaError: ${msg}`);
};
const InvalidProtocolError = function (msg) {
  return new Error(`InvalidProtocolError: ${msg}`);
};
const ValidationError = function (msg) {
  return new Error(`ValidationError: ${msg}`);
};
const ProtocolValidationError = function (msg) {
  return new Error(`ProtocolValidationError: ${msg}`);
};

function Record(name, namespace, fields, typeName) {
  function validateArgs(name, namespace, fields) {
    if (!isString(name)) {
      throw new InvalidSchemaError("Record name must be string");
    }

    if (!isNull(namespace) && !isUndefined(namespace) && !isString(namespace)) {
      throw new InvalidSchemaError("Record namespace must be string or null");
    }

    if (!Array.isArray(fields)) {
      throw new InvalidSchemaError("Record name must be string");
    }
  }

  validateArgs(name, namespace, fields);

  this.name = name;
  this.typeName = typeName;
  this.namespace = namespace;
  this.fields = fields;
}

function isHex(input) {
  return typeof input === "string" && (input.match(hexRegEx) || []).length === input.length;
}

function makeFullyQualifiedTypeName(schema, namespace) {
  let typeName = null;
  if (isString(schema)) {
    typeName = schema;
  } else if (isObject(schema)) {
    if (isString(schema.namespace)) {
      namespace = schema.namespace;
    }
    if (isString(schema.name)) {
      typeName = schema.name;
    } else if (isString(schema.type)) {
      typeName = schema.type;
    } else if (has("valueSchema", schema) && isString(schema.valueSchema.type)) {
      /** BEGIN CHANGE BY drewp **/
      typeName = schema.typeName;
    }
    /** END CHANGE BY drewp **/
  } else {
    throw new InvalidSchemaError(`unable to determine fully qualified type name from schema ${JSON.stringify(schema)} in namespace ${namespace}`);
  }

  if (!isString(typeName)) {
    throw new InvalidSchemaError(`unable to determine type name from schema ${JSON.stringify(schema)} in namespace ${namespace}`);
  }

  if (typeName.indexOf(".") !== -1) {
    return typeName;
  } else if (contains(typeName, AvroSpec.PrimitiveTypes)) {
    return typeName;
  } else if (isString(namespace)) {
    return `${namespace}.${typeName}`;
  }
  return typeName;
}

function Union(typeSchemas, namespace, typeName) {
  this.branchNames = function () {
    return typeSchemas.map(function (typeSchema) {
      return makeFullyQualifiedTypeName(typeSchema, namespace);
    });
  };

  function validateArgs(typeSchemas) {
    if (!Array.isArray(typeSchemas) || !typeSchemas.length) {
      throw new InvalidSchemaError("Union must have at least 1 branch");
    }
  }

  validateArgs(typeSchemas);

  this.typeSchemas = typeSchemas;
  this.typeName = typeName;
  this.namespace = namespace;
}

function Enum(symbols, typeName) {
  function validateArgs(symbols) {
    if (!Array.isArray(symbols)) {
      throw new InvalidSchemaError(`Enum must have array of symbols, got ${JSON.stringify(symbols)}`);
    }
    if (!all(function (symbol) {
      return isString(symbol);
    }, symbols)) {
      throw new InvalidSchemaError(`Enum symbols must be strings, got ${JSON.stringify(symbols)}`);
    }
  }

  validateArgs(symbols);

  this.symbols = symbols;
  this.typeName = typeName;
}

function AvroArray(itemSchema, typeName) {
  function validateArgs(itemSchema) {
    if (isNull(itemSchema) || isUndefined(itemSchema)) {
      throw new InvalidSchemaError('Array "items" schema should not be null or undefined');
    }
  }

  validateArgs(itemSchema);

  this.itemSchema = itemSchema;
  this.typeName = typeName;
}

function Map(valueSchema, typeName) {
  function validateArgs(valueSchema) {
    if (isNull(valueSchema) || isUndefined(valueSchema)) {
      throw new InvalidSchemaError('Map "values" schema should not be null or undefined');
    }
  }

  validateArgs(valueSchema);

  this.valueSchema = valueSchema;
  this.typeName = typeName;
}

function Field(name, schema) {
  function validateArgs(name, schema) {
    if (!isString(name)) {
      throw new InvalidSchemaError("Field name must be string");
    }
  }

  this.name = name;
  this.schema = schema;
}

function Primitive(type) {
  function validateArgs(type) {
    if (!isString(type)) {
      throw new InvalidSchemaError("Primitive type name must be a string");
    }

    if (!contains(type, AvroSpec.PrimitiveTypes)) {
      throw new InvalidSchemaError(`Primitive type must be one of: ${JSON.stringify(AvroSpec.PrimitiveTypes)}; got ${type}`);
    }
  }

  validateArgs(type);

  this.type = type;
}

function Validator(schema, namespace, namedTypes) {
  this.validate = function (obj) {
    return _validate(this.schema, obj);
  };

  var _validate = function (schema, obj, fieldName) {
    if (schema instanceof Record) {
      return _validateRecord(schema, obj);
    } else if (schema instanceof Union) {
      return _validateUnion(schema, obj, fieldName);
    } else if (schema instanceof Enum) {
      return _validateEnum(schema, obj);
    } else if (schema instanceof AvroArray) {
      return _validateArray(schema, obj);
    } else if (schema instanceof Map) {
      return _validateMap(schema, obj);
    } else if (schema instanceof Primitive) {
      return _validatePrimitive(schema, obj);
    }
    throw new InvalidSchemaError(`validation not yet implemented: ${JSON.stringify(schema)}`);
  };

  var _validateRecord = function (schema, obj) {
    if (!isObject(obj)) {
      throw new ValidationError(`Expected record Javascript type to be non-array object, got ${JSON.stringify(obj)}`);
    }

    const schemaFieldNames = pluck("name", schema.fields).sort();
    const objFieldNames = Object.keys(obj).sort();
    if (!equals(schemaFieldNames, objFieldNames)) {
      throw new ValidationError(`Expected record fields ${JSON.stringify(schemaFieldNames)}; got ${JSON.stringify(objFieldNames)}`);
    }
    return all(function (field) {
      return _validate(field.schema, obj[field.name], field.name);
    }, schema.fields);
  };

  var _validateUnion = function (schema, obj, fieldName) {
    if (isObject(obj)) {
      if (Array.isArray(obj)) {
        throw new ValidationError(`Expected union Javascript type to be non-array object (or null), got ${JSON.stringify(obj)}`);
      } else if (Object.keys(obj).length !== 1) {
        throw new ValidationError(`Expected union Javascript object to be object with exactly 1 key (or null), got ${JSON.stringify(obj)}`);
      } else {
        const unionBranch = Object.keys(obj)[0];
        if (unionBranch === "") {
          throw new ValidationError(`Expected union Javascript object to contain non-empty string branch, got ${JSON.stringify(obj)}`);
        }
        if (contains(unionBranch, schema.branchNames())) {
          const typeIndex = schema.branchNames().indexOf(unionBranch);
          const unionBranchVal = obj[unionBranch];
          if (isNull(unionBranchVal) && contains("null", schema.branchNames()) || isUndefined(unionBranchVal)) {
            return true;
          }
          try {
            _validate(schema.typeSchemas[typeIndex], obj[unionBranch]);
            return true;
          } catch (e) {
            throw new ValidationError(`Expected field name ${fieldName} value to validate. Instead got an error: ${e.message}`);
          }
        } else {
          throw new ValidationError(`Expected union branch to be one of ${JSON.stringify(schema.branchNames())}; got ${JSON.stringify(unionBranch)}`);
        }
      }
    } else if (isNull(obj)) {
      if (contains("null", schema.branchNames())) {
        return true;
      }
      throw new ValidationError(`Expected union branch to be one of ${JSON.stringify(schema.branchNames())}; got ${JSON.stringify(obj)}`);
    } else if (Array.isArray(obj)) {
      throw new ValidationError(`Expected union Javascript type to be non-array object (or null), got ${JSON.stringify(obj)}`);
    } else {
      throw new ValidationError(`Expected union Javascript object to be non-array object of size 1 or null, got ${JSON.stringify(obj)}`);
    }
  };

  var _validateEnum = function (schema, obj) {
    if (isString(obj)) {
      if (contains(obj, schema.symbols)) {
        return true;
      }
      throw new ValidationError(`Expected enum value to be one of ${JSON.stringify(schema.symbols)}; got ${JSON.stringify(obj)}`);
    } else {
      throw new ValidationError(`Expected enum Javascript object to be string, got ${JSON.stringify(obj)}`);
    }
  };

  var _validateArray = function (schema, obj) {
    if (Array.isArray(obj)) {
      return all(function (member) {
        return _validate(schema.itemSchema, member);
      }, obj);
    }
    throw new ValidationError(`Expected array Javascript object to be array, got ${JSON.stringify(obj)}`);
  };

  var _validateMap = function (schema, obj) {
    if (isObject(obj)) {
      return all(function (key) {
        return _validate(schema.valueSchema, obj[key]);
      }, Object.keys(obj));
    } else if (Array.isArray(obj)) {
      throw new ValidationError(`Expected map Javascript object to be non-array object, got array ${JSON.stringify(obj)}`);
    } else {
      throw new ValidationError(`Expected map Javascript object to be non-array object, got ${JSON.stringify(obj)}`);
    }
  };

  var _validatePrimitive = function (schema, obj) {
    switch (schema.type) {
      case "null":
        if (isNull(obj) || isUndefined(obj)) {
          return true;
        }
        throw new ValidationError(`Expected Javascript null or undefined for Avro null, got ${JSON.stringify(obj)}`);

        break;
      case "boolean":
        if (isBoolean(obj)) {
          return true;
        }
        throw new ValidationError(`Expected Javascript boolean for Avro boolean, got ${JSON.stringify(obj)}`);

        break;
      case "int":
        if (isNumber(obj) && Math.floor(obj) === obj && Math.abs(obj) <= Math.pow(2, 31)) {
          return true;
        }
        throw new ValidationError(`Expected Javascript int32 number for Avro int, got ${JSON.stringify(obj)}`);

        break;
      case "long":
        if (isNumber(obj) && Math.floor(obj) === obj && Math.abs(obj) <= Math.pow(2, 63)) {
          return true;
        }
        throw new ValidationError(`Expected Javascript int64 number for Avro long, got ${JSON.stringify(obj)}`);

        break;
      case "float":
        if (isNumber(obj)) {
          // TODO: handle NaN?
          return true;
        }
        throw new ValidationError(`Expected Javascript float number for Avro float, got ${JSON.stringify(obj)}`);

        break;
      case "double":
        if (isNumber(obj)) {
          // TODO: handle NaN?
          return true;
        }
        throw new ValidationError(`Expected Javascript double number for Avro double, got ${JSON.stringify(obj)}`);

        break;
      case "bytes":
        if (isHex(obj)) {
          return true;
        }
        throw new ValidationError(`Expected Javascript bytes for Avro byts, got ${JSON.stringify(obj)}`);

      case "string":
        if (isString(obj)) {
          // TODO: handle NaN?
          return true;
        }
        throw new ValidationError(`Expected Javascript string for Avro string, got ${JSON.stringify(obj)}`);

        break;
      default:
        throw new InvalidSchemaError(`unrecognized primitive type: ${schema.type}`);
    }
  };

  // TODO: namespace handling is rudimentary. multiple namespaces within a certain nested schema definition
  // are probably buggy.
  const _namedTypes = namedTypes || {};
  const _saveNamedType = function (fullyQualifiedTypeName, schema) {
    if (has(fullyQualifiedTypeName, _namedTypes)) {
      if (!equals(_namedTypes[fullyQualifiedTypeName], schema)) {
        throw new InvalidSchemaError(`conflicting definitions for type ${fullyQualifiedTypeName}: ${JSON.stringify(_namedTypes[fullyQualifiedTypeName])} and ${JSON.stringify(schema)}`);
      }
    } else {
      _namedTypes[fullyQualifiedTypeName] = schema;
    }
  };

  const _lookupTypeByFullyQualifiedName = function (fullyQualifiedTypeName) {
    if (has(fullyQualifiedTypeName, _namedTypes)) {
      return _namedTypes[fullyQualifiedTypeName];
    }
    return null;
  };

  const _parseNamedType = function (schema, namespace) {
    if (contains(schema, AvroSpec.PrimitiveTypes)) {
      return new Primitive(schema);
    } else if (!isNull(_lookupTypeByFullyQualifiedName(makeFullyQualifiedTypeName(schema, namespace)))) {
      return _lookupTypeByFullyQualifiedName(makeFullyQualifiedTypeName(schema, namespace));
    }
    throw new InvalidSchemaError(`unknown type name: ${JSON.stringify(schema)}; known type names are ${JSON.stringify(Object.keys(_namedTypes))}`);
  };

  var _parseSchema = function (schema, parentSchema, namespace) {
    if (isNull(schema) || isUndefined(schema)) {
      throw new InvalidSchemaError(`schema is null, in parentSchema: ${JSON.stringify(parentSchema)}`);
    } else if (isString(schema)) {
      return _parseNamedType(schema, namespace);
    } else if (isObject(schema)) {
      if (schema.type === "record") {
        const newRecord = new Record(schema.name, schema.namespace, schema.fields.map(function (field) {
          return new Field(field.name, _parseSchema(field.type, schema, schema.namespace || namespace));
        }), schema.type);
        _saveNamedType(makeFullyQualifiedTypeName(schema, namespace), newRecord);
        return newRecord;
      } else if (schema.type === "enum") {
        if (has("symbols", schema)) {
          const newEnum = new Enum(schema.symbols, schema.type);
          _saveNamedType(makeFullyQualifiedTypeName(schema, namespace), newEnum);
          return newEnum;
        }
        throw new InvalidSchemaError(`enum must specify symbols, got ${JSON.stringify(schema)}`);
      } else if (schema.type === "array") {
        if (has("items", schema)) {
          return new AvroArray(_parseSchema(schema.items, schema, namespace), schema.type);
        }
        throw new InvalidSchemaError(`array must specify "items" schema, got ${JSON.stringify(schema)}`);
      } else if (schema.type === "map") {
        if (has("values", schema)) {
          return new Map(_parseSchema(schema.values, schema, namespace), schema.type);
        }
        throw new InvalidSchemaError(`map must specify "values" schema, got ${JSON.stringify(schema)}`);
      } else if (has("type", schema) && contains(schema.type, AvroSpec.PrimitiveTypes)) {
        return _parseNamedType(schema.type, namespace);
      } else {
        throw new InvalidSchemaError(`not yet implemented: ${schema.type}`);
      }
    } else if (Array.isArray(schema)) {
      if (!schema.length) {
        throw new InvalidSchemaError("unions must have at least 1 branch");
      }
      const branchTypes = schema.map(function (branchType) {
        return _parseSchema(branchType, schema, namespace);
      });
      return new Union(branchTypes, namespace, "union");
    } else {
      throw new InvalidSchemaError(`unexpected Javascript type for schema: ${typeof schema}`);
    }
  };

  this.rawSchema = schema;
  this.schema = _parseSchema(schema, null, namespace);
}

Validator.validate = function (schema, obj) {
  return new Validator(schema).validate(obj);
};

function ProtocolValidator(protocol) {
  this.validate = function (typeName, obj) {
    const fullyQualifiedTypeName = makeFullyQualifiedTypeName(typeName, protocol.namespace);
    if (!has(fullyQualifiedTypeName, _typeSchemaValidators)) {
      throw new ProtocolValidationError(`Protocol does not contain definition for type ${JSON.stringify(fullyQualifiedTypeName)} (fully qualified from input "${typeName}"); known types are ${JSON.stringify(Object.keys(_typeSchemaValidators))}`);
    }
    return _typeSchemaValidators[fullyQualifiedTypeName].validate(obj);
  };

  var _typeSchemaValidators = {};
  const _initSchemaValidators = function (protocol) {
    const namedTypes = {};
    if (!has("protocol", protocol) || !isString(protocol.protocol)) {
      throw new InvalidProtocolError('Protocol must contain a "protocol" attribute with a string value');
    }
    if (Array.isArray(protocol.types)) {
      protocol.types.forEach(function (typeSchema) {
        const schemaValidator = new Validator(typeSchema, protocol.namespace, namedTypes);
        const fullyQualifiedTypeName = makeFullyQualifiedTypeName(typeSchema, protocol.namespace);
        _typeSchemaValidators[fullyQualifiedTypeName] = schemaValidator;
      });
    }
  };

  _initSchemaValidators(protocol);
}

ProtocolValidator.validate = function (protocol, typeName, obj) {
  return new ProtocolValidator(protocol).validate(typeName, obj);
};

if (typeof exports !== "undefined") {
  exports.Validator = Validator;
  exports.ProtocolValidator = ProtocolValidator;
}

},{"ramda/src/all":497,"ramda/src/contains":498,"ramda/src/equals":499,"ramda/src/has":500,"ramda/src/pluck":520,"ramda/src/type":522}]},{},[24]);
